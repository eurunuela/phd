import {
  color,
  format,
  init_src,
  init_src2
} from "/build/_shared/chunk-WYS2FUD5.js";
import {
  SourceFileKind,
  credit,
  orcid
} from "/build/_shared/chunk-TDUKKLNI.js";
import {
  defined,
  doi,
  filterKeys,
  incrementOptions,
  validateBoolean,
  validateChoice,
  validateDate,
  validateEmail,
  validateEnum,
  validateKeys,
  validateList,
  validateNumber,
  validateNumbering,
  validateObject,
  validateObjectKeys,
  validateString,
  validateUrl,
  validationError,
  validationWarning
} from "/build/_shared/chunk-XIVVYPNM.js";
import {
  Panel,
  PanelLayout,
  Printing,
  Sanitizer,
  Signal,
  TabBar,
  Widget,
  WidgetTracker,
  __assign,
  __awaiter,
  __rest,
  __spreadArray,
  _arrayLikeToArray,
  _defineProperty,
  _extends,
  _toPropertyKey,
  _typeof,
  _unsupportedIterableToArray,
  index_es6_exports,
  index_es6_exports2,
  index_es6_exports3,
  init_arrayLikeToArray,
  init_defineProperty,
  init_extends,
  init_index_es6,
  init_index_es62,
  init_index_es63,
  init_index_es64,
  init_lib,
  init_lib4 as init_lib2,
  init_toPropertyKey,
  init_tslib_es6,
  init_typeof,
  init_unsupportedIterableToArray,
  nullTranslator,
  require_cjs,
  require_dist,
  require_isEqual,
  require_is_plain_object,
  require_jsx_runtime,
  require_lib,
  require_minimist,
  require_parse_srcset,
  require_postcss,
  require_url_parse,
  tslib_es6_exports
} from "/build/_shared/chunk-VQ44ZQQP.js";
import {
  ArrayExt,
  MessageLoop,
  Platform,
  each,
  init_index_es6 as init_index_es65,
  init_index_es62 as init_index_es66,
  init_index_es63 as init_index_es67
} from "/build/_shared/chunk-KAB4N37T.js";
import {
  require_classnames
} from "/build/_shared/chunk-XJ2I6HXP.js";
import {
  VFile
} from "/build/_shared/chunk-44FAGZWP.js";
import {
  RuleId,
  copyNode,
  extractPart,
  fileError,
  select,
  selectAll
} from "/build/_shared/chunk-DXW3BAL6.js";
import {
  EXIT,
  SKIP,
  visit
} from "/build/_shared/chunk-63RQRREX.js";
import {
  Link,
  Links,
  LiveReload,
  Meta,
  NavLink,
  Scripts,
  ScrollRestoration,
  useLocation,
  useNavigation
} from "/build/_shared/chunk-Q2QM3PSE.js";
import {
  require_client,
  require_react_dom
} from "/build/_shared/chunk-EO2YHY6V.js";
import {
  require_jsx_dev_runtime
} from "/build/_shared/chunk-BR5CJPZL.js";
import {
  require_react
} from "/build/_shared/chunk-IFNAVDNZ.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "/build/_shared/chunk-D5NAPBYJ.js";

// ../../node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "../../node_modules/@babel/runtime/helpers/typeof.js"(exports2, module2) {
    function _typeof2(o10) {
      "@babel/helpers - typeof";
      return module2.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o11) {
        return typeof o11;
      } : function(o11) {
        return o11 && "function" == typeof Symbol && o11.constructor === Symbol && o11 !== Symbol.prototype ? "symbol" : typeof o11;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof2(o10);
    }
    module2.exports = _typeof2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "../../node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports2, module2) {
    var _typeof2 = require_typeof()["default"];
    function _regeneratorRuntime3() {
      "use strict";
      module2.exports = _regeneratorRuntime3 = function _regeneratorRuntime4() {
        return e4;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      var t10, e4 = {}, r4 = Object.prototype, n4 = r4.hasOwnProperty, o10 = Object.defineProperty || function(t11, e5, r5) {
        t11[e5] = r5.value;
      }, i5 = "function" == typeof Symbol ? Symbol : {}, a4 = i5.iterator || "@@iterator", c6 = i5.asyncIterator || "@@asyncIterator", u4 = i5.toStringTag || "@@toStringTag";
      function define2(t11, e5, r5) {
        return Object.defineProperty(t11, e5, {
          value: r5,
          enumerable: true,
          configurable: true,
          writable: true
        }), t11[e5];
      }
      try {
        define2({}, "");
      } catch (t11) {
        define2 = function define3(t12, e5, r5) {
          return t12[e5] = r5;
        };
      }
      function wrap2(t11, e5, r5, n5) {
        var i6 = e5 && e5.prototype instanceof Generator ? e5 : Generator, a5 = Object.create(i6.prototype), c7 = new Context2(n5 || []);
        return o10(a5, "_invoke", {
          value: makeInvokeMethod(t11, r5, c7)
        }), a5;
      }
      function tryCatch(t11, e5, r5) {
        try {
          return {
            type: "normal",
            arg: t11.call(e5, r5)
          };
        } catch (t12) {
          return {
            type: "throw",
            arg: t12
          };
        }
      }
      e4.wrap = wrap2;
      var h4 = "suspendedStart", l7 = "suspendedYield", f6 = "executing", s7 = "completed", y3 = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p3 = {};
      define2(p3, a4, function() {
        return this;
      });
      var d6 = Object.getPrototypeOf, v2 = d6 && d6(d6(values2([])));
      v2 && v2 !== r4 && n4.call(v2, a4) && (p3 = v2);
      var g4 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p3);
      function defineIteratorMethods(t11) {
        ["next", "throw", "return"].forEach(function(e5) {
          define2(t11, e5, function(t12) {
            return this._invoke(e5, t12);
          });
        });
      }
      function AsyncIterator(t11, e5) {
        function invoke(r6, o11, i6, a5) {
          var c7 = tryCatch(t11[r6], t11, o11);
          if ("throw" !== c7.type) {
            var u5 = c7.arg, h5 = u5.value;
            return h5 && "object" == _typeof2(h5) && n4.call(h5, "__await") ? e5.resolve(h5.__await).then(function(t12) {
              invoke("next", t12, i6, a5);
            }, function(t12) {
              invoke("throw", t12, i6, a5);
            }) : e5.resolve(h5).then(function(t12) {
              u5.value = t12, i6(u5);
            }, function(t12) {
              return invoke("throw", t12, i6, a5);
            });
          }
          a5(c7.arg);
        }
        var r5;
        o10(this, "_invoke", {
          value: function value(t12, n5) {
            function callInvokeWithMethodAndArg() {
              return new e5(function(e6, r6) {
                invoke(t12, n5, e6, r6);
              });
            }
            return r5 = r5 ? r5.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(e5, r5, n5) {
        var o11 = h4;
        return function(i6, a5) {
          if (o11 === f6)
            throw new Error("Generator is already running");
          if (o11 === s7) {
            if ("throw" === i6)
              throw a5;
            return {
              value: t10,
              done: true
            };
          }
          for (n5.method = i6, n5.arg = a5; ; ) {
            var c7 = n5.delegate;
            if (c7) {
              var u5 = maybeInvokeDelegate(c7, n5);
              if (u5) {
                if (u5 === y3)
                  continue;
                return u5;
              }
            }
            if ("next" === n5.method)
              n5.sent = n5._sent = n5.arg;
            else if ("throw" === n5.method) {
              if (o11 === h4)
                throw o11 = s7, n5.arg;
              n5.dispatchException(n5.arg);
            } else
              "return" === n5.method && n5.abrupt("return", n5.arg);
            o11 = f6;
            var p4 = tryCatch(e5, r5, n5);
            if ("normal" === p4.type) {
              if (o11 = n5.done ? s7 : l7, p4.arg === y3)
                continue;
              return {
                value: p4.arg,
                done: n5.done
              };
            }
            "throw" === p4.type && (o11 = s7, n5.method = "throw", n5.arg = p4.arg);
          }
        };
      }
      function maybeInvokeDelegate(e5, r5) {
        var n5 = r5.method, o11 = e5.iterator[n5];
        if (o11 === t10)
          return r5.delegate = null, "throw" === n5 && e5.iterator["return"] && (r5.method = "return", r5.arg = t10, maybeInvokeDelegate(e5, r5), "throw" === r5.method) || "return" !== n5 && (r5.method = "throw", r5.arg = new TypeError("The iterator does not provide a '" + n5 + "' method")), y3;
        var i6 = tryCatch(o11, e5.iterator, r5.arg);
        if ("throw" === i6.type)
          return r5.method = "throw", r5.arg = i6.arg, r5.delegate = null, y3;
        var a5 = i6.arg;
        return a5 ? a5.done ? (r5[e5.resultName] = a5.value, r5.next = e5.nextLoc, "return" !== r5.method && (r5.method = "next", r5.arg = t10), r5.delegate = null, y3) : a5 : (r5.method = "throw", r5.arg = new TypeError("iterator result is not an object"), r5.delegate = null, y3);
      }
      function pushTryEntry(t11) {
        var e5 = {
          tryLoc: t11[0]
        };
        1 in t11 && (e5.catchLoc = t11[1]), 2 in t11 && (e5.finallyLoc = t11[2], e5.afterLoc = t11[3]), this.tryEntries.push(e5);
      }
      function resetTryEntry(t11) {
        var e5 = t11.completion || {};
        e5.type = "normal", delete e5.arg, t11.completion = e5;
      }
      function Context2(t11) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t11.forEach(pushTryEntry, this), this.reset(true);
      }
      function values2(e5) {
        if (e5 || "" === e5) {
          var r5 = e5[a4];
          if (r5)
            return r5.call(e5);
          if ("function" == typeof e5.next)
            return e5;
          if (!isNaN(e5.length)) {
            var o11 = -1, i6 = function next() {
              for (; ++o11 < e5.length; )
                if (n4.call(e5, o11))
                  return next.value = e5[o11], next.done = false, next;
              return next.value = t10, next.done = true, next;
            };
            return i6.next = i6;
          }
        }
        throw new TypeError(_typeof2(e5) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o10(g4, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o10(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u4, "GeneratorFunction"), e4.isGeneratorFunction = function(t11) {
        var e5 = "function" == typeof t11 && t11.constructor;
        return !!e5 && (e5 === GeneratorFunction || "GeneratorFunction" === (e5.displayName || e5.name));
      }, e4.mark = function(t11) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t11, GeneratorFunctionPrototype) : (t11.__proto__ = GeneratorFunctionPrototype, define2(t11, u4, "GeneratorFunction")), t11.prototype = Object.create(g4), t11;
      }, e4.awrap = function(t11) {
        return {
          __await: t11
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c6, function() {
        return this;
      }), e4.AsyncIterator = AsyncIterator, e4.async = function(t11, r5, n5, o11, i6) {
        void 0 === i6 && (i6 = Promise);
        var a5 = new AsyncIterator(wrap2(t11, r5, n5, o11), i6);
        return e4.isGeneratorFunction(r5) ? a5 : a5.next().then(function(t12) {
          return t12.done ? t12.value : a5.next();
        });
      }, defineIteratorMethods(g4), define2(g4, u4, "Generator"), define2(g4, a4, function() {
        return this;
      }), define2(g4, "toString", function() {
        return "[object Generator]";
      }), e4.keys = function(t11) {
        var e5 = Object(t11), r5 = [];
        for (var n5 in e5)
          r5.push(n5);
        return r5.reverse(), function next() {
          for (; r5.length; ) {
            var t12 = r5.pop();
            if (t12 in e5)
              return next.value = t12, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e4.values = values2, Context2.prototype = {
        constructor: Context2,
        reset: function reset(e5) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t10, this.done = false, this.delegate = null, this.method = "next", this.arg = t10, this.tryEntries.forEach(resetTryEntry), !e5)
            for (var r5 in this)
              "t" === r5.charAt(0) && n4.call(this, r5) && !isNaN(+r5.slice(1)) && (this[r5] = t10);
        },
        stop: function stop() {
          this.done = true;
          var t11 = this.tryEntries[0].completion;
          if ("throw" === t11.type)
            throw t11.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(e5) {
          if (this.done)
            throw e5;
          var r5 = this;
          function handle(n5, o12) {
            return a5.type = "throw", a5.arg = e5, r5.next = n5, o12 && (r5.method = "next", r5.arg = t10), !!o12;
          }
          for (var o11 = this.tryEntries.length - 1; o11 >= 0; --o11) {
            var i6 = this.tryEntries[o11], a5 = i6.completion;
            if ("root" === i6.tryLoc)
              return handle("end");
            if (i6.tryLoc <= this.prev) {
              var c7 = n4.call(i6, "catchLoc"), u5 = n4.call(i6, "finallyLoc");
              if (c7 && u5) {
                if (this.prev < i6.catchLoc)
                  return handle(i6.catchLoc, true);
                if (this.prev < i6.finallyLoc)
                  return handle(i6.finallyLoc);
              } else if (c7) {
                if (this.prev < i6.catchLoc)
                  return handle(i6.catchLoc, true);
              } else {
                if (!u5)
                  throw new Error("try statement without catch or finally");
                if (this.prev < i6.finallyLoc)
                  return handle(i6.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(t11, e5) {
          for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
            var o11 = this.tryEntries[r5];
            if (o11.tryLoc <= this.prev && n4.call(o11, "finallyLoc") && this.prev < o11.finallyLoc) {
              var i6 = o11;
              break;
            }
          }
          i6 && ("break" === t11 || "continue" === t11) && i6.tryLoc <= e5 && e5 <= i6.finallyLoc && (i6 = null);
          var a5 = i6 ? i6.completion : {};
          return a5.type = t11, a5.arg = e5, i6 ? (this.method = "next", this.next = i6.finallyLoc, y3) : this.complete(a5);
        },
        complete: function complete(t11, e5) {
          if ("throw" === t11.type)
            throw t11.arg;
          return "break" === t11.type || "continue" === t11.type ? this.next = t11.arg : "return" === t11.type ? (this.rval = this.arg = t11.arg, this.method = "return", this.next = "end") : "normal" === t11.type && e5 && (this.next = e5), y3;
        },
        finish: function finish(t11) {
          for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
            var r5 = this.tryEntries[e5];
            if (r5.finallyLoc === t11)
              return this.complete(r5.completion, r5.afterLoc), resetTryEntry(r5), y3;
          }
        },
        "catch": function _catch(t11) {
          for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
            var r5 = this.tryEntries[e5];
            if (r5.tryLoc === t11) {
              var n5 = r5.completion;
              if ("throw" === n5.type) {
                var o11 = n5.arg;
                resetTryEntry(r5);
              }
              return o11;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e5, r5, n5) {
          return this.delegate = {
            iterator: values2(e5),
            resultName: r5,
            nextLoc: n5
          }, "next" === this.method && (this.arg = t10), y3;
        }
      }, e4;
    }
    module2.exports = _regeneratorRuntime3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "../../node_modules/@babel/runtime/regenerator/index.js"(exports2, module2) {
    var runtime = require_regeneratorRuntime()();
    module2.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React79 = require_react();
        var ReactSharedInternals = React79.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format2) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format2, args);
            }
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is2(x4, y3) {
          return x4 === y3 && (x4 !== 0 || 1 / x4 === 1 / y3) || x4 !== x4 && y3 !== y3;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is2;
        var useState24 = React79.useState, useEffect24 = React79.useEffect, useLayoutEffect4 = React79.useLayoutEffect, useDebugValue2 = React79.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React79.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState24({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect4(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect24(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue2(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore2;
        var useSyncExternalStore$2 = React79.useSyncExternalStore !== void 0 ? React79.useSyncExternalStore : shim;
        exports2.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// ../../node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "../../node_modules/use-sync-external-store/shim/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// ../../node_modules/thebe-react/dist/OutputAreaByRef.js
var require_OutputAreaByRef = __commonJS({
  "../../node_modules/thebe-react/dist/OutputAreaByRef.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OutputAreaByRef = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importDefault(require_react());
    exports2.OutputAreaByRef = react_1.default.forwardRef(({ busy, content }, ref) => {
      return (0, jsx_runtime_1.jsx)("div", { children: (0, jsx_runtime_1.jsxs)("div", Object.assign({ className: "m-1 hover:delay-15" }, { children: [(0, jsx_runtime_1.jsx)("div", Object.assign({ className: "p-1 rounded", ref }, { children: content ? content : "[Output Area]" })), busy && (0, jsx_runtime_1.jsx)("div", { children: "Cell is running..." })] })) });
    });
  }
});

// ../../node_modules/thebe-core/dist/esm/url.js
function makeDefaultStorageKey(storagePrefix, url) {
  const urlObj = new URL(url);
  return `${storagePrefix}-${urlObj.origin + urlObj.pathname}`;
}
function makeDefaultBuildSpec(storagePrefix, binderUrl, stub) {
  const build = `${binderUrl}/build/${stub}`;
  const launch = `${binderUrl}/v2/${stub}`;
  return {
    build,
    launch,
    storageKey: makeDefaultStorageKey(storagePrefix, build)
  };
}
function makeGitUrls(config) {
  if (!config.binder.repo)
    throw Error("repo is required for git provider");
  const { repo, binderUrl, ref } = config.binder;
  const encodedRepo = encodeURIComponent(repo.replace(/(^\/)|(\/?$)/g, ""));
  const base = binderUrl === null || binderUrl === void 0 ? void 0 : binderUrl.replace(/(\/?$)/g, "");
  const stub = `git/${encodedRepo}/${ref !== null && ref !== void 0 ? ref : "HEAD"}`;
  return makeDefaultBuildSpec(config.savedSessions.storagePrefix, base, stub);
}
function makeGitLabUrl(config) {
  var _a, _b, _c;
  if (!config.binder.repo)
    throw Error("repo is required for gitlab provider");
  const binderUrl = (_a = config.binder.binderUrl) === null || _a === void 0 ? void 0 : _a.replace(/(\/?$)/g, "");
  const repo = encodeURIComponent(((_b = config.binder.repo) !== null && _b !== void 0 ? _b : "").replace(/^(https?:\/\/)?gitlab.com\//, "").replace(/(^\/)|(\/?$)/g, ""));
  const stub = `gl/${repo}/${(_c = config.binder.ref) !== null && _c !== void 0 ? _c : "HEAD"}`;
  return makeDefaultBuildSpec(config.savedSessions.storagePrefix, binderUrl, stub);
}
function makeGitHubUrl(config) {
  var _a, _b;
  if (!config.binder.repo)
    throw Error("repo is required for github provider");
  const repo = config.binder.repo.replace(/^(https?:\/\/)?github.com\//, "").replace(/(^\/)|(\/?$)/g, "");
  const binderUrl = (_a = config.binder.binderUrl) === null || _a === void 0 ? void 0 : _a.replace(/(\/?$)/g, "");
  const stub = `gh/${repo}/${(_b = config.binder.ref) !== null && _b !== void 0 ? _b : "HEAD"}`;
  return makeDefaultBuildSpec(config.savedSessions.storagePrefix, binderUrl, stub);
}
function makeGistUrl(config) {
  var _a, _b;
  if (!config.binder.repo)
    throw Error("repo is required for gist provider");
  const repo = config.binder.repo.replace(/^(https?:\/\/)?github.com\//, "").replace(/(^\/)|(\/?$)/g, "");
  const binderUrl = (_a = config.binder.binderUrl) === null || _a === void 0 ? void 0 : _a.replace(/(\/?$)/g, "");
  const stub = `gist/${repo}/${(_b = config.binder.ref) !== null && _b !== void 0 ? _b : "HEAD"}`;
  return makeDefaultBuildSpec(config.savedSessions.storagePrefix, binderUrl, stub);
}
function makeBinderUrls(config, repoProviders) {
  var _a, _b;
  const providerMap = (_a = repoProviders.reduce((obj, spec) => Object.assign(Object.assign({}, obj), { [spec.name]: spec }), {})) !== null && _a !== void 0 ? _a : {};
  const provider = (_b = config.binder.repoProvider) !== null && _b !== void 0 ? _b : "github";
  if (!Object.keys(providerMap).includes(provider))
    throw Error(`Unknown provider ${config.binder.repoProvider}`);
  if (!providerMap[provider].makeUrls)
    throw Error(`No makeUrls function for ${provider}`);
  return providerMap[provider].makeUrls(config);
}
var GITHUB_SPEC, GITLAB_SPEC, GIT_SPEC, GIST_SPEC, WELL_KNOWN_REPO_PROVIDERS;
var init_url = __esm({
  "../../node_modules/thebe-core/dist/esm/url.js"() {
    GITHUB_SPEC = {
      name: "github",
      makeUrls: makeGitHubUrl
    };
    GITLAB_SPEC = {
      name: "gitlab",
      makeUrls: makeGitLabUrl
    };
    GIT_SPEC = {
      name: "git",
      makeUrls: makeGitUrls
    };
    GIST_SPEC = {
      name: "gist",
      makeUrls: makeGistUrl
    };
    WELL_KNOWN_REPO_PROVIDERS = [GITHUB_SPEC, GITLAB_SPEC, GIT_SPEC, GIST_SPEC];
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/activitymonitor.js
var require_activitymonitor = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/activitymonitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActivityMonitor = void 0;
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var ActivityMonitor = class {
      /**
       * Construct a new activity monitor.
       */
      constructor(options) {
        this._timer = -1;
        this._timeout = -1;
        this._isDisposed = false;
        this._activityStopped = new signaling_1.Signal(this);
        options.signal.connect(this._onSignalFired, this);
        this._timeout = options.timeout || 1e3;
      }
      /**
       * A signal emitted when activity has ceased.
       */
      get activityStopped() {
        return this._activityStopped;
      }
      /**
       * The timeout associated with the monitor, in milliseconds.
       */
      get timeout() {
        return this._timeout;
      }
      set timeout(value) {
        this._timeout = value;
      }
      /**
       * Test whether the monitor has been disposed.
       *
       * #### Notes
       * This is a read-only property.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the activity monitor.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * A signal handler for the monitored signal.
       */
      _onSignalFired(sender, args) {
        clearTimeout(this._timer);
        this._sender = sender;
        this._args = args;
        this._timer = setTimeout(() => {
          this._activityStopped.emit({
            sender: this._sender,
            args: this._args
          });
        }, this._timeout);
      }
    };
    exports2.ActivityMonitor = ActivityMonitor;
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/interfaces.js
var require_interfaces = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js
var require_markdowncodeblocks = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MarkdownCodeBlocks = void 0;
    var MarkdownCodeBlocks;
    (function(MarkdownCodeBlocks2) {
      MarkdownCodeBlocks2.CODE_BLOCK_MARKER = "```";
      const markdownExtensions = [
        ".markdown",
        ".mdown",
        ".mkdn",
        ".md",
        ".mkd",
        ".mdwn",
        ".mdtxt",
        ".mdtext",
        ".text",
        ".txt",
        ".Rmd"
      ];
      class MarkdownCodeBlock {
        constructor(startLine) {
          this.startLine = startLine;
          this.code = "";
          this.endLine = -1;
        }
      }
      MarkdownCodeBlocks2.MarkdownCodeBlock = MarkdownCodeBlock;
      function isMarkdown(extension2) {
        return markdownExtensions.indexOf(extension2) > -1;
      }
      MarkdownCodeBlocks2.isMarkdown = isMarkdown;
      function findMarkdownCodeBlocks(text) {
        if (!text || text === "") {
          return [];
        }
        const lines = text.split("\n");
        const codeBlocks = [];
        let currentBlock = null;
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
          const line = lines[lineIndex];
          const lineContainsMarker = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER) === 0;
          const constructingBlock = currentBlock != null;
          if (!lineContainsMarker && !constructingBlock) {
            continue;
          }
          if (!constructingBlock) {
            currentBlock = new MarkdownCodeBlock(lineIndex);
            const firstIndex = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const lastIndex = line.lastIndexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const isSingleLine = firstIndex !== lastIndex;
            if (isSingleLine) {
              currentBlock.code = line.substring(firstIndex + MarkdownCodeBlocks2.CODE_BLOCK_MARKER.length, lastIndex);
              currentBlock.endLine = lineIndex;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            }
          } else if (currentBlock) {
            if (lineContainsMarker) {
              currentBlock.endLine = lineIndex - 1;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            } else {
              currentBlock.code += line + "\n";
            }
          }
        }
        return codeBlocks;
      }
      MarkdownCodeBlocks2.findMarkdownCodeBlocks = findMarkdownCodeBlocks;
    })(MarkdownCodeBlocks = exports2.MarkdownCodeBlocks || (exports2.MarkdownCodeBlocks = {}));
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/url.js
var require_url = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/url.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLExt = void 0;
    var path_1 = __require("path");
    var url_parse_1 = __importDefault2(require_url_parse());
    var URLExt3;
    (function(URLExt4) {
      function parse4(url) {
        if (typeof document !== "undefined" && document) {
          const a4 = document.createElement("a");
          a4.href = url;
          return a4;
        }
        return (0, url_parse_1.default)(url);
      }
      URLExt4.parse = parse4;
      function getHostName(url) {
        return (0, url_parse_1.default)(url).hostname;
      }
      URLExt4.getHostName = getHostName;
      function normalize2(url) {
        return url && parse4(url).toString();
      }
      URLExt4.normalize = normalize2;
      function join(...parts) {
        let u4 = (0, url_parse_1.default)(parts[0], {});
        const isSchemaLess = u4.protocol === "" && u4.slashes;
        if (isSchemaLess) {
          u4 = (0, url_parse_1.default)(parts[0], "https:" + parts[0]);
        }
        const prefix = `${isSchemaLess ? "" : u4.protocol}${u4.slashes ? "//" : ""}${u4.auth}${u4.auth ? "@" : ""}${u4.host}`;
        const path2 = path_1.posix.join(`${!!prefix && u4.pathname[0] !== "/" ? "/" : ""}${u4.pathname}`, ...parts.slice(1));
        return `${prefix}${path2 === "." ? "" : path2}`;
      }
      URLExt4.join = join;
      function encodeParts(url) {
        return join(...url.split("/").map(encodeURIComponent));
      }
      URLExt4.encodeParts = encodeParts;
      function objectToQueryString(value) {
        const keys2 = Object.keys(value).filter((key) => key.length > 0);
        if (!keys2.length) {
          return "";
        }
        return "?" + keys2.map((key) => {
          const content = encodeURIComponent(String(value[key]));
          return key + (content ? "=" + content : "");
        }).join("&");
      }
      URLExt4.objectToQueryString = objectToQueryString;
      function queryStringToObject(value) {
        return value.replace(/^\?/, "").split("&").reduce((acc, val) => {
          const [key, value2] = val.split("=");
          if (key.length > 0) {
            acc[key] = decodeURIComponent(value2 || "");
          }
          return acc;
        }, {});
      }
      URLExt4.queryStringToObject = queryStringToObject;
      function isLocal(url) {
        const { protocol } = parse4(url);
        return (!protocol || url.toLowerCase().indexOf(protocol) !== 0) && url.indexOf("/") !== 0;
      }
      URLExt4.isLocal = isLocal;
    })(URLExt3 = exports2.URLExt || (exports2.URLExt = {}));
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/pageconfig.js
var require_pageconfig = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/pageconfig.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageConfig = void 0;
    var coreutils_1 = require_dist();
    var minimist_1 = __importDefault(require_minimist());
    var url_1 = require_url();
    var PageConfig;
    (function(PageConfig) {
      function getOption(name) {
        if (configData) {
          return configData[name] || getBodyData(name);
        }
        configData = /* @__PURE__ */ Object.create(null);
        let found = false;
        if (typeof document !== "undefined" && document) {
          const el = document.getElementById("jupyter-config-data");
          if (el) {
            configData = JSON.parse(el.textContent || "");
            found = true;
          }
        }
        if (!found && typeof process !== "undefined" && process.argv) {
          try {
            const cli = (0, minimist_1.default)(process.argv.slice(2));
            const path = __require("path");
            let fullPath = "";
            if ("jupyter-config-data" in cli) {
              fullPath = path.resolve(cli["jupyter-config-data"]);
            } else if ("JUPYTER_CONFIG_DATA" in process.env) {
              fullPath = path.resolve(process.env["JUPYTER_CONFIG_DATA"]);
            }
            if (fullPath) {
              configData = eval("require")(fullPath);
            }
          } catch (e4) {
            console.error(e4);
          }
        }
        if (!coreutils_1.JSONExt.isObject(configData)) {
          configData = /* @__PURE__ */ Object.create(null);
        } else {
          for (const key in configData) {
            if (typeof configData[key] !== "string") {
              configData[key] = JSON.stringify(configData[key]);
            }
          }
        }
        return configData[name] || getBodyData(name);
      }
      PageConfig.getOption = getOption;
      function setOption(name2, value) {
        const last2 = getOption(name2);
        configData[name2] = value;
        return last2;
      }
      PageConfig.setOption = setOption;
      function getBaseUrl() {
        return url_1.URLExt.normalize(getOption("baseUrl") || "/");
      }
      PageConfig.getBaseUrl = getBaseUrl;
      function getTreeUrl() {
        return url_1.URLExt.join(getBaseUrl(), getOption("treeUrl"));
      }
      PageConfig.getTreeUrl = getTreeUrl;
      function getShareUrl() {
        return url_1.URLExt.normalize(getOption("shareUrl") || getBaseUrl());
      }
      PageConfig.getShareUrl = getShareUrl;
      function getTreeShareUrl() {
        return url_1.URLExt.normalize(url_1.URLExt.join(getShareUrl(), getOption("treeUrl")));
      }
      PageConfig.getTreeShareUrl = getTreeShareUrl;
      function getUrl(options) {
        var _a, _b, _c, _d;
        let path2 = options.toShare ? getShareUrl() : getBaseUrl();
        const mode = (_a = options.mode) !== null && _a !== void 0 ? _a : getOption("mode");
        const workspace = (_b = options.workspace) !== null && _b !== void 0 ? _b : getOption("workspace");
        const labOrDoc = mode === "single-document" ? "doc" : "lab";
        path2 = url_1.URLExt.join(path2, labOrDoc);
        if (workspace !== PageConfig.defaultWorkspace) {
          path2 = url_1.URLExt.join(path2, "workspaces", encodeURIComponent((_c = getOption("workspace")) !== null && _c !== void 0 ? _c : PageConfig.defaultWorkspace));
        }
        const treePath = (_d = options.treePath) !== null && _d !== void 0 ? _d : getOption("treePath");
        if (treePath) {
          path2 = url_1.URLExt.join(path2, "tree", url_1.URLExt.encodeParts(treePath));
        }
        return path2;
      }
      PageConfig.getUrl = getUrl;
      PageConfig.defaultWorkspace = "default";
      function getWsUrl(baseUrl) {
        let wsUrl = getOption("wsUrl");
        if (!wsUrl) {
          baseUrl = baseUrl ? url_1.URLExt.normalize(baseUrl) : getBaseUrl();
          if (baseUrl.indexOf("http") !== 0) {
            return "";
          }
          wsUrl = "ws" + baseUrl.slice(4);
        }
        return url_1.URLExt.normalize(wsUrl);
      }
      PageConfig.getWsUrl = getWsUrl;
      function getNBConvertURL({ path: path2, format: format2, download }) {
        const notebookPath = url_1.URLExt.encodeParts(path2);
        const url = url_1.URLExt.join(getBaseUrl(), "nbconvert", format2, notebookPath);
        if (download) {
          return url + "?download=true";
        }
        return url;
      }
      PageConfig.getNBConvertURL = getNBConvertURL;
      function getToken() {
        return getOption("token") || getBodyData("jupyterApiToken");
      }
      PageConfig.getToken = getToken;
      function getNotebookVersion() {
        const notebookVersion = getOption("notebookVersion");
        if (notebookVersion === "") {
          return [0, 0, 0];
        }
        return JSON.parse(notebookVersion);
      }
      PageConfig.getNotebookVersion = getNotebookVersion;
      let configData = null;
      function getBodyData(key) {
        if (typeof document === "undefined" || !document.body) {
          return "";
        }
        const val = document.body.dataset[key];
        if (typeof val === "undefined") {
          return "";
        }
        return decodeURIComponent(val);
      }
      let Extension;
      (function(Extension2) {
        function populate(key) {
          try {
            const raw = getOption(key);
            if (raw) {
              return JSON.parse(raw);
            }
          } catch (error) {
            console.warn(`Unable to parse ${key}.`, error);
          }
          return [];
        }
        Extension2.deferred = populate("deferredExtensions");
        Extension2.disabled = populate("disabledExtensions");
        function isDeferred(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.deferred.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDeferred = isDeferred;
        function isDisabled(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.disabled.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDisabled = isDisabled;
      })(Extension = PageConfig.Extension || (PageConfig.Extension = {}));
    })(PageConfig = exports.PageConfig || (exports.PageConfig = {}));
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/path.js
var require_path = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathExt = void 0;
    var path_1 = __require("path");
    var PathExt2;
    (function(PathExt3) {
      function join(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : removeSlash(path2);
      }
      PathExt3.join = join;
      function basename(path2, ext) {
        return path_1.posix.basename(path2, ext);
      }
      PathExt3.basename = basename;
      function dirname(path2) {
        const dir = removeSlash(path_1.posix.dirname(path2));
        return dir === "." ? "" : dir;
      }
      PathExt3.dirname = dirname;
      function extname(path2) {
        return path_1.posix.extname(path2);
      }
      PathExt3.extname = extname;
      function normalize2(path2) {
        if (path2 === "") {
          return "";
        }
        return removeSlash(path_1.posix.normalize(path2));
      }
      PathExt3.normalize = normalize2;
      function resolve(...parts) {
        return removeSlash(path_1.posix.resolve(...parts));
      }
      PathExt3.resolve = resolve;
      function relative(from, to) {
        return removeSlash(path_1.posix.relative(from, to));
      }
      PathExt3.relative = relative;
      function normalizeExtension(extension2) {
        if (extension2.length > 0 && extension2.indexOf(".") !== 0) {
          extension2 = `.${extension2}`;
        }
        return extension2;
      }
      PathExt3.normalizeExtension = normalizeExtension;
      function removeSlash(path2) {
        if (path2.indexOf("/") === 0) {
          path2 = path2.slice(1);
        }
        return path2;
      }
      PathExt3.removeSlash = removeSlash;
    })(PathExt2 = exports2.PathExt || (exports2.PathExt = {}));
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/signal.js
var require_signal = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/signal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signalToPromise = void 0;
    var coreutils_12 = require_dist();
    function signalToPromise(signal, timeout) {
      const waitForSignal = new coreutils_12.PromiseDelegate();
      function cleanup() {
        signal.disconnect(slot);
      }
      function slot(sender, args) {
        cleanup();
        waitForSignal.resolve([sender, args]);
      }
      signal.connect(slot);
      if ((timeout !== null && timeout !== void 0 ? timeout : 0) > 0) {
        setTimeout(() => {
          cleanup();
          waitForSignal.reject(`Signal not emitted within ${timeout} ms.`);
        }, timeout);
      }
      return waitForSignal.promise;
    }
    exports2.signalToPromise = signalToPromise;
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/text.js
var require_text = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/text.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Text = void 0;
    var Text;
    (function(Text2) {
      const HAS_SURROGATES = "\u{1D41A}".length > 1;
      function jsIndexToCharIndex(jsIdx, text) {
        if (HAS_SURROGATES) {
          return jsIdx;
        }
        let charIdx = jsIdx;
        for (let i5 = 0; i5 + 1 < text.length && i5 < jsIdx; i5++) {
          const charCode = text.charCodeAt(i5);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i5 + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              charIdx--;
              i5++;
            }
          }
        }
        return charIdx;
      }
      Text2.jsIndexToCharIndex = jsIndexToCharIndex;
      function charIndexToJsIndex(charIdx, text) {
        if (HAS_SURROGATES) {
          return charIdx;
        }
        let jsIdx = charIdx;
        for (let i5 = 0; i5 + 1 < text.length && i5 < jsIdx; i5++) {
          const charCode = text.charCodeAt(i5);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i5 + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              jsIdx++;
              i5++;
            }
          }
        }
        return jsIdx;
      }
      Text2.charIndexToJsIndex = charIndexToJsIndex;
      function camelCase(str2, upper = false) {
        return str2.replace(/^(\w)|[\s-_:]+(\w)/g, function(match, p1, p22) {
          if (p22) {
            return p22.toUpperCase();
          } else {
            return upper ? p1.toUpperCase() : p1.toLowerCase();
          }
        });
      }
      Text2.camelCase = camelCase;
      function titleCase(str2) {
        return (str2 || "").toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
      }
      Text2.titleCase = titleCase;
    })(Text = exports2.Text || (exports2.Text = {}));
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/time.js
var require_time = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Time = void 0;
    var UNITS = [
      { name: "years", milliseconds: 365 * 24 * 60 * 60 * 1e3 },
      { name: "months", milliseconds: 30 * 24 * 60 * 60 * 1e3 },
      { name: "days", milliseconds: 24 * 60 * 60 * 1e3 },
      { name: "hours", milliseconds: 60 * 60 * 1e3 },
      { name: "minutes", milliseconds: 60 * 1e3 },
      { name: "seconds", milliseconds: 1e3 }
    ];
    var Time;
    (function(Time2) {
      function formatHuman(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.RelativeTimeFormat(lang, { numeric: "auto" });
        const delta = new Date(value).getTime() - Date.now();
        for (let unit of UNITS) {
          const amount = Math.ceil(delta / unit.milliseconds);
          if (amount === 0) {
            continue;
          }
          return formatter.format(amount, unit.name);
        }
        return formatter.format(0, "seconds");
      }
      Time2.formatHuman = formatHuman;
      function format2(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.DateTimeFormat(lang, {
          dateStyle: "short",
          timeStyle: "short"
        });
        return formatter.format(new Date(value));
      }
      Time2.format = format2;
    })(Time = exports2.Time || (exports2.Time = {}));
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_activitymonitor(), exports2);
    __exportStar(require_interfaces(), exports2);
    __exportStar(require_markdowncodeblocks(), exports2);
    __exportStar(require_pageconfig(), exports2);
    __exportStar(require_path(), exports2);
    __exportStar(require_signal(), exports2);
    __exportStar(require_text(), exports2);
    __exportStar(require_time(), exports2);
    __exportStar(require_url(), exports2);
  }
});

// ../../node_modules/@jupyterlab/services/lib/shim/ws.js
var require_ws = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/shim/ws.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = WebSocket;
  }
});

// ../../node_modules/@jupyterlab/services/lib/serverconnection.js
var require_serverconnection = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/serverconnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerConnection = void 0;
    var coreutils_12 = require_lib2();
    var WEBSOCKET;
    if (typeof window === "undefined") {
      WEBSOCKET = require_ws();
    } else {
      WEBSOCKET = WebSocket;
    }
    var ServerConnection3;
    (function(ServerConnection4) {
      function makeSettings(options) {
        return Private19.makeSettings(options);
      }
      ServerConnection4.makeSettings = makeSettings;
      function makeRequest(url, init, settings) {
        return Private19.handleRequest(url, init, settings);
      }
      ServerConnection4.makeRequest = makeRequest;
      class ResponseError extends Error {
        /**
         * Create a ResponseError from a response, handling the traceback and message
         * as appropriate.
         *
         * @param response The response object.
         *
         * @returns A promise that resolves with a `ResponseError` object.
         */
        static async create(response) {
          try {
            const data = await response.json();
            const { message, traceback } = data;
            if (traceback) {
              console.error(traceback);
            }
            return new ResponseError(response, message !== null && message !== void 0 ? message : ResponseError._defaultMessage(response), traceback !== null && traceback !== void 0 ? traceback : "");
          } catch (e4) {
            console.debug(e4);
            return new ResponseError(response);
          }
        }
        /**
         * Create a new response error.
         */
        constructor(response, message = ResponseError._defaultMessage(response), traceback = "") {
          super(message);
          this.response = response;
          this.traceback = traceback;
        }
        static _defaultMessage(response) {
          return `Invalid response: ${response.status} ${response.statusText}`;
        }
      }
      ServerConnection4.ResponseError = ResponseError;
      class NetworkError extends TypeError {
        /**
         * Create a new network error.
         */
        constructor(original) {
          super(original.message);
          this.stack = original.stack;
        }
      }
      ServerConnection4.NetworkError = NetworkError;
    })(ServerConnection3 = exports2.ServerConnection || (exports2.ServerConnection = {}));
    var Private19;
    (function(Private20) {
      function makeSettings(options = {}) {
        var _a;
        const pageBaseUrl = coreutils_12.PageConfig.getBaseUrl();
        const pageWsUrl = coreutils_12.PageConfig.getWsUrl();
        const baseUrl = coreutils_12.URLExt.normalize(options.baseUrl) || pageBaseUrl;
        let wsUrl = options.wsUrl;
        if (!wsUrl && baseUrl === pageBaseUrl) {
          wsUrl = pageWsUrl;
        }
        if (!wsUrl && baseUrl.indexOf("http") === 0) {
          wsUrl = "ws" + baseUrl.slice(4);
        }
        wsUrl = wsUrl !== null && wsUrl !== void 0 ? wsUrl : pageWsUrl;
        return {
          init: { cache: "no-store", credentials: "same-origin" },
          fetch,
          Headers,
          Request,
          WebSocket: WEBSOCKET,
          token: coreutils_12.PageConfig.getToken(),
          appUrl: coreutils_12.PageConfig.getOption("appUrl"),
          appendToken: typeof window === "undefined" || typeof process !== "undefined" && ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.JEST_WORKER_ID) !== void 0 || coreutils_12.URLExt.getHostName(pageBaseUrl) !== coreutils_12.URLExt.getHostName(wsUrl),
          ...options,
          baseUrl,
          wsUrl
        };
      }
      Private20.makeSettings = makeSettings;
      function handleRequest(url, init, settings) {
        var _a;
        if (url.indexOf(settings.baseUrl) !== 0) {
          throw new Error("Can only be used for notebook server requests");
        }
        const cache2 = (_a = init.cache) !== null && _a !== void 0 ? _a : settings.init.cache;
        if (cache2 === "no-store") {
          url += (/\?/.test(url) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
        }
        const request = new settings.Request(url, { ...settings.init, ...init });
        let authenticated = false;
        if (settings.token) {
          authenticated = true;
          request.headers.append("Authorization", `token ${settings.token}`);
        }
        if (typeof document !== "undefined" && (document === null || document === void 0 ? void 0 : document.cookie)) {
          const xsrfToken = getCookie("_xsrf");
          if (xsrfToken !== void 0) {
            authenticated = true;
            request.headers.append("X-XSRFToken", xsrfToken);
          }
        }
        if (!request.headers.has("Content-Type") && authenticated) {
          request.headers.set("Content-Type", "application/json");
        }
        return settings.fetch.call(null, request).catch((e4) => {
          throw new ServerConnection3.NetworkError(e4);
        });
      }
      Private20.handleRequest = handleRequest;
      function getCookie(name2) {
        const matches = document.cookie.match("\\b" + name2 + "=([^;]*)\\b");
        return matches === null || matches === void 0 ? void 0 : matches[1];
      }
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/basemanager.js
var require_basemanager = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/basemanager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseManager = void 0;
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var serverconnection_1 = require_serverconnection();
    var BaseManager = class {
      constructor(options) {
        var _a;
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * A signal emitted when the delegate is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Test whether the delegate has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Whether the manager is active.
       */
      get isActive() {
        return true;
      }
      /**
       * Dispose of the delegate and invoke the callback function.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._disposed.emit(void 0);
        signaling_1.Signal.clearData(this);
      }
    };
    exports2.BaseManager = BaseManager;
  }
});

// ../../node_modules/@jupyterlab/services/lib/config/index.js
var require_config = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigWithDefaults = exports2.ConfigSection = void 0;
    var coreutils_12 = require_lib2();
    var __1 = require_lib4();
    var SERVICE_CONFIG_URL = "api/config";
    var ConfigSection;
    (function(ConfigSection2) {
      function create2(options) {
        const section = new DefaultConfigSection(options);
        return section.load().then(() => {
          return section;
        });
      }
      ConfigSection2.create = create2;
    })(ConfigSection = exports2.ConfigSection || (exports2.ConfigSection = {}));
    var DefaultConfigSection = class {
      /**
       * Construct a new config section.
       */
      constructor(options) {
        var _a;
        this._url = "unknown";
        const settings = this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._url = coreutils_12.URLExt.join(settings.baseUrl, SERVICE_CONFIG_URL, encodeURIComponent(options.name));
      }
      /**
       * Get the data for this section.
       */
      get data() {
        return this._data;
      }
      /**
       * Load the initial data for this section.
       *
       * #### Notes
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       */
      async load() {
        const response = await __1.ServerConnection.makeRequest(this._url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._data = await response.json();
      }
      /**
       * Modify the stored config values.
       *
       * #### Notes
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * Updates the local data immediately, sends the change to the server,
       * and updates the local data with the response, and fulfils the promise
       * with that data.
       */
      async update(newdata) {
        this._data = { ...this._data, ...newdata };
        const init = {
          method: "PATCH",
          body: JSON.stringify(newdata)
        };
        const response = await __1.ServerConnection.makeRequest(this._url, init, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._data = await response.json();
        return this._data;
      }
    };
    var ConfigWithDefaults = class {
      /**
       * Create a new config with defaults.
       */
      constructor(options) {
        var _a, _b;
        this._className = "";
        this._section = options.section;
        this._defaults = (_a = options.defaults) !== null && _a !== void 0 ? _a : {};
        this._className = (_b = options.className) !== null && _b !== void 0 ? _b : "";
      }
      /**
       * Get data from the config section or fall back to defaults.
       */
      get(key) {
        const data = this._classData();
        return key in data ? data[key] : this._defaults[key];
      }
      /**
       * Set a config value.
       *
       * #### Notes
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * Sends the update to the server, and changes our local copy of the data
       * immediately.
       */
      set(key, value) {
        const d6 = {};
        d6[key] = value;
        if (this._className) {
          const d22 = {};
          d22[this._className] = d6;
          return this._section.update(d22);
        } else {
          return this._section.update(d6);
        }
      }
      /**
       * Get data from the Section with our classname, if available.
       *
       * #### Notes
       * If we have no classname, get all of the data in the Section
       */
      _classData() {
        const data = this._section.data;
        if (this._className && this._className in data) {
          return data[this._className];
        }
        return data;
      }
    };
    exports2.ConfigWithDefaults = ConfigWithDefaults;
  }
});

// ../../node_modules/@jupyterlab/services/lib/validate.js
var require_validate = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateProperty = void 0;
    function validateProperty(object2, name2, typeName, values2 = []) {
      if (!object2.hasOwnProperty(name2)) {
        throw Error(`Missing property '${name2}'`);
      }
      const value = object2[name2];
      if (typeName !== void 0) {
        let valid2 = true;
        switch (typeName) {
          case "array":
            valid2 = Array.isArray(value);
            break;
          case "object":
            valid2 = typeof value !== "undefined";
            break;
          default:
            valid2 = typeof value === typeName;
        }
        if (!valid2) {
          throw new Error(`Property '${name2}' is not of type '${typeName}'`);
        }
        if (values2.length > 0) {
          let valid3 = true;
          switch (typeName) {
            case "string":
            case "number":
            case "boolean":
              valid3 = values2.includes(value);
              break;
            default:
              valid3 = values2.findIndex((v2) => v2 === value) >= 0;
              break;
          }
          if (!valid3) {
            throw new Error(`Property '${name2}' is not one of the valid values ${JSON.stringify(values2)}`);
          }
        }
      }
    }
    exports2.validateProperty = validateProperty;
  }
});

// ../../node_modules/@jupyterlab/services/lib/contents/validate.js
var require_validate2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/contents/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateCheckpointModel = exports2.validateContentsModel = void 0;
    var validate_1 = require_validate();
    function validateContentsModel(model) {
      (0, validate_1.validateProperty)(model, "name", "string");
      (0, validate_1.validateProperty)(model, "path", "string");
      (0, validate_1.validateProperty)(model, "type", "string");
      (0, validate_1.validateProperty)(model, "created", "string");
      (0, validate_1.validateProperty)(model, "last_modified", "string");
      (0, validate_1.validateProperty)(model, "mimetype", "object");
      (0, validate_1.validateProperty)(model, "content", "object");
      (0, validate_1.validateProperty)(model, "format", "object");
    }
    exports2.validateContentsModel = validateContentsModel;
    function validateCheckpointModel(model) {
      (0, validate_1.validateProperty)(model, "id", "string");
      (0, validate_1.validateProperty)(model, "last_modified", "string");
    }
    exports2.validateCheckpointModel = validateCheckpointModel;
  }
});

// ../../node_modules/@jupyterlab/services/lib/contents/index.js
var require_contents = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/contents/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Drive = exports2.ContentsManager = exports2.Contents = void 0;
    var coreutils_12 = require_lib2();
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var __1 = require_lib4();
    var validate = __importStar(require_validate2());
    var SERVICE_DRIVE_URL = "api/contents";
    var FILES_URL = "files";
    var Contents;
    (function(Contents2) {
      function validateContentsModel(contents) {
        validate.validateContentsModel(contents);
      }
      Contents2.validateContentsModel = validateContentsModel;
      function validateCheckpointModel(checkpoint) {
        validate.validateCheckpointModel(checkpoint);
      }
      Contents2.validateCheckpointModel = validateCheckpointModel;
    })(Contents = exports2.Contents || (exports2.Contents = {}));
    var ContentsManager = class {
      /**
       * Construct a new contents manager object.
       *
       * @param options - The options used to initialize the object.
       */
      constructor(options = {}) {
        var _a, _b;
        this._isDisposed = false;
        this._additionalDrives = /* @__PURE__ */ new Map();
        this._fileChanged = new signaling_1.Signal(this);
        const serverSettings = this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._defaultDrive = (_b = options.defaultDrive) !== null && _b !== void 0 ? _b : new Drive({ serverSettings });
        this._defaultDrive.fileChanged.connect(this._onFileChanged, this);
      }
      /**
       * A signal emitted when a file operation takes place.
       */
      get fileChanged() {
        return this._fileChanged;
      }
      /**
       * Test whether the manager has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * Add an `IDrive` to the manager.
       */
      addDrive(drive) {
        this._additionalDrives.set(drive.name, drive);
        drive.fileChanged.connect(this._onFileChanged, this);
      }
      /**
       * Given a path, get a shared model factory from the
       * relevant backend. Returns `null` if the backend
       * does not provide one.
       */
      getSharedModelFactory(path2) {
        var _a;
        const [drive] = this._driveForPath(path2);
        return (_a = drive === null || drive === void 0 ? void 0 : drive.sharedModelFactory) !== null && _a !== void 0 ? _a : null;
      }
      /**
       * Given a path of the form `drive:local/portion/of/it.txt`
       * get the local part of it.
       *
       * @param path: the path.
       *
       * @returns The local part of the path.
       */
      localPath(path2) {
        const parts = path2.split("/");
        const firstParts = parts[0].split(":");
        if (firstParts.length === 1 || !this._additionalDrives.has(firstParts[0])) {
          return coreutils_12.PathExt.removeSlash(path2);
        }
        return coreutils_12.PathExt.join(firstParts.slice(1).join(":"), ...parts.slice(1));
      }
      /**
       * Normalize a global path. Reduces '..' and '.' parts, and removes
       * leading slashes from the local part of the path, while retaining
       * the drive name if it exists.
       *
       * @param path: the path.
       *
       * @returns The normalized path.
       */
      normalize(path2) {
        const parts = path2.split(":");
        if (parts.length === 1) {
          return coreutils_12.PathExt.normalize(path2);
        }
        return `${parts[0]}:${coreutils_12.PathExt.normalize(parts.slice(1).join(":"))}`;
      }
      /**
       * Resolve a global path, starting from the root path. Behaves like
       * posix-path.resolve, with 3 differences:
       *  - will never prepend cwd
       *  - if root has a drive name, the result is prefixed with "<drive>:"
       *  - before adding drive name, leading slashes are removed
       *
       * @param path: the path.
       *
       * @returns The normalized path.
       */
      resolvePath(root2, path2) {
        const driveName = this.driveName(root2);
        const localPath = this.localPath(root2);
        const resolved = coreutils_12.PathExt.resolve("/", localPath, path2);
        return driveName ? `${driveName}:${resolved}` : resolved;
      }
      /**
       * Given a path of the form `drive:local/portion/of/it.txt`
       * get the name of the drive. If the path is missing
       * a drive portion, returns an empty string.
       *
       * @param path: the path.
       *
       * @returns The drive name for the path, or the empty string.
       */
      driveName(path2) {
        const parts = path2.split("/");
        const firstParts = parts[0].split(":");
        if (firstParts.length === 1) {
          return "";
        }
        if (this._additionalDrives.has(firstParts[0])) {
          return firstParts[0];
        }
        return "";
      }
      /**
       * Get a file or directory.
       *
       * @param path: The path to the file.
       *
       * @param options: The options used to fetch the file.
       *
       * @returns A promise which resolves with the file content.
       */
      get(path2, options) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.get(localPath, options).then((contentsModel) => {
          const listing = [];
          if (contentsModel.type === "directory" && contentsModel.content) {
            for (const item of contentsModel.content) {
              listing.push({ ...item, path: this._toGlobalPath(drive, item.path) });
            }
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive, localPath),
              content: listing,
              serverPath: contentsModel.path
            };
          } else {
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive, localPath),
              serverPath: contentsModel.path
            };
          }
        });
      }
      /**
       * Get an encoded download url given a file path.
       *
       * @param path - An absolute POSIX file path on the server.
       *
       * #### Notes
       * It is expected that the path contains no relative paths.
       *
       * The returned URL may include a query parameter.
       */
      getDownloadUrl(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.getDownloadUrl(localPath);
      }
      /**
       * Create a new untitled file or directory in the specified directory path.
       *
       * @param options: The options used to create the file.
       *
       * @returns A promise which resolves with the created file content when the
       *    file is created.
       */
      newUntitled(options = {}) {
        if (options.path) {
          const globalPath = this.normalize(options.path);
          const [drive, localPath] = this._driveForPath(globalPath);
          return drive.newUntitled({ ...options, path: localPath }).then((contentsModel) => {
            return {
              ...contentsModel,
              path: coreutils_12.PathExt.join(globalPath, contentsModel.name),
              serverPath: contentsModel.path
            };
          });
        } else {
          return this._defaultDrive.newUntitled(options);
        }
      }
      /**
       * Delete a file.
       *
       * @param path - The path to the file.
       *
       * @returns A promise which resolves when the file is deleted.
       */
      delete(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.delete(localPath);
      }
      /**
       * Rename a file or directory.
       *
       * @param path - The original file path.
       *
       * @param newPath - The new file path.
       *
       * @returns A promise which resolves with the new file contents model when
       *   the file is renamed.
       */
      rename(path2, newPath) {
        const [drive1, path1] = this._driveForPath(path2);
        const [drive2, path22] = this._driveForPath(newPath);
        if (drive1 !== drive2) {
          throw Error("ContentsManager: renaming files must occur within a Drive");
        }
        return drive1.rename(path1, path22).then((contentsModel) => {
          return {
            ...contentsModel,
            path: this._toGlobalPath(drive1, path22),
            serverPath: contentsModel.path
          };
        });
      }
      /**
       * Save a file.
       *
       * @param path - The desired file path.
       *
       * @param options - Optional overrides to the model.
       *
       * @returns A promise which resolves with the file content model when the
       *   file is saved.
       *
       * #### Notes
       * Ensure that `model.content` is populated for the file.
       */
      save(path2, options = {}) {
        const globalPath = this.normalize(path2);
        const [drive, localPath] = this._driveForPath(path2);
        return drive.save(localPath, { ...options, path: localPath }).then((contentsModel) => {
          return {
            ...contentsModel,
            path: globalPath,
            serverPath: contentsModel.path
          };
        });
      }
      /**
       * Copy a file into a given directory.
       *
       * @param path - The original file path.
       *
       * @param toDir - The destination directory path.
       *
       * @returns A promise which resolves with the new contents model when the
       *  file is copied.
       *
       * #### Notes
       * The server will select the name of the copied file.
       */
      copy(fromFile, toDir) {
        const [drive1, path1] = this._driveForPath(fromFile);
        const [drive2, path2] = this._driveForPath(toDir);
        if (drive1 === drive2) {
          return drive1.copy(path1, path2).then((contentsModel) => {
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive1, contentsModel.path),
              serverPath: contentsModel.path
            };
          });
        } else {
          throw Error("Copying files between drives is not currently implemented");
        }
      }
      /**
       * Create a checkpoint for a file.
       *
       * @param path - The path of the file.
       *
       * @returns A promise which resolves with the new checkpoint model when the
       *   checkpoint is created.
       */
      createCheckpoint(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.createCheckpoint(localPath);
      }
      /**
       * List available checkpoints for a file.
       *
       * @param path - The path of the file.
       *
       * @returns A promise which resolves with a list of checkpoint models for
       *    the file.
       */
      listCheckpoints(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.listCheckpoints(localPath);
      }
      /**
       * Restore a file to a known checkpoint state.
       *
       * @param path - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to restore.
       *
       * @returns A promise which resolves when the checkpoint is restored.
       */
      restoreCheckpoint(path2, checkpointID) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.restoreCheckpoint(localPath, checkpointID);
      }
      /**
       * Delete a checkpoint for a file.
       *
       * @param path - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to delete.
       *
       * @returns A promise which resolves when the checkpoint is deleted.
       */
      deleteCheckpoint(path2, checkpointID) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.deleteCheckpoint(localPath, checkpointID);
      }
      /**
       * Given a drive and a local path, construct a fully qualified
       * path. The inverse of `_driveForPath`.
       *
       * @param drive: an `IDrive`.
       *
       * @param localPath: the local path on the drive.
       *
       * @returns the fully qualified path.
       */
      _toGlobalPath(drive, localPath) {
        if (drive === this._defaultDrive) {
          return coreutils_12.PathExt.removeSlash(localPath);
        } else {
          return `${drive.name}:${coreutils_12.PathExt.removeSlash(localPath)}`;
        }
      }
      /**
       * Given a path, get the `IDrive to which it refers,
       * where the path satisfies the pattern
       * `'driveName:path/to/file'`. If there is no `driveName`
       * prepended to the path, it returns the default drive.
       *
       * @param path: a path to a file.
       *
       * @returns A tuple containing an `IDrive` object for the path,
       * and a local path for that drive.
       */
      _driveForPath(path2) {
        const driveName = this.driveName(path2);
        const localPath = this.localPath(path2);
        if (driveName) {
          return [this._additionalDrives.get(driveName), localPath];
        } else {
          return [this._defaultDrive, localPath];
        }
      }
      /**
       * Respond to fileChanged signals from the drives attached to
       * the manager. This prepends the drive name to the path if necessary,
       * and then forwards the signal.
       */
      _onFileChanged(sender, args) {
        var _a, _b;
        if (sender === this._defaultDrive) {
          this._fileChanged.emit(args);
        } else {
          let newValue = null;
          let oldValue = null;
          if ((_a = args.newValue) === null || _a === void 0 ? void 0 : _a.path) {
            newValue = {
              ...args.newValue,
              path: this._toGlobalPath(sender, args.newValue.path)
            };
          }
          if ((_b = args.oldValue) === null || _b === void 0 ? void 0 : _b.path) {
            oldValue = {
              ...args.oldValue,
              path: this._toGlobalPath(sender, args.oldValue.path)
            };
          }
          this._fileChanged.emit({
            type: args.type,
            newValue,
            oldValue
          });
        }
      }
    };
    exports2.ContentsManager = ContentsManager;
    var Drive = class {
      /**
       * Construct a new contents manager object.
       *
       * @param options - The options used to initialize the object.
       */
      constructor(options = {}) {
        var _a, _b, _c;
        this._isDisposed = false;
        this._fileChanged = new signaling_1.Signal(this);
        this.name = (_a = options.name) !== null && _a !== void 0 ? _a : "Default";
        this._apiEndpoint = (_b = options.apiEndpoint) !== null && _b !== void 0 ? _b : SERVICE_DRIVE_URL;
        this.serverSettings = (_c = options.serverSettings) !== null && _c !== void 0 ? _c : __1.ServerConnection.makeSettings();
      }
      /**
       * A signal emitted when a file operation takes place.
       */
      get fileChanged() {
        return this._fileChanged;
      }
      /**
       * Test whether the manager has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * Get a file or directory.
       *
       * @param localPath: The path to the file.
       *
       * @param options: The options used to fetch the file.
       *
       * @returns A promise which resolves with the file content.
       *
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async get(localPath, options) {
        let url = this._getUrl(localPath);
        if (options) {
          if (options.type === "notebook") {
            delete options["format"];
          }
          const content = options.content ? "1" : "0";
          const params = { ...options, content };
          url += coreutils_12.URLExt.objectToQueryString(params);
        }
        const settings = this.serverSettings;
        const response = await __1.ServerConnection.makeRequest(url, {}, settings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        return data;
      }
      /**
       * Get an encoded download url given a file path.
       *
       * @param localPath - An absolute POSIX file path on the server.
       *
       * #### Notes
       * It is expected that the path contains no relative paths.
       *
       * The returned URL may include a query parameter.
       */
      getDownloadUrl(localPath) {
        const baseUrl = this.serverSettings.baseUrl;
        let url = coreutils_12.URLExt.join(baseUrl, FILES_URL, coreutils_12.URLExt.encodeParts(localPath));
        const xsrfTokenMatch = document.cookie.match("\\b_xsrf=([^;]*)\\b");
        if (xsrfTokenMatch) {
          const fullUrl = new URL(url);
          fullUrl.searchParams.append("_xsrf", xsrfTokenMatch[1]);
          url = fullUrl.toString();
        }
        return Promise.resolve(url);
      }
      /**
       * Create a new untitled file or directory in the specified directory path.
       *
       * @param options: The options used to create the file.
       *
       * @returns A promise which resolves with the created file content when the
       *    file is created.
       *
       * #### Notes
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async newUntitled(options = {}) {
        var _a;
        let body = "{}";
        if (options) {
          if (options.ext) {
            options.ext = Private19.normalizeExtension(options.ext);
          }
          body = JSON.stringify(options);
        }
        const settings = this.serverSettings;
        const url = this._getUrl((_a = options.path) !== null && _a !== void 0 ? _a : "");
        const init = {
          method: "POST",
          body
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "new",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Delete a file.
       *
       * @param localPath - The path to the file.
       *
       * @returns A promise which resolves when the file is deleted.
       *
       * #### Notes
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async delete(localPath) {
        const url = this._getUrl(localPath);
        const settings = this.serverSettings;
        const init = { method: "DELETE" };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._fileChanged.emit({
          type: "delete",
          oldValue: { path: localPath },
          newValue: null
        });
      }
      /**
       * Rename a file or directory.
       *
       * @param oldLocalPath - The original file path.
       *
       * @param newLocalPath - The new file path.
       *
       * @returns A promise which resolves with the new file contents model when
       *   the file is renamed.
       *
       * #### Notes
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async rename(oldLocalPath, newLocalPath) {
        const settings = this.serverSettings;
        const url = this._getUrl(oldLocalPath);
        const init = {
          method: "PATCH",
          body: JSON.stringify({ path: newLocalPath })
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "rename",
          oldValue: { path: oldLocalPath },
          newValue: data
        });
        return data;
      }
      /**
       * Save a file.
       *
       * @param localPath - The desired file path.
       *
       * @param options - Optional overrides to the model.
       *
       * @returns A promise which resolves with the file content model when the
       *   file is saved.
       *
       * #### Notes
       * Ensure that `model.content` is populated for the file.
       *
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async save(localPath, options = {}) {
        const settings = this.serverSettings;
        const url = this._getUrl(localPath);
        const init = {
          method: "PUT",
          body: JSON.stringify(options)
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 200 && response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "save",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Copy a file into a given directory.
       *
       * @param localPath - The original file path.
       *
       * @param toDir - The destination directory path.
       *
       * @returns A promise which resolves with the new contents model when the
       *  file is copied.
       *
       * #### Notes
       * The server will select the name of the copied file.
       *
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async copy(fromFile, toDir) {
        const settings = this.serverSettings;
        const url = this._getUrl(toDir);
        const init = {
          method: "POST",
          body: JSON.stringify({ copy_from: fromFile })
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "new",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Create a checkpoint for a file.
       *
       * @param localPath - The path of the file.
       *
       * @returns A promise which resolves with the new checkpoint model when the
       *   checkpoint is created.
       *
       * #### Notes
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async createCheckpoint(localPath) {
        const url = this._getUrl(localPath, "checkpoints");
        const init = { method: "POST" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateCheckpointModel(data);
        return data;
      }
      /**
       * List available checkpoints for a file.
       *
       * @param localPath - The path of the file.
       *
       * @returns A promise which resolves with a list of checkpoint models for
       *    the file.
       *
       * #### Notes
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async listCheckpoints(localPath) {
        const url = this._getUrl(localPath, "checkpoints");
        const response = await __1.ServerConnection.makeRequest(url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        if (!Array.isArray(data)) {
          throw new Error("Invalid Checkpoint list");
        }
        for (let i5 = 0; i5 < data.length; i5++) {
          validate.validateCheckpointModel(data[i5]);
        }
        return data;
      }
      /**
       * Restore a file to a known checkpoint state.
       *
       * @param localPath - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to restore.
       *
       * @returns A promise which resolves when the checkpoint is restored.
       *
       * #### Notes
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async restoreCheckpoint(localPath, checkpointID) {
        const url = this._getUrl(localPath, "checkpoints", checkpointID);
        const init = { method: "POST" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Delete a checkpoint for a file.
       *
       * @param localPath - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to delete.
       *
       * @returns A promise which resolves when the checkpoint is deleted.
       *
       * #### Notes
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async deleteCheckpoint(localPath, checkpointID) {
        const url = this._getUrl(localPath, "checkpoints", checkpointID);
        const init = { method: "DELETE" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Get a REST url for a file given a path.
       */
      _getUrl(...args) {
        const parts = args.map((path2) => coreutils_12.URLExt.encodeParts(path2));
        const baseUrl = this.serverSettings.baseUrl;
        return coreutils_12.URLExt.join(baseUrl, this._apiEndpoint, ...parts);
      }
    };
    exports2.Drive = Drive;
    var Private19;
    (function(Private20) {
      function normalizeExtension(extension2) {
        if (extension2.length > 0 && extension2.indexOf(".") !== 0) {
          extension2 = `.${extension2}`;
        }
        return extension2;
      }
      Private20.normalizeExtension = normalizeExtension;
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/event/index.js
var require_event = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/event/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventManager = void 0;
    var coreutils_12 = require_lib2();
    var polling_1 = (init_index_es62(), __toCommonJS(index_es6_exports2));
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var serverconnection_1 = require_serverconnection();
    var SERVICE_EVENTS_URL = "api/events";
    var EventManager = class {
      /**
       * Create a new event manager.
       */
      constructor(options = {}) {
        var _a;
        this._socket = null;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        this._poll = new polling_1.Poll({ factory: () => this._subscribe() });
        this._stream = new signaling_1.Stream(this);
        void this._poll.start();
      }
      /**
       * Whether the event manager is disposed.
       */
      get isDisposed() {
        return this._poll.isDisposed;
      }
      /**
       * An event stream that emits and yields each new event.
       */
      get stream() {
        return this._stream;
      }
      /**
       * Dispose the event manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._poll.dispose();
        const socket = this._socket;
        if (socket) {
          this._socket = null;
          socket.onopen = () => void 0;
          socket.onerror = () => void 0;
          socket.onmessage = () => void 0;
          socket.onclose = () => void 0;
          socket.close();
        }
        signaling_1.Signal.clearData(this);
        this._stream.stop();
      }
      /**
       * Post an event request to be emitted by the event bus.
       */
      async emit(event) {
        const { serverSettings } = this;
        const { baseUrl, token } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const url = coreutils_12.URLExt.join(baseUrl, SERVICE_EVENTS_URL) + (token ? `?token=${token}` : "");
        const init = { body: JSON.stringify(event), method: "POST" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          throw new ResponseError(response);
        }
      }
      /**
       * Subscribe to event bus emissions.
       */
      _subscribe() {
        return new Promise((_5, reject4) => {
          if (this.isDisposed) {
            return;
          }
          const { token, WebSocket: WebSocket2, wsUrl } = this.serverSettings;
          const url = coreutils_12.URLExt.join(wsUrl, SERVICE_EVENTS_URL, "subscribe") + (token ? `?token=${encodeURIComponent(token)}` : "");
          const socket = this._socket = new WebSocket2(url);
          const stream = this._stream;
          socket.onclose = () => reject4(new Error("EventManager socket closed"));
          socket.onmessage = (msg) => msg.data && stream.emit(JSON.parse(msg.data));
        });
      }
    };
    exports2.EventManager = EventManager;
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/kernel.js
var require_kernel = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/kernel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/messages.js
var require_messages = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.supportedKernelWebSocketProtocols = exports2.isInputReplyMsg = exports2.isInputRequestMsg = exports2.isDebugReplyMsg = exports2.isDebugRequestMsg = exports2.isExecuteReplyMsg = exports2.isInfoRequestMsg = exports2.isCommMsgMsg = exports2.isCommCloseMsg = exports2.isCommOpenMsg = exports2.isDebugEventMsg = exports2.isClearOutputMsg = exports2.isStatusMsg = exports2.isErrorMsg = exports2.isExecuteResultMsg = exports2.isExecuteInputMsg = exports2.isUpdateDisplayDataMsg = exports2.isDisplayDataMsg = exports2.isStreamMsg = exports2.createMessage = void 0;
    var coreutils_12 = require_dist();
    function createMessage(options) {
      var _a, _b, _c, _d, _e;
      return {
        buffers: (_a = options.buffers) !== null && _a !== void 0 ? _a : [],
        channel: options.channel,
        content: options.content,
        header: {
          date: (/* @__PURE__ */ new Date()).toISOString(),
          msg_id: (_b = options.msgId) !== null && _b !== void 0 ? _b : coreutils_12.UUID.uuid4(),
          msg_type: options.msgType,
          session: options.session,
          username: (_c = options.username) !== null && _c !== void 0 ? _c : "",
          version: "5.2"
        },
        metadata: (_d = options.metadata) !== null && _d !== void 0 ? _d : {},
        parent_header: (_e = options.parentHeader) !== null && _e !== void 0 ? _e : {}
      };
    }
    exports2.createMessage = createMessage;
    function isStreamMsg(msg) {
      return msg.header.msg_type === "stream";
    }
    exports2.isStreamMsg = isStreamMsg;
    function isDisplayDataMsg(msg) {
      return msg.header.msg_type === "display_data";
    }
    exports2.isDisplayDataMsg = isDisplayDataMsg;
    function isUpdateDisplayDataMsg(msg) {
      return msg.header.msg_type === "update_display_data";
    }
    exports2.isUpdateDisplayDataMsg = isUpdateDisplayDataMsg;
    function isExecuteInputMsg(msg) {
      return msg.header.msg_type === "execute_input";
    }
    exports2.isExecuteInputMsg = isExecuteInputMsg;
    function isExecuteResultMsg(msg) {
      return msg.header.msg_type === "execute_result";
    }
    exports2.isExecuteResultMsg = isExecuteResultMsg;
    function isErrorMsg(msg) {
      return msg.header.msg_type === "error";
    }
    exports2.isErrorMsg = isErrorMsg;
    function isStatusMsg(msg) {
      return msg.header.msg_type === "status";
    }
    exports2.isStatusMsg = isStatusMsg;
    function isClearOutputMsg(msg) {
      return msg.header.msg_type === "clear_output";
    }
    exports2.isClearOutputMsg = isClearOutputMsg;
    function isDebugEventMsg(msg) {
      return msg.header.msg_type === "debug_event";
    }
    exports2.isDebugEventMsg = isDebugEventMsg;
    function isCommOpenMsg(msg) {
      return msg.header.msg_type === "comm_open";
    }
    exports2.isCommOpenMsg = isCommOpenMsg;
    function isCommCloseMsg(msg) {
      return msg.header.msg_type === "comm_close";
    }
    exports2.isCommCloseMsg = isCommCloseMsg;
    function isCommMsgMsg(msg) {
      return msg.header.msg_type === "comm_msg";
    }
    exports2.isCommMsgMsg = isCommMsgMsg;
    function isInfoRequestMsg(msg) {
      return msg.header.msg_type === "kernel_info_request";
    }
    exports2.isInfoRequestMsg = isInfoRequestMsg;
    function isExecuteReplyMsg(msg) {
      return msg.header.msg_type === "execute_reply";
    }
    exports2.isExecuteReplyMsg = isExecuteReplyMsg;
    function isDebugRequestMsg(msg) {
      return msg.header.msg_type === "debug_request";
    }
    exports2.isDebugRequestMsg = isDebugRequestMsg;
    function isDebugReplyMsg(msg) {
      return msg.header.msg_type === "debug_reply";
    }
    exports2.isDebugReplyMsg = isDebugReplyMsg;
    function isInputRequestMsg(msg) {
      return msg.header.msg_type === "input_request";
    }
    exports2.isInputRequestMsg = isInputRequestMsg;
    function isInputReplyMsg(msg) {
      return msg.header.msg_type === "input_reply";
    }
    exports2.isInputReplyMsg = isInputReplyMsg;
    var supportedKernelWebSocketProtocols;
    (function(supportedKernelWebSocketProtocols2) {
      supportedKernelWebSocketProtocols2["v1KernelWebsocketJupyterOrg"] = "v1.kernel.websocket.jupyter.org";
    })(supportedKernelWebSocketProtocols = exports2.supportedKernelWebSocketProtocols || (exports2.supportedKernelWebSocketProtocols = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/validate.js
var require_validate3 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateModels = exports2.validateModel = exports2.validateMessage = void 0;
    var validate_1 = require_validate();
    var HEADER_FIELDS = ["username", "version", "session", "msg_id", "msg_type"];
    var IOPUB_CONTENT_FIELDS = {
      stream: { name: "string", text: "string" },
      display_data: { data: "object", metadata: "object" },
      execute_input: { code: "string", execution_count: "number" },
      execute_result: {
        execution_count: "number",
        data: "object",
        metadata: "object"
      },
      error: { ename: "string", evalue: "string", traceback: "object" },
      status: {
        execution_state: [
          "string",
          ["starting", "idle", "busy", "restarting", "dead"]
        ]
      },
      clear_output: { wait: "boolean" },
      comm_open: { comm_id: "string", target_name: "string", data: "object" },
      comm_msg: { comm_id: "string", data: "object" },
      comm_close: { comm_id: "string" },
      shutdown_reply: { restart: "boolean" }
      // Emitted by the IPython kernel.
    };
    function validateHeader(header) {
      for (let i5 = 0; i5 < HEADER_FIELDS.length; i5++) {
        (0, validate_1.validateProperty)(header, HEADER_FIELDS[i5], "string");
      }
    }
    function validateMessage(msg) {
      (0, validate_1.validateProperty)(msg, "metadata", "object");
      (0, validate_1.validateProperty)(msg, "content", "object");
      (0, validate_1.validateProperty)(msg, "channel", "string");
      validateHeader(msg.header);
      if (msg.channel === "iopub") {
        validateIOPubContent(msg);
      }
    }
    exports2.validateMessage = validateMessage;
    function validateIOPubContent(msg) {
      if (msg.channel === "iopub") {
        const fields = IOPUB_CONTENT_FIELDS[msg.header.msg_type];
        if (fields === void 0) {
          return;
        }
        const names = Object.keys(fields);
        const content = msg.content;
        for (let i5 = 0; i5 < names.length; i5++) {
          let args = fields[names[i5]];
          if (!Array.isArray(args)) {
            args = [args];
          }
          (0, validate_1.validateProperty)(content, names[i5], ...args);
        }
      }
    }
    function validateModel(model) {
      (0, validate_1.validateProperty)(model, "name", "string");
      (0, validate_1.validateProperty)(model, "id", "string");
    }
    exports2.validateModel = validateModel;
    function validateModels(models) {
      if (!Array.isArray(models)) {
        throw new Error("Invalid kernel list");
      }
      models.forEach((d6) => validateModel(d6));
    }
    exports2.validateModels = validateModels;
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/restapi.js
var require_restapi = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKernelModel = exports2.shutdownKernel = exports2.interruptKernel = exports2.restartKernel = exports2.startNew = exports2.listRunning = exports2.KERNEL_SERVICE_URL = void 0;
    var serverconnection_1 = require_serverconnection();
    var coreutils_12 = require_lib2();
    var validate_1 = require_validate3();
    exports2.KERNEL_SERVICE_URL = "api/kernels";
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModels)(data);
      return data;
    }
    exports2.listRunning = listRunning;
    async function startNew(options = {}, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify(options)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 201) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.startNew = startNew;
    async function restartKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id), "restart");
      const init = { method: "POST" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
    }
    exports2.restartKernel = restartKernel;
    async function interruptKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id), "interrupt");
      const init = { method: "POST" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.interruptKernel = interruptKernel;
    async function shutdownKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id));
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const msg = `The kernel "${id}" does not exist on the server`;
        console.warn(msg);
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownKernel = shutdownKernel;
    async function getKernelModel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id));
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status === 404) {
        return void 0;
      } else if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.getKernelModel = getKernelModel;
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/comm.js
var require_comm = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/comm.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommHandler = void 0;
    var disposable_1 = (init_index_es63(), __toCommonJS(index_es6_exports3));
    var KernelMessage2 = __importStar(require_messages());
    var CommHandler = class extends disposable_1.DisposableDelegate {
      /**
       * Construct a new comm channel.
       */
      constructor(target, id, kernel, disposeCb) {
        super(disposeCb);
        this._target = "";
        this._id = "";
        this._id = id;
        this._target = target;
        this._kernel = kernel;
      }
      /**
       * The unique id for the comm channel.
       */
      get commId() {
        return this._id;
      }
      /**
       * The target name for the comm channel.
       */
      get targetName() {
        return this._target;
      }
      /**
       * Get the callback for a comm close event.
       *
       * #### Notes
       * This is called when the comm is closed from either the server or client.
       *
       * **See also:** [[ICommClose]], [[close]]
       */
      get onClose() {
        return this._onClose;
      }
      /**
       * Set the callback for a comm close event.
       *
       * #### Notes
       * This is called when the comm is closed from either the server or client. If
       * the function returns a promise, and the kernel was closed from the server,
       * kernel message processing will pause until the returned promise is
       * fulfilled.
       *
       * **See also:** [[close]]
       */
      set onClose(cb2) {
        this._onClose = cb2;
      }
      /**
       * Get the callback for a comm message received event.
       */
      get onMsg() {
        return this._onMsg;
      }
      /**
       * Set the callback for a comm message received event.
       *
       * #### Notes
       * This is called when a comm message is received. If the function returns a
       * promise, kernel message processing will pause until it is fulfilled.
       */
      set onMsg(cb2) {
        this._onMsg = cb2;
      }
      /**
       * Open a comm with optional data and metadata.
       *
       * #### Notes
       * This sends a `comm_open` message to the server.
       *
       * **See also:** [[ICommOpen]]
       */
      open(data, metadata, buffers = []) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot open");
        }
        const msg = KernelMessage2.createMessage({
          msgType: "comm_open",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            target_name: this._target,
            data: data !== null && data !== void 0 ? data : {}
          },
          metadata,
          buffers
        });
        return this._kernel.sendShellMessage(msg, false, true);
      }
      /**
       * Send a `comm_msg` message to the kernel.
       *
       * #### Notes
       * This is a no-op if the comm has been closed.
       *
       * **See also:** [[ICommMsg]]
       */
      send(data, metadata, buffers = [], disposeOnDone = true) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot send");
        }
        const msg = KernelMessage2.createMessage({
          msgType: "comm_msg",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            data
          },
          metadata,
          buffers
        });
        return this._kernel.sendShellMessage(msg, false, disposeOnDone);
      }
      /**
       * Close the comm.
       *
       * #### Notes
       * This will send a `comm_close` message to the kernel, and call the
       * `onClose` callback if set.
       *
       * This is a no-op if the comm is already closed.
       *
       * **See also:** [[ICommClose]], [[onClose]]
       */
      close(data, metadata, buffers = []) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot close");
        }
        const msg = KernelMessage2.createMessage({
          msgType: "comm_close",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            data: data !== null && data !== void 0 ? data : {}
          },
          metadata,
          buffers
        });
        const future = this._kernel.sendShellMessage(msg, false, true);
        const onClose = this._onClose;
        if (onClose) {
          const ioMsg = KernelMessage2.createMessage({
            msgType: "comm_close",
            channel: "iopub",
            username: this._kernel.username,
            session: this._kernel.clientId,
            content: {
              comm_id: this._id,
              data: data !== null && data !== void 0 ? data : {}
            },
            metadata,
            buffers
          });
          void onClose(ioMsg);
        }
        this.dispose();
        return future;
      }
    };
    exports2.CommHandler = CommHandler;
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/future.js
var require_future = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/future.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelShellFutureHandler = exports2.KernelControlFutureHandler = exports2.KernelFutureHandler = void 0;
    var coreutils_12 = require_dist();
    var disposable_1 = (init_index_es63(), __toCommonJS(index_es6_exports3));
    var KernelMessage2 = __importStar(require_messages());
    var KernelFutureHandler = class extends disposable_1.DisposableDelegate {
      /**
       * Construct a new KernelFutureHandler.
       */
      constructor(cb2, msg, expectReply, disposeOnDone, kernel) {
        super(cb2);
        this._status = 0;
        this._stdin = Private19.noOp;
        this._iopub = Private19.noOp;
        this._reply = Private19.noOp;
        this._done = new coreutils_12.PromiseDelegate();
        this._hooks = new Private19.HookList();
        this._disposeOnDone = true;
        this._msg = msg;
        if (!expectReply) {
          this._setFlag(Private19.KernelFutureFlag.GotReply);
        }
        this._disposeOnDone = disposeOnDone;
        this._kernel = kernel;
      }
      /**
       * Get the original outgoing message.
       */
      get msg() {
        return this._msg;
      }
      /**
       * A promise that resolves when the future is done.
       */
      get done() {
        return this._done.promise;
      }
      /**
       * Get the reply handler.
       */
      get onReply() {
        return this._reply;
      }
      /**
       * Set the reply handler.
       */
      set onReply(cb2) {
        this._reply = cb2;
      }
      /**
       * Get the iopub handler.
       */
      get onIOPub() {
        return this._iopub;
      }
      /**
       * Set the iopub handler.
       */
      set onIOPub(cb2) {
        this._iopub = cb2;
      }
      /**
       * Get the stdin handler.
       */
      get onStdin() {
        return this._stdin;
      }
      /**
       * Set the stdin handler.
       */
      set onStdin(cb2) {
        this._stdin = cb2;
      }
      /**
       * Register hook for IOPub messages.
       *
       * @param hook - The callback invoked for an IOPub message.
       *
       * #### Notes
       * The IOPub hook system allows you to preempt the handlers for IOPub
       * messages handled by the future.
       *
       * The most recently registered hook is run first. A hook can return a
       * boolean or a promise to a boolean, in which case all kernel message
       * processing pauses until the promise is fulfilled. If a hook return value
       * resolves to false, any later hooks will not run and the function will
       * return a promise resolving to false. If a hook throws an error, the error
       * is logged to the console and the next hook is run. If a hook is
       * registered during the hook processing, it will not run until the next
       * message. If a hook is removed during the hook processing, it will be
       * deactivated immediately.
       */
      registerMessageHook(hook) {
        if (this.isDisposed) {
          throw new Error("Kernel future is disposed");
        }
        this._hooks.add(hook);
      }
      /**
       * Remove a hook for IOPub messages.
       *
       * @param hook - The hook to remove.
       *
       * #### Notes
       * If a hook is removed during the hook processing, it will be deactivated immediately.
       */
      removeMessageHook(hook) {
        if (this.isDisposed) {
          return;
        }
        this._hooks.remove(hook);
      }
      /**
       * Send an `input_reply` message.
       */
      sendInputReply(content, parent_header) {
        this._kernel.sendInputReply(content, parent_header);
      }
      /**
       * Dispose and unregister the future.
       */
      dispose() {
        this._stdin = Private19.noOp;
        this._iopub = Private19.noOp;
        this._reply = Private19.noOp;
        this._hooks = null;
        if (!this._testFlag(Private19.KernelFutureFlag.IsDone)) {
          this._done.promise.catch(() => {
          });
          this._done.reject(new Error(`Canceled future for ${this.msg.header.msg_type} message before replies were done`));
        }
        super.dispose();
      }
      /**
       * Handle an incoming kernel message.
       */
      async handleMsg(msg) {
        switch (msg.channel) {
          case "control":
          case "shell":
            if (msg.channel === this.msg.channel && msg.parent_header.msg_id === this.msg.header.msg_id) {
              await this._handleReply(msg);
            }
            break;
          case "stdin":
            await this._handleStdin(msg);
            break;
          case "iopub":
            await this._handleIOPub(msg);
            break;
          default:
            break;
        }
      }
      async _handleReply(msg) {
        const reply = this._reply;
        if (reply) {
          await reply(msg);
        }
        this._replyMsg = msg;
        this._setFlag(Private19.KernelFutureFlag.GotReply);
        if (this._testFlag(Private19.KernelFutureFlag.GotIdle)) {
          this._handleDone();
        }
      }
      async _handleStdin(msg) {
        this._kernel.hasPendingInput = true;
        const stdin = this._stdin;
        if (stdin) {
          await stdin(msg);
        }
      }
      async _handleIOPub(msg) {
        const process2 = await this._hooks.process(msg);
        const iopub = this._iopub;
        if (process2 && iopub) {
          await iopub(msg);
        }
        if (KernelMessage2.isStatusMsg(msg) && msg.content.execution_state === "idle") {
          this._setFlag(Private19.KernelFutureFlag.GotIdle);
          if (this._testFlag(Private19.KernelFutureFlag.GotReply)) {
            this._handleDone();
          }
        }
      }
      _handleDone() {
        if (this._testFlag(Private19.KernelFutureFlag.IsDone)) {
          return;
        }
        this._setFlag(Private19.KernelFutureFlag.IsDone);
        this._done.resolve(this._replyMsg);
        if (this._disposeOnDone) {
          this.dispose();
        }
      }
      /**
       * Test whether the given future flag is set.
       */
      _testFlag(flag) {
        return (this._status & flag) !== 0;
      }
      /**
       * Set the given future flag.
       */
      _setFlag(flag) {
        this._status |= flag;
      }
    };
    exports2.KernelFutureHandler = KernelFutureHandler;
    var KernelControlFutureHandler = class extends KernelFutureHandler {
    };
    exports2.KernelControlFutureHandler = KernelControlFutureHandler;
    var KernelShellFutureHandler = class extends KernelFutureHandler {
    };
    exports2.KernelShellFutureHandler = KernelShellFutureHandler;
    var Private19;
    (function(Private20) {
      Private20.noOp = () => {
      };
      const defer = (() => {
        const ok2 = typeof requestAnimationFrame === "function";
        return ok2 ? requestAnimationFrame : setImmediate;
      })();
      class HookList {
        constructor() {
          this._hooks = [];
        }
        /**
         * Register a hook.
         *
         * @param hook - The callback to register.
         */
        add(hook) {
          this.remove(hook);
          this._hooks.push(hook);
        }
        /**
         * Remove a hook, if it exists in the hook list.
         *
         * @param hook - The callback to remove.
         */
        remove(hook) {
          const index2 = this._hooks.indexOf(hook);
          if (index2 >= 0) {
            this._hooks[index2] = null;
            this._scheduleCompact();
          }
        }
        /**
         * Process a message through the hooks.
         *
         * @returns a promise resolving to false if any hook resolved as false,
         * otherwise true
         *
         * #### Notes
         * The most recently registered hook is run first. A hook can return a
         * boolean or a promise to a boolean, in which case processing pauses until
         * the promise is fulfilled. If a hook return value resolves to false, any
         * later hooks will not run and the function will return a promise resolving
         * to false. If a hook throws an error, the error is logged to the console
         * and the next hook is run. If a hook is registered during the hook
         * processing, it will not run until the next message. If a hook is removed
         * during the hook processing, it will be deactivated immediately.
         */
        async process(msg) {
          await this._processing;
          const processing = new coreutils_12.PromiseDelegate();
          this._processing = processing.promise;
          let continueHandling;
          for (let i5 = this._hooks.length - 1; i5 >= 0; i5--) {
            const hook = this._hooks[i5];
            if (hook === null) {
              continue;
            }
            try {
              continueHandling = await hook(msg);
            } catch (err) {
              continueHandling = true;
              console.error(err);
            }
            if (continueHandling === false) {
              processing.resolve(void 0);
              return false;
            }
          }
          processing.resolve(void 0);
          return true;
        }
        /**
         * Schedule a cleanup of the list, removing any hooks that have been nulled out.
         */
        _scheduleCompact() {
          if (!this._compactScheduled) {
            this._compactScheduled = true;
            defer(() => {
              this._processing = this._processing.then(() => {
                this._compactScheduled = false;
                this._compact();
              });
            });
          }
        }
        /**
         * Compact the list, removing any nulls.
         */
        _compact() {
          let numNulls = 0;
          for (let i5 = 0, len = this._hooks.length; i5 < len; i5++) {
            const hook = this._hooks[i5];
            if (this._hooks[i5] === null) {
              numNulls++;
            } else {
              this._hooks[i5 - numNulls] = hook;
            }
          }
          this._hooks.length -= numNulls;
        }
      }
      Private20.HookList = HookList;
      let KernelFutureFlag;
      (function(KernelFutureFlag2) {
        KernelFutureFlag2[KernelFutureFlag2["GotReply"] = 1] = "GotReply";
        KernelFutureFlag2[KernelFutureFlag2["GotIdle"] = 2] = "GotIdle";
        KernelFutureFlag2[KernelFutureFlag2["IsDone"] = 4] = "IsDone";
        KernelFutureFlag2[KernelFutureFlag2["DisposeOnDone"] = 8] = "DisposeOnDone";
      })(KernelFutureFlag = Private20.KernelFutureFlag || (Private20.KernelFutureFlag = {}));
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/serialize.js
var require_serialize = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/serialize.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deserialize = exports2.serialize = void 0;
    var KernelMessage2 = __importStar(require_messages());
    function serialize2(msg, protocol = "") {
      switch (protocol) {
        case KernelMessage2.supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg:
          return Private19.serializeV1KernelWebsocketJupyterOrg(msg);
        default:
          return Private19.serializeDefault(msg);
      }
    }
    exports2.serialize = serialize2;
    function deserialize(data, protocol = "") {
      switch (protocol) {
        case KernelMessage2.supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg:
          return Private19.deserializeV1KernelWebsocketJupyterOrg(data);
        default:
          return Private19.deserializeDefault(data);
      }
    }
    exports2.deserialize = deserialize;
    var Private19;
    (function(Private20) {
      function deserializeV1KernelWebsocketJupyterOrg(binMsg) {
        let msg;
        const data = new DataView(binMsg);
        const offsetNumber = Number(data.getBigUint64(
          0,
          true
          /* littleEndian */
        ));
        let offsets = [];
        for (let i5 = 0; i5 < offsetNumber; i5++) {
          offsets.push(Number(data.getBigUint64(
            8 * (i5 + 1),
            true
            /* littleEndian */
          )));
        }
        const decoder = new TextDecoder("utf8");
        const channel = decoder.decode(binMsg.slice(offsets[0], offsets[1]));
        const header = JSON.parse(decoder.decode(binMsg.slice(offsets[1], offsets[2])));
        const parent_header = JSON.parse(decoder.decode(binMsg.slice(offsets[2], offsets[3])));
        const metadata = JSON.parse(decoder.decode(binMsg.slice(offsets[3], offsets[4])));
        const content = JSON.parse(decoder.decode(binMsg.slice(offsets[4], offsets[5])));
        let buffers = [];
        for (let i5 = 5; i5 < offsets.length - 1; i5++) {
          buffers.push(new DataView(binMsg.slice(offsets[i5], offsets[i5 + 1])));
        }
        msg = {
          channel,
          header,
          parent_header,
          metadata,
          content,
          buffers
        };
        return msg;
      }
      Private20.deserializeV1KernelWebsocketJupyterOrg = deserializeV1KernelWebsocketJupyterOrg;
      function serializeV1KernelWebsocketJupyterOrg(msg) {
        const header = JSON.stringify(msg.header);
        const parentHeader = msg.parent_header == null ? "{}" : JSON.stringify(msg.parent_header);
        const metadata = JSON.stringify(msg.metadata);
        const content = JSON.stringify(msg.content);
        const buffers = msg.buffers !== void 0 ? msg.buffers : [];
        const offsetNumber = 1 + 4 + buffers.length + 1;
        let offsets = [];
        offsets.push(8 * (1 + offsetNumber));
        offsets.push(msg.channel.length + offsets[offsets.length - 1]);
        const encoder = new TextEncoder();
        const channelEncoded = encoder.encode(msg.channel);
        const headerEncoded = encoder.encode(header);
        const parentHeaderEncoded = encoder.encode(parentHeader);
        const metadataEncoded = encoder.encode(metadata);
        const contentEncoded = encoder.encode(content);
        const binMsgNoBuff = new Uint8Array(channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length + metadataEncoded.length + contentEncoded.length);
        binMsgNoBuff.set(channelEncoded);
        binMsgNoBuff.set(headerEncoded, channelEncoded.length);
        binMsgNoBuff.set(parentHeaderEncoded, channelEncoded.length + headerEncoded.length);
        binMsgNoBuff.set(metadataEncoded, channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length);
        binMsgNoBuff.set(contentEncoded, channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length + metadataEncoded.length);
        for (let length of [
          headerEncoded.length,
          parentHeaderEncoded.length,
          metadataEncoded.length,
          contentEncoded.length
        ]) {
          offsets.push(length + offsets[offsets.length - 1]);
        }
        let buffersByteLength = 0;
        for (let buffer of buffers) {
          let length = buffer.byteLength;
          offsets.push(length + offsets[offsets.length - 1]);
          buffersByteLength += length;
        }
        const binMsg = new Uint8Array(8 * (1 + offsetNumber) + binMsgNoBuff.byteLength + buffersByteLength);
        const word = new ArrayBuffer(8);
        const data = new DataView(word);
        data.setBigUint64(
          0,
          BigInt(offsetNumber),
          true
          /* littleEndian */
        );
        binMsg.set(new Uint8Array(word), 0);
        for (let i5 = 0; i5 < offsets.length; i5++) {
          data.setBigUint64(
            0,
            BigInt(offsets[i5]),
            true
            /* littleEndian */
          );
          binMsg.set(new Uint8Array(word), 8 * (i5 + 1));
        }
        binMsg.set(binMsgNoBuff, offsets[0]);
        for (let i5 = 0; i5 < buffers.length; i5++) {
          const buffer = buffers[i5];
          binMsg.set(new Uint8Array(ArrayBuffer.isView(buffer) ? buffer.buffer : buffer), offsets[5 + i5]);
        }
        return binMsg.buffer;
      }
      Private20.serializeV1KernelWebsocketJupyterOrg = serializeV1KernelWebsocketJupyterOrg;
      function deserializeDefault(data) {
        let value;
        if (typeof data === "string") {
          value = JSON.parse(data);
        } else {
          value = deserializeBinary(data);
        }
        return value;
      }
      Private20.deserializeDefault = deserializeDefault;
      function serializeDefault(msg) {
        var _a;
        let value;
        if ((_a = msg.buffers) === null || _a === void 0 ? void 0 : _a.length) {
          value = serializeBinary(msg);
        } else {
          value = JSON.stringify(msg);
        }
        return value;
      }
      Private20.serializeDefault = serializeDefault;
      function deserializeBinary(buf) {
        const data = new DataView(buf);
        const nbufs = data.getUint32(0);
        const offsets = [];
        if (nbufs < 2) {
          throw new Error("Invalid incoming Kernel Message");
        }
        for (let i5 = 1; i5 <= nbufs; i5++) {
          offsets.push(data.getUint32(i5 * 4));
        }
        const jsonBytes = new Uint8Array(buf.slice(offsets[0], offsets[1]));
        const msg = JSON.parse(new TextDecoder("utf8").decode(jsonBytes));
        msg.buffers = [];
        for (let i5 = 1; i5 < nbufs; i5++) {
          const start = offsets[i5];
          const stop = offsets[i5 + 1] || buf.byteLength;
          msg.buffers.push(new DataView(buf.slice(start, stop)));
        }
        return msg;
      }
      function serializeBinary(msg) {
        const offsets = [];
        const buffers = [];
        const encoder = new TextEncoder();
        let origBuffers = [];
        if (msg.buffers !== void 0) {
          origBuffers = msg.buffers;
          delete msg["buffers"];
        }
        const jsonUtf8 = encoder.encode(JSON.stringify(msg));
        buffers.push(jsonUtf8.buffer);
        for (let i5 = 0; i5 < origBuffers.length; i5++) {
          const b4 = origBuffers[i5];
          buffers.push(ArrayBuffer.isView(b4) ? b4.buffer : b4);
        }
        const nbufs = buffers.length;
        offsets.push(4 * (nbufs + 1));
        for (let i5 = 0; i5 + 1 < buffers.length; i5++) {
          offsets.push(offsets[offsets.length - 1] + buffers[i5].byteLength);
        }
        const msgBuf = new Uint8Array(offsets[offsets.length - 1] + buffers[buffers.length - 1].byteLength);
        const view = new DataView(msgBuf.buffer);
        view.setUint32(0, nbufs);
        for (let i5 = 0; i5 < offsets.length; i5++) {
          view.setUint32(4 * (i5 + 1), offsets[i5]);
        }
        for (let i5 = 0; i5 < buffers.length; i5++) {
          msgBuf.set(new Uint8Array(buffers[i5]), offsets[i5]);
        }
        return msgBuf.buffer;
      }
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernelspec/kernelspec.js
var require_kernelspec = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernelspec/kernelspec.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernelspec/validate.js
var require_validate4 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernelspec/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSpecModels = exports2.validateSpecModel = void 0;
    var validate_1 = require_validate();
    function validateSpecModel(data) {
      const spec = data.spec;
      if (!spec) {
        throw new Error("Invalid kernel spec");
      }
      (0, validate_1.validateProperty)(data, "name", "string");
      (0, validate_1.validateProperty)(data, "resources", "object");
      (0, validate_1.validateProperty)(spec, "language", "string");
      (0, validate_1.validateProperty)(spec, "display_name", "string");
      (0, validate_1.validateProperty)(spec, "argv", "array");
      let metadata = null;
      if (spec.hasOwnProperty("metadata")) {
        (0, validate_1.validateProperty)(spec, "metadata", "object");
        metadata = spec.metadata;
      }
      let env = null;
      if (spec.hasOwnProperty("env")) {
        (0, validate_1.validateProperty)(spec, "env", "object");
        env = spec.env;
      }
      return {
        name: data.name,
        resources: data.resources,
        language: spec.language,
        display_name: spec.display_name,
        argv: spec.argv,
        metadata,
        env
      };
    }
    exports2.validateSpecModel = validateSpecModel;
    function validateSpecModels(data) {
      if (!data.hasOwnProperty("kernelspecs")) {
        throw new Error("No kernelspecs found");
      }
      let keys2 = Object.keys(data.kernelspecs);
      const kernelspecs = /* @__PURE__ */ Object.create(null);
      let defaultSpec = data.default;
      for (let i5 = 0; i5 < keys2.length; i5++) {
        const ks = data.kernelspecs[keys2[i5]];
        try {
          kernelspecs[keys2[i5]] = validateSpecModel(ks);
        } catch (err) {
          console.warn(`Removing errant kernel spec: ${keys2[i5]}`);
        }
      }
      keys2 = Object.keys(kernelspecs);
      if (!keys2.length) {
        throw new Error("No valid kernelspecs found");
      }
      if (!defaultSpec || typeof defaultSpec !== "string" || !(defaultSpec in kernelspecs)) {
        defaultSpec = keys2[0];
        console.warn(`Default kernel not found, using '${keys2[0]}'`);
      }
      return {
        default: defaultSpec,
        kernelspecs
      };
    }
    exports2.validateSpecModels = validateSpecModels;
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernelspec/restapi.js
var require_restapi2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernelspec/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSpecs = void 0;
    var serverconnection_1 = require_serverconnection();
    var validate_1 = require_validate4();
    var coreutils_12 = require_lib2();
    var KERNELSPEC_SERVICE_URL = "api/kernelspecs";
    async function getSpecs(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, KERNELSPEC_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      return (0, validate_1.validateSpecModels)(data);
    }
    exports2.getSpecs = getSpecs;
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernelspec/manager.js
var require_manager = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernelspec/manager.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelSpecManager = void 0;
    var coreutils_12 = require_dist();
    var polling_1 = (init_index_es62(), __toCommonJS(index_es6_exports2));
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var restapi = __importStar(require_restapi2());
    var basemanager_1 = require_basemanager();
    var KernelSpecManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new kernel spec manager.
       *
       * @param options - The default options for kernel.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._connectionFailure = new signaling_1.Signal(this);
        this._specs = null;
        this._specsChanged = new signaling_1.Signal(this);
        this._ready = Promise.all([this.requestSpecs()]).then((_5) => void 0).catch((_5) => void 0).then(() => {
          if (this.isDisposed) {
            return;
          }
          this._isReady = true;
        });
        this._pollSpecs = new polling_1.Poll({
          auto: false,
          factory: () => this.requestSpecs(),
          frequency: {
            interval: 61 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:KernelSpecManager#specs`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        void this.ready.then(() => {
          void this._pollSpecs.start();
        });
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * Get the most recently fetched kernel specs.
       */
      get specs() {
        return this._specs;
      }
      /**
       * A signal emitted when the specs change.
       */
      get specsChanged() {
        return this._specsChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        this._pollSpecs.dispose();
        super.dispose();
      }
      /**
       * Force a refresh of the specs from the server.
       *
       * @returns A promise that resolves when the specs are fetched.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshSpecs() {
        await this._pollSpecs.refresh();
        await this._pollSpecs.tick;
      }
      /**
       * Execute a request to the server to poll specs and update state.
       */
      async requestSpecs() {
        const specs = await restapi.getSpecs(this.serverSettings);
        if (this.isDisposed) {
          return;
        }
        if (!coreutils_12.JSONExt.deepEqual(specs, this._specs)) {
          this._specs = specs;
          this._specsChanged.emit(specs);
        }
      }
    };
    exports2.KernelSpecManager = KernelSpecManager;
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernelspec/index.js
var require_kernelspec2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernelspec/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelSpecAPI = exports2.KernelSpec = void 0;
    var KernelSpec = __importStar(require_kernelspec());
    exports2.KernelSpec = KernelSpec;
    var KernelSpecAPI2 = __importStar(require_restapi2());
    exports2.KernelSpecAPI = KernelSpecAPI2;
    __exportStar(require_manager(), exports2);
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/default.js
var require_default = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/default.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelConnection = void 0;
    var coreutils_12 = require_lib2();
    var coreutils_2 = require_dist();
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var __1 = require_lib4();
    var comm_1 = require_comm();
    var KernelMessage2 = __importStar(require_messages());
    var future_1 = require_future();
    var serialize_1 = require_serialize();
    var validate = __importStar(require_validate3());
    var kernelspec_1 = require_kernelspec2();
    var restapi = __importStar(require_restapi());
    var KERNEL_INFO_TIMEOUT = 3e3;
    var RESTARTING_KERNEL_SESSION = "_RESTARTING_";
    var STARTING_KERNEL_SESSION = "";
    var KernelConnection = class {
      /**
       * Construct a kernel object.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        this._createSocket = (useProtocols = true) => {
          this._errorIfDisposed();
          this._clearSocket();
          this._updateConnectionStatus("connecting");
          const settings = this.serverSettings;
          const partialUrl = coreutils_12.URLExt.join(settings.wsUrl, restapi.KERNEL_SERVICE_URL, encodeURIComponent(this._id));
          const display = partialUrl.replace(/^((?:\w+:)?\/\/)(?:[^@\/]+@)/, "$1");
          console.debug(`Starting WebSocket: ${display}`);
          let url = coreutils_12.URLExt.join(partialUrl, "channels?session_id=" + encodeURIComponent(this._clientId));
          const token = settings.token;
          if (settings.appendToken && token !== "") {
            url = url + `&token=${encodeURIComponent(token)}`;
          }
          const supportedProtocols = useProtocols ? this._supportedProtocols : [];
          this._ws = new settings.WebSocket(url, supportedProtocols);
          this._ws.binaryType = "arraybuffer";
          let alreadyCalledOnclose = false;
          const getKernelModel = async (evt) => {
            var _a2, _b2;
            if (this._isDisposed) {
              return;
            }
            this._reason = "";
            this._model = void 0;
            try {
              const model = await restapi.getKernelModel(this._id, settings);
              this._model = model;
              if ((model === null || model === void 0 ? void 0 : model.execution_state) === "dead") {
                this._updateStatus("dead");
              } else {
                this._onWSClose(evt);
              }
            } catch (err) {
              if (err instanceof __1.ServerConnection.NetworkError || ((_a2 = err.response) === null || _a2 === void 0 ? void 0 : _a2.status) === 503 || ((_b2 = err.response) === null || _b2 === void 0 ? void 0 : _b2.status) === 424) {
                const timeout = Private19.getRandomIntInclusive(10, 30) * 1e3;
                setTimeout(getKernelModel, timeout, evt);
              } else {
                this._reason = "Kernel died unexpectedly";
                this._updateStatus("dead");
              }
            }
            return;
          };
          const earlyClose = async (evt) => {
            if (alreadyCalledOnclose) {
              return;
            }
            alreadyCalledOnclose = true;
            await getKernelModel(evt);
            return;
          };
          this._ws.onmessage = this._onWSMessage;
          this._ws.onopen = this._onWSOpen;
          this._ws.onclose = earlyClose;
          this._ws.onerror = earlyClose;
        };
        this._onWSOpen = (evt) => {
          if (this._ws.protocol !== "" && !this._supportedProtocols.includes(this._ws.protocol)) {
            console.log("Server selected unknown kernel wire protocol:", this._ws.protocol);
            this._updateStatus("dead");
            throw new Error(`Unknown kernel wire protocol:  ${this._ws.protocol}`);
          }
          this._selectedProtocol = this._ws.protocol;
          this._ws.onclose = this._onWSClose;
          this._ws.onerror = this._onWSClose;
          this._updateConnectionStatus("connected");
        };
        this._onWSMessage = (evt) => {
          let msg;
          try {
            msg = (0, serialize_1.deserialize)(evt.data, this._ws.protocol);
            validate.validateMessage(msg);
          } catch (error) {
            error.message = `Kernel message validation error: ${error.message}`;
            throw error;
          }
          this._kernelSession = msg.header.session;
          this._msgChain = this._msgChain.then(() => {
            return this._handleMessage(msg);
          }).catch((error) => {
            if (error.message.startsWith("Canceled future for ")) {
              console.error(error);
            }
          });
          this._anyMessage.emit({ msg, direction: "recv" });
        };
        this._onWSClose = (evt) => {
          if (!this.isDisposed) {
            this._reconnect();
          }
        };
        this._id = "";
        this._name = "";
        this._status = "unknown";
        this._connectionStatus = "connecting";
        this._kernelSession = "";
        this._isDisposed = false;
        this._ws = null;
        this._username = "";
        this._reconnectLimit = 7;
        this._reconnectAttempt = 0;
        this._reconnectTimeout = null;
        this._supportedProtocols = Object.values(KernelMessage2.supportedKernelWebSocketProtocols);
        this._selectedProtocol = "";
        this._futures = /* @__PURE__ */ new Map();
        this._comms = /* @__PURE__ */ new Map();
        this._targetRegistry = /* @__PURE__ */ Object.create(null);
        this._info = new coreutils_2.PromiseDelegate();
        this._pendingMessages = [];
        this._statusChanged = new signaling_1.Signal(this);
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._disposed = new signaling_1.Signal(this);
        this._iopubMessage = new signaling_1.Signal(this);
        this._anyMessage = new signaling_1.Signal(this);
        this._pendingInput = new signaling_1.Signal(this);
        this._unhandledMessage = new signaling_1.Signal(this);
        this._displayIdToParentIds = /* @__PURE__ */ new Map();
        this._msgIdToDisplayIds = /* @__PURE__ */ new Map();
        this._msgChain = Promise.resolve();
        this._hasPendingInput = false;
        this._reason = "";
        this._noOp = () => {
        };
        this._name = options.model.name;
        this._id = options.model.id;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._clientId = (_b = options.clientId) !== null && _b !== void 0 ? _b : coreutils_2.UUID.uuid4();
        this._username = (_c = options.username) !== null && _c !== void 0 ? _c : "";
        this.handleComms = (_d = options.handleComms) !== null && _d !== void 0 ? _d : true;
        this._createSocket();
      }
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when the kernel status changes.
       */
      get statusChanged() {
        return this._statusChanged;
      }
      /**
       * A signal emitted when the kernel status changes.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * A signal emitted for iopub kernel messages.
       *
       * #### Notes
       * This signal is emitted after the iopub message is handled asynchronously.
       */
      get iopubMessage() {
        return this._iopubMessage;
      }
      /**
       * A signal emitted for unhandled kernel message.
       *
       * #### Notes
       * This signal is emitted for a message that was not handled. It is emitted
       * during the asynchronous message handling code.
       */
      get unhandledMessage() {
        return this._unhandledMessage;
      }
      /**
       * The kernel model
       */
      get model() {
        return this._model || {
          id: this.id,
          name: this.name,
          reason: this._reason
        };
      }
      /**
       * A signal emitted for any kernel message.
       *
       * #### Notes
       * This signal is emitted when a message is received, before it is handled
       * asynchronously.
       *
       * This message is emitted when a message is queued for sending (either in
       * the websocket buffer, or our own pending message buffer). The message may
       * actually be sent across the wire at a later time.
       *
       * The message emitted in this signal should not be modified in any way.
       */
      get anyMessage() {
        return this._anyMessage;
      }
      /**
       * A signal emitted when a kernel has pending inputs from the user.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * The id of the server-side kernel.
       */
      get id() {
        return this._id;
      }
      /**
       * The name of the server-side kernel.
       */
      get name() {
        return this._name;
      }
      /**
       * The client username.
       */
      get username() {
        return this._username;
      }
      /**
       * The client unique id.
       */
      get clientId() {
        return this._clientId;
      }
      /**
       * The current status of the kernel.
       */
      get status() {
        return this._status;
      }
      /**
       * The current connection status of the kernel connection.
       */
      get connectionStatus() {
        return this._connectionStatus;
      }
      /**
       * Test whether the kernel has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * The cached kernel info.
       *
       * @returns A promise that resolves to the kernel info.
       */
      get info() {
        return this._info.promise;
      }
      /**
       * The kernel spec.
       *
       * @returns A promise that resolves to the kernel spec.
       */
      get spec() {
        if (this._specPromise) {
          return this._specPromise;
        }
        this._specPromise = kernelspec_1.KernelSpecAPI.getSpecs(this.serverSettings).then((specs) => {
          return specs.kernelspecs[this._name];
        });
        return this._specPromise;
      }
      /**
       * Clone the current kernel with a new clientId.
       */
      clone(options = {}) {
        return new KernelConnection({
          model: this.model,
          username: this.username,
          serverSettings: this.serverSettings,
          // handleComms defaults to false since that is safer
          handleComms: false,
          ...options
        });
      }
      /**
       * Dispose of the resources held by the kernel.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        this._updateConnectionStatus("disconnected");
        this._clearKernelState();
        this._pendingMessages = [];
        this._clearSocket();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Send a shell message to the kernel.
       *
       * #### Notes
       * Send a message to the kernel's shell channel, yielding a future object
       * for accepting replies.
       *
       * If `expectReply` is given and `true`, the future is disposed when both a
       * shell reply and an idle status message are received. If `expectReply`
       * is not given or is `false`, the future is resolved when an idle status
       * message is received.
       * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.
       * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.
       *
       * All replies are validated as valid kernel messages.
       *
       * If the kernel status is `dead`, this will throw an error.
       */
      sendShellMessage(msg, expectReply = false, disposeOnDone = true) {
        return this._sendKernelShellControl(future_1.KernelShellFutureHandler, msg, expectReply, disposeOnDone);
      }
      /**
       * Send a control message to the kernel.
       *
       * #### Notes
       * Send a message to the kernel's control channel, yielding a future object
       * for accepting replies.
       *
       * If `expectReply` is given and `true`, the future is disposed when both a
       * control reply and an idle status message are received. If `expectReply`
       * is not given or is `false`, the future is resolved when an idle status
       * message is received.
       * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.
       * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.
       *
       * All replies are validated as valid kernel messages.
       *
       * If the kernel status is `dead`, this will throw an error.
       */
      sendControlMessage(msg, expectReply = false, disposeOnDone = true) {
        return this._sendKernelShellControl(future_1.KernelControlFutureHandler, msg, expectReply, disposeOnDone);
      }
      _sendKernelShellControl(ctor2, msg, expectReply = false, disposeOnDone = true) {
        this._sendMessage(msg);
        this._anyMessage.emit({ msg, direction: "send" });
        const future = new ctor2(() => {
          const msgId = msg.header.msg_id;
          this._futures.delete(msgId);
          const displayIds = this._msgIdToDisplayIds.get(msgId);
          if (!displayIds) {
            return;
          }
          displayIds.forEach((displayId) => {
            const msgIds = this._displayIdToParentIds.get(displayId);
            if (msgIds) {
              const idx = msgIds.indexOf(msgId);
              if (idx === -1) {
                return;
              }
              if (msgIds.length === 1) {
                this._displayIdToParentIds.delete(displayId);
              } else {
                msgIds.splice(idx, 1);
                this._displayIdToParentIds.set(displayId, msgIds);
              }
            }
          });
          this._msgIdToDisplayIds.delete(msgId);
        }, msg, expectReply, disposeOnDone, this);
        this._futures.set(msg.header.msg_id, future);
        return future;
      }
      /**
       * Send a message on the websocket.
       *
       * If queue is true, queue the message for later sending if we cannot send
       * now. Otherwise throw an error.
       *
       * #### Notes
       * As an exception to the queueing, if we are sending a kernel_info_request
       * message while we think the kernel is restarting, we send the message
       * immediately without queueing. This is so that we can trigger a message
       * back, which will then clear the kernel restarting state.
       */
      _sendMessage(msg, queue = true) {
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        if ((this._kernelSession === STARTING_KERNEL_SESSION || this._kernelSession === RESTARTING_KERNEL_SESSION) && KernelMessage2.isInfoRequestMsg(msg)) {
          if (this.connectionStatus === "connected") {
            this._ws.send((0, serialize_1.serialize)(msg, this._ws.protocol));
            return;
          } else {
            throw new Error("Could not send message: status is not connected");
          }
        }
        if (queue && this._pendingMessages.length > 0) {
          this._pendingMessages.push(msg);
          return;
        }
        if (this.connectionStatus === "connected" && this._kernelSession !== RESTARTING_KERNEL_SESSION) {
          this._ws.send((0, serialize_1.serialize)(msg, this._ws.protocol));
        } else if (queue) {
          this._pendingMessages.push(msg);
        } else {
          throw new Error("Could not send message");
        }
      }
      /**
       * Interrupt a kernel.
       *
       * #### Notes
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * It is assumed that the API call does not mutate the kernel id or name.
       *
       * The promise will be rejected if the kernel status is `Dead` or if the
       * request fails or the response is invalid.
       */
      async interrupt() {
        this.hasPendingInput = false;
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        return restapi.interruptKernel(this.id, this.serverSettings);
      }
      /**
       * Request a kernel restart.
       *
       * #### Notes
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels)
       * and validates the response model.
       *
       * Any existing Future or Comm objects are cleared once the kernel has
       * actually be restarted.
       *
       * The promise is fulfilled on a valid server response (after the kernel restarts)
       * and rejected otherwise.
       *
       * It is assumed that the API call does not mutate the kernel id or name.
       *
       * The promise will be rejected if the request fails or the response is
       * invalid.
       */
      async restart() {
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        this._updateStatus("restarting");
        this._clearKernelState();
        this._kernelSession = RESTARTING_KERNEL_SESSION;
        await restapi.restartKernel(this.id, this.serverSettings);
        await this.reconnect();
        this.hasPendingInput = false;
      }
      /**
       * Reconnect to a kernel.
       *
       * #### Notes
       * This may try multiple times to reconnect to a kernel, and will sever any
       * existing connection.
       */
      reconnect() {
        this._errorIfDisposed();
        const result2 = new coreutils_2.PromiseDelegate();
        const fulfill = (sender, status) => {
          if (status === "connected") {
            result2.resolve();
            this.connectionStatusChanged.disconnect(fulfill, this);
          } else if (status === "disconnected") {
            result2.reject(new Error("Kernel connection disconnected"));
            this.connectionStatusChanged.disconnect(fulfill, this);
          }
        };
        this.connectionStatusChanged.connect(fulfill, this);
        this._reconnectAttempt = 0;
        this._reconnect();
        return result2.promise;
      }
      /**
       * Shutdown a kernel.
       *
       * #### Notes
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * On a valid response, disposes this kernel connection.
       *
       * If the kernel is already `dead`, disposes this kernel connection without
       * a server request.
       */
      async shutdown() {
        if (this.status !== "dead") {
          await restapi.shutdownKernel(this.id, this.serverSettings);
        }
        this.handleShutdown();
      }
      /**
       * Handles a kernel shutdown.
       *
       * #### Notes
       * This method should be called if we know from outside information that a
       * kernel is dead (for example, we cannot find the kernel model on the
       * server).
       */
      handleShutdown() {
        this._updateStatus("dead");
        this.dispose();
      }
      /**
       * Send a `kernel_info_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#kernel-info).
       *
       * Fulfills with the `kernel_info_response` content when the shell reply is
       * received and validated.
       */
      async requestKernelInfo() {
        const msg = KernelMessage2.createMessage({
          msgType: "kernel_info_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content: {}
        });
        let reply;
        try {
          reply = await Private19.handleShellMessage(this, msg);
        } catch (e4) {
          if (this.isDisposed) {
            return;
          } else {
            throw e4;
          }
        }
        this._errorIfDisposed();
        if (!reply) {
          return;
        }
        if (reply.content.status === void 0) {
          reply.content.status = "ok";
        }
        if (reply.content.status !== "ok") {
          this._info.reject("Kernel info reply errored");
          return reply;
        }
        this._info.resolve(reply.content);
        this._kernelSession = reply.header.session;
        return reply;
      }
      /**
       * Send a `complete_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#completion).
       *
       * Fulfills with the `complete_reply` content when the shell reply is
       * received and validated.
       */
      requestComplete(content) {
        const msg = KernelMessage2.createMessage({
          msgType: "complete_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private19.handleShellMessage(this, msg);
      }
      /**
       * Send an `inspect_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#introspection).
       *
       * Fulfills with the `inspect_reply` content when the shell reply is
       * received and validated.
       */
      requestInspect(content) {
        const msg = KernelMessage2.createMessage({
          msgType: "inspect_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private19.handleShellMessage(this, msg);
      }
      /**
       * Send a `history_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#history).
       *
       * Fulfills with the `history_reply` content when the shell reply is
       * received and validated.
       */
      requestHistory(content) {
        const msg = KernelMessage2.createMessage({
          msgType: "history_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private19.handleShellMessage(this, msg);
      }
      /**
       * Send an `execute_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#execute).
       *
       * Future `onReply` is called with the `execute_reply` content when the
       * shell reply is received and validated. The future will resolve when
       * this message is received and the `idle` iopub status is received.
       * The future will also be disposed at this point unless `disposeOnDone`
       * is specified and `false`, in which case it is up to the caller to dispose
       * of the future.
       *
       * **See also:** [[IExecuteReply]]
       */
      requestExecute(content, disposeOnDone = true, metadata) {
        const defaults = {
          silent: false,
          store_history: true,
          user_expressions: {},
          allow_stdin: true,
          stop_on_error: false
        };
        const msg = KernelMessage2.createMessage({
          msgType: "execute_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content: { ...defaults, ...content },
          metadata
        });
        return this.sendShellMessage(msg, true, disposeOnDone);
      }
      /**
       * Send an experimental `debug_request` message.
       *
       * @hidden
       *
       * #### Notes
       * Debug messages are experimental messages that are not in the official
       * kernel message specification. As such, this function is *NOT* considered
       * part of the public API, and may change without notice.
       */
      requestDebug(content, disposeOnDone = true) {
        const msg = KernelMessage2.createMessage({
          msgType: "debug_request",
          channel: "control",
          username: this._username,
          session: this._clientId,
          content
        });
        return this.sendControlMessage(msg, true, disposeOnDone);
      }
      /**
       * Send an `is_complete_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#code-completeness).
       *
       * Fulfills with the `is_complete_response` content when the shell reply is
       * received and validated.
       */
      requestIsComplete(content) {
        const msg = KernelMessage2.createMessage({
          msgType: "is_complete_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private19.handleShellMessage(this, msg);
      }
      /**
       * Send a `comm_info_request` message.
       *
       * #### Notes
       * Fulfills with the `comm_info_reply` content when the shell reply is
       * received and validated.
       */
      requestCommInfo(content) {
        const msg = KernelMessage2.createMessage({
          msgType: "comm_info_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private19.handleShellMessage(this, msg);
      }
      /**
       * Send an `input_reply` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#messages-on-the-stdin-router-dealer-sockets).
       */
      sendInputReply(content, parent_header) {
        const msg = KernelMessage2.createMessage({
          msgType: "input_reply",
          channel: "stdin",
          username: this._username,
          session: this._clientId,
          content
        });
        msg.parent_header = parent_header;
        this._sendMessage(msg);
        this._anyMessage.emit({ msg, direction: "send" });
        this.hasPendingInput = false;
      }
      /**
       * Create a new comm.
       *
       * #### Notes
       * If a client-side comm already exists with the given commId, an error is thrown.
       * If the kernel does not handle comms, an error is thrown.
       */
      createComm(targetName, commId = coreutils_2.UUID.uuid4()) {
        if (!this.handleComms) {
          throw new Error("Comms are disabled on this kernel connection");
        }
        if (this._comms.has(commId)) {
          throw new Error("Comm is already created");
        }
        const comm = new comm_1.CommHandler(targetName, commId, this, () => {
          this._unregisterComm(commId);
        });
        this._comms.set(commId, comm);
        return comm;
      }
      /**
       * Check if a comm exists.
       */
      hasComm(commId) {
        return this._comms.has(commId);
      }
      /**
       * Register a comm target handler.
       *
       * @param targetName - The name of the comm target.
       *
       * @param callback - The callback invoked for a comm open message.
       *
       * @returns A disposable used to unregister the comm target.
       *
       * #### Notes
       * Only one comm target can be registered to a target name at a time, an
       * existing callback for the same target name will be overridden.  A registered
       * comm target handler will take precedence over a comm which specifies a
       * `target_module`.
       *
       * If the callback returns a promise, kernel message processing will pause
       * until the returned promise is fulfilled.
       */
      registerCommTarget(targetName, callback) {
        if (!this.handleComms) {
          return;
        }
        this._targetRegistry[targetName] = callback;
      }
      /**
       * Remove a comm target handler.
       *
       * @param targetName - The name of the comm target to remove.
       *
       * @param callback - The callback to remove.
       *
       * #### Notes
       * The comm target is only removed if the callback argument matches.
       */
      removeCommTarget(targetName, callback) {
        if (!this.handleComms) {
          return;
        }
        if (!this.isDisposed && this._targetRegistry[targetName] === callback) {
          delete this._targetRegistry[targetName];
        }
      }
      /**
       * Register an IOPub message hook.
       *
       * @param msg_id - The parent_header message id the hook will intercept.
       *
       * @param hook - The callback invoked for the message.
       *
       * #### Notes
       * The IOPub hook system allows you to preempt the handlers for IOPub
       * messages that are responses to a given message id.
       *
       * The most recently registered hook is run first. A hook can return a
       * boolean or a promise to a boolean, in which case all kernel message
       * processing pauses until the promise is fulfilled. If a hook return value
       * resolves to false, any later hooks will not run and the function will
       * return a promise resolving to false. If a hook throws an error, the error
       * is logged to the console and the next hook is run. If a hook is
       * registered during the hook processing, it will not run until the next
       * message. If a hook is removed during the hook processing, it will be
       * deactivated immediately.
       *
       * See also [[IFuture.registerMessageHook]].
       */
      registerMessageHook(msgId, hook) {
        var _a;
        const future = (_a = this._futures) === null || _a === void 0 ? void 0 : _a.get(msgId);
        if (future) {
          future.registerMessageHook(hook);
        }
      }
      /**
       * Remove an IOPub message hook.
       *
       * @param msg_id - The parent_header message id the hook intercepted.
       *
       * @param hook - The callback invoked for the message.
       *
       */
      removeMessageHook(msgId, hook) {
        var _a;
        const future = (_a = this._futures) === null || _a === void 0 ? void 0 : _a.get(msgId);
        if (future) {
          future.removeMessageHook(hook);
        }
      }
      /**
       * Remove the input guard, if any.
       */
      removeInputGuard() {
        this.hasPendingInput = false;
      }
      /**
       * Handle a message with a display id.
       *
       * @returns Whether the message was handled.
       */
      async _handleDisplayId(displayId, msg) {
        var _a, _b;
        const msgId = msg.parent_header.msg_id;
        let parentIds = this._displayIdToParentIds.get(displayId);
        if (parentIds) {
          const updateMsg = {
            header: coreutils_2.JSONExt.deepCopy(msg.header),
            parent_header: coreutils_2.JSONExt.deepCopy(msg.parent_header),
            metadata: coreutils_2.JSONExt.deepCopy(msg.metadata),
            content: coreutils_2.JSONExt.deepCopy(msg.content),
            channel: msg.channel,
            buffers: msg.buffers ? msg.buffers.slice() : []
          };
          updateMsg.header.msg_type = "update_display_data";
          await Promise.all(parentIds.map(async (parentId) => {
            const future = this._futures && this._futures.get(parentId);
            if (future) {
              await future.handleMsg(updateMsg);
            }
          }));
        }
        if (msg.header.msg_type === "update_display_data") {
          return true;
        }
        parentIds = (_a = this._displayIdToParentIds.get(displayId)) !== null && _a !== void 0 ? _a : [];
        if (parentIds.indexOf(msgId) === -1) {
          parentIds.push(msgId);
        }
        this._displayIdToParentIds.set(displayId, parentIds);
        const displayIds = (_b = this._msgIdToDisplayIds.get(msgId)) !== null && _b !== void 0 ? _b : [];
        if (displayIds.indexOf(msgId) === -1) {
          displayIds.push(msgId);
        }
        this._msgIdToDisplayIds.set(msgId, displayIds);
        return false;
      }
      /**
       * Forcefully clear the socket state.
       *
       * #### Notes
       * This will clear all socket state without calling any handlers and will
       * not update the connection status. If you call this method, you are
       * responsible for updating the connection status as needed and recreating
       * the socket if you plan to reconnect.
       */
      _clearSocket() {
        if (this._ws !== null) {
          this._ws.onopen = this._noOp;
          this._ws.onclose = this._noOp;
          this._ws.onerror = this._noOp;
          this._ws.onmessage = this._noOp;
          this._ws.close();
          this._ws = null;
        }
      }
      /**
       * Handle status iopub messages from the kernel.
       */
      _updateStatus(status) {
        if (this._status === status || this._status === "dead") {
          return;
        }
        this._status = status;
        Private19.logKernelStatus(this);
        this._statusChanged.emit(status);
        if (status === "dead") {
          this.dispose();
        }
      }
      /**
       * Send pending messages to the kernel.
       */
      _sendPending() {
        while (this.connectionStatus === "connected" && this._kernelSession !== RESTARTING_KERNEL_SESSION && this._pendingMessages.length > 0) {
          this._sendMessage(this._pendingMessages[0], false);
          this._pendingMessages.shift();
        }
      }
      /**
       * Clear the internal state.
       */
      _clearKernelState() {
        this._kernelSession = "";
        this._pendingMessages = [];
        this._futures.forEach((future) => {
          future.dispose();
        });
        this._comms.forEach((comm) => {
          comm.dispose();
        });
        this._msgChain = Promise.resolve();
        this._futures = /* @__PURE__ */ new Map();
        this._comms = /* @__PURE__ */ new Map();
        this._displayIdToParentIds.clear();
        this._msgIdToDisplayIds.clear();
      }
      /**
       * Check to make sure it is okay to proceed to handle a message.
       *
       * #### Notes
       * Because we handle messages asynchronously, before a message is handled the
       * kernel might be disposed or restarted (and have a different session id).
       * This function throws an error in each of these cases. This is meant to be
       * called at the start of an asynchronous message handler to cancel message
       * processing if the message no longer is valid.
       */
      _assertCurrentMessage(msg) {
        this._errorIfDisposed();
        if (msg.header.session !== this._kernelSession) {
          throw new Error(`Canceling handling of old message: ${msg.header.msg_type}`);
        }
      }
      /**
       * Handle a `comm_open` kernel message.
       */
      async _handleCommOpen(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = new comm_1.CommHandler(content.target_name, content.comm_id, this, () => {
          this._unregisterComm(content.comm_id);
        });
        this._comms.set(content.comm_id, comm);
        try {
          const target = await Private19.loadObject(content.target_name, content.target_module, this._targetRegistry);
          await target(comm, msg);
        } catch (e4) {
          comm.close();
          console.error("Exception opening new comm");
          throw e4;
        }
      }
      /**
       * Handle 'comm_close' kernel message.
       */
      async _handleCommClose(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = this._comms.get(content.comm_id);
        if (!comm) {
          console.error("Comm not found for comm id " + content.comm_id);
          return;
        }
        this._unregisterComm(comm.commId);
        const onClose = comm.onClose;
        if (onClose) {
          await onClose(msg);
        }
        comm.dispose();
      }
      /**
       * Handle a 'comm_msg' kernel message.
       */
      async _handleCommMsg(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = this._comms.get(content.comm_id);
        if (!comm) {
          return;
        }
        const onMsg = comm.onMsg;
        if (onMsg) {
          await onMsg(msg);
        }
      }
      /**
       * Unregister a comm instance.
       */
      _unregisterComm(commId) {
        this._comms.delete(commId);
      }
      /**
       * Handle connection status changes.
       */
      _updateConnectionStatus(connectionStatus) {
        if (this._connectionStatus === connectionStatus) {
          return;
        }
        this._connectionStatus = connectionStatus;
        if (connectionStatus !== "connecting") {
          this._reconnectAttempt = 0;
          clearTimeout(this._reconnectTimeout);
        }
        if (this.status !== "dead") {
          if (connectionStatus === "connected") {
            let restarting = this._kernelSession === RESTARTING_KERNEL_SESSION;
            let p3 = this.requestKernelInfo();
            let sendPendingCalled = false;
            let sendPendingOnce = () => {
              if (sendPendingCalled) {
                return;
              }
              sendPendingCalled = true;
              if (restarting && this._kernelSession === RESTARTING_KERNEL_SESSION) {
                this._kernelSession = "";
              }
              clearTimeout(timeoutHandle);
              if (this._pendingMessages.length > 0) {
                this._sendPending();
              }
            };
            void p3.then(sendPendingOnce);
            let timeoutHandle = setTimeout(sendPendingOnce, KERNEL_INFO_TIMEOUT);
          } else {
            this._updateStatus("unknown");
          }
        }
        this._connectionStatusChanged.emit(connectionStatus);
      }
      async _handleMessage(msg) {
        var _a, _b;
        let handled = false;
        if (msg.parent_header && msg.channel === "iopub" && (KernelMessage2.isDisplayDataMsg(msg) || KernelMessage2.isUpdateDisplayDataMsg(msg) || KernelMessage2.isExecuteResultMsg(msg))) {
          const transient = (_a = msg.content.transient) !== null && _a !== void 0 ? _a : {};
          const displayId = transient["display_id"];
          if (displayId) {
            handled = await this._handleDisplayId(displayId, msg);
            this._assertCurrentMessage(msg);
          }
        }
        if (!handled && msg.parent_header) {
          const parentHeader = msg.parent_header;
          const future = (_b = this._futures) === null || _b === void 0 ? void 0 : _b.get(parentHeader.msg_id);
          if (future) {
            await future.handleMsg(msg);
            this._assertCurrentMessage(msg);
          } else {
            const owned = parentHeader.session === this.clientId;
            if (msg.channel !== "iopub" && owned) {
              this._unhandledMessage.emit(msg);
            }
          }
        }
        if (msg.channel === "iopub") {
          switch (msg.header.msg_type) {
            case "status": {
              const executionState = msg.content.execution_state;
              if (executionState === "restarting") {
                void Promise.resolve().then(async () => {
                  this._updateStatus("autorestarting");
                  this._clearKernelState();
                  await this.reconnect();
                });
              }
              this._updateStatus(executionState);
              break;
            }
            case "comm_open":
              if (this.handleComms) {
                await this._handleCommOpen(msg);
              }
              break;
            case "comm_msg":
              if (this.handleComms) {
                await this._handleCommMsg(msg);
              }
              break;
            case "comm_close":
              if (this.handleComms) {
                await this._handleCommClose(msg);
              }
              break;
            default:
              break;
          }
          if (!this.isDisposed) {
            this._assertCurrentMessage(msg);
            this._iopubMessage.emit(msg);
          }
        }
      }
      /**
       * Attempt a connection if we have not exhausted connection attempts.
       */
      _reconnect() {
        this._errorIfDisposed();
        clearTimeout(this._reconnectTimeout);
        if (this._reconnectAttempt < this._reconnectLimit) {
          this._updateConnectionStatus("connecting");
          const timeout = Private19.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
          console.warn(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`);
          const useProtocols = this._selectedProtocol !== "" ? true : false;
          this._reconnectTimeout = setTimeout(this._createSocket, timeout, useProtocols);
          this._reconnectAttempt += 1;
        } else {
          this._updateConnectionStatus("disconnected");
        }
        this._clearSocket();
      }
      /**
       * Utility function to throw an error if this instance is disposed.
       */
      _errorIfDisposed() {
        if (this.isDisposed) {
          throw new Error("Kernel connection is disposed");
        }
      }
      get hasPendingInput() {
        return this._hasPendingInput;
      }
      set hasPendingInput(value) {
        this._hasPendingInput = value;
        this._pendingInput.emit(value);
      }
    };
    exports2.KernelConnection = KernelConnection;
    var Private19;
    (function(Private20) {
      function logKernelStatus(kernel) {
        switch (kernel.status) {
          case "idle":
          case "busy":
          case "unknown":
            return;
          default:
            console.debug(`Kernel: ${kernel.status} (${kernel.id})`);
            break;
        }
      }
      Private20.logKernelStatus = logKernelStatus;
      async function handleShellMessage(kernel, msg) {
        const future = kernel.sendShellMessage(msg, true);
        return future.done;
      }
      Private20.handleShellMessage = handleShellMessage;
      function loadObject(name2, moduleName, registry) {
        return new Promise((resolve, reject4) => {
          if (moduleName) {
            if (typeof requirejs === "undefined") {
              throw new Error("requirejs not found");
            }
            requirejs([moduleName], (mod) => {
              if (mod[name2] === void 0) {
                const msg = `Object '${name2}' not found in module '${moduleName}'`;
                reject4(new Error(msg));
              } else {
                resolve(mod[name2]);
              }
            }, reject4);
          } else {
            if (registry === null || registry === void 0 ? void 0 : registry[name2]) {
              resolve(registry[name2]);
            } else {
              reject4(new Error(`Object '${name2}' not found in registry`));
            }
          }
        });
      }
      Private20.loadObject = loadObject;
      function getRandomIntInclusive(min3, max3) {
        min3 = Math.ceil(min3);
        max3 = Math.floor(max3);
        return Math.floor(Math.random() * (max3 - min3 + 1)) + min3;
      }
      Private20.getRandomIntInclusive = getRandomIntInclusive;
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/manager.js
var require_manager2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelManager = void 0;
    var polling_1 = (init_index_es62(), __toCommonJS(index_es6_exports2));
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var __1 = require_lib4();
    var basemanager_1 = require_basemanager();
    var restapi_1 = require_restapi();
    var default_1 = require_default();
    var KernelManager2 = class extends basemanager_1.BaseManager {
      /**
       * Construct a new kernel manager.
       *
       * @param options - The default options for kernel.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._kernelConnections = /* @__PURE__ */ new Set();
        this._models = /* @__PURE__ */ new Map();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:KernelManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running kernels change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._models.clear();
        this._kernelConnections.forEach((x4) => x4.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /**
       * Connect to an existing kernel.
       *
       * @returns The new kernel connection.
       *
       * #### Notes
       * This will use the manager's server settings and ignore any server
       * settings passed in the options.
       */
      connectTo(options) {
        var _a;
        const { id } = options.model;
        let handleComms = (_a = options.handleComms) !== null && _a !== void 0 ? _a : true;
        if (options.handleComms === void 0) {
          for (const kc of this._kernelConnections) {
            if (kc.id === id && kc.handleComms) {
              handleComms = false;
              break;
            }
          }
        }
        const kernelConnection = new default_1.KernelConnection({
          handleComms,
          ...options,
          serverSettings: this.serverSettings
        });
        this._onStarted(kernelConnection);
        if (!this._models.has(id)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return kernelConnection;
      }
      /**
       * Create an iterator over the most recent running kernels.
       *
       * @returns A new iterator over the running kernels.
       */
      running() {
        return this._models.values();
      }
      /**
       * Force a refresh of the running kernels.
       *
       * @returns A promise that resolves when the running list has been refreshed.
       *
       * #### Notes
       * This is not typically meant to be called by the user, since the
       * manager maintains its own internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Start a new kernel.
       *
       * @param createOptions - The kernel creation options
       *
       * @param connectOptions - The kernel connection options
       *
       * @returns A promise that resolves with the kernel connection.
       *
       * #### Notes
       * The manager `serverSettings` will be always be used.
       */
      async startNew(createOptions = {}, connectOptions = {}) {
        const model = await (0, restapi_1.startNew)(createOptions, this.serverSettings);
        return this.connectTo({
          ...connectOptions,
          model
        });
      }
      /**
       * Shut down a kernel by id.
       *
       * @param id - The id of the target kernel.
       *
       * @returns A promise that resolves when the operation is complete.
       */
      async shutdown(id) {
        await (0, restapi_1.shutdownKernel)(id, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all kernels.
       *
       * @returns A promise that resolves when all of the kernels are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all([...this._models.keys()].map((id) => (0, restapi_1.shutdownKernel)(id, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Find a kernel by id.
       *
       * @param id - The id of the target kernel.
       *
       * @returns A promise that resolves with the kernel's model.
       */
      async findById(id) {
        if (this._models.has(id)) {
          return this._models.get(id);
        }
        await this.refreshRunning();
        return this._models.get(id);
      }
      /**
       * Execute a request to the server to poll running kernels and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof __1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        if (this._models.size === models.length && models.every((model) => {
          const existing = this._models.get(model.id);
          if (!existing) {
            return false;
          }
          return existing.connections === model.connections && existing.execution_state === model.execution_state && existing.last_activity === model.last_activity && existing.name === model.name && existing.reason === model.reason && existing.traceback === model.traceback;
        })) {
          return;
        }
        this._models = new Map(models.map((x4) => [x4.id, x4]));
        this._kernelConnections.forEach((kc) => {
          if (!this._models.has(kc.id)) {
            kc.handleShutdown();
          }
        });
        this._runningChanged.emit(models);
      }
      /**
       * Handle a kernel starting.
       */
      _onStarted(kernelConnection) {
        this._kernelConnections.add(kernelConnection);
        kernelConnection.statusChanged.connect(this._onStatusChanged, this);
        kernelConnection.disposed.connect(this._onDisposed, this);
      }
      _onDisposed(kernelConnection) {
        this._kernelConnections.delete(kernelConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      _onStatusChanged(kernelConnection, status) {
        if (status === "dead") {
          void this.refreshRunning().catch(() => {
          });
        }
      }
    };
    exports2.KernelManager = KernelManager2;
    (function(KernelManager3) {
      class NoopManager extends KernelManager3 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * Start a new kernel - throws an error since it is not supported.
         */
        async startNew(createOptions = {}, connectOptions = {}) {
          return Promise.reject(new Error("Not implemented in no-op Kernel Manager"));
        }
        /**
         * Connect to an existing kernel - throws an error since it is not supported.
         */
        connectTo(options) {
          throw new Error("Not implemented in no-op Kernel Manager");
        }
        /**
         * Shut down a kernel by id - throws an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Kernel Manager"));
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Execute a request to the server to poll running kernels and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      KernelManager3.NoopManager = NoopManager;
    })(KernelManager2 = exports2.KernelManager || (exports2.KernelManager = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/index.js
var require_kernel2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelConnection = exports2.KernelAPI = exports2.KernelMessage = exports2.Kernel = void 0;
    var Kernel = __importStar(require_kernel());
    exports2.Kernel = Kernel;
    var KernelMessage2 = __importStar(require_messages());
    exports2.KernelMessage = KernelMessage2;
    var KernelAPI2 = __importStar(require_restapi());
    exports2.KernelAPI = KernelAPI2;
    var default_1 = require_default();
    Object.defineProperty(exports2, "KernelConnection", { enumerable: true, get: function() {
      return default_1.KernelConnection;
    } });
    __exportStar(require_manager2(), exports2);
  }
});

// ../../node_modules/@jupyterlab/services/lib/builder/index.js
var require_builder = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/builder/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BuildManager = void 0;
    var coreutils_12 = require_lib2();
    var serverconnection_1 = require_serverconnection();
    var BUILD_SETTINGS_URL = "api/build";
    var BuildManager = class {
      /**
       * Create a new setting manager.
       */
      constructor(options = {}) {
        var _a;
        this._url = "";
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        const { baseUrl, appUrl } = this.serverSettings;
        this._url = coreutils_12.URLExt.join(baseUrl, appUrl, BUILD_SETTINGS_URL);
      }
      /**
       * Test whether the build service is available.
       */
      get isAvailable() {
        return coreutils_12.PageConfig.getOption("buildAvailable").toLowerCase() === "true";
      }
      /**
       * Test whether to check build status automatically.
       */
      get shouldCheck() {
        return coreutils_12.PageConfig.getOption("buildCheck").toLowerCase() === "true";
      }
      /**
       * Get whether the application should be built.
       */
      getStatus() {
        const { _url, serverSettings } = this;
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, {}, serverSettings);
        return promise.then((response) => {
          if (response.status !== 200) {
            throw new serverconnection_1.ServerConnection.ResponseError(response);
          }
          return response.json();
        }).then((data) => {
          if (typeof data.status !== "string") {
            throw new Error("Invalid data");
          }
          if (typeof data.message !== "string") {
            throw new Error("Invalid data");
          }
          return data;
        });
      }
      /**
       * Build the application.
       */
      build() {
        const { _url, serverSettings } = this;
        const init = { method: "POST" };
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, init, serverSettings);
        return promise.then((response) => {
          if (response.status === 400) {
            throw new serverconnection_1.ServerConnection.ResponseError(response, "Build aborted");
          }
          if (response.status !== 200) {
            const message = `Build failed with ${response.status}.

        If you are experiencing the build failure after installing an extension (or trying to include previously installed extension after updating JupyterLab) please check the extension repository for new installation instructions as many extensions migrated to the prebuilt extensions system which no longer requires rebuilding JupyterLab (but uses a different installation procedure, typically involving a package manager such as 'pip' or 'conda').

        If you specifically intended to install a source extension, please run 'jupyter lab build' on the server for full output.`;
            throw new serverconnection_1.ServerConnection.ResponseError(response, message);
          }
        });
      }
      /**
       * Cancel an active build.
       */
      cancel() {
        const { _url, serverSettings } = this;
        const init = { method: "DELETE" };
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, init, serverSettings);
        return promise.then((response) => {
          if (response.status !== 204) {
            throw new serverconnection_1.ServerConnection.ResponseError(response);
          }
        });
      }
    };
    exports2.BuildManager = BuildManager;
  }
});

// ../../node_modules/@jupyterlab/services/lib/nbconvert/index.js
var require_nbconvert = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/nbconvert/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NbConvertManager = void 0;
    var coreutils_12 = require_lib2();
    var serverconnection_1 = require_serverconnection();
    var coreutils_2 = require_dist();
    var NBCONVERT_SETTINGS_URL = "api/nbconvert";
    var NbConvertManager = class {
      /**
       * Create a new nbconvert manager.
       */
      constructor(options = {}) {
        var _a;
        this._exportFormats = null;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch and cache the export formats from the expensive nbconvert handler.
       */
      async fetchExportFormats() {
        this._requestingFormats = new coreutils_2.PromiseDelegate();
        this._exportFormats = null;
        const base = this.serverSettings.baseUrl;
        const url = coreutils_12.URLExt.join(base, NBCONVERT_SETTINGS_URL);
        const { serverSettings } = this;
        const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        const exportList = {};
        const keys2 = Object.keys(data);
        keys2.forEach(function(key) {
          const mimeType = data[key].output_mimetype;
          exportList[key] = { output_mimetype: mimeType };
        });
        this._exportFormats = exportList;
        this._requestingFormats.resolve(exportList);
        return exportList;
      }
      /**
       * Get the list of export formats, preferring pre-cached ones.
       */
      async getExportFormats(force = true) {
        if (this._requestingFormats) {
          return this._requestingFormats.promise;
        }
        if (force || !this._exportFormats) {
          return await this.fetchExportFormats();
        }
        return this._exportFormats;
      }
    };
    exports2.NbConvertManager = NbConvertManager;
  }
});

// ../../node_modules/@jupyterlab/services/lib/session/session.js
var require_session = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/session/session.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/services/lib/session/validate.js
var require_validate5 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/session/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateModels = exports2.updateLegacySessionModel = exports2.validateModel = void 0;
    var validate_1 = require_validate3();
    var validate_2 = require_validate();
    function validateModel(data) {
      (0, validate_2.validateProperty)(data, "id", "string");
      (0, validate_2.validateProperty)(data, "type", "string");
      (0, validate_2.validateProperty)(data, "name", "string");
      (0, validate_2.validateProperty)(data, "path", "string");
      (0, validate_2.validateProperty)(data, "kernel", "object");
      (0, validate_1.validateModel)(data.kernel);
    }
    exports2.validateModel = validateModel;
    function updateLegacySessionModel(data) {
      if (data.path === void 0 && data.notebook !== void 0) {
        data.path = data.notebook.path;
        data.type = "notebook";
        data.name = "";
      }
    }
    exports2.updateLegacySessionModel = updateLegacySessionModel;
    function validateModels(models) {
      if (!Array.isArray(models)) {
        throw new Error("Invalid session list");
      }
      models.forEach((d6) => validateModel(d6));
    }
    exports2.validateModels = validateModels;
  }
});

// ../../node_modules/@jupyterlab/services/lib/session/restapi.js
var require_restapi3 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/session/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateSession = exports2.startSession = exports2.getSessionModel = exports2.shutdownSession = exports2.getSessionUrl = exports2.listRunning = exports2.SESSION_SERVICE_URL = void 0;
    var serverconnection_1 = require_serverconnection();
    var coreutils_12 = require_lib2();
    var validate_1 = require_validate5();
    exports2.SESSION_SERVICE_URL = "api/sessions";
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.SESSION_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error("Invalid Session list");
      }
      data.forEach((m4) => {
        (0, validate_1.updateLegacySessionModel)(m4);
        (0, validate_1.validateModel)(m4);
      });
      return data;
    }
    exports2.listRunning = listRunning;
    function getSessionUrl(baseUrl, id) {
      return coreutils_12.URLExt.join(baseUrl, exports2.SESSION_SERVICE_URL, id);
    }
    exports2.getSessionUrl = getSessionUrl;
    async function shutdownSession(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      var _a;
      const url = getSessionUrl(settings.baseUrl, id);
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const data = await response.json();
        const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The session "${id}"" does not exist on the server`;
        console.warn(msg);
      } else if (response.status === 410) {
        throw new serverconnection_1.ServerConnection.ResponseError(response, "The kernel was deleted but the session was not");
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownSession = shutdownSession;
    async function getSessionModel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = getSessionUrl(settings.baseUrl, id);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.getSessionModel = getSessionModel;
    async function startSession(options, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.SESSION_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify(options)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 201) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.startSession = startSession;
    async function updateSession(model, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = getSessionUrl(settings.baseUrl, model.id);
      const init = {
        method: "PATCH",
        body: JSON.stringify(model)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.updateSession = updateSession;
  }
});

// ../../node_modules/@jupyterlab/services/lib/session/default.js
var require_default2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/session/default.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionConnection = void 0;
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var __1 = require_lib4();
    var restapi_1 = require_restapi3();
    var coreutils_12 = require_dist();
    var SessionConnection = class {
      /**
       * Construct a new session.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        this._id = "";
        this._path = "";
        this._name = "";
        this._type = "";
        this._kernel = null;
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this._kernelChanged = new signaling_1.Signal(this);
        this._statusChanged = new signaling_1.Signal(this);
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._pendingInput = new signaling_1.Signal(this);
        this._iopubMessage = new signaling_1.Signal(this);
        this._unhandledMessage = new signaling_1.Signal(this);
        this._anyMessage = new signaling_1.Signal(this);
        this._propertyChanged = new signaling_1.Signal(this);
        this._id = options.model.id;
        this._name = options.model.name;
        this._path = options.model.path;
        this._type = options.model.type;
        this._username = (_a = options.username) !== null && _a !== void 0 ? _a : "";
        this._clientId = (_b = options.clientId) !== null && _b !== void 0 ? _b : coreutils_12.UUID.uuid4();
        this._connectToKernel = options.connectToKernel;
        this._kernelConnectionOptions = (_c = options.kernelConnectionOptions) !== null && _c !== void 0 ? _c : {};
        this.serverSettings = (_d = options.serverSettings) !== null && _d !== void 0 ? _d : __1.ServerConnection.makeSettings();
        this.setupKernel(options.model.kernel);
      }
      /**
       * A signal emitted when the session is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when the kernel changes.
       */
      get kernelChanged() {
        return this._kernelChanged;
      }
      /**
       * A signal proxied from the connection about the kernel status.
       */
      get statusChanged() {
        return this._statusChanged;
      }
      /**
       * A signal proxied from the kernel about the connection status.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * A signal proxied from the kernel pending input.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * A signal proxied from the kernel about iopub kernel messages.
       */
      get iopubMessage() {
        return this._iopubMessage;
      }
      /**
       * A signal proxied from the kernel for an unhandled kernel message.
       */
      get unhandledMessage() {
        return this._unhandledMessage;
      }
      /**
       * A signal proxied from the kernel emitted for any kernel message.
       *
       * #### Notes
       * The behavior is undefined if the message is modified during message
       * handling. As such, it should be treated as read-only.
       */
      get anyMessage() {
        return this._anyMessage;
      }
      /**
       * A signal emitted when a session property changes.
       */
      get propertyChanged() {
        return this._propertyChanged;
      }
      /**
       * Get the session id.
       */
      get id() {
        return this._id;
      }
      /**
       * Get the session kernel connection object.
       *
       * #### Notes
       * This is a read-only property, and can be altered by [changeKernel].
       */
      get kernel() {
        return this._kernel;
      }
      /**
       * Get the session path.
       */
      get path() {
        return this._path;
      }
      /**
       * Get the session type.
       */
      get type() {
        return this._type;
      }
      /**
       * Get the session name.
       */
      get name() {
        return this._name;
      }
      /**
       * Get the model associated with the session.
       */
      get model() {
        return {
          id: this.id,
          kernel: this.kernel && { id: this.kernel.id, name: this.kernel.name },
          path: this._path,
          type: this._type,
          name: this._name
        };
      }
      /**
       * Test whether the session has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Update the session based on a session model from the server.
       *
       * #### Notes
       * This only updates this session connection instance. Use `setPath`,
       * `setName`, `setType`, and `changeKernel` to change the session values on
       * the server.
       */
      update(model) {
        const oldModel = this.model;
        this._path = model.path;
        this._name = model.name;
        this._type = model.type;
        if (this._kernel === null && model.kernel !== null || this._kernel !== null && model.kernel === null || this._kernel !== null && model.kernel !== null && this._kernel.id !== model.kernel.id) {
          if (this._kernel !== null) {
            this._kernel.dispose();
          }
          const oldValue = this._kernel || null;
          this.setupKernel(model.kernel);
          const newValue = this._kernel || null;
          this._kernelChanged.emit({ name: "kernel", oldValue, newValue });
        }
        this._handleModelChange(oldModel);
      }
      /**
       * Dispose of the resources held by the session.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        if (this._kernel) {
          this._kernel.dispose();
          const oldValue = this._kernel;
          this._kernel = null;
          const newValue = this._kernel;
          this._kernelChanged.emit({ name: "kernel", oldValue, newValue });
        }
        signaling_1.Signal.clearData(this);
      }
      /**
       * Change the session path.
       *
       * @param path - The new session path.
       *
       * @returns A promise that resolves when the session has renamed.
       *
       * #### Notes
       * This uses the Jupyter REST API, and the response is validated.
       * The promise is fulfilled on a valid response and rejected otherwise.
       */
      async setPath(path2) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ path: path2 });
      }
      /**
       * Change the session name.
       */
      async setName(name2) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ name: name2 });
      }
      /**
       * Change the session type.
       */
      async setType(type2) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ type: type2 });
      }
      /**
       * Change the kernel.
       *
       * @param options - The name or id of the new kernel.
       *
       * #### Notes
       * This shuts down the existing kernel and creates a new kernel,
       * keeping the existing session ID and session path.
       */
      async changeKernel(options) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ kernel: options });
        return this.kernel;
      }
      /**
       * Kill the kernel and shutdown the session.
       *
       * @returns - The promise fulfilled on a valid response from the server.
       *
       * #### Notes
       * Uses the [Jupyter Notebook API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/sessions), and validates the response.
       * Disposes of the session and emits a [sessionDied] signal on success.
       */
      async shutdown() {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await (0, restapi_1.shutdownSession)(this.id, this.serverSettings);
        this.dispose();
      }
      /**
       * Create a new kernel connection and connect to its signals.
       *
       * #### Notes
       * This method is not meant to be subclassed.
       */
      setupKernel(model) {
        if (model === null) {
          this._kernel = null;
          return;
        }
        const kc = this._connectToKernel({
          ...this._kernelConnectionOptions,
          model,
          username: this._username,
          clientId: this._clientId,
          serverSettings: this.serverSettings
        });
        this._kernel = kc;
        kc.statusChanged.connect(this.onKernelStatus, this);
        kc.connectionStatusChanged.connect(this.onKernelConnectionStatus, this);
        kc.pendingInput.connect(this.onPendingInput, this);
        kc.unhandledMessage.connect(this.onUnhandledMessage, this);
        kc.iopubMessage.connect(this.onIOPubMessage, this);
        kc.anyMessage.connect(this.onAnyMessage, this);
      }
      /**
       * Handle to changes in the Kernel status.
       */
      onKernelStatus(sender, state) {
        this._statusChanged.emit(state);
      }
      /**
       * Handle to changes in the Kernel status.
       */
      onKernelConnectionStatus(sender, state) {
        this._connectionStatusChanged.emit(state);
      }
      /**
       * Handle a change in the pendingInput.
       */
      onPendingInput(sender, state) {
        this._pendingInput.emit(state);
      }
      /**
       * Handle iopub kernel messages.
       */
      onIOPubMessage(sender, msg) {
        this._iopubMessage.emit(msg);
      }
      /**
       * Handle unhandled kernel messages.
       */
      onUnhandledMessage(sender, msg) {
        this._unhandledMessage.emit(msg);
      }
      /**
       * Handle any kernel messages.
       */
      onAnyMessage(sender, args) {
        this._anyMessage.emit(args);
      }
      /**
       * Send a PATCH to the server, updating the session path or the kernel.
       */
      async _patch(body) {
        const model = await (0, restapi_1.updateSession)({ ...body, id: this._id }, this.serverSettings);
        this.update(model);
        return model;
      }
      /**
       * Handle a change to the model.
       */
      _handleModelChange(oldModel) {
        if (oldModel.name !== this._name) {
          this._propertyChanged.emit("name");
        }
        if (oldModel.type !== this._type) {
          this._propertyChanged.emit("type");
        }
        if (oldModel.path !== this._path) {
          this._propertyChanged.emit("path");
        }
      }
    };
    exports2.SessionConnection = SessionConnection;
  }
});

// ../../node_modules/@jupyterlab/services/lib/session/manager.js
var require_manager3 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/session/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionManager = void 0;
    var polling_1 = (init_index_es62(), __toCommonJS(index_es6_exports2));
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var serverconnection_1 = require_serverconnection();
    var basemanager_1 = require_basemanager();
    var default_1 = require_default2();
    var restapi_1 = require_restapi3();
    var SessionManager2 = class extends basemanager_1.BaseManager {
      /**
       * Construct a new session manager.
       *
       * @param options - The default options for each session.
       */
      constructor(options) {
        var _a;
        super(options);
        this._isReady = false;
        this._sessionConnections = /* @__PURE__ */ new Set();
        this._models = /* @__PURE__ */ new Map();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._connectToKernel = (options2) => {
          return this._kernelManager.connectTo(options2);
        };
        this._kernelManager = options.kernelManager;
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:SessionManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          if (this._kernelManager.isActive) {
            await this._kernelManager.ready;
          }
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running sessions change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._models.clear();
        this._sessionConnections.forEach((x4) => x4.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /*
       * Connect to a running session.  See also [[connectToSession]].
       */
      connectTo(options) {
        const sessionConnection = new default_1.SessionConnection({
          ...options,
          connectToKernel: this._connectToKernel,
          serverSettings: this.serverSettings
        });
        this._onStarted(sessionConnection);
        if (!this._models.has(options.model.id)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return sessionConnection;
      }
      /**
       * Create an iterator over the most recent running sessions.
       *
       * @returns A new iterator over the running sessions.
       */
      running() {
        return this._models.values();
      }
      /**
       * Force a refresh of the running sessions.
       *
       * @returns A promise that with the list of running sessions.
       *
       * #### Notes
       * This is not typically meant to be called by the user, since the
       * manager maintains its own internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Start a new session.  See also [[startNewSession]].
       *
       * @param createOptions - Options for creating the session
       *
       * @param connectOptions - Options for connecting to the session
       */
      async startNew(createOptions, connectOptions = {}) {
        const model = await (0, restapi_1.startSession)(createOptions, this.serverSettings);
        await this.refreshRunning();
        return this.connectTo({ ...connectOptions, model });
      }
      /**
       * Shut down a session by id.
       */
      async shutdown(id) {
        await (0, restapi_1.shutdownSession)(id, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all sessions.
       *
       * @returns A promise that resolves when all of the kernels are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all([...this._models.keys()].map((id) => (0, restapi_1.shutdownSession)(id, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Find a session associated with a path and stop it if it is the only session
       * using that kernel.
       *
       * @param path - The path in question.
       *
       * @returns A promise that resolves when the relevant sessions are stopped.
       */
      async stopIfNeeded(path2) {
        try {
          const sessions = await (0, restapi_1.listRunning)(this.serverSettings);
          const matches = sessions.filter((value) => value.path === path2);
          if (matches.length === 1) {
            const id = matches[0].id;
            await this.shutdown(id);
          }
        } catch (error) {
        }
      }
      /**
       * Find a session by id.
       */
      async findById(id) {
        if (this._models.has(id)) {
          return this._models.get(id);
        }
        await this.refreshRunning();
        return this._models.get(id);
      }
      /**
       * Find a session by path.
       */
      async findByPath(path2) {
        for (const m4 of this._models.values()) {
          if (m4.path === path2) {
            return m4;
          }
        }
        await this.refreshRunning();
        for (const m4 of this._models.values()) {
          if (m4.path === path2) {
            return m4;
          }
        }
        return void 0;
      }
      /**
       * Execute a request to the server to poll running kernels and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof serverconnection_1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        if (this._models.size === models.length && models.every((model) => {
          var _a2, _b2, _c, _d;
          const existing = this._models.get(model.id);
          if (!existing) {
            return false;
          }
          return ((_a2 = existing.kernel) === null || _a2 === void 0 ? void 0 : _a2.id) === ((_b2 = model.kernel) === null || _b2 === void 0 ? void 0 : _b2.id) && ((_c = existing.kernel) === null || _c === void 0 ? void 0 : _c.name) === ((_d = model.kernel) === null || _d === void 0 ? void 0 : _d.name) && existing.name === model.name && existing.path === model.path && existing.type === model.type;
        })) {
          return;
        }
        this._models = new Map(models.map((x4) => [x4.id, x4]));
        this._sessionConnections.forEach((sc) => {
          if (this._models.has(sc.id)) {
            sc.update(this._models.get(sc.id));
          } else {
            sc.dispose();
          }
        });
        this._runningChanged.emit(models);
      }
      /**
       * Handle a session starting.
       */
      _onStarted(sessionConnection) {
        this._sessionConnections.add(sessionConnection);
        sessionConnection.disposed.connect(this._onDisposed, this);
        sessionConnection.propertyChanged.connect(this._onChanged, this);
        sessionConnection.kernelChanged.connect(this._onChanged, this);
      }
      _onDisposed(sessionConnection) {
        this._sessionConnections.delete(sessionConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      _onChanged() {
        void this.refreshRunning().catch(() => {
        });
      }
    };
    exports2.SessionManager = SessionManager2;
    (function(SessionManager3) {
      class NoopManager extends SessionManager3 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * Start a new session - throw an error since it is not supported.
         */
        async startNew(createOptions, connectOptions = {}) {
          return Promise.reject(new Error("Not implemented in no-op Session Manager"));
        }
        /*
         * Connect to a running session - throw an error since it is not supported.
         */
        connectTo(options) {
          throw Error("Not implemented in no-op Session Manager");
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Shut down a session by id - throw an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Session Manager"));
        }
        /**
         * Execute a request to the server to poll running sessions and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      SessionManager3.NoopManager = NoopManager;
    })(SessionManager2 = exports2.SessionManager || (exports2.SessionManager = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/session/index.js
var require_session2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/session/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionAPI = exports2.Session = void 0;
    var Session = __importStar(require_session());
    exports2.Session = Session;
    var SessionAPI = __importStar(require_restapi3());
    exports2.SessionAPI = SessionAPI;
    __exportStar(require_manager3(), exports2);
  }
});

// ../../node_modules/@jupyterlab/statedb/lib/dataconnector.js
var require_dataconnector = __commonJS({
  "../../node_modules/@jupyterlab/statedb/lib/dataconnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DataConnector = void 0;
    var DataConnector = class {
      /**
       * Retrieve the list of items available from the data connector.
       *
       * @param query - The optional query filter to apply to the connector request.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can list.
       */
      async list(query) {
        throw new Error("DataConnector#list method has not been implemented.");
      }
      /**
       * Remove a value using the data connector.
       *
       * @param id - The identifier for the data being removed.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can remove.
       */
      async remove(id) {
        throw new Error("DataConnector#remove method has not been implemented.");
      }
      /**
       * Save a value using the data connector.
       *
       * @param id - The identifier for the data being saved.
       *
       * @param value - The data being saved.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can save.
       */
      async save(id, value) {
        throw new Error("DataConnector#save method has not been implemented.");
      }
    };
    exports2.DataConnector = DataConnector;
  }
});

// ../../node_modules/@jupyterlab/statedb/lib/interfaces.js
var require_interfaces2 = __commonJS({
  "../../node_modules/@jupyterlab/statedb/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/statedb/node_modules/@lumino/properties/dist/index.es6.js
var index_es6_exports4 = {};
__export(index_es6_exports4, {
  AttachedProperty: () => AttachedProperty
});
var AttachedProperty, Private;
var init_index_es68 = __esm({
  "../../node_modules/@jupyterlab/statedb/node_modules/@lumino/properties/dist/index.es6.js"() {
    AttachedProperty = class {
      /**
       * Construct a new attached property.
       *
       * @param options - The options for initializing the property.
       */
      constructor(options) {
        this._pid = Private.nextPID();
        this.name = options.name;
        this._create = options.create;
        this._coerce = options.coerce || null;
        this._compare = options.compare || null;
        this._changed = options.changed || null;
      }
      /**
       * Get the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @returns The current value of the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and assigned as the current value of the property.
       */
      get(owner) {
        let value;
        let map4 = Private.ensureMap(owner);
        if (this._pid in map4) {
          value = map4[this._pid];
        } else {
          value = map4[this._pid] = this._createValue(owner);
        }
        return value;
      }
      /**
       * Set the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @param value - The value for the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      set(owner, value) {
        let oldValue;
        let map4 = Private.ensureMap(owner);
        if (this._pid in map4) {
          oldValue = map4[this._pid];
        } else {
          oldValue = map4[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, value);
        this._maybeNotify(owner, oldValue, map4[this._pid] = newValue);
      }
      /**
       * Explicitly coerce the current property value for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      coerce(owner) {
        let oldValue;
        let map4 = Private.ensureMap(owner);
        if (this._pid in map4) {
          oldValue = map4[this._pid];
        } else {
          oldValue = map4[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, oldValue);
        this._maybeNotify(owner, oldValue, map4[this._pid] = newValue);
      }
      /**
       * Get or create the default value for the given owner.
       */
      _createValue(owner) {
        let create2 = this._create;
        return create2(owner);
      }
      /**
       * Coerce the value for the given owner.
       */
      _coerceValue(owner, value) {
        let coerce = this._coerce;
        return coerce ? coerce(owner, value) : value;
      }
      /**
       * Compare the old value and new value for equality.
       */
      _compareValue(oldValue, newValue) {
        let compare2 = this._compare;
        return compare2 ? compare2(oldValue, newValue) : oldValue === newValue;
      }
      /**
       * Run the change notification if the given values are different.
       */
      _maybeNotify(owner, oldValue, newValue) {
        let changed = this._changed;
        if (changed && !this._compareValue(oldValue, newValue)) {
          changed(owner, oldValue, newValue);
        }
      }
    };
    (function(AttachedProperty3) {
      function clearData(owner) {
        Private.ownerData.delete(owner);
      }
      AttachedProperty3.clearData = clearData;
    })(AttachedProperty || (AttachedProperty = {}));
    (function(Private19) {
      Private19.ownerData = /* @__PURE__ */ new WeakMap();
      Private19.nextPID = (() => {
        let id = 0;
        return () => {
          let rand = Math.random();
          let stem = `${rand}`.slice(2);
          return `pid-${stem}-${id++}`;
        };
      })();
      function ensureMap(owner) {
        let map4 = Private19.ownerData.get(owner);
        if (map4) {
          return map4;
        }
        map4 = /* @__PURE__ */ Object.create(null);
        Private19.ownerData.set(owner, map4);
        return map4;
      }
      Private19.ensureMap = ensureMap;
    })(Private || (Private = {}));
  }
});

// ../../node_modules/@jupyterlab/statedb/lib/restorablepool.js
var require_restorablepool = __commonJS({
  "../../node_modules/@jupyterlab/statedb/lib/restorablepool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestorablePool = void 0;
    var coreutils_12 = require_dist();
    var properties_1 = (init_index_es68(), __toCommonJS(index_es6_exports4));
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var RestorablePool = class {
      /**
       * Create a new restorable pool.
       *
       * @param options - The instantiation options for a restorable pool.
       */
      constructor(options) {
        this._added = new signaling_1.Signal(this);
        this._current = null;
        this._currentChanged = new signaling_1.Signal(this);
        this._hasRestored = false;
        this._isDisposed = false;
        this._objects = /* @__PURE__ */ new Set();
        this._restore = null;
        this._restored = new coreutils_12.PromiseDelegate();
        this._updated = new signaling_1.Signal(this);
        this.namespace = options.namespace;
      }
      /**
       * A signal emitted when an object object is added.
       *
       * #### Notes
       * This signal will only fire when an object is added to the pool.
       * It will not fire if an object injected into the pool.
       */
      get added() {
        return this._added;
      }
      /**
       * The current object.
       *
       * #### Notes
       * The restorable pool does not set `current`. It is intended for client use.
       *
       * If `current` is set to an object that does not exist in the pool, it is a
       * no-op.
       */
      get current() {
        return this._current;
      }
      set current(obj) {
        if (this._current === obj) {
          return;
        }
        if (obj !== null && this._objects.has(obj)) {
          this._current = obj;
          this._currentChanged.emit(this._current);
        }
      }
      /**
       * A signal emitted when the current widget changes.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * Test whether the pool is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * A promise resolved when the restorable pool has been restored.
       */
      get restored() {
        return this._restored.promise;
      }
      /**
       * The number of objects held by the pool.
       */
      get size() {
        return this._objects.size;
      }
      /**
       * A signal emitted when an object is updated.
       */
      get updated() {
        return this._updated;
      }
      /**
       * Add a new object to the pool.
       *
       * @param obj - The object object being added.
       *
       * #### Notes
       * The object passed into the pool is added synchronously; its existence in
       * the pool can be checked with the `has()` method. The promise this method
       * returns resolves after the object has been added and saved to an underlying
       * restoration connector, if one is available.
       */
      async add(obj) {
        var _a, _b;
        if (obj.isDisposed) {
          const warning = "A disposed object cannot be added.";
          console.warn(warning, obj);
          throw new Error(warning);
        }
        if (this._objects.has(obj)) {
          const warning = "This object already exists in the pool.";
          console.warn(warning, obj);
          throw new Error(warning);
        }
        this._objects.add(obj);
        obj.disposed.connect(this._onInstanceDisposed, this);
        if (Private19.injectedProperty.get(obj)) {
          return;
        }
        if (this._restore) {
          const { connector } = this._restore;
          const objName = this._restore.name(obj);
          if (objName) {
            const name2 = `${this.namespace}:${objName}`;
            const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
            Private19.nameProperty.set(obj, name2);
            await connector.save(name2, { data });
          }
        }
        this._added.emit(obj);
      }
      /**
       * Dispose of the resources held by the pool.
       *
       * #### Notes
       * Disposing a pool does not affect the underlying data in the data connector,
       * it simply disposes the client-side pool without making any connector calls.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._current = null;
        this._isDisposed = true;
        this._objects.clear();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Find the first object in the pool that satisfies a filter function.
       *
       * @param - fn The filter function to call on each object.
       */
      find(fn) {
        const values2 = this._objects.values();
        for (const value of values2) {
          if (fn(value)) {
            return value;
          }
        }
        return void 0;
      }
      /**
       * Iterate through each object in the pool.
       *
       * @param fn - The function to call on each object.
       */
      forEach(fn) {
        this._objects.forEach(fn);
      }
      /**
       * Filter the objects in the pool based on a predicate.
       *
       * @param fn - The function by which to filter.
       */
      filter(fn) {
        const filtered = [];
        this.forEach((obj) => {
          if (fn(obj)) {
            filtered.push(obj);
          }
        });
        return filtered;
      }
      /**
       * Inject an object into the restorable pool without the pool handling its
       * restoration lifecycle.
       *
       * @param obj - The object to inject into the pool.
       */
      inject(obj) {
        Private19.injectedProperty.set(obj, true);
        return this.add(obj);
      }
      /**
       * Check if this pool has the specified object.
       *
       * @param obj - The object whose existence is being checked.
       */
      has(obj) {
        return this._objects.has(obj);
      }
      /**
       * Restore the objects in this pool's namespace.
       *
       * @param options - The configuration options that describe restoration.
       *
       * @returns A promise that resolves when restoration has completed.
       *
       * #### Notes
       * This function should almost never be invoked by client code. Its primary
       * use case is to be invoked by a layout restorer plugin that handles
       * multiple restorable pools and, when ready, asks them each to restore their
       * respective objects.
       */
      async restore(options) {
        if (this._hasRestored) {
          throw new Error("This pool has already been restored.");
        }
        this._hasRestored = true;
        const { command, connector, registry, when } = options;
        const namespace = this.namespace;
        const promises = when ? [connector.list(namespace)].concat(when) : [connector.list(namespace)];
        this._restore = options;
        const [saved] = await Promise.all(promises);
        const values2 = await Promise.all(saved.ids.map(async (id, index2) => {
          const value = saved.values[index2];
          const args = value && value.data;
          if (args === void 0) {
            return connector.remove(id);
          }
          return registry.execute(command, args).catch(() => connector.remove(id));
        }));
        this._restored.resolve();
        return values2;
      }
      /**
       * Save the restore data for a given object.
       *
       * @param obj - The object being saved.
       */
      async save(obj) {
        var _a, _b;
        const injected = Private19.injectedProperty.get(obj);
        if (!this._restore || !this.has(obj) || injected) {
          return;
        }
        const { connector } = this._restore;
        const objName = this._restore.name(obj);
        const oldName = Private19.nameProperty.get(obj);
        const newName = objName ? `${this.namespace}:${objName}` : "";
        if (oldName && oldName !== newName) {
          await connector.remove(oldName);
        }
        Private19.nameProperty.set(obj, newName);
        if (newName) {
          const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
          await connector.save(newName, { data });
        }
        if (oldName !== newName) {
          this._updated.emit(obj);
        }
      }
      /**
       * Clean up after disposed objects.
       */
      _onInstanceDisposed(obj) {
        this._objects.delete(obj);
        if (obj === this._current) {
          this._current = null;
          this._currentChanged.emit(this._current);
        }
        if (Private19.injectedProperty.get(obj)) {
          return;
        }
        if (!this._restore) {
          return;
        }
        const { connector } = this._restore;
        const name2 = Private19.nameProperty.get(obj);
        if (name2) {
          void connector.remove(name2);
        }
      }
    };
    exports2.RestorablePool = RestorablePool;
    var Private19;
    (function(Private20) {
      Private20.injectedProperty = new properties_1.AttachedProperty({
        name: "injected",
        create: () => false
      });
      Private20.nameProperty = new properties_1.AttachedProperty({
        name: "name",
        create: () => ""
      });
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/statedb/lib/statedb.js
var require_statedb = __commonJS({
  "../../node_modules/@jupyterlab/statedb/lib/statedb.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StateDB = void 0;
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var StateDB = class {
      /**
       * Create a new state database.
       *
       * @param options - The instantiation options for a state database.
       */
      constructor(options = {}) {
        this._changed = new signaling_1.Signal(this);
        const { connector, transform } = options;
        this._connector = connector || new StateDB.Connector();
        if (!transform) {
          this._ready = Promise.resolve(void 0);
        } else {
          this._ready = transform.then((transformation) => {
            const { contents, type: type2 } = transformation;
            switch (type2) {
              case "cancel":
                return;
              case "clear":
                return this._clear();
              case "merge":
                return this._merge(contents || {});
              case "overwrite":
                return this._overwrite(contents || {});
              default:
                return;
            }
          });
        }
      }
      /**
       * A signal that emits the change type any time a value changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Clear the entire database.
       */
      async clear() {
        await this._ready;
        await this._clear();
      }
      /**
       * Retrieve a saved bundle from the database.
       *
       * @param id - The identifier used to retrieve a data bundle.
       *
       * @returns A promise that bears a data payload if available.
       *
       * #### Notes
       * The `id` values of stored items in the state database are formatted:
       * `'namespace:identifier'`, which is the same convention that command
       * identifiers in JupyterLab use as well. While this is not a technical
       * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
       * using the `list(namespace: string)` method.
       *
       * The promise returned by this method may be rejected if an error occurs in
       * retrieving the data. Non-existence of an `id` will succeed with the `value`
       * `undefined`.
       */
      async fetch(id) {
        await this._ready;
        return this._fetch(id);
      }
      /**
       * Retrieve all the saved bundles for a namespace.
       *
       * @param filter - The namespace prefix to retrieve.
       *
       * @returns A promise that bears a collection of payloads for a namespace.
       *
       * #### Notes
       * Namespaces are entirely conventional entities. The `id` values of stored
       * items in the state database are formatted: `'namespace:identifier'`, which
       * is the same convention that command identifiers in JupyterLab use as well.
       *
       * If there are any errors in retrieving the data, they will be logged to the
       * console in order to optimistically return any extant data without failing.
       * This promise will always succeed.
       */
      async list(namespace) {
        await this._ready;
        return this._list(namespace);
      }
      /**
       * Remove a value from the database.
       *
       * @param id - The identifier for the data being removed.
       *
       * @returns A promise that is rejected if remove fails and succeeds otherwise.
       */
      async remove(id) {
        await this._ready;
        await this._remove(id);
        this._changed.emit({ id, type: "remove" });
      }
      /**
       * Save a value in the database.
       *
       * @param id - The identifier for the data being saved.
       *
       * @param value - The data being saved.
       *
       * @returns A promise that is rejected if saving fails and succeeds otherwise.
       *
       * #### Notes
       * The `id` values of stored items in the state database are formatted:
       * `'namespace:identifier'`, which is the same convention that command
       * identifiers in JupyterLab use as well. While this is not a technical
       * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
       * using the `list(namespace: string)` method.
       */
      async save(id, value) {
        await this._ready;
        await this._save(id, value);
        this._changed.emit({ id, type: "save" });
      }
      /**
       * Return a serialized copy of the state database's entire contents.
       *
       * @returns A promise that resolves with the database contents as JSON.
       */
      async toJSON() {
        await this._ready;
        const { ids, values: values2 } = await this._list();
        return values2.reduce((acc, val, idx) => {
          acc[ids[idx]] = val;
          return acc;
        }, {});
      }
      /**
       * Clear the entire database.
       */
      async _clear() {
        await Promise.all((await this._list()).ids.map((id) => this._remove(id)));
      }
      /**
       * Fetch a value from the database.
       */
      async _fetch(id) {
        const value = await this._connector.fetch(id);
        if (value) {
          return JSON.parse(value).v;
        }
      }
      /**
       * Fetch a list from the database.
       */
      async _list(namespace = "") {
        const { ids, values: values2 } = await this._connector.list(namespace);
        return {
          ids,
          values: values2.map((val) => JSON.parse(val).v)
        };
      }
      /**
       * Merge data into the state database.
       */
      async _merge(contents) {
        await Promise.all(Object.keys(contents).map((key) => contents[key] && this._save(key, contents[key])));
      }
      /**
       * Overwrite the entire database with new contents.
       */
      async _overwrite(contents) {
        await this._clear();
        await this._merge(contents);
      }
      /**
       * Remove a key in the database.
       */
      async _remove(id) {
        return this._connector.remove(id);
      }
      /**
       * Save a key and its value in the database.
       */
      async _save(id, value) {
        return this._connector.save(id, JSON.stringify({ v: value }));
      }
    };
    exports2.StateDB = StateDB;
    (function(StateDB2) {
      class Connector {
        constructor() {
          this._storage = {};
        }
        /**
         * Retrieve an item from the data connector.
         */
        async fetch(id) {
          return this._storage[id];
        }
        /**
         * Retrieve the list of items available from the data connector.
         *
         * @param namespace - If not empty, only keys whose first token before `:`
         * exactly match `namespace` will be returned, e.g. `foo` in `foo:bar`.
         */
        async list(namespace = "") {
          return Object.keys(this._storage).reduce((acc, val) => {
            if (namespace === "" ? true : namespace === val.split(":")[0]) {
              acc.ids.push(val);
              acc.values.push(this._storage[val]);
            }
            return acc;
          }, { ids: [], values: [] });
        }
        /**
         * Remove a value using the data connector.
         */
        async remove(id) {
          delete this._storage[id];
        }
        /**
         * Save a value using the data connector.
         */
        async save(id, value) {
          this._storage[id] = value;
        }
      }
      StateDB2.Connector = Connector;
    })(StateDB = exports2.StateDB || (exports2.StateDB = {}));
  }
});

// ../../node_modules/@jupyterlab/statedb/lib/tokens.js
var require_tokens = __commonJS({
  "../../node_modules/@jupyterlab/statedb/lib/tokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IStateDB = void 0;
    var coreutils_12 = require_dist();
    exports2.IStateDB = new coreutils_12.Token("@jupyterlab/coreutils:IStateDB", `A service for the JupyterLab state database.
  Use this if you want to store data that will persist across page loads.
  See "state database" for more information.`);
  }
});

// ../../node_modules/@jupyterlab/statedb/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/@jupyterlab/statedb/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_dataconnector(), exports2);
    __exportStar(require_interfaces2(), exports2);
    __exportStar(require_restorablepool(), exports2);
    __exportStar(require_statedb(), exports2);
    __exportStar(require_tokens(), exports2);
  }
});

// ../../node_modules/@jupyterlab/services/lib/setting/index.js
var require_setting = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/setting/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SettingManager = void 0;
    var coreutils_12 = require_lib2();
    var statedb_1 = require_lib3();
    var serverconnection_1 = require_serverconnection();
    var SERVICE_SETTINGS_URL = "api/settings";
    var SettingManager = class extends statedb_1.DataConnector {
      /**
       * Create a new setting manager.
       */
      constructor(options = {}) {
        var _a;
        super();
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch a plugin's settings.
       *
       * @param id - The plugin's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async fetch(id) {
        if (!id) {
          throw new Error("Plugin `id` parameter is required for settings fetch.");
        }
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private19.url(base, id);
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        return response.json();
      }
      /**
       * Fetch the list of all plugin setting bundles.
       *
       * @returns A promise that resolves if successful.
       */
      async list(query) {
        var _a, _b, _c, _d;
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private19.url(base, "", query === "ids");
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          throw new ResponseError(response);
        }
        const json2 = await response.json();
        const ids = (_b = (_a = json2 === null || json2 === void 0 ? void 0 : json2["settings"]) === null || _a === void 0 ? void 0 : _a.map((plugin) => plugin.id)) !== null && _b !== void 0 ? _b : [];
        let values2 = [];
        if (!query) {
          values2 = (_d = (_c = json2 === null || json2 === void 0 ? void 0 : json2["settings"]) === null || _c === void 0 ? void 0 : _c.map((plugin) => {
            plugin.data = { composite: {}, user: {} };
            return plugin;
          })) !== null && _d !== void 0 ? _d : [];
        }
        return { ids, values: values2 };
      }
      /**
       * Save a plugin's settings.
       *
       * @param id - The plugin's ID.
       *
       * @param raw - The user setting values as a raw string of JSON with comments.
       *
       * @returns A promise that resolves if successful.
       */
      async save(id, raw) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private19.url(base, id);
        const init = { body: JSON.stringify({ raw }), method: "PUT" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          throw new ResponseError(response);
        }
      }
    };
    exports2.SettingManager = SettingManager;
    var Private19;
    (function(Private20) {
      function url(base, id, idsOnly) {
        const idsOnlyParam = idsOnly ? coreutils_12.URLExt.objectToQueryString({ ids_only: true }) : "";
        return `${coreutils_12.URLExt.join(base, SERVICE_SETTINGS_URL, id)}${idsOnlyParam}`;
      }
      Private20.url = url;
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/terminal/restapi.js
var require_restapi4 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/terminal/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shutdownTerminal = exports2.listRunning = exports2.startNew = exports2.isAvailable = exports2.TERMINAL_SERVICE_URL = void 0;
    var coreutils_12 = require_lib2();
    var serverconnection_1 = require_serverconnection();
    exports2.TERMINAL_SERVICE_URL = "api/terminals";
    function isAvailable() {
      const available = String(coreutils_12.PageConfig.getOption("terminalsAvailable"));
      return available.toLowerCase() === "true";
    }
    exports2.isAvailable = isAvailable;
    async function startNew(settings = serverconnection_1.ServerConnection.makeSettings(), name2, cwd) {
      Private19.errorIfNotAvailable();
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify({ name: name2, cwd })
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      return data;
    }
    exports2.startNew = startNew;
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      Private19.errorIfNotAvailable();
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error("Invalid terminal list");
      }
      return data;
    }
    exports2.listRunning = listRunning;
    async function shutdownTerminal(name2, settings = serverconnection_1.ServerConnection.makeSettings()) {
      var _a;
      Private19.errorIfNotAvailable();
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL, name2);
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const data = await response.json();
        const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The terminal session "${name2}"" does not exist on the server`;
        console.warn(msg);
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownTerminal = shutdownTerminal;
    var Private19;
    (function(Private20) {
      function errorIfNotAvailable() {
        if (!isAvailable()) {
          throw new Error("Terminals Unavailable");
        }
      }
      Private20.errorIfNotAvailable = errorIfNotAvailable;
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/terminal/terminal.js
var require_terminal = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/terminal/terminal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAvailable = void 0;
    var restapi_1 = require_restapi4();
    Object.defineProperty(exports2, "isAvailable", { enumerable: true, get: function() {
      return restapi_1.isAvailable;
    } });
  }
});

// ../../node_modules/@jupyterlab/services/lib/terminal/default.js
var require_default3 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/terminal/default.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalConnection = void 0;
    var coreutils_12 = require_lib2();
    var coreutils_2 = require_dist();
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var __1 = require_lib4();
    var restapi_1 = require_restapi4();
    var TerminalConnection = class {
      /**
       * Construct a new terminal session.
       */
      constructor(options) {
        var _a;
        this._createSocket = () => {
          this._errorIfDisposed();
          this._clearSocket();
          this._updateConnectionStatus("connecting");
          const name2 = this._name;
          const settings = this.serverSettings;
          let url = coreutils_12.URLExt.join(settings.wsUrl, "terminals", "websocket", encodeURIComponent(name2));
          const token = settings.token;
          if (settings.appendToken && token !== "") {
            url = url + `?token=${encodeURIComponent(token)}`;
          }
          this._ws = new settings.WebSocket(url);
          this._ws.onmessage = this._onWSMessage;
          this._ws.onclose = this._onWSClose;
          this._ws.onerror = this._onWSClose;
        };
        this._onWSMessage = (event) => {
          if (this._isDisposed) {
            return;
          }
          const data = JSON.parse(event.data);
          if (data[0] === "disconnect") {
            this.dispose();
          }
          if (this._connectionStatus === "connecting") {
            if (data[0] === "setup") {
              this._updateConnectionStatus("connected");
            }
            return;
          }
          this._messageReceived.emit({
            type: data[0],
            content: data.slice(1)
          });
        };
        this._onWSClose = (event) => {
          console.warn(`Terminal websocket closed: ${event.code}`);
          if (!this.isDisposed) {
            this._reconnect();
          }
        };
        this._connectionStatus = "connecting";
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this._messageReceived = new signaling_1.Signal(this);
        this._reconnectTimeout = null;
        this._ws = null;
        this._noOp = () => {
        };
        this._reconnectLimit = 7;
        this._reconnectAttempt = 0;
        this._pendingMessages = [];
        this._name = options.model.name;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._createSocket();
      }
      /**
       * A signal emitted when the session is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when a message is received from the server.
       */
      get messageReceived() {
        return this._messageReceived;
      }
      /**
       * Get the name of the terminal session.
       */
      get name() {
        return this._name;
      }
      /**
       * Get the model for the terminal session.
       */
      get model() {
        return { name: this._name };
      }
      /**
       * Test whether the session is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the session.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        this._updateConnectionStatus("disconnected");
        this._clearSocket();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Send a message to the terminal session.
       *
       * #### Notes
       * If the connection is down, the message will be queued for sending when
       * the connection comes back up.
       */
      send(message) {
        this._sendMessage(message);
      }
      /**
       * Send a message on the websocket, or possibly queue for later sending.
       *
       * @param queue - whether to queue the message if it cannot be sent
       */
      _sendMessage(message, queue = true) {
        if (this._isDisposed || !message.content) {
          return;
        }
        if (this.connectionStatus === "connected" && this._ws) {
          const msg = [message.type, ...message.content];
          this._ws.send(JSON.stringify(msg));
        } else if (queue) {
          this._pendingMessages.push(message);
        } else {
          throw new Error(`Could not send message: ${JSON.stringify(message)}`);
        }
      }
      /**
       * Send pending messages to the kernel.
       */
      _sendPending() {
        while (this.connectionStatus === "connected" && this._pendingMessages.length > 0) {
          this._sendMessage(this._pendingMessages[0], false);
          this._pendingMessages.shift();
        }
      }
      /**
       * Reconnect to a terminal.
       *
       * #### Notes
       * This may try multiple times to reconnect to a terminal, and will sever
       * any existing connection.
       */
      reconnect() {
        this._errorIfDisposed();
        const result2 = new coreutils_2.PromiseDelegate();
        const fulfill = (sender, status) => {
          if (status === "connected") {
            result2.resolve();
            this.connectionStatusChanged.disconnect(fulfill, this);
          } else if (status === "disconnected") {
            result2.reject(new Error("Terminal connection disconnected"));
            this.connectionStatusChanged.disconnect(fulfill, this);
          }
        };
        this.connectionStatusChanged.connect(fulfill, this);
        this._reconnectAttempt = 0;
        this._reconnect();
        return result2.promise;
      }
      /**
       * Attempt a connection if we have not exhausted connection attempts.
       */
      _reconnect() {
        this._errorIfDisposed();
        clearTimeout(this._reconnectTimeout);
        if (this._reconnectAttempt < this._reconnectLimit) {
          this._updateConnectionStatus("connecting");
          const timeout = Private19.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
          console.error(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`);
          this._reconnectTimeout = setTimeout(this._createSocket, timeout);
          this._reconnectAttempt += 1;
        } else {
          this._updateConnectionStatus("disconnected");
        }
        this._clearSocket();
      }
      /**
       * Forcefully clear the socket state.
       *
       * #### Notes
       * This will clear all socket state without calling any handlers and will
       * not update the connection status. If you call this method, you are
       * responsible for updating the connection status as needed and recreating
       * the socket if you plan to reconnect.
       */
      _clearSocket() {
        if (this._ws !== null) {
          this._ws.onopen = this._noOp;
          this._ws.onclose = this._noOp;
          this._ws.onerror = this._noOp;
          this._ws.onmessage = this._noOp;
          this._ws.close();
          this._ws = null;
        }
      }
      /**
       * Shut down the terminal session.
       */
      async shutdown() {
        await (0, restapi_1.shutdownTerminal)(this.name, this.serverSettings);
        this.dispose();
      }
      /**
       * Clone the current terminal connection.
       */
      clone() {
        return new TerminalConnection(this);
      }
      /**
       * Handle connection status changes.
       */
      _updateConnectionStatus(connectionStatus) {
        if (this._connectionStatus === connectionStatus) {
          return;
        }
        this._connectionStatus = connectionStatus;
        if (connectionStatus !== "connecting") {
          this._reconnectAttempt = 0;
          clearTimeout(this._reconnectTimeout);
        }
        if (connectionStatus === "connected") {
          this._sendPending();
        }
        this._connectionStatusChanged.emit(connectionStatus);
      }
      /**
       * Utility function to throw an error if this instance is disposed.
       */
      _errorIfDisposed() {
        if (this.isDisposed) {
          throw new Error("Terminal connection is disposed");
        }
      }
      /**
       * A signal emitted when the terminal connection status changes.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * The current connection status of the terminal connection.
       */
      get connectionStatus() {
        return this._connectionStatus;
      }
    };
    exports2.TerminalConnection = TerminalConnection;
    var Private19;
    (function(Private20) {
      function getTermUrl(baseUrl, name2) {
        return coreutils_12.URLExt.join(baseUrl, restapi_1.TERMINAL_SERVICE_URL, encodeURIComponent(name2));
      }
      Private20.getTermUrl = getTermUrl;
      function getRandomIntInclusive(min3, max3) {
        min3 = Math.ceil(min3);
        max3 = Math.floor(max3);
        return Math.floor(Math.random() * (max3 - min3 + 1)) + min3;
      }
      Private20.getRandomIntInclusive = getRandomIntInclusive;
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/terminal/manager.js
var require_manager4 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/terminal/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalManager = void 0;
    var polling_1 = (init_index_es62(), __toCommonJS(index_es6_exports2));
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var __1 = require_lib4();
    var basemanager_1 = require_basemanager();
    var restapi_1 = require_restapi4();
    var default_1 = require_default3();
    var TerminalManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new terminal manager.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._names = [];
        this._terminalConnections = /* @__PURE__ */ new Set();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        if (!this.isAvailable()) {
          this._ready = Promise.reject("Terminals unavailable");
          this._ready.catch((_5) => void 0);
          return;
        }
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:TerminalManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running terminals change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._names.length = 0;
        this._terminalConnections.forEach((x4) => x4.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /**
       * Whether the terminal service is available.
       */
      isAvailable() {
        return (0, restapi_1.isAvailable)();
      }
      /*
       * Connect to a running terminal.
       *
       * @param options - The options used to connect to the terminal.
       *
       * @returns The new terminal connection instance.
       *
       * #### Notes
       * The manager `serverSettings` will be used.
       */
      connectTo(options) {
        const terminalConnection = new default_1.TerminalConnection({
          ...options,
          serverSettings: this.serverSettings
        });
        this._onStarted(terminalConnection);
        if (!this._names.includes(options.model.name)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return terminalConnection;
      }
      /**
       * Create an iterator over the most recent running terminals.
       *
       * @returns A new iterator over the running terminals.
       */
      running() {
        return this._models[Symbol.iterator]();
      }
      /**
       * Force a refresh of the running terminals.
       *
       * @returns A promise that with the list of running terminals.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Create a new terminal session.
       *
       * @param options - The options used to create the terminal.
       *
       * @returns A promise that resolves with the terminal connection instance.
       *
       * #### Notes
       * The manager `serverSettings` will be used unless overridden in the
       * options.
       */
      async startNew(options) {
        const model = await (0, restapi_1.startNew)(this.serverSettings, options === null || options === void 0 ? void 0 : options.name, options === null || options === void 0 ? void 0 : options.cwd);
        await this.refreshRunning();
        return this.connectTo({ model });
      }
      /**
       * Shut down a terminal session by name.
       */
      async shutdown(name2) {
        await (0, restapi_1.shutdownTerminal)(name2, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all terminal sessions.
       *
       * @returns A promise that resolves when all of the sessions are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all(this._names.map((name2) => (0, restapi_1.shutdownTerminal)(name2, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Execute a request to the server to poll running terminals and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof __1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        const names = models.map(({ name: name2 }) => name2).sort();
        if (names === this._names) {
          return;
        }
        this._names = names;
        this._terminalConnections.forEach((tc) => {
          if (!names.includes(tc.name)) {
            tc.dispose();
          }
        });
        this._runningChanged.emit(this._models);
      }
      /**
       * Handle a session starting.
       */
      _onStarted(terminalConnection) {
        this._terminalConnections.add(terminalConnection);
        terminalConnection.disposed.connect(this._onDisposed, this);
      }
      /**
       * Handle a session terminating.
       */
      _onDisposed(terminalConnection) {
        this._terminalConnections.delete(terminalConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      get _models() {
        return this._names.map((name2) => {
          return { name: name2 };
        });
      }
    };
    exports2.TerminalManager = TerminalManager;
    (function(TerminalManager2) {
      class NoopManager extends TerminalManager2 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Create a new terminal session - throw an error since it is not supported.
         *
         */
        async startNew(options) {
          return Promise.reject(new Error("Not implemented in no-op Terminal Manager"));
        }
        /*
         * Connect to a running terminal - throw an error since it is not supported.
         */
        connectTo(options) {
          throw Error("Not implemented in no-op Terminal Manager");
        }
        /**
         * Shut down a session by id - throw an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Terminal Manager"));
        }
        /**
         * Execute a request to the server to poll running sessions and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      TerminalManager2.NoopManager = NoopManager;
    })(TerminalManager = exports2.TerminalManager || (exports2.TerminalManager = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/terminal/index.js
var require_terminal2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/terminal/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalAPI = exports2.Terminal = void 0;
    var Terminal = __importStar(require_terminal());
    exports2.Terminal = Terminal;
    var TerminalAPI = __importStar(require_restapi4());
    exports2.TerminalAPI = TerminalAPI;
    __exportStar(require_manager4(), exports2);
  }
});

// ../../node_modules/@jupyterlab/services/lib/user/index.js
var require_user = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/user/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserManager = void 0;
    var coreutils_12 = require_lib2();
    var coreutils_2 = require_dist();
    var polling_1 = (init_index_es62(), __toCommonJS(index_es6_exports2));
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var serverconnection_1 = require_serverconnection();
    var basemanager_1 = require_basemanager();
    var SERVICE_USER_URL = "api/me";
    var SERVICE_ID = "@jupyterlab/services:UserManager#user";
    var UserManager = class extends basemanager_1.BaseManager {
      /**
       * Create a new user manager.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._userChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._ready = this.requestUser().then(() => {
          if (this.isDisposed) {
            return;
          }
          this._isReady = true;
        }).catch((_5) => (
          // Return a promise that will never resolve, so user service is never ready
          // This typically occurs when the backend has no user service
          new Promise(() => {
          })
        ));
        this._pollSpecs = new polling_1.Poll({
          auto: false,
          factory: () => this.requestUser(),
          frequency: {
            interval: 61 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: SERVICE_ID,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        void this.ready.then(() => {
          void this._pollSpecs.start();
        });
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * Get the most recently fetched identity.
       */
      get identity() {
        return this._identity;
      }
      /**
       * Get the most recently fetched permissions.
       */
      get permissions() {
        return this._permissions;
      }
      /**
       * A signal emitted when the user changes.
       */
      get userChanged() {
        return this._userChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        this._pollSpecs.dispose();
        super.dispose();
      }
      /**
       * Force a refresh of the specs from the server.
       *
       * @returns A promise that resolves when the specs are fetched.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshUser() {
        await this._pollSpecs.refresh();
        await this._pollSpecs.tick;
      }
      /**
       * Execute a request to the server to poll the user and update state.
       */
      async requestUser() {
        if (this.isDisposed) {
          return;
        }
        const { baseUrl } = this.serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const url = coreutils_12.URLExt.join(baseUrl, SERVICE_USER_URL);
        const response = await makeRequest(url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        const oldUser = {
          identity: this._identity,
          permissions: this._permissions
        };
        const newUser = await response.json();
        const identity2 = newUser.identity;
        const { localStorage } = window;
        const data = localStorage.getItem(SERVICE_ID);
        if (data && (!identity2.initials || !identity2.color)) {
          const localUser = JSON.parse(data);
          identity2.initials = identity2.initials || localUser.initials || identity2.name.substring(0, 1);
          identity2.color = identity2.color || localUser.color || Private19.getRandomColor();
        }
        if (!coreutils_2.JSONExt.deepEqual(newUser, oldUser)) {
          this._identity = identity2;
          this._permissions = newUser.permissions;
          localStorage.setItem(SERVICE_ID, JSON.stringify(identity2));
          this._userChanged.emit(newUser);
        }
      }
    };
    exports2.UserManager = UserManager;
    var Private19;
    (function(Private20) {
      const userColors = [
        "var(--jp-collaborator-color1)",
        "var(--jp-collaborator-color2)",
        "var(--jp-collaborator-color3)",
        "var(--jp-collaborator-color4)",
        "var(--jp-collaborator-color5)",
        "var(--jp-collaborator-color6)",
        "var(--jp-collaborator-color7)"
      ];
      Private20.getRandomColor = () => userColors[Math.floor(Math.random() * userColors.length)];
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/workspace/index.js
var require_workspace = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/workspace/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceManager = void 0;
    var coreutils_12 = require_lib2();
    var statedb_1 = require_lib3();
    var serverconnection_1 = require_serverconnection();
    var SERVICE_WORKSPACES_URL = "api/workspaces";
    var WorkspaceManager = class extends statedb_1.DataConnector {
      /**
       * Create a new workspace manager.
       */
      constructor(options = {}) {
        var _a;
        super();
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch a workspace.
       *
       * @param id - The workspace's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async fetch(id) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private19.url(base, id);
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        return response.json();
      }
      /**
       * Fetch the list of workspace IDs that exist on the server.
       *
       * @returns A promise that resolves if successful.
       */
      async list() {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private19.url(base, "");
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        const result2 = await response.json();
        return result2.workspaces;
      }
      /**
       * Remove a workspace from the server.
       *
       * @param id - The workspaces's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async remove(id) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private19.url(base, id);
        const init = { method: "DELETE" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          const err = await ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Save a workspace.
       *
       * @param id - The workspace's ID.
       *
       * @param workspace - The workspace being saved.
       *
       * @returns A promise that resolves if successful.
       */
      async save(id, workspace) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private19.url(base, id);
        const init = { body: JSON.stringify(workspace), method: "PUT" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          const err = await ResponseError.create(response);
          throw err;
        }
      }
    };
    exports2.WorkspaceManager = WorkspaceManager;
    var Private19;
    (function(Private20) {
      function url(base, id) {
        return coreutils_12.URLExt.join(base, SERVICE_WORKSPACES_URL, id);
      }
      Private20.url = url;
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/manager.js
var require_manager5 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServiceManager = void 0;
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var builder_1 = require_builder();
    var contents_1 = require_contents();
    var event_1 = require_event();
    var kernel_1 = require_kernel2();
    var kernelspec_1 = require_kernelspec2();
    var nbconvert_1 = require_nbconvert();
    var serverconnection_1 = require_serverconnection();
    var session_1 = require_session2();
    var setting_1 = require_setting();
    var terminal_1 = require_terminal2();
    var user_1 = require_user();
    var workspace_1 = require_workspace();
    var ServiceManager = class {
      /**
       * Construct a new services provider.
       */
      constructor(options = {}) {
        var _a, _b;
        this._isDisposed = false;
        this._connectionFailure = new signaling_1.Signal(this);
        this._isReady = false;
        const defaultDrive = options.defaultDrive;
        const serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        const standby = (_b = options.standby) !== null && _b !== void 0 ? _b : "when-hidden";
        const normalized = { defaultDrive, serverSettings, standby };
        this.serverSettings = serverSettings;
        this.contents = options.contents || new contents_1.ContentsManager(normalized);
        this.events = options.events || new event_1.EventManager(normalized);
        this.kernels = options.kernels || new kernel_1.KernelManager(normalized);
        this.sessions = options.sessions || new session_1.SessionManager({
          ...normalized,
          kernelManager: this.kernels
        });
        this.settings = options.settings || new setting_1.SettingManager(normalized);
        this.terminals = options.terminals || new terminal_1.TerminalManager(normalized);
        this.builder = options.builder || new builder_1.BuildManager(normalized);
        this.workspaces = options.workspaces || new workspace_1.WorkspaceManager(normalized);
        this.nbconvert = options.nbconvert || new nbconvert_1.NbConvertManager(normalized);
        this.kernelspecs = options.kernelspecs || new kernelspec_1.KernelSpecManager(normalized);
        this.user = options.user || new user_1.UserManager(normalized);
        this.kernelspecs.connectionFailure.connect(this._onConnectionFailure, this);
        this.sessions.connectionFailure.connect(this._onConnectionFailure, this);
        this.terminals.connectionFailure.connect(this._onConnectionFailure, this);
        const readyList = [this.sessions.ready, this.kernelspecs.ready];
        if (this.terminals.isAvailable()) {
          readyList.push(this.terminals.ready);
        }
        this._readyPromise = Promise.all(readyList).then(() => {
          this._isReady = true;
        });
      }
      /**
       * A signal emitted when there is a connection failure with the kernel.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Test whether the service manager is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
        this.contents.dispose();
        this.events.dispose();
        this.sessions.dispose();
        this.terminals.dispose();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._readyPromise;
      }
      _onConnectionFailure(sender, err) {
        this._connectionFailure.emit(err);
      }
    };
    exports2.ServiceManager = ServiceManager;
  }
});

// ../../node_modules/@jupyterlab/services/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_basemanager(), exports2);
    __exportStar(require_config(), exports2);
    __exportStar(require_contents(), exports2);
    __exportStar(require_event(), exports2);
    __exportStar(require_kernel2(), exports2);
    __exportStar(require_kernelspec2(), exports2);
    __exportStar(require_manager5(), exports2);
    __exportStar(require_serverconnection(), exports2);
    __exportStar(require_session2(), exports2);
    __exportStar(require_setting(), exports2);
    __exportStar(require_terminal2(), exports2);
    __exportStar(require_user(), exports2);
    __exportStar(require_workspace(), exports2);
    __exportStar(require_nbconvert(), exports2);
  }
});

// ../../node_modules/thebe-core/dist/esm/sessions.js
function updateLastUsedTimestamp(storageKey) {
  const saved = window.localStorage.getItem(storageKey);
  if (!saved)
    return;
  const obj = JSON.parse(saved);
  window.localStorage.setItem(storageKey, JSON.stringify(Object.assign(Object.assign({}, obj), { lastUsed: /* @__PURE__ */ new Date() })));
}
function saveServerInfo(storageKey, id, serverSettings) {
  try {
    const { baseUrl, token, wsUrl } = serverSettings;
    window.localStorage.setItem(storageKey, JSON.stringify({
      id,
      baseUrl,
      token,
      wsUrl,
      lastUsed: /* @__PURE__ */ new Date()
    }));
  } catch (e4) {
    console.warn("Couldn't save thebe binder connection info to local storage", e4);
  }
}
function getExistingServer(savedSessionOptions, storageKey) {
  return __awaiter(this, void 0, void 0, function* () {
    if (!savedSessionOptions.enabled)
      return null;
    const storedInfoJSON = window.localStorage.getItem(storageKey);
    if (storedInfoJSON == null) {
      console.debug("thebe:getExistingServer No session saved in ", storageKey);
      return null;
    }
    console.debug("thebe:getExistingServer Saved binder session found");
    const existingSettings = JSON.parse(storedInfoJSON !== null && storedInfoJSON !== void 0 ? storedInfoJSON : "");
    const lastUsed = new Date(existingSettings.lastUsed);
    const now = /* @__PURE__ */ new Date();
    const ageSeconds = (now.getTime() - lastUsed.getTime()) / 1e3;
    if (ageSeconds > savedSessionOptions.maxAge) {
      console.debug(`thebe:getExistingServer Not using expired binder session for ${existingSettings.baseUrl} from ${lastUsed}`);
      window.localStorage.removeItem(storageKey);
      return null;
    }
    try {
      yield import_services.KernelAPI.listRunning(import_services.ServerConnection.makeSettings(existingSettings));
    } catch (err) {
      console.debug("thebe:getExistingServer Saved binder connection appears to be invalid, requesting new session", err);
      window.localStorage.removeItem(storageKey);
      return null;
    }
    updateLastUsedTimestamp(storageKey);
    console.debug(`thebe:getExistingServer Saved binder session is valid and will be reused ${existingSettings.baseUrl}`);
    return existingSettings;
  });
}
function clearAllSavedSessions(storagePrefix = "thebe-binder") {
  const keysToRemove = [];
  for (let i5 = 0; i5 < window.localStorage.length; i5++) {
    const key = window.localStorage.key(i5);
    if (key === null || key === void 0 ? void 0 : key.startsWith(storagePrefix)) {
      keysToRemove.push(key);
    }
  }
  console.debug(`thebe:clearAllSavedSessions - removing ${keysToRemove.length} saved sessions`, keysToRemove.join(","));
  keysToRemove.forEach((key) => window.localStorage.removeItem(key));
}
function clearSavedSession(storageKey) {
  console.debug(`thebe:clearSavedSession - removing ${storageKey}`);
  window.localStorage.removeItem(storageKey);
}
var import_services;
var init_sessions = __esm({
  "../../node_modules/thebe-core/dist/esm/sessions.js"() {
    init_tslib_es6();
    import_services = __toESM(require_lib4());
  }
});

// ../../node_modules/thebe-core/dist/esm/events.js
function errorToMessage(json2) {
  var _a;
  if (!json2.traceback) {
    return json2.evalue;
  } else if (Array.isArray(json2.traceback)) {
    return `${json2.evalue}
${((_a = json2.traceback) !== null && _a !== void 0 ? _a : []).join("")}`;
  } else {
    return `${json2.evalue}
${JSON.stringify(json2.traceback)}`;
  }
}
var ServerStatusEvent, SessionStatusEvent, KernelStatusEvent, NotebookStatusEvent, CellStatusEvent, EventSubject, ErrorStatusEvent, ThebeEventType, ThebeEvents;
var init_events = __esm({
  "../../node_modules/thebe-core/dist/esm/events.js"() {
    (function(ServerStatusEvent2) {
      ServerStatusEvent2["launching"] = "launching";
      ServerStatusEvent2["ready"] = "server-ready";
      ServerStatusEvent2["closed"] = "closed";
      ServerStatusEvent2["unknown"] = "unknown";
    })(ServerStatusEvent || (ServerStatusEvent = {}));
    (function(SessionStatusEvent2) {
      SessionStatusEvent2["starting"] = "starting";
      SessionStatusEvent2["ready"] = "ready";
      SessionStatusEvent2["shutdown"] = "shutdown";
    })(SessionStatusEvent || (SessionStatusEvent = {}));
    (function(KernelStatusEvent2) {
      KernelStatusEvent2["starting"] = "starting";
      KernelStatusEvent2["ready"] = "ready";
      KernelStatusEvent2["shutdown"] = "shutdown";
    })(KernelStatusEvent || (KernelStatusEvent = {}));
    (function(NotebookStatusEvent2) {
      NotebookStatusEvent2["attached"] = "attached";
      NotebookStatusEvent2["detached"] = "detached";
      NotebookStatusEvent2["executing"] = "executing";
      NotebookStatusEvent2["idle"] = "idle";
    })(NotebookStatusEvent || (NotebookStatusEvent = {}));
    (function(CellStatusEvent2) {
      CellStatusEvent2["attached"] = "attached";
      CellStatusEvent2["detached"] = "detached";
      CellStatusEvent2["executing"] = "executing";
      CellStatusEvent2["idle"] = "idle";
    })(CellStatusEvent || (CellStatusEvent = {}));
    (function(EventSubject2) {
      EventSubject2["server"] = "server";
      EventSubject2["session"] = "session";
      EventSubject2["kernel"] = "kernel";
      EventSubject2["notebook"] = "notebook";
      EventSubject2["cell"] = "cell";
    })(EventSubject || (EventSubject = {}));
    (function(ErrorStatusEvent2) {
      ErrorStatusEvent2["warning"] = "warning";
      ErrorStatusEvent2["executeError"] = "execute-error";
      ErrorStatusEvent2["error"] = "error";
      ErrorStatusEvent2["server"] = "server-error";
      ErrorStatusEvent2["session"] = "session-error";
    })(ErrorStatusEvent || (ErrorStatusEvent = {}));
    (function(ThebeEventType2) {
      ThebeEventType2["status"] = "status";
      ThebeEventType2["error"] = "error";
    })(ThebeEventType || (ThebeEventType = {}));
    ThebeEvents = class {
      constructor() {
        this.listeners = {};
      }
      _ensureMap(event) {
        if (!(event in this.listeners))
          this.listeners[event] = /* @__PURE__ */ new Map();
      }
      trigger(event, evt) {
        if (!(event in this.listeners))
          return;
        this.listeners[event].forEach(({ unbind }, cb2) => {
          cb2(event, evt);
          if (unbind)
            this.listeners[event].delete(cb2);
        });
      }
      on(event, cb2) {
        this._ensureMap(event);
        this.listeners[event].set(cb2, { unbind: false });
        return () => this.off(event, cb2);
      }
      one(event, cb2) {
        this._ensureMap(event);
        this.listeners[event].set(cb2, { unbind: true });
        return () => this.off(event, cb2);
      }
      off(event, cb2) {
        if (!(event in this.listeners))
          return;
        this.listeners[event].delete(cb2);
      }
    };
  }
});

// ../../node_modules/@jupyterlab/rendermime-interfaces/lib/index.js
var init_lib3 = __esm({
  "../../node_modules/@jupyterlab/rendermime-interfaces/lib/index.js"() {
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@lumino/algorithm/dist/index.es6.js
function every(object2, fn) {
  let index2 = 0;
  for (const value of object2) {
    if (false === fn(value, index2++)) {
      return false;
    }
  }
  return true;
}
function some(object2, fn) {
  let index2 = 0;
  for (const value of object2) {
    if (fn(value, index2++)) {
      return true;
    }
  }
  return false;
}
function* retro(object2) {
  if (typeof object2.retro === "function") {
    yield* object2.retro();
  } else {
    for (let index2 = object2.length - 1; index2 > -1; index2--) {
      yield object2[index2];
    }
  }
}
var ArrayExt2, Private2, StringExt;
var init_index_es69 = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt4) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n4 - start);
        } else {
          span = stop - start + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          let j2 = (start + i5) % n4;
          if (array[j2] === value) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n4 - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          let j2 = (start - i5 + n4) % n4;
          if (array[j2] === value) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n4 - start);
        } else {
          span = stop - start + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          let j2 = (start + i5) % n4;
          if (fn(array[j2], j2)) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.findFirstIndex = findFirstIndex;
      function findLastIndex(array, fn, start = -1, stop = 0) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let d6;
        if (start < stop) {
          d6 = start + 1 + (n4 - stop);
        } else {
          d6 = start - stop + 1;
        }
        for (let i5 = 0; i5 < d6; ++i5) {
          let j2 = (start - i5 + n4) % n4;
          if (fn(array[j2], j2)) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.findLastIndex = findLastIndex;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index2 = findFirstIndex(array, fn, start, stop);
        return index2 !== -1 ? array[index2] : void 0;
      }
      ArrayExt4.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index2 = findLastIndex(array, fn, start, stop);
        return index2 !== -1 ? array[index2] : void 0;
      }
      ArrayExt4.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt4.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt4.upperBound = upperBound;
      function shallowEqual(a4, b4, fn) {
        if (a4 === b4) {
          return true;
        }
        if (a4.length !== b4.length) {
          return false;
        }
        for (let i5 = 0, n4 = a4.length; i5 < n4; ++i5) {
          if (fn ? !fn(a4[i5], b4[i5]) : a4[i5] !== b4[i5]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt4.shallowEqual = shallowEqual;
      function slice2(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n4 = array.length;
        if (start === void 0) {
          start = step < 0 ? n4 - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n4, step < 0 ? -1 : 0);
        } else if (start >= n4) {
          start = step < 0 ? n4 - 1 : n4;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n4;
        } else if (stop < 0) {
          stop = Math.max(stop + n4, step < 0 ? -1 : 0);
        } else if (stop >= n4) {
          stop = step < 0 ? n4 - 1 : n4;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result2 = [];
        for (let i5 = 0; i5 < length; ++i5) {
          result2[i5] = array[start + i5 * step];
        }
        return result2;
      }
      ArrayExt4.slice = slice2;
      function move(array, fromIndex, toIndex) {
        let n4 = array.length;
        if (n4 <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n4);
        } else {
          fromIndex = Math.min(fromIndex, n4 - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n4);
        } else {
          toIndex = Math.min(toIndex, n4 - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d6 = fromIndex < toIndex ? 1 : -1;
        for (let i5 = fromIndex; i5 !== toIndex; i5 += d6) {
          array[i5] = array[i5 + d6];
        }
        array[toIndex] = value;
      }
      ArrayExt4.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        while (start < stop) {
          let a4 = array[start];
          let b4 = array[stop];
          array[start++] = b4;
          array[stop--] = a4;
        }
      }
      ArrayExt4.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt4.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n4 - start);
        } else {
          span = stop - start + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          array[(start + i5) % n4] = value;
        }
      }
      ArrayExt4.fill = fill;
      function insert(array, index2, value) {
        let n4 = array.length;
        if (index2 < 0) {
          index2 = Math.max(0, index2 + n4);
        } else {
          index2 = Math.min(index2, n4);
        }
        for (let i5 = n4; i5 > index2; --i5) {
          array[i5] = array[i5 - 1];
        }
        array[index2] = value;
      }
      ArrayExt4.insert = insert;
      function removeAt(array, index2) {
        let n4 = array.length;
        if (index2 < 0) {
          index2 += n4;
        }
        if (index2 < 0 || index2 >= n4) {
          return void 0;
        }
        let value = array[index2];
        for (let i5 = index2 + 1; i5 < n4; ++i5) {
          array[i5 - 1] = array[i5];
        }
        array.length = n4 - 1;
        return value;
      }
      ArrayExt4.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index2 = firstIndexOf(array, value, start, stop);
        if (index2 !== -1) {
          removeAt(array, index2);
        }
        return index2;
      }
      ArrayExt4.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index2 = lastIndexOf(array, value, start, stop);
        if (index2 !== -1) {
          removeAt(array, index2);
        }
        return index2;
      }
      ArrayExt4.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let count = 0;
        for (let i5 = 0; i5 < n4; ++i5) {
          if (start <= stop && i5 >= start && i5 <= stop && array[i5] === value) {
            count++;
          } else if (stop < start && (i5 <= stop || i5 >= start) && array[i5] === value) {
            count++;
          } else if (count > 0) {
            array[i5 - count] = array[i5];
          }
        }
        if (count > 0) {
          array.length = n4 - count;
        }
        return count;
      }
      ArrayExt4.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index2 = findFirstIndex(array, fn, start, stop);
        if (index2 !== -1) {
          value = removeAt(array, index2);
        }
        return { index: index2, value };
      }
      ArrayExt4.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index2 = findLastIndex(array, fn, start, stop);
        if (index2 !== -1) {
          value = removeAt(array, index2);
        }
        return { index: index2, value };
      }
      ArrayExt4.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let count = 0;
        for (let i5 = 0; i5 < n4; ++i5) {
          if (start <= stop && i5 >= start && i5 <= stop && fn(array[i5], i5)) {
            count++;
          } else if (stop < start && (i5 <= stop || i5 >= start) && fn(array[i5], i5)) {
            count++;
          } else if (count > 0) {
            array[i5 - count] = array[i5];
          }
        }
        if (count > 0) {
          array.length = n4 - count;
        }
        return count;
      }
      ArrayExt4.removeAllWhere = removeAllWhere;
    })(ArrayExt2 || (ArrayExt2 = {}));
    (function(Private19) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private19.rangeLength = rangeLength;
    })(Private2 || (Private2 = {}));
    (function(StringExt3) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i5 = 0, j2 = start, n4 = query.length; i5 < n4; ++i5, ++j2) {
          j2 = source.indexOf(query[i5], j2);
          if (j2 === -1) {
            return null;
          }
          indices[i5] = j2;
        }
        return indices;
      }
      StringExt3.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i5 = 0, n4 = indices.length; i5 < n4; ++i5) {
          let j2 = indices[i5] - start;
          score += j2 * j2;
        }
        return { score, indices };
      }
      StringExt3.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last2 = start - 1;
        for (let i5 = 0, n4 = indices.length; i5 < n4; ++i5) {
          let j2 = indices[i5];
          score += j2 - last2 - 1;
          last2 = j2;
        }
        return { score, indices };
      }
      StringExt3.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result2 = [];
        let k = 0;
        let last2 = 0;
        let n4 = indices.length;
        while (k < n4) {
          let i5 = indices[k];
          let j2 = indices[k];
          while (++k < n4 && indices[k] === j2 + 1) {
            j2++;
          }
          if (last2 < i5) {
            result2.push(source.slice(last2, i5));
          }
          if (i5 < j2 + 1) {
            result2.push(fn(source.slice(i5, j2 + 1)));
          }
          last2 = j2 + 1;
        }
        if (last2 < source.length) {
          result2.push(source.slice(last2));
        }
        return result2;
      }
      StringExt3.highlight = highlight;
      function cmp(a4, b4) {
        return a4 < b4 ? -1 : a4 > b4 ? 1 : 0;
      }
      StringExt3.cmp = cmp;
    })(StringExt || (StringExt = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@lumino/collections/dist/index.es6.js
var LinkedList, Private3;
var init_index_es610 = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@lumino/collections/dist/index.es6.js"() {
    LinkedList = class {
      constructor() {
        this._first = null;
        this._last = null;
        this._size = 0;
      }
      /**
       * Whether the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get isEmpty() {
        return this._size === 0;
      }
      /**
       * The size of the list.
       *
       * #### Complexity
       * `O(1)`
       *
       * #### Notes
       * This is equivalent to `length`.
       */
      get size() {
        return this._size;
      }
      /**
       * The length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `size`.
       *
       * This property is deprecated.
       */
      get length() {
        return this._size;
      }
      /**
       * The first value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get first() {
        return this._first ? this._first.value : void 0;
      }
      /**
       * The last value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get last() {
        return this._last ? this._last.value : void 0;
      }
      /**
       * The first node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get firstNode() {
        return this._first;
      }
      /**
       * The last node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get lastNode() {
        return this._last;
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting with the first value.
       *
       * #### Complexity
       * Constant.
       */
      *[Symbol.iterator]() {
        let node = this._first;
        while (node) {
          yield node.value;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the values in the list.
       *
       * @returns A new iterator starting with the last value.
       *
       * #### Complexity
       * Constant.
       */
      *retro() {
        let node = this._last;
        while (node) {
          yield node.value;
          node = node.prev;
        }
      }
      /**
       * Create an iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the first node.
       *
       * #### Complexity
       * Constant.
       */
      *nodes() {
        let node = this._first;
        while (node) {
          yield node;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the last node.
       *
       * #### Complexity
       * Constant.
       */
      *retroNodes() {
        let node = this._last;
        while (node) {
          yield node;
          node = node.prev;
        }
      }
      /**
       * Assign new values to the list, replacing all current values.
       *
       * @param values - The values to assign to the list.
       *
       * #### Complexity
       * Linear.
       */
      assign(values2) {
        this.clear();
        for (const value of values2) {
          this.addLast(value);
        }
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addLast`.
       */
      push(value) {
        this.addLast(value);
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeLast`.
       */
      pop() {
        return this.removeLast();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addFirst`.
       */
      shift(value) {
        this.addFirst(value);
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeFirst`.
       */
      unshift() {
        return this.removeFirst();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addFirst(value) {
        let node = new Private3.LinkedListNode(this, value);
        if (!this._first) {
          this._first = node;
          this._last = node;
        } else {
          node.next = this._first;
          this._first.prev = node;
          this._first = node;
        }
        this._size++;
        return node;
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addLast(value) {
        let node = new Private3.LinkedListNode(this, value);
        if (!this._last) {
          this._first = node;
          this._last = node;
        } else {
          node.prev = this._last;
          this._last.next = node;
          this._last = node;
        }
        this._size++;
        return node;
      }
      /**
       * Insert a value before a specific node in the list.
       *
       * @param value - The value to insert before the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertBefore(value, ref) {
        if (!ref || ref === this._first) {
          return this.addFirst(value);
        }
        if (!(ref instanceof Private3.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private3.LinkedListNode(this, value);
        let _ref = ref;
        let prev = _ref.prev;
        node.next = _ref;
        node.prev = prev;
        _ref.prev = node;
        prev.next = node;
        this._size++;
        return node;
      }
      /**
       * Insert a value after a specific node in the list.
       *
       * @param value - The value to insert after the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertAfter(value, ref) {
        if (!ref || ref === this._last) {
          return this.addLast(value);
        }
        if (!(ref instanceof Private3.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private3.LinkedListNode(this, value);
        let _ref = ref;
        let next = _ref.next;
        node.next = next;
        node.prev = _ref;
        _ref.next = node;
        next.prev = node;
        this._size++;
        return node;
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeFirst() {
        let node = this._first;
        if (!node) {
          return void 0;
        }
        if (node === this._last) {
          this._first = null;
          this._last = null;
        } else {
          this._first = node.next;
          this._first.prev = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeLast() {
        let node = this._last;
        if (!node) {
          return void 0;
        }
        if (node === this._first) {
          this._first = null;
          this._last = null;
        } else {
          this._last = node.prev;
          this._last.next = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove a specific node from the list.
       *
       * @param node - The node to remove from the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * The node must be owned by the list.
       */
      removeNode(node) {
        if (!(node instanceof Private3.LinkedListNode) || node.list !== this) {
          throw new Error("Node is not owned by the list.");
        }
        let _node = node;
        if (_node === this._first && _node === this._last) {
          this._first = null;
          this._last = null;
        } else if (_node === this._first) {
          this._first = _node.next;
          this._first.prev = null;
        } else if (_node === this._last) {
          this._last = _node.prev;
          this._last.next = null;
        } else {
          _node.next.prev = _node.prev;
          _node.prev.next = _node.next;
        }
        _node.list = null;
        _node.next = null;
        _node.prev = null;
        this._size--;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       */
      clear() {
        let node = this._first;
        while (node) {
          let next = node.next;
          node.list = null;
          node.prev = null;
          node.next = null;
          node = next;
        }
        this._first = null;
        this._last = null;
        this._size = 0;
      }
    };
    (function(LinkedList3) {
      function from(values2) {
        let list = new LinkedList3();
        list.assign(values2);
        return list;
      }
      LinkedList3.from = from;
    })(LinkedList || (LinkedList = {}));
    (function(Private19) {
      class LinkedListNode {
        /**
         * Construct a new linked list node.
         *
         * @param list - The list which owns the node.
         *
         * @param value - The value for the link.
         */
        constructor(list, value) {
          this.list = null;
          this.next = null;
          this.prev = null;
          this.list = list;
          this.value = value;
        }
      }
      Private19.LinkedListNode = LinkedListNode;
    })(Private3 || (Private3 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@lumino/messaging/dist/index.es6.js
var Message, MessageLoop2;
var init_index_es611 = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@lumino/messaging/dist/index.es6.js"() {
    init_index_es69();
    init_index_es610();
    Message = class {
      /**
       * Construct a new message.
       *
       * @param type - The type of the message.
       */
      constructor(type2) {
        this.type = type2;
      }
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * If a conflatable message is posted to a handler while another
       * conflatable message of the same `type` has already been posted
       * to the handler, the `conflate()` method of the existing message
       * will be invoked. If that method returns `true`, the new message
       * will not be enqueued. This allows messages to be compressed, so
       * that only a single instance of the message type is processed per
       * cycle, no matter how many times messages of that type are posted.
       *
       * Custom message types may reimplement this property.
       *
       * The default implementation is always `false`.
       */
      get isConflatable() {
        return false;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * @param other - A conflatable message of the same `type`.
       *
       * @returns `true` if the message was successfully conflated, or
       *   `false` otherwise.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * This method is called automatically by the message loop when the
       * given message is posted to the handler paired with this message.
       * This message will already be enqueued and conflatable, and the
       * given message will have the same `type` and also be conflatable.
       *
       * This method should merge the state of the other message into this
       * message as needed so that when this message is finally delivered
       * to the handler, it receives the most up-to-date information.
       *
       * If this method returns `true`, it signals that the other message
       * was successfully conflated and that message will not be enqueued.
       *
       * If this method returns `false`, the other message will be enqueued
       * for normal delivery.
       *
       * Custom message types may reimplement this method.
       *
       * The default implementation always returns `false`.
       */
      conflate(other) {
        return false;
      }
    };
    (function(MessageLoop4) {
      let pending = null;
      const schedule = ((resolved) => (fn) => {
        let rejected = false;
        resolved.then(() => !rejected && fn());
        return () => {
          rejected = true;
        };
      })(Promise.resolve());
      function sendMessage(handler, msg) {
        let hooks = messageHooks.get(handler);
        if (!hooks || hooks.length === 0) {
          invokeHandler(handler, msg);
          return;
        }
        let passed = every(retro(hooks), (hook) => {
          return hook ? invokeHook(hook, handler, msg) : true;
        });
        if (passed) {
          invokeHandler(handler, msg);
        }
      }
      MessageLoop4.sendMessage = sendMessage;
      function postMessage(handler, msg) {
        if (!msg.isConflatable) {
          enqueueMessage(handler, msg);
          return;
        }
        let conflated = some(messageQueue, (posted) => {
          if (posted.handler !== handler) {
            return false;
          }
          if (!posted.msg) {
            return false;
          }
          if (posted.msg.type !== msg.type) {
            return false;
          }
          if (!posted.msg.isConflatable) {
            return false;
          }
          return posted.msg.conflate(msg);
        });
        if (!conflated) {
          enqueueMessage(handler, msg);
        }
      }
      MessageLoop4.postMessage = postMessage;
      function installMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.indexOf(hook) !== -1) {
          return;
        }
        if (!hooks) {
          messageHooks.set(handler, [hook]);
        } else {
          hooks.push(hook);
        }
      }
      MessageLoop4.installMessageHook = installMessageHook;
      function removeMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (!hooks) {
          return;
        }
        let i5 = hooks.indexOf(hook);
        if (i5 === -1) {
          return;
        }
        hooks[i5] = null;
        scheduleCleanup(hooks);
      }
      MessageLoop4.removeMessageHook = removeMessageHook;
      function clearData(handler) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.length > 0) {
          ArrayExt2.fill(hooks, null);
          scheduleCleanup(hooks);
        }
        for (const posted of messageQueue) {
          if (posted.handler === handler) {
            posted.handler = null;
            posted.msg = null;
          }
        }
      }
      MessageLoop4.clearData = clearData;
      function flush() {
        if (flushGuard || pending === null) {
          return;
        }
        pending();
        pending = null;
        flushGuard = true;
        runMessageLoop();
        flushGuard = false;
      }
      MessageLoop4.flush = flush;
      function getExceptionHandler() {
        return exceptionHandler;
      }
      MessageLoop4.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = exceptionHandler;
        exceptionHandler = handler;
        return old;
      }
      MessageLoop4.setExceptionHandler = setExceptionHandler;
      const messageQueue = new LinkedList();
      const messageHooks = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      let exceptionHandler = (err) => {
        console.error(err);
      };
      let flushGuard = false;
      function invokeHook(hook, handler, msg) {
        let result2 = true;
        try {
          if (typeof hook === "function") {
            result2 = hook(handler, msg);
          } else {
            result2 = hook.messageHook(handler, msg);
          }
        } catch (err) {
          exceptionHandler(err);
        }
        return result2;
      }
      function invokeHandler(handler, msg) {
        try {
          handler.processMessage(msg);
        } catch (err) {
          exceptionHandler(err);
        }
      }
      function enqueueMessage(handler, msg) {
        messageQueue.addLast({ handler, msg });
        if (pending !== null) {
          return;
        }
        pending = schedule(runMessageLoop);
      }
      function runMessageLoop() {
        pending = null;
        if (messageQueue.isEmpty) {
          return;
        }
        let sentinel = { handler: null, msg: null };
        messageQueue.addLast(sentinel);
        while (true) {
          let posted = messageQueue.removeFirst();
          if (posted === sentinel) {
            return;
          }
          if (posted.handler && posted.msg) {
            sendMessage(posted.handler, posted.msg);
          }
        }
      }
      function scheduleCleanup(hooks) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(hooks);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupHooks);
        dirtySet.clear();
      }
      function cleanupHooks(hooks) {
        ArrayExt2.removeAllWhere(hooks, isNull3);
      }
      function isNull3(value) {
        return value === null;
      }
    })(MessageLoop2 || (MessageLoop2 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/observables/lib/observablemap.js
var ObservableMap, Private4;
var init_observablemap = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/observables/lib/observablemap.js"() {
    init_index_es6();
    ObservableMap = class {
      /**
       * Construct a new observable map.
       */
      constructor(options = {}) {
        this._map = /* @__PURE__ */ new Map();
        this._changed = new Signal(this);
        this._isDisposed = false;
        this._itemCmp = options.itemCmp || Private4.itemCmp;
        if (options.values) {
          for (const key in options.values) {
            this._map.set(key, options.values[key]);
          }
        }
      }
      /**
       * The type of the Observable.
       */
      get type() {
        return "Map";
      }
      /**
       * A signal emitted when the map has changed.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Whether this map has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * The number of key-value pairs in the map.
       */
      get size() {
        return this._map.size;
      }
      /**
       * Set a key-value pair in the map
       *
       * @param key - The key to set.
       *
       * @param value - The value for the key.
       *
       * @returns the old value for the key, or undefined
       *   if that did not exist.
       *
       * @throws if the new value is undefined.
       *
       * #### Notes
       * This is a no-op if the value does not change.
       */
      set(key, value) {
        const oldVal = this._map.get(key);
        if (value === void 0) {
          throw Error("Cannot set an undefined value, use remove");
        }
        const itemCmp = this._itemCmp;
        if (oldVal !== void 0 && itemCmp(oldVal, value)) {
          return oldVal;
        }
        this._map.set(key, value);
        this._changed.emit({
          type: oldVal ? "change" : "add",
          key,
          oldValue: oldVal,
          newValue: value
        });
        return oldVal;
      }
      /**
       * Get a value for a given key.
       *
       * @param key - the key.
       *
       * @returns the value for that key.
       */
      get(key) {
        return this._map.get(key);
      }
      /**
       * Check whether the map has a key.
       *
       * @param key - the key to check.
       *
       * @returns `true` if the map has the key, `false` otherwise.
       */
      has(key) {
        return this._map.has(key);
      }
      /**
       * Get a list of the keys in the map.
       *
       * @returns - a list of keys.
       */
      keys() {
        const keyList = [];
        this._map.forEach((v2, k) => {
          keyList.push(k);
        });
        return keyList;
      }
      /**
       * Get a list of the values in the map.
       *
       * @returns - a list of values.
       */
      values() {
        const valList = [];
        this._map.forEach((v2, k) => {
          valList.push(v2);
        });
        return valList;
      }
      /**
       * Remove a key from the map
       *
       * @param key - the key to remove.
       *
       * @returns the value of the given key,
       *   or undefined if that does not exist.
       *
       * #### Notes
       * This is a no-op if the value does not change.
       */
      delete(key) {
        const oldVal = this._map.get(key);
        const removed = this._map.delete(key);
        if (removed) {
          this._changed.emit({
            type: "remove",
            key,
            oldValue: oldVal,
            newValue: void 0
          });
        }
        return oldVal;
      }
      /**
       * Set the ObservableMap to an empty map.
       */
      clear() {
        const keyList = this.keys();
        for (let i5 = 0; i5 < keyList.length; i5++) {
          this.delete(keyList[i5]);
        }
      }
      /**
       * Dispose of the resources held by the map.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
        this._map.clear();
      }
    };
    (function(Private19) {
      function itemCmp(first2, second) {
        return first2 === second;
      }
      Private19.itemCmp = itemCmp;
    })(Private4 || (Private4 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/observables/lib/observablejson.js
var import_coreutils, ObservableJSON;
var init_observablejson = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/observables/lib/observablejson.js"() {
    import_coreutils = __toESM(require_dist());
    init_index_es611();
    init_observablemap();
    ObservableJSON = class extends ObservableMap {
      /**
       * Construct a new observable JSON object.
       */
      constructor(options = {}) {
        super({
          itemCmp: import_coreutils.JSONExt.deepEqual,
          values: options.values
        });
      }
      /**
       * Serialize the model to JSON.
       */
      toJSON() {
        const out = /* @__PURE__ */ Object.create(null);
        const keys2 = this.keys();
        for (const key of keys2) {
          const value = this.get(key);
          if (value !== void 0) {
            out[key] = import_coreutils.JSONExt.deepCopy(value);
          }
        }
        return out;
      }
    };
    (function(ObservableJSON3) {
      class ChangeMessage extends Message {
        /**
         * Create a new metadata changed message.
         */
        constructor(type2, args) {
          super(type2);
          this.args = args;
        }
      }
      ObservableJSON3.ChangeMessage = ChangeMessage;
    })(ObservableJSON || (ObservableJSON = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/observables/lib/observablestring.js
var init_observablestring = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/observables/lib/observablestring.js"() {
    init_index_es6();
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/observables/lib/observablelist.js
var ObservableList, Private5;
var init_observablelist = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/observables/lib/observablelist.js"() {
    init_index_es69();
    init_index_es6();
    ObservableList = class {
      /**
       * Construct a new observable map.
       */
      constructor(options = {}) {
        this._array = [];
        this._isDisposed = false;
        this._changed = new Signal(this);
        if (options.values) {
          for (const value of options.values) {
            this._array.push(value);
          }
        }
        this._itemCmp = options.itemCmp || Private5.itemCmp;
      }
      /**
       * The type of this object.
       */
      get type() {
        return "List";
      }
      /**
       * A signal emitted when the list has changed.
       */
      get changed() {
        return this._changed;
      }
      /**
       * The length of the list.
       */
      get length() {
        return this._array.length;
      }
      /**
       * Test whether the list has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the list.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
        this.clear();
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting at the front of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Iterator Validity
       * No changes.
       */
      [Symbol.iterator]() {
        return this._array[Symbol.iterator]();
      }
      /**
       * Get the value at the specified index.
       *
       * @param index - The positive integer index of interest.
       *
       * @returns The value at the specified index.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral or out of range.
       */
      get(index2) {
        return this._array[index2];
      }
      /**
       * Set the value at the specified index.
       *
       * @param index - The positive integer index of interest.
       *
       * @param value - The value to set at the specified index.
       *
       * #### Complexity
       * Constant.
       *
       * #### Iterator Validity
       * No changes.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral or out of range.
       */
      set(index2, value) {
        const oldValue = this._array[index2];
        if (value === void 0) {
          throw new Error("Cannot set an undefined item");
        }
        const itemCmp = this._itemCmp;
        if (itemCmp(oldValue, value)) {
          return;
        }
        this._array[index2] = value;
        this._changed.emit({
          type: "set",
          oldIndex: index2,
          newIndex: index2,
          oldValues: [oldValue],
          newValues: [value]
        });
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The new length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * By convention, the oldIndex is set to -1 to indicate
       * an push operation.
       *
       * #### Iterator Validity
       * No changes.
       */
      push(value) {
        const num = this._array.push(value);
        this._changed.emit({
          type: "add",
          oldIndex: -1,
          newIndex: this.length - 1,
          oldValues: [],
          newValues: [value]
        });
        return num;
      }
      /**
       * Insert a value into the list at a specific index.
       *
       * @param index - The index at which to insert the value.
       *
       * @param value - The value to set at the specified index.
       *
       * #### Complexity
       * Linear.
       *
       * #### Iterator Validity
       * No changes.
       *
       * #### Notes
       * The `index` will be clamped to the bounds of the list.
       *
       * By convention, the oldIndex is set to -2 to indicate
       * an insert operation.
       *
       * The value -2 as oldIndex can be used to distinguish from the push
       * method which will use a value -1.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insert(index2, value) {
        if (index2 === this._array.length) {
          this._array.push(value);
        } else {
          ArrayExt2.insert(this._array, index2, value);
        }
        this._changed.emit({
          type: "add",
          oldIndex: -2,
          newIndex: index2,
          oldValues: [],
          newValues: [value]
        });
      }
      /**
       * Remove the first occurrence of a value from the list.
       *
       * @param value - The value of interest.
       *
       * @returns The index of the removed value, or `-1` if the value
       *   is not contained in the list.
       *
       * #### Complexity
       * Linear.
       *
       * #### Iterator Validity
       * Iterators pointing at the removed value and beyond are invalidated.
       */
      removeValue(value) {
        const itemCmp = this._itemCmp;
        const index2 = ArrayExt2.findFirstIndex(this._array, (item) => {
          return itemCmp(item, value);
        });
        this.remove(index2);
        return index2;
      }
      /**
       * Remove and return the value at a specific index.
       *
       * @param index - The index of the value of interest.
       *
       * @returns The value at the specified index, or `undefined` if the
       *   index is out of range.
       *
       * #### Complexity
       * Constant.
       *
       * #### Iterator Validity
       * Iterators pointing at the removed value and beyond are invalidated.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      remove(index2) {
        const value = ArrayExt2.removeAt(this._array, index2);
        if (value === void 0) {
          return;
        }
        this._changed.emit({
          type: "remove",
          oldIndex: index2,
          newIndex: -1,
          newValues: [],
          oldValues: [value]
        });
        return value;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       *
       * #### Iterator Validity
       * All current iterators are invalidated.
       */
      clear() {
        const copy = this._array.slice();
        this._array.length = 0;
        this._changed.emit({
          type: "remove",
          oldIndex: 0,
          newIndex: 0,
          newValues: [],
          oldValues: copy
        });
      }
      /**
       * Move a value from one index to another.
       *
       * @param fromIndex - The index of the element to move.
       *
       * @param toIndex - The index to move the element to.
       *
       * #### Complexity
       * Constant.
       *
       * #### Iterator Validity
       * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`
       * and beyond are invalidated.
       *
       * #### Undefined Behavior
       * A `fromIndex` or a `toIndex` which is non-integral.
       */
      move(fromIndex, toIndex) {
        if (this.length <= 1 || fromIndex === toIndex) {
          return;
        }
        const values2 = [this._array[fromIndex]];
        ArrayExt2.move(this._array, fromIndex, toIndex);
        this._changed.emit({
          type: "move",
          oldIndex: fromIndex,
          newIndex: toIndex,
          oldValues: values2,
          newValues: values2
        });
      }
      /**
       * Push a set of values to the back of the list.
       *
       * @param values - An iterable set of values to add.
       *
       * @returns The new length of the list.
       *
       * #### Complexity
       * Linear.
       *
       * #### Notes
       * By convention, the oldIndex is set to -1 to indicate
       * an push operation.
       *
       * #### Iterator Validity
       * No changes.
       */
      pushAll(values2) {
        const newIndex = this.length;
        for (const value of values2) {
          this._array.push(value);
        }
        this._changed.emit({
          type: "add",
          oldIndex: -1,
          newIndex,
          oldValues: [],
          newValues: Array.from(values2)
        });
        return this.length;
      }
      /**
       * Insert a set of items into the list at the specified index.
       *
       * @param index - The index at which to insert the values.
       *
       * @param values - The values to insert at the specified index.
       *
       * #### Complexity.
       * Linear.
       *
       * #### Iterator Validity
       * No changes.
       *
       * #### Notes
       * The `index` will be clamped to the bounds of the list.
       * By convention, the oldIndex is set to -2 to indicate
       * an insert operation.
       *
       * #### Undefined Behavior.
       * An `index` which is non-integral.
       */
      insertAll(index2, values2) {
        const newIndex = index2;
        for (const value of values2) {
          ArrayExt2.insert(this._array, index2++, value);
        }
        this._changed.emit({
          type: "add",
          oldIndex: -2,
          newIndex,
          oldValues: [],
          newValues: Array.from(values2)
        });
      }
      /**
       * Remove a range of items from the list.
       *
       * @param startIndex - The start index of the range to remove (inclusive).
       *
       * @param endIndex - The end index of the range to remove (exclusive).
       *
       * @returns The new length of the list.
       *
       * #### Complexity
       * Linear.
       *
       * #### Iterator Validity
       * Iterators pointing to the first removed value and beyond are invalid.
       *
       * #### Undefined Behavior
       * A `startIndex` or `endIndex` which is non-integral.
       */
      removeRange(startIndex, endIndex) {
        const oldValues = this._array.slice(startIndex, endIndex);
        for (let i5 = startIndex; i5 < endIndex; i5++) {
          ArrayExt2.removeAt(this._array, startIndex);
        }
        this._changed.emit({
          type: "remove",
          oldIndex: startIndex,
          newIndex: -1,
          oldValues,
          newValues: []
        });
        return this.length;
      }
    };
    (function(Private19) {
      function itemCmp(first2, second) {
        return first2 === second;
      }
      Private19.itemCmp = itemCmp;
    })(Private5 || (Private5 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/observables/lib/undoablelist.js
var ObservableUndoableList;
var init_undoablelist = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/observables/lib/undoablelist.js"() {
    init_observablelist();
    ObservableUndoableList = class extends ObservableList {
      /**
       * Construct a new undoable observable list.
       */
      constructor(serializer) {
        super();
        this._inCompound = false;
        this._isUndoable = true;
        this._madeCompoundChange = false;
        this._index = -1;
        this._stack = [];
        this._serializer = serializer;
        this.changed.connect(this._onListChanged, this);
      }
      /**
       * Whether the object can redo changes.
       */
      get canRedo() {
        return this._index < this._stack.length - 1;
      }
      /**
       * Whether the object can undo changes.
       */
      get canUndo() {
        return this._index >= 0;
      }
      /**
       * Begin a compound operation.
       *
       * @param isUndoAble - Whether the operation is undoable.
       *   The default is `true`.
       */
      beginCompoundOperation(isUndoAble) {
        this._inCompound = true;
        this._isUndoable = isUndoAble !== false;
        this._madeCompoundChange = false;
      }
      /**
       * End a compound operation.
       */
      endCompoundOperation() {
        this._inCompound = false;
        this._isUndoable = true;
        if (this._madeCompoundChange) {
          this._index++;
        }
      }
      /**
       * Undo an operation.
       */
      undo() {
        if (!this.canUndo) {
          return;
        }
        const changes = this._stack[this._index];
        this._isUndoable = false;
        for (const change of changes.reverse()) {
          this._undoChange(change);
        }
        this._isUndoable = true;
        this._index--;
      }
      /**
       * Redo an operation.
       */
      redo() {
        if (!this.canRedo) {
          return;
        }
        this._index++;
        const changes = this._stack[this._index];
        this._isUndoable = false;
        for (const change of changes) {
          this._redoChange(change);
        }
        this._isUndoable = true;
      }
      /**
       * Clear the change stack.
       */
      clearUndo() {
        this._index = -1;
        this._stack = [];
      }
      /**
       * Handle a change in the list.
       */
      _onListChanged(list, change) {
        if (this.isDisposed || !this._isUndoable) {
          return;
        }
        if (!this._inCompound || !this._madeCompoundChange) {
          this._stack = this._stack.slice(0, this._index + 1);
        }
        const evt = this._copyChange(change);
        if (this._stack[this._index + 1]) {
          this._stack[this._index + 1].push(evt);
        } else {
          this._stack.push([evt]);
        }
        if (!this._inCompound) {
          this._index++;
        } else {
          this._madeCompoundChange = true;
        }
      }
      /**
       * Undo a change event.
       */
      _undoChange(change) {
        let index2 = 0;
        const serializer = this._serializer;
        switch (change.type) {
          case "add":
            for (let length = change.newValues.length; length > 0; length--) {
              this.remove(change.newIndex);
            }
            break;
          case "set":
            index2 = change.oldIndex;
            for (const value of change.oldValues) {
              this.set(index2++, serializer.fromJSON(value));
            }
            break;
          case "remove":
            index2 = change.oldIndex;
            for (const value of change.oldValues) {
              this.insert(index2++, serializer.fromJSON(value));
            }
            break;
          case "move":
            this.move(change.newIndex, change.oldIndex);
            break;
          default:
            return;
        }
      }
      /**
       * Redo a change event.
       */
      _redoChange(change) {
        let index2 = 0;
        const serializer = this._serializer;
        switch (change.type) {
          case "add":
            index2 = change.newIndex;
            for (const value of change.newValues) {
              this.insert(index2++, serializer.fromJSON(value));
            }
            break;
          case "set":
            index2 = change.newIndex;
            for (const value of change.newValues) {
              this.set(change.newIndex++, serializer.fromJSON(value));
            }
            break;
          case "remove":
            for (let length = change.oldValues.length; length > 0; length--) {
              this.remove(change.oldIndex);
            }
            break;
          case "move":
            this.move(change.oldIndex, change.newIndex);
            break;
          default:
            return;
        }
      }
      /**
       * Copy a change as JSON.
       */
      _copyChange(change) {
        const oldValues = [];
        for (const value of change.oldValues) {
          oldValues.push(this._serializer.toJSON(value));
        }
        const newValues = [];
        for (const value of change.newValues) {
          newValues.push(this._serializer.toJSON(value));
        }
        return {
          type: change.type,
          oldIndex: change.oldIndex,
          newIndex: change.newIndex,
          oldValues,
          newValues
        };
      }
    };
    (function(ObservableUndoableList3) {
      class IdentitySerializer {
        /**
         * Identity serialize.
         */
        toJSON(value) {
          return value;
        }
        /**
         * Identity deserialize.
         */
        fromJSON(value) {
          return value;
        }
      }
      ObservableUndoableList3.IdentitySerializer = IdentitySerializer;
    })(ObservableUndoableList || (ObservableUndoableList = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/observables/lib/modeldb.js
var import_coreutils2, ObservableValue;
var init_modeldb = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/observables/lib/modeldb.js"() {
    import_coreutils2 = __toESM(require_dist());
    init_index_es63();
    init_index_es6();
    ObservableValue = class {
      /**
       * Constructor for the value.
       *
       * @param initialValue: the starting value for the `ObservableValue`.
       */
      constructor(initialValue = null) {
        this._value = null;
        this._changed = new Signal(this);
        this._isDisposed = false;
        this._value = initialValue;
      }
      /**
       * The observable type.
       */
      get type() {
        return "Value";
      }
      /**
       * Whether the value has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * The changed signal.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Get the current value, or `undefined` if it has not been set.
       */
      get() {
        return this._value;
      }
      /**
       * Set the current value.
       */
      set(value) {
        const oldValue = this._value;
        if (import_coreutils2.JSONExt.deepEqual(oldValue, value)) {
          return;
        }
        this._value = value;
        this._changed.emit({
          oldValue,
          newValue: value
        });
      }
      /**
       * Dispose of the resources held by the value.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
        this._value = null;
      }
    };
    (function(ObservableValue3) {
      class IChangedArgs {
      }
      ObservableValue3.IChangedArgs = IChangedArgs;
    })(ObservableValue || (ObservableValue = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/observables/lib/index.js
var init_lib4 = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/observables/lib/index.js"() {
    init_modeldb();
    init_observablejson();
    init_observablelist();
    init_observablemap();
    init_observablestring();
    init_undoablelist();
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/attachmentmodel.js
var import_coreutils3, AttachmentModel, Private6;
var init_attachmentmodel = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/attachmentmodel.js"() {
    init_lib4();
    import_coreutils3 = __toESM(require_dist());
    init_index_es6();
    AttachmentModel = class {
      /**
       * Construct a new attachment model.
       */
      constructor(options) {
        this.trusted = false;
        this._changed = new Signal(this);
        this._raw = {};
        const data = Private6.getData(options.value);
        this._data = new ObservableJSON({ values: data });
        this._rawData = data;
        const value = options.value;
        for (const key in value) {
          switch (key) {
            case "data":
              break;
            default:
              this._raw[key] = Private6.extract(value, key);
          }
        }
      }
      /**
       * A signal emitted when the attachment model changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Dispose of the resources used by the attachment model.
       */
      dispose() {
        this._data.dispose();
        Signal.clearData(this);
      }
      /**
       * The data associated with the model.
       */
      get data() {
        return this._rawData;
      }
      /**
       * The metadata associated with the model.
       */
      get metadata() {
        return {};
      }
      /**
       * Set the data associated with the model.
       *
       * #### Notes
       * Depending on the implementation of the mime model,
       * this call may or may not have deferred effects,
       */
      setData(options) {
        if (options.data) {
          this._updateObservable(this._data, options.data);
          this._rawData = options.data;
        }
        this._changed.emit(void 0);
      }
      /**
       * Serialize the model to JSON.
       */
      toJSON() {
        const attachment = {};
        for (const key in this._raw) {
          attachment[key] = Private6.extract(this._raw, key);
        }
        return attachment;
      }
      /**
       * Update an observable JSON object using a readonly JSON object.
       */
      _updateObservable(observable, data) {
        const oldKeys = observable.keys();
        const newKeys = Object.keys(data);
        for (const key of oldKeys) {
          if (newKeys.indexOf(key) === -1) {
            observable.delete(key);
          }
        }
        for (const key of newKeys) {
          const oldValue = observable.get(key);
          const newValue = data[key];
          if (oldValue !== newValue) {
            observable.set(key, newValue);
          }
        }
      }
    };
    (function(AttachmentModel2) {
      function getData(bundle) {
        return Private6.getData(bundle);
      }
      AttachmentModel2.getData = getData;
    })(AttachmentModel || (AttachmentModel = {}));
    (function(Private19) {
      function getData(bundle) {
        return convertBundle(bundle);
      }
      Private19.getData = getData;
      function getBundleOptions(options) {
        const data = getData(options.value);
        return { data };
      }
      Private19.getBundleOptions = getBundleOptions;
      function extract(value, key) {
        const item = value[key];
        if (item === void 0 || import_coreutils3.JSONExt.isPrimitive(item)) {
          return item;
        }
        return import_coreutils3.JSONExt.deepCopy(item);
      }
      Private19.extract = extract;
      function convertBundle(bundle) {
        const map4 = /* @__PURE__ */ Object.create(null);
        for (const mimeType in bundle) {
          map4[mimeType] = extract(bundle, mimeType);
        }
        return map4;
      }
    })(Private6 || (Private6 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/activitymonitor.js
var require_activitymonitor2 = __commonJS({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/activitymonitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActivityMonitor = void 0;
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var ActivityMonitor = class {
      /**
       * Construct a new activity monitor.
       */
      constructor(options) {
        this._timer = -1;
        this._timeout = -1;
        this._isDisposed = false;
        this._activityStopped = new signaling_1.Signal(this);
        options.signal.connect(this._onSignalFired, this);
        this._timeout = options.timeout || 1e3;
      }
      /**
       * A signal emitted when activity has ceased.
       */
      get activityStopped() {
        return this._activityStopped;
      }
      /**
       * The timeout associated with the monitor, in milliseconds.
       */
      get timeout() {
        return this._timeout;
      }
      set timeout(value) {
        this._timeout = value;
      }
      /**
       * Test whether the monitor has been disposed.
       *
       * #### Notes
       * This is a read-only property.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the activity monitor.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * A signal handler for the monitored signal.
       */
      _onSignalFired(sender, args) {
        clearTimeout(this._timer);
        this._sender = sender;
        this._args = args;
        this._timer = setTimeout(() => {
          this._activityStopped.emit({
            sender: this._sender,
            args: this._args
          });
        }, this._timeout);
      }
    };
    exports2.ActivityMonitor = ActivityMonitor;
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/interfaces.js
var require_interfaces3 = __commonJS({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/lru.js
var require_lru = __commonJS({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/lru.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LruCache = void 0;
    var DEFAULT_MAX_SIZE = 128;
    var LruCache = class {
      constructor(options = {}) {
        this._map = /* @__PURE__ */ new Map();
        this._maxSize = (options === null || options === void 0 ? void 0 : options.maxSize) || DEFAULT_MAX_SIZE;
      }
      /**
       * Return the current size of the cache.
       */
      get size() {
        return this._map.size;
      }
      /**
       * Clear the values in the cache.
       */
      clear() {
        this._map.clear();
      }
      /**
       * Get a value (or null) from the cache, pushing the item to the front of the cache.
       */
      get(key) {
        const item = this._map.get(key) || null;
        if (item != null) {
          this._map.delete(key);
          this._map.set(key, item);
        }
        return item;
      }
      /**
       * Set a value in the cache, potentially evicting an old item.
       */
      set(key, value) {
        if (this._map.size >= this._maxSize) {
          this._map.delete(this._map.keys().next().value);
        }
        this._map.set(key, value);
      }
    };
    exports2.LruCache = LruCache;
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js
var require_markdowncodeblocks2 = __commonJS({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MarkdownCodeBlocks = void 0;
    var MarkdownCodeBlocks;
    (function(MarkdownCodeBlocks2) {
      MarkdownCodeBlocks2.CODE_BLOCK_MARKER = "```";
      const markdownExtensions = [
        ".markdown",
        ".mdown",
        ".mkdn",
        ".md",
        ".mkd",
        ".mdwn",
        ".mdtxt",
        ".mdtext",
        ".text",
        ".txt",
        ".Rmd"
      ];
      class MarkdownCodeBlock {
        constructor(startLine) {
          this.startLine = startLine;
          this.code = "";
          this.endLine = -1;
        }
      }
      MarkdownCodeBlocks2.MarkdownCodeBlock = MarkdownCodeBlock;
      function isMarkdown(extension2) {
        return markdownExtensions.indexOf(extension2) > -1;
      }
      MarkdownCodeBlocks2.isMarkdown = isMarkdown;
      function findMarkdownCodeBlocks(text) {
        if (!text || text === "") {
          return [];
        }
        const lines = text.split("\n");
        const codeBlocks = [];
        let currentBlock = null;
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
          const line = lines[lineIndex];
          const lineContainsMarker = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER) === 0;
          const constructingBlock = currentBlock != null;
          if (!lineContainsMarker && !constructingBlock) {
            continue;
          }
          if (!constructingBlock) {
            currentBlock = new MarkdownCodeBlock(lineIndex);
            const firstIndex = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const lastIndex = line.lastIndexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const isSingleLine = firstIndex !== lastIndex;
            if (isSingleLine) {
              currentBlock.code = line.substring(firstIndex + MarkdownCodeBlocks2.CODE_BLOCK_MARKER.length, lastIndex);
              currentBlock.endLine = lineIndex;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            }
          } else if (currentBlock) {
            if (lineContainsMarker) {
              currentBlock.endLine = lineIndex - 1;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            } else {
              currentBlock.code += line + "\n";
            }
          }
        }
        return codeBlocks;
      }
      MarkdownCodeBlocks2.findMarkdownCodeBlocks = findMarkdownCodeBlocks;
    })(MarkdownCodeBlocks || (exports2.MarkdownCodeBlocks = MarkdownCodeBlocks = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/url.js
var require_url2 = __commonJS({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/url.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLExt = void 0;
    var path_1 = __require("path");
    var url_parse_1 = __importDefault2(require_url_parse());
    var URLExt3;
    (function(URLExt4) {
      function parse4(url) {
        if (typeof document !== "undefined" && document) {
          const a4 = document.createElement("a");
          a4.href = url;
          return a4;
        }
        return (0, url_parse_1.default)(url);
      }
      URLExt4.parse = parse4;
      function getHostName(url) {
        return (0, url_parse_1.default)(url).hostname;
      }
      URLExt4.getHostName = getHostName;
      function normalize2(url) {
        return url && parse4(url).toString();
      }
      URLExt4.normalize = normalize2;
      function join(...parts) {
        let u4 = (0, url_parse_1.default)(parts[0], {});
        const isSchemaLess = u4.protocol === "" && u4.slashes;
        if (isSchemaLess) {
          u4 = (0, url_parse_1.default)(parts[0], "https:" + parts[0]);
        }
        const prefix = `${isSchemaLess ? "" : u4.protocol}${u4.slashes ? "//" : ""}${u4.auth}${u4.auth ? "@" : ""}${u4.host}`;
        const path2 = path_1.posix.join(`${!!prefix && u4.pathname[0] !== "/" ? "/" : ""}${u4.pathname}`, ...parts.slice(1));
        return `${prefix}${path2 === "." ? "" : path2}`;
      }
      URLExt4.join = join;
      function encodeParts(url) {
        return join(...url.split("/").map(encodeURIComponent));
      }
      URLExt4.encodeParts = encodeParts;
      function objectToQueryString(value) {
        const keys2 = Object.keys(value).filter((key) => key.length > 0);
        if (!keys2.length) {
          return "";
        }
        return "?" + keys2.map((key) => {
          const content = encodeURIComponent(String(value[key]));
          return key + (content ? "=" + content : "");
        }).join("&");
      }
      URLExt4.objectToQueryString = objectToQueryString;
      function queryStringToObject(value) {
        return value.replace(/^\?/, "").split("&").reduce((acc, val) => {
          const [key, value2] = val.split("=");
          if (key.length > 0) {
            acc[key] = decodeURIComponent(value2 || "");
          }
          return acc;
        }, {});
      }
      URLExt4.queryStringToObject = queryStringToObject;
      function isLocal(url, allowRoot = false) {
        const { protocol } = parse4(url);
        return (!protocol || url.toLowerCase().indexOf(protocol) !== 0) && (allowRoot ? url.indexOf("//") !== 0 : url.indexOf("/") !== 0);
      }
      URLExt4.isLocal = isLocal;
    })(URLExt3 || (exports2.URLExt = URLExt3 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/pageconfig.js
var require_pageconfig2 = __commonJS({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/pageconfig.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageConfig = void 0;
    var coreutils_1 = require_dist();
    var minimist_1 = __importDefault(require_minimist());
    var url_1 = require_url2();
    var PageConfig;
    (function(PageConfig) {
      function getOption(name) {
        if (configData) {
          return configData[name] || getBodyData(name);
        }
        configData = /* @__PURE__ */ Object.create(null);
        let found = false;
        if (typeof document !== "undefined" && document) {
          const el = document.getElementById("jupyter-config-data");
          if (el) {
            configData = JSON.parse(el.textContent || "");
            found = true;
          }
        }
        if (!found && typeof process !== "undefined" && process.argv) {
          try {
            const cli = (0, minimist_1.default)(process.argv.slice(2));
            const path = __require("path");
            let fullPath = "";
            if ("jupyter-config-data" in cli) {
              fullPath = path.resolve(cli["jupyter-config-data"]);
            } else if ("JUPYTER_CONFIG_DATA" in process.env) {
              fullPath = path.resolve(process.env["JUPYTER_CONFIG_DATA"]);
            }
            if (fullPath) {
              configData = eval("require")(fullPath);
            }
          } catch (e4) {
            console.error(e4);
          }
        }
        if (!coreutils_1.JSONExt.isObject(configData)) {
          configData = /* @__PURE__ */ Object.create(null);
        } else {
          for (const key in configData) {
            if (typeof configData[key] !== "string") {
              configData[key] = JSON.stringify(configData[key]);
            }
          }
        }
        return configData[name] || getBodyData(name);
      }
      PageConfig.getOption = getOption;
      function setOption(name2, value) {
        const last2 = getOption(name2);
        configData[name2] = value;
        return last2;
      }
      PageConfig.setOption = setOption;
      function getBaseUrl() {
        return url_1.URLExt.normalize(getOption("baseUrl") || "/");
      }
      PageConfig.getBaseUrl = getBaseUrl;
      function getTreeUrl() {
        return url_1.URLExt.join(getBaseUrl(), getOption("treeUrl"));
      }
      PageConfig.getTreeUrl = getTreeUrl;
      function getShareUrl() {
        return url_1.URLExt.normalize(getOption("shareUrl") || getBaseUrl());
      }
      PageConfig.getShareUrl = getShareUrl;
      function getTreeShareUrl() {
        return url_1.URLExt.normalize(url_1.URLExt.join(getShareUrl(), getOption("treeUrl")));
      }
      PageConfig.getTreeShareUrl = getTreeShareUrl;
      function getUrl(options) {
        var _a, _b, _c, _d;
        let path2 = options.toShare ? getShareUrl() : getBaseUrl();
        const mode = (_a = options.mode) !== null && _a !== void 0 ? _a : getOption("mode");
        const workspace = (_b = options.workspace) !== null && _b !== void 0 ? _b : getOption("workspace");
        const labOrDoc = mode === "single-document" ? "doc" : "lab";
        path2 = url_1.URLExt.join(path2, labOrDoc);
        if (workspace !== PageConfig.defaultWorkspace) {
          path2 = url_1.URLExt.join(path2, "workspaces", encodeURIComponent((_c = getOption("workspace")) !== null && _c !== void 0 ? _c : PageConfig.defaultWorkspace));
        }
        const treePath = (_d = options.treePath) !== null && _d !== void 0 ? _d : getOption("treePath");
        if (treePath) {
          path2 = url_1.URLExt.join(path2, "tree", url_1.URLExt.encodeParts(treePath));
        }
        return path2;
      }
      PageConfig.getUrl = getUrl;
      PageConfig.defaultWorkspace = "default";
      function getWsUrl(baseUrl) {
        let wsUrl = getOption("wsUrl");
        if (!wsUrl) {
          baseUrl = baseUrl ? url_1.URLExt.normalize(baseUrl) : getBaseUrl();
          if (baseUrl.indexOf("http") !== 0) {
            return "";
          }
          wsUrl = "ws" + baseUrl.slice(4);
        }
        return url_1.URLExt.normalize(wsUrl);
      }
      PageConfig.getWsUrl = getWsUrl;
      function getNBConvertURL({ path: path2, format: format2, download }) {
        const notebookPath = url_1.URLExt.encodeParts(path2);
        const url = url_1.URLExt.join(getBaseUrl(), "nbconvert", format2, notebookPath);
        if (download) {
          return url + "?download=true";
        }
        return url;
      }
      PageConfig.getNBConvertURL = getNBConvertURL;
      function getToken() {
        return getOption("token") || getBodyData("jupyterApiToken");
      }
      PageConfig.getToken = getToken;
      function getNotebookVersion() {
        const notebookVersion = getOption("notebookVersion");
        if (notebookVersion === "") {
          return [0, 0, 0];
        }
        return JSON.parse(notebookVersion);
      }
      PageConfig.getNotebookVersion = getNotebookVersion;
      let configData = null;
      function getBodyData(key) {
        if (typeof document === "undefined" || !document.body) {
          return "";
        }
        const val = document.body.dataset[key];
        if (typeof val === "undefined") {
          return "";
        }
        return decodeURIComponent(val);
      }
      let Extension;
      (function(Extension2) {
        function populate(key) {
          try {
            const raw = getOption(key);
            if (raw) {
              return JSON.parse(raw);
            }
          } catch (error) {
            console.warn(`Unable to parse ${key}.`, error);
          }
          return [];
        }
        Extension2.deferred = populate("deferredExtensions");
        Extension2.disabled = populate("disabledExtensions");
        function isDeferred(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.deferred.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDeferred = isDeferred;
        function isDisabled(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.disabled.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDisabled = isDisabled;
      })(Extension = PageConfig.Extension || (PageConfig.Extension = {}));
    })(PageConfig || (exports.PageConfig = PageConfig = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/path.js
var require_path2 = __commonJS({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathExt = void 0;
    var path_1 = __require("path");
    var PathExt2;
    (function(PathExt3) {
      function join(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : removeSlash(path2);
      }
      PathExt3.join = join;
      function joinWithLeadingSlash(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : path2;
      }
      PathExt3.joinWithLeadingSlash = joinWithLeadingSlash;
      function basename(path2, ext) {
        return path_1.posix.basename(path2, ext);
      }
      PathExt3.basename = basename;
      function dirname(path2) {
        const dir = removeSlash(path_1.posix.dirname(path2));
        return dir === "." ? "" : dir;
      }
      PathExt3.dirname = dirname;
      function extname(path2) {
        return path_1.posix.extname(path2);
      }
      PathExt3.extname = extname;
      function normalize2(path2) {
        if (path2 === "") {
          return "";
        }
        return removeSlash(path_1.posix.normalize(path2));
      }
      PathExt3.normalize = normalize2;
      function resolve(...parts) {
        return removeSlash(path_1.posix.resolve(...parts));
      }
      PathExt3.resolve = resolve;
      function relative(from, to) {
        return removeSlash(path_1.posix.relative(from, to));
      }
      PathExt3.relative = relative;
      function normalizeExtension(extension2) {
        if (extension2.length > 0 && extension2.indexOf(".") !== 0) {
          extension2 = `.${extension2}`;
        }
        return extension2;
      }
      PathExt3.normalizeExtension = normalizeExtension;
      function removeSlash(path2) {
        if (path2.indexOf("/") === 0) {
          path2 = path2.slice(1);
        }
        return path2;
      }
      PathExt3.removeSlash = removeSlash;
    })(PathExt2 || (exports2.PathExt = PathExt2 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/signal.js
var require_signal2 = __commonJS({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/signal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signalToPromise = void 0;
    var coreutils_12 = require_dist();
    function signalToPromise(signal, timeout) {
      const waitForSignal = new coreutils_12.PromiseDelegate();
      function cleanup() {
        signal.disconnect(slot);
      }
      function slot(sender, args) {
        cleanup();
        waitForSignal.resolve([sender, args]);
      }
      signal.connect(slot);
      if ((timeout !== null && timeout !== void 0 ? timeout : 0) > 0) {
        setTimeout(() => {
          cleanup();
          waitForSignal.reject(`Signal not emitted within ${timeout} ms.`);
        }, timeout);
      }
      return waitForSignal.promise;
    }
    exports2.signalToPromise = signalToPromise;
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/text.js
var require_text2 = __commonJS({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/text.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Text = void 0;
    var Text;
    (function(Text2) {
      const HAS_SURROGATES = "\u{1D41A}".length > 1;
      function jsIndexToCharIndex(jsIdx, text) {
        if (HAS_SURROGATES) {
          return jsIdx;
        }
        let charIdx = jsIdx;
        for (let i5 = 0; i5 + 1 < text.length && i5 < jsIdx; i5++) {
          const charCode = text.charCodeAt(i5);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i5 + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              charIdx--;
              i5++;
            }
          }
        }
        return charIdx;
      }
      Text2.jsIndexToCharIndex = jsIndexToCharIndex;
      function charIndexToJsIndex(charIdx, text) {
        if (HAS_SURROGATES) {
          return charIdx;
        }
        let jsIdx = charIdx;
        for (let i5 = 0; i5 + 1 < text.length && i5 < jsIdx; i5++) {
          const charCode = text.charCodeAt(i5);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i5 + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              jsIdx++;
              i5++;
            }
          }
        }
        return jsIdx;
      }
      Text2.charIndexToJsIndex = charIndexToJsIndex;
      function camelCase(str2, upper = false) {
        return str2.replace(/^(\w)|[\s-_:]+(\w)/g, function(match, p1, p22) {
          if (p22) {
            return p22.toUpperCase();
          } else {
            return upper ? p1.toUpperCase() : p1.toLowerCase();
          }
        });
      }
      Text2.camelCase = camelCase;
      function titleCase(str2) {
        return (str2 || "").toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
      }
      Text2.titleCase = titleCase;
    })(Text || (exports2.Text = Text = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/time.js
var require_time2 = __commonJS({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Time = void 0;
    var UNITS = [
      { name: "years", milliseconds: 365 * 24 * 60 * 60 * 1e3 },
      { name: "months", milliseconds: 30 * 24 * 60 * 60 * 1e3 },
      { name: "days", milliseconds: 24 * 60 * 60 * 1e3 },
      { name: "hours", milliseconds: 60 * 60 * 1e3 },
      { name: "minutes", milliseconds: 60 * 1e3 },
      { name: "seconds", milliseconds: 1e3 }
    ];
    var Time;
    (function(Time2) {
      function formatHuman(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.RelativeTimeFormat(lang, { numeric: "auto" });
        const delta = new Date(value).getTime() - Date.now();
        for (let unit of UNITS) {
          const amount = Math.ceil(delta / unit.milliseconds);
          if (amount === 0) {
            continue;
          }
          return formatter.format(amount, unit.name);
        }
        return formatter.format(0, "seconds");
      }
      Time2.formatHuman = formatHuman;
      function format2(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.DateTimeFormat(lang, {
          dateStyle: "short",
          timeStyle: "short"
        });
        return formatter.format(new Date(value));
      }
      Time2.format = format2;
    })(Time || (exports2.Time = Time = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/index.js
var require_lib5 = __commonJS({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/coreutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_activitymonitor2(), exports2);
    __exportStar(require_interfaces3(), exports2);
    __exportStar(require_lru(), exports2);
    __exportStar(require_markdowncodeblocks2(), exports2);
    __exportStar(require_pageconfig2(), exports2);
    __exportStar(require_path2(), exports2);
    __exportStar(require_signal2(), exports2);
    __exportStar(require_text2(), exports2);
    __exportStar(require_time2(), exports2);
    __exportStar(require_url2(), exports2);
  }
});

// ../../node_modules/lodash.escape/index.js
var require_lodash = __commonJS({
  "../../node_modules/lodash.escape/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reUnescapedHtml = /[&<>"'`]/g;
    var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "`": "&#96;"
    };
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    function basePropertyOf(object2) {
      return function(key) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root2.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString3(value) {
      return value == null ? "" : baseToString(value);
    }
    function escape2(string) {
      string = toString3(string);
      return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
    }
    module2.exports = escape2;
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/latex.js
function removeMath(text) {
  const math = [];
  let start = null;
  let end = null;
  let last2 = null;
  let braces = 0;
  let deTilde;
  const hasCodeSpans = text.includes("`") || text.includes("~~~");
  if (hasCodeSpans) {
    text = text.replace(/~/g, "~T").replace(/^(?<fence>`{3,}|(~T){3,})[^`\n]*\n([\s\S]*?)^\k<fence>`*$/gm, (wholematch) => wholematch.replace(/\$/g, "~D")).replace(/(^|[^\\])(`+)([^\n]*?[^`\n])\2(?!`)/gm, (wholematch) => wholematch.replace(/\$/g, "~D"));
    deTilde = (text2) => {
      return text2.replace(/~([TD])/g, (wholematch, character) => character === "T" ? "~" : inline2);
    };
  } else {
    deTilde = (text2) => {
      return text2;
    };
  }
  let blocks = text.replace(/\r\n?/g, "\n").split(MATHSPLIT);
  for (let i5 = 1, m4 = blocks.length; i5 < m4; i5 += 2) {
    const block = blocks[i5];
    if (block.charAt(0) === "@") {
      blocks[i5] = "@@" + math.length + "@@";
      math.push(block);
    } else if (start !== null) {
      if (block === end) {
        if (braces) {
          last2 = i5;
        } else {
          blocks = processMath(start, i5, deTilde, math, blocks);
          start = null;
          end = null;
          last2 = null;
        }
      } else if (block.match(/\n.*\n/)) {
        if (last2 !== null) {
          i5 = last2;
          blocks = processMath(start, i5, deTilde, math, blocks);
        }
        start = null;
        end = null;
        last2 = null;
        braces = 0;
      } else if (block === "{") {
        braces++;
      } else if (block === "}" && braces) {
        braces--;
      }
    } else {
      if (block === inline2 || block === "$$") {
        start = i5;
        end = block;
        braces = 0;
      } else if (block === "\\\\(" || block === "\\\\[") {
        start = i5;
        end = block.slice(-1) === "(" ? "\\\\)" : "\\\\]";
        braces = 0;
      } else if (block.substr(1, 5) === "begin") {
        start = i5;
        end = "\\end" + block.substr(6);
        braces = 0;
      }
    }
  }
  if (start !== null && last2 !== null) {
    blocks = processMath(start, last2, deTilde, math, blocks);
    start = null;
    end = null;
    last2 = null;
  }
  return { text: deTilde(blocks.join("")), math };
}
function replaceMath(text, math) {
  const process2 = (match, n4) => {
    let group2 = math[n4];
    if (group2.substr(0, 3) === "\\\\(" && group2.substr(group2.length - 3) === "\\\\)") {
      group2 = "\\(" + group2.substring(3, group2.length - 3) + "\\)";
    } else if (group2.substr(0, 3) === "\\\\[" && group2.substr(group2.length - 3) === "\\\\]") {
      group2 = "\\[" + group2.substring(3, group2.length - 3) + "\\]";
    }
    return group2;
  };
  return text.replace(/@@(\d+)@@/g, process2);
}
function processMath(i5, j2, preProcess, math, blocks) {
  let block = blocks.slice(i5, j2 + 1).join("").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  if (navigator && navigator.appName === "Microsoft Internet Explorer") {
    block = block.replace(/(%[^\n]*)\n/g, "$1<br/>\n");
  }
  while (j2 > i5) {
    blocks[j2] = "";
    j2--;
  }
  blocks[i5] = "@@" + math.length + "@@";
  if (preProcess) {
    block = preProcess(block);
  }
  math.push(block);
  return blocks;
}
var inline2, MATHSPLIT;
var init_latex = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/latex.js"() {
    inline2 = "$";
    MATHSPLIT = /(\$\$?|\\(?:begin|end)\{[a-z]*\*?\}|\\[{}$]|[{}]|(?:\n\s*)+|@@\d+@@|\\\\(?:\(|\)|\[|\]))/i;
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/renderers.js
function renderHTML(options) {
  let { host, source, trusted, sanitizer, resolver, linkHandler, shouldTypeset, latexTypesetter, translator } = options;
  translator = translator || nullTranslator;
  const trans = translator === null || translator === void 0 ? void 0 : translator.load("jupyterlab");
  let originalSource = source;
  if (!source) {
    host.textContent = "";
    return Promise.resolve(void 0);
  }
  if (!trusted) {
    originalSource = `${source}`;
    source = sanitizer.sanitize(source);
  }
  host.innerHTML = source;
  if (host.getElementsByTagName("script").length > 0) {
    if (trusted) {
      Private7.evalInnerHTMLScriptTags(host);
    } else {
      const container = document.createElement("div");
      const warning = document.createElement("pre");
      warning.textContent = trans.__("This HTML output contains inline scripts. Are you sure that you want to run arbitrary Javascript within your JupyterLab session?");
      const runButton = document.createElement("button");
      runButton.textContent = trans.__("Run");
      runButton.onclick = (event) => {
        host.innerHTML = originalSource;
        Private7.evalInnerHTMLScriptTags(host);
        if (host.firstChild) {
          host.removeChild(host.firstChild);
        }
      };
      container.appendChild(warning);
      container.appendChild(runButton);
      host.insertBefore(container, host.firstChild);
    }
  }
  Private7.handleDefaults(host, resolver);
  let promise;
  if (resolver) {
    promise = Private7.handleUrls(host, resolver, linkHandler);
  } else {
    promise = Promise.resolve(void 0);
  }
  return promise.then(() => {
    if (shouldTypeset && latexTypesetter) {
      latexTypesetter.typeset(host);
    }
  });
}
function renderImage(options) {
  const { host, mimeType, source, width, height, needsBackground, unconfined } = options;
  host.textContent = "";
  const img = document.createElement("img");
  img.src = `data:${mimeType};base64,${source}`;
  if (typeof height === "number") {
    img.height = height;
  }
  if (typeof width === "number") {
    img.width = width;
  }
  if (needsBackground === "light") {
    img.classList.add("jp-needs-light-background");
  } else if (needsBackground === "dark") {
    img.classList.add("jp-needs-dark-background");
  }
  if (unconfined === true) {
    img.classList.add("jp-mod-unconfined");
  }
  host.appendChild(img);
  return Promise.resolve(void 0);
}
function renderLatex(options) {
  const { host, source, shouldTypeset, latexTypesetter } = options;
  host.textContent = source;
  if (shouldTypeset && latexTypesetter) {
    latexTypesetter.typeset(host);
  }
  return Promise.resolve(void 0);
}
async function renderMarkdown(options) {
  const { host, source, markdownParser, ...others } = options;
  if (!source) {
    host.textContent = "";
    return;
  }
  let html = "";
  if (markdownParser) {
    const parts = removeMath(source);
    html = await markdownParser.render(parts["text"]);
    html = replaceMath(html, parts["math"]);
  } else {
    html = `<pre>${source}</pre>`;
  }
  await renderHTML({
    host,
    source: html,
    ...others
  });
  Private7.headerAnchors(host);
}
function renderSVG(options) {
  let { host, source, trusted, unconfined } = options;
  if (!source) {
    host.textContent = "";
    return Promise.resolve(void 0);
  }
  if (!trusted) {
    host.textContent = "Cannot display an untrusted SVG. Maybe you need to run the cell?";
    return Promise.resolve(void 0);
  }
  const patt = "<svg[^>]+xmlns=[^>]+svg";
  if (source.search(patt) < 0) {
    source = source.replace("<svg", '<svg xmlns="http://www.w3.org/2000/svg"');
  }
  const img = new Image();
  img.src = `data:image/svg+xml,${encodeURIComponent(source)}`;
  host.appendChild(img);
  if (unconfined === true) {
    host.classList.add("jp-mod-unconfined");
  }
  return Promise.resolve();
}
function autolink(content, options) {
  const linkers = [];
  if (options.checkWeb) {
    linkers.push(new WebLinker());
  }
  if (options.checkPaths) {
    linkers.push(new PathLinker());
  }
  const nodes = [];
  const linkify = (content2, regexIndex) => {
    if (regexIndex >= linkers.length) {
      nodes.push(document.createTextNode(content2));
      return;
    }
    const linker = linkers[regexIndex];
    let match;
    let currentIndex = 0;
    const regex = linker.regex;
    regex.lastIndex = 0;
    while (null != (match = regex.exec(content2))) {
      const stringBeforeMatch = content2.substring(currentIndex, match.index);
      if (stringBeforeMatch) {
        linkify(stringBeforeMatch, regexIndex + 1);
      }
      const { path: path2, ...locators } = match.groups;
      const value = linker.processPath ? linker.processPath(path2) : path2;
      const label = linker.processLabel ? linker.processLabel(match[0]) : match[0];
      nodes.push(linker.createAnchor(value, label, locators));
      currentIndex = match.index + label.length;
    }
    const stringAfterMatches = content2.substring(currentIndex);
    if (stringAfterMatches) {
      linkify(stringAfterMatches, regexIndex + 1);
    }
  };
  linkify(content, 0);
  return nodes;
}
function splitShallowNode(node, at) {
  var _a, _b;
  const pre = node.cloneNode();
  pre.textContent = (_a = node.textContent) === null || _a === void 0 ? void 0 : _a.slice(0, at);
  const post = node.cloneNode();
  post.textContent = (_b = node.textContent) === null || _b === void 0 ? void 0 : _b.slice(at);
  return {
    pre,
    post
  };
}
function* nodeIter(nodes) {
  var _a;
  let start = 0;
  let end;
  for (let node of nodes) {
    end = start + (((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0);
    yield {
      node,
      start,
      end,
      isText: node.nodeType === Node.TEXT_NODE
    };
    start = end;
  }
}
function* alignedNodes(a4, b4) {
  var _a, _b;
  let iterA = nodeIter(a4);
  let iterB = nodeIter(b4);
  let nA = iterA.next();
  let nB = iterB.next();
  while (!nA.done && !nB.done) {
    let A = nA.value;
    let B2 = nB.value;
    if (A.isText && A.start <= B2.start && A.end >= B2.end) {
      yield [null, B2.node];
      nB = iterB.next();
    } else if (B2.isText && B2.start <= A.start && B2.end >= A.end) {
      yield [A.node, null];
      nA = iterA.next();
    } else {
      if (A.end === B2.end && A.start === B2.start) {
        yield [A.node, B2.node];
        nA = iterA.next();
        nB = iterB.next();
      } else if (A.end > B2.end) {
        let { pre, post } = splitShallowNode(A.node, B2.end - A.start);
        if (B2.start < A.start) {
          B2.node.textContent = (_a = B2.node.textContent) === null || _a === void 0 ? void 0 : _a.slice(A.start - B2.start);
        }
        yield [pre, B2.node];
        A.node = post;
        A.start = B2.end;
        nB = iterB.next();
      } else if (B2.end > A.end) {
        let { pre, post } = splitShallowNode(B2.node, A.end - B2.start);
        if (A.start < B2.start) {
          A.node.textContent = (_b = A.node.textContent) === null || _b === void 0 ? void 0 : _b.slice(B2.start - A.start);
        }
        yield [A.node, pre];
        B2.node = post;
        B2.start = A.end;
        nA = iterA.next();
      } else {
        throw new Error(`Unexpected intersection: ${JSON.stringify(A)} ${JSON.stringify(B2)}`);
      }
    }
  }
}
function renderText(options) {
  var _a, _b;
  const { host, sanitizer, source } = options;
  const content = sanitizer.sanitize(Private7.ansiSpan(source), {
    allowedTags: ["span"]
  });
  const pre = document.createElement("pre");
  pre.innerHTML = content;
  const preTextContent = pre.textContent;
  let ret;
  if (preTextContent) {
    const linkedNodes = ((_b = (_a = sanitizer.getAutolink) === null || _a === void 0 ? void 0 : _a.call(sanitizer)) !== null && _b !== void 0 ? _b : true) ? autolink(preTextContent, {
      checkWeb: true,
      checkPaths: false
    }) : [document.createTextNode(content)];
    const preNodes = Array.from(pre.childNodes);
    ret = mergeNodes(preNodes, linkedNodes);
  } else {
    ret = document.createElement("pre");
  }
  host.appendChild(ret);
  return Promise.resolve(void 0);
}
function mergeNodes(preNodes, linkedNodes) {
  const ret = document.createElement("pre");
  let inAnchorElement = false;
  const combinedNodes = [];
  for (let nodes of alignedNodes(preNodes, linkedNodes)) {
    if (!nodes[0]) {
      combinedNodes.push(nodes[1]);
      inAnchorElement = nodes[1].nodeType !== Node.TEXT_NODE;
      continue;
    } else if (!nodes[1]) {
      combinedNodes.push(nodes[0]);
      inAnchorElement = false;
      continue;
    }
    let [preNode, linkNode] = nodes;
    const lastCombined = combinedNodes[combinedNodes.length - 1];
    if (inAnchorElement && linkNode.href === lastCombined.href) {
      lastCombined.appendChild(preNode);
    } else {
      const isAnchor = linkNode.nodeType !== Node.TEXT_NODE;
      if (!isAnchor) {
        combinedNodes.push(preNode);
        inAnchorElement = false;
      } else {
        linkNode.textContent = "";
        linkNode.appendChild(preNode);
        combinedNodes.push(linkNode);
        inAnchorElement = true;
      }
    }
  }
  for (const child of combinedNodes) {
    ret.appendChild(child);
  }
  return ret;
}
var import_coreutils4, import_lodash, ILinker, WebLinker, PathLinker, Private7;
var init_renderers = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/renderers.js"() {
    import_coreutils4 = __toESM(require_lib5());
    init_lib();
    import_lodash = __toESM(require_lodash());
    init_latex();
    (function(renderMarkdown2) {
      function createHeaderId(header) {
        var _a;
        return ((_a = header.textContent) !== null && _a !== void 0 ? _a : "").replace(/ /g, "-");
      }
      renderMarkdown2.createHeaderId = createHeaderId;
    })(renderMarkdown || (renderMarkdown = {}));
    (function(ILinker2) {
      const controlCodes = "\\u0000-\\u0020\\u007f-\\u009f";
      ILinker2.webLinkRegex = new RegExp("(?<path>(?:[a-zA-Z][a-zA-Z0-9+.-]{2,}:\\/\\/|data:|www\\.)[^\\s" + controlCodes + '"]{2,}[^\\s' + controlCodes + `"'(){}\\[\\],:;.!?])`, "ug");
      const winAbsPathRegex = /(?:[a-zA-Z]:(?:(?:\\|\/)[\w\.-]*)+)/;
      const winRelPathRegex = /(?:(?:\~|\.)(?:(?:\\|\/)[\w\.-]*)+)/;
      const winPathRegex = new RegExp(`(${winAbsPathRegex.source}|${winRelPathRegex.source})`);
      const posixPathRegex = /((?:\~|\.)?(?:\/[\w\.-]*)+)/;
      const lineColumnRegex = /(?:(?:\:|", line )(?<line>[\d]+))?(?:\:(?<column>[\d]+))?/;
      const isWindows = navigator.userAgent.indexOf("Windows") >= 0;
      ILinker2.pathLinkRegex = new RegExp(`(?<path>${isWindows ? winPathRegex.source : posixPathRegex.source})${lineColumnRegex.source}`, "g");
    })(ILinker || (ILinker = {}));
    WebLinker = class {
      constructor() {
        this.regex = ILinker.webLinkRegex;
      }
      createAnchor(url, label) {
        const anchor = document.createElement("a");
        anchor.href = url.startsWith("www.") ? "https://" + url : url;
        anchor.rel = "noopener";
        anchor.target = "_blank";
        anchor.appendChild(document.createTextNode(label));
        return anchor;
      }
      processPath(url) {
        const lastChars = url.slice(-1);
        const endsWithGtLt = [">", "<"].indexOf(lastChars) !== -1;
        const len = endsWithGtLt ? url.length - 1 : url.length;
        url = url.slice(0, len);
        return url;
      }
      processLabel(url) {
        return this.processPath(url);
      }
    };
    PathLinker = class {
      constructor() {
        this.regex = ILinker.pathLinkRegex;
      }
      createAnchor(path2, label, locators) {
        const anchor = document.createElement("a");
        anchor.dataset.path = path2;
        const line = parseInt(locators["line"], 10);
        let locator = !isNaN(line) ? `line=${line - 1}` : "";
        anchor.dataset.locator = locator;
        anchor.appendChild(document.createTextNode(label));
        return anchor;
      }
    };
    (function(Private19) {
      function evalInnerHTMLScriptTags(host) {
        const scripts = Array.from(host.getElementsByTagName("script"));
        for (const script of scripts) {
          if (!script.parentNode) {
            continue;
          }
          const clone2 = document.createElement("script");
          const attrs = script.attributes;
          for (let i5 = 0, n4 = attrs.length; i5 < n4; ++i5) {
            const { name: name2, value } = attrs[i5];
            clone2.setAttribute(name2, value);
          }
          clone2.textContent = script.textContent;
          script.parentNode.replaceChild(clone2, script);
        }
      }
      Private19.evalInnerHTMLScriptTags = evalInnerHTMLScriptTags;
      function handleDefaults(node, resolver) {
        const anchors = node.getElementsByTagName("a");
        for (let i5 = 0; i5 < anchors.length; i5++) {
          const el = anchors[i5];
          if (!(el instanceof HTMLAnchorElement)) {
            continue;
          }
          const path2 = el.href;
          const isLocal = resolver && resolver.isLocal ? resolver.isLocal(path2) : import_coreutils4.URLExt.isLocal(path2);
          if (!el.target) {
            el.target = isLocal ? "_self" : "_blank";
          }
          if (!isLocal) {
            el.rel = "noopener";
          }
        }
        const imgs = node.getElementsByTagName("img");
        for (let i5 = 0; i5 < imgs.length; i5++) {
          if (!imgs[i5].alt) {
            imgs[i5].alt = "Image";
          }
        }
      }
      Private19.handleDefaults = handleDefaults;
      function handleUrls(node, resolver, linkHandler) {
        const promises = [];
        const nodes = node.querySelectorAll("*[src]");
        for (let i5 = 0; i5 < nodes.length; i5++) {
          promises.push(handleAttr(nodes[i5], "src", resolver));
        }
        const anchors = node.getElementsByTagName("a");
        for (let i5 = 0; i5 < anchors.length; i5++) {
          promises.push(handleAnchor(anchors[i5], resolver, linkHandler));
        }
        const links = node.getElementsByTagName("link");
        for (let i5 = 0; i5 < links.length; i5++) {
          promises.push(handleAttr(links[i5], "href", resolver));
        }
        return Promise.all(promises).then(() => void 0);
      }
      Private19.handleUrls = handleUrls;
      async function handlePaths(node, resolver, linkHandler) {
        const anchors = node.getElementsByTagName("a");
        for (let i5 = 0; i5 < anchors.length; i5++) {
          await handlePathAnchor(anchors[i5], resolver, linkHandler);
        }
      }
      Private19.handlePaths = handlePaths;
      function headerAnchors(node) {
        const headerNames = ["h1", "h2", "h3", "h4", "h5", "h6"];
        for (const headerType of headerNames) {
          const headers = node.getElementsByTagName(headerType);
          for (let i5 = 0; i5 < headers.length; i5++) {
            const header = headers[i5];
            header.id = renderMarkdown.createHeaderId(header);
            const anchor = document.createElement("a");
            anchor.target = "_self";
            anchor.textContent = "\xB6";
            anchor.href = "#" + header.id;
            anchor.classList.add("jp-InternalAnchorLink");
            header.appendChild(anchor);
          }
        }
      }
      Private19.headerAnchors = headerAnchors;
      async function handleAttr(node, name2, resolver) {
        const source = node.getAttribute(name2) || "";
        const isLocal = resolver.isLocal ? resolver.isLocal(source) : import_coreutils4.URLExt.isLocal(source);
        if (!source || !isLocal) {
          return;
        }
        try {
          const urlPath = await resolver.resolveUrl(source);
          let url = await resolver.getDownloadUrl(urlPath);
          if (import_coreutils4.URLExt.parse(url).protocol !== "data:") {
            url += (/\?/.test(url) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
          }
          node.setAttribute(name2, url);
        } catch (err) {
          node.setAttribute(name2, "");
          throw err;
        }
      }
      function handleAnchor(anchor, resolver, linkHandler) {
        let href = anchor.getAttribute("href") || "";
        const isLocal = resolver.isLocal ? resolver.isLocal(href) : import_coreutils4.URLExt.isLocal(href);
        if (!href || !isLocal) {
          return Promise.resolve(void 0);
        }
        const hash = anchor.hash;
        if (hash) {
          if (hash === href) {
            anchor.target = "_self";
            return Promise.resolve(void 0);
          }
          href = href.replace(hash, "");
        }
        return resolver.resolveUrl(href).then((urlPath) => {
          const path2 = decodeURIComponent(urlPath);
          if (linkHandler) {
            linkHandler.handleLink(anchor, path2, hash);
          }
          return resolver.getDownloadUrl(urlPath);
        }).then((url) => {
          anchor.href = url + hash;
        }).catch((err) => {
          anchor.href = "";
        });
      }
      async function handlePathAnchor(anchor, resolver, linkHandler) {
        let path2 = anchor.dataset.path || "";
        let locator = anchor.dataset.locator ? "#" + anchor.dataset.locator : "";
        delete anchor.dataset.path;
        delete anchor.dataset.locator;
        const allowRoot = true;
        const isLocal = resolver.isLocal ? resolver.isLocal(path2, allowRoot) : import_coreutils4.URLExt.isLocal(path2, allowRoot);
        if (!path2 || !isLocal || !resolver.resolvePath || !linkHandler || !linkHandler.handlePath) {
          anchor.replaceWith(...anchor.childNodes);
          return Promise.resolve(void 0);
        }
        try {
          const resolution = await resolver.resolvePath(path2);
          if (!resolution) {
            console.log("Path resolution bailing: does not exist");
            return Promise.resolve(void 0);
          }
          linkHandler.handlePath(anchor, resolution.path, resolution.scope, locator);
          anchor.href = resolution.path + locator;
        } catch (err) {
          console.warn("Path anchor error:", err);
          anchor.href = "#linking-failed-see-console";
        }
      }
      const ANSI_COLORS = [
        "ansi-black",
        "ansi-red",
        "ansi-green",
        "ansi-yellow",
        "ansi-blue",
        "ansi-magenta",
        "ansi-cyan",
        "ansi-white",
        "ansi-black-intense",
        "ansi-red-intense",
        "ansi-green-intense",
        "ansi-yellow-intense",
        "ansi-blue-intense",
        "ansi-magenta-intense",
        "ansi-cyan-intense",
        "ansi-white-intense"
      ];
      function pushColoredChunk(chunk2, fg, bg, bold, underline, inverse, out) {
        if (chunk2) {
          const classes = [];
          const styles = [];
          if (bold && typeof fg === "number" && 0 <= fg && fg < 8) {
            fg += 8;
          }
          if (inverse) {
            [fg, bg] = [bg, fg];
          }
          if (typeof fg === "number") {
            classes.push(ANSI_COLORS[fg] + "-fg");
          } else if (fg.length) {
            styles.push(`color: rgb(${fg})`);
          } else if (inverse) {
            classes.push("ansi-default-inverse-fg");
          }
          if (typeof bg === "number") {
            classes.push(ANSI_COLORS[bg] + "-bg");
          } else if (bg.length) {
            styles.push(`background-color: rgb(${bg})`);
          } else if (inverse) {
            classes.push("ansi-default-inverse-bg");
          }
          if (bold) {
            classes.push("ansi-bold");
          }
          if (underline) {
            classes.push("ansi-underline");
          }
          if (classes.length || styles.length) {
            out.push("<span");
            if (classes.length) {
              out.push(` class="${classes.join(" ")}"`);
            }
            if (styles.length) {
              out.push(` style="${styles.join("; ")}"`);
            }
            out.push(">");
            out.push(chunk2);
            out.push("</span>");
          } else {
            out.push(chunk2);
          }
        }
      }
      function getExtendedColors(numbers) {
        let r4;
        let g4;
        let b4;
        const n4 = numbers.shift();
        if (n4 === 2 && numbers.length >= 3) {
          r4 = numbers.shift();
          g4 = numbers.shift();
          b4 = numbers.shift();
          if ([r4, g4, b4].some((c6) => c6 < 0 || 255 < c6)) {
            throw new RangeError("Invalid range for RGB colors");
          }
        } else if (n4 === 5 && numbers.length >= 1) {
          const idx = numbers.shift();
          if (idx < 0) {
            throw new RangeError("Color index must be >= 0");
          } else if (idx < 16) {
            return idx;
          } else if (idx < 232) {
            r4 = Math.floor((idx - 16) / 36);
            r4 = r4 > 0 ? 55 + r4 * 40 : 0;
            g4 = Math.floor((idx - 16) % 36 / 6);
            g4 = g4 > 0 ? 55 + g4 * 40 : 0;
            b4 = (idx - 16) % 6;
            b4 = b4 > 0 ? 55 + b4 * 40 : 0;
          } else if (idx < 256) {
            r4 = g4 = b4 = (idx - 232) * 10 + 8;
          } else {
            throw new RangeError("Color index must be < 256");
          }
        } else {
          throw new RangeError("Invalid extended color specification");
        }
        return [r4, g4, b4];
      }
      function ansiSpan(str2) {
        const ansiRe = /\x1b\[(.*?)([@-~])/g;
        let fg = [];
        let bg = [];
        let bold = false;
        let underline = false;
        let inverse = false;
        let match;
        const out = [];
        const numbers = [];
        let start = 0;
        str2 = (0, import_lodash.default)(str2);
        str2 += "\x1B[m";
        while (match = ansiRe.exec(str2)) {
          if (match[2] === "m") {
            const items = match[1].split(";");
            for (let i5 = 0; i5 < items.length; i5++) {
              const item = items[i5];
              if (item === "") {
                numbers.push(0);
              } else if (item.search(/^\d+$/) !== -1) {
                numbers.push(parseInt(item, 10));
              } else {
                numbers.length = 0;
                break;
              }
            }
          } else {
          }
          const chunk2 = str2.substring(start, match.index);
          pushColoredChunk(chunk2, fg, bg, bold, underline, inverse, out);
          start = ansiRe.lastIndex;
          while (numbers.length) {
            const n4 = numbers.shift();
            switch (n4) {
              case 0:
                fg = bg = [];
                bold = false;
                underline = false;
                inverse = false;
                break;
              case 1:
              case 5:
                bold = true;
                break;
              case 4:
                underline = true;
                break;
              case 7:
                inverse = true;
                break;
              case 21:
              case 22:
                bold = false;
                break;
              case 24:
                underline = false;
                break;
              case 27:
                inverse = false;
                break;
              case 30:
              case 31:
              case 32:
              case 33:
              case 34:
              case 35:
              case 36:
              case 37:
                fg = n4 - 30;
                break;
              case 38:
                try {
                  fg = getExtendedColors(numbers);
                } catch (e4) {
                  numbers.length = 0;
                }
                break;
              case 39:
                fg = [];
                break;
              case 40:
              case 41:
              case 42:
              case 43:
              case 44:
              case 45:
              case 46:
              case 47:
                bg = n4 - 40;
                break;
              case 48:
                try {
                  bg = getExtendedColors(numbers);
                } catch (e4) {
                  numbers.length = 0;
                }
                break;
              case 49:
                bg = [];
                break;
              case 90:
              case 91:
              case 92:
              case 93:
              case 94:
              case 95:
              case 96:
              case 97:
                fg = n4 - 90 + 8;
                break;
              case 100:
              case 101:
              case 102:
              case 103:
              case 104:
              case 105:
              case 106:
              case 107:
                bg = n4 - 100 + 8;
                break;
              default:
            }
          }
        }
        return out.join("");
      }
      Private19.ansiSpan = ansiSpan;
    })(Private7 || (Private7 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/widgets.js
var RenderedCommon, RenderedHTMLCommon, RenderedHTML, RenderedLatex, RenderedImage, RenderedMarkdown, RenderedSVG, RenderedText, RenderedJavaScript;
var init_widgets = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/widgets.js"() {
    init_lib();
    init_index_es64();
    init_renderers();
    RenderedCommon = class extends Widget {
      /**
       * Construct a new rendered common widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        var _a, _b;
        super();
        this.mimeType = options.mimeType;
        this.sanitizer = options.sanitizer;
        this.resolver = options.resolver;
        this.linkHandler = options.linkHandler;
        this.translator = (_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator;
        this.latexTypesetter = options.latexTypesetter;
        this.markdownParser = (_b = options.markdownParser) !== null && _b !== void 0 ? _b : null;
        this.node.dataset["mimeType"] = this.mimeType;
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @param keepExisting - Whether to keep the existing rendering.
       *
       * @returns A promise which resolves when rendering is complete.
       *
       * #### Notes
       * By default, if the DOM node for this widget already has content, it
       * is emptied before rendering. Subclasses that do not want this behavior
       * (if, for instance, they are using DOM diffing), should override this
       * method or call `super.renderModel(model, true)`.
       */
      async renderModel(model, keepExisting) {
        if (!keepExisting) {
          while (this.node.firstChild) {
            this.node.removeChild(this.node.firstChild);
          }
        }
        this.toggleClass("jp-mod-trusted", model.trusted);
        await this.render(model);
        const { fragment } = model.metadata;
        if (fragment) {
          this.setFragment(fragment);
        }
      }
      /**
       * Set the URI fragment identifier.
       *
       * @param fragment - The URI fragment identifier.
       */
      setFragment(fragment) {
      }
    };
    RenderedHTMLCommon = class extends RenderedCommon {
      /**
       * Construct a new rendered HTML common widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedHTMLCommon");
      }
      setFragment(fragment) {
        let el;
        try {
          el = this.node.querySelector(fragment.startsWith("#") ? `#${CSS.escape(fragment.slice(1))}` : fragment);
        } catch (error) {
          console.warn("Unable to set URI fragment identifier.", error);
        }
        if (el) {
          el.scrollIntoView();
        }
      }
    };
    RenderedHTML = class extends RenderedHTMLCommon {
      /**
       * Construct a new rendered HTML widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this._rendered = Promise.resolve();
        this.addClass("jp-RenderedHTML");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        return this._rendered = renderHTML({
          host: this.node,
          source: String(model.data[this.mimeType]),
          trusted: model.trusted,
          resolver: this.resolver,
          sanitizer: this.sanitizer,
          linkHandler: this.linkHandler,
          shouldTypeset: this.isAttached,
          latexTypesetter: this.latexTypesetter,
          translator: this.translator
        });
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        this._rendered.then(() => {
          if (this.latexTypesetter) {
            this.latexTypesetter.typeset(this.node);
          }
        }).catch(console.warn);
      }
    };
    RenderedLatex = class extends RenderedCommon {
      /**
       * Construct a new rendered LaTeX widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this._rendered = Promise.resolve();
        this.addClass("jp-RenderedLatex");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        return this._rendered = renderLatex({
          host: this.node,
          source: String(model.data[this.mimeType]),
          shouldTypeset: this.isAttached,
          latexTypesetter: this.latexTypesetter
        });
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        this._rendered.then(() => {
          if (this.latexTypesetter) {
            this.latexTypesetter.typeset(this.node);
          }
        }).catch(console.warn);
      }
    };
    RenderedImage = class extends RenderedCommon {
      /**
       * Construct a new rendered image widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedImage");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        const metadata = model.metadata[this.mimeType];
        return renderImage({
          host: this.node,
          mimeType: this.mimeType,
          source: String(model.data[this.mimeType]),
          width: metadata && metadata.width,
          height: metadata && metadata.height,
          needsBackground: model.metadata["needs_background"],
          unconfined: metadata && metadata.unconfined
        });
      }
    };
    RenderedMarkdown = class extends RenderedHTMLCommon {
      /**
       * Construct a new rendered markdown widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this._rendered = Promise.resolve();
        this.addClass("jp-RenderedMarkdown");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        return this._rendered = renderMarkdown({
          host: this.node,
          source: String(model.data[this.mimeType]),
          trusted: model.trusted,
          resolver: this.resolver,
          sanitizer: this.sanitizer,
          linkHandler: this.linkHandler,
          shouldTypeset: this.isAttached,
          latexTypesetter: this.latexTypesetter,
          markdownParser: this.markdownParser,
          translator: this.translator
        });
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      async renderModel(model) {
        await super.renderModel(model, true);
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        this._rendered.then(() => {
          if (this.latexTypesetter) {
            this.latexTypesetter.typeset(this.node);
          }
        }).catch(console.warn);
      }
    };
    RenderedSVG = class extends RenderedCommon {
      /**
       * Construct a new rendered SVG widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this._rendered = Promise.resolve();
        this.addClass("jp-RenderedSVG");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        const metadata = model.metadata[this.mimeType];
        return this._rendered = renderSVG({
          host: this.node,
          source: String(model.data[this.mimeType]),
          trusted: model.trusted,
          unconfined: metadata && metadata.unconfined,
          translator: this.translator
        });
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        this._rendered.then(() => {
          if (this.latexTypesetter) {
            this.latexTypesetter.typeset(this.node);
          }
        }).catch(console.warn);
      }
    };
    RenderedText = class extends RenderedCommon {
      /**
       * Construct a new rendered text widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedText");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        return renderText({
          host: this.node,
          sanitizer: this.sanitizer,
          source: String(model.data[this.mimeType]),
          translator: this.translator
        });
      }
    };
    RenderedJavaScript = class extends RenderedCommon {
      /**
       * Construct a new rendered text widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedJavaScript");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        const trans = this.translator.load("jupyterlab");
        return renderText({
          host: this.node,
          sanitizer: this.sanitizer,
          source: trans.__("JavaScript output is disabled in JupyterLab"),
          translator: this.translator
        });
      }
    };
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/factories.js
var htmlRendererFactory, imageRendererFactory, latexRendererFactory, markdownRendererFactory, svgRendererFactory, textRendererFactory;
var init_factories = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/factories.js"() {
    init_widgets();
    htmlRendererFactory = {
      safe: true,
      mimeTypes: ["text/html"],
      defaultRank: 50,
      createRenderer: (options) => new RenderedHTML(options)
    };
    imageRendererFactory = {
      safe: true,
      mimeTypes: [
        "image/bmp",
        "image/png",
        "image/jpeg",
        "image/gif",
        "image/webp"
      ],
      defaultRank: 90,
      createRenderer: (options) => new RenderedImage(options)
    };
    latexRendererFactory = {
      safe: true,
      mimeTypes: ["text/latex"],
      defaultRank: 70,
      createRenderer: (options) => new RenderedLatex(options)
    };
    markdownRendererFactory = {
      safe: true,
      mimeTypes: ["text/markdown"],
      defaultRank: 60,
      createRenderer: (options) => new RenderedMarkdown(options)
    };
    svgRendererFactory = {
      safe: false,
      mimeTypes: ["image/svg+xml"],
      defaultRank: 80,
      createRenderer: (options) => new RenderedSVG(options)
    };
    textRendererFactory = {
      safe: true,
      mimeTypes: ["text/plain", "application/vnd.jupyter.stdout"],
      defaultRank: 120,
      createRenderer: (options) => new RenderedText(options)
    };
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/mimemodel.js
var MimeModel, Private8;
var init_mimemodel = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/mimemodel.js"() {
    MimeModel = class {
      /**
       * Construct a new mime model.
       */
      constructor(options = {}) {
        this.trusted = !!options.trusted;
        this._data = options.data || {};
        this._metadata = options.metadata || {};
        this._callback = options.callback || Private8.noOp;
      }
      /**
       * The data associated with the model.
       */
      get data() {
        return this._data;
      }
      /**
       * The metadata associated with the model.
       */
      get metadata() {
        return this._metadata;
      }
      /**
       * Set the data associated with the model.
       *
       * #### Notes
       * Depending on the implementation of the mime model,
       * this call may or may not have deferred effects,
       */
      setData(options) {
        this._data = options.data || this._data;
        this._metadata = options.metadata || this._metadata;
        this._callback(options);
      }
    };
    (function(Private19) {
      function noOp() {
      }
      Private19.noOp = noOp;
    })(Private8 || (Private8 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/nbformat/lib/index.js
function isExecuteResult(output) {
  return output.output_type === "execute_result";
}
function isDisplayData(output) {
  return output.output_type === "display_data";
}
function isDisplayUpdate(output) {
  return output.output_type === "update_display_data";
}
function isStream(output) {
  return output.output_type === "stream";
}
function isError(output) {
  return output.output_type === "error";
}
var import_coreutils5;
var init_lib5 = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@jupyterlab/nbformat/lib/index.js"() {
    import_coreutils5 = __toESM(require_dist());
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/outputmodel.js
var import_coreutils6, OutputModel, Private9;
var init_outputmodel = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/outputmodel.js"() {
    init_lib5();
    init_lib4();
    import_coreutils6 = __toESM(require_dist());
    init_index_es6();
    OutputModel = class {
      /**
       * Construct a new output model.
       */
      constructor(options) {
        this._changed = new Signal(this);
        this._raw = {};
        const { data, metadata, trusted } = Private9.getBundleOptions(options);
        this._data = new ObservableJSON({ values: data });
        this._rawData = data;
        this._metadata = new ObservableJSON({ values: metadata });
        this._rawMetadata = metadata;
        this.trusted = trusted;
        const value = options.value;
        for (const key in value) {
          switch (key) {
            case "data":
            case "metadata":
              break;
            default:
              this._raw[key] = Private9.extract(value, key);
          }
        }
        this.type = value.output_type;
        if (isExecuteResult(value)) {
          this.executionCount = value.execution_count;
        } else {
          this.executionCount = null;
        }
      }
      /**
       * A signal emitted when the output model changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Dispose of the resources used by the output model.
       */
      dispose() {
        this._data.dispose();
        this._metadata.dispose();
        Signal.clearData(this);
      }
      /**
       * The data associated with the model.
       */
      get data() {
        return this._rawData;
      }
      /**
       * The metadata associated with the model.
       */
      get metadata() {
        return this._rawMetadata;
      }
      /**
       * Set the data associated with the model.
       *
       * #### Notes
       * Depending on the implementation of the mime model,
       * this call may or may not have deferred effects,
       */
      setData(options) {
        if (options.data) {
          this._updateObservable(this._data, options.data);
          this._rawData = options.data;
        }
        if (options.metadata) {
          this._updateObservable(this._metadata, options.metadata);
          this._rawMetadata = options.metadata;
        }
        this._changed.emit();
      }
      /**
       * Serialize the model to JSON.
       */
      toJSON() {
        const output = {};
        for (const key in this._raw) {
          output[key] = Private9.extract(this._raw, key);
        }
        switch (this.type) {
          case "display_data":
          case "execute_result":
          case "update_display_data":
            output["data"] = this.data;
            output["metadata"] = this.metadata;
            break;
          default:
            break;
        }
        delete output["transient"];
        return output;
      }
      /**
       * Update an observable JSON object using a readonly JSON object.
       */
      _updateObservable(observable, data) {
        const oldKeys = observable.keys();
        const newKeys = Object.keys(data);
        for (const key of oldKeys) {
          if (newKeys.indexOf(key) === -1) {
            observable.delete(key);
          }
        }
        for (const key of newKeys) {
          const oldValue = observable.get(key);
          const newValue = data[key];
          if (oldValue !== newValue) {
            observable.set(key, newValue);
          }
        }
      }
    };
    (function(OutputModel4) {
      function getData(output) {
        return Private9.getData(output);
      }
      OutputModel4.getData = getData;
      function getMetadata(output) {
        return Private9.getMetadata(output);
      }
      OutputModel4.getMetadata = getMetadata;
    })(OutputModel || (OutputModel = {}));
    (function(Private19) {
      function getData(output) {
        let bundle = {};
        if (isExecuteResult(output) || isDisplayData(output) || isDisplayUpdate(output)) {
          bundle = output.data;
        } else if (isStream(output)) {
          if (output.name === "stderr") {
            bundle["application/vnd.jupyter.stderr"] = output.text;
          } else {
            bundle["application/vnd.jupyter.stdout"] = output.text;
          }
        } else if (isError(output)) {
          bundle["application/vnd.jupyter.error"] = output;
          const traceback = output.traceback.join("\n");
          bundle["application/vnd.jupyter.stderr"] = traceback || `${output.ename}: ${output.evalue}`;
        }
        return convertBundle(bundle);
      }
      Private19.getData = getData;
      function getMetadata(output) {
        const value = /* @__PURE__ */ Object.create(null);
        if (isExecuteResult(output) || isDisplayData(output)) {
          for (const key in output.metadata) {
            value[key] = extract(output.metadata, key);
          }
        }
        return value;
      }
      Private19.getMetadata = getMetadata;
      function getBundleOptions(options) {
        const data = getData(options.value);
        const metadata = getMetadata(options.value);
        const trusted = !!options.trusted;
        return { data, metadata, trusted };
      }
      Private19.getBundleOptions = getBundleOptions;
      function extract(value, key) {
        const item = value[key];
        if (item === void 0 || import_coreutils6.JSONExt.isPrimitive(item)) {
          return item;
        }
        return JSON.parse(JSON.stringify(item));
      }
      Private19.extract = extract;
      function convertBundle(bundle) {
        const map4 = /* @__PURE__ */ Object.create(null);
        for (const mimeType in bundle) {
          map4[mimeType] = extract(bundle, mimeType);
        }
        return map4;
      }
    })(Private9 || (Private9 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/registry.js
var import_coreutils7, RenderMimeRegistry, Private10;
var init_registry = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/registry.js"() {
    init_lib2();
    import_coreutils7 = __toESM(require_lib5());
    init_lib();
    init_mimemodel();
    RenderMimeRegistry = class {
      /**
       * Construct a new rendermime.
       *
       * @param options - The options for initializing the instance.
       */
      constructor(options = {}) {
        var _a, _b, _c, _d, _e, _f;
        this._id = 0;
        this._ranks = {};
        this._types = null;
        this._factories = {};
        this.translator = (_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator;
        this.resolver = (_b = options.resolver) !== null && _b !== void 0 ? _b : null;
        this.linkHandler = (_c = options.linkHandler) !== null && _c !== void 0 ? _c : null;
        this.latexTypesetter = (_d = options.latexTypesetter) !== null && _d !== void 0 ? _d : null;
        this.markdownParser = (_e = options.markdownParser) !== null && _e !== void 0 ? _e : null;
        this.sanitizer = (_f = options.sanitizer) !== null && _f !== void 0 ? _f : new Sanitizer();
        if (options.initialFactories) {
          for (const factory of options.initialFactories) {
            this.addFactory(factory);
          }
        }
      }
      /**
       * The ordered list of mimeTypes.
       */
      get mimeTypes() {
        return this._types || (this._types = Private10.sortedTypes(this._ranks));
      }
      /**
       * Find the preferred mime type for a mime bundle.
       *
       * @param bundle - The bundle of mime data.
       *
       * @param safe - How to consider safe/unsafe factories. If 'ensure',
       *   it will only consider safe factories. If 'any', any factory will be
       *   considered. If 'prefer', unsafe factories will be considered, but
       *   only after the safe options have been exhausted.
       *
       * @returns The preferred mime type from the available factories,
       *   or `undefined` if the mime type cannot be rendered.
       */
      preferredMimeType(bundle, safe = "ensure") {
        if (safe === "ensure" || safe === "prefer") {
          for (const mt of this.mimeTypes) {
            if (mt in bundle && this._factories[mt].safe) {
              return mt;
            }
          }
        }
        if (safe !== "ensure") {
          for (const mt of this.mimeTypes) {
            if (mt in bundle) {
              return mt;
            }
          }
        }
        return void 0;
      }
      /**
       * Create a renderer for a mime type.
       *
       * @param mimeType - The mime type of interest.
       *
       * @returns A new renderer for the given mime type.
       *
       * @throws An error if no factory exists for the mime type.
       */
      createRenderer(mimeType) {
        if (!(mimeType in this._factories)) {
          throw new Error(`No factory for mime type: '${mimeType}'`);
        }
        return this._factories[mimeType].createRenderer({
          mimeType,
          resolver: this.resolver,
          sanitizer: this.sanitizer,
          linkHandler: this.linkHandler,
          latexTypesetter: this.latexTypesetter,
          markdownParser: this.markdownParser,
          translator: this.translator
        });
      }
      /**
       * Create a new mime model.  This is a convenience method.
       *
       * @options - The options used to create the model.
       *
       * @returns A new mime model.
       */
      createModel(options = {}) {
        return new MimeModel(options);
      }
      /**
       * Create a clone of this rendermime instance.
       *
       * @param options - The options for configuring the clone.
       *
       * @returns A new independent clone of the rendermime.
       */
      clone(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const clone2 = new RenderMimeRegistry({
          resolver: (_b = (_a = options.resolver) !== null && _a !== void 0 ? _a : this.resolver) !== null && _b !== void 0 ? _b : void 0,
          sanitizer: (_d = (_c = options.sanitizer) !== null && _c !== void 0 ? _c : this.sanitizer) !== null && _d !== void 0 ? _d : void 0,
          linkHandler: (_f = (_e = options.linkHandler) !== null && _e !== void 0 ? _e : this.linkHandler) !== null && _f !== void 0 ? _f : void 0,
          latexTypesetter: (_h = (_g = options.latexTypesetter) !== null && _g !== void 0 ? _g : this.latexTypesetter) !== null && _h !== void 0 ? _h : void 0,
          markdownParser: (_k = (_j = options.markdownParser) !== null && _j !== void 0 ? _j : this.markdownParser) !== null && _k !== void 0 ? _k : void 0,
          translator: this.translator
        });
        clone2._factories = { ...this._factories };
        clone2._ranks = { ...this._ranks };
        clone2._id = this._id;
        return clone2;
      }
      /**
       * Get the renderer factory registered for a mime type.
       *
       * @param mimeType - The mime type of interest.
       *
       * @returns The factory for the mime type, or `undefined`.
       */
      getFactory(mimeType) {
        return this._factories[mimeType];
      }
      /**
       * Add a renderer factory to the rendermime.
       *
       * @param factory - The renderer factory of interest.
       *
       * @param rank - The rank of the renderer. A lower rank indicates
       *   a higher priority for rendering. If not given, the rank will
       *   defer to the `defaultRank` of the factory.  If no `defaultRank`
       *   is given, it will default to 100.
       *
       * #### Notes
       * The renderer will replace an existing renderer for the given
       * mimeType.
       */
      addFactory(factory, rank) {
        if (rank === void 0) {
          rank = factory.defaultRank;
          if (rank === void 0) {
            rank = 100;
          }
        }
        for (const mt of factory.mimeTypes) {
          this._factories[mt] = factory;
          this._ranks[mt] = { rank, id: this._id++ };
        }
        this._types = null;
      }
      /**
       * Remove a mime type.
       *
       * @param mimeType - The mime type of interest.
       */
      removeMimeType(mimeType) {
        delete this._factories[mimeType];
        delete this._ranks[mimeType];
        this._types = null;
      }
      /**
       * Get the rank for a given mime type.
       *
       * @param mimeType - The mime type of interest.
       *
       * @returns The rank of the mime type or undefined.
       */
      getRank(mimeType) {
        const rank = this._ranks[mimeType];
        return rank && rank.rank;
      }
      /**
       * Set the rank of a given mime type.
       *
       * @param mimeType - The mime type of interest.
       *
       * @param rank - The new rank to assign.
       *
       * #### Notes
       * This is a no-op if the mime type is not registered.
       */
      setRank(mimeType, rank) {
        if (!this._ranks[mimeType]) {
          return;
        }
        const id = this._id++;
        this._ranks[mimeType] = { rank, id };
        this._types = null;
      }
    };
    (function(RenderMimeRegistry2) {
      class UrlResolver {
        /**
         * Create a new url resolver.
         */
        constructor(options) {
          this._path = options.path;
          this._contents = options.contents;
        }
        /**
         * The path of the object, from which local urls can be derived.
         */
        get path() {
          return this._path;
        }
        set path(value) {
          this._path = value;
        }
        /**
         * Resolve a relative url to an absolute url path.
         */
        async resolveUrl(url) {
          if (this.isLocal(url)) {
            const cwd = encodeURI(import_coreutils7.PathExt.dirname(this.path));
            url = import_coreutils7.PathExt.resolve(cwd, url);
          }
          return url;
        }
        /**
         * Get the download url of a given absolute url path.
         *
         * #### Notes
         * The returned URL may include a query parameter.
         */
        async getDownloadUrl(urlPath) {
          if (this.isLocal(urlPath)) {
            return this._contents.getDownloadUrl(decodeURIComponent(urlPath));
          }
          return urlPath;
        }
        /**
         * Whether the URL should be handled by the resolver
         * or not.
         *
         * @param allowRoot - Whether the paths starting at Unix-style filesystem root (`/`) are permitted.
         *
         * #### Notes
         * This is similar to the `isLocal` check in `URLExt`,
         * but it also checks whether the path points to any
         * of the `IDrive`s that may be registered with the contents
         * manager.
         */
        isLocal(url, allowRoot = false) {
          if (this.isMalformed(url)) {
            return false;
          }
          return import_coreutils7.URLExt.isLocal(url, allowRoot) || !!this._contents.driveName(decodeURI(url));
        }
        /**
         * Resolve a path from Jupyter kernel to a path:
         * - relative to `root_dir` (preferrably) this is in jupyter-server scope,
         * - path understood and known by kernel (if such a path exists).
         * Returns `null` if there is no file matching provided path in neither
         * kernel nor jupyter-server contents manager.
         */
        async resolvePath(path2) {
          const rootDir = import_coreutils7.PageConfig.getOption("rootUri").replace("file://", "");
          if (path2.startsWith("~/") && rootDir.startsWith("/home/")) {
            path2 = rootDir.split("/").slice(0, 3).join("/") + path2.substring(1);
          }
          if (path2.startsWith(rootDir) || path2.startsWith("./")) {
            try {
              const relativePath = path2.replace(rootDir, "");
              const response = await this._contents.get(relativePath, {
                content: false
              });
              return {
                path: response.path,
                scope: "server"
              };
            } catch (error) {
              console.warn(`Could not resolve location of ${path2} on server`);
              return null;
            }
          }
          return {
            path: path2,
            scope: "kernel"
          };
        }
        /**
         * Whether the URL can be decoded using `decodeURI`.
         */
        isMalformed(url) {
          try {
            decodeURI(url);
            return false;
          } catch (error) {
            if (error instanceof URIError) {
              return true;
            }
            throw error;
          }
        }
      }
      RenderMimeRegistry2.UrlResolver = UrlResolver;
    })(RenderMimeRegistry || (RenderMimeRegistry = {}));
    (function(Private19) {
      function sortedTypes(map4) {
        return Object.keys(map4).sort((a4, b4) => {
          const p1 = map4[a4];
          const p22 = map4[b4];
          if (p1.rank !== p22.rank) {
            return p1.rank - p22.rank;
          }
          return p1.id - p22.id;
        });
      }
      Private19.sortedTypes = sortedTypes;
    })(Private10 || (Private10 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/tokens.js
var import_coreutils8, IRenderMimeRegistry, ILatexTypesetter, IMarkdownParser;
var init_tokens = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/tokens.js"() {
    import_coreutils8 = __toESM(require_dist());
    IRenderMimeRegistry = new import_coreutils8.Token("@jupyterlab/rendermime:IRenderMimeRegistry", 'A service for the rendermime registry for the application. Use this to create renderers for various mime-types in your extension. Many times it will be easier to create a "mime renderer extension" rather than using this service directly.');
    ILatexTypesetter = new import_coreutils8.Token("@jupyterlab/rendermime:ILatexTypesetter", "A service for the LaTeX typesetter for the application. Use this if you want to typeset math in your extension.");
    IMarkdownParser = new import_coreutils8.Token("@jupyterlab/rendermime:IMarkdownParser", "A service for rendering markdown syntax as HTML content.");
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/index.js
var init_lib6 = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/index.js"() {
    init_lib3();
    init_attachmentmodel();
    init_factories();
    init_latex();
    init_mimemodel();
    init_outputmodel();
    init_registry();
    init_renderers();
    init_tokens();
    init_widgets();
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/nbformat/lib/index.js
function isStream2(output) {
  return output.output_type === "stream";
}
var import_coreutils9;
var init_lib7 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/nbformat/lib/index.js"() {
    import_coreutils9 = __toESM(require_dist());
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/algorithm/dist/index.es6.js
function every2(object2, fn) {
  let index2 = 0;
  for (const value of object2) {
    if (false === fn(value, index2++)) {
      return false;
    }
  }
  return true;
}
function some2(object2, fn) {
  let index2 = 0;
  for (const value of object2) {
    if (fn(value, index2++)) {
      return true;
    }
  }
  return false;
}
function* map(object2, fn) {
  let index2 = 0;
  for (const value of object2) {
    yield fn(value, index2++);
  }
}
function* retro2(object2) {
  if (typeof object2.retro === "function") {
    yield* object2.retro();
  } else {
    for (let index2 = object2.length - 1; index2 > -1; index2--) {
      yield object2[index2];
    }
  }
}
var ArrayExt3, Private11, StringExt2;
var init_index_es612 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt4) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n4 - start);
        } else {
          span = stop - start + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          let j2 = (start + i5) % n4;
          if (array[j2] === value) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n4 - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          let j2 = (start - i5 + n4) % n4;
          if (array[j2] === value) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n4 - start);
        } else {
          span = stop - start + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          let j2 = (start + i5) % n4;
          if (fn(array[j2], j2)) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.findFirstIndex = findFirstIndex;
      function findLastIndex(array, fn, start = -1, stop = 0) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let d6;
        if (start < stop) {
          d6 = start + 1 + (n4 - stop);
        } else {
          d6 = start - stop + 1;
        }
        for (let i5 = 0; i5 < d6; ++i5) {
          let j2 = (start - i5 + n4) % n4;
          if (fn(array[j2], j2)) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.findLastIndex = findLastIndex;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index2 = findFirstIndex(array, fn, start, stop);
        return index2 !== -1 ? array[index2] : void 0;
      }
      ArrayExt4.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index2 = findLastIndex(array, fn, start, stop);
        return index2 !== -1 ? array[index2] : void 0;
      }
      ArrayExt4.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt4.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt4.upperBound = upperBound;
      function shallowEqual(a4, b4, fn) {
        if (a4 === b4) {
          return true;
        }
        if (a4.length !== b4.length) {
          return false;
        }
        for (let i5 = 0, n4 = a4.length; i5 < n4; ++i5) {
          if (fn ? !fn(a4[i5], b4[i5]) : a4[i5] !== b4[i5]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt4.shallowEqual = shallowEqual;
      function slice2(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n4 = array.length;
        if (start === void 0) {
          start = step < 0 ? n4 - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n4, step < 0 ? -1 : 0);
        } else if (start >= n4) {
          start = step < 0 ? n4 - 1 : n4;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n4;
        } else if (stop < 0) {
          stop = Math.max(stop + n4, step < 0 ? -1 : 0);
        } else if (stop >= n4) {
          stop = step < 0 ? n4 - 1 : n4;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result2 = [];
        for (let i5 = 0; i5 < length; ++i5) {
          result2[i5] = array[start + i5 * step];
        }
        return result2;
      }
      ArrayExt4.slice = slice2;
      function move(array, fromIndex, toIndex) {
        let n4 = array.length;
        if (n4 <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n4);
        } else {
          fromIndex = Math.min(fromIndex, n4 - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n4);
        } else {
          toIndex = Math.min(toIndex, n4 - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d6 = fromIndex < toIndex ? 1 : -1;
        for (let i5 = fromIndex; i5 !== toIndex; i5 += d6) {
          array[i5] = array[i5 + d6];
        }
        array[toIndex] = value;
      }
      ArrayExt4.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        while (start < stop) {
          let a4 = array[start];
          let b4 = array[stop];
          array[start++] = b4;
          array[stop--] = a4;
        }
      }
      ArrayExt4.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt4.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n4 - start);
        } else {
          span = stop - start + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          array[(start + i5) % n4] = value;
        }
      }
      ArrayExt4.fill = fill;
      function insert(array, index2, value) {
        let n4 = array.length;
        if (index2 < 0) {
          index2 = Math.max(0, index2 + n4);
        } else {
          index2 = Math.min(index2, n4);
        }
        for (let i5 = n4; i5 > index2; --i5) {
          array[i5] = array[i5 - 1];
        }
        array[index2] = value;
      }
      ArrayExt4.insert = insert;
      function removeAt(array, index2) {
        let n4 = array.length;
        if (index2 < 0) {
          index2 += n4;
        }
        if (index2 < 0 || index2 >= n4) {
          return void 0;
        }
        let value = array[index2];
        for (let i5 = index2 + 1; i5 < n4; ++i5) {
          array[i5 - 1] = array[i5];
        }
        array.length = n4 - 1;
        return value;
      }
      ArrayExt4.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index2 = firstIndexOf(array, value, start, stop);
        if (index2 !== -1) {
          removeAt(array, index2);
        }
        return index2;
      }
      ArrayExt4.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index2 = lastIndexOf(array, value, start, stop);
        if (index2 !== -1) {
          removeAt(array, index2);
        }
        return index2;
      }
      ArrayExt4.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let count = 0;
        for (let i5 = 0; i5 < n4; ++i5) {
          if (start <= stop && i5 >= start && i5 <= stop && array[i5] === value) {
            count++;
          } else if (stop < start && (i5 <= stop || i5 >= start) && array[i5] === value) {
            count++;
          } else if (count > 0) {
            array[i5 - count] = array[i5];
          }
        }
        if (count > 0) {
          array.length = n4 - count;
        }
        return count;
      }
      ArrayExt4.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index2 = findFirstIndex(array, fn, start, stop);
        if (index2 !== -1) {
          value = removeAt(array, index2);
        }
        return { index: index2, value };
      }
      ArrayExt4.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index2 = findLastIndex(array, fn, start, stop);
        if (index2 !== -1) {
          value = removeAt(array, index2);
        }
        return { index: index2, value };
      }
      ArrayExt4.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let count = 0;
        for (let i5 = 0; i5 < n4; ++i5) {
          if (start <= stop && i5 >= start && i5 <= stop && fn(array[i5], i5)) {
            count++;
          } else if (stop < start && (i5 <= stop || i5 >= start) && fn(array[i5], i5)) {
            count++;
          } else if (count > 0) {
            array[i5 - count] = array[i5];
          }
        }
        if (count > 0) {
          array.length = n4 - count;
        }
        return count;
      }
      ArrayExt4.removeAllWhere = removeAllWhere;
    })(ArrayExt3 || (ArrayExt3 = {}));
    (function(Private19) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private19.rangeLength = rangeLength;
    })(Private11 || (Private11 = {}));
    (function(StringExt3) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i5 = 0, j2 = start, n4 = query.length; i5 < n4; ++i5, ++j2) {
          j2 = source.indexOf(query[i5], j2);
          if (j2 === -1) {
            return null;
          }
          indices[i5] = j2;
        }
        return indices;
      }
      StringExt3.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i5 = 0, n4 = indices.length; i5 < n4; ++i5) {
          let j2 = indices[i5] - start;
          score += j2 * j2;
        }
        return { score, indices };
      }
      StringExt3.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last2 = start - 1;
        for (let i5 = 0, n4 = indices.length; i5 < n4; ++i5) {
          let j2 = indices[i5];
          score += j2 - last2 - 1;
          last2 = j2;
        }
        return { score, indices };
      }
      StringExt3.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result2 = [];
        let k = 0;
        let last2 = 0;
        let n4 = indices.length;
        while (k < n4) {
          let i5 = indices[k];
          let j2 = indices[k];
          while (++k < n4 && indices[k] === j2 + 1) {
            j2++;
          }
          if (last2 < i5) {
            result2.push(source.slice(last2, i5));
          }
          if (i5 < j2 + 1) {
            result2.push(fn(source.slice(i5, j2 + 1)));
          }
          last2 = j2 + 1;
        }
        if (last2 < source.length) {
          result2.push(source.slice(last2));
        }
        return result2;
      }
      StringExt3.highlight = highlight;
      function cmp(a4, b4) {
        return a4 < b4 ? -1 : a4 > b4 ? 1 : 0;
      }
      StringExt3.cmp = cmp;
    })(StringExt2 || (StringExt2 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/collections/dist/index.es6.js
var LinkedList2, Private12;
var init_index_es613 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/collections/dist/index.es6.js"() {
    LinkedList2 = class {
      constructor() {
        this._first = null;
        this._last = null;
        this._size = 0;
      }
      /**
       * Whether the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get isEmpty() {
        return this._size === 0;
      }
      /**
       * The size of the list.
       *
       * #### Complexity
       * `O(1)`
       *
       * #### Notes
       * This is equivalent to `length`.
       */
      get size() {
        return this._size;
      }
      /**
       * The length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `size`.
       *
       * This property is deprecated.
       */
      get length() {
        return this._size;
      }
      /**
       * The first value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get first() {
        return this._first ? this._first.value : void 0;
      }
      /**
       * The last value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get last() {
        return this._last ? this._last.value : void 0;
      }
      /**
       * The first node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get firstNode() {
        return this._first;
      }
      /**
       * The last node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get lastNode() {
        return this._last;
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting with the first value.
       *
       * #### Complexity
       * Constant.
       */
      *[Symbol.iterator]() {
        let node = this._first;
        while (node) {
          yield node.value;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the values in the list.
       *
       * @returns A new iterator starting with the last value.
       *
       * #### Complexity
       * Constant.
       */
      *retro() {
        let node = this._last;
        while (node) {
          yield node.value;
          node = node.prev;
        }
      }
      /**
       * Create an iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the first node.
       *
       * #### Complexity
       * Constant.
       */
      *nodes() {
        let node = this._first;
        while (node) {
          yield node;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the last node.
       *
       * #### Complexity
       * Constant.
       */
      *retroNodes() {
        let node = this._last;
        while (node) {
          yield node;
          node = node.prev;
        }
      }
      /**
       * Assign new values to the list, replacing all current values.
       *
       * @param values - The values to assign to the list.
       *
       * #### Complexity
       * Linear.
       */
      assign(values2) {
        this.clear();
        for (const value of values2) {
          this.addLast(value);
        }
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addLast`.
       */
      push(value) {
        this.addLast(value);
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeLast`.
       */
      pop() {
        return this.removeLast();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addFirst`.
       */
      shift(value) {
        this.addFirst(value);
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeFirst`.
       */
      unshift() {
        return this.removeFirst();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addFirst(value) {
        let node = new Private12.LinkedListNode(this, value);
        if (!this._first) {
          this._first = node;
          this._last = node;
        } else {
          node.next = this._first;
          this._first.prev = node;
          this._first = node;
        }
        this._size++;
        return node;
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addLast(value) {
        let node = new Private12.LinkedListNode(this, value);
        if (!this._last) {
          this._first = node;
          this._last = node;
        } else {
          node.prev = this._last;
          this._last.next = node;
          this._last = node;
        }
        this._size++;
        return node;
      }
      /**
       * Insert a value before a specific node in the list.
       *
       * @param value - The value to insert before the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertBefore(value, ref) {
        if (!ref || ref === this._first) {
          return this.addFirst(value);
        }
        if (!(ref instanceof Private12.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private12.LinkedListNode(this, value);
        let _ref = ref;
        let prev = _ref.prev;
        node.next = _ref;
        node.prev = prev;
        _ref.prev = node;
        prev.next = node;
        this._size++;
        return node;
      }
      /**
       * Insert a value after a specific node in the list.
       *
       * @param value - The value to insert after the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertAfter(value, ref) {
        if (!ref || ref === this._last) {
          return this.addLast(value);
        }
        if (!(ref instanceof Private12.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private12.LinkedListNode(this, value);
        let _ref = ref;
        let next = _ref.next;
        node.next = next;
        node.prev = _ref;
        _ref.next = node;
        next.prev = node;
        this._size++;
        return node;
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeFirst() {
        let node = this._first;
        if (!node) {
          return void 0;
        }
        if (node === this._last) {
          this._first = null;
          this._last = null;
        } else {
          this._first = node.next;
          this._first.prev = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeLast() {
        let node = this._last;
        if (!node) {
          return void 0;
        }
        if (node === this._first) {
          this._first = null;
          this._last = null;
        } else {
          this._last = node.prev;
          this._last.next = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove a specific node from the list.
       *
       * @param node - The node to remove from the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * The node must be owned by the list.
       */
      removeNode(node) {
        if (!(node instanceof Private12.LinkedListNode) || node.list !== this) {
          throw new Error("Node is not owned by the list.");
        }
        let _node = node;
        if (_node === this._first && _node === this._last) {
          this._first = null;
          this._last = null;
        } else if (_node === this._first) {
          this._first = _node.next;
          this._first.prev = null;
        } else if (_node === this._last) {
          this._last = _node.prev;
          this._last.next = null;
        } else {
          _node.next.prev = _node.prev;
          _node.prev.next = _node.next;
        }
        _node.list = null;
        _node.next = null;
        _node.prev = null;
        this._size--;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       */
      clear() {
        let node = this._first;
        while (node) {
          let next = node.next;
          node.list = null;
          node.prev = null;
          node.next = null;
          node = next;
        }
        this._first = null;
        this._last = null;
        this._size = 0;
      }
    };
    (function(LinkedList3) {
      function from(values2) {
        let list = new LinkedList3();
        list.assign(values2);
        return list;
      }
      LinkedList3.from = from;
    })(LinkedList2 || (LinkedList2 = {}));
    (function(Private19) {
      class LinkedListNode {
        /**
         * Construct a new linked list node.
         *
         * @param list - The list which owns the node.
         *
         * @param value - The value for the link.
         */
        constructor(list, value) {
          this.list = null;
          this.next = null;
          this.prev = null;
          this.list = list;
          this.value = value;
        }
      }
      Private19.LinkedListNode = LinkedListNode;
    })(Private12 || (Private12 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/messaging/dist/index.es6.js
var Message2, MessageLoop3;
var init_index_es614 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/messaging/dist/index.es6.js"() {
    init_index_es612();
    init_index_es613();
    Message2 = class {
      /**
       * Construct a new message.
       *
       * @param type - The type of the message.
       */
      constructor(type2) {
        this.type = type2;
      }
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * If a conflatable message is posted to a handler while another
       * conflatable message of the same `type` has already been posted
       * to the handler, the `conflate()` method of the existing message
       * will be invoked. If that method returns `true`, the new message
       * will not be enqueued. This allows messages to be compressed, so
       * that only a single instance of the message type is processed per
       * cycle, no matter how many times messages of that type are posted.
       *
       * Custom message types may reimplement this property.
       *
       * The default implementation is always `false`.
       */
      get isConflatable() {
        return false;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * @param other - A conflatable message of the same `type`.
       *
       * @returns `true` if the message was successfully conflated, or
       *   `false` otherwise.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * This method is called automatically by the message loop when the
       * given message is posted to the handler paired with this message.
       * This message will already be enqueued and conflatable, and the
       * given message will have the same `type` and also be conflatable.
       *
       * This method should merge the state of the other message into this
       * message as needed so that when this message is finally delivered
       * to the handler, it receives the most up-to-date information.
       *
       * If this method returns `true`, it signals that the other message
       * was successfully conflated and that message will not be enqueued.
       *
       * If this method returns `false`, the other message will be enqueued
       * for normal delivery.
       *
       * Custom message types may reimplement this method.
       *
       * The default implementation always returns `false`.
       */
      conflate(other) {
        return false;
      }
    };
    (function(MessageLoop4) {
      let pending = null;
      const schedule = ((resolved) => (fn) => {
        let rejected = false;
        resolved.then(() => !rejected && fn());
        return () => {
          rejected = true;
        };
      })(Promise.resolve());
      function sendMessage(handler, msg) {
        let hooks = messageHooks.get(handler);
        if (!hooks || hooks.length === 0) {
          invokeHandler(handler, msg);
          return;
        }
        let passed = every2(retro2(hooks), (hook) => {
          return hook ? invokeHook(hook, handler, msg) : true;
        });
        if (passed) {
          invokeHandler(handler, msg);
        }
      }
      MessageLoop4.sendMessage = sendMessage;
      function postMessage(handler, msg) {
        if (!msg.isConflatable) {
          enqueueMessage(handler, msg);
          return;
        }
        let conflated = some2(messageQueue, (posted) => {
          if (posted.handler !== handler) {
            return false;
          }
          if (!posted.msg) {
            return false;
          }
          if (posted.msg.type !== msg.type) {
            return false;
          }
          if (!posted.msg.isConflatable) {
            return false;
          }
          return posted.msg.conflate(msg);
        });
        if (!conflated) {
          enqueueMessage(handler, msg);
        }
      }
      MessageLoop4.postMessage = postMessage;
      function installMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.indexOf(hook) !== -1) {
          return;
        }
        if (!hooks) {
          messageHooks.set(handler, [hook]);
        } else {
          hooks.push(hook);
        }
      }
      MessageLoop4.installMessageHook = installMessageHook;
      function removeMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (!hooks) {
          return;
        }
        let i5 = hooks.indexOf(hook);
        if (i5 === -1) {
          return;
        }
        hooks[i5] = null;
        scheduleCleanup(hooks);
      }
      MessageLoop4.removeMessageHook = removeMessageHook;
      function clearData(handler) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.length > 0) {
          ArrayExt3.fill(hooks, null);
          scheduleCleanup(hooks);
        }
        for (const posted of messageQueue) {
          if (posted.handler === handler) {
            posted.handler = null;
            posted.msg = null;
          }
        }
      }
      MessageLoop4.clearData = clearData;
      function flush() {
        if (flushGuard || pending === null) {
          return;
        }
        pending();
        pending = null;
        flushGuard = true;
        runMessageLoop();
        flushGuard = false;
      }
      MessageLoop4.flush = flush;
      function getExceptionHandler() {
        return exceptionHandler;
      }
      MessageLoop4.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = exceptionHandler;
        exceptionHandler = handler;
        return old;
      }
      MessageLoop4.setExceptionHandler = setExceptionHandler;
      const messageQueue = new LinkedList2();
      const messageHooks = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      let exceptionHandler = (err) => {
        console.error(err);
      };
      let flushGuard = false;
      function invokeHook(hook, handler, msg) {
        let result2 = true;
        try {
          if (typeof hook === "function") {
            result2 = hook(handler, msg);
          } else {
            result2 = hook.messageHook(handler, msg);
          }
        } catch (err) {
          exceptionHandler(err);
        }
        return result2;
      }
      function invokeHandler(handler, msg) {
        try {
          handler.processMessage(msg);
        } catch (err) {
          exceptionHandler(err);
        }
      }
      function enqueueMessage(handler, msg) {
        messageQueue.addLast({ handler, msg });
        if (pending !== null) {
          return;
        }
        pending = schedule(runMessageLoop);
      }
      function runMessageLoop() {
        pending = null;
        if (messageQueue.isEmpty) {
          return;
        }
        let sentinel = { handler: null, msg: null };
        messageQueue.addLast(sentinel);
        while (true) {
          let posted = messageQueue.removeFirst();
          if (posted === sentinel) {
            return;
          }
          if (posted.handler && posted.msg) {
            sendMessage(posted.handler, posted.msg);
          }
        }
      }
      function scheduleCleanup(hooks) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(hooks);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupHooks);
        dirtySet.clear();
      }
      function cleanupHooks(hooks) {
        ArrayExt3.removeAllWhere(hooks, isNull3);
      }
      function isNull3(value) {
        return value === null;
      }
    })(MessageLoop3 || (MessageLoop3 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/observables/lib/observablemap.js
var ObservableMap2, Private13;
var init_observablemap2 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/observables/lib/observablemap.js"() {
    init_index_es6();
    ObservableMap2 = class {
      /**
       * Construct a new observable map.
       */
      constructor(options = {}) {
        this._map = /* @__PURE__ */ new Map();
        this._changed = new Signal(this);
        this._isDisposed = false;
        this._itemCmp = options.itemCmp || Private13.itemCmp;
        if (options.values) {
          for (const key in options.values) {
            this._map.set(key, options.values[key]);
          }
        }
      }
      /**
       * The type of the Observable.
       */
      get type() {
        return "Map";
      }
      /**
       * A signal emitted when the map has changed.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Whether this map has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * The number of key-value pairs in the map.
       */
      get size() {
        return this._map.size;
      }
      /**
       * Set a key-value pair in the map
       *
       * @param key - The key to set.
       *
       * @param value - The value for the key.
       *
       * @returns the old value for the key, or undefined
       *   if that did not exist.
       *
       * @throws if the new value is undefined.
       *
       * #### Notes
       * This is a no-op if the value does not change.
       */
      set(key, value) {
        const oldVal = this._map.get(key);
        if (value === void 0) {
          throw Error("Cannot set an undefined value, use remove");
        }
        const itemCmp = this._itemCmp;
        if (oldVal !== void 0 && itemCmp(oldVal, value)) {
          return oldVal;
        }
        this._map.set(key, value);
        this._changed.emit({
          type: oldVal ? "change" : "add",
          key,
          oldValue: oldVal,
          newValue: value
        });
        return oldVal;
      }
      /**
       * Get a value for a given key.
       *
       * @param key - the key.
       *
       * @returns the value for that key.
       */
      get(key) {
        return this._map.get(key);
      }
      /**
       * Check whether the map has a key.
       *
       * @param key - the key to check.
       *
       * @returns `true` if the map has the key, `false` otherwise.
       */
      has(key) {
        return this._map.has(key);
      }
      /**
       * Get a list of the keys in the map.
       *
       * @returns - a list of keys.
       */
      keys() {
        const keyList = [];
        this._map.forEach((v2, k) => {
          keyList.push(k);
        });
        return keyList;
      }
      /**
       * Get a list of the values in the map.
       *
       * @returns - a list of values.
       */
      values() {
        const valList = [];
        this._map.forEach((v2, k) => {
          valList.push(v2);
        });
        return valList;
      }
      /**
       * Remove a key from the map
       *
       * @param key - the key to remove.
       *
       * @returns the value of the given key,
       *   or undefined if that does not exist.
       *
       * #### Notes
       * This is a no-op if the value does not change.
       */
      delete(key) {
        const oldVal = this._map.get(key);
        const removed = this._map.delete(key);
        if (removed) {
          this._changed.emit({
            type: "remove",
            key,
            oldValue: oldVal,
            newValue: void 0
          });
        }
        return oldVal;
      }
      /**
       * Set the ObservableMap to an empty map.
       */
      clear() {
        const keyList = this.keys();
        for (let i5 = 0; i5 < keyList.length; i5++) {
          this.delete(keyList[i5]);
        }
      }
      /**
       * Dispose of the resources held by the map.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
        this._map.clear();
      }
    };
    (function(Private19) {
      function itemCmp(first2, second) {
        return first2 === second;
      }
      Private19.itemCmp = itemCmp;
    })(Private13 || (Private13 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/observables/lib/observablejson.js
var import_coreutils10, ObservableJSON2;
var init_observablejson2 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/observables/lib/observablejson.js"() {
    import_coreutils10 = __toESM(require_dist());
    init_index_es614();
    init_observablemap2();
    ObservableJSON2 = class extends ObservableMap2 {
      /**
       * Construct a new observable JSON object.
       */
      constructor(options = {}) {
        super({
          itemCmp: import_coreutils10.JSONExt.deepEqual,
          values: options.values
        });
      }
      /**
       * Serialize the model to JSON.
       */
      toJSON() {
        const out = /* @__PURE__ */ Object.create(null);
        const keys2 = this.keys();
        for (const key of keys2) {
          const value = this.get(key);
          if (value !== void 0) {
            out[key] = import_coreutils10.JSONExt.deepCopy(value);
          }
        }
        return out;
      }
    };
    (function(ObservableJSON3) {
      class ChangeMessage extends Message2 {
        /**
         * Create a new metadata changed message.
         */
        constructor(type2, args) {
          super(type2);
          this.args = args;
        }
      }
      ObservableJSON3.ChangeMessage = ChangeMessage;
    })(ObservableJSON2 || (ObservableJSON2 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/observables/lib/observablestring.js
var init_observablestring2 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/observables/lib/observablestring.js"() {
    init_index_es6();
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/observables/lib/observablelist.js
var ObservableList2, Private14;
var init_observablelist2 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/observables/lib/observablelist.js"() {
    init_index_es612();
    init_index_es6();
    ObservableList2 = class {
      /**
       * Construct a new observable map.
       */
      constructor(options = {}) {
        this._array = [];
        this._isDisposed = false;
        this._changed = new Signal(this);
        if (options.values) {
          for (const value of options.values) {
            this._array.push(value);
          }
        }
        this._itemCmp = options.itemCmp || Private14.itemCmp;
      }
      /**
       * The type of this object.
       */
      get type() {
        return "List";
      }
      /**
       * A signal emitted when the list has changed.
       */
      get changed() {
        return this._changed;
      }
      /**
       * The length of the list.
       */
      get length() {
        return this._array.length;
      }
      /**
       * Test whether the list has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the list.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
        this.clear();
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting at the front of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Iterator Validity
       * No changes.
       */
      [Symbol.iterator]() {
        return this._array[Symbol.iterator]();
      }
      /**
       * Get the value at the specified index.
       *
       * @param index - The positive integer index of interest.
       *
       * @returns The value at the specified index.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral or out of range.
       */
      get(index2) {
        return this._array[index2];
      }
      /**
       * Set the value at the specified index.
       *
       * @param index - The positive integer index of interest.
       *
       * @param value - The value to set at the specified index.
       *
       * #### Complexity
       * Constant.
       *
       * #### Iterator Validity
       * No changes.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral or out of range.
       */
      set(index2, value) {
        const oldValue = this._array[index2];
        if (value === void 0) {
          throw new Error("Cannot set an undefined item");
        }
        const itemCmp = this._itemCmp;
        if (itemCmp(oldValue, value)) {
          return;
        }
        this._array[index2] = value;
        this._changed.emit({
          type: "set",
          oldIndex: index2,
          newIndex: index2,
          oldValues: [oldValue],
          newValues: [value]
        });
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The new length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * By convention, the oldIndex is set to -1 to indicate
       * an push operation.
       *
       * #### Iterator Validity
       * No changes.
       */
      push(value) {
        const num = this._array.push(value);
        this._changed.emit({
          type: "add",
          oldIndex: -1,
          newIndex: this.length - 1,
          oldValues: [],
          newValues: [value]
        });
        return num;
      }
      /**
       * Insert a value into the list at a specific index.
       *
       * @param index - The index at which to insert the value.
       *
       * @param value - The value to set at the specified index.
       *
       * #### Complexity
       * Linear.
       *
       * #### Iterator Validity
       * No changes.
       *
       * #### Notes
       * The `index` will be clamped to the bounds of the list.
       *
       * By convention, the oldIndex is set to -2 to indicate
       * an insert operation.
       *
       * The value -2 as oldIndex can be used to distinguish from the push
       * method which will use a value -1.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insert(index2, value) {
        if (index2 === this._array.length) {
          this._array.push(value);
        } else {
          ArrayExt3.insert(this._array, index2, value);
        }
        this._changed.emit({
          type: "add",
          oldIndex: -2,
          newIndex: index2,
          oldValues: [],
          newValues: [value]
        });
      }
      /**
       * Remove the first occurrence of a value from the list.
       *
       * @param value - The value of interest.
       *
       * @returns The index of the removed value, or `-1` if the value
       *   is not contained in the list.
       *
       * #### Complexity
       * Linear.
       *
       * #### Iterator Validity
       * Iterators pointing at the removed value and beyond are invalidated.
       */
      removeValue(value) {
        const itemCmp = this._itemCmp;
        const index2 = ArrayExt3.findFirstIndex(this._array, (item) => {
          return itemCmp(item, value);
        });
        this.remove(index2);
        return index2;
      }
      /**
       * Remove and return the value at a specific index.
       *
       * @param index - The index of the value of interest.
       *
       * @returns The value at the specified index, or `undefined` if the
       *   index is out of range.
       *
       * #### Complexity
       * Constant.
       *
       * #### Iterator Validity
       * Iterators pointing at the removed value and beyond are invalidated.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      remove(index2) {
        const value = ArrayExt3.removeAt(this._array, index2);
        if (value === void 0) {
          return;
        }
        this._changed.emit({
          type: "remove",
          oldIndex: index2,
          newIndex: -1,
          newValues: [],
          oldValues: [value]
        });
        return value;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       *
       * #### Iterator Validity
       * All current iterators are invalidated.
       */
      clear() {
        const copy = this._array.slice();
        this._array.length = 0;
        this._changed.emit({
          type: "remove",
          oldIndex: 0,
          newIndex: 0,
          newValues: [],
          oldValues: copy
        });
      }
      /**
       * Move a value from one index to another.
       *
       * @param fromIndex - The index of the element to move.
       *
       * @param toIndex - The index to move the element to.
       *
       * #### Complexity
       * Constant.
       *
       * #### Iterator Validity
       * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`
       * and beyond are invalidated.
       *
       * #### Undefined Behavior
       * A `fromIndex` or a `toIndex` which is non-integral.
       */
      move(fromIndex, toIndex) {
        if (this.length <= 1 || fromIndex === toIndex) {
          return;
        }
        const values2 = [this._array[fromIndex]];
        ArrayExt3.move(this._array, fromIndex, toIndex);
        this._changed.emit({
          type: "move",
          oldIndex: fromIndex,
          newIndex: toIndex,
          oldValues: values2,
          newValues: values2
        });
      }
      /**
       * Push a set of values to the back of the list.
       *
       * @param values - An iterable set of values to add.
       *
       * @returns The new length of the list.
       *
       * #### Complexity
       * Linear.
       *
       * #### Notes
       * By convention, the oldIndex is set to -1 to indicate
       * an push operation.
       *
       * #### Iterator Validity
       * No changes.
       */
      pushAll(values2) {
        const newIndex = this.length;
        for (const value of values2) {
          this._array.push(value);
        }
        this._changed.emit({
          type: "add",
          oldIndex: -1,
          newIndex,
          oldValues: [],
          newValues: Array.from(values2)
        });
        return this.length;
      }
      /**
       * Insert a set of items into the list at the specified index.
       *
       * @param index - The index at which to insert the values.
       *
       * @param values - The values to insert at the specified index.
       *
       * #### Complexity.
       * Linear.
       *
       * #### Iterator Validity
       * No changes.
       *
       * #### Notes
       * The `index` will be clamped to the bounds of the list.
       * By convention, the oldIndex is set to -2 to indicate
       * an insert operation.
       *
       * #### Undefined Behavior.
       * An `index` which is non-integral.
       */
      insertAll(index2, values2) {
        const newIndex = index2;
        for (const value of values2) {
          ArrayExt3.insert(this._array, index2++, value);
        }
        this._changed.emit({
          type: "add",
          oldIndex: -2,
          newIndex,
          oldValues: [],
          newValues: Array.from(values2)
        });
      }
      /**
       * Remove a range of items from the list.
       *
       * @param startIndex - The start index of the range to remove (inclusive).
       *
       * @param endIndex - The end index of the range to remove (exclusive).
       *
       * @returns The new length of the list.
       *
       * #### Complexity
       * Linear.
       *
       * #### Iterator Validity
       * Iterators pointing to the first removed value and beyond are invalid.
       *
       * #### Undefined Behavior
       * A `startIndex` or `endIndex` which is non-integral.
       */
      removeRange(startIndex, endIndex) {
        const oldValues = this._array.slice(startIndex, endIndex);
        for (let i5 = startIndex; i5 < endIndex; i5++) {
          ArrayExt3.removeAt(this._array, startIndex);
        }
        this._changed.emit({
          type: "remove",
          oldIndex: startIndex,
          newIndex: -1,
          oldValues,
          newValues: []
        });
        return this.length;
      }
    };
    (function(Private19) {
      function itemCmp(first2, second) {
        return first2 === second;
      }
      Private19.itemCmp = itemCmp;
    })(Private14 || (Private14 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/observables/lib/undoablelist.js
var ObservableUndoableList2;
var init_undoablelist2 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/observables/lib/undoablelist.js"() {
    init_observablelist2();
    ObservableUndoableList2 = class extends ObservableList2 {
      /**
       * Construct a new undoable observable list.
       */
      constructor(serializer) {
        super();
        this._inCompound = false;
        this._isUndoable = true;
        this._madeCompoundChange = false;
        this._index = -1;
        this._stack = [];
        this._serializer = serializer;
        this.changed.connect(this._onListChanged, this);
      }
      /**
       * Whether the object can redo changes.
       */
      get canRedo() {
        return this._index < this._stack.length - 1;
      }
      /**
       * Whether the object can undo changes.
       */
      get canUndo() {
        return this._index >= 0;
      }
      /**
       * Begin a compound operation.
       *
       * @param isUndoAble - Whether the operation is undoable.
       *   The default is `true`.
       */
      beginCompoundOperation(isUndoAble) {
        this._inCompound = true;
        this._isUndoable = isUndoAble !== false;
        this._madeCompoundChange = false;
      }
      /**
       * End a compound operation.
       */
      endCompoundOperation() {
        this._inCompound = false;
        this._isUndoable = true;
        if (this._madeCompoundChange) {
          this._index++;
        }
      }
      /**
       * Undo an operation.
       */
      undo() {
        if (!this.canUndo) {
          return;
        }
        const changes = this._stack[this._index];
        this._isUndoable = false;
        for (const change of changes.reverse()) {
          this._undoChange(change);
        }
        this._isUndoable = true;
        this._index--;
      }
      /**
       * Redo an operation.
       */
      redo() {
        if (!this.canRedo) {
          return;
        }
        this._index++;
        const changes = this._stack[this._index];
        this._isUndoable = false;
        for (const change of changes) {
          this._redoChange(change);
        }
        this._isUndoable = true;
      }
      /**
       * Clear the change stack.
       */
      clearUndo() {
        this._index = -1;
        this._stack = [];
      }
      /**
       * Handle a change in the list.
       */
      _onListChanged(list, change) {
        if (this.isDisposed || !this._isUndoable) {
          return;
        }
        if (!this._inCompound || !this._madeCompoundChange) {
          this._stack = this._stack.slice(0, this._index + 1);
        }
        const evt = this._copyChange(change);
        if (this._stack[this._index + 1]) {
          this._stack[this._index + 1].push(evt);
        } else {
          this._stack.push([evt]);
        }
        if (!this._inCompound) {
          this._index++;
        } else {
          this._madeCompoundChange = true;
        }
      }
      /**
       * Undo a change event.
       */
      _undoChange(change) {
        let index2 = 0;
        const serializer = this._serializer;
        switch (change.type) {
          case "add":
            for (let length = change.newValues.length; length > 0; length--) {
              this.remove(change.newIndex);
            }
            break;
          case "set":
            index2 = change.oldIndex;
            for (const value of change.oldValues) {
              this.set(index2++, serializer.fromJSON(value));
            }
            break;
          case "remove":
            index2 = change.oldIndex;
            for (const value of change.oldValues) {
              this.insert(index2++, serializer.fromJSON(value));
            }
            break;
          case "move":
            this.move(change.newIndex, change.oldIndex);
            break;
          default:
            return;
        }
      }
      /**
       * Redo a change event.
       */
      _redoChange(change) {
        let index2 = 0;
        const serializer = this._serializer;
        switch (change.type) {
          case "add":
            index2 = change.newIndex;
            for (const value of change.newValues) {
              this.insert(index2++, serializer.fromJSON(value));
            }
            break;
          case "set":
            index2 = change.newIndex;
            for (const value of change.newValues) {
              this.set(change.newIndex++, serializer.fromJSON(value));
            }
            break;
          case "remove":
            for (let length = change.oldValues.length; length > 0; length--) {
              this.remove(change.oldIndex);
            }
            break;
          case "move":
            this.move(change.oldIndex, change.newIndex);
            break;
          default:
            return;
        }
      }
      /**
       * Copy a change as JSON.
       */
      _copyChange(change) {
        const oldValues = [];
        for (const value of change.oldValues) {
          oldValues.push(this._serializer.toJSON(value));
        }
        const newValues = [];
        for (const value of change.newValues) {
          newValues.push(this._serializer.toJSON(value));
        }
        return {
          type: change.type,
          oldIndex: change.oldIndex,
          newIndex: change.newIndex,
          oldValues,
          newValues
        };
      }
    };
    (function(ObservableUndoableList3) {
      class IdentitySerializer {
        /**
         * Identity serialize.
         */
        toJSON(value) {
          return value;
        }
        /**
         * Identity deserialize.
         */
        fromJSON(value) {
          return value;
        }
      }
      ObservableUndoableList3.IdentitySerializer = IdentitySerializer;
    })(ObservableUndoableList2 || (ObservableUndoableList2 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/observables/lib/modeldb.js
var import_coreutils11, ObservableValue2;
var init_modeldb2 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/observables/lib/modeldb.js"() {
    import_coreutils11 = __toESM(require_dist());
    init_index_es63();
    init_index_es6();
    ObservableValue2 = class {
      /**
       * Constructor for the value.
       *
       * @param initialValue: the starting value for the `ObservableValue`.
       */
      constructor(initialValue = null) {
        this._value = null;
        this._changed = new Signal(this);
        this._isDisposed = false;
        this._value = initialValue;
      }
      /**
       * The observable type.
       */
      get type() {
        return "Value";
      }
      /**
       * Whether the value has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * The changed signal.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Get the current value, or `undefined` if it has not been set.
       */
      get() {
        return this._value;
      }
      /**
       * Set the current value.
       */
      set(value) {
        const oldValue = this._value;
        if (import_coreutils11.JSONExt.deepEqual(oldValue, value)) {
          return;
        }
        this._value = value;
        this._changed.emit({
          oldValue,
          newValue: value
        });
      }
      /**
       * Dispose of the resources held by the value.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
        this._value = null;
      }
    };
    (function(ObservableValue3) {
      class IChangedArgs {
      }
      ObservableValue3.IChangedArgs = IChangedArgs;
    })(ObservableValue2 || (ObservableValue2 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/observables/lib/index.js
var init_lib8 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/observables/lib/index.js"() {
    init_modeldb2();
    init_observablejson2();
    init_observablelist2();
    init_observablemap2();
    init_observablestring2();
    init_undoablelist2();
  }
});

// ../../node_modules/@jupyterlab/outputarea/lib/model.js
var import_coreutils12, OutputAreaModel, Private15;
var init_model = __esm({
  "../../node_modules/@jupyterlab/outputarea/lib/model.js"() {
    init_lib7();
    init_lib8();
    init_lib6();
    init_index_es612();
    import_coreutils12 = __toESM(require_dist());
    init_index_es6();
    OutputAreaModel = class {
      /**
       * Construct a new observable outputs instance.
       */
      constructor(options = {}) {
        this.clearNext = false;
        this._lastStream = "";
        this._trusted = false;
        this._isDisposed = false;
        this._stateChanged = new Signal(this);
        this._changed = new Signal(this);
        this._trusted = !!options.trusted;
        this.contentFactory = options.contentFactory || OutputAreaModel.defaultContentFactory;
        this.list = new ObservableList2();
        if (options.values) {
          for (const value of options.values) {
            const index2 = this._add(value) - 1;
            const item = this.list.get(index2);
            item.changed.connect(this._onGenericChange, this);
          }
        }
        this.list.changed.connect(this._onListChanged, this);
      }
      /**
       * A signal emitted when an item changes.
       */
      get stateChanged() {
        return this._stateChanged;
      }
      /**
       * A signal emitted when the list of items changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Get the length of the items in the model.
       */
      get length() {
        return this.list ? this.list.length : 0;
      }
      /**
       * Get whether the model is trusted.
       */
      get trusted() {
        return this._trusted;
      }
      /**
       * Set whether the model is trusted.
       *
       * #### Notes
       * Changing the value will cause all of the models to re-set.
       */
      set trusted(value) {
        if (value === this._trusted) {
          return;
        }
        const trusted = this._trusted = value;
        for (let i5 = 0; i5 < this.list.length; i5++) {
          const oldItem = this.list.get(i5);
          const value2 = oldItem.toJSON();
          const item = this._createItem({ value: value2, trusted });
          this.list.set(i5, item);
          oldItem.dispose();
        }
      }
      /**
       * Test whether the model is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the model.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this.list.dispose();
        Signal.clearData(this);
      }
      /**
       * Get an item at the specified index.
       */
      get(index2) {
        return this.list.get(index2);
      }
      /**
       * Set the value at the specified index.
       */
      set(index2, value) {
        value = import_coreutils12.JSONExt.deepCopy(value);
        Private15.normalize(value);
        const item = this._createItem({ value, trusted: this._trusted });
        this.list.set(index2, item);
      }
      /**
       * Add an output, which may be combined with previous output.
       *
       * @returns The total number of outputs.
       *
       * #### Notes
       * The output bundle is copied.
       * Contiguous stream outputs of the same `name` are combined.
       */
      add(output) {
        if (this.clearNext) {
          this.clear();
          this.clearNext = false;
        }
        return this._add(output);
      }
      /**
       * Clear all of the output.
       *
       * @param wait Delay clearing the output until the next message is added.
       */
      clear(wait = false) {
        this._lastStream = "";
        if (wait) {
          this.clearNext = true;
          return;
        }
        for (const item of this.list) {
          item.dispose();
        }
        this.list.clear();
      }
      /**
       * Deserialize the model from JSON.
       *
       * #### Notes
       * This will clear any existing data.
       */
      fromJSON(values2) {
        this.clear();
        for (const value of values2) {
          this._add(value);
        }
      }
      /**
       * Serialize the model to JSON.
       */
      toJSON() {
        return Array.from(map(this.list, (output) => output.toJSON()));
      }
      /**
       * Add a copy of the item to the list.
       *
       * @returns The list length
       */
      _add(value) {
        const trusted = this._trusted;
        value = import_coreutils12.JSONExt.deepCopy(value);
        Private15.normalize(value);
        if (isStream2(value) && this._lastStream && value.name === this._lastName && this.shouldCombine({
          value,
          lastModel: this.list.get(this.length - 1)
        })) {
          this._lastStream += value.text;
          this._lastStream = Private15.removeOverwrittenChars(this._lastStream);
          value.text = this._lastStream;
          const item2 = this._createItem({ value, trusted });
          const index2 = this.length - 1;
          const prev = this.list.get(index2);
          this.list.set(index2, item2);
          prev.dispose();
          return this.length;
        }
        if (isStream2(value)) {
          value.text = Private15.removeOverwrittenChars(value.text);
        }
        const item = this._createItem({ value, trusted });
        if (isStream2(value)) {
          this._lastStream = value.text;
          this._lastName = value.name;
        } else {
          this._lastStream = "";
        }
        return this.list.push(item);
      }
      /**
       * Whether a new value should be consolidated with the previous output.
       *
       * This will only be called if the minimal criteria of both being stream
       * messages of the same type.
       */
      shouldCombine(options) {
        return true;
      }
      /**
       * Create an output item and hook up its signals.
       */
      _createItem(options) {
        const factory = this.contentFactory;
        const item = factory.createOutputModel(options);
        return item;
      }
      /**
       * Handle a change to the list.
       */
      _onListChanged(sender, args) {
        switch (args.type) {
          case "add":
            args.newValues.forEach((item) => {
              item.changed.connect(this._onGenericChange, this);
            });
            break;
          case "remove":
            args.oldValues.forEach((item) => {
              item.changed.disconnect(this._onGenericChange, this);
            });
            break;
          case "set":
            args.newValues.forEach((item) => {
              item.changed.connect(this._onGenericChange, this);
            });
            args.oldValues.forEach((item) => {
              item.changed.disconnect(this._onGenericChange, this);
            });
            break;
        }
        this._changed.emit(args);
      }
      /**
       * Handle a change to an item.
       */
      _onGenericChange(itemModel) {
        let idx;
        let item = null;
        for (idx = 0; idx < this.list.length; idx++) {
          item = this.list.get(idx);
          if (item === itemModel) {
            break;
          }
        }
        if (item != null) {
          this._stateChanged.emit(idx);
          this._changed.emit({
            type: "set",
            newIndex: idx,
            oldIndex: idx,
            oldValues: [item],
            newValues: [item]
          });
        }
      }
    };
    (function(OutputAreaModel2) {
      class ContentFactory {
        /**
         * Create an output model.
         */
        createOutputModel(options) {
          return new OutputModel(options);
        }
      }
      OutputAreaModel2.ContentFactory = ContentFactory;
      OutputAreaModel2.defaultContentFactory = new ContentFactory();
    })(OutputAreaModel || (OutputAreaModel = {}));
    (function(Private19) {
      function normalize2(value) {
        if (isStream2(value)) {
          if (Array.isArray(value.text)) {
            value.text = value.text.join("\n");
          }
        }
      }
      Private19.normalize = normalize2;
      function fixBackspace2(txt) {
        let tmp = txt;
        do {
          txt = tmp;
          tmp = txt.replace(/[^\n]\x08/gm, "");
        } while (tmp.length < txt.length);
        return txt;
      }
      function fixCarriageReturn(txt) {
        txt = txt.replace(/\r+\n/gm, "\n");
        while (txt.search(/\r[^$]/g) > -1) {
          const base = txt.match(/^(.*)\r+/m)[1];
          let insert = txt.match(/\r+(.*)$/m)[1];
          insert = insert + base.slice(insert.length, base.length);
          txt = txt.replace(/\r+.*$/m, "\r").replace(/^.*\r/m, insert);
        }
        return txt;
      }
      function removeOverwrittenChars(text) {
        return fixCarriageReturn(fixBackspace2(text));
      }
      Private19.removeOverwrittenChars = removeOverwrittenChars;
    })(Private15 || (Private15 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/activitymonitor.js
var require_activitymonitor3 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/activitymonitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActivityMonitor = void 0;
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var ActivityMonitor = class {
      /**
       * Construct a new activity monitor.
       */
      constructor(options) {
        this._timer = -1;
        this._timeout = -1;
        this._isDisposed = false;
        this._activityStopped = new signaling_1.Signal(this);
        options.signal.connect(this._onSignalFired, this);
        this._timeout = options.timeout || 1e3;
      }
      /**
       * A signal emitted when activity has ceased.
       */
      get activityStopped() {
        return this._activityStopped;
      }
      /**
       * The timeout associated with the monitor, in milliseconds.
       */
      get timeout() {
        return this._timeout;
      }
      set timeout(value) {
        this._timeout = value;
      }
      /**
       * Test whether the monitor has been disposed.
       *
       * #### Notes
       * This is a read-only property.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the activity monitor.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * A signal handler for the monitored signal.
       */
      _onSignalFired(sender, args) {
        clearTimeout(this._timer);
        this._sender = sender;
        this._args = args;
        this._timer = setTimeout(() => {
          this._activityStopped.emit({
            sender: this._sender,
            args: this._args
          });
        }, this._timeout);
      }
    };
    exports2.ActivityMonitor = ActivityMonitor;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/interfaces.js
var require_interfaces4 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/lru.js
var require_lru2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/lru.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LruCache = void 0;
    var DEFAULT_MAX_SIZE = 128;
    var LruCache = class {
      constructor(options = {}) {
        this._map = /* @__PURE__ */ new Map();
        this._maxSize = (options === null || options === void 0 ? void 0 : options.maxSize) || DEFAULT_MAX_SIZE;
      }
      /**
       * Return the current size of the cache.
       */
      get size() {
        return this._map.size;
      }
      /**
       * Clear the values in the cache.
       */
      clear() {
        this._map.clear();
      }
      /**
       * Get a value (or null) from the cache, pushing the item to the front of the cache.
       */
      get(key) {
        const item = this._map.get(key) || null;
        if (item != null) {
          this._map.delete(key);
          this._map.set(key, item);
        }
        return item;
      }
      /**
       * Set a value in the cache, potentially evicting an old item.
       */
      set(key, value) {
        if (this._map.size >= this._maxSize) {
          this._map.delete(this._map.keys().next().value);
        }
        this._map.set(key, value);
      }
    };
    exports2.LruCache = LruCache;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js
var require_markdowncodeblocks3 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MarkdownCodeBlocks = void 0;
    var MarkdownCodeBlocks;
    (function(MarkdownCodeBlocks2) {
      MarkdownCodeBlocks2.CODE_BLOCK_MARKER = "```";
      const markdownExtensions = [
        ".markdown",
        ".mdown",
        ".mkdn",
        ".md",
        ".mkd",
        ".mdwn",
        ".mdtxt",
        ".mdtext",
        ".text",
        ".txt",
        ".Rmd"
      ];
      class MarkdownCodeBlock {
        constructor(startLine) {
          this.startLine = startLine;
          this.code = "";
          this.endLine = -1;
        }
      }
      MarkdownCodeBlocks2.MarkdownCodeBlock = MarkdownCodeBlock;
      function isMarkdown(extension2) {
        return markdownExtensions.indexOf(extension2) > -1;
      }
      MarkdownCodeBlocks2.isMarkdown = isMarkdown;
      function findMarkdownCodeBlocks(text) {
        if (!text || text === "") {
          return [];
        }
        const lines = text.split("\n");
        const codeBlocks = [];
        let currentBlock = null;
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
          const line = lines[lineIndex];
          const lineContainsMarker = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER) === 0;
          const constructingBlock = currentBlock != null;
          if (!lineContainsMarker && !constructingBlock) {
            continue;
          }
          if (!constructingBlock) {
            currentBlock = new MarkdownCodeBlock(lineIndex);
            const firstIndex = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const lastIndex = line.lastIndexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const isSingleLine = firstIndex !== lastIndex;
            if (isSingleLine) {
              currentBlock.code = line.substring(firstIndex + MarkdownCodeBlocks2.CODE_BLOCK_MARKER.length, lastIndex);
              currentBlock.endLine = lineIndex;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            }
          } else if (currentBlock) {
            if (lineContainsMarker) {
              currentBlock.endLine = lineIndex - 1;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            } else {
              currentBlock.code += line + "\n";
            }
          }
        }
        return codeBlocks;
      }
      MarkdownCodeBlocks2.findMarkdownCodeBlocks = findMarkdownCodeBlocks;
    })(MarkdownCodeBlocks || (exports2.MarkdownCodeBlocks = MarkdownCodeBlocks = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/url.js
var require_url3 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/url.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLExt = void 0;
    var path_1 = __require("path");
    var url_parse_1 = __importDefault2(require_url_parse());
    var URLExt3;
    (function(URLExt4) {
      function parse4(url) {
        if (typeof document !== "undefined" && document) {
          const a4 = document.createElement("a");
          a4.href = url;
          return a4;
        }
        return (0, url_parse_1.default)(url);
      }
      URLExt4.parse = parse4;
      function getHostName(url) {
        return (0, url_parse_1.default)(url).hostname;
      }
      URLExt4.getHostName = getHostName;
      function normalize2(url) {
        return url && parse4(url).toString();
      }
      URLExt4.normalize = normalize2;
      function join(...parts) {
        let u4 = (0, url_parse_1.default)(parts[0], {});
        const isSchemaLess = u4.protocol === "" && u4.slashes;
        if (isSchemaLess) {
          u4 = (0, url_parse_1.default)(parts[0], "https:" + parts[0]);
        }
        const prefix = `${isSchemaLess ? "" : u4.protocol}${u4.slashes ? "//" : ""}${u4.auth}${u4.auth ? "@" : ""}${u4.host}`;
        const path2 = path_1.posix.join(`${!!prefix && u4.pathname[0] !== "/" ? "/" : ""}${u4.pathname}`, ...parts.slice(1));
        return `${prefix}${path2 === "." ? "" : path2}`;
      }
      URLExt4.join = join;
      function encodeParts(url) {
        return join(...url.split("/").map(encodeURIComponent));
      }
      URLExt4.encodeParts = encodeParts;
      function objectToQueryString(value) {
        const keys2 = Object.keys(value).filter((key) => key.length > 0);
        if (!keys2.length) {
          return "";
        }
        return "?" + keys2.map((key) => {
          const content = encodeURIComponent(String(value[key]));
          return key + (content ? "=" + content : "");
        }).join("&");
      }
      URLExt4.objectToQueryString = objectToQueryString;
      function queryStringToObject(value) {
        return value.replace(/^\?/, "").split("&").reduce((acc, val) => {
          const [key, value2] = val.split("=");
          if (key.length > 0) {
            acc[key] = decodeURIComponent(value2 || "");
          }
          return acc;
        }, {});
      }
      URLExt4.queryStringToObject = queryStringToObject;
      function isLocal(url, allowRoot = false) {
        const { protocol } = parse4(url);
        return (!protocol || url.toLowerCase().indexOf(protocol) !== 0) && (allowRoot ? url.indexOf("//") !== 0 : url.indexOf("/") !== 0);
      }
      URLExt4.isLocal = isLocal;
    })(URLExt3 || (exports2.URLExt = URLExt3 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/pageconfig.js
var require_pageconfig3 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/pageconfig.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageConfig = void 0;
    var coreutils_1 = require_dist();
    var minimist_1 = __importDefault(require_minimist());
    var url_1 = require_url3();
    var PageConfig;
    (function(PageConfig) {
      function getOption(name) {
        if (configData) {
          return configData[name] || getBodyData(name);
        }
        configData = /* @__PURE__ */ Object.create(null);
        let found = false;
        if (typeof document !== "undefined" && document) {
          const el = document.getElementById("jupyter-config-data");
          if (el) {
            configData = JSON.parse(el.textContent || "");
            found = true;
          }
        }
        if (!found && typeof process !== "undefined" && process.argv) {
          try {
            const cli = (0, minimist_1.default)(process.argv.slice(2));
            const path = __require("path");
            let fullPath = "";
            if ("jupyter-config-data" in cli) {
              fullPath = path.resolve(cli["jupyter-config-data"]);
            } else if ("JUPYTER_CONFIG_DATA" in process.env) {
              fullPath = path.resolve(process.env["JUPYTER_CONFIG_DATA"]);
            }
            if (fullPath) {
              configData = eval("require")(fullPath);
            }
          } catch (e4) {
            console.error(e4);
          }
        }
        if (!coreutils_1.JSONExt.isObject(configData)) {
          configData = /* @__PURE__ */ Object.create(null);
        } else {
          for (const key in configData) {
            if (typeof configData[key] !== "string") {
              configData[key] = JSON.stringify(configData[key]);
            }
          }
        }
        return configData[name] || getBodyData(name);
      }
      PageConfig.getOption = getOption;
      function setOption(name2, value) {
        const last2 = getOption(name2);
        configData[name2] = value;
        return last2;
      }
      PageConfig.setOption = setOption;
      function getBaseUrl() {
        return url_1.URLExt.normalize(getOption("baseUrl") || "/");
      }
      PageConfig.getBaseUrl = getBaseUrl;
      function getTreeUrl() {
        return url_1.URLExt.join(getBaseUrl(), getOption("treeUrl"));
      }
      PageConfig.getTreeUrl = getTreeUrl;
      function getShareUrl() {
        return url_1.URLExt.normalize(getOption("shareUrl") || getBaseUrl());
      }
      PageConfig.getShareUrl = getShareUrl;
      function getTreeShareUrl() {
        return url_1.URLExt.normalize(url_1.URLExt.join(getShareUrl(), getOption("treeUrl")));
      }
      PageConfig.getTreeShareUrl = getTreeShareUrl;
      function getUrl(options) {
        var _a, _b, _c, _d;
        let path2 = options.toShare ? getShareUrl() : getBaseUrl();
        const mode = (_a = options.mode) !== null && _a !== void 0 ? _a : getOption("mode");
        const workspace = (_b = options.workspace) !== null && _b !== void 0 ? _b : getOption("workspace");
        const labOrDoc = mode === "single-document" ? "doc" : "lab";
        path2 = url_1.URLExt.join(path2, labOrDoc);
        if (workspace !== PageConfig.defaultWorkspace) {
          path2 = url_1.URLExt.join(path2, "workspaces", encodeURIComponent((_c = getOption("workspace")) !== null && _c !== void 0 ? _c : PageConfig.defaultWorkspace));
        }
        const treePath = (_d = options.treePath) !== null && _d !== void 0 ? _d : getOption("treePath");
        if (treePath) {
          path2 = url_1.URLExt.join(path2, "tree", url_1.URLExt.encodeParts(treePath));
        }
        return path2;
      }
      PageConfig.getUrl = getUrl;
      PageConfig.defaultWorkspace = "default";
      function getWsUrl(baseUrl) {
        let wsUrl = getOption("wsUrl");
        if (!wsUrl) {
          baseUrl = baseUrl ? url_1.URLExt.normalize(baseUrl) : getBaseUrl();
          if (baseUrl.indexOf("http") !== 0) {
            return "";
          }
          wsUrl = "ws" + baseUrl.slice(4);
        }
        return url_1.URLExt.normalize(wsUrl);
      }
      PageConfig.getWsUrl = getWsUrl;
      function getNBConvertURL({ path: path2, format: format2, download }) {
        const notebookPath = url_1.URLExt.encodeParts(path2);
        const url = url_1.URLExt.join(getBaseUrl(), "nbconvert", format2, notebookPath);
        if (download) {
          return url + "?download=true";
        }
        return url;
      }
      PageConfig.getNBConvertURL = getNBConvertURL;
      function getToken() {
        return getOption("token") || getBodyData("jupyterApiToken");
      }
      PageConfig.getToken = getToken;
      function getNotebookVersion() {
        const notebookVersion = getOption("notebookVersion");
        if (notebookVersion === "") {
          return [0, 0, 0];
        }
        return JSON.parse(notebookVersion);
      }
      PageConfig.getNotebookVersion = getNotebookVersion;
      let configData = null;
      function getBodyData(key) {
        if (typeof document === "undefined" || !document.body) {
          return "";
        }
        const val = document.body.dataset[key];
        if (typeof val === "undefined") {
          return "";
        }
        return decodeURIComponent(val);
      }
      let Extension;
      (function(Extension2) {
        function populate(key) {
          try {
            const raw = getOption(key);
            if (raw) {
              return JSON.parse(raw);
            }
          } catch (error) {
            console.warn(`Unable to parse ${key}.`, error);
          }
          return [];
        }
        Extension2.deferred = populate("deferredExtensions");
        Extension2.disabled = populate("disabledExtensions");
        function isDeferred(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.deferred.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDeferred = isDeferred;
        function isDisabled(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.disabled.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDisabled = isDisabled;
      })(Extension = PageConfig.Extension || (PageConfig.Extension = {}));
    })(PageConfig || (exports.PageConfig = PageConfig = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/path.js
var require_path3 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathExt = void 0;
    var path_1 = __require("path");
    var PathExt2;
    (function(PathExt3) {
      function join(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : removeSlash(path2);
      }
      PathExt3.join = join;
      function joinWithLeadingSlash(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : path2;
      }
      PathExt3.joinWithLeadingSlash = joinWithLeadingSlash;
      function basename(path2, ext) {
        return path_1.posix.basename(path2, ext);
      }
      PathExt3.basename = basename;
      function dirname(path2) {
        const dir = removeSlash(path_1.posix.dirname(path2));
        return dir === "." ? "" : dir;
      }
      PathExt3.dirname = dirname;
      function extname(path2) {
        return path_1.posix.extname(path2);
      }
      PathExt3.extname = extname;
      function normalize2(path2) {
        if (path2 === "") {
          return "";
        }
        return removeSlash(path_1.posix.normalize(path2));
      }
      PathExt3.normalize = normalize2;
      function resolve(...parts) {
        return removeSlash(path_1.posix.resolve(...parts));
      }
      PathExt3.resolve = resolve;
      function relative(from, to) {
        return removeSlash(path_1.posix.relative(from, to));
      }
      PathExt3.relative = relative;
      function normalizeExtension(extension2) {
        if (extension2.length > 0 && extension2.indexOf(".") !== 0) {
          extension2 = `.${extension2}`;
        }
        return extension2;
      }
      PathExt3.normalizeExtension = normalizeExtension;
      function removeSlash(path2) {
        if (path2.indexOf("/") === 0) {
          path2 = path2.slice(1);
        }
        return path2;
      }
      PathExt3.removeSlash = removeSlash;
    })(PathExt2 || (exports2.PathExt = PathExt2 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/signal.js
var require_signal3 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/signal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signalToPromise = void 0;
    var coreutils_12 = require_dist();
    function signalToPromise(signal, timeout) {
      const waitForSignal = new coreutils_12.PromiseDelegate();
      function cleanup() {
        signal.disconnect(slot);
      }
      function slot(sender, args) {
        cleanup();
        waitForSignal.resolve([sender, args]);
      }
      signal.connect(slot);
      if ((timeout !== null && timeout !== void 0 ? timeout : 0) > 0) {
        setTimeout(() => {
          cleanup();
          waitForSignal.reject(`Signal not emitted within ${timeout} ms.`);
        }, timeout);
      }
      return waitForSignal.promise;
    }
    exports2.signalToPromise = signalToPromise;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/text.js
var require_text3 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/text.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Text = void 0;
    var Text;
    (function(Text2) {
      const HAS_SURROGATES = "\u{1D41A}".length > 1;
      function jsIndexToCharIndex(jsIdx, text) {
        if (HAS_SURROGATES) {
          return jsIdx;
        }
        let charIdx = jsIdx;
        for (let i5 = 0; i5 + 1 < text.length && i5 < jsIdx; i5++) {
          const charCode = text.charCodeAt(i5);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i5 + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              charIdx--;
              i5++;
            }
          }
        }
        return charIdx;
      }
      Text2.jsIndexToCharIndex = jsIndexToCharIndex;
      function charIndexToJsIndex(charIdx, text) {
        if (HAS_SURROGATES) {
          return charIdx;
        }
        let jsIdx = charIdx;
        for (let i5 = 0; i5 + 1 < text.length && i5 < jsIdx; i5++) {
          const charCode = text.charCodeAt(i5);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i5 + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              jsIdx++;
              i5++;
            }
          }
        }
        return jsIdx;
      }
      Text2.charIndexToJsIndex = charIndexToJsIndex;
      function camelCase(str2, upper = false) {
        return str2.replace(/^(\w)|[\s-_:]+(\w)/g, function(match, p1, p22) {
          if (p22) {
            return p22.toUpperCase();
          } else {
            return upper ? p1.toUpperCase() : p1.toLowerCase();
          }
        });
      }
      Text2.camelCase = camelCase;
      function titleCase(str2) {
        return (str2 || "").toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
      }
      Text2.titleCase = titleCase;
    })(Text || (exports2.Text = Text = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/time.js
var require_time3 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Time = void 0;
    var UNITS = [
      { name: "years", milliseconds: 365 * 24 * 60 * 60 * 1e3 },
      { name: "months", milliseconds: 30 * 24 * 60 * 60 * 1e3 },
      { name: "days", milliseconds: 24 * 60 * 60 * 1e3 },
      { name: "hours", milliseconds: 60 * 60 * 1e3 },
      { name: "minutes", milliseconds: 60 * 1e3 },
      { name: "seconds", milliseconds: 1e3 }
    ];
    var Time;
    (function(Time2) {
      function formatHuman(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.RelativeTimeFormat(lang, { numeric: "auto" });
        const delta = new Date(value).getTime() - Date.now();
        for (let unit of UNITS) {
          const amount = Math.ceil(delta / unit.milliseconds);
          if (amount === 0) {
            continue;
          }
          return formatter.format(amount, unit.name);
        }
        return formatter.format(0, "seconds");
      }
      Time2.formatHuman = formatHuman;
      function format2(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.DateTimeFormat(lang, {
          dateStyle: "short",
          timeStyle: "short"
        });
        return formatter.format(new Date(value));
      }
      Time2.format = format2;
    })(Time || (exports2.Time = Time = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/index.js
var require_lib6 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/coreutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_activitymonitor3(), exports2);
    __exportStar(require_interfaces4(), exports2);
    __exportStar(require_lru2(), exports2);
    __exportStar(require_markdowncodeblocks3(), exports2);
    __exportStar(require_pageconfig3(), exports2);
    __exportStar(require_path3(), exports2);
    __exportStar(require_signal3(), exports2);
    __exportStar(require_text3(), exports2);
    __exportStar(require_time3(), exports2);
    __exportStar(require_url3(), exports2);
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/messages.js
var require_messages2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.supportedKernelWebSocketProtocols = exports2.isInputReplyMsg = exports2.isInputRequestMsg = exports2.isDebugReplyMsg = exports2.isDebugRequestMsg = exports2.isExecuteReplyMsg = exports2.isInfoRequestMsg = exports2.isCommMsgMsg = exports2.isCommCloseMsg = exports2.isCommOpenMsg = exports2.isDebugEventMsg = exports2.isClearOutputMsg = exports2.isStatusMsg = exports2.isErrorMsg = exports2.isExecuteResultMsg = exports2.isExecuteInputMsg = exports2.isUpdateDisplayDataMsg = exports2.isDisplayDataMsg = exports2.isStreamMsg = exports2.createMessage = void 0;
    var coreutils_12 = require_dist();
    function createMessage(options) {
      var _a, _b, _c, _d, _e;
      return {
        buffers: (_a = options.buffers) !== null && _a !== void 0 ? _a : [],
        channel: options.channel,
        content: options.content,
        header: {
          date: (/* @__PURE__ */ new Date()).toISOString(),
          msg_id: (_b = options.msgId) !== null && _b !== void 0 ? _b : coreutils_12.UUID.uuid4(),
          msg_type: options.msgType,
          session: options.session,
          username: (_c = options.username) !== null && _c !== void 0 ? _c : "",
          version: "5.2"
        },
        metadata: (_d = options.metadata) !== null && _d !== void 0 ? _d : {},
        parent_header: (_e = options.parentHeader) !== null && _e !== void 0 ? _e : {}
      };
    }
    exports2.createMessage = createMessage;
    function isStreamMsg(msg) {
      return msg.header.msg_type === "stream";
    }
    exports2.isStreamMsg = isStreamMsg;
    function isDisplayDataMsg(msg) {
      return msg.header.msg_type === "display_data";
    }
    exports2.isDisplayDataMsg = isDisplayDataMsg;
    function isUpdateDisplayDataMsg(msg) {
      return msg.header.msg_type === "update_display_data";
    }
    exports2.isUpdateDisplayDataMsg = isUpdateDisplayDataMsg;
    function isExecuteInputMsg(msg) {
      return msg.header.msg_type === "execute_input";
    }
    exports2.isExecuteInputMsg = isExecuteInputMsg;
    function isExecuteResultMsg(msg) {
      return msg.header.msg_type === "execute_result";
    }
    exports2.isExecuteResultMsg = isExecuteResultMsg;
    function isErrorMsg(msg) {
      return msg.header.msg_type === "error";
    }
    exports2.isErrorMsg = isErrorMsg;
    function isStatusMsg(msg) {
      return msg.header.msg_type === "status";
    }
    exports2.isStatusMsg = isStatusMsg;
    function isClearOutputMsg(msg) {
      return msg.header.msg_type === "clear_output";
    }
    exports2.isClearOutputMsg = isClearOutputMsg;
    function isDebugEventMsg(msg) {
      return msg.header.msg_type === "debug_event";
    }
    exports2.isDebugEventMsg = isDebugEventMsg;
    function isCommOpenMsg(msg) {
      return msg.header.msg_type === "comm_open";
    }
    exports2.isCommOpenMsg = isCommOpenMsg;
    function isCommCloseMsg(msg) {
      return msg.header.msg_type === "comm_close";
    }
    exports2.isCommCloseMsg = isCommCloseMsg;
    function isCommMsgMsg(msg) {
      return msg.header.msg_type === "comm_msg";
    }
    exports2.isCommMsgMsg = isCommMsgMsg;
    function isInfoRequestMsg(msg) {
      return msg.header.msg_type === "kernel_info_request";
    }
    exports2.isInfoRequestMsg = isInfoRequestMsg;
    function isExecuteReplyMsg(msg) {
      return msg.header.msg_type === "execute_reply";
    }
    exports2.isExecuteReplyMsg = isExecuteReplyMsg;
    function isDebugRequestMsg(msg) {
      return msg.header.msg_type === "debug_request";
    }
    exports2.isDebugRequestMsg = isDebugRequestMsg;
    function isDebugReplyMsg(msg) {
      return msg.header.msg_type === "debug_reply";
    }
    exports2.isDebugReplyMsg = isDebugReplyMsg;
    function isInputRequestMsg(msg) {
      return msg.header.msg_type === "input_request";
    }
    exports2.isInputRequestMsg = isInputRequestMsg;
    function isInputReplyMsg(msg) {
      return msg.header.msg_type === "input_reply";
    }
    exports2.isInputReplyMsg = isInputReplyMsg;
    var supportedKernelWebSocketProtocols;
    (function(supportedKernelWebSocketProtocols2) {
      supportedKernelWebSocketProtocols2["v1KernelWebsocketJupyterOrg"] = "v1.kernel.websocket.jupyter.org";
    })(supportedKernelWebSocketProtocols || (exports2.supportedKernelWebSocketProtocols = supportedKernelWebSocketProtocols = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/serialize.js
var require_serialize2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/serialize.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deserialize = exports2.serialize = void 0;
    var KernelMessage2 = __importStar(require_messages2());
    function serialize2(msg, protocol = "") {
      switch (protocol) {
        case KernelMessage2.supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg:
          return Private19.serializeV1KernelWebsocketJupyterOrg(msg);
        default:
          return Private19.serializeDefault(msg);
      }
    }
    exports2.serialize = serialize2;
    function deserialize(data, protocol = "") {
      switch (protocol) {
        case KernelMessage2.supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg:
          return Private19.deserializeV1KernelWebsocketJupyterOrg(data);
        default:
          return Private19.deserializeDefault(data);
      }
    }
    exports2.deserialize = deserialize;
    var Private19;
    (function(Private20) {
      function deserializeV1KernelWebsocketJupyterOrg(binMsg) {
        let msg;
        const data = new DataView(binMsg);
        const offsetNumber = Number(data.getBigUint64(
          0,
          true
          /* littleEndian */
        ));
        let offsets = [];
        for (let i5 = 0; i5 < offsetNumber; i5++) {
          offsets.push(Number(data.getBigUint64(
            8 * (i5 + 1),
            true
            /* littleEndian */
          )));
        }
        const decoder = new TextDecoder("utf8");
        const channel = decoder.decode(binMsg.slice(offsets[0], offsets[1]));
        const header = JSON.parse(decoder.decode(binMsg.slice(offsets[1], offsets[2])));
        const parent_header = JSON.parse(decoder.decode(binMsg.slice(offsets[2], offsets[3])));
        const metadata = JSON.parse(decoder.decode(binMsg.slice(offsets[3], offsets[4])));
        const content = JSON.parse(decoder.decode(binMsg.slice(offsets[4], offsets[5])));
        let buffers = [];
        for (let i5 = 5; i5 < offsets.length - 1; i5++) {
          buffers.push(new DataView(binMsg.slice(offsets[i5], offsets[i5 + 1])));
        }
        msg = {
          channel,
          header,
          parent_header,
          metadata,
          content,
          buffers
        };
        return msg;
      }
      Private20.deserializeV1KernelWebsocketJupyterOrg = deserializeV1KernelWebsocketJupyterOrg;
      function serializeV1KernelWebsocketJupyterOrg(msg) {
        const header = JSON.stringify(msg.header);
        const parentHeader = msg.parent_header == null ? "{}" : JSON.stringify(msg.parent_header);
        const metadata = JSON.stringify(msg.metadata);
        const content = JSON.stringify(msg.content);
        const buffers = msg.buffers !== void 0 ? msg.buffers : [];
        const offsetNumber = 1 + 4 + buffers.length + 1;
        let offsets = [];
        offsets.push(8 * (1 + offsetNumber));
        offsets.push(msg.channel.length + offsets[offsets.length - 1]);
        const encoder = new TextEncoder();
        const channelEncoded = encoder.encode(msg.channel);
        const headerEncoded = encoder.encode(header);
        const parentHeaderEncoded = encoder.encode(parentHeader);
        const metadataEncoded = encoder.encode(metadata);
        const contentEncoded = encoder.encode(content);
        const binMsgNoBuff = new Uint8Array(channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length + metadataEncoded.length + contentEncoded.length);
        binMsgNoBuff.set(channelEncoded);
        binMsgNoBuff.set(headerEncoded, channelEncoded.length);
        binMsgNoBuff.set(parentHeaderEncoded, channelEncoded.length + headerEncoded.length);
        binMsgNoBuff.set(metadataEncoded, channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length);
        binMsgNoBuff.set(contentEncoded, channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length + metadataEncoded.length);
        for (let length of [
          headerEncoded.length,
          parentHeaderEncoded.length,
          metadataEncoded.length,
          contentEncoded.length
        ]) {
          offsets.push(length + offsets[offsets.length - 1]);
        }
        let buffersByteLength = 0;
        for (let buffer of buffers) {
          let length = buffer.byteLength;
          offsets.push(length + offsets[offsets.length - 1]);
          buffersByteLength += length;
        }
        const binMsg = new Uint8Array(8 * (1 + offsetNumber) + binMsgNoBuff.byteLength + buffersByteLength);
        const word = new ArrayBuffer(8);
        const data = new DataView(word);
        data.setBigUint64(
          0,
          BigInt(offsetNumber),
          true
          /* littleEndian */
        );
        binMsg.set(new Uint8Array(word), 0);
        for (let i5 = 0; i5 < offsets.length; i5++) {
          data.setBigUint64(
            0,
            BigInt(offsets[i5]),
            true
            /* littleEndian */
          );
          binMsg.set(new Uint8Array(word), 8 * (i5 + 1));
        }
        binMsg.set(binMsgNoBuff, offsets[0]);
        for (let i5 = 0; i5 < buffers.length; i5++) {
          const buffer = buffers[i5];
          binMsg.set(new Uint8Array(ArrayBuffer.isView(buffer) ? buffer.buffer : buffer), offsets[5 + i5]);
        }
        return binMsg.buffer;
      }
      Private20.serializeV1KernelWebsocketJupyterOrg = serializeV1KernelWebsocketJupyterOrg;
      function deserializeDefault(data) {
        let value;
        if (typeof data === "string") {
          value = JSON.parse(data);
        } else {
          value = deserializeBinary(data);
        }
        return value;
      }
      Private20.deserializeDefault = deserializeDefault;
      function serializeDefault(msg) {
        var _a;
        let value;
        if ((_a = msg.buffers) === null || _a === void 0 ? void 0 : _a.length) {
          value = serializeBinary(msg);
        } else {
          value = JSON.stringify(msg);
        }
        return value;
      }
      Private20.serializeDefault = serializeDefault;
      function deserializeBinary(buf) {
        const data = new DataView(buf);
        const nbufs = data.getUint32(0);
        const offsets = [];
        if (nbufs < 2) {
          throw new Error("Invalid incoming Kernel Message");
        }
        for (let i5 = 1; i5 <= nbufs; i5++) {
          offsets.push(data.getUint32(i5 * 4));
        }
        const jsonBytes = new Uint8Array(buf.slice(offsets[0], offsets[1]));
        const msg = JSON.parse(new TextDecoder("utf8").decode(jsonBytes));
        msg.buffers = [];
        for (let i5 = 1; i5 < nbufs; i5++) {
          const start = offsets[i5];
          const stop = offsets[i5 + 1] || buf.byteLength;
          msg.buffers.push(new DataView(buf.slice(start, stop)));
        }
        return msg;
      }
      function serializeBinary(msg) {
        const offsets = [];
        const buffers = [];
        const encoder = new TextEncoder();
        let origBuffers = [];
        if (msg.buffers !== void 0) {
          origBuffers = msg.buffers;
          delete msg["buffers"];
        }
        const jsonUtf8 = encoder.encode(JSON.stringify(msg));
        buffers.push(jsonUtf8.buffer);
        for (let i5 = 0; i5 < origBuffers.length; i5++) {
          const b4 = origBuffers[i5];
          buffers.push(ArrayBuffer.isView(b4) ? b4.buffer : b4);
        }
        const nbufs = buffers.length;
        offsets.push(4 * (nbufs + 1));
        for (let i5 = 0; i5 + 1 < buffers.length; i5++) {
          offsets.push(offsets[offsets.length - 1] + buffers[i5].byteLength);
        }
        const msgBuf = new Uint8Array(offsets[offsets.length - 1] + buffers[buffers.length - 1].byteLength);
        const view = new DataView(msgBuf.buffer);
        view.setUint32(0, nbufs);
        for (let i5 = 0; i5 < offsets.length; i5++) {
          view.setUint32(4 * (i5 + 1), offsets[i5]);
        }
        for (let i5 = 0; i5 < buffers.length; i5++) {
          msgBuf.set(new Uint8Array(buffers[i5]), offsets[i5]);
        }
        return msgBuf.buffer;
      }
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/shim/ws.js
var require_ws2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/shim/ws.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = WebSocket;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/serverconnection.js
var require_serverconnection2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/serverconnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerConnection = void 0;
    var coreutils_12 = require_lib6();
    var serialize_1 = require_serialize2();
    var WEBSOCKET;
    if (typeof window === "undefined") {
      WEBSOCKET = require_ws2();
    } else {
      WEBSOCKET = WebSocket;
    }
    var ServerConnection3;
    (function(ServerConnection4) {
      function makeSettings(options) {
        return Private19.makeSettings(options);
      }
      ServerConnection4.makeSettings = makeSettings;
      function makeRequest(url, init, settings) {
        return Private19.handleRequest(url, init, settings);
      }
      ServerConnection4.makeRequest = makeRequest;
      class ResponseError extends Error {
        /**
         * Create a ResponseError from a response, handling the traceback and message
         * as appropriate.
         *
         * @param response The response object.
         *
         * @returns A promise that resolves with a `ResponseError` object.
         */
        static async create(response) {
          try {
            const data = await response.json();
            const { message, traceback } = data;
            if (traceback) {
              console.error(traceback);
            }
            return new ResponseError(response, message !== null && message !== void 0 ? message : ResponseError._defaultMessage(response), traceback !== null && traceback !== void 0 ? traceback : "");
          } catch (e4) {
            console.debug(e4);
            return new ResponseError(response);
          }
        }
        /**
         * Create a new response error.
         */
        constructor(response, message = ResponseError._defaultMessage(response), traceback = "") {
          super(message);
          this.response = response;
          this.traceback = traceback;
        }
        static _defaultMessage(response) {
          return `Invalid response: ${response.status} ${response.statusText}`;
        }
      }
      ServerConnection4.ResponseError = ResponseError;
      class NetworkError extends TypeError {
        /**
         * Create a new network error.
         */
        constructor(original) {
          super(original.message);
          this.stack = original.stack;
        }
      }
      ServerConnection4.NetworkError = NetworkError;
    })(ServerConnection3 || (exports2.ServerConnection = ServerConnection3 = {}));
    var Private19;
    (function(Private20) {
      function makeSettings(options = {}) {
        var _a;
        const pageBaseUrl = coreutils_12.PageConfig.getBaseUrl();
        const pageWsUrl = coreutils_12.PageConfig.getWsUrl();
        const baseUrl = coreutils_12.URLExt.normalize(options.baseUrl) || pageBaseUrl;
        let wsUrl = options.wsUrl;
        if (!wsUrl && baseUrl === pageBaseUrl) {
          wsUrl = pageWsUrl;
        }
        if (!wsUrl && baseUrl.indexOf("http") === 0) {
          wsUrl = "ws" + baseUrl.slice(4);
        }
        wsUrl = wsUrl !== null && wsUrl !== void 0 ? wsUrl : pageWsUrl;
        return {
          init: { cache: "no-store", credentials: "same-origin" },
          fetch,
          Headers,
          Request,
          WebSocket: WEBSOCKET,
          token: coreutils_12.PageConfig.getToken(),
          appUrl: coreutils_12.PageConfig.getOption("appUrl"),
          appendToken: typeof window === "undefined" || typeof process !== "undefined" && ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.JEST_WORKER_ID) !== void 0 || coreutils_12.URLExt.getHostName(pageBaseUrl) !== coreutils_12.URLExt.getHostName(wsUrl),
          serializer: { serialize: serialize_1.serialize, deserialize: serialize_1.deserialize },
          ...options,
          baseUrl,
          wsUrl
        };
      }
      Private20.makeSettings = makeSettings;
      function handleRequest(url, init, settings) {
        var _a;
        if (url.indexOf(settings.baseUrl) !== 0) {
          throw new Error("Can only be used for notebook server requests");
        }
        const cache2 = (_a = init.cache) !== null && _a !== void 0 ? _a : settings.init.cache;
        if (cache2 === "no-store") {
          url += (/\?/.test(url) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
        }
        const request = new settings.Request(url, { ...settings.init, ...init });
        let authenticated = false;
        if (settings.token) {
          authenticated = true;
          request.headers.append("Authorization", `token ${settings.token}`);
        }
        if (typeof document !== "undefined") {
          const xsrfToken = getCookie("_xsrf");
          if (xsrfToken !== void 0) {
            authenticated = true;
            request.headers.append("X-XSRFToken", xsrfToken);
          }
        }
        if (!request.headers.has("Content-Type") && authenticated) {
          request.headers.set("Content-Type", "application/json");
        }
        return settings.fetch.call(null, request).catch((e4) => {
          throw new ServerConnection3.NetworkError(e4);
        });
      }
      Private20.handleRequest = handleRequest;
      function getCookie(name2) {
        let cookie = "";
        try {
          cookie = document.cookie;
        } catch (e4) {
          return;
        }
        const matches = cookie.match("\\b" + name2 + "=([^;]*)\\b");
        return matches === null || matches === void 0 ? void 0 : matches[1];
      }
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/basemanager.js
var require_basemanager2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/basemanager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseManager = void 0;
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var serverconnection_1 = require_serverconnection2();
    var BaseManager = class {
      constructor(options) {
        var _a;
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * A signal emitted when the delegate is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Test whether the delegate has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Whether the manager is active.
       */
      get isActive() {
        return true;
      }
      /**
       * Dispose of the delegate and invoke the callback function.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._disposed.emit(void 0);
        signaling_1.Signal.clearData(this);
      }
    };
    exports2.BaseManager = BaseManager;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/config/index.js
var require_config2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigWithDefaults = exports2.ConfigSection = void 0;
    var coreutils_12 = require_lib6();
    var __1 = require_lib8();
    var SERVICE_CONFIG_URL = "api/config";
    var ConfigSection;
    (function(ConfigSection2) {
      function create2(options) {
        const section = new DefaultConfigSection(options);
        return section.load().then(() => {
          return section;
        });
      }
      ConfigSection2.create = create2;
    })(ConfigSection || (exports2.ConfigSection = ConfigSection = {}));
    var DefaultConfigSection = class {
      /**
       * Construct a new config section.
       */
      constructor(options) {
        var _a;
        this._url = "unknown";
        const settings = this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._url = coreutils_12.URLExt.join(settings.baseUrl, SERVICE_CONFIG_URL, encodeURIComponent(options.name));
      }
      /**
       * Get the data for this section.
       */
      get data() {
        return this._data;
      }
      /**
       * Load the initial data for this section.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       */
      async load() {
        const response = await __1.ServerConnection.makeRequest(this._url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._data = await response.json();
      }
      /**
       * Modify the stored config values.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * Updates the local data immediately, sends the change to the server,
       * and updates the local data with the response, and fulfils the promise
       * with that data.
       */
      async update(newdata) {
        this._data = { ...this._data, ...newdata };
        const init = {
          method: "PATCH",
          body: JSON.stringify(newdata)
        };
        const response = await __1.ServerConnection.makeRequest(this._url, init, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._data = await response.json();
        return this._data;
      }
    };
    var ConfigWithDefaults = class {
      /**
       * Create a new config with defaults.
       */
      constructor(options) {
        var _a, _b;
        this._className = "";
        this._section = options.section;
        this._defaults = (_a = options.defaults) !== null && _a !== void 0 ? _a : {};
        this._className = (_b = options.className) !== null && _b !== void 0 ? _b : "";
      }
      /**
       * Get data from the config section or fall back to defaults.
       */
      get(key) {
        const data = this._classData();
        return key in data ? data[key] : this._defaults[key];
      }
      /**
       * Set a config value.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * Sends the update to the server, and changes our local copy of the data
       * immediately.
       */
      set(key, value) {
        const d6 = {};
        d6[key] = value;
        if (this._className) {
          const d22 = {};
          d22[this._className] = d6;
          return this._section.update(d22);
        } else {
          return this._section.update(d6);
        }
      }
      /**
       * Get data from the Section with our classname, if available.
       *
       * #### Notes
       * If we have no classname, get all of the data in the Section
       */
      _classData() {
        const data = this._section.data;
        if (this._className && this._className in data) {
          return data[this._className];
        }
        return data;
      }
    };
    exports2.ConfigWithDefaults = ConfigWithDefaults;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/validate.js
var require_validate6 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateProperty = void 0;
    function validateProperty(object2, name2, typeName, values2 = []) {
      if (!object2.hasOwnProperty(name2)) {
        throw Error(`Missing property '${name2}'`);
      }
      const value = object2[name2];
      if (typeName !== void 0) {
        let valid2 = true;
        switch (typeName) {
          case "array":
            valid2 = Array.isArray(value);
            break;
          case "object":
            valid2 = typeof value !== "undefined";
            break;
          default:
            valid2 = typeof value === typeName;
        }
        if (!valid2) {
          throw new Error(`Property '${name2}' is not of type '${typeName}'`);
        }
        if (values2.length > 0) {
          let valid3 = true;
          switch (typeName) {
            case "string":
            case "number":
            case "boolean":
              valid3 = values2.includes(value);
              break;
            default:
              valid3 = values2.findIndex((v2) => v2 === value) >= 0;
              break;
          }
          if (!valid3) {
            throw new Error(`Property '${name2}' is not one of the valid values ${JSON.stringify(values2)}`);
          }
        }
      }
    }
    exports2.validateProperty = validateProperty;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/contents/validate.js
var require_validate7 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/contents/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateCheckpointModel = exports2.validateContentsModel = void 0;
    var validate_1 = require_validate6();
    function validateContentsModel(model) {
      (0, validate_1.validateProperty)(model, "name", "string");
      (0, validate_1.validateProperty)(model, "path", "string");
      (0, validate_1.validateProperty)(model, "type", "string");
      (0, validate_1.validateProperty)(model, "created", "string");
      (0, validate_1.validateProperty)(model, "last_modified", "string");
      (0, validate_1.validateProperty)(model, "mimetype", "object");
      (0, validate_1.validateProperty)(model, "content", "object");
      (0, validate_1.validateProperty)(model, "format", "object");
    }
    exports2.validateContentsModel = validateContentsModel;
    function validateCheckpointModel(model) {
      (0, validate_1.validateProperty)(model, "id", "string");
      (0, validate_1.validateProperty)(model, "last_modified", "string");
    }
    exports2.validateCheckpointModel = validateCheckpointModel;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/contents/index.js
var require_contents2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/contents/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Drive = exports2.ContentsManager = exports2.Contents = void 0;
    var coreutils_12 = require_lib6();
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var __1 = require_lib8();
    var validate = __importStar(require_validate7());
    var SERVICE_DRIVE_URL = "api/contents";
    var FILES_URL = "files";
    var Contents;
    (function(Contents2) {
      function validateContentsModel(contents) {
        validate.validateContentsModel(contents);
      }
      Contents2.validateContentsModel = validateContentsModel;
      function validateCheckpointModel(checkpoint) {
        validate.validateCheckpointModel(checkpoint);
      }
      Contents2.validateCheckpointModel = validateCheckpointModel;
    })(Contents || (exports2.Contents = Contents = {}));
    var ContentsManager = class {
      /**
       * Construct a new contents manager object.
       *
       * @param options - The options used to initialize the object.
       */
      constructor(options = {}) {
        var _a, _b;
        this._isDisposed = false;
        this._additionalDrives = /* @__PURE__ */ new Map();
        this._fileChanged = new signaling_1.Signal(this);
        const serverSettings = this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._defaultDrive = (_b = options.defaultDrive) !== null && _b !== void 0 ? _b : new Drive({ serverSettings });
        this._defaultDrive.fileChanged.connect(this._onFileChanged, this);
      }
      /**
       * A signal emitted when a file operation takes place.
       */
      get fileChanged() {
        return this._fileChanged;
      }
      /**
       * Test whether the manager has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * Add an `IDrive` to the manager.
       */
      addDrive(drive) {
        this._additionalDrives.set(drive.name, drive);
        drive.fileChanged.connect(this._onFileChanged, this);
      }
      /**
       * Given a path, get a shared model factory from the
       * relevant backend. Returns `null` if the backend
       * does not provide one.
       */
      getSharedModelFactory(path2) {
        var _a;
        const [drive] = this._driveForPath(path2);
        return (_a = drive === null || drive === void 0 ? void 0 : drive.sharedModelFactory) !== null && _a !== void 0 ? _a : null;
      }
      /**
       * Given a path of the form `drive:local/portion/of/it.txt`
       * get the local part of it.
       *
       * @param path: the path.
       *
       * @returns The local part of the path.
       */
      localPath(path2) {
        const parts = path2.split("/");
        const firstParts = parts[0].split(":");
        if (firstParts.length === 1 || !this._additionalDrives.has(firstParts[0])) {
          return coreutils_12.PathExt.removeSlash(path2);
        }
        return coreutils_12.PathExt.join(firstParts.slice(1).join(":"), ...parts.slice(1));
      }
      /**
       * Normalize a global path. Reduces '..' and '.' parts, and removes
       * leading slashes from the local part of the path, while retaining
       * the drive name if it exists.
       *
       * @param path: the path.
       *
       * @returns The normalized path.
       */
      normalize(path2) {
        const parts = path2.split(":");
        if (parts.length === 1) {
          return coreutils_12.PathExt.normalize(path2);
        }
        return `${parts[0]}:${coreutils_12.PathExt.normalize(parts.slice(1).join(":"))}`;
      }
      /**
       * Resolve a global path, starting from the root path. Behaves like
       * posix-path.resolve, with 3 differences:
       *  - will never prepend cwd
       *  - if root has a drive name, the result is prefixed with "<drive>:"
       *  - before adding drive name, leading slashes are removed
       *
       * @param path: the path.
       *
       * @returns The normalized path.
       */
      resolvePath(root2, path2) {
        const driveName = this.driveName(root2);
        const localPath = this.localPath(root2);
        const resolved = coreutils_12.PathExt.resolve("/", localPath, path2);
        return driveName ? `${driveName}:${resolved}` : resolved;
      }
      /**
       * Given a path of the form `drive:local/portion/of/it.txt`
       * get the name of the drive. If the path is missing
       * a drive portion, returns an empty string.
       *
       * @param path: the path.
       *
       * @returns The drive name for the path, or the empty string.
       */
      driveName(path2) {
        const parts = path2.split("/");
        const firstParts = parts[0].split(":");
        if (firstParts.length === 1) {
          return "";
        }
        if (this._additionalDrives.has(firstParts[0])) {
          return firstParts[0];
        }
        return "";
      }
      /**
       * Get a file or directory.
       *
       * @param path: The path to the file.
       *
       * @param options: The options used to fetch the file.
       *
       * @returns A promise which resolves with the file content.
       */
      get(path2, options) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.get(localPath, options).then((contentsModel) => {
          const listing = [];
          if (contentsModel.type === "directory" && contentsModel.content) {
            for (const item of contentsModel.content) {
              listing.push({ ...item, path: this._toGlobalPath(drive, item.path) });
            }
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive, localPath),
              content: listing,
              serverPath: contentsModel.path
            };
          } else {
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive, localPath),
              serverPath: contentsModel.path
            };
          }
        });
      }
      /**
       * Get an encoded download url given a file path.
       *
       * @param path - An absolute POSIX file path on the server.
       *
       * #### Notes
       * It is expected that the path contains no relative paths.
       *
       * The returned URL may include a query parameter.
       */
      getDownloadUrl(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.getDownloadUrl(localPath);
      }
      /**
       * Create a new untitled file or directory in the specified directory path.
       *
       * @param options: The options used to create the file.
       *
       * @returns A promise which resolves with the created file content when the
       *    file is created.
       */
      newUntitled(options = {}) {
        if (options.path) {
          const globalPath = this.normalize(options.path);
          const [drive, localPath] = this._driveForPath(globalPath);
          return drive.newUntitled({ ...options, path: localPath }).then((contentsModel) => {
            return {
              ...contentsModel,
              path: coreutils_12.PathExt.join(globalPath, contentsModel.name),
              serverPath: contentsModel.path
            };
          });
        } else {
          return this._defaultDrive.newUntitled(options);
        }
      }
      /**
       * Delete a file.
       *
       * @param path - The path to the file.
       *
       * @returns A promise which resolves when the file is deleted.
       */
      delete(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.delete(localPath);
      }
      /**
       * Rename a file or directory.
       *
       * @param path - The original file path.
       *
       * @param newPath - The new file path.
       *
       * @returns A promise which resolves with the new file contents model when
       *   the file is renamed.
       */
      rename(path2, newPath) {
        const [drive1, path1] = this._driveForPath(path2);
        const [drive2, path22] = this._driveForPath(newPath);
        if (drive1 !== drive2) {
          throw Error("ContentsManager: renaming files must occur within a Drive");
        }
        return drive1.rename(path1, path22).then((contentsModel) => {
          return {
            ...contentsModel,
            path: this._toGlobalPath(drive1, path22),
            serverPath: contentsModel.path
          };
        });
      }
      /**
       * Save a file.
       *
       * @param path - The desired file path.
       *
       * @param options - Optional overrides to the model.
       *
       * @returns A promise which resolves with the file content model when the
       *   file is saved.
       *
       * #### Notes
       * Ensure that `model.content` is populated for the file.
       */
      save(path2, options = {}) {
        const globalPath = this.normalize(path2);
        const [drive, localPath] = this._driveForPath(path2);
        return drive.save(localPath, { ...options, path: localPath }).then((contentsModel) => {
          return {
            ...contentsModel,
            path: globalPath,
            serverPath: contentsModel.path
          };
        });
      }
      /**
       * Copy a file into a given directory.
       *
       * @param path - The original file path.
       *
       * @param toDir - The destination directory path.
       *
       * @returns A promise which resolves with the new contents model when the
       *  file is copied.
       *
       * #### Notes
       * The server will select the name of the copied file.
       */
      copy(fromFile, toDir) {
        const [drive1, path1] = this._driveForPath(fromFile);
        const [drive2, path2] = this._driveForPath(toDir);
        if (drive1 === drive2) {
          return drive1.copy(path1, path2).then((contentsModel) => {
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive1, contentsModel.path),
              serverPath: contentsModel.path
            };
          });
        } else {
          throw Error("Copying files between drives is not currently implemented");
        }
      }
      /**
       * Create a checkpoint for a file.
       *
       * @param path - The path of the file.
       *
       * @returns A promise which resolves with the new checkpoint model when the
       *   checkpoint is created.
       */
      createCheckpoint(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.createCheckpoint(localPath);
      }
      /**
       * List available checkpoints for a file.
       *
       * @param path - The path of the file.
       *
       * @returns A promise which resolves with a list of checkpoint models for
       *    the file.
       */
      listCheckpoints(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.listCheckpoints(localPath);
      }
      /**
       * Restore a file to a known checkpoint state.
       *
       * @param path - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to restore.
       *
       * @returns A promise which resolves when the checkpoint is restored.
       */
      restoreCheckpoint(path2, checkpointID) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.restoreCheckpoint(localPath, checkpointID);
      }
      /**
       * Delete a checkpoint for a file.
       *
       * @param path - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to delete.
       *
       * @returns A promise which resolves when the checkpoint is deleted.
       */
      deleteCheckpoint(path2, checkpointID) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.deleteCheckpoint(localPath, checkpointID);
      }
      /**
       * Given a drive and a local path, construct a fully qualified
       * path. The inverse of `_driveForPath`.
       *
       * @param drive: an `IDrive`.
       *
       * @param localPath: the local path on the drive.
       *
       * @returns the fully qualified path.
       */
      _toGlobalPath(drive, localPath) {
        if (drive === this._defaultDrive) {
          return coreutils_12.PathExt.removeSlash(localPath);
        } else {
          return `${drive.name}:${coreutils_12.PathExt.removeSlash(localPath)}`;
        }
      }
      /**
       * Given a path, get the `IDrive to which it refers,
       * where the path satisfies the pattern
       * `'driveName:path/to/file'`. If there is no `driveName`
       * prepended to the path, it returns the default drive.
       *
       * @param path: a path to a file.
       *
       * @returns A tuple containing an `IDrive` object for the path,
       * and a local path for that drive.
       */
      _driveForPath(path2) {
        const driveName = this.driveName(path2);
        const localPath = this.localPath(path2);
        if (driveName) {
          return [this._additionalDrives.get(driveName), localPath];
        } else {
          return [this._defaultDrive, localPath];
        }
      }
      /**
       * Respond to fileChanged signals from the drives attached to
       * the manager. This prepends the drive name to the path if necessary,
       * and then forwards the signal.
       */
      _onFileChanged(sender, args) {
        var _a, _b;
        if (sender === this._defaultDrive) {
          this._fileChanged.emit(args);
        } else {
          let newValue = null;
          let oldValue = null;
          if ((_a = args.newValue) === null || _a === void 0 ? void 0 : _a.path) {
            newValue = {
              ...args.newValue,
              path: this._toGlobalPath(sender, args.newValue.path)
            };
          }
          if ((_b = args.oldValue) === null || _b === void 0 ? void 0 : _b.path) {
            oldValue = {
              ...args.oldValue,
              path: this._toGlobalPath(sender, args.oldValue.path)
            };
          }
          this._fileChanged.emit({
            type: args.type,
            newValue,
            oldValue
          });
        }
      }
    };
    exports2.ContentsManager = ContentsManager;
    var Drive = class {
      /**
       * Construct a new contents manager object.
       *
       * @param options - The options used to initialize the object.
       */
      constructor(options = {}) {
        var _a, _b, _c;
        this._isDisposed = false;
        this._fileChanged = new signaling_1.Signal(this);
        this.name = (_a = options.name) !== null && _a !== void 0 ? _a : "Default";
        this._apiEndpoint = (_b = options.apiEndpoint) !== null && _b !== void 0 ? _b : SERVICE_DRIVE_URL;
        this.serverSettings = (_c = options.serverSettings) !== null && _c !== void 0 ? _c : __1.ServerConnection.makeSettings();
      }
      /**
       * A signal emitted when a file operation takes place.
       */
      get fileChanged() {
        return this._fileChanged;
      }
      /**
       * Test whether the manager has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * Get a file or directory.
       *
       * @param localPath: The path to the file.
       *
       * @param options: The options used to fetch the file.
       *
       * @returns A promise which resolves with the file content.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async get(localPath, options) {
        let url = this._getUrl(localPath);
        if (options) {
          if (options.type === "notebook") {
            delete options["format"];
          }
          const content = options.content ? "1" : "0";
          const hash = options.hash ? "1" : "0";
          const params = { ...options, content, hash };
          url += coreutils_12.URLExt.objectToQueryString(params);
        }
        const settings = this.serverSettings;
        const response = await __1.ServerConnection.makeRequest(url, {}, settings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        return data;
      }
      /**
       * Get an encoded download url given a file path.
       *
       * @param localPath - An absolute POSIX file path on the server.
       *
       * #### Notes
       * It is expected that the path contains no relative paths.
       *
       * The returned URL may include a query parameter.
       */
      getDownloadUrl(localPath) {
        const baseUrl = this.serverSettings.baseUrl;
        let url = coreutils_12.URLExt.join(baseUrl, FILES_URL, coreutils_12.URLExt.encodeParts(localPath));
        let cookie = "";
        try {
          cookie = document.cookie;
        } catch (e4) {
        }
        const xsrfTokenMatch = cookie.match("\\b_xsrf=([^;]*)\\b");
        if (xsrfTokenMatch) {
          const fullUrl = new URL(url);
          fullUrl.searchParams.append("_xsrf", xsrfTokenMatch[1]);
          url = fullUrl.toString();
        }
        return Promise.resolve(url);
      }
      /**
       * Create a new untitled file or directory in the specified directory path.
       *
       * @param options: The options used to create the file.
       *
       * @returns A promise which resolves with the created file content when the
       *    file is created.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async newUntitled(options = {}) {
        var _a;
        let body = "{}";
        if (options) {
          if (options.ext) {
            options.ext = Private19.normalizeExtension(options.ext);
          }
          body = JSON.stringify(options);
        }
        const settings = this.serverSettings;
        const url = this._getUrl((_a = options.path) !== null && _a !== void 0 ? _a : "");
        const init = {
          method: "POST",
          body
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "new",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Delete a file.
       *
       * @param localPath - The path to the file.
       *
       * @returns A promise which resolves when the file is deleted.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async delete(localPath) {
        const url = this._getUrl(localPath);
        const settings = this.serverSettings;
        const init = { method: "DELETE" };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._fileChanged.emit({
          type: "delete",
          oldValue: { path: localPath },
          newValue: null
        });
      }
      /**
       * Rename a file or directory.
       *
       * @param oldLocalPath - The original file path.
       *
       * @param newLocalPath - The new file path.
       *
       * @returns A promise which resolves with the new file contents model when
       *   the file is renamed.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async rename(oldLocalPath, newLocalPath) {
        const settings = this.serverSettings;
        const url = this._getUrl(oldLocalPath);
        const init = {
          method: "PATCH",
          body: JSON.stringify({ path: newLocalPath })
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "rename",
          oldValue: { path: oldLocalPath },
          newValue: data
        });
        return data;
      }
      /**
       * Save a file.
       *
       * @param localPath - The desired file path.
       *
       * @param options - Optional overrides to the model.
       *
       * @returns A promise which resolves with the file content model when the
       *   file is saved.
       *
       * #### Notes
       * Ensure that `model.content` is populated for the file.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async save(localPath, options = {}) {
        const settings = this.serverSettings;
        const url = this._getUrl(localPath);
        const init = {
          method: "PUT",
          body: JSON.stringify(options)
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 200 && response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "save",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Copy a file into a given directory.
       *
       * @param localPath - The original file path.
       *
       * @param toDir - The destination directory path.
       *
       * @returns A promise which resolves with the new contents model when the
       *  file is copied.
       *
       * #### Notes
       * The server will select the name of the copied file.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async copy(fromFile, toDir) {
        const settings = this.serverSettings;
        const url = this._getUrl(toDir);
        const init = {
          method: "POST",
          body: JSON.stringify({ copy_from: fromFile })
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "new",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Create a checkpoint for a file.
       *
       * @param localPath - The path of the file.
       *
       * @returns A promise which resolves with the new checkpoint model when the
       *   checkpoint is created.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async createCheckpoint(localPath) {
        const url = this._getUrl(localPath, "checkpoints");
        const init = { method: "POST" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateCheckpointModel(data);
        return data;
      }
      /**
       * List available checkpoints for a file.
       *
       * @param localPath - The path of the file.
       *
       * @returns A promise which resolves with a list of checkpoint models for
       *    the file.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async listCheckpoints(localPath) {
        const url = this._getUrl(localPath, "checkpoints");
        const response = await __1.ServerConnection.makeRequest(url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        if (!Array.isArray(data)) {
          throw new Error("Invalid Checkpoint list");
        }
        for (let i5 = 0; i5 < data.length; i5++) {
          validate.validateCheckpointModel(data[i5]);
        }
        return data;
      }
      /**
       * Restore a file to a known checkpoint state.
       *
       * @param localPath - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to restore.
       *
       * @returns A promise which resolves when the checkpoint is restored.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async restoreCheckpoint(localPath, checkpointID) {
        const url = this._getUrl(localPath, "checkpoints", checkpointID);
        const init = { method: "POST" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Delete a checkpoint for a file.
       *
       * @param localPath - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to delete.
       *
       * @returns A promise which resolves when the checkpoint is deleted.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async deleteCheckpoint(localPath, checkpointID) {
        const url = this._getUrl(localPath, "checkpoints", checkpointID);
        const init = { method: "DELETE" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Get a REST url for a file given a path.
       */
      _getUrl(...args) {
        const parts = args.map((path2) => coreutils_12.URLExt.encodeParts(path2));
        const baseUrl = this.serverSettings.baseUrl;
        return coreutils_12.URLExt.join(baseUrl, this._apiEndpoint, ...parts);
      }
    };
    exports2.Drive = Drive;
    var Private19;
    (function(Private20) {
      function normalizeExtension(extension2) {
        if (extension2.length > 0 && extension2.indexOf(".") !== 0) {
          extension2 = `.${extension2}`;
        }
        return extension2;
      }
      Private20.normalizeExtension = normalizeExtension;
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/event/index.js
var require_event2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/event/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventManager = void 0;
    var coreutils_12 = require_lib6();
    var polling_1 = (init_index_es62(), __toCommonJS(index_es6_exports2));
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var serverconnection_1 = require_serverconnection2();
    var SERVICE_EVENTS_URL = "api/events";
    var EventManager = class {
      /**
       * Create a new event manager.
       */
      constructor(options = {}) {
        var _a;
        this._socket = null;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        this._poll = new polling_1.Poll({ factory: () => this._subscribe() });
        this._stream = new signaling_1.Stream(this);
        void this._poll.start();
      }
      /**
       * Whether the event manager is disposed.
       */
      get isDisposed() {
        return this._poll.isDisposed;
      }
      /**
       * An event stream that emits and yields each new event.
       */
      get stream() {
        return this._stream;
      }
      /**
       * Dispose the event manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._poll.dispose();
        const socket = this._socket;
        if (socket) {
          this._socket = null;
          socket.onopen = () => void 0;
          socket.onerror = () => void 0;
          socket.onmessage = () => void 0;
          socket.onclose = () => void 0;
          socket.close();
        }
        signaling_1.Signal.clearData(this);
        this._stream.stop();
      }
      /**
       * Post an event request to be emitted by the event bus.
       */
      async emit(event) {
        const { serverSettings } = this;
        const { baseUrl, token } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const url = coreutils_12.URLExt.join(baseUrl, SERVICE_EVENTS_URL) + (token ? `?token=${token}` : "");
        const init = { body: JSON.stringify(event), method: "POST" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          throw new ResponseError(response);
        }
      }
      /**
       * Subscribe to event bus emissions.
       */
      _subscribe() {
        return new Promise((_5, reject4) => {
          if (this.isDisposed) {
            return;
          }
          const { token, WebSocket: WebSocket2, wsUrl } = this.serverSettings;
          const url = coreutils_12.URLExt.join(wsUrl, SERVICE_EVENTS_URL, "subscribe") + (token ? `?token=${encodeURIComponent(token)}` : "");
          const socket = this._socket = new WebSocket2(url);
          const stream = this._stream;
          socket.onclose = () => reject4(new Error("EventManager socket closed"));
          socket.onmessage = (msg) => msg.data && stream.emit(JSON.parse(msg.data));
        });
      }
    };
    exports2.EventManager = EventManager;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/kernel.js
var require_kernel3 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/kernel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/validate.js
var require_validate8 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateModels = exports2.validateModel = exports2.validateMessage = void 0;
    var validate_1 = require_validate6();
    var HEADER_FIELDS = ["username", "version", "session", "msg_id", "msg_type"];
    var IOPUB_CONTENT_FIELDS = {
      stream: { name: "string", text: "string" },
      display_data: { data: "object", metadata: "object" },
      execute_input: { code: "string", execution_count: "number" },
      execute_result: {
        execution_count: "number",
        data: "object",
        metadata: "object"
      },
      error: { ename: "string", evalue: "string", traceback: "object" },
      status: {
        execution_state: [
          "string",
          ["starting", "idle", "busy", "restarting", "dead"]
        ]
      },
      clear_output: { wait: "boolean" },
      comm_open: { comm_id: "string", target_name: "string", data: "object" },
      comm_msg: { comm_id: "string", data: "object" },
      comm_close: { comm_id: "string" },
      shutdown_reply: { restart: "boolean" }
      // Emitted by the IPython kernel.
    };
    function validateHeader(header) {
      for (let i5 = 0; i5 < HEADER_FIELDS.length; i5++) {
        (0, validate_1.validateProperty)(header, HEADER_FIELDS[i5], "string");
      }
    }
    function validateMessage(msg) {
      (0, validate_1.validateProperty)(msg, "metadata", "object");
      (0, validate_1.validateProperty)(msg, "content", "object");
      (0, validate_1.validateProperty)(msg, "channel", "string");
      validateHeader(msg.header);
      if (msg.channel === "iopub") {
        validateIOPubContent(msg);
      }
    }
    exports2.validateMessage = validateMessage;
    function validateIOPubContent(msg) {
      if (msg.channel === "iopub") {
        const fields = IOPUB_CONTENT_FIELDS[msg.header.msg_type];
        if (fields === void 0) {
          return;
        }
        const names = Object.keys(fields);
        const content = msg.content;
        for (let i5 = 0; i5 < names.length; i5++) {
          let args = fields[names[i5]];
          if (!Array.isArray(args)) {
            args = [args];
          }
          (0, validate_1.validateProperty)(content, names[i5], ...args);
        }
      }
    }
    function validateModel(model) {
      (0, validate_1.validateProperty)(model, "name", "string");
      (0, validate_1.validateProperty)(model, "id", "string");
    }
    exports2.validateModel = validateModel;
    function validateModels(models) {
      if (!Array.isArray(models)) {
        throw new Error("Invalid kernel list");
      }
      models.forEach((d6) => validateModel(d6));
    }
    exports2.validateModels = validateModels;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/restapi.js
var require_restapi5 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKernelModel = exports2.shutdownKernel = exports2.interruptKernel = exports2.restartKernel = exports2.startNew = exports2.listRunning = exports2.KERNEL_SERVICE_URL = void 0;
    var serverconnection_1 = require_serverconnection2();
    var coreutils_12 = require_lib6();
    var validate_1 = require_validate8();
    exports2.KERNEL_SERVICE_URL = "api/kernels";
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModels)(data);
      return data;
    }
    exports2.listRunning = listRunning;
    async function startNew(options = {}, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify(options)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 201) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.startNew = startNew;
    async function restartKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id), "restart");
      const init = { method: "POST" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
    }
    exports2.restartKernel = restartKernel;
    async function interruptKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id), "interrupt");
      const init = { method: "POST" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.interruptKernel = interruptKernel;
    async function shutdownKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id));
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const msg = `The kernel "${id}" does not exist on the server`;
        console.warn(msg);
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownKernel = shutdownKernel;
    async function getKernelModel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id));
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status === 404) {
        return void 0;
      } else if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.getKernelModel = getKernelModel;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/comm.js
var require_comm2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/comm.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommHandler = void 0;
    var disposable_1 = (init_index_es63(), __toCommonJS(index_es6_exports3));
    var KernelMessage2 = __importStar(require_messages2());
    var CommHandler = class extends disposable_1.DisposableDelegate {
      /**
       * Construct a new comm channel.
       */
      constructor(target, id, kernel, disposeCb) {
        super(disposeCb);
        this._target = "";
        this._id = "";
        this._id = id;
        this._target = target;
        this._kernel = kernel;
      }
      /**
       * The unique id for the comm channel.
       */
      get commId() {
        return this._id;
      }
      /**
       * The target name for the comm channel.
       */
      get targetName() {
        return this._target;
      }
      /**
       * Get the callback for a comm close event.
       *
       * #### Notes
       * This is called when the comm is closed from either the server or client.
       *
       * **See also:** [[ICommClose]], [[close]]
       */
      get onClose() {
        return this._onClose;
      }
      /**
       * Set the callback for a comm close event.
       *
       * #### Notes
       * This is called when the comm is closed from either the server or client. If
       * the function returns a promise, and the kernel was closed from the server,
       * kernel message processing will pause until the returned promise is
       * fulfilled.
       *
       * **See also:** [[close]]
       */
      set onClose(cb2) {
        this._onClose = cb2;
      }
      /**
       * Get the callback for a comm message received event.
       */
      get onMsg() {
        return this._onMsg;
      }
      /**
       * Set the callback for a comm message received event.
       *
       * #### Notes
       * This is called when a comm message is received. If the function returns a
       * promise, kernel message processing will pause until it is fulfilled.
       */
      set onMsg(cb2) {
        this._onMsg = cb2;
      }
      /**
       * Open a comm with optional data and metadata.
       *
       * #### Notes
       * This sends a `comm_open` message to the server.
       *
       * **See also:** [[ICommOpen]]
       */
      open(data, metadata, buffers = []) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot open");
        }
        const msg = KernelMessage2.createMessage({
          msgType: "comm_open",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            target_name: this._target,
            data: data !== null && data !== void 0 ? data : {}
          },
          metadata,
          buffers
        });
        return this._kernel.sendShellMessage(msg, false, true);
      }
      /**
       * Send a `comm_msg` message to the kernel.
       *
       * #### Notes
       * This is a no-op if the comm has been closed.
       *
       * **See also:** [[ICommMsg]]
       */
      send(data, metadata, buffers = [], disposeOnDone = true) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot send");
        }
        const msg = KernelMessage2.createMessage({
          msgType: "comm_msg",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            data
          },
          metadata,
          buffers
        });
        return this._kernel.sendShellMessage(msg, false, disposeOnDone);
      }
      /**
       * Close the comm.
       *
       * #### Notes
       * This will send a `comm_close` message to the kernel, and call the
       * `onClose` callback if set.
       *
       * This is a no-op if the comm is already closed.
       *
       * **See also:** [[ICommClose]], [[onClose]]
       */
      close(data, metadata, buffers = []) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot close");
        }
        const msg = KernelMessage2.createMessage({
          msgType: "comm_close",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            data: data !== null && data !== void 0 ? data : {}
          },
          metadata,
          buffers
        });
        const future = this._kernel.sendShellMessage(msg, false, true);
        const onClose = this._onClose;
        if (onClose) {
          const ioMsg = KernelMessage2.createMessage({
            msgType: "comm_close",
            channel: "iopub",
            username: this._kernel.username,
            session: this._kernel.clientId,
            content: {
              comm_id: this._id,
              data: data !== null && data !== void 0 ? data : {}
            },
            metadata,
            buffers
          });
          void onClose(ioMsg);
        }
        this.dispose();
        return future;
      }
    };
    exports2.CommHandler = CommHandler;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/future.js
var require_future2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/future.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelShellFutureHandler = exports2.KernelControlFutureHandler = exports2.KernelFutureHandler = void 0;
    var coreutils_12 = require_dist();
    var disposable_1 = (init_index_es63(), __toCommonJS(index_es6_exports3));
    var KernelMessage2 = __importStar(require_messages2());
    var KernelFutureHandler = class extends disposable_1.DisposableDelegate {
      /**
       * Construct a new KernelFutureHandler.
       */
      constructor(cb2, msg, expectReply, disposeOnDone, kernel) {
        super(cb2);
        this._status = 0;
        this._stdin = Private19.noOp;
        this._iopub = Private19.noOp;
        this._reply = Private19.noOp;
        this._done = new coreutils_12.PromiseDelegate();
        this._hooks = new Private19.HookList();
        this._disposeOnDone = true;
        this._msg = msg;
        if (!expectReply) {
          this._setFlag(Private19.KernelFutureFlag.GotReply);
        }
        this._disposeOnDone = disposeOnDone;
        this._kernel = kernel;
      }
      /**
       * Get the original outgoing message.
       */
      get msg() {
        return this._msg;
      }
      /**
       * A promise that resolves when the future is done.
       */
      get done() {
        return this._done.promise;
      }
      /**
       * Get the reply handler.
       */
      get onReply() {
        return this._reply;
      }
      /**
       * Set the reply handler.
       */
      set onReply(cb2) {
        this._reply = cb2;
      }
      /**
       * Get the iopub handler.
       */
      get onIOPub() {
        return this._iopub;
      }
      /**
       * Set the iopub handler.
       */
      set onIOPub(cb2) {
        this._iopub = cb2;
      }
      /**
       * Get the stdin handler.
       */
      get onStdin() {
        return this._stdin;
      }
      /**
       * Set the stdin handler.
       */
      set onStdin(cb2) {
        this._stdin = cb2;
      }
      /**
       * Register hook for IOPub messages.
       *
       * @param hook - The callback invoked for an IOPub message.
       *
       * #### Notes
       * The IOPub hook system allows you to preempt the handlers for IOPub
       * messages handled by the future.
       *
       * The most recently registered hook is run first. A hook can return a
       * boolean or a promise to a boolean, in which case all kernel message
       * processing pauses until the promise is fulfilled. If a hook return value
       * resolves to false, any later hooks will not run and the function will
       * return a promise resolving to false. If a hook throws an error, the error
       * is logged to the console and the next hook is run. If a hook is
       * registered during the hook processing, it will not run until the next
       * message. If a hook is removed during the hook processing, it will be
       * deactivated immediately.
       */
      registerMessageHook(hook) {
        if (this.isDisposed) {
          throw new Error("Kernel future is disposed");
        }
        this._hooks.add(hook);
      }
      /**
       * Remove a hook for IOPub messages.
       *
       * @param hook - The hook to remove.
       *
       * #### Notes
       * If a hook is removed during the hook processing, it will be deactivated immediately.
       */
      removeMessageHook(hook) {
        if (this.isDisposed) {
          return;
        }
        this._hooks.remove(hook);
      }
      /**
       * Send an `input_reply` message.
       */
      sendInputReply(content, parent_header) {
        this._kernel.sendInputReply(content, parent_header);
      }
      /**
       * Dispose and unregister the future.
       */
      dispose() {
        this._stdin = Private19.noOp;
        this._iopub = Private19.noOp;
        this._reply = Private19.noOp;
        this._hooks = null;
        if (!this._testFlag(Private19.KernelFutureFlag.IsDone)) {
          this._done.promise.catch(() => {
          });
          this._done.reject(new Error(`Canceled future for ${this.msg.header.msg_type} message before replies were done`));
        }
        super.dispose();
      }
      /**
       * Handle an incoming kernel message.
       */
      async handleMsg(msg) {
        switch (msg.channel) {
          case "control":
          case "shell":
            if (msg.channel === this.msg.channel && msg.parent_header.msg_id === this.msg.header.msg_id) {
              await this._handleReply(msg);
            }
            break;
          case "stdin":
            await this._handleStdin(msg);
            break;
          case "iopub":
            await this._handleIOPub(msg);
            break;
          default:
            break;
        }
      }
      async _handleReply(msg) {
        const reply = this._reply;
        if (reply) {
          await reply(msg);
        }
        this._replyMsg = msg;
        this._setFlag(Private19.KernelFutureFlag.GotReply);
        if (this._testFlag(Private19.KernelFutureFlag.GotIdle)) {
          this._handleDone();
        }
      }
      async _handleStdin(msg) {
        this._kernel.hasPendingInput = true;
        const stdin = this._stdin;
        if (stdin) {
          await stdin(msg);
        }
      }
      async _handleIOPub(msg) {
        const process2 = await this._hooks.process(msg);
        const iopub = this._iopub;
        if (process2 && iopub) {
          await iopub(msg);
        }
        if (KernelMessage2.isStatusMsg(msg) && msg.content.execution_state === "idle") {
          this._setFlag(Private19.KernelFutureFlag.GotIdle);
          if (this._testFlag(Private19.KernelFutureFlag.GotReply)) {
            this._handleDone();
          }
        }
      }
      _handleDone() {
        if (this._testFlag(Private19.KernelFutureFlag.IsDone)) {
          return;
        }
        this._setFlag(Private19.KernelFutureFlag.IsDone);
        this._done.resolve(this._replyMsg);
        if (this._disposeOnDone) {
          this.dispose();
        }
      }
      /**
       * Test whether the given future flag is set.
       */
      _testFlag(flag) {
        return (this._status & flag) !== 0;
      }
      /**
       * Set the given future flag.
       */
      _setFlag(flag) {
        this._status |= flag;
      }
    };
    exports2.KernelFutureHandler = KernelFutureHandler;
    var KernelControlFutureHandler = class extends KernelFutureHandler {
    };
    exports2.KernelControlFutureHandler = KernelControlFutureHandler;
    var KernelShellFutureHandler = class extends KernelFutureHandler {
    };
    exports2.KernelShellFutureHandler = KernelShellFutureHandler;
    var Private19;
    (function(Private20) {
      Private20.noOp = () => {
      };
      const defer = (() => {
        const ok2 = typeof requestAnimationFrame === "function";
        return ok2 ? requestAnimationFrame : setImmediate;
      })();
      class HookList {
        constructor() {
          this._hooks = [];
        }
        /**
         * Register a hook.
         *
         * @param hook - The callback to register.
         */
        add(hook) {
          this.remove(hook);
          this._hooks.push(hook);
        }
        /**
         * Remove a hook, if it exists in the hook list.
         *
         * @param hook - The callback to remove.
         */
        remove(hook) {
          const index2 = this._hooks.indexOf(hook);
          if (index2 >= 0) {
            this._hooks[index2] = null;
            this._scheduleCompact();
          }
        }
        /**
         * Process a message through the hooks.
         *
         * @returns a promise resolving to false if any hook resolved as false,
         * otherwise true
         *
         * #### Notes
         * The most recently registered hook is run first. A hook can return a
         * boolean or a promise to a boolean, in which case processing pauses until
         * the promise is fulfilled. If a hook return value resolves to false, any
         * later hooks will not run and the function will return a promise resolving
         * to false. If a hook throws an error, the error is logged to the console
         * and the next hook is run. If a hook is registered during the hook
         * processing, it will not run until the next message. If a hook is removed
         * during the hook processing, it will be deactivated immediately.
         */
        async process(msg) {
          await this._processing;
          const processing = new coreutils_12.PromiseDelegate();
          this._processing = processing.promise;
          let continueHandling;
          for (let i5 = this._hooks.length - 1; i5 >= 0; i5--) {
            const hook = this._hooks[i5];
            if (hook === null) {
              continue;
            }
            try {
              continueHandling = await hook(msg);
            } catch (err) {
              continueHandling = true;
              console.error(err);
            }
            if (continueHandling === false) {
              processing.resolve(void 0);
              return false;
            }
          }
          processing.resolve(void 0);
          return true;
        }
        /**
         * Schedule a cleanup of the list, removing any hooks that have been nulled out.
         */
        _scheduleCompact() {
          if (!this._compactScheduled) {
            this._compactScheduled = true;
            defer(() => {
              this._processing = this._processing.then(() => {
                this._compactScheduled = false;
                this._compact();
              });
            });
          }
        }
        /**
         * Compact the list, removing any nulls.
         */
        _compact() {
          let numNulls = 0;
          for (let i5 = 0, len = this._hooks.length; i5 < len; i5++) {
            const hook = this._hooks[i5];
            if (this._hooks[i5] === null) {
              numNulls++;
            } else {
              this._hooks[i5 - numNulls] = hook;
            }
          }
          this._hooks.length -= numNulls;
        }
      }
      Private20.HookList = HookList;
      let KernelFutureFlag;
      (function(KernelFutureFlag2) {
        KernelFutureFlag2[KernelFutureFlag2["GotReply"] = 1] = "GotReply";
        KernelFutureFlag2[KernelFutureFlag2["GotIdle"] = 2] = "GotIdle";
        KernelFutureFlag2[KernelFutureFlag2["IsDone"] = 4] = "IsDone";
        KernelFutureFlag2[KernelFutureFlag2["DisposeOnDone"] = 8] = "DisposeOnDone";
      })(KernelFutureFlag = Private20.KernelFutureFlag || (Private20.KernelFutureFlag = {}));
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernelspec/kernelspec.js
var require_kernelspec3 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernelspec/kernelspec.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernelspec/validate.js
var require_validate9 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernelspec/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSpecModels = exports2.validateSpecModel = void 0;
    var validate_1 = require_validate6();
    function validateSpecModel(data) {
      const spec = data.spec;
      if (!spec) {
        throw new Error("Invalid kernel spec");
      }
      (0, validate_1.validateProperty)(data, "name", "string");
      (0, validate_1.validateProperty)(data, "resources", "object");
      (0, validate_1.validateProperty)(spec, "language", "string");
      (0, validate_1.validateProperty)(spec, "display_name", "string");
      (0, validate_1.validateProperty)(spec, "argv", "array");
      let metadata = null;
      if (spec.hasOwnProperty("metadata")) {
        (0, validate_1.validateProperty)(spec, "metadata", "object");
        metadata = spec.metadata;
      }
      let env = null;
      if (spec.hasOwnProperty("env")) {
        (0, validate_1.validateProperty)(spec, "env", "object");
        env = spec.env;
      }
      return {
        name: data.name,
        resources: data.resources,
        language: spec.language,
        display_name: spec.display_name,
        argv: spec.argv,
        metadata,
        env
      };
    }
    exports2.validateSpecModel = validateSpecModel;
    function validateSpecModels(data) {
      if (!data.hasOwnProperty("kernelspecs")) {
        throw new Error("No kernelspecs found");
      }
      let keys2 = Object.keys(data.kernelspecs);
      const kernelspecs = /* @__PURE__ */ Object.create(null);
      let defaultSpec = data.default;
      for (let i5 = 0; i5 < keys2.length; i5++) {
        const ks = data.kernelspecs[keys2[i5]];
        try {
          kernelspecs[keys2[i5]] = validateSpecModel(ks);
        } catch (err) {
          console.warn(`Removing errant kernel spec: ${keys2[i5]}`);
        }
      }
      keys2 = Object.keys(kernelspecs);
      if (!keys2.length) {
        throw new Error("No valid kernelspecs found");
      }
      if (!defaultSpec || typeof defaultSpec !== "string" || !(defaultSpec in kernelspecs)) {
        defaultSpec = keys2[0];
        console.warn(`Default kernel not found, using '${keys2[0]}'`);
      }
      return {
        default: defaultSpec,
        kernelspecs
      };
    }
    exports2.validateSpecModels = validateSpecModels;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernelspec/restapi.js
var require_restapi6 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernelspec/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSpecs = void 0;
    var serverconnection_1 = require_serverconnection2();
    var validate_1 = require_validate9();
    var coreutils_12 = require_lib6();
    var KERNELSPEC_SERVICE_URL = "api/kernelspecs";
    async function getSpecs(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, KERNELSPEC_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      return (0, validate_1.validateSpecModels)(data);
    }
    exports2.getSpecs = getSpecs;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernelspec/manager.js
var require_manager6 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernelspec/manager.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelSpecManager = void 0;
    var coreutils_12 = require_dist();
    var polling_1 = (init_index_es62(), __toCommonJS(index_es6_exports2));
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var restapi = __importStar(require_restapi6());
    var basemanager_1 = require_basemanager2();
    var KernelSpecManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new kernel spec manager.
       *
       * @param options - The default options for kernel.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._connectionFailure = new signaling_1.Signal(this);
        this._specs = null;
        this._specsChanged = new signaling_1.Signal(this);
        this._ready = Promise.all([this.requestSpecs()]).then((_5) => void 0).catch((_5) => void 0).then(() => {
          if (this.isDisposed) {
            return;
          }
          this._isReady = true;
        });
        this._pollSpecs = new polling_1.Poll({
          auto: false,
          factory: () => this.requestSpecs(),
          frequency: {
            interval: 61 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:KernelSpecManager#specs`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        void this.ready.then(() => {
          void this._pollSpecs.start();
        });
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * Get the most recently fetched kernel specs.
       */
      get specs() {
        return this._specs;
      }
      /**
       * A signal emitted when the specs change.
       */
      get specsChanged() {
        return this._specsChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        this._pollSpecs.dispose();
        super.dispose();
      }
      /**
       * Force a refresh of the specs from the server.
       *
       * @returns A promise that resolves when the specs are fetched.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshSpecs() {
        await this._pollSpecs.refresh();
        await this._pollSpecs.tick;
      }
      /**
       * Execute a request to the server to poll specs and update state.
       */
      async requestSpecs() {
        const specs = await restapi.getSpecs(this.serverSettings);
        if (this.isDisposed) {
          return;
        }
        if (!coreutils_12.JSONExt.deepEqual(specs, this._specs)) {
          this._specs = specs;
          this._specsChanged.emit(specs);
        }
      }
    };
    exports2.KernelSpecManager = KernelSpecManager;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernelspec/index.js
var require_kernelspec4 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernelspec/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelSpecAPI = exports2.KernelSpec = void 0;
    var KernelSpec = __importStar(require_kernelspec3());
    exports2.KernelSpec = KernelSpec;
    var KernelSpecAPI2 = __importStar(require_restapi6());
    exports2.KernelSpecAPI = KernelSpecAPI2;
    __exportStar(require_manager6(), exports2);
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/default.js
var require_default4 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/default.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelConnection = void 0;
    var coreutils_12 = require_lib6();
    var coreutils_2 = require_dist();
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var __1 = require_lib8();
    var comm_1 = require_comm2();
    var KernelMessage2 = __importStar(require_messages2());
    var future_1 = require_future2();
    var validate = __importStar(require_validate8());
    var kernelspec_1 = require_kernelspec4();
    var restapi = __importStar(require_restapi5());
    var KERNEL_INFO_TIMEOUT = 3e3;
    var RESTARTING_KERNEL_SESSION = "_RESTARTING_";
    var STARTING_KERNEL_SESSION = "";
    var KernelConnection = class {
      /**
       * Construct a kernel object.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        this._createSocket = (useProtocols = true) => {
          this._errorIfDisposed();
          this._clearSocket();
          this._updateConnectionStatus("connecting");
          const settings = this.serverSettings;
          const partialUrl = coreutils_12.URLExt.join(settings.wsUrl, restapi.KERNEL_SERVICE_URL, encodeURIComponent(this._id));
          const display = partialUrl.replace(/^((?:\w+:)?\/\/)(?:[^@\/]+@)/, "$1");
          console.debug(`Starting WebSocket: ${display}`);
          let url = coreutils_12.URLExt.join(partialUrl, "channels?session_id=" + encodeURIComponent(this._clientId));
          const token = settings.token;
          if (settings.appendToken && token !== "") {
            url = url + `&token=${encodeURIComponent(token)}`;
          }
          const supportedProtocols = useProtocols ? this._supportedProtocols : [];
          this._ws = new settings.WebSocket(url, supportedProtocols);
          this._ws.binaryType = "arraybuffer";
          let alreadyCalledOnclose = false;
          const getKernelModel = async (evt) => {
            var _a2, _b2;
            if (this._isDisposed) {
              return;
            }
            this._reason = "";
            this._model = void 0;
            try {
              const model = await restapi.getKernelModel(this._id, settings);
              this._model = model;
              if ((model === null || model === void 0 ? void 0 : model.execution_state) === "dead") {
                this._updateStatus("dead");
              } else {
                this._onWSClose(evt);
              }
            } catch (err) {
              if (err instanceof __1.ServerConnection.NetworkError || ((_a2 = err.response) === null || _a2 === void 0 ? void 0 : _a2.status) === 503 || ((_b2 = err.response) === null || _b2 === void 0 ? void 0 : _b2.status) === 424) {
                const timeout = Private19.getRandomIntInclusive(10, 30) * 1e3;
                setTimeout(getKernelModel, timeout, evt);
              } else {
                this._reason = "Kernel died unexpectedly";
                this._updateStatus("dead");
              }
            }
            return;
          };
          const earlyClose = async (evt) => {
            if (alreadyCalledOnclose) {
              return;
            }
            alreadyCalledOnclose = true;
            await getKernelModel(evt);
            return;
          };
          this._ws.onmessage = this._onWSMessage;
          this._ws.onopen = this._onWSOpen;
          this._ws.onclose = earlyClose;
          this._ws.onerror = earlyClose;
        };
        this._onWSOpen = (evt) => {
          if (this._ws.protocol !== "" && !this._supportedProtocols.includes(this._ws.protocol)) {
            console.log("Server selected unknown kernel wire protocol:", this._ws.protocol);
            this._updateStatus("dead");
            throw new Error(`Unknown kernel wire protocol:  ${this._ws.protocol}`);
          }
          this._selectedProtocol = this._ws.protocol;
          this._ws.onclose = this._onWSClose;
          this._ws.onerror = this._onWSClose;
          this._updateConnectionStatus("connected");
        };
        this._onWSMessage = (evt) => {
          let msg;
          try {
            msg = this.serverSettings.serializer.deserialize(evt.data, this._ws.protocol);
            validate.validateMessage(msg);
          } catch (error) {
            error.message = `Kernel message validation error: ${error.message}`;
            throw error;
          }
          this._kernelSession = msg.header.session;
          this._msgChain = this._msgChain.then(() => {
            return this._handleMessage(msg);
          }).catch((error) => {
            if (error.message.startsWith("Canceled future for ")) {
              console.error(error);
            }
          });
          this._anyMessage.emit({ msg, direction: "recv" });
        };
        this._onWSClose = (evt) => {
          if (!this.isDisposed) {
            this._reconnect();
          }
        };
        this._id = "";
        this._name = "";
        this._status = "unknown";
        this._connectionStatus = "connecting";
        this._kernelSession = "";
        this._isDisposed = false;
        this._ws = null;
        this._username = "";
        this._reconnectLimit = 7;
        this._reconnectAttempt = 0;
        this._reconnectTimeout = null;
        this._supportedProtocols = Object.values(KernelMessage2.supportedKernelWebSocketProtocols);
        this._selectedProtocol = "";
        this._futures = /* @__PURE__ */ new Map();
        this._comms = /* @__PURE__ */ new Map();
        this._targetRegistry = /* @__PURE__ */ Object.create(null);
        this._info = new coreutils_2.PromiseDelegate();
        this._pendingMessages = [];
        this._statusChanged = new signaling_1.Signal(this);
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._disposed = new signaling_1.Signal(this);
        this._iopubMessage = new signaling_1.Signal(this);
        this._anyMessage = new signaling_1.Signal(this);
        this._pendingInput = new signaling_1.Signal(this);
        this._unhandledMessage = new signaling_1.Signal(this);
        this._displayIdToParentIds = /* @__PURE__ */ new Map();
        this._msgIdToDisplayIds = /* @__PURE__ */ new Map();
        this._msgChain = Promise.resolve();
        this._hasPendingInput = false;
        this._reason = "";
        this._noOp = () => {
        };
        this._name = options.model.name;
        this._id = options.model.id;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._clientId = (_b = options.clientId) !== null && _b !== void 0 ? _b : coreutils_2.UUID.uuid4();
        this._username = (_c = options.username) !== null && _c !== void 0 ? _c : "";
        this.handleComms = (_d = options.handleComms) !== null && _d !== void 0 ? _d : true;
        this._createSocket();
      }
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when the kernel status changes.
       */
      get statusChanged() {
        return this._statusChanged;
      }
      /**
       * A signal emitted when the kernel status changes.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * A signal emitted for iopub kernel messages.
       *
       * #### Notes
       * This signal is emitted after the iopub message is handled asynchronously.
       */
      get iopubMessage() {
        return this._iopubMessage;
      }
      /**
       * A signal emitted for unhandled kernel message.
       *
       * #### Notes
       * This signal is emitted for a message that was not handled. It is emitted
       * during the asynchronous message handling code.
       */
      get unhandledMessage() {
        return this._unhandledMessage;
      }
      /**
       * The kernel model
       */
      get model() {
        return this._model || {
          id: this.id,
          name: this.name,
          reason: this._reason
        };
      }
      /**
       * A signal emitted for any kernel message.
       *
       * #### Notes
       * This signal is emitted when a message is received, before it is handled
       * asynchronously.
       *
       * This message is emitted when a message is queued for sending (either in
       * the websocket buffer, or our own pending message buffer). The message may
       * actually be sent across the wire at a later time.
       *
       * The message emitted in this signal should not be modified in any way.
       */
      get anyMessage() {
        return this._anyMessage;
      }
      /**
       * A signal emitted when a kernel has pending inputs from the user.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * The id of the server-side kernel.
       */
      get id() {
        return this._id;
      }
      /**
       * The name of the server-side kernel.
       */
      get name() {
        return this._name;
      }
      /**
       * The client username.
       */
      get username() {
        return this._username;
      }
      /**
       * The client unique id.
       */
      get clientId() {
        return this._clientId;
      }
      /**
       * The current status of the kernel.
       */
      get status() {
        return this._status;
      }
      /**
       * The current connection status of the kernel connection.
       */
      get connectionStatus() {
        return this._connectionStatus;
      }
      /**
       * Test whether the kernel has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * The cached kernel info.
       *
       * @returns A promise that resolves to the kernel info.
       */
      get info() {
        return this._info.promise;
      }
      /**
       * The kernel spec.
       *
       * @returns A promise that resolves to the kernel spec.
       */
      get spec() {
        if (this._specPromise) {
          return this._specPromise;
        }
        this._specPromise = kernelspec_1.KernelSpecAPI.getSpecs(this.serverSettings).then((specs) => {
          return specs.kernelspecs[this._name];
        });
        return this._specPromise;
      }
      /**
       * Clone the current kernel with a new clientId.
       */
      clone(options = {}) {
        return new KernelConnection({
          model: this.model,
          username: this.username,
          serverSettings: this.serverSettings,
          // handleComms defaults to false since that is safer
          handleComms: false,
          ...options
        });
      }
      /**
       * Dispose of the resources held by the kernel.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        this._updateConnectionStatus("disconnected");
        this._clearKernelState();
        this._pendingMessages = [];
        this._clearSocket();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Send a shell message to the kernel.
       *
       * #### Notes
       * Send a message to the kernel's shell channel, yielding a future object
       * for accepting replies.
       *
       * If `expectReply` is given and `true`, the future is disposed when both a
       * shell reply and an idle status message are received. If `expectReply`
       * is not given or is `false`, the future is resolved when an idle status
       * message is received.
       * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.
       * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.
       *
       * All replies are validated as valid kernel messages.
       *
       * If the kernel status is `dead`, this will throw an error.
       */
      sendShellMessage(msg, expectReply = false, disposeOnDone = true) {
        return this._sendKernelShellControl(future_1.KernelShellFutureHandler, msg, expectReply, disposeOnDone);
      }
      /**
       * Send a control message to the kernel.
       *
       * #### Notes
       * Send a message to the kernel's control channel, yielding a future object
       * for accepting replies.
       *
       * If `expectReply` is given and `true`, the future is disposed when both a
       * control reply and an idle status message are received. If `expectReply`
       * is not given or is `false`, the future is resolved when an idle status
       * message is received.
       * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.
       * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.
       *
       * All replies are validated as valid kernel messages.
       *
       * If the kernel status is `dead`, this will throw an error.
       */
      sendControlMessage(msg, expectReply = false, disposeOnDone = true) {
        return this._sendKernelShellControl(future_1.KernelControlFutureHandler, msg, expectReply, disposeOnDone);
      }
      _sendKernelShellControl(ctor2, msg, expectReply = false, disposeOnDone = true) {
        this._sendMessage(msg);
        this._anyMessage.emit({ msg, direction: "send" });
        const future = new ctor2(() => {
          const msgId = msg.header.msg_id;
          this._futures.delete(msgId);
          const displayIds = this._msgIdToDisplayIds.get(msgId);
          if (!displayIds) {
            return;
          }
          displayIds.forEach((displayId) => {
            const msgIds = this._displayIdToParentIds.get(displayId);
            if (msgIds) {
              const idx = msgIds.indexOf(msgId);
              if (idx === -1) {
                return;
              }
              if (msgIds.length === 1) {
                this._displayIdToParentIds.delete(displayId);
              } else {
                msgIds.splice(idx, 1);
                this._displayIdToParentIds.set(displayId, msgIds);
              }
            }
          });
          this._msgIdToDisplayIds.delete(msgId);
        }, msg, expectReply, disposeOnDone, this);
        this._futures.set(msg.header.msg_id, future);
        return future;
      }
      /**
       * Send a message on the websocket.
       *
       * If queue is true, queue the message for later sending if we cannot send
       * now. Otherwise throw an error.
       *
       * #### Notes
       * As an exception to the queueing, if we are sending a kernel_info_request
       * message while we think the kernel is restarting, we send the message
       * immediately without queueing. This is so that we can trigger a message
       * back, which will then clear the kernel restarting state.
       */
      _sendMessage(msg, queue = true) {
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        if ((this._kernelSession === STARTING_KERNEL_SESSION || this._kernelSession === RESTARTING_KERNEL_SESSION) && KernelMessage2.isInfoRequestMsg(msg)) {
          if (this.connectionStatus === "connected") {
            this._ws.send(this.serverSettings.serializer.serialize(msg, this._ws.protocol));
            return;
          } else {
            throw new Error("Could not send message: status is not connected");
          }
        }
        if (queue && this._pendingMessages.length > 0) {
          this._pendingMessages.push(msg);
          return;
        }
        if (this.connectionStatus === "connected" && this._kernelSession !== RESTARTING_KERNEL_SESSION) {
          this._ws.send(this.serverSettings.serializer.serialize(msg, this._ws.protocol));
        } else if (queue) {
          this._pendingMessages.push(msg);
        } else {
          throw new Error("Could not send message");
        }
      }
      /**
       * Interrupt a kernel.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * It is assumed that the API call does not mutate the kernel id or name.
       *
       * The promise will be rejected if the kernel status is `Dead` or if the
       * request fails or the response is invalid.
       */
      async interrupt() {
        this.hasPendingInput = false;
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        return restapi.interruptKernel(this.id, this.serverSettings);
      }
      /**
       * Request a kernel restart.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels)
       * and validates the response model.
       *
       * Any existing Future or Comm objects are cleared once the kernel has
       * actually be restarted.
       *
       * The promise is fulfilled on a valid server response (after the kernel restarts)
       * and rejected otherwise.
       *
       * It is assumed that the API call does not mutate the kernel id or name.
       *
       * The promise will be rejected if the request fails or the response is
       * invalid.
       */
      async restart() {
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        this._updateStatus("restarting");
        this._clearKernelState();
        this._kernelSession = RESTARTING_KERNEL_SESSION;
        await restapi.restartKernel(this.id, this.serverSettings);
        await this.reconnect();
        this.hasPendingInput = false;
      }
      /**
       * Reconnect to a kernel.
       *
       * #### Notes
       * This may try multiple times to reconnect to a kernel, and will sever any
       * existing connection.
       */
      reconnect() {
        this._errorIfDisposed();
        const result2 = new coreutils_2.PromiseDelegate();
        const fulfill = (sender, status) => {
          if (status === "connected") {
            result2.resolve();
            this.connectionStatusChanged.disconnect(fulfill, this);
          } else if (status === "disconnected") {
            result2.reject(new Error("Kernel connection disconnected"));
            this.connectionStatusChanged.disconnect(fulfill, this);
          }
        };
        this.connectionStatusChanged.connect(fulfill, this);
        this._reconnectAttempt = 0;
        this._reconnect();
        return result2.promise;
      }
      /**
       * Shutdown a kernel.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * On a valid response, disposes this kernel connection.
       *
       * If the kernel is already `dead`, disposes this kernel connection without
       * a server request.
       */
      async shutdown() {
        if (this.status !== "dead") {
          await restapi.shutdownKernel(this.id, this.serverSettings);
        }
        this.handleShutdown();
      }
      /**
       * Handles a kernel shutdown.
       *
       * #### Notes
       * This method should be called if we know from outside information that a
       * kernel is dead (for example, we cannot find the kernel model on the
       * server).
       */
      handleShutdown() {
        this._updateStatus("dead");
        this.dispose();
      }
      /**
       * Send a `kernel_info_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#kernel-info).
       *
       * Fulfills with the `kernel_info_response` content when the shell reply is
       * received and validated.
       */
      async requestKernelInfo() {
        const msg = KernelMessage2.createMessage({
          msgType: "kernel_info_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content: {}
        });
        let reply;
        try {
          reply = await Private19.handleShellMessage(this, msg);
        } catch (e4) {
          if (this.isDisposed) {
            return;
          } else {
            throw e4;
          }
        }
        this._errorIfDisposed();
        if (!reply) {
          return;
        }
        if (reply.content.status === void 0) {
          reply.content.status = "ok";
        }
        if (reply.content.status !== "ok") {
          this._info.reject("Kernel info reply errored");
          return reply;
        }
        this._info.resolve(reply.content);
        this._kernelSession = reply.header.session;
        return reply;
      }
      /**
       * Send a `complete_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#completion).
       *
       * Fulfills with the `complete_reply` content when the shell reply is
       * received and validated.
       */
      requestComplete(content) {
        const msg = KernelMessage2.createMessage({
          msgType: "complete_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private19.handleShellMessage(this, msg);
      }
      /**
       * Send an `inspect_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#introspection).
       *
       * Fulfills with the `inspect_reply` content when the shell reply is
       * received and validated.
       */
      requestInspect(content) {
        const msg = KernelMessage2.createMessage({
          msgType: "inspect_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private19.handleShellMessage(this, msg);
      }
      /**
       * Send a `history_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#history).
       *
       * Fulfills with the `history_reply` content when the shell reply is
       * received and validated.
       */
      requestHistory(content) {
        const msg = KernelMessage2.createMessage({
          msgType: "history_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private19.handleShellMessage(this, msg);
      }
      /**
       * Send an `execute_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#execute).
       *
       * Future `onReply` is called with the `execute_reply` content when the
       * shell reply is received and validated. The future will resolve when
       * this message is received and the `idle` iopub status is received.
       * The future will also be disposed at this point unless `disposeOnDone`
       * is specified and `false`, in which case it is up to the caller to dispose
       * of the future.
       *
       * **See also:** [[IExecuteReply]]
       */
      requestExecute(content, disposeOnDone = true, metadata) {
        const defaults = {
          silent: false,
          store_history: true,
          user_expressions: {},
          allow_stdin: true,
          stop_on_error: false
        };
        const msg = KernelMessage2.createMessage({
          msgType: "execute_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content: { ...defaults, ...content },
          metadata
        });
        return this.sendShellMessage(msg, true, disposeOnDone);
      }
      /**
       * Send an experimental `debug_request` message.
       *
       * @hidden
       *
       * #### Notes
       * Debug messages are experimental messages that are not in the official
       * kernel message specification. As such, this function is *NOT* considered
       * part of the public API, and may change without notice.
       */
      requestDebug(content, disposeOnDone = true) {
        const msg = KernelMessage2.createMessage({
          msgType: "debug_request",
          channel: "control",
          username: this._username,
          session: this._clientId,
          content
        });
        return this.sendControlMessage(msg, true, disposeOnDone);
      }
      /**
       * Send an `is_complete_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#code-completeness).
       *
       * Fulfills with the `is_complete_response` content when the shell reply is
       * received and validated.
       */
      requestIsComplete(content) {
        const msg = KernelMessage2.createMessage({
          msgType: "is_complete_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private19.handleShellMessage(this, msg);
      }
      /**
       * Send a `comm_info_request` message.
       *
       * #### Notes
       * Fulfills with the `comm_info_reply` content when the shell reply is
       * received and validated.
       */
      requestCommInfo(content) {
        const msg = KernelMessage2.createMessage({
          msgType: "comm_info_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private19.handleShellMessage(this, msg);
      }
      /**
       * Send an `input_reply` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#messages-on-the-stdin-router-dealer-sockets).
       */
      sendInputReply(content, parent_header) {
        const msg = KernelMessage2.createMessage({
          msgType: "input_reply",
          channel: "stdin",
          username: this._username,
          session: this._clientId,
          content
        });
        msg.parent_header = parent_header;
        this._sendMessage(msg);
        this._anyMessage.emit({ msg, direction: "send" });
        this.hasPendingInput = false;
      }
      /**
       * Create a new comm.
       *
       * #### Notes
       * If a client-side comm already exists with the given commId, an error is thrown.
       * If the kernel does not handle comms, an error is thrown.
       */
      createComm(targetName, commId = coreutils_2.UUID.uuid4()) {
        if (!this.handleComms) {
          throw new Error("Comms are disabled on this kernel connection");
        }
        if (this._comms.has(commId)) {
          throw new Error("Comm is already created");
        }
        const comm = new comm_1.CommHandler(targetName, commId, this, () => {
          this._unregisterComm(commId);
        });
        this._comms.set(commId, comm);
        return comm;
      }
      /**
       * Check if a comm exists.
       */
      hasComm(commId) {
        return this._comms.has(commId);
      }
      /**
       * Register a comm target handler.
       *
       * @param targetName - The name of the comm target.
       *
       * @param callback - The callback invoked for a comm open message.
       *
       * @returns A disposable used to unregister the comm target.
       *
       * #### Notes
       * Only one comm target can be registered to a target name at a time, an
       * existing callback for the same target name will be overridden.  A registered
       * comm target handler will take precedence over a comm which specifies a
       * `target_module`.
       *
       * If the callback returns a promise, kernel message processing will pause
       * until the returned promise is fulfilled.
       */
      registerCommTarget(targetName, callback) {
        if (!this.handleComms) {
          return;
        }
        this._targetRegistry[targetName] = callback;
      }
      /**
       * Remove a comm target handler.
       *
       * @param targetName - The name of the comm target to remove.
       *
       * @param callback - The callback to remove.
       *
       * #### Notes
       * The comm target is only removed if the callback argument matches.
       */
      removeCommTarget(targetName, callback) {
        if (!this.handleComms) {
          return;
        }
        if (!this.isDisposed && this._targetRegistry[targetName] === callback) {
          delete this._targetRegistry[targetName];
        }
      }
      /**
       * Register an IOPub message hook.
       *
       * @param msg_id - The parent_header message id the hook will intercept.
       *
       * @param hook - The callback invoked for the message.
       *
       * #### Notes
       * The IOPub hook system allows you to preempt the handlers for IOPub
       * messages that are responses to a given message id.
       *
       * The most recently registered hook is run first. A hook can return a
       * boolean or a promise to a boolean, in which case all kernel message
       * processing pauses until the promise is fulfilled. If a hook return value
       * resolves to false, any later hooks will not run and the function will
       * return a promise resolving to false. If a hook throws an error, the error
       * is logged to the console and the next hook is run. If a hook is
       * registered during the hook processing, it will not run until the next
       * message. If a hook is removed during the hook processing, it will be
       * deactivated immediately.
       *
       * See also [[IFuture.registerMessageHook]].
       */
      registerMessageHook(msgId, hook) {
        var _a;
        const future = (_a = this._futures) === null || _a === void 0 ? void 0 : _a.get(msgId);
        if (future) {
          future.registerMessageHook(hook);
        }
      }
      /**
       * Remove an IOPub message hook.
       *
       * @param msg_id - The parent_header message id the hook intercepted.
       *
       * @param hook - The callback invoked for the message.
       *
       */
      removeMessageHook(msgId, hook) {
        var _a;
        const future = (_a = this._futures) === null || _a === void 0 ? void 0 : _a.get(msgId);
        if (future) {
          future.removeMessageHook(hook);
        }
      }
      /**
       * Remove the input guard, if any.
       */
      removeInputGuard() {
        this.hasPendingInput = false;
      }
      /**
       * Handle a message with a display id.
       *
       * @returns Whether the message was handled.
       */
      async _handleDisplayId(displayId, msg) {
        var _a, _b;
        const msgId = msg.parent_header.msg_id;
        let parentIds = this._displayIdToParentIds.get(displayId);
        if (parentIds) {
          const updateMsg = {
            header: coreutils_2.JSONExt.deepCopy(msg.header),
            parent_header: coreutils_2.JSONExt.deepCopy(msg.parent_header),
            metadata: coreutils_2.JSONExt.deepCopy(msg.metadata),
            content: coreutils_2.JSONExt.deepCopy(msg.content),
            channel: msg.channel,
            buffers: msg.buffers ? msg.buffers.slice() : []
          };
          updateMsg.header.msg_type = "update_display_data";
          await Promise.all(parentIds.map(async (parentId) => {
            const future = this._futures && this._futures.get(parentId);
            if (future) {
              await future.handleMsg(updateMsg);
            }
          }));
        }
        if (msg.header.msg_type === "update_display_data") {
          return true;
        }
        parentIds = (_a = this._displayIdToParentIds.get(displayId)) !== null && _a !== void 0 ? _a : [];
        if (parentIds.indexOf(msgId) === -1) {
          parentIds.push(msgId);
        }
        this._displayIdToParentIds.set(displayId, parentIds);
        const displayIds = (_b = this._msgIdToDisplayIds.get(msgId)) !== null && _b !== void 0 ? _b : [];
        if (displayIds.indexOf(msgId) === -1) {
          displayIds.push(msgId);
        }
        this._msgIdToDisplayIds.set(msgId, displayIds);
        return false;
      }
      /**
       * Forcefully clear the socket state.
       *
       * #### Notes
       * This will clear all socket state without calling any handlers and will
       * not update the connection status. If you call this method, you are
       * responsible for updating the connection status as needed and recreating
       * the socket if you plan to reconnect.
       */
      _clearSocket() {
        if (this._ws !== null) {
          this._ws.onopen = this._noOp;
          this._ws.onclose = this._noOp;
          this._ws.onerror = this._noOp;
          this._ws.onmessage = this._noOp;
          this._ws.close();
          this._ws = null;
        }
      }
      /**
       * Handle status iopub messages from the kernel.
       */
      _updateStatus(status) {
        if (this._status === status || this._status === "dead") {
          return;
        }
        this._status = status;
        Private19.logKernelStatus(this);
        this._statusChanged.emit(status);
        if (status === "dead") {
          this.dispose();
        }
      }
      /**
       * Send pending messages to the kernel.
       */
      _sendPending() {
        while (this.connectionStatus === "connected" && this._kernelSession !== RESTARTING_KERNEL_SESSION && this._pendingMessages.length > 0) {
          this._sendMessage(this._pendingMessages[0], false);
          this._pendingMessages.shift();
        }
      }
      /**
       * Clear the internal state.
       */
      _clearKernelState() {
        this._kernelSession = "";
        this._pendingMessages = [];
        this._futures.forEach((future) => {
          future.dispose();
        });
        this._comms.forEach((comm) => {
          comm.dispose();
        });
        this._msgChain = Promise.resolve();
        this._futures = /* @__PURE__ */ new Map();
        this._comms = /* @__PURE__ */ new Map();
        this._displayIdToParentIds.clear();
        this._msgIdToDisplayIds.clear();
      }
      /**
       * Check to make sure it is okay to proceed to handle a message.
       *
       * #### Notes
       * Because we handle messages asynchronously, before a message is handled the
       * kernel might be disposed or restarted (and have a different session id).
       * This function throws an error in each of these cases. This is meant to be
       * called at the start of an asynchronous message handler to cancel message
       * processing if the message no longer is valid.
       */
      _assertCurrentMessage(msg) {
        this._errorIfDisposed();
        if (msg.header.session !== this._kernelSession) {
          throw new Error(`Canceling handling of old message: ${msg.header.msg_type}`);
        }
      }
      /**
       * Handle a `comm_open` kernel message.
       */
      async _handleCommOpen(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = new comm_1.CommHandler(content.target_name, content.comm_id, this, () => {
          this._unregisterComm(content.comm_id);
        });
        this._comms.set(content.comm_id, comm);
        try {
          const target = await Private19.loadObject(content.target_name, content.target_module, this._targetRegistry);
          await target(comm, msg);
        } catch (e4) {
          comm.close();
          console.error("Exception opening new comm");
          throw e4;
        }
      }
      /**
       * Handle 'comm_close' kernel message.
       */
      async _handleCommClose(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = this._comms.get(content.comm_id);
        if (!comm) {
          console.error("Comm not found for comm id " + content.comm_id);
          return;
        }
        this._unregisterComm(comm.commId);
        const onClose = comm.onClose;
        if (onClose) {
          await onClose(msg);
        }
        comm.dispose();
      }
      /**
       * Handle a 'comm_msg' kernel message.
       */
      async _handleCommMsg(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = this._comms.get(content.comm_id);
        if (!comm) {
          return;
        }
        const onMsg = comm.onMsg;
        if (onMsg) {
          await onMsg(msg);
        }
      }
      /**
       * Unregister a comm instance.
       */
      _unregisterComm(commId) {
        this._comms.delete(commId);
      }
      /**
       * Handle connection status changes.
       */
      _updateConnectionStatus(connectionStatus) {
        if (this._connectionStatus === connectionStatus) {
          return;
        }
        this._connectionStatus = connectionStatus;
        if (connectionStatus !== "connecting") {
          this._reconnectAttempt = 0;
          clearTimeout(this._reconnectTimeout);
        }
        if (this.status !== "dead") {
          if (connectionStatus === "connected") {
            let restarting = this._kernelSession === RESTARTING_KERNEL_SESSION;
            let p3 = this.requestKernelInfo();
            let sendPendingCalled = false;
            let sendPendingOnce = () => {
              if (sendPendingCalled) {
                return;
              }
              sendPendingCalled = true;
              if (restarting && this._kernelSession === RESTARTING_KERNEL_SESSION) {
                this._kernelSession = "";
              }
              clearTimeout(timeoutHandle);
              if (this._pendingMessages.length > 0) {
                this._sendPending();
              }
            };
            void p3.then(sendPendingOnce);
            let timeoutHandle = setTimeout(sendPendingOnce, KERNEL_INFO_TIMEOUT);
          } else {
            this._updateStatus("unknown");
          }
        }
        this._connectionStatusChanged.emit(connectionStatus);
      }
      async _handleMessage(msg) {
        var _a, _b;
        let handled = false;
        if (msg.parent_header && msg.channel === "iopub" && (KernelMessage2.isDisplayDataMsg(msg) || KernelMessage2.isUpdateDisplayDataMsg(msg) || KernelMessage2.isExecuteResultMsg(msg))) {
          const transient = (_a = msg.content.transient) !== null && _a !== void 0 ? _a : {};
          const displayId = transient["display_id"];
          if (displayId) {
            handled = await this._handleDisplayId(displayId, msg);
            this._assertCurrentMessage(msg);
          }
        }
        if (!handled && msg.parent_header) {
          const parentHeader = msg.parent_header;
          const future = (_b = this._futures) === null || _b === void 0 ? void 0 : _b.get(parentHeader.msg_id);
          if (future) {
            await future.handleMsg(msg);
            this._assertCurrentMessage(msg);
          } else {
            const owned = parentHeader.session === this.clientId;
            if (msg.channel !== "iopub" && owned) {
              this._unhandledMessage.emit(msg);
            }
          }
        }
        if (msg.channel === "iopub") {
          switch (msg.header.msg_type) {
            case "status": {
              const executionState = msg.content.execution_state;
              if (executionState === "restarting") {
                void Promise.resolve().then(async () => {
                  this._updateStatus("autorestarting");
                  this._clearKernelState();
                  await this.reconnect();
                });
              }
              this._updateStatus(executionState);
              break;
            }
            case "comm_open":
              if (this.handleComms) {
                await this._handleCommOpen(msg);
              }
              break;
            case "comm_msg":
              if (this.handleComms) {
                await this._handleCommMsg(msg);
              }
              break;
            case "comm_close":
              if (this.handleComms) {
                await this._handleCommClose(msg);
              }
              break;
            default:
              break;
          }
          if (!this.isDisposed) {
            this._assertCurrentMessage(msg);
            this._iopubMessage.emit(msg);
          }
        }
      }
      /**
       * Attempt a connection if we have not exhausted connection attempts.
       */
      _reconnect() {
        this._errorIfDisposed();
        clearTimeout(this._reconnectTimeout);
        if (this._reconnectAttempt < this._reconnectLimit) {
          this._updateConnectionStatus("connecting");
          const timeout = Private19.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
          console.warn(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`);
          const useProtocols = this._selectedProtocol !== "" ? true : false;
          this._reconnectTimeout = setTimeout(this._createSocket, timeout, useProtocols);
          this._reconnectAttempt += 1;
        } else {
          this._updateConnectionStatus("disconnected");
        }
        this._clearSocket();
      }
      /**
       * Utility function to throw an error if this instance is disposed.
       */
      _errorIfDisposed() {
        if (this.isDisposed) {
          throw new Error("Kernel connection is disposed");
        }
      }
      get hasPendingInput() {
        return this._hasPendingInput;
      }
      set hasPendingInput(value) {
        this._hasPendingInput = value;
        this._pendingInput.emit(value);
      }
    };
    exports2.KernelConnection = KernelConnection;
    var Private19;
    (function(Private20) {
      function logKernelStatus(kernel) {
        switch (kernel.status) {
          case "idle":
          case "busy":
          case "unknown":
            return;
          default:
            console.debug(`Kernel: ${kernel.status} (${kernel.id})`);
            break;
        }
      }
      Private20.logKernelStatus = logKernelStatus;
      async function handleShellMessage(kernel, msg) {
        const future = kernel.sendShellMessage(msg, true);
        return future.done;
      }
      Private20.handleShellMessage = handleShellMessage;
      function loadObject(name2, moduleName, registry) {
        return new Promise((resolve, reject4) => {
          if (moduleName) {
            if (typeof requirejs === "undefined") {
              throw new Error("requirejs not found");
            }
            requirejs([moduleName], (mod) => {
              if (mod[name2] === void 0) {
                const msg = `Object '${name2}' not found in module '${moduleName}'`;
                reject4(new Error(msg));
              } else {
                resolve(mod[name2]);
              }
            }, reject4);
          } else {
            if (registry === null || registry === void 0 ? void 0 : registry[name2]) {
              resolve(registry[name2]);
            } else {
              reject4(new Error(`Object '${name2}' not found in registry`));
            }
          }
        });
      }
      Private20.loadObject = loadObject;
      function getRandomIntInclusive(min3, max3) {
        min3 = Math.ceil(min3);
        max3 = Math.floor(max3);
        return Math.floor(Math.random() * (max3 - min3 + 1)) + min3;
      }
      Private20.getRandomIntInclusive = getRandomIntInclusive;
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/manager.js
var require_manager7 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelManager = void 0;
    var polling_1 = (init_index_es62(), __toCommonJS(index_es6_exports2));
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var __1 = require_lib8();
    var basemanager_1 = require_basemanager2();
    var restapi_1 = require_restapi5();
    var default_1 = require_default4();
    var KernelManager2 = class extends basemanager_1.BaseManager {
      /**
       * Construct a new kernel manager.
       *
       * @param options - The default options for kernel.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._kernelConnections = /* @__PURE__ */ new Set();
        this._models = /* @__PURE__ */ new Map();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:KernelManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running kernels change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._models.clear();
        this._kernelConnections.forEach((x4) => x4.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /**
       * Connect to an existing kernel.
       *
       * @returns The new kernel connection.
       *
       * #### Notes
       * This will use the manager's server settings and ignore any server
       * settings passed in the options.
       */
      connectTo(options) {
        var _a;
        const { id } = options.model;
        let handleComms = (_a = options.handleComms) !== null && _a !== void 0 ? _a : true;
        if (options.handleComms === void 0) {
          for (const kc of this._kernelConnections) {
            if (kc.id === id && kc.handleComms) {
              handleComms = false;
              break;
            }
          }
        }
        const kernelConnection = new default_1.KernelConnection({
          handleComms,
          ...options,
          serverSettings: this.serverSettings
        });
        this._onStarted(kernelConnection);
        if (!this._models.has(id)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return kernelConnection;
      }
      /**
       * Create an iterator over the most recent running kernels.
       *
       * @returns A new iterator over the running kernels.
       */
      running() {
        return this._models.values();
      }
      /**
       * Force a refresh of the running kernels.
       *
       * @returns A promise that resolves when the running list has been refreshed.
       *
       * #### Notes
       * This is not typically meant to be called by the user, since the
       * manager maintains its own internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Start a new kernel.
       *
       * @param createOptions - The kernel creation options
       *
       * @param connectOptions - The kernel connection options
       *
       * @returns A promise that resolves with the kernel connection.
       *
       * #### Notes
       * The manager `serverSettings` will be always be used.
       */
      async startNew(createOptions = {}, connectOptions = {}) {
        const model = await (0, restapi_1.startNew)(createOptions, this.serverSettings);
        return this.connectTo({
          ...connectOptions,
          model
        });
      }
      /**
       * Shut down a kernel by id.
       *
       * @param id - The id of the target kernel.
       *
       * @returns A promise that resolves when the operation is complete.
       */
      async shutdown(id) {
        await (0, restapi_1.shutdownKernel)(id, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all kernels.
       *
       * @returns A promise that resolves when all of the kernels are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all([...this._models.keys()].map((id) => (0, restapi_1.shutdownKernel)(id, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Find a kernel by id.
       *
       * @param id - The id of the target kernel.
       *
       * @returns A promise that resolves with the kernel's model.
       */
      async findById(id) {
        if (this._models.has(id)) {
          return this._models.get(id);
        }
        await this.refreshRunning();
        return this._models.get(id);
      }
      /**
       * Execute a request to the server to poll running kernels and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof __1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        if (this._models.size === models.length && models.every((model) => {
          const existing = this._models.get(model.id);
          if (!existing) {
            return false;
          }
          return existing.connections === model.connections && existing.execution_state === model.execution_state && existing.last_activity === model.last_activity && existing.name === model.name && existing.reason === model.reason && existing.traceback === model.traceback;
        })) {
          return;
        }
        this._models = new Map(models.map((x4) => [x4.id, x4]));
        this._kernelConnections.forEach((kc) => {
          if (!this._models.has(kc.id)) {
            kc.handleShutdown();
          }
        });
        this._runningChanged.emit(models);
      }
      /**
       * Handle a kernel starting.
       */
      _onStarted(kernelConnection) {
        this._kernelConnections.add(kernelConnection);
        kernelConnection.statusChanged.connect(this._onStatusChanged, this);
        kernelConnection.disposed.connect(this._onDisposed, this);
      }
      _onDisposed(kernelConnection) {
        this._kernelConnections.delete(kernelConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      _onStatusChanged(kernelConnection, status) {
        if (status === "dead") {
          void this.refreshRunning().catch(() => {
          });
        }
      }
    };
    exports2.KernelManager = KernelManager2;
    (function(KernelManager3) {
      class NoopManager extends KernelManager3 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * Start a new kernel - throws an error since it is not supported.
         */
        async startNew(createOptions = {}, connectOptions = {}) {
          return Promise.reject(new Error("Not implemented in no-op Kernel Manager"));
        }
        /**
         * Connect to an existing kernel - throws an error since it is not supported.
         */
        connectTo(options) {
          throw new Error("Not implemented in no-op Kernel Manager");
        }
        /**
         * Shut down a kernel by id - throws an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Kernel Manager"));
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Execute a request to the server to poll running kernels and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      KernelManager3.NoopManager = NoopManager;
    })(KernelManager2 || (exports2.KernelManager = KernelManager2 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/index.js
var require_kernel4 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/kernel/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelConnection = exports2.KernelAPI = exports2.KernelMessage = exports2.Kernel = void 0;
    var Kernel = __importStar(require_kernel3());
    exports2.Kernel = Kernel;
    var KernelMessage2 = __importStar(require_messages2());
    exports2.KernelMessage = KernelMessage2;
    var KernelAPI2 = __importStar(require_restapi5());
    exports2.KernelAPI = KernelAPI2;
    var default_1 = require_default4();
    Object.defineProperty(exports2, "KernelConnection", { enumerable: true, get: function() {
      return default_1.KernelConnection;
    } });
    __exportStar(require_manager7(), exports2);
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/builder/index.js
var require_builder2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/builder/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BuildManager = void 0;
    var coreutils_12 = require_lib6();
    var serverconnection_1 = require_serverconnection2();
    var BUILD_SETTINGS_URL = "api/build";
    var BuildManager = class {
      /**
       * Create a new setting manager.
       */
      constructor(options = {}) {
        var _a;
        this._url = "";
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        const { baseUrl, appUrl } = this.serverSettings;
        this._url = coreutils_12.URLExt.join(baseUrl, appUrl, BUILD_SETTINGS_URL);
      }
      /**
       * Test whether the build service is available.
       */
      get isAvailable() {
        return coreutils_12.PageConfig.getOption("buildAvailable").toLowerCase() === "true";
      }
      /**
       * Test whether to check build status automatically.
       */
      get shouldCheck() {
        return coreutils_12.PageConfig.getOption("buildCheck").toLowerCase() === "true";
      }
      /**
       * Get whether the application should be built.
       */
      getStatus() {
        const { _url, serverSettings } = this;
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, {}, serverSettings);
        return promise.then((response) => {
          if (response.status !== 200) {
            throw new serverconnection_1.ServerConnection.ResponseError(response);
          }
          return response.json();
        }).then((data) => {
          if (typeof data.status !== "string") {
            throw new Error("Invalid data");
          }
          if (typeof data.message !== "string") {
            throw new Error("Invalid data");
          }
          return data;
        });
      }
      /**
       * Build the application.
       */
      build() {
        const { _url, serverSettings } = this;
        const init = { method: "POST" };
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, init, serverSettings);
        return promise.then((response) => {
          if (response.status === 400) {
            throw new serverconnection_1.ServerConnection.ResponseError(response, "Build aborted");
          }
          if (response.status !== 200) {
            const message = `Build failed with ${response.status}.

        If you are experiencing the build failure after installing an extension (or trying to include previously installed extension after updating JupyterLab) please check the extension repository for new installation instructions as many extensions migrated to the prebuilt extensions system which no longer requires rebuilding JupyterLab (but uses a different installation procedure, typically involving a package manager such as 'pip' or 'conda').

        If you specifically intended to install a source extension, please run 'jupyter lab build' on the server for full output.`;
            throw new serverconnection_1.ServerConnection.ResponseError(response, message);
          }
        });
      }
      /**
       * Cancel an active build.
       */
      cancel() {
        const { _url, serverSettings } = this;
        const init = { method: "DELETE" };
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, init, serverSettings);
        return promise.then((response) => {
          if (response.status !== 204) {
            throw new serverconnection_1.ServerConnection.ResponseError(response);
          }
        });
      }
    };
    exports2.BuildManager = BuildManager;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/nbconvert/index.js
var require_nbconvert2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/nbconvert/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NbConvertManager = void 0;
    var coreutils_12 = require_lib6();
    var serverconnection_1 = require_serverconnection2();
    var coreutils_2 = require_dist();
    var NBCONVERT_SETTINGS_URL = "api/nbconvert";
    var NbConvertManager = class {
      /**
       * Create a new nbconvert manager.
       */
      constructor(options = {}) {
        var _a;
        this._exportFormats = null;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch and cache the export formats from the expensive nbconvert handler.
       */
      async fetchExportFormats() {
        this._requestingFormats = new coreutils_2.PromiseDelegate();
        this._exportFormats = null;
        const base = this.serverSettings.baseUrl;
        const url = coreutils_12.URLExt.join(base, NBCONVERT_SETTINGS_URL);
        const { serverSettings } = this;
        const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        const exportList = {};
        const keys2 = Object.keys(data);
        keys2.forEach(function(key) {
          const mimeType = data[key].output_mimetype;
          exportList[key] = { output_mimetype: mimeType };
        });
        this._exportFormats = exportList;
        this._requestingFormats.resolve(exportList);
        return exportList;
      }
      /**
       * Get the list of export formats, preferring pre-cached ones.
       */
      async getExportFormats(force = true) {
        if (this._requestingFormats) {
          return this._requestingFormats.promise;
        }
        if (force || !this._exportFormats) {
          return await this.fetchExportFormats();
        }
        return this._exportFormats;
      }
    };
    exports2.NbConvertManager = NbConvertManager;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/session/session.js
var require_session3 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/session/session.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/session/validate.js
var require_validate10 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/session/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateModels = exports2.updateLegacySessionModel = exports2.validateModel = void 0;
    var validate_1 = require_validate8();
    var validate_2 = require_validate6();
    function validateModel(data) {
      (0, validate_2.validateProperty)(data, "id", "string");
      (0, validate_2.validateProperty)(data, "type", "string");
      (0, validate_2.validateProperty)(data, "name", "string");
      (0, validate_2.validateProperty)(data, "path", "string");
      (0, validate_2.validateProperty)(data, "kernel", "object");
      (0, validate_1.validateModel)(data.kernel);
    }
    exports2.validateModel = validateModel;
    function updateLegacySessionModel(data) {
      if (data.path === void 0 && data.notebook !== void 0) {
        data.path = data.notebook.path;
        data.type = "notebook";
        data.name = "";
      }
    }
    exports2.updateLegacySessionModel = updateLegacySessionModel;
    function validateModels(models) {
      if (!Array.isArray(models)) {
        throw new Error("Invalid session list");
      }
      models.forEach((d6) => validateModel(d6));
    }
    exports2.validateModels = validateModels;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/session/restapi.js
var require_restapi7 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/session/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateSession = exports2.startSession = exports2.getSessionModel = exports2.shutdownSession = exports2.getSessionUrl = exports2.listRunning = exports2.SESSION_SERVICE_URL = void 0;
    var serverconnection_1 = require_serverconnection2();
    var coreutils_12 = require_lib6();
    var validate_1 = require_validate10();
    exports2.SESSION_SERVICE_URL = "api/sessions";
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.SESSION_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error("Invalid Session list");
      }
      data.forEach((m4) => {
        (0, validate_1.updateLegacySessionModel)(m4);
        (0, validate_1.validateModel)(m4);
      });
      return data;
    }
    exports2.listRunning = listRunning;
    function getSessionUrl(baseUrl, id) {
      const servicesBase = coreutils_12.URLExt.join(baseUrl, exports2.SESSION_SERVICE_URL);
      const result2 = coreutils_12.URLExt.join(servicesBase, id);
      if (!result2.startsWith(servicesBase)) {
        throw new Error("Can only be used for services requests");
      }
      return result2;
    }
    exports2.getSessionUrl = getSessionUrl;
    async function shutdownSession(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      var _a;
      const url = getSessionUrl(settings.baseUrl, id);
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const data = await response.json();
        const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The session "${id}"" does not exist on the server`;
        console.warn(msg);
      } else if (response.status === 410) {
        throw new serverconnection_1.ServerConnection.ResponseError(response, "The kernel was deleted but the session was not");
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownSession = shutdownSession;
    async function getSessionModel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = getSessionUrl(settings.baseUrl, id);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.getSessionModel = getSessionModel;
    async function startSession(options, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.SESSION_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify(options)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 201) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.startSession = startSession;
    async function updateSession(model, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = getSessionUrl(settings.baseUrl, model.id);
      const init = {
        method: "PATCH",
        body: JSON.stringify(model)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.updateSession = updateSession;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/session/default.js
var require_default5 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/session/default.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionConnection = void 0;
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var __1 = require_lib8();
    var restapi_1 = require_restapi7();
    var coreutils_12 = require_dist();
    var SessionConnection = class {
      /**
       * Construct a new session.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        this._id = "";
        this._path = "";
        this._name = "";
        this._type = "";
        this._kernel = null;
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this._kernelChanged = new signaling_1.Signal(this);
        this._statusChanged = new signaling_1.Signal(this);
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._pendingInput = new signaling_1.Signal(this);
        this._iopubMessage = new signaling_1.Signal(this);
        this._unhandledMessage = new signaling_1.Signal(this);
        this._anyMessage = new signaling_1.Signal(this);
        this._propertyChanged = new signaling_1.Signal(this);
        this._id = options.model.id;
        this._name = options.model.name;
        this._path = options.model.path;
        this._type = options.model.type;
        this._username = (_a = options.username) !== null && _a !== void 0 ? _a : "";
        this._clientId = (_b = options.clientId) !== null && _b !== void 0 ? _b : coreutils_12.UUID.uuid4();
        this._connectToKernel = options.connectToKernel;
        this._kernelConnectionOptions = (_c = options.kernelConnectionOptions) !== null && _c !== void 0 ? _c : {};
        this.serverSettings = (_d = options.serverSettings) !== null && _d !== void 0 ? _d : __1.ServerConnection.makeSettings();
        this.setupKernel(options.model.kernel);
      }
      /**
       * A signal emitted when the session is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when the kernel changes.
       */
      get kernelChanged() {
        return this._kernelChanged;
      }
      /**
       * A signal proxied from the connection about the kernel status.
       */
      get statusChanged() {
        return this._statusChanged;
      }
      /**
       * A signal proxied from the kernel about the connection status.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * A signal proxied from the kernel pending input.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * A signal proxied from the kernel about iopub kernel messages.
       */
      get iopubMessage() {
        return this._iopubMessage;
      }
      /**
       * A signal proxied from the kernel for an unhandled kernel message.
       */
      get unhandledMessage() {
        return this._unhandledMessage;
      }
      /**
       * A signal proxied from the kernel emitted for any kernel message.
       *
       * #### Notes
       * The behavior is undefined if the message is modified during message
       * handling. As such, it should be treated as read-only.
       */
      get anyMessage() {
        return this._anyMessage;
      }
      /**
       * A signal emitted when a session property changes.
       */
      get propertyChanged() {
        return this._propertyChanged;
      }
      /**
       * Get the session id.
       */
      get id() {
        return this._id;
      }
      /**
       * Get the session kernel connection object.
       *
       * #### Notes
       * This is a read-only property, and can be altered by [changeKernel].
       */
      get kernel() {
        return this._kernel;
      }
      /**
       * Get the session path.
       */
      get path() {
        return this._path;
      }
      /**
       * Get the session type.
       */
      get type() {
        return this._type;
      }
      /**
       * Get the session name.
       */
      get name() {
        return this._name;
      }
      /**
       * Get the model associated with the session.
       */
      get model() {
        return {
          id: this.id,
          kernel: this.kernel && { id: this.kernel.id, name: this.kernel.name },
          path: this._path,
          type: this._type,
          name: this._name
        };
      }
      /**
       * Test whether the session has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Update the session based on a session model from the server.
       *
       * #### Notes
       * This only updates this session connection instance. Use `setPath`,
       * `setName`, `setType`, and `changeKernel` to change the session values on
       * the server.
       */
      update(model) {
        const oldModel = this.model;
        this._path = model.path;
        this._name = model.name;
        this._type = model.type;
        if (this._kernel === null && model.kernel !== null || this._kernel !== null && model.kernel === null || this._kernel !== null && model.kernel !== null && this._kernel.id !== model.kernel.id) {
          if (this._kernel !== null) {
            this._kernel.dispose();
          }
          const oldValue = this._kernel || null;
          this.setupKernel(model.kernel);
          const newValue = this._kernel || null;
          this._kernelChanged.emit({ name: "kernel", oldValue, newValue });
        }
        this._handleModelChange(oldModel);
      }
      /**
       * Dispose of the resources held by the session.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        if (this._kernel) {
          this._kernel.dispose();
          const oldValue = this._kernel;
          this._kernel = null;
          const newValue = this._kernel;
          this._kernelChanged.emit({ name: "kernel", oldValue, newValue });
        }
        signaling_1.Signal.clearData(this);
      }
      /**
       * Change the session path.
       *
       * @param path - The new session path.
       *
       * @returns A promise that resolves when the session has renamed.
       *
       * #### Notes
       * This uses the Jupyter REST API, and the response is validated.
       * The promise is fulfilled on a valid response and rejected otherwise.
       */
      async setPath(path2) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ path: path2 });
      }
      /**
       * Change the session name.
       */
      async setName(name2) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ name: name2 });
      }
      /**
       * Change the session type.
       */
      async setType(type2) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ type: type2 });
      }
      /**
       * Change the kernel.
       *
       * @param options - The name or id of the new kernel.
       *
       * #### Notes
       * This shuts down the existing kernel and creates a new kernel,
       * keeping the existing session ID and session path.
       */
      async changeKernel(options) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ kernel: options });
        return this.kernel;
      }
      /**
       * Kill the kernel and shutdown the session.
       *
       * @returns - The promise fulfilled on a valid response from the server.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/sessions), and validates the response.
       * Disposes of the session and emits a [sessionDied] signal on success.
       */
      async shutdown() {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await (0, restapi_1.shutdownSession)(this.id, this.serverSettings);
        this.dispose();
      }
      /**
       * Create a new kernel connection and connect to its signals.
       *
       * #### Notes
       * This method is not meant to be subclassed.
       */
      setupKernel(model) {
        if (model === null) {
          this._kernel = null;
          return;
        }
        const kc = this._connectToKernel({
          ...this._kernelConnectionOptions,
          model,
          username: this._username,
          clientId: this._clientId,
          serverSettings: this.serverSettings
        });
        this._kernel = kc;
        kc.statusChanged.connect(this.onKernelStatus, this);
        kc.connectionStatusChanged.connect(this.onKernelConnectionStatus, this);
        kc.pendingInput.connect(this.onPendingInput, this);
        kc.unhandledMessage.connect(this.onUnhandledMessage, this);
        kc.iopubMessage.connect(this.onIOPubMessage, this);
        kc.anyMessage.connect(this.onAnyMessage, this);
      }
      /**
       * Handle to changes in the Kernel status.
       */
      onKernelStatus(sender, state) {
        this._statusChanged.emit(state);
      }
      /**
       * Handle to changes in the Kernel status.
       */
      onKernelConnectionStatus(sender, state) {
        this._connectionStatusChanged.emit(state);
      }
      /**
       * Handle a change in the pendingInput.
       */
      onPendingInput(sender, state) {
        this._pendingInput.emit(state);
      }
      /**
       * Handle iopub kernel messages.
       */
      onIOPubMessage(sender, msg) {
        this._iopubMessage.emit(msg);
      }
      /**
       * Handle unhandled kernel messages.
       */
      onUnhandledMessage(sender, msg) {
        this._unhandledMessage.emit(msg);
      }
      /**
       * Handle any kernel messages.
       */
      onAnyMessage(sender, args) {
        this._anyMessage.emit(args);
      }
      /**
       * Send a PATCH to the server, updating the session path or the kernel.
       */
      async _patch(body) {
        const model = await (0, restapi_1.updateSession)({ ...body, id: this._id }, this.serverSettings);
        this.update(model);
        return model;
      }
      /**
       * Handle a change to the model.
       */
      _handleModelChange(oldModel) {
        if (oldModel.name !== this._name) {
          this._propertyChanged.emit("name");
        }
        if (oldModel.type !== this._type) {
          this._propertyChanged.emit("type");
        }
        if (oldModel.path !== this._path) {
          this._propertyChanged.emit("path");
        }
      }
    };
    exports2.SessionConnection = SessionConnection;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/session/manager.js
var require_manager8 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/session/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionManager = void 0;
    var polling_1 = (init_index_es62(), __toCommonJS(index_es6_exports2));
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var serverconnection_1 = require_serverconnection2();
    var basemanager_1 = require_basemanager2();
    var default_1 = require_default5();
    var restapi_1 = require_restapi7();
    var SessionManager2 = class extends basemanager_1.BaseManager {
      /**
       * Construct a new session manager.
       *
       * @param options - The default options for each session.
       */
      constructor(options) {
        var _a;
        super(options);
        this._isReady = false;
        this._sessionConnections = /* @__PURE__ */ new Set();
        this._models = /* @__PURE__ */ new Map();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._connectToKernel = (options2) => {
          return this._kernelManager.connectTo(options2);
        };
        this._kernelManager = options.kernelManager;
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:SessionManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          if (this._kernelManager.isActive) {
            await this._kernelManager.ready;
          }
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running sessions change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._models.clear();
        this._sessionConnections.forEach((x4) => x4.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /*
       * Connect to a running session.  See also [[connectToSession]].
       */
      connectTo(options) {
        const sessionConnection = new default_1.SessionConnection({
          ...options,
          connectToKernel: this._connectToKernel,
          serverSettings: this.serverSettings
        });
        this._onStarted(sessionConnection);
        if (!this._models.has(options.model.id)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return sessionConnection;
      }
      /**
       * Create an iterator over the most recent running sessions.
       *
       * @returns A new iterator over the running sessions.
       */
      running() {
        return this._models.values();
      }
      /**
       * Force a refresh of the running sessions.
       *
       * @returns A promise that with the list of running sessions.
       *
       * #### Notes
       * This is not typically meant to be called by the user, since the
       * manager maintains its own internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Start a new session.  See also [[startNewSession]].
       *
       * @param createOptions - Options for creating the session
       *
       * @param connectOptions - Options for connecting to the session
       */
      async startNew(createOptions, connectOptions = {}) {
        const model = await (0, restapi_1.startSession)(createOptions, this.serverSettings);
        await this.refreshRunning();
        return this.connectTo({ ...connectOptions, model });
      }
      /**
       * Shut down a session by id.
       */
      async shutdown(id) {
        await (0, restapi_1.shutdownSession)(id, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all sessions.
       *
       * @returns A promise that resolves when all of the kernels are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all([...this._models.keys()].map((id) => (0, restapi_1.shutdownSession)(id, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Find a session associated with a path and stop it if it is the only session
       * using that kernel.
       *
       * @param path - The path in question.
       *
       * @returns A promise that resolves when the relevant sessions are stopped.
       */
      async stopIfNeeded(path2) {
        try {
          const sessions = await (0, restapi_1.listRunning)(this.serverSettings);
          const matches = sessions.filter((value) => value.path === path2);
          if (matches.length === 1) {
            const id = matches[0].id;
            await this.shutdown(id);
          }
        } catch (error) {
        }
      }
      /**
       * Find a session by id.
       */
      async findById(id) {
        if (this._models.has(id)) {
          return this._models.get(id);
        }
        await this.refreshRunning();
        return this._models.get(id);
      }
      /**
       * Find a session by path.
       */
      async findByPath(path2) {
        for (const m4 of this._models.values()) {
          if (m4.path === path2) {
            return m4;
          }
        }
        await this.refreshRunning();
        for (const m4 of this._models.values()) {
          if (m4.path === path2) {
            return m4;
          }
        }
        return void 0;
      }
      /**
       * Execute a request to the server to poll running kernels and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof serverconnection_1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        if (this._models.size === models.length && models.every((model) => {
          var _a2, _b2, _c, _d;
          const existing = this._models.get(model.id);
          if (!existing) {
            return false;
          }
          return ((_a2 = existing.kernel) === null || _a2 === void 0 ? void 0 : _a2.id) === ((_b2 = model.kernel) === null || _b2 === void 0 ? void 0 : _b2.id) && ((_c = existing.kernel) === null || _c === void 0 ? void 0 : _c.name) === ((_d = model.kernel) === null || _d === void 0 ? void 0 : _d.name) && existing.name === model.name && existing.path === model.path && existing.type === model.type;
        })) {
          return;
        }
        this._models = new Map(models.map((x4) => [x4.id, x4]));
        this._sessionConnections.forEach((sc) => {
          if (this._models.has(sc.id)) {
            sc.update(this._models.get(sc.id));
          } else {
            sc.dispose();
          }
        });
        this._runningChanged.emit(models);
      }
      /**
       * Handle a session starting.
       */
      _onStarted(sessionConnection) {
        this._sessionConnections.add(sessionConnection);
        sessionConnection.disposed.connect(this._onDisposed, this);
        sessionConnection.propertyChanged.connect(this._onChanged, this);
        sessionConnection.kernelChanged.connect(this._onChanged, this);
      }
      _onDisposed(sessionConnection) {
        this._sessionConnections.delete(sessionConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      _onChanged() {
        void this.refreshRunning().catch(() => {
        });
      }
    };
    exports2.SessionManager = SessionManager2;
    (function(SessionManager3) {
      class NoopManager extends SessionManager3 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * Start a new session - throw an error since it is not supported.
         */
        async startNew(createOptions, connectOptions = {}) {
          return Promise.reject(new Error("Not implemented in no-op Session Manager"));
        }
        /*
         * Connect to a running session - throw an error since it is not supported.
         */
        connectTo(options) {
          throw Error("Not implemented in no-op Session Manager");
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Shut down a session by id - throw an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Session Manager"));
        }
        /**
         * Execute a request to the server to poll running sessions and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      SessionManager3.NoopManager = NoopManager;
    })(SessionManager2 || (exports2.SessionManager = SessionManager2 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/session/index.js
var require_session4 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/session/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionAPI = exports2.Session = void 0;
    var Session = __importStar(require_session3());
    exports2.Session = Session;
    var SessionAPI = __importStar(require_restapi7());
    exports2.SessionAPI = SessionAPI;
    __exportStar(require_manager8(), exports2);
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/statedb/lib/dataconnector.js
var require_dataconnector2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/statedb/lib/dataconnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DataConnector = void 0;
    var DataConnector = class {
      /**
       * Retrieve the list of items available from the data connector.
       *
       * @param query - The optional query filter to apply to the connector request.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can list.
       */
      async list(query) {
        throw new Error("DataConnector#list method has not been implemented.");
      }
      /**
       * Remove a value using the data connector.
       *
       * @param id - The identifier for the data being removed.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can remove.
       */
      async remove(id) {
        throw new Error("DataConnector#remove method has not been implemented.");
      }
      /**
       * Save a value using the data connector.
       *
       * @param id - The identifier for the data being saved.
       *
       * @param value - The data being saved.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can save.
       */
      async save(id, value) {
        throw new Error("DataConnector#save method has not been implemented.");
      }
    };
    exports2.DataConnector = DataConnector;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/statedb/lib/interfaces.js
var require_interfaces5 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/statedb/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/properties/dist/index.es6.js
var index_es6_exports5 = {};
__export(index_es6_exports5, {
  AttachedProperty: () => AttachedProperty2
});
var AttachedProperty2, Private16;
var init_index_es615 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/properties/dist/index.es6.js"() {
    AttachedProperty2 = class {
      /**
       * Construct a new attached property.
       *
       * @param options - The options for initializing the property.
       */
      constructor(options) {
        this._pid = Private16.nextPID();
        this.name = options.name;
        this._create = options.create;
        this._coerce = options.coerce || null;
        this._compare = options.compare || null;
        this._changed = options.changed || null;
      }
      /**
       * Get the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @returns The current value of the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and assigned as the current value of the property.
       */
      get(owner) {
        let value;
        let map4 = Private16.ensureMap(owner);
        if (this._pid in map4) {
          value = map4[this._pid];
        } else {
          value = map4[this._pid] = this._createValue(owner);
        }
        return value;
      }
      /**
       * Set the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @param value - The value for the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      set(owner, value) {
        let oldValue;
        let map4 = Private16.ensureMap(owner);
        if (this._pid in map4) {
          oldValue = map4[this._pid];
        } else {
          oldValue = map4[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, value);
        this._maybeNotify(owner, oldValue, map4[this._pid] = newValue);
      }
      /**
       * Explicitly coerce the current property value for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      coerce(owner) {
        let oldValue;
        let map4 = Private16.ensureMap(owner);
        if (this._pid in map4) {
          oldValue = map4[this._pid];
        } else {
          oldValue = map4[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, oldValue);
        this._maybeNotify(owner, oldValue, map4[this._pid] = newValue);
      }
      /**
       * Get or create the default value for the given owner.
       */
      _createValue(owner) {
        let create2 = this._create;
        return create2(owner);
      }
      /**
       * Coerce the value for the given owner.
       */
      _coerceValue(owner, value) {
        let coerce = this._coerce;
        return coerce ? coerce(owner, value) : value;
      }
      /**
       * Compare the old value and new value for equality.
       */
      _compareValue(oldValue, newValue) {
        let compare2 = this._compare;
        return compare2 ? compare2(oldValue, newValue) : oldValue === newValue;
      }
      /**
       * Run the change notification if the given values are different.
       */
      _maybeNotify(owner, oldValue, newValue) {
        let changed = this._changed;
        if (changed && !this._compareValue(oldValue, newValue)) {
          changed(owner, oldValue, newValue);
        }
      }
    };
    (function(AttachedProperty3) {
      function clearData(owner) {
        Private16.ownerData.delete(owner);
      }
      AttachedProperty3.clearData = clearData;
    })(AttachedProperty2 || (AttachedProperty2 = {}));
    (function(Private19) {
      Private19.ownerData = /* @__PURE__ */ new WeakMap();
      Private19.nextPID = (() => {
        let id = 0;
        return () => {
          let rand = Math.random();
          let stem = `${rand}`.slice(2);
          return `pid-${stem}-${id++}`;
        };
      })();
      function ensureMap(owner) {
        let map4 = Private19.ownerData.get(owner);
        if (map4) {
          return map4;
        }
        map4 = /* @__PURE__ */ Object.create(null);
        Private19.ownerData.set(owner, map4);
        return map4;
      }
      Private19.ensureMap = ensureMap;
    })(Private16 || (Private16 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/statedb/lib/restorablepool.js
var require_restorablepool2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/statedb/lib/restorablepool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestorablePool = void 0;
    var coreutils_12 = require_dist();
    var properties_1 = (init_index_es615(), __toCommonJS(index_es6_exports5));
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var RestorablePool = class {
      /**
       * Create a new restorable pool.
       *
       * @param options - The instantiation options for a restorable pool.
       */
      constructor(options) {
        this._added = new signaling_1.Signal(this);
        this._current = null;
        this._currentChanged = new signaling_1.Signal(this);
        this._hasRestored = false;
        this._isDisposed = false;
        this._objects = /* @__PURE__ */ new Set();
        this._restore = null;
        this._restored = new coreutils_12.PromiseDelegate();
        this._updated = new signaling_1.Signal(this);
        this.namespace = options.namespace;
      }
      /**
       * A signal emitted when an object object is added.
       *
       * #### Notes
       * This signal will only fire when an object is added to the pool.
       * It will not fire if an object injected into the pool.
       */
      get added() {
        return this._added;
      }
      /**
       * The current object.
       *
       * #### Notes
       * The restorable pool does not set `current`. It is intended for client use.
       *
       * If `current` is set to an object that does not exist in the pool, it is a
       * no-op.
       */
      get current() {
        return this._current;
      }
      set current(obj) {
        if (this._current === obj) {
          return;
        }
        if (obj !== null && this._objects.has(obj)) {
          this._current = obj;
          this._currentChanged.emit(this._current);
        }
      }
      /**
       * A signal emitted when the current widget changes.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * Test whether the pool is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * A promise resolved when the restorable pool has been restored.
       */
      get restored() {
        return this._restored.promise;
      }
      /**
       * The number of objects held by the pool.
       */
      get size() {
        return this._objects.size;
      }
      /**
       * A signal emitted when an object is updated.
       */
      get updated() {
        return this._updated;
      }
      /**
       * Add a new object to the pool.
       *
       * @param obj - The object object being added.
       *
       * #### Notes
       * The object passed into the pool is added synchronously; its existence in
       * the pool can be checked with the `has()` method. The promise this method
       * returns resolves after the object has been added and saved to an underlying
       * restoration connector, if one is available.
       */
      async add(obj) {
        var _a, _b;
        if (obj.isDisposed) {
          const warning = "A disposed object cannot be added.";
          console.warn(warning, obj);
          throw new Error(warning);
        }
        if (this._objects.has(obj)) {
          const warning = "This object already exists in the pool.";
          console.warn(warning, obj);
          throw new Error(warning);
        }
        this._objects.add(obj);
        obj.disposed.connect(this._onInstanceDisposed, this);
        if (Private19.injectedProperty.get(obj)) {
          return;
        }
        if (this._restore) {
          const { connector } = this._restore;
          const objName = this._restore.name(obj);
          if (objName) {
            const name2 = `${this.namespace}:${objName}`;
            const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
            Private19.nameProperty.set(obj, name2);
            await connector.save(name2, { data });
          }
        }
        this._added.emit(obj);
      }
      /**
       * Dispose of the resources held by the pool.
       *
       * #### Notes
       * Disposing a pool does not affect the underlying data in the data connector,
       * it simply disposes the client-side pool without making any connector calls.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._current = null;
        this._isDisposed = true;
        this._objects.clear();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Find the first object in the pool that satisfies a filter function.
       *
       * @param - fn The filter function to call on each object.
       */
      find(fn) {
        const values2 = this._objects.values();
        for (const value of values2) {
          if (fn(value)) {
            return value;
          }
        }
        return void 0;
      }
      /**
       * Iterate through each object in the pool.
       *
       * @param fn - The function to call on each object.
       */
      forEach(fn) {
        this._objects.forEach(fn);
      }
      /**
       * Filter the objects in the pool based on a predicate.
       *
       * @param fn - The function by which to filter.
       */
      filter(fn) {
        const filtered = [];
        this.forEach((obj) => {
          if (fn(obj)) {
            filtered.push(obj);
          }
        });
        return filtered;
      }
      /**
       * Inject an object into the restorable pool without the pool handling its
       * restoration lifecycle.
       *
       * @param obj - The object to inject into the pool.
       */
      inject(obj) {
        Private19.injectedProperty.set(obj, true);
        return this.add(obj);
      }
      /**
       * Check if this pool has the specified object.
       *
       * @param obj - The object whose existence is being checked.
       */
      has(obj) {
        return this._objects.has(obj);
      }
      /**
       * Restore the objects in this pool's namespace.
       *
       * @param options - The configuration options that describe restoration.
       *
       * @returns A promise that resolves when restoration has completed.
       *
       * #### Notes
       * This function should almost never be invoked by client code. Its primary
       * use case is to be invoked by a layout restorer plugin that handles
       * multiple restorable pools and, when ready, asks them each to restore their
       * respective objects.
       */
      async restore(options) {
        if (this._hasRestored) {
          throw new Error("This pool has already been restored.");
        }
        this._hasRestored = true;
        const { command, connector, registry, when } = options;
        const namespace = this.namespace;
        const promises = when ? [connector.list(namespace)].concat(when) : [connector.list(namespace)];
        this._restore = options;
        const [saved] = await Promise.all(promises);
        const values2 = await Promise.all(saved.ids.map(async (id, index2) => {
          const value = saved.values[index2];
          const args = value && value.data;
          if (args === void 0) {
            return connector.remove(id);
          }
          return registry.execute(command, args).catch(() => connector.remove(id));
        }));
        this._restored.resolve();
        return values2;
      }
      /**
       * Save the restore data for a given object.
       *
       * @param obj - The object being saved.
       */
      async save(obj) {
        var _a, _b;
        const injected = Private19.injectedProperty.get(obj);
        if (!this._restore || !this.has(obj) || injected) {
          return;
        }
        const { connector } = this._restore;
        const objName = this._restore.name(obj);
        const oldName = Private19.nameProperty.get(obj);
        const newName = objName ? `${this.namespace}:${objName}` : "";
        if (oldName && oldName !== newName) {
          await connector.remove(oldName);
        }
        Private19.nameProperty.set(obj, newName);
        if (newName) {
          const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
          await connector.save(newName, { data });
        }
        if (oldName !== newName) {
          this._updated.emit(obj);
        }
      }
      /**
       * Clean up after disposed objects.
       */
      _onInstanceDisposed(obj) {
        this._objects.delete(obj);
        if (obj === this._current) {
          this._current = null;
          this._currentChanged.emit(this._current);
        }
        if (Private19.injectedProperty.get(obj)) {
          return;
        }
        if (!this._restore) {
          return;
        }
        const { connector } = this._restore;
        const name2 = Private19.nameProperty.get(obj);
        if (name2) {
          void connector.remove(name2);
        }
      }
    };
    exports2.RestorablePool = RestorablePool;
    var Private19;
    (function(Private20) {
      Private20.injectedProperty = new properties_1.AttachedProperty({
        name: "injected",
        create: () => false
      });
      Private20.nameProperty = new properties_1.AttachedProperty({
        name: "name",
        create: () => ""
      });
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/statedb/lib/statedb.js
var require_statedb2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/statedb/lib/statedb.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StateDB = void 0;
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var StateDB = class {
      /**
       * Create a new state database.
       *
       * @param options - The instantiation options for a state database.
       */
      constructor(options = {}) {
        this._changed = new signaling_1.Signal(this);
        const { connector, transform } = options;
        this._connector = connector || new StateDB.Connector();
        if (!transform) {
          this._ready = Promise.resolve(void 0);
        } else {
          this._ready = transform.then((transformation) => {
            const { contents, type: type2 } = transformation;
            switch (type2) {
              case "cancel":
                return;
              case "clear":
                return this._clear();
              case "merge":
                return this._merge(contents || {});
              case "overwrite":
                return this._overwrite(contents || {});
              default:
                return;
            }
          });
        }
      }
      /**
       * A signal that emits the change type any time a value changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Clear the entire database.
       */
      async clear() {
        await this._ready;
        await this._clear();
      }
      /**
       * Retrieve a saved bundle from the database.
       *
       * @param id - The identifier used to retrieve a data bundle.
       *
       * @returns A promise that bears a data payload if available.
       *
       * #### Notes
       * The `id` values of stored items in the state database are formatted:
       * `'namespace:identifier'`, which is the same convention that command
       * identifiers in JupyterLab use as well. While this is not a technical
       * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
       * using the `list(namespace: string)` method.
       *
       * The promise returned by this method may be rejected if an error occurs in
       * retrieving the data. Non-existence of an `id` will succeed with the `value`
       * `undefined`.
       */
      async fetch(id) {
        await this._ready;
        return this._fetch(id);
      }
      /**
       * Retrieve all the saved bundles for a namespace.
       *
       * @param filter - The namespace prefix to retrieve.
       *
       * @returns A promise that bears a collection of payloads for a namespace.
       *
       * #### Notes
       * Namespaces are entirely conventional entities. The `id` values of stored
       * items in the state database are formatted: `'namespace:identifier'`, which
       * is the same convention that command identifiers in JupyterLab use as well.
       *
       * If there are any errors in retrieving the data, they will be logged to the
       * console in order to optimistically return any extant data without failing.
       * This promise will always succeed.
       */
      async list(namespace) {
        await this._ready;
        return this._list(namespace);
      }
      /**
       * Remove a value from the database.
       *
       * @param id - The identifier for the data being removed.
       *
       * @returns A promise that is rejected if remove fails and succeeds otherwise.
       */
      async remove(id) {
        await this._ready;
        await this._remove(id);
        this._changed.emit({ id, type: "remove" });
      }
      /**
       * Save a value in the database.
       *
       * @param id - The identifier for the data being saved.
       *
       * @param value - The data being saved.
       *
       * @returns A promise that is rejected if saving fails and succeeds otherwise.
       *
       * #### Notes
       * The `id` values of stored items in the state database are formatted:
       * `'namespace:identifier'`, which is the same convention that command
       * identifiers in JupyterLab use as well. While this is not a technical
       * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
       * using the `list(namespace: string)` method.
       */
      async save(id, value) {
        await this._ready;
        await this._save(id, value);
        this._changed.emit({ id, type: "save" });
      }
      /**
       * Return a serialized copy of the state database's entire contents.
       *
       * @returns A promise that resolves with the database contents as JSON.
       */
      async toJSON() {
        await this._ready;
        const { ids, values: values2 } = await this._list();
        return values2.reduce((acc, val, idx) => {
          acc[ids[idx]] = val;
          return acc;
        }, {});
      }
      /**
       * Clear the entire database.
       */
      async _clear() {
        await Promise.all((await this._list()).ids.map((id) => this._remove(id)));
      }
      /**
       * Fetch a value from the database.
       */
      async _fetch(id) {
        const value = await this._connector.fetch(id);
        if (value) {
          return JSON.parse(value).v;
        }
      }
      /**
       * Fetch a list from the database.
       */
      async _list(namespace = "") {
        const { ids, values: values2 } = await this._connector.list(namespace);
        return {
          ids,
          values: values2.map((val) => JSON.parse(val).v)
        };
      }
      /**
       * Merge data into the state database.
       */
      async _merge(contents) {
        await Promise.all(Object.keys(contents).map((key) => contents[key] && this._save(key, contents[key])));
      }
      /**
       * Overwrite the entire database with new contents.
       */
      async _overwrite(contents) {
        await this._clear();
        await this._merge(contents);
      }
      /**
       * Remove a key in the database.
       */
      async _remove(id) {
        return this._connector.remove(id);
      }
      /**
       * Save a key and its value in the database.
       */
      async _save(id, value) {
        return this._connector.save(id, JSON.stringify({ v: value }));
      }
    };
    exports2.StateDB = StateDB;
    (function(StateDB2) {
      class Connector {
        constructor() {
          this._storage = {};
        }
        /**
         * Retrieve an item from the data connector.
         */
        async fetch(id) {
          return this._storage[id];
        }
        /**
         * Retrieve the list of items available from the data connector.
         *
         * @param namespace - If not empty, only keys whose first token before `:`
         * exactly match `namespace` will be returned, e.g. `foo` in `foo:bar`.
         */
        async list(namespace = "") {
          return Object.keys(this._storage).reduce((acc, val) => {
            if (namespace === "" ? true : namespace === val.split(":")[0]) {
              acc.ids.push(val);
              acc.values.push(this._storage[val]);
            }
            return acc;
          }, { ids: [], values: [] });
        }
        /**
         * Remove a value using the data connector.
         */
        async remove(id) {
          delete this._storage[id];
        }
        /**
         * Save a value using the data connector.
         */
        async save(id, value) {
          this._storage[id] = value;
        }
      }
      StateDB2.Connector = Connector;
    })(StateDB || (exports2.StateDB = StateDB = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/statedb/lib/tokens.js
var require_tokens2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/statedb/lib/tokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IStateDB = void 0;
    var coreutils_12 = require_dist();
    exports2.IStateDB = new coreutils_12.Token("@jupyterlab/coreutils:IStateDB", `A service for the JupyterLab state database.
  Use this if you want to store data that will persist across page loads.
  See "state database" for more information.`);
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/statedb/lib/index.js
var require_lib7 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/statedb/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_dataconnector2(), exports2);
    __exportStar(require_interfaces5(), exports2);
    __exportStar(require_restorablepool2(), exports2);
    __exportStar(require_statedb2(), exports2);
    __exportStar(require_tokens2(), exports2);
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/setting/index.js
var require_setting2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/setting/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SettingManager = void 0;
    var coreutils_12 = require_lib6();
    var statedb_1 = require_lib7();
    var serverconnection_1 = require_serverconnection2();
    var SERVICE_SETTINGS_URL = "api/settings";
    var SettingManager = class extends statedb_1.DataConnector {
      /**
       * Create a new setting manager.
       */
      constructor(options = {}) {
        var _a;
        super();
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch a plugin's settings.
       *
       * @param id - The plugin's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async fetch(id) {
        if (!id) {
          throw new Error("Plugin `id` parameter is required for settings fetch.");
        }
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private19.url(base, id);
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        return response.json();
      }
      /**
       * Fetch the list of all plugin setting bundles.
       *
       * @returns A promise that resolves if successful.
       */
      async list(query) {
        var _a, _b, _c, _d;
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private19.url(base, "", query === "ids");
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          throw new ResponseError(response);
        }
        const json2 = await response.json();
        const ids = (_b = (_a = json2 === null || json2 === void 0 ? void 0 : json2["settings"]) === null || _a === void 0 ? void 0 : _a.map((plugin) => plugin.id)) !== null && _b !== void 0 ? _b : [];
        let values2 = [];
        if (!query) {
          values2 = (_d = (_c = json2 === null || json2 === void 0 ? void 0 : json2["settings"]) === null || _c === void 0 ? void 0 : _c.map((plugin) => {
            plugin.data = { composite: {}, user: {} };
            return plugin;
          })) !== null && _d !== void 0 ? _d : [];
        }
        return { ids, values: values2 };
      }
      /**
       * Save a plugin's settings.
       *
       * @param id - The plugin's ID.
       *
       * @param raw - The user setting values as a raw string of JSON with comments.
       *
       * @returns A promise that resolves if successful.
       */
      async save(id, raw) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private19.url(base, id);
        const init = { body: JSON.stringify({ raw }), method: "PUT" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          throw new ResponseError(response);
        }
      }
    };
    exports2.SettingManager = SettingManager;
    var Private19;
    (function(Private20) {
      function url(base, id, idsOnly) {
        const idsOnlyParam = idsOnly ? coreutils_12.URLExt.objectToQueryString({ ids_only: true }) : "";
        const settingsBase = coreutils_12.URLExt.join(base, SERVICE_SETTINGS_URL);
        const result2 = coreutils_12.URLExt.join(settingsBase, id);
        if (!result2.startsWith(settingsBase)) {
          throw new Error("Can only be used for workspaces requests");
        }
        return `${result2}${idsOnlyParam}`;
      }
      Private20.url = url;
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/terminal/restapi.js
var require_restapi8 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/terminal/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shutdownTerminal = exports2.listRunning = exports2.startNew = exports2.isAvailable = exports2.TERMINAL_SERVICE_URL = void 0;
    var coreutils_12 = require_lib6();
    var serverconnection_1 = require_serverconnection2();
    exports2.TERMINAL_SERVICE_URL = "api/terminals";
    function isAvailable() {
      const available = String(coreutils_12.PageConfig.getOption("terminalsAvailable"));
      return available.toLowerCase() === "true";
    }
    exports2.isAvailable = isAvailable;
    async function startNew(settings = serverconnection_1.ServerConnection.makeSettings(), name2, cwd) {
      Private19.errorIfNotAvailable();
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify({ name: name2, cwd })
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      return data;
    }
    exports2.startNew = startNew;
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      Private19.errorIfNotAvailable();
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error("Invalid terminal list");
      }
      return data;
    }
    exports2.listRunning = listRunning;
    async function shutdownTerminal(name2, settings = serverconnection_1.ServerConnection.makeSettings()) {
      var _a;
      Private19.errorIfNotAvailable();
      const workspacesBase = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const url = coreutils_12.URLExt.join(workspacesBase, name2);
      if (!url.startsWith(workspacesBase)) {
        throw new Error("Can only be used for terminal requests");
      }
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const data = await response.json();
        const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The terminal session "${name2}"" does not exist on the server`;
        console.warn(msg);
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownTerminal = shutdownTerminal;
    var Private19;
    (function(Private20) {
      function errorIfNotAvailable() {
        if (!isAvailable()) {
          throw new Error("Terminals Unavailable");
        }
      }
      Private20.errorIfNotAvailable = errorIfNotAvailable;
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/terminal/terminal.js
var require_terminal3 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/terminal/terminal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAvailable = void 0;
    var restapi_1 = require_restapi8();
    Object.defineProperty(exports2, "isAvailable", { enumerable: true, get: function() {
      return restapi_1.isAvailable;
    } });
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/terminal/default.js
var require_default6 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/terminal/default.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalConnection = void 0;
    var coreutils_12 = require_lib6();
    var coreutils_2 = require_dist();
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var __1 = require_lib8();
    var restapi_1 = require_restapi8();
    var TerminalConnection = class {
      /**
       * Construct a new terminal session.
       */
      constructor(options) {
        var _a;
        this._createSocket = () => {
          this._errorIfDisposed();
          this._clearSocket();
          this._updateConnectionStatus("connecting");
          const name2 = this._name;
          const settings = this.serverSettings;
          let url = coreutils_12.URLExt.join(settings.wsUrl, "terminals", "websocket", encodeURIComponent(name2));
          const token = settings.token;
          if (settings.appendToken && token !== "") {
            url = url + `?token=${encodeURIComponent(token)}`;
          }
          this._ws = new settings.WebSocket(url);
          this._ws.onmessage = this._onWSMessage;
          this._ws.onclose = this._onWSClose;
          this._ws.onerror = this._onWSClose;
        };
        this._onWSMessage = (event) => {
          if (this._isDisposed) {
            return;
          }
          const data = JSON.parse(event.data);
          if (data[0] === "disconnect") {
            this.dispose();
          }
          if (this._connectionStatus === "connecting") {
            if (data[0] === "setup") {
              this._updateConnectionStatus("connected");
            }
            return;
          }
          this._messageReceived.emit({
            type: data[0],
            content: data.slice(1)
          });
        };
        this._onWSClose = (event) => {
          console.warn(`Terminal websocket closed: ${event.code}`);
          if (!this.isDisposed) {
            this._reconnect();
          }
        };
        this._connectionStatus = "connecting";
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this._messageReceived = new signaling_1.Signal(this);
        this._reconnectTimeout = null;
        this._ws = null;
        this._noOp = () => {
        };
        this._reconnectLimit = 7;
        this._reconnectAttempt = 0;
        this._pendingMessages = [];
        this._name = options.model.name;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._createSocket();
      }
      /**
       * A signal emitted when the session is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when a message is received from the server.
       */
      get messageReceived() {
        return this._messageReceived;
      }
      /**
       * Get the name of the terminal session.
       */
      get name() {
        return this._name;
      }
      /**
       * Get the model for the terminal session.
       */
      get model() {
        return { name: this._name };
      }
      /**
       * Test whether the session is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the session.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        this._updateConnectionStatus("disconnected");
        this._clearSocket();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Send a message to the terminal session.
       *
       * #### Notes
       * If the connection is down, the message will be queued for sending when
       * the connection comes back up.
       */
      send(message) {
        this._sendMessage(message);
      }
      /**
       * Send a message on the websocket, or possibly queue for later sending.
       *
       * @param queue - whether to queue the message if it cannot be sent
       */
      _sendMessage(message, queue = true) {
        if (this._isDisposed || !message.content) {
          return;
        }
        if (this.connectionStatus === "connected" && this._ws) {
          const msg = [message.type, ...message.content];
          this._ws.send(JSON.stringify(msg));
        } else if (queue) {
          this._pendingMessages.push(message);
        } else {
          throw new Error(`Could not send message: ${JSON.stringify(message)}`);
        }
      }
      /**
       * Send pending messages to the kernel.
       */
      _sendPending() {
        while (this.connectionStatus === "connected" && this._pendingMessages.length > 0) {
          this._sendMessage(this._pendingMessages[0], false);
          this._pendingMessages.shift();
        }
      }
      /**
       * Reconnect to a terminal.
       *
       * #### Notes
       * This may try multiple times to reconnect to a terminal, and will sever
       * any existing connection.
       */
      reconnect() {
        this._errorIfDisposed();
        const result2 = new coreutils_2.PromiseDelegate();
        const fulfill = (sender, status) => {
          if (status === "connected") {
            result2.resolve();
            this.connectionStatusChanged.disconnect(fulfill, this);
          } else if (status === "disconnected") {
            result2.reject(new Error("Terminal connection disconnected"));
            this.connectionStatusChanged.disconnect(fulfill, this);
          }
        };
        this.connectionStatusChanged.connect(fulfill, this);
        this._reconnectAttempt = 0;
        this._reconnect();
        return result2.promise;
      }
      /**
       * Attempt a connection if we have not exhausted connection attempts.
       */
      _reconnect() {
        this._errorIfDisposed();
        clearTimeout(this._reconnectTimeout);
        if (this._reconnectAttempt < this._reconnectLimit) {
          this._updateConnectionStatus("connecting");
          const timeout = Private19.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
          console.error(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`);
          this._reconnectTimeout = setTimeout(this._createSocket, timeout);
          this._reconnectAttempt += 1;
        } else {
          this._updateConnectionStatus("disconnected");
        }
        this._clearSocket();
      }
      /**
       * Forcefully clear the socket state.
       *
       * #### Notes
       * This will clear all socket state without calling any handlers and will
       * not update the connection status. If you call this method, you are
       * responsible for updating the connection status as needed and recreating
       * the socket if you plan to reconnect.
       */
      _clearSocket() {
        if (this._ws !== null) {
          this._ws.onopen = this._noOp;
          this._ws.onclose = this._noOp;
          this._ws.onerror = this._noOp;
          this._ws.onmessage = this._noOp;
          this._ws.close();
          this._ws = null;
        }
      }
      /**
       * Shut down the terminal session.
       */
      async shutdown() {
        await (0, restapi_1.shutdownTerminal)(this.name, this.serverSettings);
        this.dispose();
      }
      /**
       * Clone the current terminal connection.
       */
      clone() {
        return new TerminalConnection(this);
      }
      /**
       * Handle connection status changes.
       */
      _updateConnectionStatus(connectionStatus) {
        if (this._connectionStatus === connectionStatus) {
          return;
        }
        this._connectionStatus = connectionStatus;
        if (connectionStatus !== "connecting") {
          this._reconnectAttempt = 0;
          clearTimeout(this._reconnectTimeout);
        }
        if (connectionStatus === "connected") {
          this._sendPending();
        }
        this._connectionStatusChanged.emit(connectionStatus);
      }
      /**
       * Utility function to throw an error if this instance is disposed.
       */
      _errorIfDisposed() {
        if (this.isDisposed) {
          throw new Error("Terminal connection is disposed");
        }
      }
      /**
       * A signal emitted when the terminal connection status changes.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * The current connection status of the terminal connection.
       */
      get connectionStatus() {
        return this._connectionStatus;
      }
    };
    exports2.TerminalConnection = TerminalConnection;
    var Private19;
    (function(Private20) {
      function getTermUrl(baseUrl, name2) {
        return coreutils_12.URLExt.join(baseUrl, restapi_1.TERMINAL_SERVICE_URL, encodeURIComponent(name2));
      }
      Private20.getTermUrl = getTermUrl;
      function getRandomIntInclusive(min3, max3) {
        min3 = Math.ceil(min3);
        max3 = Math.floor(max3);
        return Math.floor(Math.random() * (max3 - min3 + 1)) + min3;
      }
      Private20.getRandomIntInclusive = getRandomIntInclusive;
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/terminal/manager.js
var require_manager9 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/terminal/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalManager = void 0;
    var polling_1 = (init_index_es62(), __toCommonJS(index_es6_exports2));
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var __1 = require_lib8();
    var basemanager_1 = require_basemanager2();
    var restapi_1 = require_restapi8();
    var default_1 = require_default6();
    var TerminalManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new terminal manager.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._names = [];
        this._terminalConnections = /* @__PURE__ */ new Set();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        if (!this.isAvailable()) {
          this._ready = Promise.reject("Terminals unavailable");
          this._ready.catch((_5) => void 0);
          return;
        }
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:TerminalManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running terminals change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._names.length = 0;
        this._terminalConnections.forEach((x4) => x4.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /**
       * Whether the terminal service is available.
       */
      isAvailable() {
        return (0, restapi_1.isAvailable)();
      }
      /*
       * Connect to a running terminal.
       *
       * @param options - The options used to connect to the terminal.
       *
       * @returns The new terminal connection instance.
       *
       * #### Notes
       * The manager `serverSettings` will be used.
       */
      connectTo(options) {
        const terminalConnection = new default_1.TerminalConnection({
          ...options,
          serverSettings: this.serverSettings
        });
        this._onStarted(terminalConnection);
        if (!this._names.includes(options.model.name)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return terminalConnection;
      }
      /**
       * Create an iterator over the most recent running terminals.
       *
       * @returns A new iterator over the running terminals.
       */
      running() {
        return this._models[Symbol.iterator]();
      }
      /**
       * Force a refresh of the running terminals.
       *
       * @returns A promise that with the list of running terminals.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Create a new terminal session.
       *
       * @param options - The options used to create the terminal.
       *
       * @returns A promise that resolves with the terminal connection instance.
       *
       * #### Notes
       * The manager `serverSettings` will be used unless overridden in the
       * options.
       */
      async startNew(options) {
        const model = await (0, restapi_1.startNew)(this.serverSettings, options === null || options === void 0 ? void 0 : options.name, options === null || options === void 0 ? void 0 : options.cwd);
        await this.refreshRunning();
        return this.connectTo({ model });
      }
      /**
       * Shut down a terminal session by name.
       */
      async shutdown(name2) {
        await (0, restapi_1.shutdownTerminal)(name2, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all terminal sessions.
       *
       * @returns A promise that resolves when all of the sessions are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all(this._names.map((name2) => (0, restapi_1.shutdownTerminal)(name2, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Execute a request to the server to poll running terminals and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof __1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        const names = models.map(({ name: name2 }) => name2).sort();
        if (names === this._names) {
          return;
        }
        this._names = names;
        this._terminalConnections.forEach((tc) => {
          if (!names.includes(tc.name)) {
            tc.dispose();
          }
        });
        this._runningChanged.emit(this._models);
      }
      /**
       * Handle a session starting.
       */
      _onStarted(terminalConnection) {
        this._terminalConnections.add(terminalConnection);
        terminalConnection.disposed.connect(this._onDisposed, this);
      }
      /**
       * Handle a session terminating.
       */
      _onDisposed(terminalConnection) {
        this._terminalConnections.delete(terminalConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      get _models() {
        return this._names.map((name2) => {
          return { name: name2 };
        });
      }
    };
    exports2.TerminalManager = TerminalManager;
    (function(TerminalManager2) {
      class NoopManager extends TerminalManager2 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Create a new terminal session - throw an error since it is not supported.
         *
         */
        async startNew(options) {
          return Promise.reject(new Error("Not implemented in no-op Terminal Manager"));
        }
        /*
         * Connect to a running terminal - throw an error since it is not supported.
         */
        connectTo(options) {
          throw Error("Not implemented in no-op Terminal Manager");
        }
        /**
         * Shut down a session by id - throw an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Terminal Manager"));
        }
        /**
         * Execute a request to the server to poll running sessions and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      TerminalManager2.NoopManager = NoopManager;
    })(TerminalManager || (exports2.TerminalManager = TerminalManager = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/terminal/index.js
var require_terminal4 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/terminal/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalAPI = exports2.Terminal = void 0;
    var Terminal = __importStar(require_terminal3());
    exports2.Terminal = Terminal;
    var TerminalAPI = __importStar(require_restapi8());
    exports2.TerminalAPI = TerminalAPI;
    __exportStar(require_manager9(), exports2);
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/user/index.js
var require_user2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/user/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserManager = void 0;
    var coreutils_12 = require_lib6();
    var coreutils_2 = require_dist();
    var polling_1 = (init_index_es62(), __toCommonJS(index_es6_exports2));
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var serverconnection_1 = require_serverconnection2();
    var basemanager_1 = require_basemanager2();
    var SERVICE_USER_URL = "api/me";
    var SERVICE_ID = "@jupyterlab/services:UserManager#user";
    var UserManager = class extends basemanager_1.BaseManager {
      /**
       * Create a new user manager.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._userChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._ready = this.requestUser().then(() => {
          if (this.isDisposed) {
            return;
          }
          this._isReady = true;
        }).catch((_5) => (
          // Return a promise that will never resolve, so user service is never ready
          // This typically occurs when the backend has no user service
          new Promise(() => {
          })
        ));
        this._pollSpecs = new polling_1.Poll({
          auto: false,
          factory: () => this.requestUser(),
          frequency: {
            interval: 61 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: SERVICE_ID,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        void this.ready.then(() => {
          void this._pollSpecs.start();
        });
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * Get the most recently fetched identity.
       */
      get identity() {
        return this._identity;
      }
      /**
       * Get the most recently fetched permissions.
       */
      get permissions() {
        return this._permissions;
      }
      /**
       * A signal emitted when the user changes.
       */
      get userChanged() {
        return this._userChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        this._pollSpecs.dispose();
        super.dispose();
      }
      /**
       * Force a refresh of the specs from the server.
       *
       * @returns A promise that resolves when the specs are fetched.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshUser() {
        await this._pollSpecs.refresh();
        await this._pollSpecs.tick;
      }
      /**
       * Execute a request to the server to poll the user and update state.
       */
      async requestUser() {
        if (this.isDisposed) {
          return;
        }
        const { baseUrl } = this.serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const url = coreutils_12.URLExt.join(baseUrl, SERVICE_USER_URL);
        const response = await makeRequest(url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        const oldUser = {
          identity: this._identity,
          permissions: this._permissions
        };
        const newUser = await response.json();
        const identity2 = newUser.identity;
        const { localStorage } = window;
        const data = localStorage.getItem(SERVICE_ID);
        if (data && (!identity2.initials || !identity2.color)) {
          const localUser = JSON.parse(data);
          identity2.initials = identity2.initials || localUser.initials || identity2.name.substring(0, 1);
          identity2.color = identity2.color || localUser.color || Private19.getRandomColor();
        }
        if (!coreutils_2.JSONExt.deepEqual(newUser, oldUser)) {
          this._identity = identity2;
          this._permissions = newUser.permissions;
          localStorage.setItem(SERVICE_ID, JSON.stringify(identity2));
          this._userChanged.emit(newUser);
        }
      }
    };
    exports2.UserManager = UserManager;
    var Private19;
    (function(Private20) {
      const userColors = [
        "var(--jp-collaborator-color1)",
        "var(--jp-collaborator-color2)",
        "var(--jp-collaborator-color3)",
        "var(--jp-collaborator-color4)",
        "var(--jp-collaborator-color5)",
        "var(--jp-collaborator-color6)",
        "var(--jp-collaborator-color7)"
      ];
      Private20.getRandomColor = () => userColors[Math.floor(Math.random() * userColors.length)];
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/workspace/index.js
var require_workspace2 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/workspace/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceManager = void 0;
    var coreutils_12 = require_lib6();
    var statedb_1 = require_lib7();
    var serverconnection_1 = require_serverconnection2();
    var SERVICE_WORKSPACES_URL = "api/workspaces";
    var WorkspaceManager = class extends statedb_1.DataConnector {
      /**
       * Create a new workspace manager.
       */
      constructor(options = {}) {
        var _a;
        super();
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch a workspace.
       *
       * @param id - The workspace's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async fetch(id) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private19.url(base, id);
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        return response.json();
      }
      /**
       * Fetch the list of workspace IDs that exist on the server.
       *
       * @returns A promise that resolves if successful.
       */
      async list() {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private19.url(base, "");
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        const result2 = await response.json();
        return result2.workspaces;
      }
      /**
       * Remove a workspace from the server.
       *
       * @param id - The workspaces's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async remove(id) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private19.url(base, id);
        const init = { method: "DELETE" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          const err = await ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Save a workspace.
       *
       * @param id - The workspace's ID.
       *
       * @param workspace - The workspace being saved.
       *
       * @returns A promise that resolves if successful.
       */
      async save(id, workspace) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private19.url(base, id);
        const init = { body: JSON.stringify(workspace), method: "PUT" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          const err = await ResponseError.create(response);
          throw err;
        }
      }
    };
    exports2.WorkspaceManager = WorkspaceManager;
    var Private19;
    (function(Private20) {
      function url(base, id) {
        const workspacesBase = coreutils_12.URLExt.join(base, SERVICE_WORKSPACES_URL);
        const result2 = coreutils_12.URLExt.join(workspacesBase, id);
        if (!result2.startsWith(workspacesBase)) {
          throw new Error("Can only be used for workspaces requests");
        }
        return result2;
      }
      Private20.url = url;
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/manager.js
var require_manager10 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServiceManager = void 0;
    var signaling_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var builder_1 = require_builder2();
    var contents_1 = require_contents2();
    var event_1 = require_event2();
    var kernel_1 = require_kernel4();
    var kernelspec_1 = require_kernelspec4();
    var nbconvert_1 = require_nbconvert2();
    var serverconnection_1 = require_serverconnection2();
    var session_1 = require_session4();
    var setting_1 = require_setting2();
    var terminal_1 = require_terminal4();
    var user_1 = require_user2();
    var workspace_1 = require_workspace2();
    var ServiceManager = class {
      /**
       * Construct a new services provider.
       */
      constructor(options = {}) {
        var _a, _b;
        this._isDisposed = false;
        this._connectionFailure = new signaling_1.Signal(this);
        this._isReady = false;
        const defaultDrive = options.defaultDrive;
        const serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        const standby = (_b = options.standby) !== null && _b !== void 0 ? _b : "when-hidden";
        const normalized = { defaultDrive, serverSettings, standby };
        this.serverSettings = serverSettings;
        this.contents = options.contents || new contents_1.ContentsManager(normalized);
        this.events = options.events || new event_1.EventManager(normalized);
        this.kernels = options.kernels || new kernel_1.KernelManager(normalized);
        this.sessions = options.sessions || new session_1.SessionManager({
          ...normalized,
          kernelManager: this.kernels
        });
        this.settings = options.settings || new setting_1.SettingManager(normalized);
        this.terminals = options.terminals || new terminal_1.TerminalManager(normalized);
        this.builder = options.builder || new builder_1.BuildManager(normalized);
        this.workspaces = options.workspaces || new workspace_1.WorkspaceManager(normalized);
        this.nbconvert = options.nbconvert || new nbconvert_1.NbConvertManager(normalized);
        this.kernelspecs = options.kernelspecs || new kernelspec_1.KernelSpecManager(normalized);
        this.user = options.user || new user_1.UserManager(normalized);
        this.kernelspecs.connectionFailure.connect(this._onConnectionFailure, this);
        this.sessions.connectionFailure.connect(this._onConnectionFailure, this);
        this.terminals.connectionFailure.connect(this._onConnectionFailure, this);
        const readyList = [this.sessions.ready, this.kernelspecs.ready];
        if (this.terminals.isAvailable()) {
          readyList.push(this.terminals.ready);
        }
        this._readyPromise = Promise.all(readyList).then(() => {
          this._isReady = true;
        });
      }
      /**
       * A signal emitted when there is a connection failure with the kernel.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Test whether the service manager is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
        this.contents.dispose();
        this.events.dispose();
        this.sessions.dispose();
        this.terminals.dispose();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._readyPromise;
      }
      _onConnectionFailure(sender, err) {
        this._connectionFailure.emit(err);
      }
    };
    exports2.ServiceManager = ServiceManager;
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/index.js
var require_lib8 = __commonJS({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@jupyterlab/services/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_basemanager2(), exports2);
    __exportStar(require_config2(), exports2);
    __exportStar(require_contents2(), exports2);
    __exportStar(require_event2(), exports2);
    __exportStar(require_kernel4(), exports2);
    __exportStar(require_kernelspec4(), exports2);
    __exportStar(require_manager10(), exports2);
    __exportStar(require_serverconnection2(), exports2);
    __exportStar(require_session4(), exports2);
    __exportStar(require_setting2(), exports2);
    __exportStar(require_terminal4(), exports2);
    __exportStar(require_user2(), exports2);
    __exportStar(require_workspace2(), exports2);
    __exportStar(require_nbconvert2(), exports2);
  }
});

// ../../node_modules/@jupyterlab/outputarea/lib/widget.js
var import_services2, import_coreutils13, OUTPUT_AREA_CLASS, OUTPUT_AREA_ITEM_CLASS, OUTPUT_AREA_OUTPUT_CLASS, OUTPUT_AREA_PROMPT_CLASS, OUTPUT_AREA_STDIN_HIDING_CLASS, OUTPUT_PROMPT_CLASS, EXECUTE_CLASS, OUTPUT_AREA_STDIN_ITEM_CLASS, STDIN_CLASS, STDIN_PROMPT_CLASS, STDIN_INPUT_CLASS, OUTPUT_PROMPT_OVERLAY, OutputArea, OutputPrompt, Stdin, Private17;
var init_widget = __esm({
  "../../node_modules/@jupyterlab/outputarea/lib/widget.js"() {
    init_lib2();
    import_services2 = __toESM(require_lib8());
    init_lib();
    import_coreutils13 = __toESM(require_dist());
    init_index_es615();
    init_index_es6();
    init_index_es64();
    OUTPUT_AREA_CLASS = "jp-OutputArea";
    OUTPUT_AREA_ITEM_CLASS = "jp-OutputArea-child";
    OUTPUT_AREA_OUTPUT_CLASS = "jp-OutputArea-output";
    OUTPUT_AREA_PROMPT_CLASS = "jp-OutputArea-prompt";
    OUTPUT_AREA_STDIN_HIDING_CLASS = "jp-OutputArea-stdin-hiding";
    OUTPUT_PROMPT_CLASS = "jp-OutputPrompt";
    EXECUTE_CLASS = "jp-OutputArea-executeResult";
    OUTPUT_AREA_STDIN_ITEM_CLASS = "jp-OutputArea-stdin-item";
    STDIN_CLASS = "jp-Stdin";
    STDIN_PROMPT_CLASS = "jp-Stdin-prompt";
    STDIN_INPUT_CLASS = "jp-Stdin-input";
    OUTPUT_PROMPT_OVERLAY = "jp-OutputArea-promptOverlay";
    OutputArea = class extends Widget {
      /**
       * Construct an output area widget.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        super();
        this.outputLengthChanged = new Signal(this);
        this._onIOPub = (msg) => {
          const model2 = this.model;
          const msgType = msg.header.msg_type;
          let output;
          const transient = msg.content.transient || {};
          const displayId = transient["display_id"];
          let targets;
          switch (msgType) {
            case "execute_result":
            case "display_data":
            case "stream":
            case "error":
              output = { ...msg.content, output_type: msgType };
              model2.add(output);
              break;
            case "clear_output": {
              const wait = msg.content.wait;
              model2.clear(wait);
              break;
            }
            case "update_display_data":
              output = { ...msg.content, output_type: "display_data" };
              targets = this._displayIdMap.get(displayId);
              if (targets) {
                for (const index2 of targets) {
                  model2.set(index2, output);
                }
              }
              break;
            default:
              break;
          }
          if (displayId && msgType === "display_data") {
            targets = this._displayIdMap.get(displayId) || [];
            targets.push(model2.length - 1);
            this._displayIdMap.set(displayId, targets);
          }
        };
        this._onExecuteReply = (msg) => {
          const model2 = this.model;
          const content = msg.content;
          if (content.status !== "ok") {
            return;
          }
          const payload = content && content.payload;
          if (!payload || !payload.length) {
            return;
          }
          const pages = payload.filter((i5) => i5.source === "page");
          if (!pages.length) {
            return;
          }
          const page = JSON.parse(JSON.stringify(pages[0]));
          const output = {
            output_type: "display_data",
            data: page.data,
            metadata: {}
          };
          model2.add(output);
        };
        this._displayIdMap = /* @__PURE__ */ new Map();
        this._minHeightTimeout = null;
        this._inputRequested = new Signal(this);
        this._toggleScrolling = new Signal(this);
        this._initialize = new Signal(this);
        this._outputTracker = new WidgetTracker({
          namespace: import_coreutils13.UUID.uuid4()
        });
        this._inputHistoryScope = "global";
        super.layout = new PanelLayout();
        this.addClass(OUTPUT_AREA_CLASS);
        this.contentFactory = (_a = options.contentFactory) !== null && _a !== void 0 ? _a : OutputArea.defaultContentFactory;
        this.rendermime = options.rendermime;
        this._maxNumberOutputs = (_b = options.maxNumberOutputs) !== null && _b !== void 0 ? _b : Infinity;
        this._translator = (_c = options.translator) !== null && _c !== void 0 ? _c : nullTranslator;
        this._inputHistoryScope = (_d = options.inputHistoryScope) !== null && _d !== void 0 ? _d : "global";
        const model = this.model = options.model;
        for (let i5 = 0; i5 < Math.min(model.length, this._maxNumberOutputs + 1); i5++) {
          const output = model.get(i5);
          this._insertOutput(i5, output);
        }
        model.changed.connect(this.onModelChanged, this);
        model.stateChanged.connect(this.onStateChanged, this);
        if (options.promptOverlay) {
          this._addPromptOverlay();
        }
      }
      /**
       * Narrow the type of OutputArea's layout prop
       */
      get layout() {
        return super.layout;
      }
      /**
       * A read-only sequence of the children widgets in the output area.
       */
      get widgets() {
        return this.layout.widgets;
      }
      /**
       * The kernel future associated with the output area.
       */
      get future() {
        return this._future;
      }
      set future(value) {
        if (this.model.isDisposed) {
          throw Error("Model is disposed");
        }
        if (this._future === value) {
          return;
        }
        if (this._future) {
          this._future.dispose();
        }
        this._future = value;
        this.model.clear();
        if (this.widgets.length) {
          this._clear();
          this.outputLengthChanged.emit(Math.min(this.model.length, this._maxNumberOutputs));
        }
        value.onIOPub = this._onIOPub;
        value.onReply = this._onExecuteReply;
        value.onStdin = (msg) => {
          if (import_services2.KernelMessage.isInputRequestMsg(msg)) {
            this.onInputRequest(msg, value);
          }
        };
      }
      /**
       * Signal emitted when an output area is requesting an input. The signal
       * carries the input widget that this class creates in response to the input
       * request.
       */
      get inputRequested() {
        return this._inputRequested;
      }
      /**
       * The maximum number of output items to display on top and bottom of cell output.
       *
       * ### Notes
       * It is set to Infinity if no trim is applied.
       */
      get maxNumberOutputs() {
        return this._maxNumberOutputs;
      }
      set maxNumberOutputs(limit) {
        if (limit <= 0) {
          console.warn(`OutputArea.maxNumberOutputs must be strictly positive.`);
          return;
        }
        const lastShown = this._maxNumberOutputs;
        this._maxNumberOutputs = limit;
        if (lastShown < limit) {
          this._showTrimmedOutputs(lastShown);
        }
      }
      /**
       * Dispose of the resources used by the output area.
       */
      dispose() {
        if (this._future) {
          this._future.dispose();
          this._future = null;
        }
        this._displayIdMap.clear();
        this._outputTracker.dispose();
        super.dispose();
      }
      /**
       * Follow changes on the model state.
       */
      onModelChanged(sender, args) {
        switch (args.type) {
          case "add":
            this._insertOutput(args.newIndex, args.newValues[0]);
            break;
          case "remove":
            if (this.widgets.length) {
              if (this.model.length === 0) {
                this._clear();
              } else {
                const startIndex = args.oldIndex;
                for (let i5 = 0; i5 < args.oldValues.length && startIndex < this.widgets.length; ++i5) {
                  const widget = this.widgets[startIndex];
                  widget.parent = null;
                  widget.dispose();
                }
                this._moveDisplayIdIndices(startIndex, args.oldValues.length);
                this._preventHeightChangeJitter();
              }
            }
            break;
          case "set":
            this._setOutput(args.newIndex, args.newValues[0]);
            break;
          default:
            break;
        }
        this.outputLengthChanged.emit(Math.min(this.model.length, this._maxNumberOutputs));
      }
      /**
       * Emitted when user requests toggling of the output scrolling mode.
       */
      get toggleScrolling() {
        return this._toggleScrolling;
      }
      get initialize() {
        return this._initialize;
      }
      /**
       * Add overlay allowing to toggle scrolling.
       */
      _addPromptOverlay() {
        const overlay = document.createElement("div");
        overlay.className = OUTPUT_PROMPT_OVERLAY;
        overlay.addEventListener("click", () => {
          this._toggleScrolling.emit();
        });
        this.node.appendChild(overlay);
        requestAnimationFrame(() => {
          this._initialize.emit();
        });
      }
      /**
       * Update indices in _displayIdMap in response to element remove from model items
       *
       * @param startIndex - The index of first element removed
       *
       * @param count - The number of elements removed from model items
       *
       */
      _moveDisplayIdIndices(startIndex, count) {
        this._displayIdMap.forEach((indices) => {
          const rangeEnd = startIndex + count;
          const numIndices = indices.length;
          for (let i5 = numIndices - 1; i5 >= 0; --i5) {
            const index2 = indices[i5];
            if (index2 >= startIndex && index2 < rangeEnd) {
              indices.splice(i5, 1);
            } else if (index2 >= rangeEnd) {
              indices[i5] -= count;
            }
          }
        });
      }
      /**
       * Follow changes on the output model state.
       */
      onStateChanged(sender, change) {
        const outputLength = Math.min(this.model.length, this._maxNumberOutputs);
        if (change) {
          if (change >= this._maxNumberOutputs) {
            return;
          }
          this._setOutput(change, this.model.get(change));
        } else {
          for (let i5 = 0; i5 < outputLength; i5++) {
            this._setOutput(i5, this.model.get(i5));
          }
        }
        this.outputLengthChanged.emit(outputLength);
      }
      /**
       * Clear the widget outputs.
       */
      _clear() {
        if (!this.widgets.length) {
          return;
        }
        const length = this.widgets.length;
        for (let i5 = 0; i5 < length; i5++) {
          const widget = this.widgets[0];
          widget.parent = null;
          widget.dispose();
        }
        this._displayIdMap.clear();
        this._preventHeightChangeJitter();
      }
      _preventHeightChangeJitter() {
        const rect = this.node.getBoundingClientRect();
        this.node.style.minHeight = `${rect.height}px`;
        if (this._minHeightTimeout) {
          window.clearTimeout(this._minHeightTimeout);
        }
        this._minHeightTimeout = window.setTimeout(() => {
          if (this.isDisposed) {
            return;
          }
          this.node.style.minHeight = "";
        }, 50);
      }
      /**
       * Handle an input request from a kernel.
       */
      onInputRequest(msg, future) {
        const factory = this.contentFactory;
        const stdinPrompt = msg.content.prompt;
        const password = msg.content.password;
        const panel = new Panel();
        panel.addClass(OUTPUT_AREA_ITEM_CLASS);
        panel.addClass(OUTPUT_AREA_STDIN_ITEM_CLASS);
        const prompt = factory.createOutputPrompt();
        prompt.addClass(OUTPUT_AREA_PROMPT_CLASS);
        panel.addWidget(prompt);
        const input = factory.createStdin({
          parent_header: msg.header,
          prompt: stdinPrompt,
          password,
          future,
          translator: this._translator,
          inputHistoryScope: this._inputHistoryScope
        });
        input.addClass(OUTPUT_AREA_OUTPUT_CLASS);
        panel.addWidget(input);
        if (this.model.length >= this.maxNumberOutputs) {
          this.maxNumberOutputs = this.model.length;
        }
        this._inputRequested.emit(input);
        const inputNode = input.node.getElementsByTagName("input")[0];
        void input.value.then((value) => {
          if (this.model.length >= this.maxNumberOutputs) {
            this.maxNumberOutputs = this.model.length + 1;
          }
          panel.addClass(OUTPUT_AREA_STDIN_HIDING_CLASS);
          this.model.add({
            output_type: "stream",
            name: "stdin",
            text: value + "\n"
          });
          inputNode.focus();
          window.setTimeout(() => {
            const focusedElement = document.activeElement;
            panel.dispose();
            if (focusedElement && focusedElement instanceof HTMLElement) {
              focusedElement.focus();
            }
          }, 500);
        });
        this.layout.addWidget(panel);
      }
      /**
       * Update an output in the layout in place.
       */
      _setOutput(index2, model) {
        if (index2 >= this._maxNumberOutputs) {
          return;
        }
        const panel = this.layout.widgets[index2];
        const renderer = panel.widgets ? panel.widgets.filter((it2) => "renderModel" in it2).pop() : panel;
        const mimeType = this.rendermime.preferredMimeType(model.data, model.trusted ? "any" : "ensure");
        if (Private17.currentPreferredMimetype.get(renderer) === mimeType && OutputArea.isIsolated(mimeType, model.metadata) === renderer instanceof Private17.IsolatedRenderer) {
          void renderer.renderModel(model);
        } else {
          this.layout.widgets[index2].dispose();
          this._insertOutput(index2, model);
        }
      }
      /**
       * Render and insert a single output into the layout.
       *
       * @param index - The index of the output to be inserted.
       * @param model - The model of the output to be inserted.
       */
      _insertOutput(index2, model) {
        if (index2 > this._maxNumberOutputs) {
          return;
        }
        const layout = this.layout;
        if (index2 === this._maxNumberOutputs) {
          const warning = new Private17.TrimmedOutputs(this._maxNumberOutputs, () => {
            const lastShown = this._maxNumberOutputs;
            this._maxNumberOutputs = Infinity;
            this._showTrimmedOutputs(lastShown);
          });
          layout.insertWidget(index2, this._wrappedOutput(warning));
        } else {
          let output = this.createOutputItem(model);
          if (output) {
            output.toggleClass(EXECUTE_CLASS, model.executionCount !== null);
          } else {
            output = new Widget();
          }
          if (!this._outputTracker.has(output)) {
            void this._outputTracker.add(output);
          }
          layout.insertWidget(index2, output);
        }
      }
      /**
       * A widget tracker for individual output widgets in the output area.
       */
      get outputTracker() {
        return this._outputTracker;
      }
      /**
       * Dispose information message and show output models from the given
       * index to maxNumberOutputs
       *
       * @param lastShown Starting model index to insert.
       */
      _showTrimmedOutputs(lastShown) {
        this.widgets[lastShown].dispose();
        for (let idx = lastShown; idx < this.model.length; idx++) {
          this._insertOutput(idx, this.model.get(idx));
        }
        this.outputLengthChanged.emit(Math.min(this.model.length, this._maxNumberOutputs));
      }
      /**
       * Create an output item with a prompt and actual output
       *
       * @returns a rendered widget, or null if we cannot render
       * #### Notes
       */
      createOutputItem(model) {
        const output = this.createRenderedMimetype(model);
        if (!output) {
          return null;
        }
        return this._wrappedOutput(output, model.executionCount);
      }
      /**
       * Render a mimetype
       */
      createRenderedMimetype(model) {
        const mimeType = this.rendermime.preferredMimeType(model.data, model.trusted ? "any" : "ensure");
        if (!mimeType) {
          return null;
        }
        let output = this.rendermime.createRenderer(mimeType);
        const isolated = OutputArea.isIsolated(mimeType, model.metadata);
        if (isolated === true) {
          output = new Private17.IsolatedRenderer(output);
        }
        Private17.currentPreferredMimetype.set(output, mimeType);
        output.renderModel(model).catch((error) => {
          const pre = document.createElement("pre");
          const trans = this._translator.load("jupyterlab");
          pre.textContent = trans.__("Javascript Error: %1", error.message);
          output.node.appendChild(pre);
          output.node.className = "lm-Widget jp-RenderedText";
          output.node.setAttribute("data-mime-type", "application/vnd.jupyter.stderr");
        });
        return output;
      }
      /**
       * Wrap a output widget within a output panel
       *
       * @param output Output widget to wrap
       * @param executionCount Execution count
       * @returns The output panel
       */
      _wrappedOutput(output, executionCount = null) {
        const panel = new Private17.OutputPanel();
        panel.addClass(OUTPUT_AREA_ITEM_CLASS);
        const prompt = this.contentFactory.createOutputPrompt();
        prompt.executionCount = executionCount;
        prompt.addClass(OUTPUT_AREA_PROMPT_CLASS);
        panel.addWidget(prompt);
        output.addClass(OUTPUT_AREA_OUTPUT_CLASS);
        panel.addWidget(output);
        return panel;
      }
    };
    (function(OutputArea2) {
      async function execute(code3, output, sessionContext, metadata) {
        var _a;
        let stopOnError = true;
        if (metadata && Array.isArray(metadata.tags) && metadata.tags.indexOf("raises-exception") !== -1) {
          stopOnError = false;
        }
        const content = {
          code: code3,
          stop_on_error: stopOnError
        };
        const kernel = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (!kernel) {
          throw new Error("Session has no kernel.");
        }
        const future = kernel.requestExecute(content, false, metadata);
        output.future = future;
        return future.done;
      }
      OutputArea2.execute = execute;
      function isIsolated(mimeType, metadata) {
        const mimeMd = metadata[mimeType];
        if (mimeMd && mimeMd["isolated"] !== void 0) {
          return !!mimeMd["isolated"];
        } else {
          return !!metadata["isolated"];
        }
      }
      OutputArea2.isIsolated = isIsolated;
      class ContentFactory {
        /**
         * Create the output prompt for the widget.
         */
        createOutputPrompt() {
          return new OutputPrompt();
        }
        /**
         * Create an stdin widget.
         */
        createStdin(options) {
          return new Stdin(options);
        }
      }
      OutputArea2.ContentFactory = ContentFactory;
      OutputArea2.defaultContentFactory = new ContentFactory();
    })(OutputArea || (OutputArea = {}));
    OutputPrompt = class extends Widget {
      /*
       * Create an output prompt widget.
       */
      constructor() {
        super();
        this._executionCount = null;
        this.addClass(OUTPUT_PROMPT_CLASS);
      }
      /**
       * The execution count for the prompt.
       */
      get executionCount() {
        return this._executionCount;
      }
      set executionCount(value) {
        this._executionCount = value;
        if (value === null) {
          this.node.textContent = "";
        } else {
          this.node.textContent = `[${value}]:`;
        }
      }
    };
    Stdin = class extends Widget {
      static _historyIx(key, ix) {
        const history2 = Stdin._history.get(key);
        if (!history2) {
          return void 0;
        }
        const len = history2.length;
        if (ix <= 0) {
          return len + ix;
        }
      }
      static _historyAt(key, ix) {
        const history2 = Stdin._history.get(key);
        if (!history2) {
          return void 0;
        }
        const len = history2.length;
        const ixpos = Stdin._historyIx(key, ix);
        if (ixpos !== void 0 && ixpos < len) {
          return history2[ixpos];
        }
      }
      static _historyPush(key, line) {
        const history2 = Stdin._history.get(key);
        history2.push(line);
        if (history2.length > 1e3) {
          history2.shift();
        }
      }
      static _historySearch(key, pat, ix, reverse = true) {
        const history2 = Stdin._history.get(key);
        const len = history2.length;
        const ixpos = Stdin._historyIx(key, ix);
        const substrFound = (x4) => x4.search(pat) !== -1;
        if (ixpos === void 0) {
          return;
        }
        if (reverse) {
          if (ixpos === 0) {
            return;
          }
          const ixFound = history2.slice(0, ixpos).findLastIndex(substrFound);
          if (ixFound !== -1) {
            return ixFound - len;
          }
        } else {
          if (ixpos >= len - 1) {
            return;
          }
          const ixFound = history2.slice(ixpos + 1).findIndex(substrFound);
          if (ixFound !== -1) {
            return ixFound - len + ixpos + 1;
          }
        }
      }
      /**
       * Construct a new input widget.
       */
      constructor(options) {
        var _a;
        super({
          node: Private17.createInputWidgetNode(options.prompt, options.password)
        });
        this._promise = new import_coreutils13.PromiseDelegate();
        this._resolved = false;
        this.addClass(STDIN_CLASS);
        this._future = options.future;
        this._historyIndex = 0;
        this._historyKey = options.inputHistoryScope === "session" ? options.parent_header.session : "";
        this._historyPat = "";
        this._parentHeader = options.parent_header;
        this._password = options.password;
        this._trans = ((_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator).load("jupyterlab");
        this._value = options.prompt + " ";
        this._input = this.node.getElementsByTagName("input")[0];
        this._input.placeholder = this._trans.__("\u2191\u2193 for history. Search history with c-\u2191/c-\u2193");
        if (!Stdin._history.has(this._historyKey)) {
          Stdin._history.set(this._historyKey, []);
        }
      }
      /**
       * The value of the widget.
       */
      get value() {
        return this._promise.promise.then(() => this._value);
      }
      /**
       * Handle the DOM events for the widget.
       *
       * @param event - The DOM event sent to the widget.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the dock panel's node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        if (this._resolved) {
          event.preventDefault();
          return;
        }
        const input = this._input;
        if (event.type === "keydown") {
          if (event.key === "Enter") {
            this.resetSearch();
            this._future.sendInputReply({
              status: "ok",
              value: input.value
            }, this._parentHeader);
            if (this._password) {
              this._value += "\xB7\xB7\xB7\xB7\xB7\xB7\xB7\xB7";
            } else {
              this._value += input.value;
              Stdin._historyPush(this._historyKey, input.value);
            }
            this._resolved = true;
            this._promise.resolve(void 0);
          } else if (event.key === "Escape") {
            this.resetSearch();
            input.blur();
          } else if (event.ctrlKey && (event.key === "ArrowUp" || event.key === "ArrowDown")) {
            if (this._historyPat === "") {
              this._historyPat = input.value;
            }
            const reverse = event.key === "ArrowUp";
            const searchHistoryIx = Stdin._historySearch(this._historyKey, this._historyPat, this._historyIndex, reverse);
            if (searchHistoryIx !== void 0) {
              const historyLine = Stdin._historyAt(this._historyKey, searchHistoryIx);
              if (historyLine !== void 0) {
                if (this._historyIndex === 0) {
                  this._valueCache = input.value;
                }
                this._setInputValue(historyLine);
                this._historyIndex = searchHistoryIx;
                event.preventDefault();
              }
            }
          } else if (event.key === "ArrowUp") {
            this.resetSearch();
            const historyLine = Stdin._historyAt(this._historyKey, this._historyIndex - 1);
            if (historyLine) {
              if (this._historyIndex === 0) {
                this._valueCache = input.value;
              }
              this._setInputValue(historyLine);
              --this._historyIndex;
              event.preventDefault();
            }
          } else if (event.key === "ArrowDown") {
            this.resetSearch();
            if (this._historyIndex === 0) {
            } else if (this._historyIndex === -1) {
              this._setInputValue(this._valueCache);
              ++this._historyIndex;
            } else {
              const historyLine = Stdin._historyAt(this._historyKey, this._historyIndex + 1);
              if (historyLine) {
                this._setInputValue(historyLine);
                ++this._historyIndex;
              }
            }
          }
        }
      }
      resetSearch() {
        this._historyPat = "";
      }
      /**
       * Handle `after-attach` messages sent to the widget.
       */
      onAfterAttach(msg) {
        this._input.addEventListener("keydown", this);
        this._input.focus();
      }
      /**
       * Handle `before-detach` messages sent to the widget.
       */
      onBeforeDetach(msg) {
        this._input.removeEventListener("keydown", this);
      }
      _setInputValue(value) {
        this._input.value = value;
        this._input.setSelectionRange(value.length, value.length);
      }
    };
    Stdin._history = /* @__PURE__ */ new Map();
    (function(Private19) {
      function createInputWidgetNode(prompt, password) {
        const node = document.createElement("div");
        const promptNode = document.createElement("pre");
        promptNode.className = STDIN_PROMPT_CLASS;
        promptNode.textContent = prompt;
        const input = document.createElement("input");
        input.className = STDIN_INPUT_CLASS;
        if (password) {
          input.type = "password";
        }
        node.appendChild(promptNode);
        promptNode.appendChild(input);
        return node;
      }
      Private19.createInputWidgetNode = createInputWidgetNode;
      class IsolatedRenderer extends Widget {
        /**
         * Create an isolated renderer.
         */
        constructor(wrapped) {
          super({ node: document.createElement("iframe") });
          this.addClass("jp-mod-isolated");
          this._wrapped = wrapped;
          const iframe = this.node;
          iframe.frameBorder = "0";
          iframe.scrolling = "auto";
          iframe.addEventListener("load", () => {
            iframe.contentDocument.open();
            iframe.contentDocument.write(this._wrapped.node.innerHTML);
            iframe.contentDocument.close();
            const body = iframe.contentDocument.body;
            iframe.style.height = `${body.scrollHeight}px`;
            iframe.heightChangeObserver = new ResizeObserver(() => {
              iframe.style.height = `${body.scrollHeight}px`;
            });
            iframe.heightChangeObserver.observe(body);
          });
        }
        /**
         * Render a mime model.
         *
         * @param model - The mime model to render.
         *
         * @returns A promise which resolves when rendering is complete.
         *
         * #### Notes
         * This method may be called multiple times during the lifetime
         * of the widget to update it if and when new data is available.
         */
        renderModel(model) {
          return this._wrapped.renderModel(model);
        }
      }
      Private19.IsolatedRenderer = IsolatedRenderer;
      Private19.currentPreferredMimetype = new AttachedProperty2({
        name: "preferredMimetype",
        create: (owner) => ""
      });
      class OutputPanel extends Panel {
        /**
         * Construct a new `OutputPanel` widget.
         */
        constructor(options) {
          super(options);
        }
        /**
         * A callback that focuses on the widget.
         */
        _onContext(_5) {
          this.node.focus();
        }
        /**
         * Handle `after-attach` messages sent to the widget.
         */
        onAfterAttach(msg) {
          super.onAfterAttach(msg);
          this.node.addEventListener("contextmenu", this._onContext.bind(this));
        }
        /**
         * Handle `before-detach` messages sent to the widget.
         */
        onBeforeDetach(msg) {
          super.onAfterDetach(msg);
          this.node.removeEventListener("contextmenu", this._onContext.bind(this));
        }
      }
      Private19.OutputPanel = OutputPanel;
      class TrimmedOutputs extends Widget {
        /**
         * Widget constructor
         *
         * ### Notes
         * The widget will be disposed on click after calling the callback.
         *
         * @param maxNumberOutputs Maximal number of outputs to display
         * @param _onClick Callback on click event on the widget
         */
        constructor(maxNumberOutputs, onClick) {
          const node = document.createElement("div");
          const title = `The first ${maxNumberOutputs} are displayed`;
          const msg = "Show more outputs";
          node.insertAdjacentHTML("afterbegin", `<a title=${title}>
          <pre>${msg}</pre>
        </a>`);
          super({
            node
          });
          this._onClick = onClick;
          this.addClass("jp-TrimmedOutputs");
          this.addClass("jp-RenderedHTMLCommon");
        }
        /**
         * Handle the DOM events for widget.
         *
         * @param event - The DOM event sent to the widget.
         *
         * #### Notes
         * This method implements the DOM `EventListener` interface and is
         * called in response to events on the widget's DOM node. It should
         * not be called directly by user code.
         */
        handleEvent(event) {
          if (event.type === "click") {
            this._onClick(event);
          }
        }
        /**
         * Handle `after-attach` messages for the widget.
         */
        onAfterAttach(msg) {
          super.onAfterAttach(msg);
          this.node.addEventListener("click", this);
        }
        /**
         * A message handler invoked on a `'before-detach'`
         * message
         */
        onBeforeDetach(msg) {
          super.onBeforeDetach(msg);
          this.node.removeEventListener("click", this);
        }
      }
      Private19.TrimmedOutputs = TrimmedOutputs;
    })(Private17 || (Private17 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/lib/index.js
var init_lib9 = __esm({
  "../../node_modules/@jupyterlab/outputarea/lib/index.js"() {
    init_model();
    init_widget();
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/renderer.js
var import_coreutils14, WidgetRenderer;
var init_renderer = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/renderer.js"() {
    import_coreutils14 = __toESM(require_dist());
    init_index_es64();
    WidgetRenderer = class extends Panel {
      constructor(options, manager) {
        super();
        this._manager = new import_coreutils14.PromiseDelegate();
        this._rerenderMimeModel = null;
        this.mimeType = options.mimeType;
        if (manager) {
          this.manager = manager;
        }
      }
      /**
       * The widget manager.
       */
      set manager(value) {
        value.restored.connect(this._rerender, this);
        this._manager.resolve(value);
      }
      async renderModel(model) {
        const source = model.data[this.mimeType];
        this.node.textContent = "Loading widget...";
        const manager = await this._manager.promise;
        if (source.model_id === "") {
          this.hide();
          return Promise.resolve();
        }
        let wModel;
        try {
          wModel = await manager.get_model(source.model_id);
        } catch (err) {
          if (manager.restoredStatus) {
            this.node.textContent = "Error displaying widget: model not found";
            this.addClass("jupyter-widgets");
            console.error(err);
            return;
          }
          this._rerenderMimeModel = model;
          return;
        }
        this._rerenderMimeModel = null;
        let widget;
        try {
          widget = (await manager.create_view(wModel)).luminoWidget;
        } catch (err) {
          this.node.textContent = "Error displaying widget";
          this.addClass("jupyter-widgets");
          console.error(err);
          return;
        }
        this.node.textContent = "";
        this.addWidget(widget);
        widget.disposed.connect(() => {
          this.hide();
          source.model_id = "";
        });
      }
      /**
       * Dispose the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._manager = null;
        super.dispose();
      }
      _rerender() {
        if (this._rerenderMimeModel) {
          this.node.textContent = "";
          this.removeClass("jupyter-widgets");
          this.renderModel(this._rerenderMimeModel);
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/utils.js
function difference(a4, b4) {
  return a4.filter((v2) => b4.indexOf(v2) === -1);
}
function isEqual(a4, b4) {
  return (0, import_isEqual.default)(a4, b4);
}
function uuid() {
  return import_coreutils15.UUID.uuid4();
}
function resolvePromisesDict(d6) {
  const keys2 = Object.keys(d6);
  const values2 = [];
  keys2.forEach(function(key) {
    values2.push(d6[key]);
  });
  return Promise.all(values2).then((v2) => {
    const d7 = {};
    for (let i5 = 0; i5 < keys2.length; i5++) {
      d7[keys2[i5]] = v2[i5];
    }
    return d7;
  });
}
function reject(message, log) {
  return function promiseRejection(error) {
    if (log) {
      console.error(new Error(message));
    }
    throw error;
  };
}
function put_buffers(state, buffer_paths, buffers) {
  for (let i5 = 0; i5 < buffer_paths.length; i5++) {
    const buffer_path = buffer_paths[i5];
    let buffer = buffers[i5];
    if (!(buffer instanceof DataView)) {
      buffer = new DataView(buffer instanceof ArrayBuffer ? buffer : buffer.buffer);
    }
    let obj = state;
    for (let j2 = 0; j2 < buffer_path.length - 1; j2++) {
      obj = obj[buffer_path[j2]];
    }
    obj[buffer_path[buffer_path.length - 1]] = buffer;
  }
}
function isSerializable(object2) {
  var _a;
  return (_a = typeof object2 === "object" && object2 && "toJSON" in object2) !== null && _a !== void 0 ? _a : false;
}
function isObject(data) {
  return import_coreutils15.JSONExt.isObject(data);
}
function remove_buffers(state) {
  const buffers = [];
  const buffer_paths = [];
  function remove2(obj, path2) {
    if (isSerializable(obj)) {
      obj = obj.toJSON();
    }
    if (Array.isArray(obj)) {
      let is_cloned = false;
      for (let i5 = 0; i5 < obj.length; i5++) {
        const value = obj[i5];
        if (value) {
          if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
            if (!is_cloned) {
              obj = obj.slice();
              is_cloned = true;
            }
            buffers.push(ArrayBuffer.isView(value) ? value.buffer : value);
            buffer_paths.push(path2.concat([i5]));
            obj[i5] = null;
          } else {
            const new_value = remove2(value, path2.concat([i5]));
            if (new_value !== value) {
              if (!is_cloned) {
                obj = obj.slice();
                is_cloned = true;
              }
              obj[i5] = new_value;
            }
          }
        }
      }
    } else if (isObject(obj)) {
      for (const key in obj) {
        let is_cloned = false;
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          const value = obj[key];
          if (value) {
            if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
              if (!is_cloned) {
                obj = Object.assign({}, obj);
                is_cloned = true;
              }
              buffers.push(ArrayBuffer.isView(value) ? value.buffer : value);
              buffer_paths.push(path2.concat([key]));
              delete obj[key];
            } else {
              const new_value = remove2(value, path2.concat([key]));
              if (new_value !== value) {
                if (!is_cloned) {
                  obj = Object.assign({}, obj);
                  is_cloned = true;
                }
                obj[key] = new_value;
              }
            }
          }
        }
      }
    }
    return obj;
  }
  const new_state = remove2(state, []);
  return { state: new_state, buffers, buffer_paths };
}
var import_coreutils15, import_isEqual, assign, BROKEN_FILE_SVG_ICON;
var init_utils = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/utils.js"() {
    import_coreutils15 = __toESM(require_dist());
    import_isEqual = __toESM(require_isEqual());
    assign = Object.assign || function(t10, ...args) {
      for (let i5 = 1; i5 < args.length; i5++) {
        const s7 = args[i5];
        for (const p3 in s7) {
          if (Object.prototype.hasOwnProperty.call(s7, p3)) {
            t10[p3] = s7[p3];
          }
        }
      }
      return t10;
    };
    BROKEN_FILE_SVG_ICON = `<svg style="height:50%;max-height: 50px;" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
<g >
  <g transform="translate(0.24520123,0.93464292)">
    <path  d="M 8.2494641,21.074514 V 5.6225142 c 0,-0.314 0.254,-0.567 0.57,-0.567 H 29.978464 c 2.388,0 9.268,5.8269998 9.268,8.3029998 v 5.5835 l -3.585749,4.407396 -2.772971,-3.535534 -5.126524,3.414213 -5.944543,-3.237436 -5.722718,3.06066 z m 30.9969999,3.8675 v 15.5835 c 0,0.314 -0.254,0.567 -0.57,0.567 H 8.8194641 c -0.315,0.002 -0.57,-0.251 -0.57,-0.566 v -15.452 l 7.8444949,2.628449 5.656854,-2.65165 4.24264,3.005204 5.833631,-3.237437 3.712311,3.944543 z" style="fill:url(#linearGradient3448);stroke:#888a85"  />
    <path d="m 30.383464,12.110514 c 4.108,0.159 7.304,-0.978 8.867,1.446 0.304,-3.9679998 -7.254,-8.8279998 -9.285,-8.4979998 0.813,0.498 0.418,7.0519998 0.418,7.0519998 z" style="fill:url(#linearGradient3445);stroke:#868a84" />
    <path enable-background="new" d="m 31.443464,11.086514 c 2.754,-0.019 4.106,-0.49 5.702,0.19 -1.299,-1.8809998 -4.358,-3.3439998 -5.728,-4.0279998 0.188,0.775 0.026,3.8379998 0.026,3.8379998 z" style="opacity:0.36930003;fill:none;stroke:url(#linearGradient3442)" />
  </g>
</g>
</svg>`;
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/backbone-patch.js
function set(key, val, options) {
  if (key == null) {
    return this;
  }
  let attrs;
  if (import_coreutils16.JSONExt.isObject(key)) {
    attrs = key;
    options = val;
  } else {
    (attrs = {})[key] = val;
  }
  options || (options = {});
  if (!this._validate(attrs, options)) {
    return false;
  }
  const unset = options.unset;
  const silent = options.silent;
  const changes = [];
  const changing = this._changing;
  this._changing = true;
  try {
    if (!changing) {
      this._previousAttributes = Object.assign({}, this.attributes);
      this.changed = {};
    }
    const current = this.attributes;
    const changed = this.changed;
    const prev = this._previousAttributes;
    for (const attr in attrs) {
      val = attrs[attr];
      if (!isEqual(current[attr], val)) {
        changes.push(attr);
      }
      if (!isEqual(prev[attr], val)) {
        changed[attr] = val;
      } else {
        delete changed[attr];
      }
      unset ? delete current[attr] : current[attr] = val;
    }
    this.id = this.get(this.idAttribute);
    if (!silent) {
      if (changes.length) {
        this._pending = options;
      }
      for (let i5 = 0; i5 < changes.length; i5++) {
        this.trigger("change:" + changes[i5], this, current[changes[i5]], options);
      }
    }
    if (changing) {
      return this;
    }
    if (!silent) {
      while (this._pending) {
        options = this._pending;
        this._pending = false;
        this.trigger("change", this, options);
      }
    }
  } finally {
    this._pending = false;
    this._changing = false;
  }
  return this;
}
var import_coreutils16;
var init_backbone_patch = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/backbone-patch.js"() {
    init_utils();
    import_coreutils16 = __toESM(require_dist());
  }
});

// ../../node_modules/underscore/modules/_setup.js
var VERSION, root, ArrayProto, ObjProto, SymbolProto, push, slice, toString, hasOwnProperty, supportsArrayBuffer, supportsDataView, nativeIsArray, nativeKeys, nativeCreate, nativeIsView, _isNaN, _isFinite, hasEnumBug, nonEnumerableProps, MAX_ARRAY_INDEX;
var init_setup = __esm({
  "../../node_modules/underscore/modules/_setup.js"() {
    VERSION = "1.13.6";
    root = typeof self == "object" && self.self === self && self || typeof globalThis == "object" && globalThis.global === globalThis && globalThis || Function("return this")() || {};
    ArrayProto = Array.prototype;
    ObjProto = Object.prototype;
    SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
    push = ArrayProto.push;
    slice = ArrayProto.slice;
    toString = ObjProto.toString;
    hasOwnProperty = ObjProto.hasOwnProperty;
    supportsArrayBuffer = typeof ArrayBuffer !== "undefined";
    supportsDataView = typeof DataView !== "undefined";
    nativeIsArray = Array.isArray;
    nativeKeys = Object.keys;
    nativeCreate = Object.create;
    nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
    _isNaN = isNaN;
    _isFinite = isFinite;
    hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
    nonEnumerableProps = [
      "valueOf",
      "isPrototypeOf",
      "toString",
      "propertyIsEnumerable",
      "hasOwnProperty",
      "toLocaleString"
    ];
    MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  }
});

// ../../node_modules/underscore/modules/restArguments.js
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index2 = 0;
    for (; index2 < length; index2++) {
      rest2[index2] = arguments[index2 + startIndex];
    }
    switch (startIndex) {
      case 0:
        return func.call(this, rest2);
      case 1:
        return func.call(this, arguments[0], rest2);
      case 2:
        return func.call(this, arguments[0], arguments[1], rest2);
    }
    var args = Array(startIndex + 1);
    for (index2 = 0; index2 < startIndex; index2++) {
      args[index2] = arguments[index2];
    }
    args[startIndex] = rest2;
    return func.apply(this, args);
  };
}
var init_restArguments = __esm({
  "../../node_modules/underscore/modules/restArguments.js"() {
  }
});

// ../../node_modules/underscore/modules/isObject.js
function isObject2(obj) {
  var type2 = typeof obj;
  return type2 === "function" || type2 === "object" && !!obj;
}
var init_isObject = __esm({
  "../../node_modules/underscore/modules/isObject.js"() {
  }
});

// ../../node_modules/underscore/modules/isNull.js
function isNull(obj) {
  return obj === null;
}
var init_isNull = __esm({
  "../../node_modules/underscore/modules/isNull.js"() {
  }
});

// ../../node_modules/underscore/modules/isUndefined.js
function isUndefined2(obj) {
  return obj === void 0;
}
var init_isUndefined = __esm({
  "../../node_modules/underscore/modules/isUndefined.js"() {
  }
});

// ../../node_modules/underscore/modules/isBoolean.js
function isBoolean(obj) {
  return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
}
var init_isBoolean = __esm({
  "../../node_modules/underscore/modules/isBoolean.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/isElement.js
function isElement2(obj) {
  return !!(obj && obj.nodeType === 1);
}
var init_isElement = __esm({
  "../../node_modules/underscore/modules/isElement.js"() {
  }
});

// ../../node_modules/underscore/modules/_tagTester.js
function tagTester(name2) {
  var tag = "[object " + name2 + "]";
  return function(obj) {
    return toString.call(obj) === tag;
  };
}
var init_tagTester = __esm({
  "../../node_modules/underscore/modules/_tagTester.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/isString.js
var isString_default;
var init_isString = __esm({
  "../../node_modules/underscore/modules/isString.js"() {
    init_tagTester();
    isString_default = tagTester("String");
  }
});

// ../../node_modules/underscore/modules/isNumber.js
var isNumber_default;
var init_isNumber = __esm({
  "../../node_modules/underscore/modules/isNumber.js"() {
    init_tagTester();
    isNumber_default = tagTester("Number");
  }
});

// ../../node_modules/underscore/modules/isDate.js
var isDate_default;
var init_isDate = __esm({
  "../../node_modules/underscore/modules/isDate.js"() {
    init_tagTester();
    isDate_default = tagTester("Date");
  }
});

// ../../node_modules/underscore/modules/isRegExp.js
var isRegExp_default;
var init_isRegExp = __esm({
  "../../node_modules/underscore/modules/isRegExp.js"() {
    init_tagTester();
    isRegExp_default = tagTester("RegExp");
  }
});

// ../../node_modules/underscore/modules/isError.js
var isError_default;
var init_isError = __esm({
  "../../node_modules/underscore/modules/isError.js"() {
    init_tagTester();
    isError_default = tagTester("Error");
  }
});

// ../../node_modules/underscore/modules/isSymbol.js
var isSymbol_default;
var init_isSymbol = __esm({
  "../../node_modules/underscore/modules/isSymbol.js"() {
    init_tagTester();
    isSymbol_default = tagTester("Symbol");
  }
});

// ../../node_modules/underscore/modules/isArrayBuffer.js
var isArrayBuffer_default;
var init_isArrayBuffer = __esm({
  "../../node_modules/underscore/modules/isArrayBuffer.js"() {
    init_tagTester();
    isArrayBuffer_default = tagTester("ArrayBuffer");
  }
});

// ../../node_modules/underscore/modules/isFunction.js
var isFunction2, nodelist, isFunction_default;
var init_isFunction = __esm({
  "../../node_modules/underscore/modules/isFunction.js"() {
    init_tagTester();
    init_setup();
    isFunction2 = tagTester("Function");
    nodelist = root.document && root.document.childNodes;
    if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
      isFunction2 = function(obj) {
        return typeof obj == "function" || false;
      };
    }
    isFunction_default = isFunction2;
  }
});

// ../../node_modules/underscore/modules/_hasObjectTag.js
var hasObjectTag_default;
var init_hasObjectTag = __esm({
  "../../node_modules/underscore/modules/_hasObjectTag.js"() {
    init_tagTester();
    hasObjectTag_default = tagTester("Object");
  }
});

// ../../node_modules/underscore/modules/_stringTagBug.js
var hasStringTagBug, isIE11;
var init_stringTagBug = __esm({
  "../../node_modules/underscore/modules/_stringTagBug.js"() {
    init_setup();
    init_hasObjectTag();
    hasStringTagBug = supportsDataView && hasObjectTag_default(new DataView(new ArrayBuffer(8)));
    isIE11 = typeof Map !== "undefined" && hasObjectTag_default(/* @__PURE__ */ new Map());
  }
});

// ../../node_modules/underscore/modules/isDataView.js
function ie10IsDataView(obj) {
  return obj != null && isFunction_default(obj.getInt8) && isArrayBuffer_default(obj.buffer);
}
var isDataView, isDataView_default;
var init_isDataView = __esm({
  "../../node_modules/underscore/modules/isDataView.js"() {
    init_tagTester();
    init_isFunction();
    init_isArrayBuffer();
    init_stringTagBug();
    isDataView = tagTester("DataView");
    isDataView_default = hasStringTagBug ? ie10IsDataView : isDataView;
  }
});

// ../../node_modules/underscore/modules/isArray.js
var isArray_default;
var init_isArray = __esm({
  "../../node_modules/underscore/modules/isArray.js"() {
    init_setup();
    init_tagTester();
    isArray_default = nativeIsArray || tagTester("Array");
  }
});

// ../../node_modules/underscore/modules/_has.js
function has(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}
var init_has = __esm({
  "../../node_modules/underscore/modules/_has.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/isArguments.js
var isArguments, isArguments_default;
var init_isArguments = __esm({
  "../../node_modules/underscore/modules/isArguments.js"() {
    init_tagTester();
    init_has();
    isArguments = tagTester("Arguments");
    (function() {
      if (!isArguments(arguments)) {
        isArguments = function(obj) {
          return has(obj, "callee");
        };
      }
    })();
    isArguments_default = isArguments;
  }
});

// ../../node_modules/underscore/modules/isFinite.js
function isFinite2(obj) {
  return !isSymbol_default(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
}
var init_isFinite = __esm({
  "../../node_modules/underscore/modules/isFinite.js"() {
    init_setup();
    init_isSymbol();
  }
});

// ../../node_modules/underscore/modules/isNaN.js
function isNaN2(obj) {
  return isNumber_default(obj) && _isNaN(obj);
}
var init_isNaN = __esm({
  "../../node_modules/underscore/modules/isNaN.js"() {
    init_setup();
    init_isNumber();
  }
});

// ../../node_modules/underscore/modules/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var init_constant = __esm({
  "../../node_modules/underscore/modules/constant.js"() {
  }
});

// ../../node_modules/underscore/modules/_createSizePropertyCheck.js
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  };
}
var init_createSizePropertyCheck = __esm({
  "../../node_modules/underscore/modules/_createSizePropertyCheck.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/_shallowProperty.js
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}
var init_shallowProperty = __esm({
  "../../node_modules/underscore/modules/_shallowProperty.js"() {
  }
});

// ../../node_modules/underscore/modules/_getByteLength.js
var getByteLength_default;
var init_getByteLength = __esm({
  "../../node_modules/underscore/modules/_getByteLength.js"() {
    init_shallowProperty();
    getByteLength_default = shallowProperty("byteLength");
  }
});

// ../../node_modules/underscore/modules/_isBufferLike.js
var isBufferLike_default;
var init_isBufferLike = __esm({
  "../../node_modules/underscore/modules/_isBufferLike.js"() {
    init_createSizePropertyCheck();
    init_getByteLength();
    isBufferLike_default = createSizePropertyCheck(getByteLength_default);
  }
});

// ../../node_modules/underscore/modules/isTypedArray.js
function isTypedArray(obj) {
  return nativeIsView ? nativeIsView(obj) && !isDataView_default(obj) : isBufferLike_default(obj) && typedArrayPattern.test(toString.call(obj));
}
var typedArrayPattern, isTypedArray_default;
var init_isTypedArray = __esm({
  "../../node_modules/underscore/modules/isTypedArray.js"() {
    init_setup();
    init_isDataView();
    init_constant();
    init_isBufferLike();
    typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    isTypedArray_default = supportsArrayBuffer ? isTypedArray : constant(false);
  }
});

// ../../node_modules/underscore/modules/_getLength.js
var getLength_default;
var init_getLength = __esm({
  "../../node_modules/underscore/modules/_getLength.js"() {
    init_shallowProperty();
    getLength_default = shallowProperty("length");
  }
});

// ../../node_modules/underscore/modules/_collectNonEnumProps.js
function emulatedSet(keys2) {
  var hash = {};
  for (var l7 = keys2.length, i5 = 0; i5 < l7; ++i5)
    hash[keys2[i5]] = true;
  return {
    contains: function(key) {
      return hash[key] === true;
    },
    push: function(key) {
      hash[key] = true;
      return keys2.push(key);
    }
  };
}
function collectNonEnumProps(obj, keys2) {
  keys2 = emulatedSet(keys2);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto = isFunction_default(constructor) && constructor.prototype || ObjProto;
  var prop = "constructor";
  if (has(obj, prop) && !keys2.contains(prop))
    keys2.push(prop);
  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys2.contains(prop)) {
      keys2.push(prop);
    }
  }
}
var init_collectNonEnumProps = __esm({
  "../../node_modules/underscore/modules/_collectNonEnumProps.js"() {
    init_setup();
    init_isFunction();
    init_has();
  }
});

// ../../node_modules/underscore/modules/keys.js
function keys(obj) {
  if (!isObject2(obj))
    return [];
  if (nativeKeys)
    return nativeKeys(obj);
  var keys2 = [];
  for (var key in obj)
    if (has(obj, key))
      keys2.push(key);
  if (hasEnumBug)
    collectNonEnumProps(obj, keys2);
  return keys2;
}
var init_keys = __esm({
  "../../node_modules/underscore/modules/keys.js"() {
    init_isObject();
    init_setup();
    init_has();
    init_collectNonEnumProps();
  }
});

// ../../node_modules/underscore/modules/isEmpty.js
function isEmpty(obj) {
  if (obj == null)
    return true;
  var length = getLength_default(obj);
  if (typeof length == "number" && (isArray_default(obj) || isString_default(obj) || isArguments_default(obj)))
    return length === 0;
  return getLength_default(keys(obj)) === 0;
}
var init_isEmpty = __esm({
  "../../node_modules/underscore/modules/isEmpty.js"() {
    init_getLength();
    init_isArray();
    init_isString();
    init_isArguments();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/isMatch.js
function isMatch(object2, attrs) {
  var _keys = keys(attrs), length = _keys.length;
  if (object2 == null)
    return !length;
  var obj = Object(object2);
  for (var i5 = 0; i5 < length; i5++) {
    var key = _keys[i5];
    if (attrs[key] !== obj[key] || !(key in obj))
      return false;
  }
  return true;
}
var init_isMatch = __esm({
  "../../node_modules/underscore/modules/isMatch.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/underscore.js
function _(obj) {
  if (obj instanceof _)
    return obj;
  if (!(this instanceof _))
    return new _(obj);
  this._wrapped = obj;
}
var init_underscore = __esm({
  "../../node_modules/underscore/modules/underscore.js"() {
    init_setup();
    _.VERSION = VERSION;
    _.prototype.value = function() {
      return this._wrapped;
    };
    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
    _.prototype.toString = function() {
      return String(this._wrapped);
    };
  }
});

// ../../node_modules/underscore/modules/_toBufferView.js
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    getByteLength_default(bufferSource)
  );
}
var init_toBufferView = __esm({
  "../../node_modules/underscore/modules/_toBufferView.js"() {
    init_getByteLength();
  }
});

// ../../node_modules/underscore/modules/isEqual.js
function eq(a4, b4, aStack, bStack) {
  if (a4 === b4)
    return a4 !== 0 || 1 / a4 === 1 / b4;
  if (a4 == null || b4 == null)
    return false;
  if (a4 !== a4)
    return b4 !== b4;
  var type2 = typeof a4;
  if (type2 !== "function" && type2 !== "object" && typeof b4 != "object")
    return false;
  return deepEq(a4, b4, aStack, bStack);
}
function deepEq(a4, b4, aStack, bStack) {
  if (a4 instanceof _)
    a4 = a4._wrapped;
  if (b4 instanceof _)
    b4 = b4._wrapped;
  var className = toString.call(a4);
  if (className !== toString.call(b4))
    return false;
  if (hasStringTagBug && className == "[object Object]" && isDataView_default(a4)) {
    if (!isDataView_default(b4))
      return false;
    className = tagDataView;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a4 === "" + b4;
    case "[object Number]":
      if (+a4 !== +a4)
        return +b4 !== +b4;
      return +a4 === 0 ? 1 / +a4 === 1 / b4 : +a4 === +b4;
    case "[object Date]":
    case "[object Boolean]":
      return +a4 === +b4;
    case "[object Symbol]":
      return SymbolProto.valueOf.call(a4) === SymbolProto.valueOf.call(b4);
    case "[object ArrayBuffer]":
    case tagDataView:
      return deepEq(toBufferView(a4), toBufferView(b4), aStack, bStack);
  }
  var areArrays = className === "[object Array]";
  if (!areArrays && isTypedArray_default(a4)) {
    var byteLength = getByteLength_default(a4);
    if (byteLength !== getByteLength_default(b4))
      return false;
    if (a4.buffer === b4.buffer && a4.byteOffset === b4.byteOffset)
      return true;
    areArrays = true;
  }
  if (!areArrays) {
    if (typeof a4 != "object" || typeof b4 != "object")
      return false;
    var aCtor = a4.constructor, bCtor = b4.constructor;
    if (aCtor !== bCtor && !(isFunction_default(aCtor) && aCtor instanceof aCtor && isFunction_default(bCtor) && bCtor instanceof bCtor) && ("constructor" in a4 && "constructor" in b4)) {
      return false;
    }
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a4)
      return bStack[length] === b4;
  }
  aStack.push(a4);
  bStack.push(b4);
  if (areArrays) {
    length = a4.length;
    if (length !== b4.length)
      return false;
    while (length--) {
      if (!eq(a4[length], b4[length], aStack, bStack))
        return false;
    }
  } else {
    var _keys = keys(a4), key;
    length = _keys.length;
    if (keys(b4).length !== length)
      return false;
    while (length--) {
      key = _keys[length];
      if (!(has(b4, key) && eq(a4[key], b4[key], aStack, bStack)))
        return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function isEqual2(a4, b4) {
  return eq(a4, b4);
}
var tagDataView;
var init_isEqual = __esm({
  "../../node_modules/underscore/modules/isEqual.js"() {
    init_underscore();
    init_setup();
    init_getByteLength();
    init_isTypedArray();
    init_isFunction();
    init_stringTagBug();
    init_isDataView();
    init_keys();
    init_has();
    init_toBufferView();
    tagDataView = "[object DataView]";
  }
});

// ../../node_modules/underscore/modules/allKeys.js
function allKeys(obj) {
  if (!isObject2(obj))
    return [];
  var keys2 = [];
  for (var key in obj)
    keys2.push(key);
  if (hasEnumBug)
    collectNonEnumProps(obj, keys2);
  return keys2;
}
var init_allKeys = __esm({
  "../../node_modules/underscore/modules/allKeys.js"() {
    init_isObject();
    init_setup();
    init_collectNonEnumProps();
  }
});

// ../../node_modules/underscore/modules/_methodFingerprint.js
function ie11fingerprint(methods) {
  var length = getLength_default(methods);
  return function(obj) {
    if (obj == null)
      return false;
    var keys2 = allKeys(obj);
    if (getLength_default(keys2))
      return false;
    for (var i5 = 0; i5 < length; i5++) {
      if (!isFunction_default(obj[methods[i5]]))
        return false;
    }
    return methods !== weakMapMethods || !isFunction_default(obj[forEachName]);
  };
}
var forEachName, hasName, commonInit, mapTail, mapMethods, weakMapMethods, setMethods;
var init_methodFingerprint = __esm({
  "../../node_modules/underscore/modules/_methodFingerprint.js"() {
    init_getLength();
    init_isFunction();
    init_allKeys();
    forEachName = "forEach";
    hasName = "has";
    commonInit = ["clear", "delete"];
    mapTail = ["get", hasName, "set"];
    mapMethods = commonInit.concat(forEachName, mapTail);
    weakMapMethods = commonInit.concat(mapTail);
    setMethods = ["add"].concat(commonInit, forEachName, hasName);
  }
});

// ../../node_modules/underscore/modules/isMap.js
var isMap_default;
var init_isMap = __esm({
  "../../node_modules/underscore/modules/isMap.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isMap_default = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
  }
});

// ../../node_modules/underscore/modules/isWeakMap.js
var isWeakMap_default;
var init_isWeakMap = __esm({
  "../../node_modules/underscore/modules/isWeakMap.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isWeakMap_default = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
  }
});

// ../../node_modules/underscore/modules/isSet.js
var isSet_default;
var init_isSet = __esm({
  "../../node_modules/underscore/modules/isSet.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isSet_default = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
  }
});

// ../../node_modules/underscore/modules/isWeakSet.js
var isWeakSet_default;
var init_isWeakSet = __esm({
  "../../node_modules/underscore/modules/isWeakSet.js"() {
    init_tagTester();
    isWeakSet_default = tagTester("WeakSet");
  }
});

// ../../node_modules/underscore/modules/values.js
function values(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var values2 = Array(length);
  for (var i5 = 0; i5 < length; i5++) {
    values2[i5] = obj[_keys[i5]];
  }
  return values2;
}
var init_values = __esm({
  "../../node_modules/underscore/modules/values.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/pairs.js
function pairs(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var pairs3 = Array(length);
  for (var i5 = 0; i5 < length; i5++) {
    pairs3[i5] = [_keys[i5], obj[_keys[i5]]];
  }
  return pairs3;
}
var init_pairs = __esm({
  "../../node_modules/underscore/modules/pairs.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/invert.js
function invert(obj) {
  var result2 = {};
  var _keys = keys(obj);
  for (var i5 = 0, length = _keys.length; i5 < length; i5++) {
    result2[obj[_keys[i5]]] = _keys[i5];
  }
  return result2;
}
var init_invert = __esm({
  "../../node_modules/underscore/modules/invert.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/functions.js
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (isFunction_default(obj[key]))
      names.push(key);
  }
  return names.sort();
}
var init_functions = __esm({
  "../../node_modules/underscore/modules/functions.js"() {
    init_isFunction();
  }
});

// ../../node_modules/underscore/modules/_createAssigner.js
function createAssigner(keysFunc, defaults) {
  return function(obj) {
    var length = arguments.length;
    if (defaults)
      obj = Object(obj);
    if (length < 2 || obj == null)
      return obj;
    for (var index2 = 1; index2 < length; index2++) {
      var source = arguments[index2], keys2 = keysFunc(source), l7 = keys2.length;
      for (var i5 = 0; i5 < l7; i5++) {
        var key = keys2[i5];
        if (!defaults || obj[key] === void 0)
          obj[key] = source[key];
      }
    }
    return obj;
  };
}
var init_createAssigner = __esm({
  "../../node_modules/underscore/modules/_createAssigner.js"() {
  }
});

// ../../node_modules/underscore/modules/extend.js
var extend_default;
var init_extend = __esm({
  "../../node_modules/underscore/modules/extend.js"() {
    init_createAssigner();
    init_allKeys();
    extend_default = createAssigner(allKeys);
  }
});

// ../../node_modules/underscore/modules/extendOwn.js
var extendOwn_default;
var init_extendOwn = __esm({
  "../../node_modules/underscore/modules/extendOwn.js"() {
    init_createAssigner();
    init_keys();
    extendOwn_default = createAssigner(keys);
  }
});

// ../../node_modules/underscore/modules/defaults.js
var defaults_default;
var init_defaults = __esm({
  "../../node_modules/underscore/modules/defaults.js"() {
    init_createAssigner();
    init_allKeys();
    defaults_default = createAssigner(allKeys, true);
  }
});

// ../../node_modules/underscore/modules/_baseCreate.js
function ctor() {
  return function() {
  };
}
function baseCreate(prototype) {
  if (!isObject2(prototype))
    return {};
  if (nativeCreate)
    return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result2 = new Ctor();
  Ctor.prototype = null;
  return result2;
}
var init_baseCreate = __esm({
  "../../node_modules/underscore/modules/_baseCreate.js"() {
    init_isObject();
    init_setup();
  }
});

// ../../node_modules/underscore/modules/create.js
function create(prototype, props) {
  var result2 = baseCreate(prototype);
  if (props)
    extendOwn_default(result2, props);
  return result2;
}
var init_create = __esm({
  "../../node_modules/underscore/modules/create.js"() {
    init_baseCreate();
    init_extendOwn();
  }
});

// ../../node_modules/underscore/modules/clone.js
function clone(obj) {
  if (!isObject2(obj))
    return obj;
  return isArray_default(obj) ? obj.slice() : extend_default({}, obj);
}
var init_clone = __esm({
  "../../node_modules/underscore/modules/clone.js"() {
    init_isObject();
    init_isArray();
    init_extend();
  }
});

// ../../node_modules/underscore/modules/tap.js
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}
var init_tap = __esm({
  "../../node_modules/underscore/modules/tap.js"() {
  }
});

// ../../node_modules/underscore/modules/toPath.js
function toPath(path2) {
  return isArray_default(path2) ? path2 : [path2];
}
var init_toPath = __esm({
  "../../node_modules/underscore/modules/toPath.js"() {
    init_underscore();
    init_isArray();
    _.toPath = toPath;
  }
});

// ../../node_modules/underscore/modules/_toPath.js
function toPath2(path2) {
  return _.toPath(path2);
}
var init_toPath2 = __esm({
  "../../node_modules/underscore/modules/_toPath.js"() {
    init_underscore();
    init_toPath();
  }
});

// ../../node_modules/underscore/modules/_deepGet.js
function deepGet(obj, path2) {
  var length = path2.length;
  for (var i5 = 0; i5 < length; i5++) {
    if (obj == null)
      return void 0;
    obj = obj[path2[i5]];
  }
  return length ? obj : void 0;
}
var init_deepGet = __esm({
  "../../node_modules/underscore/modules/_deepGet.js"() {
  }
});

// ../../node_modules/underscore/modules/get.js
function get(object2, path2, defaultValue) {
  var value = deepGet(object2, toPath2(path2));
  return isUndefined2(value) ? defaultValue : value;
}
var init_get = __esm({
  "../../node_modules/underscore/modules/get.js"() {
    init_toPath2();
    init_deepGet();
    init_isUndefined();
  }
});

// ../../node_modules/underscore/modules/has.js
function has2(obj, path2) {
  path2 = toPath2(path2);
  var length = path2.length;
  for (var i5 = 0; i5 < length; i5++) {
    var key = path2[i5];
    if (!has(obj, key))
      return false;
    obj = obj[key];
  }
  return !!length;
}
var init_has2 = __esm({
  "../../node_modules/underscore/modules/has.js"() {
    init_has();
    init_toPath2();
  }
});

// ../../node_modules/underscore/modules/identity.js
function identity(value) {
  return value;
}
var init_identity = __esm({
  "../../node_modules/underscore/modules/identity.js"() {
  }
});

// ../../node_modules/underscore/modules/matcher.js
function matcher(attrs) {
  attrs = extendOwn_default({}, attrs);
  return function(obj) {
    return isMatch(obj, attrs);
  };
}
var init_matcher = __esm({
  "../../node_modules/underscore/modules/matcher.js"() {
    init_extendOwn();
    init_isMatch();
  }
});

// ../../node_modules/underscore/modules/property.js
function property(path2) {
  path2 = toPath2(path2);
  return function(obj) {
    return deepGet(obj, path2);
  };
}
var init_property = __esm({
  "../../node_modules/underscore/modules/property.js"() {
    init_deepGet();
    init_toPath2();
  }
});

// ../../node_modules/underscore/modules/_optimizeCb.js
function optimizeCb(func, context, argCount) {
  if (context === void 0)
    return func;
  switch (argCount == null ? 3 : argCount) {
    case 1:
      return function(value) {
        return func.call(context, value);
      };
    case 3:
      return function(value, index2, collection) {
        return func.call(context, value, index2, collection);
      };
    case 4:
      return function(accumulator, value, index2, collection) {
        return func.call(context, accumulator, value, index2, collection);
      };
  }
  return function() {
    return func.apply(context, arguments);
  };
}
var init_optimizeCb = __esm({
  "../../node_modules/underscore/modules/_optimizeCb.js"() {
  }
});

// ../../node_modules/underscore/modules/_baseIteratee.js
function baseIteratee(value, context, argCount) {
  if (value == null)
    return identity;
  if (isFunction_default(value))
    return optimizeCb(value, context, argCount);
  if (isObject2(value) && !isArray_default(value))
    return matcher(value);
  return property(value);
}
var init_baseIteratee = __esm({
  "../../node_modules/underscore/modules/_baseIteratee.js"() {
    init_identity();
    init_isFunction();
    init_isObject();
    init_isArray();
    init_matcher();
    init_property();
    init_optimizeCb();
  }
});

// ../../node_modules/underscore/modules/iteratee.js
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
var init_iteratee = __esm({
  "../../node_modules/underscore/modules/iteratee.js"() {
    init_underscore();
    init_baseIteratee();
    _.iteratee = iteratee;
  }
});

// ../../node_modules/underscore/modules/_cb.js
function cb(value, context, argCount) {
  if (_.iteratee !== iteratee)
    return _.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}
var init_cb = __esm({
  "../../node_modules/underscore/modules/_cb.js"() {
    init_underscore();
    init_baseIteratee();
    init_iteratee();
  }
});

// ../../node_modules/underscore/modules/mapObject.js
function mapObject(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = keys(obj), length = _keys.length, results = {};
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys[index2];
    results[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}
var init_mapObject = __esm({
  "../../node_modules/underscore/modules/mapObject.js"() {
    init_cb();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/noop.js
function noop2() {
}
var init_noop = __esm({
  "../../node_modules/underscore/modules/noop.js"() {
  }
});

// ../../node_modules/underscore/modules/propertyOf.js
function propertyOf(obj) {
  if (obj == null)
    return noop2;
  return function(path2) {
    return get(obj, path2);
  };
}
var init_propertyOf = __esm({
  "../../node_modules/underscore/modules/propertyOf.js"() {
    init_noop();
    init_get();
  }
});

// ../../node_modules/underscore/modules/times.js
function times(n4, iteratee2, context) {
  var accum = Array(Math.max(0, n4));
  iteratee2 = optimizeCb(iteratee2, context, 1);
  for (var i5 = 0; i5 < n4; i5++)
    accum[i5] = iteratee2(i5);
  return accum;
}
var init_times = __esm({
  "../../node_modules/underscore/modules/times.js"() {
    init_optimizeCb();
  }
});

// ../../node_modules/underscore/modules/random.js
function random(min3, max3) {
  if (max3 == null) {
    max3 = min3;
    min3 = 0;
  }
  return min3 + Math.floor(Math.random() * (max3 - min3 + 1));
}
var init_random = __esm({
  "../../node_modules/underscore/modules/random.js"() {
  }
});

// ../../node_modules/underscore/modules/now.js
var now_default;
var init_now = __esm({
  "../../node_modules/underscore/modules/now.js"() {
    now_default = Date.now || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
  }
});

// ../../node_modules/underscore/modules/_createEscaper.js
function createEscaper(map4) {
  var escaper = function(match) {
    return map4[match];
  };
  var source = "(?:" + keys(map4).join("|") + ")";
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, "g");
  return function(string) {
    string = string == null ? "" : "" + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}
var init_createEscaper = __esm({
  "../../node_modules/underscore/modules/_createEscaper.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/_escapeMap.js
var escapeMap_default;
var init_escapeMap = __esm({
  "../../node_modules/underscore/modules/_escapeMap.js"() {
    escapeMap_default = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;"
    };
  }
});

// ../../node_modules/underscore/modules/escape.js
var escape_default;
var init_escape = __esm({
  "../../node_modules/underscore/modules/escape.js"() {
    init_createEscaper();
    init_escapeMap();
    escape_default = createEscaper(escapeMap_default);
  }
});

// ../../node_modules/underscore/modules/_unescapeMap.js
var unescapeMap_default;
var init_unescapeMap = __esm({
  "../../node_modules/underscore/modules/_unescapeMap.js"() {
    init_invert();
    init_escapeMap();
    unescapeMap_default = invert(escapeMap_default);
  }
});

// ../../node_modules/underscore/modules/unescape.js
var unescape_default;
var init_unescape = __esm({
  "../../node_modules/underscore/modules/unescape.js"() {
    init_createEscaper();
    init_unescapeMap();
    unescape_default = createEscaper(unescapeMap_default);
  }
});

// ../../node_modules/underscore/modules/templateSettings.js
var templateSettings_default;
var init_templateSettings = __esm({
  "../../node_modules/underscore/modules/templateSettings.js"() {
    init_underscore();
    templateSettings_default = _.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };
  }
});

// ../../node_modules/underscore/modules/template.js
function escapeChar(match) {
  return "\\" + escapes[match];
}
function template(text, settings, oldSettings) {
  if (!settings && oldSettings)
    settings = oldSettings;
  settings = defaults_default({}, settings, _.templateSettings);
  var matcher2 = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join("|") + "|$", "g");
  var index2 = 0;
  var source = "__p+='";
  text.replace(matcher2, function(match, escape2, interpolate, evaluate2, offset2) {
    source += text.slice(index2, offset2).replace(escapeRegExp, escapeChar);
    index2 = offset2 + match.length;
    if (escape2) {
      source += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate2) {
      source += "';\n" + evaluate2 + "\n__p+='";
    }
    return match;
  });
  source += "';\n";
  var argument = settings.variable;
  if (argument) {
    if (!bareIdentifier.test(argument))
      throw new Error(
        "variable is not a bare identifier: " + argument
      );
  } else {
    source = "with(obj||{}){\n" + source + "}\n";
    argument = "obj";
  }
  source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
  var render;
  try {
    render = new Function(argument, "_", source);
  } catch (e4) {
    e4.source = source;
    throw e4;
  }
  var template2 = function(data) {
    return render.call(this, data, _);
  };
  template2.source = "function(" + argument + "){\n" + source + "}";
  return template2;
}
var noMatch, escapes, escapeRegExp, bareIdentifier;
var init_template = __esm({
  "../../node_modules/underscore/modules/template.js"() {
    init_defaults();
    init_underscore();
    init_templateSettings();
    noMatch = /(.)^/;
    escapes = {
      "'": "'",
      "\\": "\\",
      "\r": "r",
      "\n": "n",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
    bareIdentifier = /^\s*(\w|\$)+\s*$/;
  }
});

// ../../node_modules/underscore/modules/result.js
function result(obj, path2, fallback) {
  path2 = toPath2(path2);
  var length = path2.length;
  if (!length) {
    return isFunction_default(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i5 = 0; i5 < length; i5++) {
    var prop = obj == null ? void 0 : obj[path2[i5]];
    if (prop === void 0) {
      prop = fallback;
      i5 = length;
    }
    obj = isFunction_default(prop) ? prop.call(obj) : prop;
  }
  return obj;
}
var init_result = __esm({
  "../../node_modules/underscore/modules/result.js"() {
    init_isFunction();
    init_toPath2();
  }
});

// ../../node_modules/underscore/modules/uniqueId.js
function uniqueId(prefix) {
  var id = ++idCounter + "";
  return prefix ? prefix + id : id;
}
var idCounter;
var init_uniqueId = __esm({
  "../../node_modules/underscore/modules/uniqueId.js"() {
    idCounter = 0;
  }
});

// ../../node_modules/underscore/modules/chain.js
function chain(obj) {
  var instance = _(obj);
  instance._chain = true;
  return instance;
}
var init_chain = __esm({
  "../../node_modules/underscore/modules/chain.js"() {
    init_underscore();
  }
});

// ../../node_modules/underscore/modules/_executeBound.js
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc))
    return sourceFunc.apply(context, args);
  var self2 = baseCreate(sourceFunc.prototype);
  var result2 = sourceFunc.apply(self2, args);
  if (isObject2(result2))
    return result2;
  return self2;
}
var init_executeBound = __esm({
  "../../node_modules/underscore/modules/_executeBound.js"() {
    init_baseCreate();
    init_isObject();
  }
});

// ../../node_modules/underscore/modules/partial.js
var partial, partial_default;
var init_partial = __esm({
  "../../node_modules/underscore/modules/partial.js"() {
    init_restArguments();
    init_executeBound();
    init_underscore();
    partial = restArguments(function(func, boundArgs) {
      var placeholder2 = partial.placeholder;
      var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for (var i5 = 0; i5 < length; i5++) {
          args[i5] = boundArgs[i5] === placeholder2 ? arguments[position++] : boundArgs[i5];
        }
        while (position < arguments.length)
          args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    });
    partial.placeholder = _;
    partial_default = partial;
  }
});

// ../../node_modules/underscore/modules/bind.js
var bind_default;
var init_bind = __esm({
  "../../node_modules/underscore/modules/bind.js"() {
    init_restArguments();
    init_isFunction();
    init_executeBound();
    bind_default = restArguments(function(func, context, args) {
      if (!isFunction_default(func))
        throw new TypeError("Bind must be called on a function");
      var bound = restArguments(function(callArgs) {
        return executeBound(func, bound, context, this, args.concat(callArgs));
      });
      return bound;
    });
  }
});

// ../../node_modules/underscore/modules/_isArrayLike.js
var isArrayLike_default;
var init_isArrayLike = __esm({
  "../../node_modules/underscore/modules/_isArrayLike.js"() {
    init_createSizePropertyCheck();
    init_getLength();
    isArrayLike_default = createSizePropertyCheck(getLength_default);
  }
});

// ../../node_modules/underscore/modules/_flatten.js
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i5 = 0, length = getLength_default(input); i5 < length; i5++) {
    var value = input[i5];
    if (isArrayLike_default(value) && (isArray_default(value) || isArguments_default(value))) {
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j2 = 0, len = value.length;
        while (j2 < len)
          output[idx++] = value[j2++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}
var init_flatten = __esm({
  "../../node_modules/underscore/modules/_flatten.js"() {
    init_getLength();
    init_isArrayLike();
    init_isArray();
    init_isArguments();
  }
});

// ../../node_modules/underscore/modules/bindAll.js
var bindAll_default;
var init_bindAll = __esm({
  "../../node_modules/underscore/modules/bindAll.js"() {
    init_restArguments();
    init_flatten();
    init_bind();
    bindAll_default = restArguments(function(obj, keys2) {
      keys2 = flatten(keys2, false, false);
      var index2 = keys2.length;
      if (index2 < 1)
        throw new Error("bindAll must be passed function names");
      while (index2--) {
        var key = keys2[index2];
        obj[key] = bind_default(obj[key], obj);
      }
      return obj;
    });
  }
});

// ../../node_modules/underscore/modules/memoize.js
function memoize(func, hasher) {
  var memoize2 = function(key) {
    var cache2 = memoize2.cache;
    var address = "" + (hasher ? hasher.apply(this, arguments) : key);
    if (!has(cache2, address))
      cache2[address] = func.apply(this, arguments);
    return cache2[address];
  };
  memoize2.cache = {};
  return memoize2;
}
var init_memoize = __esm({
  "../../node_modules/underscore/modules/memoize.js"() {
    init_has();
  }
});

// ../../node_modules/underscore/modules/delay.js
var delay_default;
var init_delay = __esm({
  "../../node_modules/underscore/modules/delay.js"() {
    init_restArguments();
    delay_default = restArguments(function(func, wait, args) {
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    });
  }
});

// ../../node_modules/underscore/modules/defer.js
var defer_default;
var init_defer = __esm({
  "../../node_modules/underscore/modules/defer.js"() {
    init_partial();
    init_delay();
    init_underscore();
    defer_default = partial_default(delay_default, _, 1);
  }
});

// ../../node_modules/underscore/modules/throttle.js
function throttle(func, wait, options) {
  var timeout, context, args, result2;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : now_default();
    timeout = null;
    result2 = func.apply(context, args);
    if (!timeout)
      context = args = null;
  };
  var throttled = function() {
    var _now = now_default();
    if (!previous && options.leading === false)
      previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result2 = func.apply(context, args);
      if (!timeout)
        context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
}
var init_throttle = __esm({
  "../../node_modules/underscore/modules/throttle.js"() {
    init_now();
  }
});

// ../../node_modules/underscore/modules/debounce.js
function debounce(func, wait, immediate) {
  var timeout, previous, args, result2, context;
  var later = function() {
    var passed = now_default() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate)
        result2 = func.apply(context, args);
      if (!timeout)
        args = context = null;
    }
  };
  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now_default();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate)
        result2 = func.apply(context, args);
    }
    return result2;
  });
  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };
  return debounced;
}
var init_debounce = __esm({
  "../../node_modules/underscore/modules/debounce.js"() {
    init_restArguments();
    init_now();
  }
});

// ../../node_modules/underscore/modules/wrap.js
function wrap(func, wrapper) {
  return partial_default(wrapper, func);
}
var init_wrap = __esm({
  "../../node_modules/underscore/modules/wrap.js"() {
    init_partial();
  }
});

// ../../node_modules/underscore/modules/negate.js
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
var init_negate = __esm({
  "../../node_modules/underscore/modules/negate.js"() {
  }
});

// ../../node_modules/underscore/modules/compose.js
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i5 = start;
    var result2 = args[start].apply(this, arguments);
    while (i5--)
      result2 = args[i5].call(this, result2);
    return result2;
  };
}
var init_compose = __esm({
  "../../node_modules/underscore/modules/compose.js"() {
  }
});

// ../../node_modules/underscore/modules/after.js
function after(times2, func) {
  return function() {
    if (--times2 < 1) {
      return func.apply(this, arguments);
    }
  };
}
var init_after = __esm({
  "../../node_modules/underscore/modules/after.js"() {
  }
});

// ../../node_modules/underscore/modules/before.js
function before(times2, func) {
  var memo;
  return function() {
    if (--times2 > 0) {
      memo = func.apply(this, arguments);
    }
    if (times2 <= 1)
      func = null;
    return memo;
  };
}
var init_before = __esm({
  "../../node_modules/underscore/modules/before.js"() {
  }
});

// ../../node_modules/underscore/modules/once.js
var once_default;
var init_once = __esm({
  "../../node_modules/underscore/modules/once.js"() {
    init_partial();
    init_before();
    once_default = partial_default(before, 2);
  }
});

// ../../node_modules/underscore/modules/findKey.js
function findKey(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys(obj), key;
  for (var i5 = 0, length = _keys.length; i5 < length; i5++) {
    key = _keys[i5];
    if (predicate(obj[key], key, obj))
      return key;
  }
}
var init_findKey = __esm({
  "../../node_modules/underscore/modules/findKey.js"() {
    init_cb();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/_createPredicateIndexFinder.js
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = getLength_default(array);
    var index2 = dir > 0 ? 0 : length - 1;
    for (; index2 >= 0 && index2 < length; index2 += dir) {
      if (predicate(array[index2], index2, array))
        return index2;
    }
    return -1;
  };
}
var init_createPredicateIndexFinder = __esm({
  "../../node_modules/underscore/modules/_createPredicateIndexFinder.js"() {
    init_cb();
    init_getLength();
  }
});

// ../../node_modules/underscore/modules/findIndex.js
var findIndex_default;
var init_findIndex = __esm({
  "../../node_modules/underscore/modules/findIndex.js"() {
    init_createPredicateIndexFinder();
    findIndex_default = createPredicateIndexFinder(1);
  }
});

// ../../node_modules/underscore/modules/findLastIndex.js
var findLastIndex_default;
var init_findLastIndex = __esm({
  "../../node_modules/underscore/modules/findLastIndex.js"() {
    init_createPredicateIndexFinder();
    findLastIndex_default = createPredicateIndexFinder(-1);
  }
});

// ../../node_modules/underscore/modules/sortedIndex.js
function sortedIndex(array, obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context, 1);
  var value = iteratee2(obj);
  var low = 0, high = getLength_default(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee2(array[mid]) < value)
      low = mid + 1;
    else
      high = mid;
  }
  return low;
}
var init_sortedIndex = __esm({
  "../../node_modules/underscore/modules/sortedIndex.js"() {
    init_cb();
    init_getLength();
  }
});

// ../../node_modules/underscore/modules/_createIndexFinder.js
function createIndexFinder(dir, predicateFind, sortedIndex2) {
  return function(array, item, idx) {
    var i5 = 0, length = getLength_default(array);
    if (typeof idx == "number") {
      if (dir > 0) {
        i5 = idx >= 0 ? idx : Math.max(idx + length, i5);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex2 && idx && length) {
      idx = sortedIndex2(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i5, length), isNaN2);
      return idx >= 0 ? idx + i5 : -1;
    }
    for (idx = dir > 0 ? i5 : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item)
        return idx;
    }
    return -1;
  };
}
var init_createIndexFinder = __esm({
  "../../node_modules/underscore/modules/_createIndexFinder.js"() {
    init_getLength();
    init_setup();
    init_isNaN();
  }
});

// ../../node_modules/underscore/modules/indexOf.js
var indexOf_default;
var init_indexOf = __esm({
  "../../node_modules/underscore/modules/indexOf.js"() {
    init_sortedIndex();
    init_findIndex();
    init_createIndexFinder();
    indexOf_default = createIndexFinder(1, findIndex_default, sortedIndex);
  }
});

// ../../node_modules/underscore/modules/lastIndexOf.js
var lastIndexOf_default;
var init_lastIndexOf = __esm({
  "../../node_modules/underscore/modules/lastIndexOf.js"() {
    init_findLastIndex();
    init_createIndexFinder();
    lastIndexOf_default = createIndexFinder(-1, findLastIndex_default);
  }
});

// ../../node_modules/underscore/modules/find.js
function find(obj, predicate, context) {
  var keyFinder = isArrayLike_default(obj) ? findIndex_default : findKey;
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1)
    return obj[key];
}
var init_find = __esm({
  "../../node_modules/underscore/modules/find.js"() {
    init_isArrayLike();
    init_findIndex();
    init_findKey();
  }
});

// ../../node_modules/underscore/modules/findWhere.js
function findWhere(obj, attrs) {
  return find(obj, matcher(attrs));
}
var init_findWhere = __esm({
  "../../node_modules/underscore/modules/findWhere.js"() {
    init_find();
    init_matcher();
  }
});

// ../../node_modules/underscore/modules/each.js
function each2(obj, iteratee2, context) {
  iteratee2 = optimizeCb(iteratee2, context);
  var i5, length;
  if (isArrayLike_default(obj)) {
    for (i5 = 0, length = obj.length; i5 < length; i5++) {
      iteratee2(obj[i5], i5, obj);
    }
  } else {
    var _keys = keys(obj);
    for (i5 = 0, length = _keys.length; i5 < length; i5++) {
      iteratee2(obj[_keys[i5]], _keys[i5], obj);
    }
  }
  return obj;
}
var init_each = __esm({
  "../../node_modules/underscore/modules/each.js"() {
    init_optimizeCb();
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/map.js
function map2(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length, results = Array(length);
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    results[index2] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}
var init_map = __esm({
  "../../node_modules/underscore/modules/map.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/_createReduce.js
function createReduce(dir) {
  var reducer3 = function(obj, iteratee2, memo, initial2) {
    var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length, index2 = dir > 0 ? 0 : length - 1;
    if (!initial2) {
      memo = obj[_keys ? _keys[index2] : index2];
      index2 += dir;
    }
    for (; index2 >= 0 && index2 < length; index2 += dir) {
      var currentKey = _keys ? _keys[index2] : index2;
      memo = iteratee2(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };
  return function(obj, iteratee2, memo, context) {
    var initial2 = arguments.length >= 3;
    return reducer3(obj, optimizeCb(iteratee2, context, 4), memo, initial2);
  };
}
var init_createReduce = __esm({
  "../../node_modules/underscore/modules/_createReduce.js"() {
    init_isArrayLike();
    init_keys();
    init_optimizeCb();
  }
});

// ../../node_modules/underscore/modules/reduce.js
var reduce_default;
var init_reduce = __esm({
  "../../node_modules/underscore/modules/reduce.js"() {
    init_createReduce();
    reduce_default = createReduce(1);
  }
});

// ../../node_modules/underscore/modules/reduceRight.js
var reduceRight_default;
var init_reduceRight = __esm({
  "../../node_modules/underscore/modules/reduceRight.js"() {
    init_createReduce();
    reduceRight_default = createReduce(-1);
  }
});

// ../../node_modules/underscore/modules/filter.js
function filter(obj, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each2(obj, function(value, index2, list) {
    if (predicate(value, index2, list))
      results.push(value);
  });
  return results;
}
var init_filter = __esm({
  "../../node_modules/underscore/modules/filter.js"() {
    init_cb();
    init_each();
  }
});

// ../../node_modules/underscore/modules/reject.js
function reject2(obj, predicate, context) {
  return filter(obj, negate(cb(predicate)), context);
}
var init_reject = __esm({
  "../../node_modules/underscore/modules/reject.js"() {
    init_filter();
    init_negate();
    init_cb();
  }
});

// ../../node_modules/underscore/modules/every.js
function every3(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length;
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    if (!predicate(obj[currentKey], currentKey, obj))
      return false;
  }
  return true;
}
var init_every = __esm({
  "../../node_modules/underscore/modules/every.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/some.js
function some3(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length;
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    if (predicate(obj[currentKey], currentKey, obj))
      return true;
  }
  return false;
}
var init_some = __esm({
  "../../node_modules/underscore/modules/some.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/contains.js
function contains(obj, item, fromIndex, guard) {
  if (!isArrayLike_default(obj))
    obj = values(obj);
  if (typeof fromIndex != "number" || guard)
    fromIndex = 0;
  return indexOf_default(obj, item, fromIndex) >= 0;
}
var init_contains = __esm({
  "../../node_modules/underscore/modules/contains.js"() {
    init_isArrayLike();
    init_values();
    init_indexOf();
  }
});

// ../../node_modules/underscore/modules/invoke.js
var invoke_default;
var init_invoke = __esm({
  "../../node_modules/underscore/modules/invoke.js"() {
    init_restArguments();
    init_isFunction();
    init_map();
    init_deepGet();
    init_toPath2();
    invoke_default = restArguments(function(obj, path2, args) {
      var contextPath, func;
      if (isFunction_default(path2)) {
        func = path2;
      } else {
        path2 = toPath2(path2);
        contextPath = path2.slice(0, -1);
        path2 = path2[path2.length - 1];
      }
      return map2(obj, function(context) {
        var method = func;
        if (!method) {
          if (contextPath && contextPath.length) {
            context = deepGet(context, contextPath);
          }
          if (context == null)
            return void 0;
          method = context[path2];
        }
        return method == null ? method : method.apply(context, args);
      });
    });
  }
});

// ../../node_modules/underscore/modules/pluck.js
function pluck(obj, key) {
  return map2(obj, property(key));
}
var init_pluck = __esm({
  "../../node_modules/underscore/modules/pluck.js"() {
    init_map();
    init_property();
  }
});

// ../../node_modules/underscore/modules/where.js
function where(obj, attrs) {
  return filter(obj, matcher(attrs));
}
var init_where = __esm({
  "../../node_modules/underscore/modules/where.js"() {
    init_filter();
    init_matcher();
  }
});

// ../../node_modules/underscore/modules/max.js
function max2(obj, iteratee2, context) {
  var result2 = -Infinity, lastComputed = -Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i5 = 0, length = obj.length; i5 < length; i5++) {
      value = obj[i5];
      if (value != null && value > result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each2(obj, function(v2, index2, list) {
      computed = iteratee2(v2, index2, list);
      if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
        result2 = v2;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var init_max = __esm({
  "../../node_modules/underscore/modules/max.js"() {
    init_isArrayLike();
    init_values();
    init_cb();
    init_each();
  }
});

// ../../node_modules/underscore/modules/min.js
function min2(obj, iteratee2, context) {
  var result2 = Infinity, lastComputed = Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i5 = 0, length = obj.length; i5 < length; i5++) {
      value = obj[i5];
      if (value != null && value < result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each2(obj, function(v2, index2, list) {
      computed = iteratee2(v2, index2, list);
      if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
        result2 = v2;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var init_min = __esm({
  "../../node_modules/underscore/modules/min.js"() {
    init_isArrayLike();
    init_values();
    init_cb();
    init_each();
  }
});

// ../../node_modules/underscore/modules/toArray.js
function toArray(obj) {
  if (!obj)
    return [];
  if (isArray_default(obj))
    return slice.call(obj);
  if (isString_default(obj)) {
    return obj.match(reStrSymbol);
  }
  if (isArrayLike_default(obj))
    return map2(obj, identity);
  return values(obj);
}
var reStrSymbol;
var init_toArray = __esm({
  "../../node_modules/underscore/modules/toArray.js"() {
    init_isArray();
    init_setup();
    init_isString();
    init_isArrayLike();
    init_map();
    init_identity();
    init_values();
    reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  }
});

// ../../node_modules/underscore/modules/sample.js
function sample(obj, n4, guard) {
  if (n4 == null || guard) {
    if (!isArrayLike_default(obj))
      obj = values(obj);
    return obj[random(obj.length - 1)];
  }
  var sample2 = toArray(obj);
  var length = getLength_default(sample2);
  n4 = Math.max(Math.min(n4, length), 0);
  var last2 = length - 1;
  for (var index2 = 0; index2 < n4; index2++) {
    var rand = random(index2, last2);
    var temp = sample2[index2];
    sample2[index2] = sample2[rand];
    sample2[rand] = temp;
  }
  return sample2.slice(0, n4);
}
var init_sample = __esm({
  "../../node_modules/underscore/modules/sample.js"() {
    init_isArrayLike();
    init_values();
    init_getLength();
    init_random();
    init_toArray();
  }
});

// ../../node_modules/underscore/modules/shuffle.js
function shuffle(obj) {
  return sample(obj, Infinity);
}
var init_shuffle = __esm({
  "../../node_modules/underscore/modules/shuffle.js"() {
    init_sample();
  }
});

// ../../node_modules/underscore/modules/sortBy.js
function sortBy(obj, iteratee2, context) {
  var index2 = 0;
  iteratee2 = cb(iteratee2, context);
  return pluck(map2(obj, function(value, key, list) {
    return {
      value,
      index: index2++,
      criteria: iteratee2(value, key, list)
    };
  }).sort(function(left, right) {
    var a4 = left.criteria;
    var b4 = right.criteria;
    if (a4 !== b4) {
      if (a4 > b4 || a4 === void 0)
        return 1;
      if (a4 < b4 || b4 === void 0)
        return -1;
    }
    return left.index - right.index;
  }), "value");
}
var init_sortBy = __esm({
  "../../node_modules/underscore/modules/sortBy.js"() {
    init_cb();
    init_pluck();
    init_map();
  }
});

// ../../node_modules/underscore/modules/_group.js
function group(behavior, partition) {
  return function(obj, iteratee2, context) {
    var result2 = partition ? [[], []] : {};
    iteratee2 = cb(iteratee2, context);
    each2(obj, function(value, index2) {
      var key = iteratee2(value, index2, obj);
      behavior(result2, value, key);
    });
    return result2;
  };
}
var init_group = __esm({
  "../../node_modules/underscore/modules/_group.js"() {
    init_cb();
    init_each();
  }
});

// ../../node_modules/underscore/modules/groupBy.js
var groupBy_default;
var init_groupBy = __esm({
  "../../node_modules/underscore/modules/groupBy.js"() {
    init_group();
    init_has();
    groupBy_default = group(function(result2, value, key) {
      if (has(result2, key))
        result2[key].push(value);
      else
        result2[key] = [value];
    });
  }
});

// ../../node_modules/underscore/modules/indexBy.js
var indexBy_default;
var init_indexBy = __esm({
  "../../node_modules/underscore/modules/indexBy.js"() {
    init_group();
    indexBy_default = group(function(result2, value, key) {
      result2[key] = value;
    });
  }
});

// ../../node_modules/underscore/modules/countBy.js
var countBy_default;
var init_countBy = __esm({
  "../../node_modules/underscore/modules/countBy.js"() {
    init_group();
    init_has();
    countBy_default = group(function(result2, value, key) {
      if (has(result2, key))
        result2[key]++;
      else
        result2[key] = 1;
    });
  }
});

// ../../node_modules/underscore/modules/partition.js
var partition_default;
var init_partition = __esm({
  "../../node_modules/underscore/modules/partition.js"() {
    init_group();
    partition_default = group(function(result2, value, pass) {
      result2[pass ? 0 : 1].push(value);
    }, true);
  }
});

// ../../node_modules/underscore/modules/size.js
function size2(obj) {
  if (obj == null)
    return 0;
  return isArrayLike_default(obj) ? obj.length : keys(obj).length;
}
var init_size = __esm({
  "../../node_modules/underscore/modules/size.js"() {
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/_keyInObj.js
function keyInObj(value, key, obj) {
  return key in obj;
}
var init_keyInObj = __esm({
  "../../node_modules/underscore/modules/_keyInObj.js"() {
  }
});

// ../../node_modules/underscore/modules/pick.js
var pick_default;
var init_pick = __esm({
  "../../node_modules/underscore/modules/pick.js"() {
    init_restArguments();
    init_isFunction();
    init_optimizeCb();
    init_allKeys();
    init_keyInObj();
    init_flatten();
    pick_default = restArguments(function(obj, keys2) {
      var result2 = {}, iteratee2 = keys2[0];
      if (obj == null)
        return result2;
      if (isFunction_default(iteratee2)) {
        if (keys2.length > 1)
          iteratee2 = optimizeCb(iteratee2, keys2[1]);
        keys2 = allKeys(obj);
      } else {
        iteratee2 = keyInObj;
        keys2 = flatten(keys2, false, false);
        obj = Object(obj);
      }
      for (var i5 = 0, length = keys2.length; i5 < length; i5++) {
        var key = keys2[i5];
        var value = obj[key];
        if (iteratee2(value, key, obj))
          result2[key] = value;
      }
      return result2;
    });
  }
});

// ../../node_modules/underscore/modules/omit.js
var omit_default;
var init_omit = __esm({
  "../../node_modules/underscore/modules/omit.js"() {
    init_restArguments();
    init_isFunction();
    init_negate();
    init_map();
    init_flatten();
    init_contains();
    init_pick();
    omit_default = restArguments(function(obj, keys2) {
      var iteratee2 = keys2[0], context;
      if (isFunction_default(iteratee2)) {
        iteratee2 = negate(iteratee2);
        if (keys2.length > 1)
          context = keys2[1];
      } else {
        keys2 = map2(flatten(keys2, false, false), String);
        iteratee2 = function(value, key) {
          return !contains(keys2, key);
        };
      }
      return pick_default(obj, iteratee2, context);
    });
  }
});

// ../../node_modules/underscore/modules/initial.js
function initial(array, n4, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n4 == null || guard ? 1 : n4)));
}
var init_initial = __esm({
  "../../node_modules/underscore/modules/initial.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/first.js
function first(array, n4, guard) {
  if (array == null || array.length < 1)
    return n4 == null || guard ? void 0 : [];
  if (n4 == null || guard)
    return array[0];
  return initial(array, array.length - n4);
}
var init_first = __esm({
  "../../node_modules/underscore/modules/first.js"() {
    init_initial();
  }
});

// ../../node_modules/underscore/modules/rest.js
function rest(array, n4, guard) {
  return slice.call(array, n4 == null || guard ? 1 : n4);
}
var init_rest = __esm({
  "../../node_modules/underscore/modules/rest.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/last.js
function last(array, n4, guard) {
  if (array == null || array.length < 1)
    return n4 == null || guard ? void 0 : [];
  if (n4 == null || guard)
    return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n4));
}
var init_last = __esm({
  "../../node_modules/underscore/modules/last.js"() {
    init_rest();
  }
});

// ../../node_modules/underscore/modules/compact.js
function compact(array) {
  return filter(array, Boolean);
}
var init_compact = __esm({
  "../../node_modules/underscore/modules/compact.js"() {
    init_filter();
  }
});

// ../../node_modules/underscore/modules/flatten.js
function flatten2(array, depth) {
  return flatten(array, depth, false);
}
var init_flatten2 = __esm({
  "../../node_modules/underscore/modules/flatten.js"() {
    init_flatten();
  }
});

// ../../node_modules/underscore/modules/difference.js
var difference_default;
var init_difference = __esm({
  "../../node_modules/underscore/modules/difference.js"() {
    init_restArguments();
    init_flatten();
    init_filter();
    init_contains();
    difference_default = restArguments(function(array, rest2) {
      rest2 = flatten(rest2, true, true);
      return filter(array, function(value) {
        return !contains(rest2, value);
      });
    });
  }
});

// ../../node_modules/underscore/modules/without.js
var without_default;
var init_without = __esm({
  "../../node_modules/underscore/modules/without.js"() {
    init_restArguments();
    init_difference();
    without_default = restArguments(function(array, otherArrays) {
      return difference_default(array, otherArrays);
    });
  }
});

// ../../node_modules/underscore/modules/uniq.js
function uniq(array, isSorted, iteratee2, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee2;
    iteratee2 = isSorted;
    isSorted = false;
  }
  if (iteratee2 != null)
    iteratee2 = cb(iteratee2, context);
  var result2 = [];
  var seen = [];
  for (var i5 = 0, length = getLength_default(array); i5 < length; i5++) {
    var value = array[i5], computed = iteratee2 ? iteratee2(value, i5, array) : value;
    if (isSorted && !iteratee2) {
      if (!i5 || seen !== computed)
        result2.push(value);
      seen = computed;
    } else if (iteratee2) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result2.push(value);
      }
    } else if (!contains(result2, value)) {
      result2.push(value);
    }
  }
  return result2;
}
var init_uniq = __esm({
  "../../node_modules/underscore/modules/uniq.js"() {
    init_isBoolean();
    init_cb();
    init_getLength();
    init_contains();
  }
});

// ../../node_modules/underscore/modules/union.js
var union_default;
var init_union = __esm({
  "../../node_modules/underscore/modules/union.js"() {
    init_restArguments();
    init_uniq();
    init_flatten();
    union_default = restArguments(function(arrays) {
      return uniq(flatten(arrays, true, true));
    });
  }
});

// ../../node_modules/underscore/modules/intersection.js
function intersection(array) {
  var result2 = [];
  var argsLength = arguments.length;
  for (var i5 = 0, length = getLength_default(array); i5 < length; i5++) {
    var item = array[i5];
    if (contains(result2, item))
      continue;
    var j2;
    for (j2 = 1; j2 < argsLength; j2++) {
      if (!contains(arguments[j2], item))
        break;
    }
    if (j2 === argsLength)
      result2.push(item);
  }
  return result2;
}
var init_intersection = __esm({
  "../../node_modules/underscore/modules/intersection.js"() {
    init_getLength();
    init_contains();
  }
});

// ../../node_modules/underscore/modules/unzip.js
function unzip(array) {
  var length = array && max2(array, getLength_default).length || 0;
  var result2 = Array(length);
  for (var index2 = 0; index2 < length; index2++) {
    result2[index2] = pluck(array, index2);
  }
  return result2;
}
var init_unzip = __esm({
  "../../node_modules/underscore/modules/unzip.js"() {
    init_max();
    init_getLength();
    init_pluck();
  }
});

// ../../node_modules/underscore/modules/zip.js
var zip_default;
var init_zip = __esm({
  "../../node_modules/underscore/modules/zip.js"() {
    init_restArguments();
    init_unzip();
    zip_default = restArguments(unzip);
  }
});

// ../../node_modules/underscore/modules/object.js
function object(list, values2) {
  var result2 = {};
  for (var i5 = 0, length = getLength_default(list); i5 < length; i5++) {
    if (values2) {
      result2[list[i5]] = values2[i5];
    } else {
      result2[list[i5][0]] = list[i5][1];
    }
  }
  return result2;
}
var init_object = __esm({
  "../../node_modules/underscore/modules/object.js"() {
    init_getLength();
  }
});

// ../../node_modules/underscore/modules/range.js
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range2 = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range2[idx] = start;
  }
  return range2;
}
var init_range = __esm({
  "../../node_modules/underscore/modules/range.js"() {
  }
});

// ../../node_modules/underscore/modules/chunk.js
function chunk(array, count) {
  if (count == null || count < 1)
    return [];
  var result2 = [];
  var i5 = 0, length = array.length;
  while (i5 < length) {
    result2.push(slice.call(array, i5, i5 += count));
  }
  return result2;
}
var init_chunk = __esm({
  "../../node_modules/underscore/modules/chunk.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/_chainResult.js
function chainResult(instance, obj) {
  return instance._chain ? _(obj).chain() : obj;
}
var init_chainResult = __esm({
  "../../node_modules/underscore/modules/_chainResult.js"() {
    init_underscore();
  }
});

// ../../node_modules/underscore/modules/mixin.js
function mixin(obj) {
  each2(functions(obj), function(name2) {
    var func = _[name2] = obj[name2];
    _.prototype[name2] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_, args));
    };
  });
  return _;
}
var init_mixin = __esm({
  "../../node_modules/underscore/modules/mixin.js"() {
    init_underscore();
    init_each();
    init_functions();
    init_setup();
    init_chainResult();
  }
});

// ../../node_modules/underscore/modules/underscore-array-methods.js
var underscore_array_methods_default;
var init_underscore_array_methods = __esm({
  "../../node_modules/underscore/modules/underscore-array-methods.js"() {
    init_underscore();
    init_each();
    init_setup();
    init_chainResult();
    each2(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name2) {
      var method = ArrayProto[name2];
      _.prototype[name2] = function() {
        var obj = this._wrapped;
        if (obj != null) {
          method.apply(obj, arguments);
          if ((name2 === "shift" || name2 === "splice") && obj.length === 0) {
            delete obj[0];
          }
        }
        return chainResult(this, obj);
      };
    });
    each2(["concat", "join", "slice"], function(name2) {
      var method = ArrayProto[name2];
      _.prototype[name2] = function() {
        var obj = this._wrapped;
        if (obj != null)
          obj = method.apply(obj, arguments);
        return chainResult(this, obj);
      };
    });
    underscore_array_methods_default = _;
  }
});

// ../../node_modules/underscore/modules/index.js
var modules_exports = {};
__export(modules_exports, {
  VERSION: () => VERSION,
  after: () => after,
  all: () => every3,
  allKeys: () => allKeys,
  any: () => some3,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map2,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce,
  default: () => underscore_array_methods_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each2,
  escape: () => escape_default,
  every: () => every3,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each2,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement2,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual2,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject2,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined2,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map2,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max2,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min2,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop2,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject2,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size2,
  some: () => some3,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});
var init_modules = __esm({
  "../../node_modules/underscore/modules/index.js"() {
    init_setup();
    init_restArguments();
    init_isObject();
    init_isNull();
    init_isUndefined();
    init_isBoolean();
    init_isElement();
    init_isString();
    init_isNumber();
    init_isDate();
    init_isRegExp();
    init_isError();
    init_isSymbol();
    init_isArrayBuffer();
    init_isDataView();
    init_isArray();
    init_isFunction();
    init_isArguments();
    init_isFinite();
    init_isNaN();
    init_isTypedArray();
    init_isEmpty();
    init_isMatch();
    init_isEqual();
    init_isMap();
    init_isWeakMap();
    init_isSet();
    init_isWeakSet();
    init_keys();
    init_allKeys();
    init_values();
    init_pairs();
    init_invert();
    init_functions();
    init_extend();
    init_extendOwn();
    init_defaults();
    init_create();
    init_clone();
    init_tap();
    init_get();
    init_has2();
    init_mapObject();
    init_identity();
    init_constant();
    init_noop();
    init_toPath();
    init_property();
    init_propertyOf();
    init_matcher();
    init_times();
    init_random();
    init_now();
    init_escape();
    init_unescape();
    init_templateSettings();
    init_template();
    init_result();
    init_uniqueId();
    init_chain();
    init_iteratee();
    init_partial();
    init_bind();
    init_bindAll();
    init_memoize();
    init_delay();
    init_defer();
    init_throttle();
    init_debounce();
    init_wrap();
    init_negate();
    init_compose();
    init_after();
    init_before();
    init_once();
    init_findKey();
    init_findIndex();
    init_findLastIndex();
    init_sortedIndex();
    init_indexOf();
    init_lastIndexOf();
    init_find();
    init_findWhere();
    init_each();
    init_map();
    init_reduce();
    init_reduceRight();
    init_filter();
    init_reject();
    init_every();
    init_some();
    init_contains();
    init_invoke();
    init_pluck();
    init_where();
    init_max();
    init_min();
    init_shuffle();
    init_sample();
    init_sortBy();
    init_groupBy();
    init_indexBy();
    init_countBy();
    init_partition();
    init_toArray();
    init_size();
    init_pick();
    init_omit();
    init_first();
    init_initial();
    init_last();
    init_rest();
    init_compact();
    init_flatten2();
    init_without();
    init_uniq();
    init_union();
    init_intersection();
    init_difference();
    init_unzip();
    init_zip();
    init_object();
    init_range();
    init_chunk();
    init_mixin();
    init_underscore_array_methods();
  }
});

// ../../node_modules/underscore/modules/index-default.js
var _2, index_default_default;
var init_index_default = __esm({
  "../../node_modules/underscore/modules/index-default.js"() {
    init_modules();
    init_modules();
    _2 = mixin(modules_exports);
    _2._ = _2;
    index_default_default = _2;
  }
});

// ../../node_modules/underscore/modules/index-all.js
var index_all_exports = {};
__export(index_all_exports, {
  VERSION: () => VERSION,
  after: () => after,
  all: () => every3,
  allKeys: () => allKeys,
  any: () => some3,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map2,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce,
  default: () => index_default_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each2,
  escape: () => escape_default,
  every: () => every3,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each2,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement2,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual2,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject2,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined2,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map2,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max2,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min2,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop2,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject2,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size2,
  some: () => some3,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});
var init_index_all = __esm({
  "../../node_modules/underscore/modules/index-all.js"() {
    init_index_default();
    init_modules();
  }
});

// ../../node_modules/jquery/dist/jquery.js
var require_jquery = __commonJS({
  "../../node_modules/jquery/dist/jquery.js"(exports2, module2) {
    (function(global2, factory) {
      "use strict";
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        module2.exports = global2.document ? factory(global2, true) : function(w4) {
          if (!w4.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory(w4);
        };
      } else {
        factory(global2);
      }
    })(typeof window !== "undefined" ? window : exports2, function(window2, noGlobal) {
      "use strict";
      var arr = [];
      var getProto = Object.getPrototypeOf;
      var slice2 = arr.slice;
      var flat = arr.flat ? function(array) {
        return arr.flat.call(array);
      } : function(array) {
        return arr.concat.apply([], array);
      };
      var push2 = arr.push;
      var indexOf = arr.indexOf;
      var class2type = {};
      var toString3 = class2type.toString;
      var hasOwn = class2type.hasOwnProperty;
      var fnToString = hasOwn.toString;
      var ObjectFunctionString = fnToString.call(Object);
      var support = {};
      var isFunction3 = function isFunction4(obj) {
        return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
      };
      var isWindow = function isWindow2(obj) {
        return obj != null && obj === obj.window;
      };
      var document2 = window2.document;
      var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
      };
      function DOMEval(code3, node, doc) {
        doc = doc || document2;
        var i5, val, script = doc.createElement("script");
        script.text = code3;
        if (node) {
          for (i5 in preservedScriptAttributes) {
            val = node[i5] || node.getAttribute && node.getAttribute(i5);
            if (val) {
              script.setAttribute(i5, val);
            }
          }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
      }
      function toType(obj) {
        if (obj == null) {
          return obj + "";
        }
        return typeof obj === "object" || typeof obj === "function" ? class2type[toString3.call(obj)] || "object" : typeof obj;
      }
      var version2 = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      };
      jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version2,
        constructor: jQuery,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
          return slice2.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
          if (num == null) {
            return slice2.call(this);
          }
          return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
          var ret = jQuery.merge(this.constructor(), elems);
          ret.prevObject = this;
          return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function(callback) {
          return jQuery.each(this, callback);
        },
        map: function(callback) {
          return this.pushStack(jQuery.map(this, function(elem, i5) {
            return callback.call(elem, i5, elem);
          }));
        },
        slice: function() {
          return this.pushStack(slice2.apply(this, arguments));
        },
        first: function() {
          return this.eq(0);
        },
        last: function() {
          return this.eq(-1);
        },
        even: function() {
          return this.pushStack(jQuery.grep(this, function(_elem, i5) {
            return (i5 + 1) % 2;
          }));
        },
        odd: function() {
          return this.pushStack(jQuery.grep(this, function(_elem, i5) {
            return i5 % 2;
          }));
        },
        eq: function(i5) {
          var len = this.length, j2 = +i5 + (i5 < 0 ? len : 0);
          return this.pushStack(j2 >= 0 && j2 < len ? [this[j2]] : []);
        },
        end: function() {
          return this.prevObject || this.constructor();
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push2,
        sort: arr.sort,
        splice: arr.splice
      };
      jQuery.extend = jQuery.fn.extend = function() {
        var options, name2, src, copy, copyIsArray, clone2, target = arguments[0] || {}, i5 = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[i5] || {};
          i5++;
        }
        if (typeof target !== "object" && !isFunction3(target)) {
          target = {};
        }
        if (i5 === length) {
          target = this;
          i5--;
        }
        for (; i5 < length; i5++) {
          if ((options = arguments[i5]) != null) {
            for (name2 in options) {
              copy = options[name2];
              if (name2 === "__proto__" || target === copy) {
                continue;
              }
              if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                src = target[name2];
                if (copyIsArray && !Array.isArray(src)) {
                  clone2 = [];
                } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                  clone2 = {};
                } else {
                  clone2 = src;
                }
                copyIsArray = false;
                target[name2] = jQuery.extend(deep, clone2, copy);
              } else if (copy !== void 0) {
                target[name2] = copy;
              }
            }
          }
        }
        return target;
      };
      jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version2 + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function(msg) {
          throw new Error(msg);
        },
        noop: function() {
        },
        isPlainObject: function(obj) {
          var proto, Ctor;
          if (!obj || toString3.call(obj) !== "[object Object]") {
            return false;
          }
          proto = getProto(obj);
          if (!proto) {
            return true;
          }
          Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
          return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function(obj) {
          var name2;
          for (name2 in obj) {
            return false;
          }
          return true;
        },
        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function(code3, options, doc) {
          DOMEval(code3, { nonce: options && options.nonce }, doc);
        },
        each: function(obj, callback) {
          var length, i5 = 0;
          if (isArrayLike(obj)) {
            length = obj.length;
            for (; i5 < length; i5++) {
              if (callback.call(obj[i5], i5, obj[i5]) === false) {
                break;
              }
            }
          } else {
            for (i5 in obj) {
              if (callback.call(obj[i5], i5, obj[i5]) === false) {
                break;
              }
            }
          }
          return obj;
        },
        // Retrieve the text value of an array of DOM nodes
        text: function(elem) {
          var node, ret = "", i5 = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node = elem[i5++]) {
              ret += jQuery.text(node);
            }
          }
          if (nodeType === 1 || nodeType === 11) {
            return elem.textContent;
          }
          if (nodeType === 9) {
            return elem.documentElement.textContent;
          }
          if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        },
        // results is for internal usage only
        makeArray: function(arr2, results) {
          var ret = results || [];
          if (arr2 != null) {
            if (isArrayLike(Object(arr2))) {
              jQuery.merge(
                ret,
                typeof arr2 === "string" ? [arr2] : arr2
              );
            } else {
              push2.call(ret, arr2);
            }
          }
          return ret;
        },
        inArray: function(elem, arr2, i5) {
          return arr2 == null ? -1 : indexOf.call(arr2, elem, i5);
        },
        isXMLDoc: function(elem) {
          var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
          return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
        },
        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function(first2, second) {
          var len = +second.length, j2 = 0, i5 = first2.length;
          for (; j2 < len; j2++) {
            first2[i5++] = second[j2];
          }
          first2.length = i5;
          return first2;
        },
        grep: function(elems, callback, invert2) {
          var callbackInverse, matches = [], i5 = 0, length = elems.length, callbackExpect = !invert2;
          for (; i5 < length; i5++) {
            callbackInverse = !callback(elems[i5], i5);
            if (callbackInverse !== callbackExpect) {
              matches.push(elems[i5]);
            }
          }
          return matches;
        },
        // arg is for internal usage only
        map: function(elems, callback, arg) {
          var length, value, i5 = 0, ret = [];
          if (isArrayLike(elems)) {
            length = elems.length;
            for (; i5 < length; i5++) {
              value = callback(elems[i5], i5, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          } else {
            for (i5 in elems) {
              value = callback(elems[i5], i5, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          }
          return flat(ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support
      });
      if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
      }
      jQuery.each(
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
        function(_i, name2) {
          class2type["[object " + name2 + "]"] = name2.toLowerCase();
        }
      );
      function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length, type2 = toType(obj);
        if (isFunction3(obj) || isWindow(obj)) {
          return false;
        }
        return type2 === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
      }
      function nodeName(elem, name2) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name2.toLowerCase();
      }
      var pop = arr.pop;
      var sort = arr.sort;
      var splice = arr.splice;
      var whitespace = "[\\x20\\t\\r\\n\\f]";
      var rtrimCSS = new RegExp(
        "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
        "g"
      );
      jQuery.contains = function(a4, b4) {
        var bup = b4 && b4.parentNode;
        return a4 === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
        // IE doesn't have `contains` on SVG.
        (a4.contains ? a4.contains(bup) : a4.compareDocumentPosition && a4.compareDocumentPosition(bup) & 16));
      };
      var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
      function fcssescape(ch, asCodePoint) {
        if (asCodePoint) {
          if (ch === "\0") {
            return "\uFFFD";
          }
          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        }
        return "\\" + ch;
      }
      jQuery.escapeSelector = function(sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };
      var preferredDoc = document2, pushNative = push2;
      (function() {
        var i5, Expr, outermostContext, sortInput, hasDuplicate, push3 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches, expando = jQuery.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a4, b4) {
          if (a4 === b4) {
            hasDuplicate = true;
          }
          return 0;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
          ID: new RegExp("^#(" + identifier + ")"),
          CLASS: new RegExp("^\\.(" + identifier + ")"),
          TAG: new RegExp("^(" + identifier + "|[*])"),
          ATTR: new RegExp("^" + attributes),
          PSEUDO: new RegExp("^" + pseudos),
          CHILD: new RegExp(
            "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
            "i"
          ),
          bool: new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
          var high = "0x" + escape2.slice(1) - 65536;
          if (nonHex) {
            return nonHex;
          }
          return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, unloadHandler = function() {
          setDocument();
        }, inDisabledFieldset = addCombinator(
          function(elem) {
            return elem.disabled === true && nodeName(elem, "fieldset");
          },
          { dir: "parentNode", next: "legend" }
        );
        function safeActiveElement() {
          try {
            return document3.activeElement;
          } catch (err) {
          }
        }
        try {
          push3.apply(
            arr = slice2.call(preferredDoc.childNodes),
            preferredDoc.childNodes
          );
          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e4) {
          push3 = {
            apply: function(target, els) {
              pushNative.apply(target, slice2.call(els));
            },
            call: function(target) {
              pushNative.apply(target, slice2.call(arguments, 1));
            }
          };
        }
        function find2(selector, context, results, seed) {
          var m4, i6, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
          results = results || [];
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed) {
            setDocument(context);
            context = context || document3;
            if (documentIsHTML) {
              if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                if (m4 = match[1]) {
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m4)) {
                      if (elem.id === m4) {
                        push3.call(results, elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (newContext && (elem = newContext.getElementById(m4)) && find2.contains(context, elem) && elem.id === m4) {
                      push3.call(results, elem);
                      return results;
                    }
                  }
                } else if (match[2]) {
                  push3.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m4 = match[3]) && context.getElementsByClassName) {
                  push3.apply(results, context.getElementsByClassName(m4));
                  return results;
                }
              }
              if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                newSelector = selector;
                newContext = context;
                if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                  if (newContext != context || !support.scope) {
                    if (nid = context.getAttribute("id")) {
                      nid = jQuery.escapeSelector(nid);
                    } else {
                      context.setAttribute("id", nid = expando);
                    }
                  }
                  groups = tokenize(selector);
                  i6 = groups.length;
                  while (i6--) {
                    groups[i6] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i6]);
                  }
                  newSelector = groups.join(",");
                }
                try {
                  push3.apply(
                    results,
                    newContext.querySelectorAll(newSelector)
                  );
                  return results;
                } catch (qsaError) {
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select2(selector.replace(rtrimCSS, "$1"), context, results, seed);
        }
        function createCache() {
          var keys2 = [];
          function cache2(key, value) {
            if (keys2.push(key + " ") > Expr.cacheLength) {
              delete cache2[keys2.shift()];
            }
            return cache2[key + " "] = value;
          }
          return cache2;
        }
        function markFunction(fn) {
          fn[expando] = true;
          return fn;
        }
        function assert(fn) {
          var el = document3.createElement("fieldset");
          try {
            return !!fn(el);
          } catch (e4) {
            return false;
          } finally {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
            el = null;
          }
        }
        function createInputPseudo(type2) {
          return function(elem) {
            return nodeName(elem, "input") && elem.type === type2;
          };
        }
        function createButtonPseudo(type2) {
          return function(elem) {
            return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type2;
          };
        }
        function createDisabledPseudo(disabled) {
          return function(elem) {
            if ("form" in elem) {
              if (elem.parentNode && elem.disabled === false) {
                if ("label" in elem) {
                  if ("label" in elem.parentNode) {
                    return elem.parentNode.disabled === disabled;
                  } else {
                    return elem.disabled === disabled;
                  }
                }
                return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
              }
              return elem.disabled === disabled;
            } else if ("label" in elem) {
              return elem.disabled === disabled;
            }
            return false;
          };
        }
        function createPositionalPseudo(fn) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches2) {
              var j2, matchIndexes = fn([], seed.length, argument), i6 = matchIndexes.length;
              while (i6--) {
                if (seed[j2 = matchIndexes[i6]]) {
                  seed[j2] = !(matches2[j2] = seed[j2]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        function setDocument(node) {
          var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
          if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
            return document3;
          }
          document3 = doc;
          documentElement2 = document3.documentElement;
          documentIsHTML = !jQuery.isXMLDoc(document3);
          matches = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
          if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
            subWindow.addEventListener("unload", unloadHandler);
          }
          support.getById = assert(function(el) {
            documentElement2.appendChild(el).id = jQuery.expando;
            return !document3.getElementsByName || !document3.getElementsByName(jQuery.expando).length;
          });
          support.disconnectedMatch = assert(function(el) {
            return matches.call(el, "*");
          });
          support.scope = assert(function() {
            return document3.querySelectorAll(":scope");
          });
          support.cssHas = assert(function() {
            try {
              document3.querySelector(":has(*,:jqfake)");
              return false;
            } catch (e4) {
              return true;
            }
          });
          if (support.getById) {
            Expr.filter.ID = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
            Expr.find.ID = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var elem = context.getElementById(id);
                return elem ? [elem] : [];
              }
            };
          } else {
            Expr.filter.ID = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node2 && node2.value === attrId;
              };
            };
            Expr.find.ID = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var node2, i6, elems, elem = context.getElementById(id);
                if (elem) {
                  node2 = elem.getAttributeNode("id");
                  if (node2 && node2.value === id) {
                    return [elem];
                  }
                  elems = context.getElementsByName(id);
                  i6 = 0;
                  while (elem = elems[i6++]) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                  }
                }
                return [];
              }
            };
          }
          Expr.find.TAG = function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else {
              return context.querySelectorAll(tag);
            }
          };
          Expr.find.CLASS = function(className, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          rbuggyQSA = [];
          assert(function(el) {
            var input;
            documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            }
            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }
            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }
            input = document3.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D");
            documentElement2.appendChild(el).disabled = true;
            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            input = document3.createElement("input");
            input.setAttribute("name", "");
            el.appendChild(input);
            if (!el.querySelectorAll("[name='']").length) {
              rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
            }
          });
          if (!support.cssHas) {
            rbuggyQSA.push(":has");
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          sortOrder = function(a4, b4) {
            if (a4 === b4) {
              hasDuplicate = true;
              return 0;
            }
            var compare2 = !a4.compareDocumentPosition - !b4.compareDocumentPosition;
            if (compare2) {
              return compare2;
            }
            compare2 = (a4.ownerDocument || a4) == (b4.ownerDocument || b4) ? a4.compareDocumentPosition(b4) : (
              // Otherwise we know they are disconnected
              1
            );
            if (compare2 & 1 || !support.sortDetached && b4.compareDocumentPosition(a4) === compare2) {
              if (a4 === document3 || a4.ownerDocument == preferredDoc && find2.contains(preferredDoc, a4)) {
                return -1;
              }
              if (b4 === document3 || b4.ownerDocument == preferredDoc && find2.contains(preferredDoc, b4)) {
                return 1;
              }
              return sortInput ? indexOf.call(sortInput, a4) - indexOf.call(sortInput, b4) : 0;
            }
            return compare2 & 4 ? -1 : 1;
          };
          return document3;
        }
        find2.matches = function(expr, elements) {
          return find2(expr, null, null, elements);
        };
        find2.matchesSelector = function(elem, expr) {
          setDocument(elem);
          if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr);
              if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e4) {
              nonnativeSelectorCache(expr, true);
            }
          }
          return find2(expr, document3, null, [elem]).length > 0;
        };
        find2.contains = function(context, elem) {
          if ((context.ownerDocument || context) != document3) {
            setDocument(context);
          }
          return jQuery.contains(context, elem);
        };
        find2.attr = function(elem, name2) {
          if ((elem.ownerDocument || elem) != document3) {
            setDocument(elem);
          }
          var fn = Expr.attrHandle[name2.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name2.toLowerCase()) ? fn(elem, name2, !documentIsHTML) : void 0;
          if (val !== void 0) {
            return val;
          }
          return elem.getAttribute(name2);
        };
        find2.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        jQuery.uniqueSort = function(results) {
          var elem, duplicates = [], j2 = 0, i6 = 0;
          hasDuplicate = !support.sortStable;
          sortInput = !support.sortStable && slice2.call(results, 0);
          sort.call(results, sortOrder);
          if (hasDuplicate) {
            while (elem = results[i6++]) {
              if (elem === results[i6]) {
                j2 = duplicates.push(i6);
              }
            }
            while (j2--) {
              splice.call(results, duplicates[j2], 1);
            }
          }
          sortInput = null;
          return results;
        };
        jQuery.fn.uniqueSort = function() {
          return this.pushStack(jQuery.uniqueSort(slice2.apply(this)));
        };
        Expr = jQuery.expr = {
          // Can be adjusted by the user
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
          },
          preFilter: {
            ATTR: function(match) {
              match[1] = match[1].replace(runescape, funescape);
              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }
              return match.slice(0, 4);
            },
            CHILD: function(match) {
              match[1] = match[1].toLowerCase();
              if (match[1].slice(0, 3) === "nth") {
                if (!match[3]) {
                  find2.error(match[0]);
                }
                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +(match[7] + match[8] || match[3] === "odd");
              } else if (match[3]) {
                find2.error(match[0]);
              }
              return match;
            },
            PSEUDO: function(match) {
              var excess, unquoted = !match[6] && match[2];
              if (matchExpr.CHILD.test(match[0])) {
                return null;
              }
              if (match[3]) {
                match[2] = match[4] || match[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              }
              return match.slice(0, 3);
            }
          },
          filter: {
            TAG: function(nodeNameSelector) {
              var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return nodeName(elem, expectedNodeName);
              };
            },
            CLASS: function(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                return pattern.test(
                  typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                );
              });
            },
            ATTR: function(name2, operator, check) {
              return function(elem) {
                var result2 = find2.attr(elem, name2);
                if (result2 == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result2 += "";
                if (operator === "=") {
                  return result2 === check;
                }
                if (operator === "!=") {
                  return result2 !== check;
                }
                if (operator === "^=") {
                  return check && result2.indexOf(check) === 0;
                }
                if (operator === "*=") {
                  return check && result2.indexOf(check) > -1;
                }
                if (operator === "$=") {
                  return check && result2.slice(-check.length) === check;
                }
                if (operator === "~=") {
                  return (" " + result2.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                }
                if (operator === "|=") {
                  return result2 === check || result2.slice(0, check.length + 1) === check + "-";
                }
                return false;
              };
            },
            CHILD: function(type2, what, _argument, first2, last2) {
              var simple = type2.slice(0, 3) !== "nth", forward = type2.slice(-4) !== "last", ofType = what === "of-type";
              return first2 === 1 && last2 === 0 ? (
                // Shortcut for :nth-*(n)
                function(elem) {
                  return !!elem.parentNode;
                }
              ) : function(elem, _context, xml) {
                var cache2, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name2 = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                if (parent) {
                  if (simple) {
                    while (dir2) {
                      node = elem;
                      while (node = node[dir2]) {
                        if (ofType ? nodeName(node, name2) : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start = dir2 = type2 === "only" && !start && "nextSibling";
                    }
                    return true;
                  }
                  start = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    outerCache = parent[expando] || (parent[expando] = {});
                    cache2 = outerCache[type2] || [];
                    nodeIndex = cache2[0] === dirruns && cache2[1];
                    diff = nodeIndex && cache2[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];
                    while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                    (diff = nodeIndex = 0) || start.pop()) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        outerCache[type2] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    if (useCache) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      cache2 = outerCache[type2] || [];
                      nodeIndex = cache2[0] === dirruns && cache2[1];
                      diff = nodeIndex;
                    }
                    if (diff === false) {
                      while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                        if ((ofType ? nodeName(node, name2) : node.nodeType === 1) && ++diff) {
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {});
                            outerCache[type2] = [dirruns, diff];
                          }
                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  diff -= last2;
                  return diff === first2 || diff % first2 === 0 && diff / first2 >= 0;
                }
              };
            },
            PSEUDO: function(pseudo, argument) {
              var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find2.error("unsupported pseudo: " + pseudo);
              if (fn[expando]) {
                return fn(argument);
              }
              if (fn.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                  var idx, matched = fn(seed, argument), i6 = matched.length;
                  while (i6--) {
                    idx = indexOf.call(seed, matched[i6]);
                    seed[idx] = !(matches2[idx] = matched[i6]);
                  }
                }) : function(elem) {
                  return fn(elem, 0, args);
                };
              }
              return fn;
            }
          },
          pseudos: {
            // Potentially complex pseudos
            not: markFunction(function(selector) {
              var input = [], results = [], matcher2 = compile(selector.replace(rtrimCSS, "$1"));
              return matcher2[expando] ? markFunction(function(seed, matches2, _context, xml) {
                var elem, unmatched = matcher2(seed, null, xml, []), i6 = seed.length;
                while (i6--) {
                  if (elem = unmatched[i6]) {
                    seed[i6] = !(matches2[i6] = elem);
                  }
                }
              }) : function(elem, _context, xml) {
                input[0] = elem;
                matcher2(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
            }),
            has: markFunction(function(selector) {
              return function(elem) {
                return find2(selector, elem).length > 0;
              };
            }),
            contains: markFunction(function(text) {
              text = text.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;
              };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // https://www.w3.org/TR/selectors/#lang-pseudo
            lang: markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                find2.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            // Miscellaneous
            target: function(elem) {
              var hash = window2.location && window2.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            root: function(elem) {
              return elem === documentElement2;
            },
            focus: function(elem) {
              return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            enabled: createDisabledPseudo(false),
            disabled: createDisabledPseudo(true),
            checked: function(elem) {
              return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
            },
            selected: function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            // Contents
            empty: function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            parent: function(elem) {
              return !Expr.pseudos.empty(elem);
            },
            // Element/input types
            header: function(elem) {
              return rheader.test(elem.nodeName);
            },
            input: function(elem) {
              return rinputs.test(elem.nodeName);
            },
            button: function(elem) {
              return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
            },
            text: function(elem) {
              var attr;
              return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
              // New HTML5 attribute values (e.g., "search") appear
              // with elem.type === "text"
              ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            // Position-in-collection
            first: createPositionalPseudo(function() {
              return [0];
            }),
            last: createPositionalPseudo(function(_matchIndexes, length) {
              return [length - 1];
            }),
            eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            even: createPositionalPseudo(function(matchIndexes, length) {
              var i6 = 0;
              for (; i6 < length; i6 += 2) {
                matchIndexes.push(i6);
              }
              return matchIndexes;
            }),
            odd: createPositionalPseudo(function(matchIndexes, length) {
              var i6 = 1;
              for (; i6 < length; i6 += 2) {
                matchIndexes.push(i6);
              }
              return matchIndexes;
            }),
            lt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i6;
              if (argument < 0) {
                i6 = argument + length;
              } else if (argument > length) {
                i6 = length;
              } else {
                i6 = argument;
              }
              for (; --i6 >= 0; ) {
                matchIndexes.push(i6);
              }
              return matchIndexes;
            }),
            gt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i6 = argument < 0 ? argument + length : argument;
              for (; ++i6 < length; ) {
                matchIndexes.push(i6);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos.nth = Expr.pseudos.eq;
        for (i5 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
          Expr.pseudos[i5] = createInputPseudo(i5);
        }
        for (i5 in { submit: true, reset: true }) {
          Expr.pseudos[i5] = createButtonPseudo(i5);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        function tokenize(selector, parseOnly) {
          var matched, match, tokens, type2, soFar, groups, preFilters, cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                soFar = soFar.slice(match[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match = rleadingCombinator.exec(soFar)) {
              matched = match.shift();
              tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace(rtrimCSS, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type2 in Expr.filter) {
              if ((match = matchExpr[type2].exec(soFar)) && (!preFilters[type2] || (match = preFilters[type2](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type: type2,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          if (parseOnly) {
            return soFar.length;
          }
          return soFar ? find2.error(selector) : (
            // Cache the tokens
            tokenCache(selector, groups).slice(0)
          );
        }
        function toSelector(tokens) {
          var i6 = 0, len = tokens.length, selector = "";
          for (; i6 < len; i6++) {
            selector += tokens[i6].value;
          }
          return selector;
        }
        function addCombinator(matcher2, combinator, base) {
          var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
          return combinator.first ? (
            // Check against closest ancestor/preceding element
            function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher2(elem, context, xml);
                }
              }
              return false;
            }
          ) : (
            // Check against all ancestor/preceding elements
            function(elem, context, xml) {
              var oldCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher2(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    if (skip && nodeName(elem, skip)) {
                      elem = elem[dir2] || elem;
                    } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      outerCache[key] = newCache;
                      if (newCache[2] = matcher2(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            }
          );
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i6 = matchers.length;
            while (i6--) {
              if (!matchers[i6](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i6 = 0, len = contexts.length;
          for (; i6 < len; i6++) {
            find2(selector, contexts[i6], results);
          }
          return results;
        }
        function condense(unmatched, map4, filter2, context, xml) {
          var elem, newUnmatched = [], i6 = 0, len = unmatched.length, mapped = map4 != null;
          for (; i6 < len; i6++) {
            if (elem = unmatched[i6]) {
              if (!filter2 || filter2(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map4.push(i6);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher2, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp, i6, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
              selector || "*",
              context.nodeType ? [context] : context,
              []
            ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
            if (matcher2) {
              matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                // ...intermediate processing is necessary
                []
              ) : (
                // ...otherwise use results directly
                results
              );
              matcher2(matcherIn, matcherOut, context, xml);
            } else {
              matcherOut = matcherIn;
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i6 = temp.length;
              while (i6--) {
                if (elem = temp[i6]) {
                  matcherOut[postMap[i6]] = !(matcherIn[postMap[i6]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i6 = matcherOut.length;
                  while (i6--) {
                    if (elem = matcherOut[i6]) {
                      temp.push(matcherIn[i6] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i6 = matcherOut.length;
                while (i6--) {
                  if ((elem = matcherOut[i6]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i6]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(
                matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
              );
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push3.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher2, j2, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i6 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf.call(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context, xml) {
            var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
          for (; i6 < len; i6++) {
            if (matcher2 = Expr.relative[tokens[i6].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher2)];
            } else {
              matcher2 = Expr.filter[tokens[i6].type].apply(null, tokens[i6].matches);
              if (matcher2[expando]) {
                j2 = ++i6;
                for (; j2 < len; j2++) {
                  if (Expr.relative[tokens[j2].type]) {
                    break;
                  }
                }
                return setMatcher(
                  i6 > 1 && elementMatcher(matchers),
                  i6 > 1 && toSelector(
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i6 - 1).concat({ value: tokens[i6 - 2].type === " " ? "*" : "" })
                  ).replace(rtrimCSS, "$1"),
                  matcher2,
                  i6 < j2 && matcherFromTokens(tokens.slice(i6, j2)),
                  j2 < len && matcherFromTokens(tokens = tokens.slice(j2)),
                  j2 < len && toSelector(tokens)
                );
              }
              matchers.push(matcher2);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j2, matcher2, matchedCount = 0, i6 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context == document3 || context || outermost;
            }
            for (; i6 !== len && (elem = elems[i6]) != null; i6++) {
              if (byElement && elem) {
                j2 = 0;
                if (!context && elem.ownerDocument != document3) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while (matcher2 = elementMatchers[j2++]) {
                  if (matcher2(elem, context || document3, xml)) {
                    push3.call(results, elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher2 && elem) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i6;
            if (bySet && i6 !== matchedCount) {
              j2 = 0;
              while (matcher2 = setMatchers[j2++]) {
                matcher2(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i6--) {
                    if (!(unmatched[i6] || setMatched[i6])) {
                      setMatched[i6] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push3.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                jQuery.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        function compile(selector, match) {
          var i6, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match) {
              match = tokenize(selector);
            }
            i6 = match.length;
            while (i6--) {
              cached = matcherFromTokens(match[i6]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(
              selector,
              matcherFromGroupMatchers(elementMatchers, setMatchers)
            );
            cached.selector = selector;
          }
          return cached;
        }
        function select2(selector, context, results, seed) {
          var i6, tokens, token, type2, find3, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
          results = results || [];
          if (match.length === 1) {
            tokens = match[0] = match[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find.ID(
                token.matches[0].replace(runescape, funescape),
                context
              ) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i6 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
            while (i6--) {
              token = tokens[i6];
              if (Expr.relative[type2 = token.type]) {
                break;
              }
              if (find3 = Expr.find[type2]) {
                if (seed = find3(
                  token.matches[0].replace(runescape, funescape),
                  rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                )) {
                  tokens.splice(i6, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push3.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile(selector, match))(
            seed,
            context,
            !documentIsHTML,
            results,
            !context || rsibling.test(selector) && testContext(context.parentNode) || context
          );
          return results;
        }
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        setDocument();
        support.sortDetached = assert(function(el) {
          return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
        });
        jQuery.find = find2;
        jQuery.expr[":"] = jQuery.expr.pseudos;
        jQuery.unique = jQuery.uniqueSort;
        find2.compile = compile;
        find2.select = select2;
        find2.setDocument = setDocument;
        find2.tokenize = tokenize;
        find2.escape = jQuery.escapeSelector;
        find2.getText = jQuery.text;
        find2.isXML = jQuery.isXMLDoc;
        find2.selectors = jQuery.expr;
        find2.support = jQuery.support;
        find2.uniqueSort = jQuery.uniqueSort;
      })();
      var dir = function(elem, dir2, until) {
        var matched = [], truncate = until !== void 0;
        while ((elem = elem[dir2]) && elem.nodeType !== 9) {
          if (elem.nodeType === 1) {
            if (truncate && jQuery(elem).is(until)) {
              break;
            }
            matched.push(elem);
          }
        }
        return matched;
      };
      var siblings = function(n4, elem) {
        var matched = [];
        for (; n4; n4 = n4.nextSibling) {
          if (n4.nodeType === 1 && n4 !== elem) {
            matched.push(n4);
          }
        }
        return matched;
      };
      var rneedsContext = jQuery.expr.match.needsContext;
      var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
      function winnow(elements, qualifier, not) {
        if (isFunction3(qualifier)) {
          return jQuery.grep(elements, function(elem, i5) {
            return !!qualifier.call(elem, i5, elem) !== not;
          });
        }
        if (qualifier.nodeType) {
          return jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not;
          });
        }
        if (typeof qualifier !== "string") {
          return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
          });
        }
        return jQuery.filter(qualifier, elements, not);
      }
      jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
          expr = ":not(" + expr + ")";
        }
        if (elems.length === 1 && elem.nodeType === 1) {
          return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }
        return jQuery.find.matches(expr, jQuery.grep(elems, function(elem2) {
          return elem2.nodeType === 1;
        }));
      };
      jQuery.fn.extend({
        find: function(selector) {
          var i5, ret, len = this.length, self2 = this;
          if (typeof selector !== "string") {
            return this.pushStack(jQuery(selector).filter(function() {
              for (i5 = 0; i5 < len; i5++) {
                if (jQuery.contains(self2[i5], this)) {
                  return true;
                }
              }
            }));
          }
          ret = this.pushStack([]);
          for (i5 = 0; i5 < len; i5++) {
            jQuery.find(selector, self2[i5], ret);
          }
          return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
          return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
          return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
          return !!winnow(
            this,
            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
            false
          ).length;
        }
      });
      var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root2) {
        var match, elem;
        if (!selector) {
          return this;
        }
        root2 = root2 || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(
                match[1],
                context && context.nodeType ? context.ownerDocument || context : document2,
                true
              ));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (isFunction3(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document2.getElementById(match[2]);
              if (elem) {
                this[0] = elem;
                this.length = 1;
              }
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root2).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;
        } else if (isFunction3(selector)) {
          return root2.ready !== void 0 ? root2.ready(selector) : (
            // Execute immediately if ready is not present
            selector(jQuery)
          );
        }
        return jQuery.makeArray(selector, this);
      };
      init.prototype = jQuery.fn;
      rootjQuery = jQuery(document2);
      var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
      jQuery.fn.extend({
        has: function(target) {
          var targets = jQuery(target, this), l7 = targets.length;
          return this.filter(function() {
            var i5 = 0;
            for (; i5 < l7; i5++) {
              if (jQuery.contains(this, targets[i5])) {
                return true;
              }
            }
          });
        },
        closest: function(selectors, context) {
          var cur, i5 = 0, l7 = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
          if (!rneedsContext.test(selectors)) {
            for (; i5 < l7; i5++) {
              for (cur = this[i5]; cur && cur !== context; cur = cur.parentNode) {
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                  // Don't pass non-elements to jQuery#find
                  cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors)
                ))) {
                  matched.push(cur);
                  break;
                }
              }
            }
          }
          return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function(elem) {
          if (!elem) {
            return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
          }
          if (typeof elem === "string") {
            return indexOf.call(jQuery(elem), this[0]);
          }
          return indexOf.call(
            this,
            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem
          );
        },
        add: function(selector, context) {
          return this.pushStack(
            jQuery.uniqueSort(
              jQuery.merge(this.get(), jQuery(selector, context))
            )
          );
        },
        addBack: function(selector) {
          return this.add(
            selector == null ? this.prevObject : this.prevObject.filter(selector)
          );
        }
      });
      function sibling(cur, dir2) {
        while ((cur = cur[dir2]) && cur.nodeType !== 1) {
        }
        return cur;
      }
      jQuery.each({
        parent: function(elem) {
          var parent = elem.parentNode;
          return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
          return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, _i, until) {
          return dir(elem, "parentNode", until);
        },
        next: function(elem) {
          return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
          return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
          return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
          return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, _i, until) {
          return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, _i, until) {
          return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
          return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
          return siblings(elem.firstChild);
        },
        contents: function(elem) {
          if (elem.contentDocument != null && // Support: IE 11+
          // <object> elements with no `data` attribute has an object
          // `contentDocument` with a `null` prototype.
          getProto(elem.contentDocument)) {
            return elem.contentDocument;
          }
          if (nodeName(elem, "template")) {
            elem = elem.content || elem;
          }
          return jQuery.merge([], elem.childNodes);
        }
      }, function(name2, fn) {
        jQuery.fn[name2] = function(until, selector) {
          var matched = jQuery.map(this, fn, until);
          if (name2.slice(-5) !== "Until") {
            selector = until;
          }
          if (selector && typeof selector === "string") {
            matched = jQuery.filter(selector, matched);
          }
          if (this.length > 1) {
            if (!guaranteedUnique[name2]) {
              jQuery.uniqueSort(matched);
            }
            if (rparentsprev.test(name2)) {
              matched.reverse();
            }
          }
          return this.pushStack(matched);
        };
      });
      var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
      function createOptions(options) {
        var object2 = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function(_5, flag) {
          object2[flag] = true;
        });
        return object2;
      }
      jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
          locked = locked || options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        }, self2 = {
          // Add a callback or a collection of callbacks to the list
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add(args) {
                jQuery.each(args, function(_5, arg) {
                  if (isFunction3(arg)) {
                    if (!options.unique || !self2.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && toType(arg) !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          // Remove a callback from the list
          remove: function() {
            jQuery.each(arguments, function(_5, arg) {
              var index2;
              while ((index2 = jQuery.inArray(arg, list, index2)) > -1) {
                list.splice(index2, 1);
                if (index2 <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          // Check if a given callback is in the list.
          // If no argument is given, return whether or not list has callbacks attached.
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          // Remove all callbacks from the list
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          // Disable .fire and .add
          // Abort any current/pending executions
          // Clear all callbacks and values
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          // Disable .fire
          // Also disable .add unless we have memory (since it would have no effect)
          // Abort any pending executions
          lock: function() {
            locked = queue = [];
            if (!memory && !firing) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          // Call all callbacks with the given context and arguments
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          // Call all the callbacks with the given arguments
          fire: function() {
            self2.fireWith(this, arguments);
            return this;
          },
          // To know if the callbacks have already been called at least once
          fired: function() {
            return !!fired;
          }
        };
        return self2;
      };
      function Identity(v2) {
        return v2;
      }
      function Thrower(ex) {
        throw ex;
      }
      function adoptValue(value, resolve, reject4, noValue) {
        var method;
        try {
          if (value && isFunction3(method = value.promise)) {
            method.call(value).done(resolve).fail(reject4);
          } else if (value && isFunction3(method = value.then)) {
            method.call(value, resolve, reject4);
          } else {
            resolve.apply(void 0, [value].slice(noValue));
          }
        } catch (value2) {
          reject4.apply(void 0, [value2]);
        }
      }
      jQuery.extend({
        Deferred: function(func) {
          var tuples = [
            // action, add listener, callbacks,
            // ... .then handlers, argument index, [final state]
            [
              "notify",
              "progress",
              jQuery.Callbacks("memory"),
              jQuery.Callbacks("memory"),
              2
            ],
            [
              "resolve",
              "done",
              jQuery.Callbacks("once memory"),
              jQuery.Callbacks("once memory"),
              0,
              "resolved"
            ],
            [
              "reject",
              "fail",
              jQuery.Callbacks("once memory"),
              jQuery.Callbacks("once memory"),
              1,
              "rejected"
            ]
          ], state = "pending", promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function(fn) {
              return promise.then(null, fn);
            },
            // Keep pipe for back-compat
            pipe: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(_i, tuple) {
                  var fn = isFunction3(fns[tuple[4]]) && fns[tuple[4]];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && isFunction3(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](
                        this,
                        fn ? [returned] : arguments
                      );
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;
              function resolve(depth, deferred2, handler, special) {
                return function() {
                  var that = this, args = arguments, mightThrow = function() {
                    var returned, then;
                    if (depth < maxDepth) {
                      return;
                    }
                    returned = handler.apply(that, args);
                    if (returned === deferred2.promise()) {
                      throw new TypeError("Thenable self-resolution");
                    }
                    then = returned && // Support: Promises/A+ section 2.3.4
                    // https://promisesaplus.com/#point-64
                    // Only check objects and functions for thenability
                    (typeof returned === "object" || typeof returned === "function") && returned.then;
                    if (isFunction3(then)) {
                      if (special) {
                        then.call(
                          returned,
                          resolve(maxDepth, deferred2, Identity, special),
                          resolve(maxDepth, deferred2, Thrower, special)
                        );
                      } else {
                        maxDepth++;
                        then.call(
                          returned,
                          resolve(maxDepth, deferred2, Identity, special),
                          resolve(maxDepth, deferred2, Thrower, special),
                          resolve(
                            maxDepth,
                            deferred2,
                            Identity,
                            deferred2.notifyWith
                          )
                        );
                      }
                    } else {
                      if (handler !== Identity) {
                        that = void 0;
                        args = [returned];
                      }
                      (special || deferred2.resolveWith)(that, args);
                    }
                  }, process2 = special ? mightThrow : function() {
                    try {
                      mightThrow();
                    } catch (e4) {
                      if (jQuery.Deferred.exceptionHook) {
                        jQuery.Deferred.exceptionHook(
                          e4,
                          process2.error
                        );
                      }
                      if (depth + 1 >= maxDepth) {
                        if (handler !== Thrower) {
                          that = void 0;
                          args = [e4];
                        }
                        deferred2.rejectWith(that, args);
                      }
                    }
                  };
                  if (depth) {
                    process2();
                  } else {
                    if (jQuery.Deferred.getErrorHook) {
                      process2.error = jQuery.Deferred.getErrorHook();
                    } else if (jQuery.Deferred.getStackHook) {
                      process2.error = jQuery.Deferred.getStackHook();
                    }
                    window2.setTimeout(process2);
                  }
                };
              }
              return jQuery.Deferred(function(newDefer) {
                tuples[0][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction3(onProgress) ? onProgress : Identity,
                    newDefer.notifyWith
                  )
                );
                tuples[1][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction3(onFulfilled) ? onFulfilled : Identity
                  )
                );
                tuples[2][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction3(onRejected) ? onRejected : Thrower
                  )
                );
              }).promise();
            },
            // Get a promise for this deferred
            // If obj is provided, the promise aspect is added to the object
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          }, deferred = {};
          jQuery.each(tuples, function(i5, tuple) {
            var list = tuple[2], stateString = tuple[5];
            promise[tuple[1]] = list.add;
            if (stateString) {
              list.add(
                function() {
                  state = stateString;
                },
                // rejected_callbacks.disable
                // fulfilled_callbacks.disable
                tuples[3 - i5][2].disable,
                // rejected_handlers.disable
                // fulfilled_handlers.disable
                tuples[3 - i5][3].disable,
                // progress_callbacks.lock
                tuples[0][2].lock,
                // progress_handlers.lock
                tuples[0][3].lock
              );
            }
            list.add(tuple[3].fire);
            deferred[tuple[0]] = function() {
              deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
              return this;
            };
            deferred[tuple[0] + "With"] = list.fireWith;
          });
          promise.promise(deferred);
          if (func) {
            func.call(deferred, deferred);
          }
          return deferred;
        },
        // Deferred helper
        when: function(singleValue) {
          var remaining = arguments.length, i5 = remaining, resolveContexts = Array(i5), resolveValues = slice2.call(arguments), primary = jQuery.Deferred(), updateFunc = function(i6) {
            return function(value) {
              resolveContexts[i6] = this;
              resolveValues[i6] = arguments.length > 1 ? slice2.call(arguments) : value;
              if (!--remaining) {
                primary.resolveWith(resolveContexts, resolveValues);
              }
            };
          };
          if (remaining <= 1) {
            adoptValue(
              singleValue,
              primary.done(updateFunc(i5)).resolve,
              primary.reject,
              !remaining
            );
            if (primary.state() === "pending" || isFunction3(resolveValues[i5] && resolveValues[i5].then)) {
              return primary.then();
            }
          }
          while (i5--) {
            adoptValue(resolveValues[i5], updateFunc(i5), primary.reject);
          }
          return primary.promise();
        }
      });
      var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
      jQuery.Deferred.exceptionHook = function(error, asyncError) {
        if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
          window2.console.warn(
            "jQuery.Deferred exception: " + error.message,
            error.stack,
            asyncError
          );
        }
      };
      jQuery.readyException = function(error) {
        window2.setTimeout(function() {
          throw error;
        });
      };
      var readyList = jQuery.Deferred();
      jQuery.fn.ready = function(fn) {
        readyList.then(fn).catch(function(error) {
          jQuery.readyException(error);
        });
        return this;
      };
      jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See trac-6781
        readyWait: 1,
        // Handle when the DOM is ready
        ready: function(wait) {
          if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
            return;
          }
          jQuery.isReady = true;
          if (wait !== true && --jQuery.readyWait > 0) {
            return;
          }
          readyList.resolveWith(document2, [jQuery]);
        }
      });
      jQuery.ready.then = readyList.then;
      function completed() {
        document2.removeEventListener("DOMContentLoaded", completed);
        window2.removeEventListener("load", completed);
        jQuery.ready();
      }
      if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
        window2.setTimeout(jQuery.ready);
      } else {
        document2.addEventListener("DOMContentLoaded", completed);
        window2.addEventListener("load", completed);
      }
      var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i5 = 0, len = elems.length, bulk = key == null;
        if (toType(key) === "object") {
          chainable = true;
          for (i5 in key) {
            access(elems, fn, i5, key[i5], true, emptyGet, raw);
          }
        } else if (value !== void 0) {
          chainable = true;
          if (!isFunction3(value)) {
            raw = true;
          }
          if (bulk) {
            if (raw) {
              fn.call(elems, value);
              fn = null;
            } else {
              bulk = fn;
              fn = function(elem, _key, value2) {
                return bulk.call(jQuery(elem), value2);
              };
            }
          }
          if (fn) {
            for (; i5 < len; i5++) {
              fn(
                elems[i5],
                key,
                raw ? value : value.call(elems[i5], i5, fn(elems[i5], key))
              );
            }
          }
        }
        if (chainable) {
          return elems;
        }
        if (bulk) {
          return fn.call(elems);
        }
        return len ? fn(elems[0], key) : emptyGet;
      };
      var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
      function fcamelCase(_all, letter) {
        return letter.toUpperCase();
      }
      function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
      }
      var acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
      };
      function Data() {
        this.expando = jQuery.expando + Data.uid++;
      }
      Data.uid = 1;
      Data.prototype = {
        cache: function(owner) {
          var value = owner[this.expando];
          if (!value) {
            value = {};
            if (acceptData(owner)) {
              if (owner.nodeType) {
                owner[this.expando] = value;
              } else {
                Object.defineProperty(owner, this.expando, {
                  value,
                  configurable: true
                });
              }
            }
          }
          return value;
        },
        set: function(owner, data, value) {
          var prop, cache2 = this.cache(owner);
          if (typeof data === "string") {
            cache2[camelCase(data)] = value;
          } else {
            for (prop in data) {
              cache2[camelCase(prop)] = data[prop];
            }
          }
          return cache2;
        },
        get: function(owner, key) {
          return key === void 0 ? this.cache(owner) : (
            // Always use camelCase key (gh-2257)
            owner[this.expando] && owner[this.expando][camelCase(key)]
          );
        },
        access: function(owner, key, value) {
          if (key === void 0 || key && typeof key === "string" && value === void 0) {
            return this.get(owner, key);
          }
          this.set(owner, key, value);
          return value !== void 0 ? value : key;
        },
        remove: function(owner, key) {
          var i5, cache2 = owner[this.expando];
          if (cache2 === void 0) {
            return;
          }
          if (key !== void 0) {
            if (Array.isArray(key)) {
              key = key.map(camelCase);
            } else {
              key = camelCase(key);
              key = key in cache2 ? [key] : key.match(rnothtmlwhite) || [];
            }
            i5 = key.length;
            while (i5--) {
              delete cache2[key[i5]];
            }
          }
          if (key === void 0 || jQuery.isEmptyObject(cache2)) {
            if (owner.nodeType) {
              owner[this.expando] = void 0;
            } else {
              delete owner[this.expando];
            }
          }
        },
        hasData: function(owner) {
          var cache2 = owner[this.expando];
          return cache2 !== void 0 && !jQuery.isEmptyObject(cache2);
        }
      };
      var dataPriv = new Data();
      var dataUser = new Data();
      var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
      function getData(data) {
        if (data === "true") {
          return true;
        }
        if (data === "false") {
          return false;
        }
        if (data === "null") {
          return null;
        }
        if (data === +data + "") {
          return +data;
        }
        if (rbrace.test(data)) {
          return JSON.parse(data);
        }
        return data;
      }
      function dataAttr(elem, key, data) {
        var name2;
        if (data === void 0 && elem.nodeType === 1) {
          name2 = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
          data = elem.getAttribute(name2);
          if (typeof data === "string") {
            try {
              data = getData(data);
            } catch (e4) {
            }
            dataUser.set(elem, key, data);
          } else {
            data = void 0;
          }
        }
        return data;
      }
      jQuery.extend({
        hasData: function(elem) {
          return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name2, data) {
          return dataUser.access(elem, name2, data);
        },
        removeData: function(elem, name2) {
          dataUser.remove(elem, name2);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function(elem, name2, data) {
          return dataPriv.access(elem, name2, data);
        },
        _removeData: function(elem, name2) {
          dataPriv.remove(elem, name2);
        }
      });
      jQuery.fn.extend({
        data: function(key, value) {
          var i5, name2, data, elem = this[0], attrs = elem && elem.attributes;
          if (key === void 0) {
            if (this.length) {
              data = dataUser.get(elem);
              if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                i5 = attrs.length;
                while (i5--) {
                  if (attrs[i5]) {
                    name2 = attrs[i5].name;
                    if (name2.indexOf("data-") === 0) {
                      name2 = camelCase(name2.slice(5));
                      dataAttr(elem, name2, data[name2]);
                    }
                  }
                }
                dataPriv.set(elem, "hasDataAttrs", true);
              }
            }
            return data;
          }
          if (typeof key === "object") {
            return this.each(function() {
              dataUser.set(this, key);
            });
          }
          return access(this, function(value2) {
            var data2;
            if (elem && value2 === void 0) {
              data2 = dataUser.get(elem, key);
              if (data2 !== void 0) {
                return data2;
              }
              data2 = dataAttr(elem, key);
              if (data2 !== void 0) {
                return data2;
              }
              return;
            }
            this.each(function() {
              dataUser.set(this, key, value2);
            });
          }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
          return this.each(function() {
            dataUser.remove(this, key);
          });
        }
      });
      jQuery.extend({
        queue: function(elem, type2, data) {
          var queue;
          if (elem) {
            type2 = (type2 || "fx") + "queue";
            queue = dataPriv.get(elem, type2);
            if (data) {
              if (!queue || Array.isArray(data)) {
                queue = dataPriv.access(elem, type2, jQuery.makeArray(data));
              } else {
                queue.push(data);
              }
            }
            return queue || [];
          }
        },
        dequeue: function(elem, type2) {
          type2 = type2 || "fx";
          var queue = jQuery.queue(elem, type2), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type2), next = function() {
            jQuery.dequeue(elem, type2);
          };
          if (fn === "inprogress") {
            fn = queue.shift();
            startLength--;
          }
          if (fn) {
            if (type2 === "fx") {
              queue.unshift("inprogress");
            }
            delete hooks.stop;
            fn.call(elem, next, hooks);
          }
          if (!startLength && hooks) {
            hooks.empty.fire();
          }
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function(elem, type2) {
          var key = type2 + "queueHooks";
          return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
            empty: jQuery.Callbacks("once memory").add(function() {
              dataPriv.remove(elem, [type2 + "queue", key]);
            })
          });
        }
      });
      jQuery.fn.extend({
        queue: function(type2, data) {
          var setter = 2;
          if (typeof type2 !== "string") {
            data = type2;
            type2 = "fx";
            setter--;
          }
          if (arguments.length < setter) {
            return jQuery.queue(this[0], type2);
          }
          return data === void 0 ? this : this.each(function() {
            var queue = jQuery.queue(this, type2, data);
            jQuery._queueHooks(this, type2);
            if (type2 === "fx" && queue[0] !== "inprogress") {
              jQuery.dequeue(this, type2);
            }
          });
        },
        dequeue: function(type2) {
          return this.each(function() {
            jQuery.dequeue(this, type2);
          });
        },
        clearQueue: function(type2) {
          return this.queue(type2 || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type2, obj) {
          var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i5 = this.length, resolve = function() {
            if (!--count) {
              defer.resolveWith(elements, [elements]);
            }
          };
          if (typeof type2 !== "string") {
            obj = type2;
            type2 = void 0;
          }
          type2 = type2 || "fx";
          while (i5--) {
            tmp = dataPriv.get(elements[i5], type2 + "queueHooks");
            if (tmp && tmp.empty) {
              count++;
              tmp.empty.add(resolve);
            }
          }
          resolve();
          return defer.promise(obj);
        }
      });
      var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
      var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
      var cssExpand = ["Top", "Right", "Bottom", "Left"];
      var documentElement = document2.documentElement;
      var isAttached = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem);
      }, composed = { composed: true };
      if (documentElement.getRootNode) {
        isAttached = function(elem) {
          return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
        };
      }
      var isHiddenWithinTree = function(elem, el) {
        elem = el || elem;
        return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached(elem) && jQuery.css(elem, "display") === "none";
      };
      function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery.css(elem, prop, "");
        }, initial2 = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial2) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
          initial2 = initial2 / 2;
          unit = unit || initialInUnit[3];
          initialInUnit = +initial2 || 1;
          while (maxIterations--) {
            jQuery.style(elem, prop, initialInUnit + unit);
            if ((1 - scale) * (1 - (scale = currentValue() / initial2 || 0.5)) <= 0) {
              maxIterations = 0;
            }
            initialInUnit = initialInUnit / scale;
          }
          initialInUnit = initialInUnit * 2;
          jQuery.style(elem, prop, initialInUnit + unit);
          valueParts = valueParts || [];
        }
        if (valueParts) {
          initialInUnit = +initialInUnit || +initial2 || 0;
          adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
          if (tween) {
            tween.unit = unit;
            tween.start = initialInUnit;
            tween.end = adjusted;
          }
        }
        return adjusted;
      }
      var defaultDisplayMap = {};
      function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
        if (display) {
          return display;
        }
        temp = doc.body.appendChild(doc.createElement(nodeName2));
        display = jQuery.css(temp, "display");
        temp.parentNode.removeChild(temp);
        if (display === "none") {
          display = "block";
        }
        defaultDisplayMap[nodeName2] = display;
        return display;
      }
      function showHide(elements, show) {
        var display, elem, values2 = [], index2 = 0, length = elements.length;
        for (; index2 < length; index2++) {
          elem = elements[index2];
          if (!elem.style) {
            continue;
          }
          display = elem.style.display;
          if (show) {
            if (display === "none") {
              values2[index2] = dataPriv.get(elem, "display") || null;
              if (!values2[index2]) {
                elem.style.display = "";
              }
            }
            if (elem.style.display === "" && isHiddenWithinTree(elem)) {
              values2[index2] = getDefaultDisplay(elem);
            }
          } else {
            if (display !== "none") {
              values2[index2] = "none";
              dataPriv.set(elem, "display", display);
            }
          }
        }
        for (index2 = 0; index2 < length; index2++) {
          if (values2[index2] != null) {
            elements[index2].style.display = values2[index2];
          }
        }
        return elements;
      }
      jQuery.fn.extend({
        show: function() {
          return showHide(this, true);
        },
        hide: function() {
          return showHide(this);
        },
        toggle: function(state) {
          if (typeof state === "boolean") {
            return state ? this.show() : this.hide();
          }
          return this.each(function() {
            if (isHiddenWithinTree(this)) {
              jQuery(this).show();
            } else {
              jQuery(this).hide();
            }
          });
        }
      });
      var rcheckableType = /^(?:checkbox|radio)$/i;
      var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
      var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
      (function() {
        var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        div.innerHTML = "<option></option>";
        support.option = !!div.lastChild;
      })();
      var wrapMap = {
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      if (!support.option) {
        wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
      }
      function getAll(context, tag) {
        var ret;
        if (typeof context.getElementsByTagName !== "undefined") {
          ret = context.getElementsByTagName(tag || "*");
        } else if (typeof context.querySelectorAll !== "undefined") {
          ret = context.querySelectorAll(tag || "*");
        } else {
          ret = [];
        }
        if (tag === void 0 || tag && nodeName(context, tag)) {
          return jQuery.merge([context], ret);
        }
        return ret;
      }
      function setGlobalEval(elems, refElements) {
        var i5 = 0, l7 = elems.length;
        for (; i5 < l7; i5++) {
          dataPriv.set(
            elems[i5],
            "globalEval",
            !refElements || dataPriv.get(refElements[i5], "globalEval")
          );
        }
      }
      var rhtml = /<|&#?\w+;/;
      function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap2, attached, j2, fragment = context.createDocumentFragment(), nodes = [], i5 = 0, l7 = elems.length;
        for (; i5 < l7; i5++) {
          elem = elems[i5];
          if (elem || elem === 0) {
            if (toType(elem) === "object") {
              jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
            } else if (!rhtml.test(elem)) {
              nodes.push(context.createTextNode(elem));
            } else {
              tmp = tmp || fragment.appendChild(context.createElement("div"));
              tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
              wrap2 = wrapMap[tag] || wrapMap._default;
              tmp.innerHTML = wrap2[1] + jQuery.htmlPrefilter(elem) + wrap2[2];
              j2 = wrap2[0];
              while (j2--) {
                tmp = tmp.lastChild;
              }
              jQuery.merge(nodes, tmp.childNodes);
              tmp = fragment.firstChild;
              tmp.textContent = "";
            }
          }
        }
        fragment.textContent = "";
        i5 = 0;
        while (elem = nodes[i5++]) {
          if (selection && jQuery.inArray(elem, selection) > -1) {
            if (ignored) {
              ignored.push(elem);
            }
            continue;
          }
          attached = isAttached(elem);
          tmp = getAll(fragment.appendChild(elem), "script");
          if (attached) {
            setGlobalEval(tmp);
          }
          if (scripts) {
            j2 = 0;
            while (elem = tmp[j2++]) {
              if (rscriptType.test(elem.type || "")) {
                scripts.push(elem);
              }
            }
          }
        }
        return fragment;
      }
      var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      function on(elem, types2, selector, data, fn, one) {
        var origFn, type2;
        if (typeof types2 === "object") {
          if (typeof selector !== "string") {
            data = data || selector;
            selector = void 0;
          }
          for (type2 in types2) {
            on(elem, type2, selector, data, types2[type2], one);
          }
          return elem;
        }
        if (data == null && fn == null) {
          fn = selector;
          data = selector = void 0;
        } else if (fn == null) {
          if (typeof selector === "string") {
            fn = data;
            data = void 0;
          } else {
            fn = data;
            data = selector;
            selector = void 0;
          }
        }
        if (fn === false) {
          fn = returnFalse;
        } else if (!fn) {
          return elem;
        }
        if (one === 1) {
          origFn = fn;
          fn = function(event) {
            jQuery().off(event);
            return origFn.apply(this, arguments);
          };
          fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function() {
          jQuery.event.add(this, types2, fn, data, selector);
        });
      }
      jQuery.event = {
        global: {},
        add: function(elem, types2, handler, data, selector) {
          var handleObjIn, eventHandle, tmp, events2, t10, handleObj, special, handlers, type2, namespaces, origType, elemData = dataPriv.get(elem);
          if (!acceptData(elem)) {
            return;
          }
          if (handler.handler) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
          }
          if (selector) {
            jQuery.find.matchesSelector(documentElement, selector);
          }
          if (!handler.guid) {
            handler.guid = jQuery.guid++;
          }
          if (!(events2 = elemData.events)) {
            events2 = elemData.events = /* @__PURE__ */ Object.create(null);
          }
          if (!(eventHandle = elemData.handle)) {
            eventHandle = elemData.handle = function(e4) {
              return typeof jQuery !== "undefined" && jQuery.event.triggered !== e4.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
            };
          }
          types2 = (types2 || "").match(rnothtmlwhite) || [""];
          t10 = types2.length;
          while (t10--) {
            tmp = rtypenamespace.exec(types2[t10]) || [];
            type2 = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type2) {
              continue;
            }
            special = jQuery.event.special[type2] || {};
            type2 = (selector ? special.delegateType : special.bindType) || type2;
            special = jQuery.event.special[type2] || {};
            handleObj = jQuery.extend({
              type: type2,
              origType,
              data,
              handler,
              guid: handler.guid,
              selector,
              needsContext: selector && jQuery.expr.match.needsContext.test(selector),
              namespace: namespaces.join(".")
            }, handleObjIn);
            if (!(handlers = events2[type2])) {
              handlers = events2[type2] = [];
              handlers.delegateCount = 0;
              if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                if (elem.addEventListener) {
                  elem.addEventListener(type2, eventHandle);
                }
              }
            }
            if (special.add) {
              special.add.call(elem, handleObj);
              if (!handleObj.handler.guid) {
                handleObj.handler.guid = handler.guid;
              }
            }
            if (selector) {
              handlers.splice(handlers.delegateCount++, 0, handleObj);
            } else {
              handlers.push(handleObj);
            }
            jQuery.event.global[type2] = true;
          }
        },
        // Detach an event or set of events from an element
        remove: function(elem, types2, handler, selector, mappedTypes) {
          var j2, origCount, tmp, events2, t10, handleObj, special, handlers, type2, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
          if (!elemData || !(events2 = elemData.events)) {
            return;
          }
          types2 = (types2 || "").match(rnothtmlwhite) || [""];
          t10 = types2.length;
          while (t10--) {
            tmp = rtypenamespace.exec(types2[t10]) || [];
            type2 = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type2) {
              for (type2 in events2) {
                jQuery.event.remove(elem, type2 + types2[t10], handler, selector, true);
              }
              continue;
            }
            special = jQuery.event.special[type2] || {};
            type2 = (selector ? special.delegateType : special.bindType) || type2;
            handlers = events2[type2] || [];
            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
            origCount = j2 = handlers.length;
            while (j2--) {
              handleObj = handlers[j2];
              if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                handlers.splice(j2, 1);
                if (handleObj.selector) {
                  handlers.delegateCount--;
                }
                if (special.remove) {
                  special.remove.call(elem, handleObj);
                }
              }
            }
            if (origCount && !handlers.length) {
              if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                jQuery.removeEvent(elem, type2, elemData.handle);
              }
              delete events2[type2];
            }
          }
          if (jQuery.isEmptyObject(events2)) {
            dataPriv.remove(elem, "handle events");
          }
        },
        dispatch: function(nativeEvent) {
          var i5, j2, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
          args[0] = event;
          for (i5 = 1; i5 < arguments.length; i5++) {
            args[i5] = arguments[i5];
          }
          event.delegateTarget = this;
          if (special.preDispatch && special.preDispatch.call(this, event) === false) {
            return;
          }
          handlerQueue = jQuery.event.handlers.call(this, event, handlers);
          i5 = 0;
          while ((matched = handlerQueue[i5++]) && !event.isPropagationStopped()) {
            event.currentTarget = matched.elem;
            j2 = 0;
            while ((handleObj = matched.handlers[j2++]) && !event.isImmediatePropagationStopped()) {
              if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                event.handleObj = handleObj;
                event.data = handleObj.data;
                ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                if (ret !== void 0) {
                  if ((event.result = ret) === false) {
                    event.preventDefault();
                    event.stopPropagation();
                  }
                }
              }
            }
          }
          if (special.postDispatch) {
            special.postDispatch.call(this, event);
          }
          return event.result;
        },
        handlers: function(event, handlers) {
          var i5, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
          if (delegateCount && // Support: IE <=9
          // Black-hole SVG <use> instance trees (trac-13180)
          cur.nodeType && // Support: Firefox <=42
          // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
          // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
          // Support: IE 11 only
          // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
          !(event.type === "click" && event.button >= 1)) {
            for (; cur !== this; cur = cur.parentNode || this) {
              if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                matchedHandlers = [];
                matchedSelectors = {};
                for (i5 = 0; i5 < delegateCount; i5++) {
                  handleObj = handlers[i5];
                  sel = handleObj.selector + " ";
                  if (matchedSelectors[sel] === void 0) {
                    matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                  }
                  if (matchedSelectors[sel]) {
                    matchedHandlers.push(handleObj);
                  }
                }
                if (matchedHandlers.length) {
                  handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                }
              }
            }
          }
          cur = this;
          if (delegateCount < handlers.length) {
            handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
          }
          return handlerQueue;
        },
        addProp: function(name2, hook) {
          Object.defineProperty(jQuery.Event.prototype, name2, {
            enumerable: true,
            configurable: true,
            get: isFunction3(hook) ? function() {
              if (this.originalEvent) {
                return hook(this.originalEvent);
              }
            } : function() {
              if (this.originalEvent) {
                return this.originalEvent[name2];
              }
            },
            set: function(value) {
              Object.defineProperty(this, name2, {
                enumerable: true,
                configurable: true,
                writable: true,
                value
              });
            }
          });
        },
        fix: function(originalEvent) {
          return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
          load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
          },
          click: {
            // Utilize native event to ensure correct state for checkable inputs
            setup: function(data) {
              var el = this || data;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click", true);
              }
              return false;
            },
            trigger: function(data) {
              var el = this || data;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click");
              }
              return true;
            },
            // For cross-browser consistency, suppress native .click() on links
            // Also prevent it if we're currently inside a leveraged native-event stack
            _default: function(event) {
              var target = event.target;
              return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
            }
          },
          beforeunload: {
            postDispatch: function(event) {
              if (event.result !== void 0 && event.originalEvent) {
                event.originalEvent.returnValue = event.result;
              }
            }
          }
        }
      };
      function leverageNative(el, type2, isSetup) {
        if (!isSetup) {
          if (dataPriv.get(el, type2) === void 0) {
            jQuery.event.add(el, type2, returnTrue);
          }
          return;
        }
        dataPriv.set(el, type2, false);
        jQuery.event.add(el, type2, {
          namespace: false,
          handler: function(event) {
            var result2, saved = dataPriv.get(this, type2);
            if (event.isTrigger & 1 && this[type2]) {
              if (!saved) {
                saved = slice2.call(arguments);
                dataPriv.set(this, type2, saved);
                this[type2]();
                result2 = dataPriv.get(this, type2);
                dataPriv.set(this, type2, false);
                if (saved !== result2) {
                  event.stopImmediatePropagation();
                  event.preventDefault();
                  return result2;
                }
              } else if ((jQuery.event.special[type2] || {}).delegateType) {
                event.stopPropagation();
              }
            } else if (saved) {
              dataPriv.set(this, type2, jQuery.event.trigger(
                saved[0],
                saved.slice(1),
                this
              ));
              event.stopPropagation();
              event.isImmediatePropagationStopped = returnTrue;
            }
          }
        });
      }
      jQuery.removeEvent = function(elem, type2, handle) {
        if (elem.removeEventListener) {
          elem.removeEventListener(type2, handle);
        }
      };
      jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
          return new jQuery.Event(src, props);
        }
        if (src && src.type) {
          this.originalEvent = src;
          this.type = src.type;
          this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
          src.returnValue === false ? returnTrue : returnFalse;
          this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
          this.currentTarget = src.currentTarget;
          this.relatedTarget = src.relatedTarget;
        } else {
          this.type = src;
        }
        if (props) {
          jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || Date.now();
        this[jQuery.expando] = true;
      };
      jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
          var e4 = this.originalEvent;
          this.isDefaultPrevented = returnTrue;
          if (e4 && !this.isSimulated) {
            e4.preventDefault();
          }
        },
        stopPropagation: function() {
          var e4 = this.originalEvent;
          this.isPropagationStopped = returnTrue;
          if (e4 && !this.isSimulated) {
            e4.stopPropagation();
          }
        },
        stopImmediatePropagation: function() {
          var e4 = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue;
          if (e4 && !this.isSimulated) {
            e4.stopImmediatePropagation();
          }
          this.stopPropagation();
        }
      };
      jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: true
      }, jQuery.event.addProp);
      jQuery.each({ focus: "focusin", blur: "focusout" }, function(type2, delegateType) {
        function focusMappedHandler(nativeEvent) {
          if (document2.documentMode) {
            var handle = dataPriv.get(this, "handle"), event = jQuery.event.fix(nativeEvent);
            event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
            event.isSimulated = true;
            handle(nativeEvent);
            if (event.target === event.currentTarget) {
              handle(event);
            }
          } else {
            jQuery.event.simulate(
              delegateType,
              nativeEvent.target,
              jQuery.event.fix(nativeEvent)
            );
          }
        }
        jQuery.event.special[type2] = {
          // Utilize native event if possible so blur/focus sequence is correct
          setup: function() {
            var attaches;
            leverageNative(this, type2, true);
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType);
              if (!attaches) {
                this.addEventListener(delegateType, focusMappedHandler);
              }
              dataPriv.set(this, delegateType, (attaches || 0) + 1);
            } else {
              return false;
            }
          },
          trigger: function() {
            leverageNative(this, type2);
            return true;
          },
          teardown: function() {
            var attaches;
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType) - 1;
              if (!attaches) {
                this.removeEventListener(delegateType, focusMappedHandler);
                dataPriv.remove(this, delegateType);
              } else {
                dataPriv.set(this, delegateType, attaches);
              }
            } else {
              return false;
            }
          },
          // Suppress native focus or blur if we're currently inside
          // a leveraged native-event stack
          _default: function(event) {
            return dataPriv.get(event.target, type2);
          },
          delegateType
        };
        jQuery.event.special[delegateType] = {
          setup: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
            if (!attaches) {
              if (document2.documentMode) {
                this.addEventListener(delegateType, focusMappedHandler);
              } else {
                doc.addEventListener(type2, focusMappedHandler, true);
              }
            }
            dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
            if (!attaches) {
              if (document2.documentMode) {
                this.removeEventListener(delegateType, focusMappedHandler);
              } else {
                doc.removeEventListener(type2, focusMappedHandler, true);
              }
              dataPriv.remove(dataHolder, delegateType);
            } else {
              dataPriv.set(dataHolder, delegateType, attaches);
            }
          }
        };
      });
      jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function(orig, fix) {
        jQuery.event.special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function(event) {
            var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
            if (!related || related !== target && !jQuery.contains(target, related)) {
              event.type = handleObj.origType;
              ret = handleObj.handler.apply(this, arguments);
              event.type = fix;
            }
            return ret;
          }
        };
      });
      jQuery.fn.extend({
        on: function(types2, selector, data, fn) {
          return on(this, types2, selector, data, fn);
        },
        one: function(types2, selector, data, fn) {
          return on(this, types2, selector, data, fn, 1);
        },
        off: function(types2, selector, fn) {
          var handleObj, type2;
          if (types2 && types2.preventDefault && types2.handleObj) {
            handleObj = types2.handleObj;
            jQuery(types2.delegateTarget).off(
              handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
              handleObj.selector,
              handleObj.handler
            );
            return this;
          }
          if (typeof types2 === "object") {
            for (type2 in types2) {
              this.off(type2, selector, types2[type2]);
            }
            return this;
          }
          if (selector === false || typeof selector === "function") {
            fn = selector;
            selector = void 0;
          }
          if (fn === false) {
            fn = returnFalse;
          }
          return this.each(function() {
            jQuery.event.remove(this, types2, fn, selector);
          });
        }
      });
      var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
      function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
          return jQuery(elem).children("tbody")[0] || elem;
        }
        return elem;
      }
      function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
      }
      function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
          elem.type = elem.type.slice(5);
        } else {
          elem.removeAttribute("type");
        }
        return elem;
      }
      function cloneCopyEvent(src, dest) {
        var i5, l7, type2, pdataOld, udataOld, udataCur, events2;
        if (dest.nodeType !== 1) {
          return;
        }
        if (dataPriv.hasData(src)) {
          pdataOld = dataPriv.get(src);
          events2 = pdataOld.events;
          if (events2) {
            dataPriv.remove(dest, "handle events");
            for (type2 in events2) {
              for (i5 = 0, l7 = events2[type2].length; i5 < l7; i5++) {
                jQuery.event.add(dest, type2, events2[type2][i5]);
              }
            }
          }
        }
        if (dataUser.hasData(src)) {
          udataOld = dataUser.access(src);
          udataCur = jQuery.extend({}, udataOld);
          dataUser.set(dest, udataCur);
        }
      }
      function fixInput(src, dest) {
        var nodeName2 = dest.nodeName.toLowerCase();
        if (nodeName2 === "input" && rcheckableType.test(src.type)) {
          dest.checked = src.checked;
        } else if (nodeName2 === "input" || nodeName2 === "textarea") {
          dest.defaultValue = src.defaultValue;
        }
      }
      function domManip(collection, args, callback, ignored) {
        args = flat(args);
        var fragment, first2, scripts, hasScripts, node, doc, i5 = 0, l7 = collection.length, iNoClone = l7 - 1, value = args[0], valueIsFunction = isFunction3(value);
        if (valueIsFunction || l7 > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
          return collection.each(function(index2) {
            var self2 = collection.eq(index2);
            if (valueIsFunction) {
              args[0] = value.call(this, index2, self2.html());
            }
            domManip(self2, args, callback, ignored);
          });
        }
        if (l7) {
          fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
          first2 = fragment.firstChild;
          if (fragment.childNodes.length === 1) {
            fragment = first2;
          }
          if (first2 || ignored) {
            scripts = jQuery.map(getAll(fragment, "script"), disableScript);
            hasScripts = scripts.length;
            for (; i5 < l7; i5++) {
              node = fragment;
              if (i5 !== iNoClone) {
                node = jQuery.clone(node, true, true);
                if (hasScripts) {
                  jQuery.merge(scripts, getAll(node, "script"));
                }
              }
              callback.call(collection[i5], node, i5);
            }
            if (hasScripts) {
              doc = scripts[scripts.length - 1].ownerDocument;
              jQuery.map(scripts, restoreScript);
              for (i5 = 0; i5 < hasScripts; i5++) {
                node = scripts[i5];
                if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                  if (node.src && (node.type || "").toLowerCase() !== "module") {
                    if (jQuery._evalUrl && !node.noModule) {
                      jQuery._evalUrl(node.src, {
                        nonce: node.nonce || node.getAttribute("nonce")
                      }, doc);
                    }
                  } else {
                    DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                  }
                }
              }
            }
          }
        }
        return collection;
      }
      function remove2(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i5 = 0;
        for (; (node = nodes[i5]) != null; i5++) {
          if (!keepData && node.nodeType === 1) {
            jQuery.cleanData(getAll(node));
          }
          if (node.parentNode) {
            if (keepData && isAttached(node)) {
              setGlobalEval(getAll(node, "script"));
            }
            node.parentNode.removeChild(node);
          }
        }
        return elem;
      }
      jQuery.extend({
        htmlPrefilter: function(html) {
          return html;
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
          var i5, l7, srcElements, destElements, clone2 = elem.cloneNode(true), inPage = isAttached(elem);
          if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
            destElements = getAll(clone2);
            srcElements = getAll(elem);
            for (i5 = 0, l7 = srcElements.length; i5 < l7; i5++) {
              fixInput(srcElements[i5], destElements[i5]);
            }
          }
          if (dataAndEvents) {
            if (deepDataAndEvents) {
              srcElements = srcElements || getAll(elem);
              destElements = destElements || getAll(clone2);
              for (i5 = 0, l7 = srcElements.length; i5 < l7; i5++) {
                cloneCopyEvent(srcElements[i5], destElements[i5]);
              }
            } else {
              cloneCopyEvent(elem, clone2);
            }
          }
          destElements = getAll(clone2, "script");
          if (destElements.length > 0) {
            setGlobalEval(destElements, !inPage && getAll(elem, "script"));
          }
          return clone2;
        },
        cleanData: function(elems) {
          var data, elem, type2, special = jQuery.event.special, i5 = 0;
          for (; (elem = elems[i5]) !== void 0; i5++) {
            if (acceptData(elem)) {
              if (data = elem[dataPriv.expando]) {
                if (data.events) {
                  for (type2 in data.events) {
                    if (special[type2]) {
                      jQuery.event.remove(elem, type2);
                    } else {
                      jQuery.removeEvent(elem, type2, data.handle);
                    }
                  }
                }
                elem[dataPriv.expando] = void 0;
              }
              if (elem[dataUser.expando]) {
                elem[dataUser.expando] = void 0;
              }
            }
          }
        }
      });
      jQuery.fn.extend({
        detach: function(selector) {
          return remove2(this, selector, true);
        },
        remove: function(selector) {
          return remove2(this, selector);
        },
        text: function(value) {
          return access(this, function(value2) {
            return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                this.textContent = value2;
              }
            });
          }, null, value, arguments.length);
        },
        append: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.appendChild(elem);
            }
          });
        },
        prepend: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.insertBefore(elem, target.firstChild);
            }
          });
        },
        before: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this);
            }
          });
        },
        after: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this.nextSibling);
            }
          });
        },
        empty: function() {
          var elem, i5 = 0;
          for (; (elem = this[i5]) != null; i5++) {
            if (elem.nodeType === 1) {
              jQuery.cleanData(getAll(elem, false));
              elem.textContent = "";
            }
          }
          return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
          return this.map(function() {
            return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
          });
        },
        html: function(value) {
          return access(this, function(value2) {
            var elem = this[0] || {}, i5 = 0, l7 = this.length;
            if (value2 === void 0 && elem.nodeType === 1) {
              return elem.innerHTML;
            }
            if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
              value2 = jQuery.htmlPrefilter(value2);
              try {
                for (; i5 < l7; i5++) {
                  elem = this[i5] || {};
                  if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.innerHTML = value2;
                  }
                }
                elem = 0;
              } catch (e4) {
              }
            }
            if (elem) {
              this.empty().append(value2);
            }
          }, null, value, arguments.length);
        },
        replaceWith: function() {
          var ignored = [];
          return domManip(this, arguments, function(elem) {
            var parent = this.parentNode;
            if (jQuery.inArray(this, ignored) < 0) {
              jQuery.cleanData(getAll(this));
              if (parent) {
                parent.replaceChild(elem, this);
              }
            }
          }, ignored);
        }
      });
      jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function(name2, original) {
        jQuery.fn[name2] = function(selector) {
          var elems, ret = [], insert = jQuery(selector), last2 = insert.length - 1, i5 = 0;
          for (; i5 <= last2; i5++) {
            elems = i5 === last2 ? this : this.clone(true);
            jQuery(insert[i5])[original](elems);
            push2.apply(ret, elems.get());
          }
          return this.pushStack(ret);
        };
      });
      var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
      var rcustomProp = /^--/;
      var getStyles2 = function(elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
          view = window2;
        }
        return view.getComputedStyle(elem);
      };
      var swap = function(elem, options, callback) {
        var ret, name2, old = {};
        for (name2 in options) {
          old[name2] = elem.style[name2];
          elem.style[name2] = options[name2];
        }
        ret = callback.call(elem);
        for (name2 in options) {
          elem.style[name2] = old[name2];
        }
        return ret;
      };
      var rboxStyle = new RegExp(cssExpand.join("|"), "i");
      (function() {
        function computeStyleTests() {
          if (!div) {
            return;
          }
          container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
          div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
          documentElement.appendChild(container).appendChild(div);
          var divStyle = window2.getComputedStyle(div);
          pixelPositionVal = divStyle.top !== "1%";
          reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
          div.style.right = "60%";
          pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
          boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
          div.style.position = "absolute";
          scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
          documentElement.removeChild(container);
          div = null;
        }
        function roundPixelMeasures(measure) {
          return Math.round(parseFloat(measure));
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
        if (!div.style) {
          return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        jQuery.extend(support, {
          boxSizingReliable: function() {
            computeStyleTests();
            return boxSizingReliableVal;
          },
          pixelBoxStyles: function() {
            computeStyleTests();
            return pixelBoxStylesVal;
          },
          pixelPosition: function() {
            computeStyleTests();
            return pixelPositionVal;
          },
          reliableMarginLeft: function() {
            computeStyleTests();
            return reliableMarginLeftVal;
          },
          scrollboxSize: function() {
            computeStyleTests();
            return scrollboxSizeVal;
          },
          // Support: IE 9 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Behavior in IE 9 is more subtle than in newer versions & it passes
          // some versions of this test; make sure not to make it pass there!
          //
          // Support: Firefox 70+
          // Only Firefox includes border widths
          // in computed dimensions. (gh-4529)
          reliableTrDimensions: function() {
            var table2, tr, trChild, trStyle;
            if (reliableTrDimensionsVal == null) {
              table2 = document2.createElement("table");
              tr = document2.createElement("tr");
              trChild = document2.createElement("div");
              table2.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
              tr.style.cssText = "box-sizing:content-box;border:1px solid";
              tr.style.height = "1px";
              trChild.style.height = "9px";
              trChild.style.display = "block";
              documentElement.appendChild(table2).appendChild(tr).appendChild(trChild);
              trStyle = window2.getComputedStyle(tr);
              reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
              documentElement.removeChild(table2);
            }
            return reliableTrDimensionsVal;
          }
        });
      })();
      function curCSS(elem, name2, computed) {
        var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name2), style = elem.style;
        computed = computed || getStyles2(elem);
        if (computed) {
          ret = computed.getPropertyValue(name2) || computed[name2];
          if (isCustomProp && ret) {
            ret = ret.replace(rtrimCSS, "$1") || void 0;
          }
          if (ret === "" && !isAttached(elem)) {
            ret = jQuery.style(elem, name2);
          }
          if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name2)) {
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth;
            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width;
            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
          }
        }
        return ret !== void 0 ? (
          // Support: IE <=9 - 11 only
          // IE returns zIndex value as an integer.
          ret + ""
        ) : ret;
      }
      function addGetHookIf(conditionFn, hookFn) {
        return {
          get: function() {
            if (conditionFn()) {
              delete this.get;
              return;
            }
            return (this.get = hookFn).apply(this, arguments);
          }
        };
      }
      var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
      function vendorPropName(name2) {
        var capName = name2[0].toUpperCase() + name2.slice(1), i5 = cssPrefixes.length;
        while (i5--) {
          name2 = cssPrefixes[i5] + capName;
          if (name2 in emptyStyle) {
            return name2;
          }
        }
      }
      function finalPropName(name2) {
        var final = jQuery.cssProps[name2] || vendorProps[name2];
        if (final) {
          return final;
        }
        if (name2 in emptyStyle) {
          return name2;
        }
        return vendorProps[name2] = vendorPropName(name2) || name2;
      }
      var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      };
      function setPositiveNumber(_elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? (
          // Guard against undefined "subtract", e.g., when used as in cssHooks
          Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
        ) : value;
      }
      function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i5 = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
        if (box === (isBorderBox ? "border" : "content")) {
          return 0;
        }
        for (; i5 < 4; i5 += 2) {
          if (box === "margin") {
            marginDelta += jQuery.css(elem, box + cssExpand[i5], true, styles);
          }
          if (!isBorderBox) {
            delta += jQuery.css(elem, "padding" + cssExpand[i5], true, styles);
            if (box !== "padding") {
              delta += jQuery.css(elem, "border" + cssExpand[i5] + "Width", true, styles);
            } else {
              extra += jQuery.css(elem, "border" + cssExpand[i5] + "Width", true, styles);
            }
          } else {
            if (box === "content") {
              delta -= jQuery.css(elem, "padding" + cssExpand[i5], true, styles);
            }
            if (box !== "margin") {
              delta -= jQuery.css(elem, "border" + cssExpand[i5] + "Width", true, styles);
            }
          }
        }
        if (!isBorderBox && computedVal >= 0) {
          delta += Math.max(0, Math.ceil(
            elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
            // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
            // Use an explicit zero to avoid NaN (gh-3964)
          )) || 0;
        }
        return delta + marginDelta;
      }
      function getWidthOrHeight(elem, dimension, extra) {
        var styles = getStyles2(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
        if (rnumnonpx.test(val)) {
          if (!extra) {
            return val;
          }
          val = "auto";
        }
        if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Interestingly, in some cases IE 9 doesn't suffer from this issue.
        !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        val === "auto" || // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
        elem.getClientRects().length) {
          isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
          valueIsBorderBox = offsetProp in elem;
          if (valueIsBorderBox) {
            val = elem[offsetProp];
          }
        }
        val = parseFloat(val) || 0;
        return val + boxModelAdjustment(
          elem,
          dimension,
          extra || (isBorderBox ? "border" : "content"),
          valueIsBorderBox,
          styles,
          // Provide the current computed size to request scroll gutter calculation (gh-3589)
          val
        ) + "px";
      }
      jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
          opacity: {
            get: function(elem, computed) {
              if (computed) {
                var ret = curCSS(elem, "opacity");
                return ret === "" ? "1" : ret;
              }
            }
          }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageSlice: true,
          columnCount: true,
          flexGrow: true,
          flexShrink: true,
          fontWeight: true,
          gridArea: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnStart: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowStart: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          scale: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeMiterlimit: true,
          strokeOpacity: true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},
        // Get and set the style property on a DOM Node
        style: function(elem, name2, value, extra) {
          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
            return;
          }
          var ret, type2, hooks, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2), style = elem.style;
          if (!isCustomProp) {
            name2 = finalPropName(origName);
          }
          hooks = jQuery.cssHooks[name2] || jQuery.cssHooks[origName];
          if (value !== void 0) {
            type2 = typeof value;
            if (type2 === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
              value = adjustCSS(elem, name2, ret);
              type2 = "number";
            }
            if (value == null || value !== value) {
              return;
            }
            if (type2 === "number" && !isCustomProp) {
              value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
            }
            if (!support.clearCloneStyle && value === "" && name2.indexOf("background") === 0) {
              style[name2] = "inherit";
            }
            if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
              if (isCustomProp) {
                style.setProperty(name2, value);
              } else {
                style[name2] = value;
              }
            }
          } else {
            if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
              return ret;
            }
            return style[name2];
          }
        },
        css: function(elem, name2, extra, styles) {
          var val, num, hooks, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2);
          if (!isCustomProp) {
            name2 = finalPropName(origName);
          }
          hooks = jQuery.cssHooks[name2] || jQuery.cssHooks[origName];
          if (hooks && "get" in hooks) {
            val = hooks.get(elem, true, extra);
          }
          if (val === void 0) {
            val = curCSS(elem, name2, styles);
          }
          if (val === "normal" && name2 in cssNormalTransform) {
            val = cssNormalTransform[name2];
          }
          if (extra === "" || extra) {
            num = parseFloat(val);
            return extra === true || isFinite(num) ? num || 0 : val;
          }
          return val;
        }
      });
      jQuery.each(["height", "width"], function(_i, dimension) {
        jQuery.cssHooks[dimension] = {
          get: function(elem, computed, extra) {
            if (computed) {
              return rdisplayswap.test(jQuery.css(elem, "display")) && // Support: Safari 8+
              // Table columns in Safari have non-zero offsetWidth & zero
              // getBoundingClientRect().width unless display is changed.
              // Support: IE <=11 only
              // Running getBoundingClientRect on a disconnected node
              // in IE throws an error.
              (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                return getWidthOrHeight(elem, dimension, extra);
              }) : getWidthOrHeight(elem, dimension, extra);
            }
          },
          set: function(elem, value, extra) {
            var matches, styles = getStyles2(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
              elem,
              dimension,
              extra,
              isBorderBox,
              styles
            ) : 0;
            if (isBorderBox && scrollboxSizeBuggy) {
              subtract -= Math.ceil(
                elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
              );
            }
            if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
              elem.style[dimension] = value;
              value = jQuery.css(elem, dimension);
            }
            return setPositiveNumber(elem, value, subtract);
          }
        };
      });
      jQuery.cssHooks.marginLeft = addGetHookIf(
        support.reliableMarginLeft,
        function(elem, computed) {
          if (computed) {
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
              return elem.getBoundingClientRect().left;
            })) + "px";
          }
        }
      );
      jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
          expand: function(value) {
            var i5 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
            for (; i5 < 4; i5++) {
              expanded[prefix + cssExpand[i5] + suffix] = parts[i5] || parts[i5 - 2] || parts[0];
            }
            return expanded;
          }
        };
        if (prefix !== "margin") {
          jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
      });
      jQuery.fn.extend({
        css: function(name2, value) {
          return access(this, function(elem, name3, value2) {
            var styles, len, map4 = {}, i5 = 0;
            if (Array.isArray(name3)) {
              styles = getStyles2(elem);
              len = name3.length;
              for (; i5 < len; i5++) {
                map4[name3[i5]] = jQuery.css(elem, name3[i5], false, styles);
              }
              return map4;
            }
            return value2 !== void 0 ? jQuery.style(elem, name3, value2) : jQuery.css(elem, name3);
          }, name2, value, arguments.length > 1);
        }
      });
      function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
      }
      jQuery.Tween = Tween;
      Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing || jQuery.easing._default;
          this.options = options;
          this.start = this.now = this.cur();
          this.end = end;
          this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
          var hooks = Tween.propHooks[this.prop];
          return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
          var eased, hooks = Tween.propHooks[this.prop];
          if (this.options.duration) {
            this.pos = eased = jQuery.easing[this.easing](
              percent,
              this.options.duration * percent,
              0,
              1,
              this.options.duration
            );
          } else {
            this.pos = eased = percent;
          }
          this.now = (this.end - this.start) * eased + this.start;
          if (this.options.step) {
            this.options.step.call(this.elem, this.now, this);
          }
          if (hooks && hooks.set) {
            hooks.set(this);
          } else {
            Tween.propHooks._default.set(this);
          }
          return this;
        }
      };
      Tween.prototype.init.prototype = Tween.prototype;
      Tween.propHooks = {
        _default: {
          get: function(tween) {
            var result2;
            if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
              return tween.elem[tween.prop];
            }
            result2 = jQuery.css(tween.elem, tween.prop, "");
            return !result2 || result2 === "auto" ? 0 : result2;
          },
          set: function(tween) {
            if (jQuery.fx.step[tween.prop]) {
              jQuery.fx.step[tween.prop](tween);
            } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
              jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
            } else {
              tween.elem[tween.prop] = tween.now;
            }
          }
        }
      };
      Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
          if (tween.elem.nodeType && tween.elem.parentNode) {
            tween.elem[tween.prop] = tween.now;
          }
        }
      };
      jQuery.easing = {
        linear: function(p3) {
          return p3;
        },
        swing: function(p3) {
          return 0.5 - Math.cos(p3 * Math.PI) / 2;
        },
        _default: "swing"
      };
      jQuery.fx = Tween.prototype.init;
      jQuery.fx.step = {};
      var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
      function schedule() {
        if (inProgress) {
          if (document2.hidden === false && window2.requestAnimationFrame) {
            window2.requestAnimationFrame(schedule);
          } else {
            window2.setTimeout(schedule, jQuery.fx.interval);
          }
          jQuery.fx.tick();
        }
      }
      function createFxNow() {
        window2.setTimeout(function() {
          fxNow = void 0;
        });
        return fxNow = Date.now();
      }
      function genFx(type2, includeWidth) {
        var which, i5 = 0, attrs = { height: type2 };
        includeWidth = includeWidth ? 1 : 0;
        for (; i5 < 4; i5 += 2 - includeWidth) {
          which = cssExpand[i5];
          attrs["margin" + which] = attrs["padding" + which] = type2;
        }
        if (includeWidth) {
          attrs.opacity = attrs.width = type2;
        }
        return attrs;
      }
      function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index2 = 0, length = collection.length;
        for (; index2 < length; index2++) {
          if (tween = collection[index2].call(animation, prop, value)) {
            return tween;
          }
        }
      }
      function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        if (!opts.queue) {
          hooks = jQuery._queueHooks(elem, "fx");
          if (hooks.unqueued == null) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
              if (!hooks.unqueued) {
                oldfire();
              }
            };
          }
          hooks.unqueued++;
          anim.always(function() {
            anim.always(function() {
              hooks.unqueued--;
              if (!jQuery.queue(elem, "fx").length) {
                hooks.empty.fire();
              }
            });
          });
        }
        for (prop in props) {
          value = props[prop];
          if (rfxtypes.test(value)) {
            delete props[prop];
            toggle = toggle || value === "toggle";
            if (value === (hidden ? "hide" : "show")) {
              if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                hidden = true;
              } else {
                continue;
              }
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
          }
        }
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) {
          return;
        }
        if (isBox && elem.nodeType === 1) {
          opts.overflow = [style.overflow, style.overflowX, style.overflowY];
          restoreDisplay = dataShow && dataShow.display;
          if (restoreDisplay == null) {
            restoreDisplay = dataPriv.get(elem, "display");
          }
          display = jQuery.css(elem, "display");
          if (display === "none") {
            if (restoreDisplay) {
              display = restoreDisplay;
            } else {
              showHide([elem], true);
              restoreDisplay = elem.style.display || restoreDisplay;
              display = jQuery.css(elem, "display");
              showHide([elem]);
            }
          }
          if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
            if (jQuery.css(elem, "float") === "none") {
              if (!propTween) {
                anim.done(function() {
                  style.display = restoreDisplay;
                });
                if (restoreDisplay == null) {
                  display = style.display;
                  restoreDisplay = display === "none" ? "" : display;
                }
              }
              style.display = "inline-block";
            }
          }
        }
        if (opts.overflow) {
          style.overflow = "hidden";
          anim.always(function() {
            style.overflow = opts.overflow[0];
            style.overflowX = opts.overflow[1];
            style.overflowY = opts.overflow[2];
          });
        }
        propTween = false;
        for (prop in orig) {
          if (!propTween) {
            if (dataShow) {
              if ("hidden" in dataShow) {
                hidden = dataShow.hidden;
              }
            } else {
              dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
            }
            if (toggle) {
              dataShow.hidden = !hidden;
            }
            if (hidden) {
              showHide([elem], true);
            }
            anim.done(function() {
              if (!hidden) {
                showHide([elem]);
              }
              dataPriv.remove(elem, "fxshow");
              for (prop in orig) {
                jQuery.style(elem, prop, orig[prop]);
              }
            });
          }
          propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
          if (!(prop in dataShow)) {
            dataShow[prop] = propTween.start;
            if (hidden) {
              propTween.end = propTween.start;
              propTween.start = 0;
            }
          }
        }
      }
      function propFilter(props, specialEasing) {
        var index2, name2, easing, value, hooks;
        for (index2 in props) {
          name2 = camelCase(index2);
          easing = specialEasing[name2];
          value = props[index2];
          if (Array.isArray(value)) {
            easing = value[1];
            value = props[index2] = value[0];
          }
          if (index2 !== name2) {
            props[name2] = value;
            delete props[index2];
          }
          hooks = jQuery.cssHooks[name2];
          if (hooks && "expand" in hooks) {
            value = hooks.expand(value);
            delete props[name2];
            for (index2 in value) {
              if (!(index2 in props)) {
                props[index2] = value[index2];
                specialEasing[index2] = easing;
              }
            }
          } else {
            specialEasing[name2] = easing;
          }
        }
      }
      function Animation(elem, properties, options) {
        var result2, stopped, index2 = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }), tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index3 = 0, length2 = animation.tweens.length;
          for (; index3 < length2; index3++) {
            animation.tweens[index3].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length2) {
            return remaining;
          }
          if (!length2) {
            deferred.notifyWith(elem, [animation, 1, 0]);
          }
          deferred.resolveWith(elem, [animation]);
          return false;
        }, animation = deferred.promise({
          elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(
              elem,
              animation.opts,
              prop,
              end,
              animation.opts.specialEasing[prop] || animation.opts.easing
            );
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index3 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index3 < length2; index3++) {
              animation.tweens[index3].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index2 < length; index2++) {
          result2 = Animation.prefilters[index2].call(animation, elem, props, animation.opts);
          if (result2) {
            if (isFunction3(result2.stop)) {
              jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result2.stop.bind(result2);
            }
            return result2;
          }
        }
        jQuery.map(props, createTween, animation);
        if (isFunction3(animation.opts.start)) {
          animation.opts.start.call(elem, animation);
        }
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery.fx.timer(
          jQuery.extend(tick, {
            elem,
            anim: animation,
            queue: animation.opts.queue
          })
        );
        return animation;
      }
      jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
          "*": [function(prop, value) {
            var tween = this.createTween(prop, value);
            adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
            return tween;
          }]
        },
        tweener: function(props, callback) {
          if (isFunction3(props)) {
            callback = props;
            props = ["*"];
          } else {
            props = props.match(rnothtmlwhite);
          }
          var prop, index2 = 0, length = props.length;
          for (; index2 < length; index2++) {
            prop = props[index2];
            Animation.tweeners[prop] = Animation.tweeners[prop] || [];
            Animation.tweeners[prop].unshift(callback);
          }
        },
        prefilters: [defaultPrefilter],
        prefilter: function(callback, prepend) {
          if (prepend) {
            Animation.prefilters.unshift(callback);
          } else {
            Animation.prefilters.push(callback);
          }
        }
      });
      jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
          complete: fn || !fn && easing || isFunction3(speed) && speed,
          duration: speed,
          easing: fn && easing || easing && !isFunction3(easing) && easing
        };
        if (jQuery.fx.off) {
          opt.duration = 0;
        } else {
          if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery.fx.speeds) {
              opt.duration = jQuery.fx.speeds[opt.duration];
            } else {
              opt.duration = jQuery.fx.speeds._default;
            }
          }
        }
        if (opt.queue == null || opt.queue === true) {
          opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
          if (isFunction3(opt.old)) {
            opt.old.call(this);
          }
          if (opt.queue) {
            jQuery.dequeue(this, opt.queue);
          }
        };
        return opt;
      };
      jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
          return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
          var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
          doAnimation.finish = doAnimation;
          return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type2, clearQueue, gotoEnd) {
          var stopQueue = function(hooks) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop(gotoEnd);
          };
          if (typeof type2 !== "string") {
            gotoEnd = clearQueue;
            clearQueue = type2;
            type2 = void 0;
          }
          if (clearQueue) {
            this.queue(type2 || "fx", []);
          }
          return this.each(function() {
            var dequeue = true, index2 = type2 != null && type2 + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
            if (index2) {
              if (data[index2] && data[index2].stop) {
                stopQueue(data[index2]);
              }
            } else {
              for (index2 in data) {
                if (data[index2] && data[index2].stop && rrun.test(index2)) {
                  stopQueue(data[index2]);
                }
              }
            }
            for (index2 = timers.length; index2--; ) {
              if (timers[index2].elem === this && (type2 == null || timers[index2].queue === type2)) {
                timers[index2].anim.stop(gotoEnd);
                dequeue = false;
                timers.splice(index2, 1);
              }
            }
            if (dequeue || !gotoEnd) {
              jQuery.dequeue(this, type2);
            }
          });
        },
        finish: function(type2) {
          if (type2 !== false) {
            type2 = type2 || "fx";
          }
          return this.each(function() {
            var index2, data = dataPriv.get(this), queue = data[type2 + "queue"], hooks = data[type2 + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
            data.finish = true;
            jQuery.queue(this, type2, []);
            if (hooks && hooks.stop) {
              hooks.stop.call(this, true);
            }
            for (index2 = timers.length; index2--; ) {
              if (timers[index2].elem === this && timers[index2].queue === type2) {
                timers[index2].anim.stop(true);
                timers.splice(index2, 1);
              }
            }
            for (index2 = 0; index2 < length; index2++) {
              if (queue[index2] && queue[index2].finish) {
                queue[index2].finish.call(this);
              }
            }
            delete data.finish;
          });
        }
      });
      jQuery.each(["toggle", "show", "hide"], function(_i, name2) {
        var cssFn = jQuery.fn[name2];
        jQuery.fn[name2] = function(speed, easing, callback) {
          return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name2, true), speed, easing, callback);
        };
      });
      jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
      }, function(name2, props) {
        jQuery.fn[name2] = function(speed, easing, callback) {
          return this.animate(props, speed, easing, callback);
        };
      });
      jQuery.timers = [];
      jQuery.fx.tick = function() {
        var timer, i5 = 0, timers = jQuery.timers;
        fxNow = Date.now();
        for (; i5 < timers.length; i5++) {
          timer = timers[i5];
          if (!timer() && timers[i5] === timer) {
            timers.splice(i5--, 1);
          }
        }
        if (!timers.length) {
          jQuery.fx.stop();
        }
        fxNow = void 0;
      };
      jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
      };
      jQuery.fx.interval = 13;
      jQuery.fx.start = function() {
        if (inProgress) {
          return;
        }
        inProgress = true;
        schedule();
      };
      jQuery.fx.stop = function() {
        inProgress = null;
      };
      jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
      };
      jQuery.fn.delay = function(time, type2) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type2 = type2 || "fx";
        return this.queue(type2, function(next, hooks) {
          var timeout = window2.setTimeout(next, time);
          hooks.stop = function() {
            window2.clearTimeout(timeout);
          };
        });
      };
      (function() {
        var input = document2.createElement("input"), select2 = document2.createElement("select"), opt = select2.appendChild(document2.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        input = document2.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
      })();
      var boolHook, attrHandle = jQuery.expr.attrHandle;
      jQuery.fn.extend({
        attr: function(name2, value) {
          return access(this, jQuery.attr, name2, value, arguments.length > 1);
        },
        removeAttr: function(name2) {
          return this.each(function() {
            jQuery.removeAttr(this, name2);
          });
        }
      });
      jQuery.extend({
        attr: function(elem, name2, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (typeof elem.getAttribute === "undefined") {
            return jQuery.prop(elem, name2, value);
          }
          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            hooks = jQuery.attrHooks[name2.toLowerCase()] || (jQuery.expr.match.bool.test(name2) ? boolHook : void 0);
          }
          if (value !== void 0) {
            if (value === null) {
              jQuery.removeAttr(elem, name2);
              return;
            }
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name2)) !== void 0) {
              return ret;
            }
            elem.setAttribute(name2, value + "");
            return value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name2)) !== null) {
            return ret;
          }
          ret = jQuery.find.attr(elem, name2);
          return ret == null ? void 0 : ret;
        },
        attrHooks: {
          type: {
            set: function(elem, value) {
              if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                var val = elem.value;
                elem.setAttribute("type", value);
                if (val) {
                  elem.value = val;
                }
                return value;
              }
            }
          }
        },
        removeAttr: function(elem, value) {
          var name2, i5 = 0, attrNames = value && value.match(rnothtmlwhite);
          if (attrNames && elem.nodeType === 1) {
            while (name2 = attrNames[i5++]) {
              elem.removeAttribute(name2);
            }
          }
        }
      });
      boolHook = {
        set: function(elem, value, name2) {
          if (value === false) {
            jQuery.removeAttr(elem, name2);
          } else {
            elem.setAttribute(name2, name2);
          }
          return name2;
        }
      };
      jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name2) {
        var getter = attrHandle[name2] || jQuery.find.attr;
        attrHandle[name2] = function(elem, name3, isXML) {
          var ret, handle, lowercaseName = name3.toLowerCase();
          if (!isXML) {
            handle = attrHandle[lowercaseName];
            attrHandle[lowercaseName] = ret;
            ret = getter(elem, name3, isXML) != null ? lowercaseName : null;
            attrHandle[lowercaseName] = handle;
          }
          return ret;
        };
      });
      var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
      jQuery.fn.extend({
        prop: function(name2, value) {
          return access(this, jQuery.prop, name2, value, arguments.length > 1);
        },
        removeProp: function(name2) {
          return this.each(function() {
            delete this[jQuery.propFix[name2] || name2];
          });
        }
      });
      jQuery.extend({
        prop: function(elem, name2, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            name2 = jQuery.propFix[name2] || name2;
            hooks = jQuery.propHooks[name2];
          }
          if (value !== void 0) {
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name2)) !== void 0) {
              return ret;
            }
            return elem[name2] = value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name2)) !== null) {
            return ret;
          }
          return elem[name2];
        },
        propHooks: {
          tabIndex: {
            get: function(elem) {
              var tabindex = jQuery.find.attr(elem, "tabindex");
              if (tabindex) {
                return parseInt(tabindex, 10);
              }
              if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                return 0;
              }
              return -1;
            }
          }
        },
        propFix: {
          "for": "htmlFor",
          "class": "className"
        }
      });
      if (!support.optSelected) {
        jQuery.propHooks.selected = {
          get: function(elem) {
            var parent = elem.parentNode;
            if (parent && parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
            return null;
          },
          set: function(elem) {
            var parent = elem.parentNode;
            if (parent) {
              parent.selectedIndex;
              if (parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
            }
          }
        };
      }
      jQuery.each(
        [
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ],
        function() {
          jQuery.propFix[this.toLowerCase()] = this;
        }
      );
      function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
      }
      function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
      }
      function classesToArray(value) {
        if (Array.isArray(value)) {
          return value;
        }
        if (typeof value === "string") {
          return value.match(rnothtmlwhite) || [];
        }
        return [];
      }
      jQuery.fn.extend({
        addClass: function(value) {
          var classNames35, cur, curValue, className, i5, finalValue;
          if (isFunction3(value)) {
            return this.each(function(j2) {
              jQuery(this).addClass(value.call(this, j2, getClass(this)));
            });
          }
          classNames35 = classesToArray(value);
          if (classNames35.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i5 = 0; i5 < classNames35.length; i5++) {
                  className = classNames35[i5];
                  if (cur.indexOf(" " + className + " ") < 0) {
                    cur += className + " ";
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        removeClass: function(value) {
          var classNames35, cur, curValue, className, i5, finalValue;
          if (isFunction3(value)) {
            return this.each(function(j2) {
              jQuery(this).removeClass(value.call(this, j2, getClass(this)));
            });
          }
          if (!arguments.length) {
            return this.attr("class", "");
          }
          classNames35 = classesToArray(value);
          if (classNames35.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i5 = 0; i5 < classNames35.length; i5++) {
                  className = classNames35[i5];
                  while (cur.indexOf(" " + className + " ") > -1) {
                    cur = cur.replace(" " + className + " ", " ");
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        toggleClass: function(value, stateVal) {
          var classNames35, className, i5, self2, type2 = typeof value, isValidValue = type2 === "string" || Array.isArray(value);
          if (isFunction3(value)) {
            return this.each(function(i6) {
              jQuery(this).toggleClass(
                value.call(this, i6, getClass(this), stateVal),
                stateVal
              );
            });
          }
          if (typeof stateVal === "boolean" && isValidValue) {
            return stateVal ? this.addClass(value) : this.removeClass(value);
          }
          classNames35 = classesToArray(value);
          return this.each(function() {
            if (isValidValue) {
              self2 = jQuery(this);
              for (i5 = 0; i5 < classNames35.length; i5++) {
                className = classNames35[i5];
                if (self2.hasClass(className)) {
                  self2.removeClass(className);
                } else {
                  self2.addClass(className);
                }
              }
            } else if (value === void 0 || type2 === "boolean") {
              className = getClass(this);
              if (className) {
                dataPriv.set(this, "__className__", className);
              }
              if (this.setAttribute) {
                this.setAttribute(
                  "class",
                  className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                );
              }
            }
          });
        },
        hasClass: function(selector) {
          var className, elem, i5 = 0;
          className = " " + selector + " ";
          while (elem = this[i5++]) {
            if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
              return true;
            }
          }
          return false;
        }
      });
      var rreturn = /\r/g;
      jQuery.fn.extend({
        val: function(value) {
          var hooks, ret, valueIsFunction, elem = this[0];
          if (!arguments.length) {
            if (elem) {
              hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
              if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                return ret;
              }
              ret = elem.value;
              if (typeof ret === "string") {
                return ret.replace(rreturn, "");
              }
              return ret == null ? "" : ret;
            }
            return;
          }
          valueIsFunction = isFunction3(value);
          return this.each(function(i5) {
            var val;
            if (this.nodeType !== 1) {
              return;
            }
            if (valueIsFunction) {
              val = value.call(this, i5, jQuery(this).val());
            } else {
              val = value;
            }
            if (val == null) {
              val = "";
            } else if (typeof val === "number") {
              val += "";
            } else if (Array.isArray(val)) {
              val = jQuery.map(val, function(value2) {
                return value2 == null ? "" : value2 + "";
              });
            }
            hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
              this.value = val;
            }
          });
        }
      });
      jQuery.extend({
        valHooks: {
          option: {
            get: function(elem) {
              var val = jQuery.find.attr(elem, "value");
              return val != null ? val : (
                // Support: IE <=10 - 11 only
                // option.text throws exceptions (trac-14686, trac-14858)
                // Strip and collapse whitespace
                // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                stripAndCollapse(jQuery.text(elem))
              );
            }
          },
          select: {
            get: function(elem) {
              var value, option, i5, options = elem.options, index2 = elem.selectedIndex, one = elem.type === "select-one", values2 = one ? null : [], max3 = one ? index2 + 1 : options.length;
              if (index2 < 0) {
                i5 = max3;
              } else {
                i5 = one ? index2 : 0;
              }
              for (; i5 < max3; i5++) {
                option = options[i5];
                if ((option.selected || i5 === index2) && // Don't return options that are disabled or in a disabled optgroup
                !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                  value = jQuery(option).val();
                  if (one) {
                    return value;
                  }
                  values2.push(value);
                }
              }
              return values2;
            },
            set: function(elem, value) {
              var optionSet, option, options = elem.options, values2 = jQuery.makeArray(value), i5 = options.length;
              while (i5--) {
                option = options[i5];
                if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values2) > -1) {
                  optionSet = true;
                }
              }
              if (!optionSet) {
                elem.selectedIndex = -1;
              }
              return values2;
            }
          }
        }
      });
      jQuery.each(["radio", "checkbox"], function() {
        jQuery.valHooks[this] = {
          set: function(elem, value) {
            if (Array.isArray(value)) {
              return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
            }
          }
        };
        if (!support.checkOn) {
          jQuery.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
          };
        }
      });
      var location2 = window2.location;
      var nonce = { guid: Date.now() };
      var rquery = /\?/;
      jQuery.parseXML = function(data) {
        var xml, parserErrorElem;
        if (!data || typeof data !== "string") {
          return null;
        }
        try {
          xml = new window2.DOMParser().parseFromString(data, "text/xml");
        } catch (e4) {
        }
        parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
        if (!xml || parserErrorElem) {
          jQuery.error(
            "Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
              return el.textContent;
            }).join("\n") : data)
          );
        }
        return xml;
      };
      var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e4) {
        e4.stopPropagation();
      };
      jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
          var i5, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type2 = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
          cur = lastElement = tmp = elem = elem || document2;
          if (elem.nodeType === 3 || elem.nodeType === 8) {
            return;
          }
          if (rfocusMorph.test(type2 + jQuery.event.triggered)) {
            return;
          }
          if (type2.indexOf(".") > -1) {
            namespaces = type2.split(".");
            type2 = namespaces.shift();
            namespaces.sort();
          }
          ontype = type2.indexOf(":") < 0 && "on" + type2;
          event = event[jQuery.expando] ? event : new jQuery.Event(type2, typeof event === "object" && event);
          event.isTrigger = onlyHandlers ? 2 : 3;
          event.namespace = namespaces.join(".");
          event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
          event.result = void 0;
          if (!event.target) {
            event.target = elem;
          }
          data = data == null ? [event] : jQuery.makeArray(data, [event]);
          special = jQuery.event.special[type2] || {};
          if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
            return;
          }
          if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
            bubbleType = special.delegateType || type2;
            if (!rfocusMorph.test(bubbleType + type2)) {
              cur = cur.parentNode;
            }
            for (; cur; cur = cur.parentNode) {
              eventPath.push(cur);
              tmp = cur;
            }
            if (tmp === (elem.ownerDocument || document2)) {
              eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
            }
          }
          i5 = 0;
          while ((cur = eventPath[i5++]) && !event.isPropagationStopped()) {
            lastElement = cur;
            event.type = i5 > 1 ? bubbleType : special.bindType || type2;
            handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
            if (handle) {
              handle.apply(cur, data);
            }
            handle = ontype && cur[ontype];
            if (handle && handle.apply && acceptData(cur)) {
              event.result = handle.apply(cur, data);
              if (event.result === false) {
                event.preventDefault();
              }
            }
          }
          event.type = type2;
          if (!onlyHandlers && !event.isDefaultPrevented()) {
            if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
              if (ontype && isFunction3(elem[type2]) && !isWindow(elem)) {
                tmp = elem[ontype];
                if (tmp) {
                  elem[ontype] = null;
                }
                jQuery.event.triggered = type2;
                if (event.isPropagationStopped()) {
                  lastElement.addEventListener(type2, stopPropagationCallback);
                }
                elem[type2]();
                if (event.isPropagationStopped()) {
                  lastElement.removeEventListener(type2, stopPropagationCallback);
                }
                jQuery.event.triggered = void 0;
                if (tmp) {
                  elem[ontype] = tmp;
                }
              }
            }
          }
          return event.result;
        },
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function(type2, elem, event) {
          var e4 = jQuery.extend(
            new jQuery.Event(),
            event,
            {
              type: type2,
              isSimulated: true
            }
          );
          jQuery.event.trigger(e4, null, elem);
        }
      });
      jQuery.fn.extend({
        trigger: function(type2, data) {
          return this.each(function() {
            jQuery.event.trigger(type2, data, this);
          });
        },
        triggerHandler: function(type2, data) {
          var elem = this[0];
          if (elem) {
            return jQuery.event.trigger(type2, data, elem, true);
          }
        }
      });
      var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
      function buildParams(prefix, obj, traditional, add) {
        var name2;
        if (Array.isArray(obj)) {
          jQuery.each(obj, function(i5, v2) {
            if (traditional || rbracket.test(prefix)) {
              add(prefix, v2);
            } else {
              buildParams(
                prefix + "[" + (typeof v2 === "object" && v2 != null ? i5 : "") + "]",
                v2,
                traditional,
                add
              );
            }
          });
        } else if (!traditional && toType(obj) === "object") {
          for (name2 in obj) {
            buildParams(prefix + "[" + name2 + "]", obj[name2], traditional, add);
          }
        } else {
          add(prefix, obj);
        }
      }
      jQuery.param = function(a4, traditional) {
        var prefix, s7 = [], add = function(key, valueOrFunction) {
          var value = isFunction3(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s7[s7.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
        if (a4 == null) {
          return "";
        }
        if (Array.isArray(a4) || a4.jquery && !jQuery.isPlainObject(a4)) {
          jQuery.each(a4, function() {
            add(this.name, this.value);
          });
        } else {
          for (prefix in a4) {
            buildParams(prefix, a4[prefix], traditional, add);
          }
        }
        return s7.join("&");
      };
      jQuery.fn.extend({
        serialize: function() {
          return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
          return this.map(function() {
            var elements = jQuery.prop(this, "elements");
            return elements ? jQuery.makeArray(elements) : this;
          }).filter(function() {
            var type2 = this.type;
            return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type2) && (this.checked || !rcheckableType.test(type2));
          }).map(function(_i, elem) {
            var val = jQuery(this).val();
            if (val == null) {
              return null;
            }
            if (Array.isArray(val)) {
              return jQuery.map(val, function(val2) {
                return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
              });
            }
            return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
          }).get();
        }
      });
      var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
      originAnchor.href = location2.href;
      function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
          if (typeof dataTypeExpression !== "string") {
            func = dataTypeExpression;
            dataTypeExpression = "*";
          }
          var dataType, i5 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
          if (isFunction3(func)) {
            while (dataType = dataTypes[i5++]) {
              if (dataType[0] === "+") {
                dataType = dataType.slice(1) || "*";
                (structure[dataType] = structure[dataType] || []).unshift(func);
              } else {
                (structure[dataType] = structure[dataType] || []).push(func);
              }
            }
          }
        };
      }
      function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
          var selected;
          inspected[dataType] = true;
          jQuery.each(structure[dataType] || [], function(_5, prefilterOrFactory) {
            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
              options.dataTypes.unshift(dataTypeOrTransport);
              inspect(dataTypeOrTransport);
              return false;
            } else if (seekingTransport) {
              return !(selected = dataTypeOrTransport);
            }
          });
          return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
      }
      function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
          if (src[key] !== void 0) {
            (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
          }
        }
        if (deep) {
          jQuery.extend(true, target, deep);
        }
        return target;
      }
      function ajaxHandleResponses(s7, jqXHR, responses) {
        var ct, type2, finalDataType, firstDataType, contents = s7.contents, dataTypes = s7.dataTypes;
        while (dataTypes[0] === "*") {
          dataTypes.shift();
          if (ct === void 0) {
            ct = s7.mimeType || jqXHR.getResponseHeader("Content-Type");
          }
        }
        if (ct) {
          for (type2 in contents) {
            if (contents[type2] && contents[type2].test(ct)) {
              dataTypes.unshift(type2);
              break;
            }
          }
        }
        if (dataTypes[0] in responses) {
          finalDataType = dataTypes[0];
        } else {
          for (type2 in responses) {
            if (!dataTypes[0] || s7.converters[type2 + " " + dataTypes[0]]) {
              finalDataType = type2;
              break;
            }
            if (!firstDataType) {
              firstDataType = type2;
            }
          }
          finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
          if (finalDataType !== dataTypes[0]) {
            dataTypes.unshift(finalDataType);
          }
          return responses[finalDataType];
        }
      }
      function ajaxConvert(s7, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s7.dataTypes.slice();
        if (dataTypes[1]) {
          for (conv in s7.converters) {
            converters[conv.toLowerCase()] = s7.converters[conv];
          }
        }
        current = dataTypes.shift();
        while (current) {
          if (s7.responseFields[current]) {
            jqXHR[s7.responseFields[current]] = response;
          }
          if (!prev && isSuccess && s7.dataFilter) {
            response = s7.dataFilter(response, s7.dataType);
          }
          prev = current;
          current = dataTypes.shift();
          if (current) {
            if (current === "*") {
              current = prev;
            } else if (prev !== "*" && prev !== current) {
              conv = converters[prev + " " + current] || converters["* " + current];
              if (!conv) {
                for (conv2 in converters) {
                  tmp = conv2.split(" ");
                  if (tmp[1] === current) {
                    conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                    if (conv) {
                      if (conv === true) {
                        conv = converters[conv2];
                      } else if (converters[conv2] !== true) {
                        current = tmp[0];
                        dataTypes.unshift(tmp[1]);
                      }
                      break;
                    }
                  }
                }
              }
              if (conv !== true) {
                if (conv && s7.throws) {
                  response = conv(response);
                } else {
                  try {
                    response = conv(response);
                  } catch (e4) {
                    return {
                      state: "parsererror",
                      error: conv ? e4 : "No conversion from " + prev + " to " + current
                    };
                  }
                }
              }
            }
          }
        }
        return { state: "success", data: response };
      }
      jQuery.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: location2.href,
          type: "GET",
          isLocal: rlocalProtocol.test(location2.protocol),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          /*
          timeout: 0,
          data: null,
          dataType: null,
          username: null,
          password: null,
          cache: null,
          throws: false,
          traditional: false,
          headers: {},
          */
          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          // Data converters
          // Keys separate source (or catchall "*") and destination types with a single space
          converters: {
            // Convert anything to text
            "* text": String,
            // Text to html (true = no transformation)
            "text html": true,
            // Evaluate text as a json expression
            "text json": JSON.parse,
            // Parse text as xml
            "text xml": jQuery.parseXML
          },
          // For options that shouldn't be deep extended:
          // you can add your own custom options here if
          // and when you create one that shouldn't be
          // deep extended (see ajaxExtend)
          flatOptions: {
            url: true,
            context: true
          }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
          return settings ? (
            // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
          ) : (
            // Extending ajaxSettings
            ajaxExtend(jQuery.ajaxSettings, target)
          );
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function(url, options) {
          if (typeof url === "object") {
            options = url;
            url = void 0;
          }
          options = options || {};
          var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i5, uncached, s7 = jQuery.ajaxSetup({}, options), callbackContext = s7.context || s7, globalEventContext = s7.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s7.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
            readyState: 0,
            // Builds headers hashtable if needed
            getResponseHeader: function(key) {
              var match;
              if (completed2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while (match = rheaders.exec(responseHeadersString)) {
                    responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                  }
                }
                match = responseHeaders[key.toLowerCase() + " "];
              }
              return match == null ? null : match.join(", ");
            },
            // Raw string
            getAllResponseHeaders: function() {
              return completed2 ? responseHeadersString : null;
            },
            // Caches the header
            setRequestHeader: function(name2, value) {
              if (completed2 == null) {
                name2 = requestHeadersNames[name2.toLowerCase()] = requestHeadersNames[name2.toLowerCase()] || name2;
                requestHeaders[name2] = value;
              }
              return this;
            },
            // Overrides response content-type header
            overrideMimeType: function(type2) {
              if (completed2 == null) {
                s7.mimeType = type2;
              }
              return this;
            },
            // Status-dependent callbacks
            statusCode: function(map4) {
              var code3;
              if (map4) {
                if (completed2) {
                  jqXHR.always(map4[jqXHR.status]);
                } else {
                  for (code3 in map4) {
                    statusCode[code3] = [statusCode[code3], map4[code3]];
                  }
                }
              }
              return this;
            },
            // Cancel the request
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
          deferred.promise(jqXHR);
          s7.url = ((url || s7.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
          s7.type = options.method || options.type || s7.method || s7.type;
          s7.dataTypes = (s7.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
          if (s7.crossDomain == null) {
            urlAnchor = document2.createElement("a");
            try {
              urlAnchor.href = s7.url;
              urlAnchor.href = urlAnchor.href;
              s7.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
            } catch (e4) {
              s7.crossDomain = true;
            }
          }
          if (s7.data && s7.processData && typeof s7.data !== "string") {
            s7.data = jQuery.param(s7.data, s7.traditional);
          }
          inspectPrefiltersOrTransports(prefilters, s7, options, jqXHR);
          if (completed2) {
            return jqXHR;
          }
          fireGlobals = jQuery.event && s7.global;
          if (fireGlobals && jQuery.active++ === 0) {
            jQuery.event.trigger("ajaxStart");
          }
          s7.type = s7.type.toUpperCase();
          s7.hasContent = !rnoContent.test(s7.type);
          cacheURL = s7.url.replace(rhash, "");
          if (!s7.hasContent) {
            uncached = s7.url.slice(cacheURL.length);
            if (s7.data && (s7.processData || typeof s7.data === "string")) {
              cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s7.data;
              delete s7.data;
            }
            if (s7.cache === false) {
              cacheURL = cacheURL.replace(rantiCache, "$1");
              uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
            }
            s7.url = cacheURL + uncached;
          } else if (s7.data && s7.processData && (s7.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
            s7.data = s7.data.replace(r20, "+");
          }
          if (s7.ifModified) {
            if (jQuery.lastModified[cacheURL]) {
              jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
            }
            if (jQuery.etag[cacheURL]) {
              jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
            }
          }
          if (s7.data && s7.hasContent && s7.contentType !== false || options.contentType) {
            jqXHR.setRequestHeader("Content-Type", s7.contentType);
          }
          jqXHR.setRequestHeader(
            "Accept",
            s7.dataTypes[0] && s7.accepts[s7.dataTypes[0]] ? s7.accepts[s7.dataTypes[0]] + (s7.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s7.accepts["*"]
          );
          for (i5 in s7.headers) {
            jqXHR.setRequestHeader(i5, s7.headers[i5]);
          }
          if (s7.beforeSend && (s7.beforeSend.call(callbackContext, jqXHR, s7) === false || completed2)) {
            return jqXHR.abort();
          }
          strAbort = "abort";
          completeDeferred.add(s7.complete);
          jqXHR.done(s7.success);
          jqXHR.fail(s7.error);
          transport = inspectPrefiltersOrTransports(transports, s7, options, jqXHR);
          if (!transport) {
            done(-1, "No Transport");
          } else {
            jqXHR.readyState = 1;
            if (fireGlobals) {
              globalEventContext.trigger("ajaxSend", [jqXHR, s7]);
            }
            if (completed2) {
              return jqXHR;
            }
            if (s7.async && s7.timeout > 0) {
              timeoutTimer = window2.setTimeout(function() {
                jqXHR.abort("timeout");
              }, s7.timeout);
            }
            try {
              completed2 = false;
              transport.send(requestHeaders, done);
            } catch (e4) {
              if (completed2) {
                throw e4;
              }
              done(-1, e4);
            }
          }
          function done(status, nativeStatusText, responses, headers) {
            var isSuccess, success, error, response, modified, statusText = nativeStatusText;
            if (completed2) {
              return;
            }
            completed2 = true;
            if (timeoutTimer) {
              window2.clearTimeout(timeoutTimer);
            }
            transport = void 0;
            responseHeadersString = headers || "";
            jqXHR.readyState = status > 0 ? 4 : 0;
            isSuccess = status >= 200 && status < 300 || status === 304;
            if (responses) {
              response = ajaxHandleResponses(s7, jqXHR, responses);
            }
            if (!isSuccess && jQuery.inArray("script", s7.dataTypes) > -1 && jQuery.inArray("json", s7.dataTypes) < 0) {
              s7.converters["text script"] = function() {
              };
            }
            response = ajaxConvert(s7, response, jqXHR, isSuccess);
            if (isSuccess) {
              if (s7.ifModified) {
                modified = jqXHR.getResponseHeader("Last-Modified");
                if (modified) {
                  jQuery.lastModified[cacheURL] = modified;
                }
                modified = jqXHR.getResponseHeader("etag");
                if (modified) {
                  jQuery.etag[cacheURL] = modified;
                }
              }
              if (status === 204 || s7.type === "HEAD") {
                statusText = "nocontent";
              } else if (status === 304) {
                statusText = "notmodified";
              } else {
                statusText = response.state;
                success = response.data;
                error = response.error;
                isSuccess = !error;
              }
            } else {
              error = statusText;
              if (status || !statusText) {
                statusText = "error";
                if (status < 0) {
                  status = 0;
                }
              }
            }
            jqXHR.status = status;
            jqXHR.statusText = (nativeStatusText || statusText) + "";
            if (isSuccess) {
              deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
            } else {
              deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
            }
            jqXHR.statusCode(statusCode);
            statusCode = void 0;
            if (fireGlobals) {
              globalEventContext.trigger(
                isSuccess ? "ajaxSuccess" : "ajaxError",
                [jqXHR, s7, isSuccess ? success : error]
              );
            }
            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
            if (fireGlobals) {
              globalEventContext.trigger("ajaxComplete", [jqXHR, s7]);
              if (!--jQuery.active) {
                jQuery.event.trigger("ajaxStop");
              }
            }
          }
          return jqXHR;
        },
        getJSON: function(url, data, callback) {
          return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
          return jQuery.get(url, void 0, callback, "script");
        }
      });
      jQuery.each(["get", "post"], function(_i, method) {
        jQuery[method] = function(url, data, callback, type2) {
          if (isFunction3(data)) {
            type2 = type2 || callback;
            callback = data;
            data = void 0;
          }
          return jQuery.ajax(jQuery.extend({
            url,
            type: method,
            dataType: type2,
            data,
            success: callback
          }, jQuery.isPlainObject(url) && url));
        };
      });
      jQuery.ajaxPrefilter(function(s7) {
        var i5;
        for (i5 in s7.headers) {
          if (i5.toLowerCase() === "content-type") {
            s7.contentType = s7.headers[i5] || "";
          }
        }
      });
      jQuery._evalUrl = function(url, options, doc) {
        return jQuery.ajax({
          url,
          // Make this explicit, since user can override this through ajaxSetup (trac-11264)
          type: "GET",
          dataType: "script",
          cache: true,
          async: false,
          global: false,
          // Only evaluate the response if it is successful (gh-4126)
          // dataFilter is not invoked for failure responses, so using it instead
          // of the default converter is kludgy but it works.
          converters: {
            "text script": function() {
            }
          },
          dataFilter: function(response) {
            jQuery.globalEval(response, options, doc);
          }
        });
      };
      jQuery.fn.extend({
        wrapAll: function(html) {
          var wrap2;
          if (this[0]) {
            if (isFunction3(html)) {
              html = html.call(this[0]);
            }
            wrap2 = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
            if (this[0].parentNode) {
              wrap2.insertBefore(this[0]);
            }
            wrap2.map(function() {
              var elem = this;
              while (elem.firstElementChild) {
                elem = elem.firstElementChild;
              }
              return elem;
            }).append(this);
          }
          return this;
        },
        wrapInner: function(html) {
          if (isFunction3(html)) {
            return this.each(function(i5) {
              jQuery(this).wrapInner(html.call(this, i5));
            });
          }
          return this.each(function() {
            var self2 = jQuery(this), contents = self2.contents();
            if (contents.length) {
              contents.wrapAll(html);
            } else {
              self2.append(html);
            }
          });
        },
        wrap: function(html) {
          var htmlIsFunction = isFunction3(html);
          return this.each(function(i5) {
            jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i5) : html);
          });
        },
        unwrap: function(selector) {
          this.parent(selector).not("body").each(function() {
            jQuery(this).replaceWith(this.childNodes);
          });
          return this;
        }
      });
      jQuery.expr.pseudos.hidden = function(elem) {
        return !jQuery.expr.pseudos.visible(elem);
      };
      jQuery.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
      };
      jQuery.ajaxSettings.xhr = function() {
        try {
          return new window2.XMLHttpRequest();
        } catch (e4) {
        }
      };
      var xhrSuccessStatus = {
        // File protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE <=9 only
        // trac-1450: sometimes IE returns 1223 when it should be 204
        1223: 204
      }, xhrSupported = jQuery.ajaxSettings.xhr();
      support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
      support.ajax = xhrSupported = !!xhrSupported;
      jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
          return {
            send: function(headers, complete) {
              var i5, xhr = options.xhr();
              xhr.open(
                options.type,
                options.url,
                options.async,
                options.username,
                options.password
              );
              if (options.xhrFields) {
                for (i5 in options.xhrFields) {
                  xhr[i5] = options.xhrFields[i5];
                }
              }
              if (options.mimeType && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.mimeType);
              }
              if (!options.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest";
              }
              for (i5 in headers) {
                xhr.setRequestHeader(i5, headers[i5]);
              }
              callback = function(type2) {
                return function() {
                  if (callback) {
                    callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                    if (type2 === "abort") {
                      xhr.abort();
                    } else if (type2 === "error") {
                      if (typeof xhr.status !== "number") {
                        complete(0, "error");
                      } else {
                        complete(
                          // File: protocol always yields status 0; see trac-8605, trac-14207
                          xhr.status,
                          xhr.statusText
                        );
                      }
                    } else {
                      complete(
                        xhrSuccessStatus[xhr.status] || xhr.status,
                        xhr.statusText,
                        // Support: IE <=9 only
                        // IE9 has no XHR2 but throws on binary (trac-11426)
                        // For XHR2 non-text, let the caller handle it (gh-2498)
                        (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                        xhr.getAllResponseHeaders()
                      );
                    }
                  }
                };
              };
              xhr.onload = callback();
              errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
              if (xhr.onabort !== void 0) {
                xhr.onabort = errorCallback;
              } else {
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    window2.setTimeout(function() {
                      if (callback) {
                        errorCallback();
                      }
                    });
                  }
                };
              }
              callback = callback("abort");
              try {
                xhr.send(options.hasContent && options.data || null);
              } catch (e4) {
                if (callback) {
                  throw e4;
                }
              }
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      jQuery.ajaxPrefilter(function(s7) {
        if (s7.crossDomain) {
          s7.contents.script = false;
        }
      });
      jQuery.ajaxSetup({
        accepts: {
          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function(text) {
            jQuery.globalEval(text);
            return text;
          }
        }
      });
      jQuery.ajaxPrefilter("script", function(s7) {
        if (s7.cache === void 0) {
          s7.cache = false;
        }
        if (s7.crossDomain) {
          s7.type = "GET";
        }
      });
      jQuery.ajaxTransport("script", function(s7) {
        if (s7.crossDomain || s7.scriptAttrs) {
          var script, callback;
          return {
            send: function(_5, complete) {
              script = jQuery("<script>").attr(s7.scriptAttrs || {}).prop({ charset: s7.scriptCharset, src: s7.url }).on("load error", callback = function(evt) {
                script.remove();
                callback = null;
                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              });
              document2.head.appendChild(script[0]);
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
      jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
          var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
          this[callback] = true;
          return callback;
        }
      });
      jQuery.ajaxPrefilter("json jsonp", function(s7, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s7.jsonp !== false && (rjsonp.test(s7.url) ? "url" : typeof s7.data === "string" && (s7.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s7.data) && "data");
        if (jsonProp || s7.dataTypes[0] === "jsonp") {
          callbackName = s7.jsonpCallback = isFunction3(s7.jsonpCallback) ? s7.jsonpCallback() : s7.jsonpCallback;
          if (jsonProp) {
            s7[jsonProp] = s7[jsonProp].replace(rjsonp, "$1" + callbackName);
          } else if (s7.jsonp !== false) {
            s7.url += (rquery.test(s7.url) ? "&" : "?") + s7.jsonp + "=" + callbackName;
          }
          s7.converters["script json"] = function() {
            if (!responseContainer) {
              jQuery.error(callbackName + " was not called");
            }
            return responseContainer[0];
          };
          s7.dataTypes[0] = "json";
          overwritten = window2[callbackName];
          window2[callbackName] = function() {
            responseContainer = arguments;
          };
          jqXHR.always(function() {
            if (overwritten === void 0) {
              jQuery(window2).removeProp(callbackName);
            } else {
              window2[callbackName] = overwritten;
            }
            if (s7[callbackName]) {
              s7.jsonpCallback = originalSettings.jsonpCallback;
              oldCallbacks.push(callbackName);
            }
            if (responseContainer && isFunction3(overwritten)) {
              overwritten(responseContainer[0]);
            }
            responseContainer = overwritten = void 0;
          });
          return "script";
        }
      });
      support.createHTMLDocument = function() {
        var body = document2.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
      }();
      jQuery.parseHTML = function(data, context, keepScripts) {
        if (typeof data !== "string") {
          return [];
        }
        if (typeof context === "boolean") {
          keepScripts = context;
          context = false;
        }
        var base, parsed, scripts;
        if (!context) {
          if (support.createHTMLDocument) {
            context = document2.implementation.createHTMLDocument("");
            base = context.createElement("base");
            base.href = document2.location.href;
            context.head.appendChild(base);
          } else {
            context = document2;
          }
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        if (parsed) {
          return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
          jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
      };
      jQuery.fn.load = function(url, params, callback) {
        var selector, type2, response, self2 = this, off = url.indexOf(" ");
        if (off > -1) {
          selector = stripAndCollapse(url.slice(off));
          url = url.slice(0, off);
        }
        if (isFunction3(params)) {
          callback = params;
          params = void 0;
        } else if (params && typeof params === "object") {
          type2 = "POST";
        }
        if (self2.length > 0) {
          jQuery.ajax({
            url,
            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type2 || "GET",
            dataType: "html",
            data: params
          }).done(function(responseText) {
            response = arguments;
            self2.html(selector ? (
              // If a selector was specified, locate the right elements in a dummy div
              // Exclude scripts to avoid IE 'Permission Denied' errors
              jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector)
            ) : (
              // Otherwise use the full result
              responseText
            ));
          }).always(callback && function(jqXHR, status) {
            self2.each(function() {
              callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
            });
          });
        }
        return this;
      };
      jQuery.expr.pseudos.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
          return elem === fn.elem;
        }).length;
      };
      jQuery.offset = {
        setOffset: function(elem, options, i5) {
          var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
          if (position === "static") {
            elem.style.position = "relative";
          }
          curOffset = curElem.offset();
          curCSSTop = jQuery.css(elem, "top");
          curCSSLeft = jQuery.css(elem, "left");
          calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
          if (calculatePosition) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
          } else {
            curTop = parseFloat(curCSSTop) || 0;
            curLeft = parseFloat(curCSSLeft) || 0;
          }
          if (isFunction3(options)) {
            options = options.call(elem, i5, jQuery.extend({}, curOffset));
          }
          if (options.top != null) {
            props.top = options.top - curOffset.top + curTop;
          }
          if (options.left != null) {
            props.left = options.left - curOffset.left + curLeft;
          }
          if ("using" in options) {
            options.using.call(elem, props);
          } else {
            curElem.css(props);
          }
        }
      };
      jQuery.fn.extend({
        // offset() relates an element's border box to the document origin
        offset: function(options) {
          if (arguments.length) {
            return options === void 0 ? this : this.each(function(i5) {
              jQuery.offset.setOffset(this, options, i5);
            });
          }
          var rect, win, elem = this[0];
          if (!elem) {
            return;
          }
          if (!elem.getClientRects().length) {
            return { top: 0, left: 0 };
          }
          rect = elem.getBoundingClientRect();
          win = elem.ownerDocument.defaultView;
          return {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
          };
        },
        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function() {
          if (!this[0]) {
            return;
          }
          var offsetParent, offset2, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
          if (jQuery.css(elem, "position") === "fixed") {
            offset2 = elem.getBoundingClientRect();
          } else {
            offset2 = this.offset();
            doc = elem.ownerDocument;
            offsetParent = elem.offsetParent || doc.documentElement;
            while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.parentNode;
            }
            if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
              parentOffset = jQuery(offsetParent).offset();
              parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
              parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
            }
          }
          return {
            top: offset2.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
            left: offset2.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
          };
        },
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
          return this.map(function() {
            var offsetParent = this.offsetParent;
            while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || documentElement;
          });
        }
      });
      jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
          return access(this, function(elem, method2, val2) {
            var win;
            if (isWindow(elem)) {
              win = elem;
            } else if (elem.nodeType === 9) {
              win = elem.defaultView;
            }
            if (val2 === void 0) {
              return win ? win[prop] : elem[method2];
            }
            if (win) {
              win.scrollTo(
                !top ? val2 : win.pageXOffset,
                top ? val2 : win.pageYOffset
              );
            } else {
              elem[method2] = val2;
            }
          }, method, val, arguments.length);
        };
      });
      jQuery.each(["top", "left"], function(_i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(
          support.pixelPosition,
          function(elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
          }
        );
      });
      jQuery.each({ Height: "height", Width: "width" }, function(name2, type2) {
        jQuery.each({
          padding: "inner" + name2,
          content: type2,
          "": "outer" + name2
        }, function(defaultExtra, funcName) {
          jQuery.fn[funcName] = function(margin, value) {
            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
            return access(this, function(elem, type3, value2) {
              var doc;
              if (isWindow(elem)) {
                return funcName.indexOf("outer") === 0 ? elem["inner" + name2] : elem.document.documentElement["client" + name2];
              }
              if (elem.nodeType === 9) {
                doc = elem.documentElement;
                return Math.max(
                  elem.body["scroll" + name2],
                  doc["scroll" + name2],
                  elem.body["offset" + name2],
                  doc["offset" + name2],
                  doc["client" + name2]
                );
              }
              return value2 === void 0 ? (
                // Get width or height on the element, requesting but not forcing parseFloat
                jQuery.css(elem, type3, extra)
              ) : (
                // Set width or height on the element
                jQuery.style(elem, type3, value2, extra)
              );
            }, type2, chainable ? margin : void 0, chainable);
          };
        });
      });
      jQuery.each(
        [
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ],
        function(_i, type2) {
          jQuery.fn[type2] = function(fn) {
            return this.on(type2, fn);
          };
        }
      );
      jQuery.fn.extend({
        bind: function(types2, data, fn) {
          return this.on(types2, null, data, fn);
        },
        unbind: function(types2, fn) {
          return this.off(types2, null, fn);
        },
        delegate: function(selector, types2, data, fn) {
          return this.on(types2, selector, data, fn);
        },
        undelegate: function(selector, types2, fn) {
          return arguments.length === 1 ? this.off(selector, "**") : this.off(types2, selector || "**", fn);
        },
        hover: function(fnOver, fnOut) {
          return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
        }
      });
      jQuery.each(
        "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
        function(_i, name2) {
          jQuery.fn[name2] = function(data, fn) {
            return arguments.length > 0 ? this.on(name2, null, data, fn) : this.trigger(name2);
          };
        }
      );
      var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
      jQuery.proxy = function(fn, context) {
        var tmp, args, proxy;
        if (typeof context === "string") {
          tmp = fn[context];
          context = fn;
          fn = tmp;
        }
        if (!isFunction3(fn)) {
          return void 0;
        }
        args = slice2.call(arguments, 2);
        proxy = function() {
          return fn.apply(context || this, args.concat(slice2.call(arguments)));
        };
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
        return proxy;
      };
      jQuery.holdReady = function(hold) {
        if (hold) {
          jQuery.readyWait++;
        } else {
          jQuery.ready(true);
        }
      };
      jQuery.isArray = Array.isArray;
      jQuery.parseJSON = JSON.parse;
      jQuery.nodeName = nodeName;
      jQuery.isFunction = isFunction3;
      jQuery.isWindow = isWindow;
      jQuery.camelCase = camelCase;
      jQuery.type = toType;
      jQuery.now = Date.now;
      jQuery.isNumeric = function(obj) {
        var type2 = jQuery.type(obj);
        return (type2 === "number" || type2 === "string") && // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
      };
      jQuery.trim = function(text) {
        return text == null ? "" : (text + "").replace(rtrim, "$1");
      };
      if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
          return jQuery;
        });
      }
      var _jQuery = window2.jQuery, _$ = window2.$;
      jQuery.noConflict = function(deep) {
        if (window2.$ === jQuery) {
          window2.$ = _$;
        }
        if (deep && window2.jQuery === jQuery) {
          window2.jQuery = _jQuery;
        }
        return jQuery;
      };
      if (typeof noGlobal === "undefined") {
        window2.jQuery = window2.$ = jQuery;
      }
      return jQuery;
    });
  }
});

// ../../node_modules/backbone/backbone.js
var require_backbone = __commonJS({
  "../../node_modules/backbone/backbone.js"(exports2) {
    (function(factory) {
      var root2 = typeof self == "object" && self.self === self && self || typeof globalThis == "object" && globalThis.global === globalThis && globalThis;
      if (typeof define === "function" && define.amd) {
        define(["underscore", "jquery", "exports"], function(_6, $9, exports3) {
          root2.Backbone = factory(root2, exports3, _6, $9);
        });
      } else if (typeof exports2 !== "undefined") {
        var _5 = (init_index_all(), __toCommonJS(index_all_exports)), $8;
        try {
          $8 = require_jquery();
        } catch (e4) {
        }
        factory(root2, exports2, _5, $8);
      } else {
        root2.Backbone = factory(root2, {}, root2._, root2.jQuery || root2.Zepto || root2.ender || root2.$);
      }
    })(function(root2, Backbone3, _5, $8) {
      var previousBackbone = root2.Backbone;
      var slice2 = Array.prototype.slice;
      Backbone3.VERSION = "1.4.0";
      Backbone3.$ = $8;
      Backbone3.noConflict = function() {
        root2.Backbone = previousBackbone;
        return this;
      };
      Backbone3.emulateHTTP = false;
      Backbone3.emulateJSON = false;
      var Events = Backbone3.Events = {};
      var eventSplitter = /\s+/;
      var _listening;
      var eventsApi = function(iteratee2, events2, name2, callback, opts) {
        var i5 = 0, names;
        if (name2 && typeof name2 === "object") {
          if (callback !== void 0 && "context" in opts && opts.context === void 0)
            opts.context = callback;
          for (names = _5.keys(name2); i5 < names.length; i5++) {
            events2 = eventsApi(iteratee2, events2, names[i5], name2[names[i5]], opts);
          }
        } else if (name2 && eventSplitter.test(name2)) {
          for (names = name2.split(eventSplitter); i5 < names.length; i5++) {
            events2 = iteratee2(events2, names[i5], callback, opts);
          }
        } else {
          events2 = iteratee2(events2, name2, callback, opts);
        }
        return events2;
      };
      Events.on = function(name2, callback, context) {
        this._events = eventsApi(onApi, this._events || {}, name2, callback, {
          context,
          ctx: this,
          listening: _listening
        });
        if (_listening) {
          var listeners = this._listeners || (this._listeners = {});
          listeners[_listening.id] = _listening;
          _listening.interop = false;
        }
        return this;
      };
      Events.listenTo = function(obj, name2, callback) {
        if (!obj)
          return this;
        var id = obj._listenId || (obj._listenId = _5.uniqueId("l"));
        var listeningTo = this._listeningTo || (this._listeningTo = {});
        var listening = _listening = listeningTo[id];
        if (!listening) {
          this._listenId || (this._listenId = _5.uniqueId("l"));
          listening = _listening = listeningTo[id] = new Listening(this, obj);
        }
        var error = tryCatchOn(obj, name2, callback, this);
        _listening = void 0;
        if (error)
          throw error;
        if (listening.interop)
          listening.on(name2, callback);
        return this;
      };
      var onApi = function(events2, name2, callback, options) {
        if (callback) {
          var handlers = events2[name2] || (events2[name2] = []);
          var context = options.context, ctx = options.ctx, listening = options.listening;
          if (listening)
            listening.count++;
          handlers.push({ callback, context, ctx: context || ctx, listening });
        }
        return events2;
      };
      var tryCatchOn = function(obj, name2, callback, context) {
        try {
          obj.on(name2, callback, context);
        } catch (e4) {
          return e4;
        }
      };
      Events.off = function(name2, callback, context) {
        if (!this._events)
          return this;
        this._events = eventsApi(offApi, this._events, name2, callback, {
          context,
          listeners: this._listeners
        });
        return this;
      };
      Events.stopListening = function(obj, name2, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo)
          return this;
        var ids = obj ? [obj._listenId] : _5.keys(listeningTo);
        for (var i5 = 0; i5 < ids.length; i5++) {
          var listening = listeningTo[ids[i5]];
          if (!listening)
            break;
          listening.obj.off(name2, callback, this);
          if (listening.interop)
            listening.off(name2, callback);
        }
        if (_5.isEmpty(listeningTo))
          this._listeningTo = void 0;
        return this;
      };
      var offApi = function(events2, name2, callback, options) {
        if (!events2)
          return;
        var context = options.context, listeners = options.listeners;
        var i5 = 0, names;
        if (!name2 && !context && !callback) {
          for (names = _5.keys(listeners); i5 < names.length; i5++) {
            listeners[names[i5]].cleanup();
          }
          return;
        }
        names = name2 ? [name2] : _5.keys(events2);
        for (; i5 < names.length; i5++) {
          name2 = names[i5];
          var handlers = events2[name2];
          if (!handlers)
            break;
          var remaining = [];
          for (var j2 = 0; j2 < handlers.length; j2++) {
            var handler = handlers[j2];
            if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {
              remaining.push(handler);
            } else {
              var listening = handler.listening;
              if (listening)
                listening.off(name2, callback);
            }
          }
          if (remaining.length) {
            events2[name2] = remaining;
          } else {
            delete events2[name2];
          }
        }
        return events2;
      };
      Events.once = function(name2, callback, context) {
        var events2 = eventsApi(onceMap, {}, name2, callback, this.off.bind(this));
        if (typeof name2 === "string" && context == null)
          callback = void 0;
        return this.on(events2, callback, context);
      };
      Events.listenToOnce = function(obj, name2, callback) {
        var events2 = eventsApi(onceMap, {}, name2, callback, this.stopListening.bind(this, obj));
        return this.listenTo(obj, events2);
      };
      var onceMap = function(map4, name2, callback, offer) {
        if (callback) {
          var once = map4[name2] = _5.once(function() {
            offer(name2, once);
            callback.apply(this, arguments);
          });
          once._callback = callback;
        }
        return map4;
      };
      Events.trigger = function(name2) {
        if (!this._events)
          return this;
        var length = Math.max(0, arguments.length - 1);
        var args = Array(length);
        for (var i5 = 0; i5 < length; i5++)
          args[i5] = arguments[i5 + 1];
        eventsApi(triggerApi, this._events, name2, void 0, args);
        return this;
      };
      var triggerApi = function(objEvents, name2, callback, args) {
        if (objEvents) {
          var events2 = objEvents[name2];
          var allEvents = objEvents.all;
          if (events2 && allEvents)
            allEvents = allEvents.slice();
          if (events2)
            triggerEvents(events2, args);
          if (allEvents)
            triggerEvents(allEvents, [name2].concat(args));
        }
        return objEvents;
      };
      var triggerEvents = function(events2, args) {
        var ev, i5 = -1, l7 = events2.length, a1 = args[0], a22 = args[1], a32 = args[2];
        switch (args.length) {
          case 0:
            while (++i5 < l7)
              (ev = events2[i5]).callback.call(ev.ctx);
            return;
          case 1:
            while (++i5 < l7)
              (ev = events2[i5]).callback.call(ev.ctx, a1);
            return;
          case 2:
            while (++i5 < l7)
              (ev = events2[i5]).callback.call(ev.ctx, a1, a22);
            return;
          case 3:
            while (++i5 < l7)
              (ev = events2[i5]).callback.call(ev.ctx, a1, a22, a32);
            return;
          default:
            while (++i5 < l7)
              (ev = events2[i5]).callback.apply(ev.ctx, args);
            return;
        }
      };
      var Listening = function(listener, obj) {
        this.id = listener._listenId;
        this.listener = listener;
        this.obj = obj;
        this.interop = true;
        this.count = 0;
        this._events = void 0;
      };
      Listening.prototype.on = Events.on;
      Listening.prototype.off = function(name2, callback) {
        var cleanup;
        if (this.interop) {
          this._events = eventsApi(offApi, this._events, name2, callback, {
            context: void 0,
            listeners: void 0
          });
          cleanup = !this._events;
        } else {
          this.count--;
          cleanup = this.count === 0;
        }
        if (cleanup)
          this.cleanup();
      };
      Listening.prototype.cleanup = function() {
        delete this.listener._listeningTo[this.obj._listenId];
        if (!this.interop)
          delete this.obj._listeners[this.id];
      };
      Events.bind = Events.on;
      Events.unbind = Events.off;
      _5.extend(Backbone3, Events);
      var Model2 = Backbone3.Model = function(attributes, options) {
        var attrs = attributes || {};
        options || (options = {});
        this.preinitialize.apply(this, arguments);
        this.cid = _5.uniqueId(this.cidPrefix);
        this.attributes = {};
        if (options.collection)
          this.collection = options.collection;
        if (options.parse)
          attrs = this.parse(attrs, options) || {};
        var defaults = _5.result(this, "defaults");
        attrs = _5.defaults(_5.extend({}, defaults, attrs), defaults);
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
      };
      _5.extend(Model2.prototype, Events, {
        // A hash of attributes whose current and previous value differ.
        changed: null,
        // The value returned during the last failed validation.
        validationError: null,
        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: "id",
        // The prefix is used to create the client id which is used to identify models locally.
        // You may want to override this if you're experiencing name clashes with model ids.
        cidPrefix: "c",
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the Model.
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
          return _5.clone(this.attributes);
        },
        // Proxy `Backbone.sync` by default -- but override this if you need
        // custom syncing semantics for *this* particular model.
        sync: function() {
          return Backbone3.sync.apply(this, arguments);
        },
        // Get the value of an attribute.
        get: function(attr) {
          return this.attributes[attr];
        },
        // Get the HTML-escaped value of an attribute.
        escape: function(attr) {
          return _5.escape(this.get(attr));
        },
        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function(attr) {
          return this.get(attr) != null;
        },
        // Special-cased proxy to underscore's `_.matches` method.
        matches: function(attrs) {
          return !!_5.iteratee(attrs, this)(this.attributes);
        },
        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function(key, val, options) {
          if (key == null)
            return this;
          var attrs;
          if (typeof key === "object") {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
          options || (options = {});
          if (!this._validate(attrs, options))
            return false;
          var unset = options.unset;
          var silent = options.silent;
          var changes = [];
          var changing = this._changing;
          this._changing = true;
          if (!changing) {
            this._previousAttributes = _5.clone(this.attributes);
            this.changed = {};
          }
          var current = this.attributes;
          var changed = this.changed;
          var prev = this._previousAttributes;
          for (var attr in attrs) {
            val = attrs[attr];
            if (!_5.isEqual(current[attr], val))
              changes.push(attr);
            if (!_5.isEqual(prev[attr], val)) {
              changed[attr] = val;
            } else {
              delete changed[attr];
            }
            unset ? delete current[attr] : current[attr] = val;
          }
          if (this.idAttribute in attrs)
            this.id = this.get(this.idAttribute);
          if (!silent) {
            if (changes.length)
              this._pending = options;
            for (var i5 = 0; i5 < changes.length; i5++) {
              this.trigger("change:" + changes[i5], this, current[changes[i5]], options);
            }
          }
          if (changing)
            return this;
          if (!silent) {
            while (this._pending) {
              options = this._pending;
              this._pending = false;
              this.trigger("change", this, options);
            }
          }
          this._pending = false;
          this._changing = false;
          return this;
        },
        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function(attr, options) {
          return this.set(attr, void 0, _5.extend({}, options, { unset: true }));
        },
        // Clear all attributes on the model, firing `"change"`.
        clear: function(options) {
          var attrs = {};
          for (var key in this.attributes)
            attrs[key] = void 0;
          return this.set(attrs, _5.extend({}, options, { unset: true }));
        },
        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
          if (attr == null)
            return !_5.isEmpty(this.changed);
          return _5.has(this.changed, attr);
        },
        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
          if (!diff)
            return this.hasChanged() ? _5.clone(this.changed) : false;
          var old = this._changing ? this._previousAttributes : this.attributes;
          var changed = {};
          var hasChanged;
          for (var attr in diff) {
            var val = diff[attr];
            if (_5.isEqual(old[attr], val))
              continue;
            changed[attr] = val;
            hasChanged = true;
          }
          return hasChanged ? changed : false;
        },
        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
          if (attr == null || !this._previousAttributes)
            return null;
          return this._previousAttributes[attr];
        },
        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
          return _5.clone(this._previousAttributes);
        },
        // Fetch the model from the server, merging the response with the model's
        // local attributes. Any changed attributes will trigger a "change" event.
        fetch: function(options) {
          options = _5.extend({ parse: true }, options);
          var model = this;
          var success = options.success;
          options.success = function(resp) {
            var serverAttrs = options.parse ? model.parse(resp, options) : resp;
            if (!model.set(serverAttrs, options))
              return false;
            if (success)
              success.call(options.context, model, resp, options);
            model.trigger("sync", model, resp, options);
          };
          wrapError(this, options);
          return this.sync("read", this, options);
        },
        // Set a hash of model attributes, and sync the model to the server.
        // If the server returns an attributes hash that differs, the model's
        // state will be `set` again.
        save: function(key, val, options) {
          var attrs;
          if (key == null || typeof key === "object") {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
          options = _5.extend({ validate: true, parse: true }, options);
          var wait = options.wait;
          if (attrs && !wait) {
            if (!this.set(attrs, options))
              return false;
          } else if (!this._validate(attrs, options)) {
            return false;
          }
          var model = this;
          var success = options.success;
          var attributes = this.attributes;
          options.success = function(resp) {
            model.attributes = attributes;
            var serverAttrs = options.parse ? model.parse(resp, options) : resp;
            if (wait)
              serverAttrs = _5.extend({}, attrs, serverAttrs);
            if (serverAttrs && !model.set(serverAttrs, options))
              return false;
            if (success)
              success.call(options.context, model, resp, options);
            model.trigger("sync", model, resp, options);
          };
          wrapError(this, options);
          if (attrs && wait)
            this.attributes = _5.extend({}, attributes, attrs);
          var method = this.isNew() ? "create" : options.patch ? "patch" : "update";
          if (method === "patch" && !options.attrs)
            options.attrs = attrs;
          var xhr = this.sync(method, this, options);
          this.attributes = attributes;
          return xhr;
        },
        // Destroy this model on the server if it was already persisted.
        // Optimistically removes the model from its collection, if it has one.
        // If `wait: true` is passed, waits for the server to respond before removal.
        destroy: function(options) {
          options = options ? _5.clone(options) : {};
          var model = this;
          var success = options.success;
          var wait = options.wait;
          var destroy = function() {
            model.stopListening();
            model.trigger("destroy", model, model.collection, options);
          };
          options.success = function(resp) {
            if (wait)
              destroy();
            if (success)
              success.call(options.context, model, resp, options);
            if (!model.isNew())
              model.trigger("sync", model, resp, options);
          };
          var xhr = false;
          if (this.isNew()) {
            _5.defer(options.success);
          } else {
            wrapError(this, options);
            xhr = this.sync("delete", this, options);
          }
          if (!wait)
            destroy();
          return xhr;
        },
        // Default URL for the model's representation on the server -- if you're
        // using Backbone's restful methods, override this to change the endpoint
        // that will be called.
        url: function() {
          var base = _5.result(this, "urlRoot") || _5.result(this.collection, "url") || urlError();
          if (this.isNew())
            return base;
          var id = this.get(this.idAttribute);
          return base.replace(/[^\/]$/, "$&/") + encodeURIComponent(id);
        },
        // **parse** converts a response into the hash of attributes to be `set` on
        // the model. The default implementation is just to pass the response along.
        parse: function(resp, options) {
          return resp;
        },
        // Create a new model with identical attributes to this one.
        clone: function() {
          return new this.constructor(this.attributes);
        },
        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function() {
          return !this.has(this.idAttribute);
        },
        // Check if the model is currently in a valid state.
        isValid: function(options) {
          return this._validate({}, _5.extend({}, options, { validate: true }));
        },
        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function(attrs, options) {
          if (!options.validate || !this.validate)
            return true;
          attrs = _5.extend({}, this.attributes, attrs);
          var error = this.validationError = this.validate(attrs, options) || null;
          if (!error)
            return true;
          this.trigger("invalid", this, error, _5.extend(options, { validationError: error }));
          return false;
        }
      });
      var Collection = Backbone3.Collection = function(models, options) {
        options || (options = {});
        this.preinitialize.apply(this, arguments);
        if (options.model)
          this.model = options.model;
        if (options.comparator !== void 0)
          this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models)
          this.reset(models, _5.extend({ silent: true }, options));
      };
      var setOptions = { add: true, remove: true, merge: true };
      var addOptions = { add: true, remove: false };
      var splice = function(array, insert, at) {
        at = Math.min(Math.max(at, 0), array.length);
        var tail = Array(array.length - at);
        var length = insert.length;
        var i5;
        for (i5 = 0; i5 < tail.length; i5++)
          tail[i5] = array[i5 + at];
        for (i5 = 0; i5 < length; i5++)
          array[i5 + at] = insert[i5];
        for (i5 = 0; i5 < tail.length; i5++)
          array[i5 + length + at] = tail[i5];
      };
      _5.extend(Collection.prototype, Events, {
        // The default model for a collection is just a **Backbone.Model**.
        // This should be overridden in most cases.
        model: Model2,
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the Collection.
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // The JSON representation of a Collection is an array of the
        // models' attributes.
        toJSON: function(options) {
          return this.map(function(model) {
            return model.toJSON(options);
          });
        },
        // Proxy `Backbone.sync` by default.
        sync: function() {
          return Backbone3.sync.apply(this, arguments);
        },
        // Add a model, or list of models to the set. `models` may be Backbone
        // Models or raw JavaScript objects to be converted to Models, or any
        // combination of the two.
        add: function(models, options) {
          return this.set(models, _5.extend({ merge: false }, options, addOptions));
        },
        // Remove a model, or a list of models from the set.
        remove: function(models, options) {
          options = _5.extend({}, options);
          var singular = !_5.isArray(models);
          models = singular ? [models] : models.slice();
          var removed = this._removeModels(models, options);
          if (!options.silent && removed.length) {
            options.changes = { added: [], merged: [], removed };
            this.trigger("update", this, options);
          }
          return singular ? removed[0] : removed;
        },
        // Update a collection by `set`-ing a new list of models, adding new ones,
        // removing models that are no longer present, and merging models that
        // already exist in the collection, as necessary. Similar to **Model#set**,
        // the core operation for updating the data contained by the collection.
        set: function(models, options) {
          if (models == null)
            return;
          options = _5.extend({}, setOptions, options);
          if (options.parse && !this._isModel(models)) {
            models = this.parse(models, options) || [];
          }
          var singular = !_5.isArray(models);
          models = singular ? [models] : models.slice();
          var at = options.at;
          if (at != null)
            at = +at;
          if (at > this.length)
            at = this.length;
          if (at < 0)
            at += this.length + 1;
          var set3 = [];
          var toAdd = [];
          var toMerge = [];
          var toRemove = [];
          var modelMap = {};
          var add = options.add;
          var merge2 = options.merge;
          var remove2 = options.remove;
          var sort = false;
          var sortable = this.comparator && at == null && options.sort !== false;
          var sortAttr = _5.isString(this.comparator) ? this.comparator : null;
          var model, i5;
          for (i5 = 0; i5 < models.length; i5++) {
            model = models[i5];
            var existing = this.get(model);
            if (existing) {
              if (merge2 && model !== existing) {
                var attrs = this._isModel(model) ? model.attributes : model;
                if (options.parse)
                  attrs = existing.parse(attrs, options);
                existing.set(attrs, options);
                toMerge.push(existing);
                if (sortable && !sort)
                  sort = existing.hasChanged(sortAttr);
              }
              if (!modelMap[existing.cid]) {
                modelMap[existing.cid] = true;
                set3.push(existing);
              }
              models[i5] = existing;
            } else if (add) {
              model = models[i5] = this._prepareModel(model, options);
              if (model) {
                toAdd.push(model);
                this._addReference(model, options);
                modelMap[model.cid] = true;
                set3.push(model);
              }
            }
          }
          if (remove2) {
            for (i5 = 0; i5 < this.length; i5++) {
              model = this.models[i5];
              if (!modelMap[model.cid])
                toRemove.push(model);
            }
            if (toRemove.length)
              this._removeModels(toRemove, options);
          }
          var orderChanged = false;
          var replace = !sortable && add && remove2;
          if (set3.length && replace) {
            orderChanged = this.length !== set3.length || _5.some(this.models, function(m4, index2) {
              return m4 !== set3[index2];
            });
            this.models.length = 0;
            splice(this.models, set3, 0);
            this.length = this.models.length;
          } else if (toAdd.length) {
            if (sortable)
              sort = true;
            splice(this.models, toAdd, at == null ? this.length : at);
            this.length = this.models.length;
          }
          if (sort)
            this.sort({ silent: true });
          if (!options.silent) {
            for (i5 = 0; i5 < toAdd.length; i5++) {
              if (at != null)
                options.index = at + i5;
              model = toAdd[i5];
              model.trigger("add", model, this, options);
            }
            if (sort || orderChanged)
              this.trigger("sort", this, options);
            if (toAdd.length || toRemove.length || toMerge.length) {
              options.changes = {
                added: toAdd,
                removed: toRemove,
                merged: toMerge
              };
              this.trigger("update", this, options);
            }
          }
          return singular ? models[0] : models;
        },
        // When you have more items than you want to add or remove individually,
        // you can reset the entire set with a new list of models, without firing
        // any granular `add` or `remove` events. Fires `reset` when finished.
        // Useful for bulk operations and optimizations.
        reset: function(models, options) {
          options = options ? _5.clone(options) : {};
          for (var i5 = 0; i5 < this.models.length; i5++) {
            this._removeReference(this.models[i5], options);
          }
          options.previousModels = this.models;
          this._reset();
          models = this.add(models, _5.extend({ silent: true }, options));
          if (!options.silent)
            this.trigger("reset", this, options);
          return models;
        },
        // Add a model to the end of the collection.
        push: function(model, options) {
          return this.add(model, _5.extend({ at: this.length }, options));
        },
        // Remove a model from the end of the collection.
        pop: function(options) {
          var model = this.at(this.length - 1);
          return this.remove(model, options);
        },
        // Add a model to the beginning of the collection.
        unshift: function(model, options) {
          return this.add(model, _5.extend({ at: 0 }, options));
        },
        // Remove a model from the beginning of the collection.
        shift: function(options) {
          var model = this.at(0);
          return this.remove(model, options);
        },
        // Slice out a sub-array of models from the collection.
        slice: function() {
          return slice2.apply(this.models, arguments);
        },
        // Get a model from the set by id, cid, model object with id or cid
        // properties, or an attributes object that is transformed through modelId.
        get: function(obj) {
          if (obj == null)
            return void 0;
          return this._byId[obj] || this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj)] || obj.cid && this._byId[obj.cid];
        },
        // Returns `true` if the model is in the collection.
        has: function(obj) {
          return this.get(obj) != null;
        },
        // Get the model at the given index.
        at: function(index2) {
          if (index2 < 0)
            index2 += this.length;
          return this.models[index2];
        },
        // Return models with matching attributes. Useful for simple cases of
        // `filter`.
        where: function(attrs, first2) {
          return this[first2 ? "find" : "filter"](attrs);
        },
        // Return the first model with matching attributes. Useful for simple cases
        // of `find`.
        findWhere: function(attrs) {
          return this.where(attrs, true);
        },
        // Force the collection to re-sort itself. You don't need to call this under
        // normal circumstances, as the set will maintain sort order as each item
        // is added.
        sort: function(options) {
          var comparator = this.comparator;
          if (!comparator)
            throw new Error("Cannot sort a set without a comparator");
          options || (options = {});
          var length = comparator.length;
          if (_5.isFunction(comparator))
            comparator = comparator.bind(this);
          if (length === 1 || _5.isString(comparator)) {
            this.models = this.sortBy(comparator);
          } else {
            this.models.sort(comparator);
          }
          if (!options.silent)
            this.trigger("sort", this, options);
          return this;
        },
        // Pluck an attribute from each model in the collection.
        pluck: function(attr) {
          return this.map(attr + "");
        },
        // Fetch the default set of models for this collection, resetting the
        // collection when they arrive. If `reset: true` is passed, the response
        // data will be passed through the `reset` method instead of `set`.
        fetch: function(options) {
          options = _5.extend({ parse: true }, options);
          var success = options.success;
          var collection = this;
          options.success = function(resp) {
            var method = options.reset ? "reset" : "set";
            collection[method](resp, options);
            if (success)
              success.call(options.context, collection, resp, options);
            collection.trigger("sync", collection, resp, options);
          };
          wrapError(this, options);
          return this.sync("read", this, options);
        },
        // Create a new instance of a model in this collection. Add the model to the
        // collection immediately, unless `wait: true` is passed, in which case we
        // wait for the server to agree.
        create: function(model, options) {
          options = options ? _5.clone(options) : {};
          var wait = options.wait;
          model = this._prepareModel(model, options);
          if (!model)
            return false;
          if (!wait)
            this.add(model, options);
          var collection = this;
          var success = options.success;
          options.success = function(m4, resp, callbackOpts) {
            if (wait)
              collection.add(m4, callbackOpts);
            if (success)
              success.call(callbackOpts.context, m4, resp, callbackOpts);
          };
          model.save(null, options);
          return model;
        },
        // **parse** converts a response into a list of models to be added to the
        // collection. The default implementation is just to pass it through.
        parse: function(resp, options) {
          return resp;
        },
        // Create a new collection with an identical list of models as this one.
        clone: function() {
          return new this.constructor(this.models, {
            model: this.model,
            comparator: this.comparator
          });
        },
        // Define how to uniquely identify models in the collection.
        modelId: function(attrs) {
          return attrs[this.model.prototype.idAttribute || "id"];
        },
        // Get an iterator of all models in this collection.
        values: function() {
          return new CollectionIterator(this, ITERATOR_VALUES);
        },
        // Get an iterator of all model IDs in this collection.
        keys: function() {
          return new CollectionIterator(this, ITERATOR_KEYS);
        },
        // Get an iterator of all [ID, model] tuples in this collection.
        entries: function() {
          return new CollectionIterator(this, ITERATOR_KEYSVALUES);
        },
        // Private method to reset all internal state. Called when the collection
        // is first initialized or reset.
        _reset: function() {
          this.length = 0;
          this.models = [];
          this._byId = {};
        },
        // Prepare a hash of attributes (or other model) to be added to this
        // collection.
        _prepareModel: function(attrs, options) {
          if (this._isModel(attrs)) {
            if (!attrs.collection)
              attrs.collection = this;
            return attrs;
          }
          options = options ? _5.clone(options) : {};
          options.collection = this;
          var model = new this.model(attrs, options);
          if (!model.validationError)
            return model;
          this.trigger("invalid", this, model.validationError, options);
          return false;
        },
        // Internal method called by both remove and set.
        _removeModels: function(models, options) {
          var removed = [];
          for (var i5 = 0; i5 < models.length; i5++) {
            var model = this.get(models[i5]);
            if (!model)
              continue;
            var index2 = this.indexOf(model);
            this.models.splice(index2, 1);
            this.length--;
            delete this._byId[model.cid];
            var id = this.modelId(model.attributes);
            if (id != null)
              delete this._byId[id];
            if (!options.silent) {
              options.index = index2;
              model.trigger("remove", model, this, options);
            }
            removed.push(model);
            this._removeReference(model, options);
          }
          return removed;
        },
        // Method for checking whether an object should be considered a model for
        // the purposes of adding to the collection.
        _isModel: function(model) {
          return model instanceof Model2;
        },
        // Internal method to create a model's ties to a collection.
        _addReference: function(model, options) {
          this._byId[model.cid] = model;
          var id = this.modelId(model.attributes);
          if (id != null)
            this._byId[id] = model;
          model.on("all", this._onModelEvent, this);
        },
        // Internal method to sever a model's ties to a collection.
        _removeReference: function(model, options) {
          delete this._byId[model.cid];
          var id = this.modelId(model.attributes);
          if (id != null)
            delete this._byId[id];
          if (this === model.collection)
            delete model.collection;
          model.off("all", this._onModelEvent, this);
        },
        // Internal method called every time a model in the set fires an event.
        // Sets need to update their indexes when models change ids. All other
        // events simply proxy through. "add" and "remove" events that originate
        // in other collections are ignored.
        _onModelEvent: function(event, model, collection, options) {
          if (model) {
            if ((event === "add" || event === "remove") && collection !== this)
              return;
            if (event === "destroy")
              this.remove(model, options);
            if (event === "change") {
              var prevId = this.modelId(model.previousAttributes());
              var id = this.modelId(model.attributes);
              if (prevId !== id) {
                if (prevId != null)
                  delete this._byId[prevId];
                if (id != null)
                  this._byId[id] = model;
              }
            }
          }
          this.trigger.apply(this, arguments);
        }
      });
      var $$iterator = typeof Symbol === "function" && Symbol.iterator;
      if ($$iterator) {
        Collection.prototype[$$iterator] = Collection.prototype.values;
      }
      var CollectionIterator = function(collection, kind) {
        this._collection = collection;
        this._kind = kind;
        this._index = 0;
      };
      var ITERATOR_VALUES = 1;
      var ITERATOR_KEYS = 2;
      var ITERATOR_KEYSVALUES = 3;
      if ($$iterator) {
        CollectionIterator.prototype[$$iterator] = function() {
          return this;
        };
      }
      CollectionIterator.prototype.next = function() {
        if (this._collection) {
          if (this._index < this._collection.length) {
            var model = this._collection.at(this._index);
            this._index++;
            var value;
            if (this._kind === ITERATOR_VALUES) {
              value = model;
            } else {
              var id = this._collection.modelId(model.attributes);
              if (this._kind === ITERATOR_KEYS) {
                value = id;
              } else {
                value = [id, model];
              }
            }
            return { value, done: false };
          }
          this._collection = void 0;
        }
        return { value: void 0, done: true };
      };
      var View2 = Backbone3.View = function(options) {
        this.cid = _5.uniqueId("view");
        this.preinitialize.apply(this, arguments);
        _5.extend(this, _5.pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
      };
      var delegateEventSplitter = /^(\S+)\s*(.*)$/;
      var viewOptions = ["model", "collection", "el", "id", "attributes", "className", "tagName", "events"];
      _5.extend(View2.prototype, Events, {
        // The default `tagName` of a View's element is `"div"`.
        tagName: "div",
        // jQuery delegate for element lookup, scoped to DOM elements within the
        // current view. This should be preferred to global lookups where possible.
        $: function(selector) {
          return this.$el.find(selector);
        },
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the View
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // **render** is the core function that your view should override, in order
        // to populate its element (`this.el`), with the appropriate HTML. The
        // convention is for **render** to always return `this`.
        render: function() {
          return this;
        },
        // Remove this view by taking the element out of the DOM, and removing any
        // applicable Backbone.Events listeners.
        remove: function() {
          this._removeElement();
          this.stopListening();
          return this;
        },
        // Remove this view's element from the document and all event listeners
        // attached to it. Exposed for subclasses using an alternative DOM
        // manipulation API.
        _removeElement: function() {
          this.$el.remove();
        },
        // Change the view's element (`this.el` property) and re-delegate the
        // view's events on the new element.
        setElement: function(element2) {
          this.undelegateEvents();
          this._setElement(element2);
          this.delegateEvents();
          return this;
        },
        // Creates the `this.el` and `this.$el` references for this view using the
        // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
        // context or an element. Subclasses can override this to utilize an
        // alternative DOM manipulation API and are only required to set the
        // `this.el` property.
        _setElement: function(el) {
          this.$el = el instanceof Backbone3.$ ? el : Backbone3.$(el);
          this.el = this.$el[0];
        },
        // Set callbacks, where `this.events` is a hash of
        //
        // *{"event selector": "callback"}*
        //
        //     {
        //       'mousedown .title':  'edit',
        //       'click .button':     'save',
        //       'click .open':       function(e) { ... }
        //     }
        //
        // pairs. Callbacks will be bound to the view, with `this` set properly.
        // Uses event delegation for efficiency.
        // Omitting the selector binds the event to `this.el`.
        delegateEvents: function(events2) {
          events2 || (events2 = _5.result(this, "events"));
          if (!events2)
            return this;
          this.undelegateEvents();
          for (var key in events2) {
            var method = events2[key];
            if (!_5.isFunction(method))
              method = this[method];
            if (!method)
              continue;
            var match = key.match(delegateEventSplitter);
            this.delegate(match[1], match[2], method.bind(this));
          }
          return this;
        },
        // Add a single event listener to the view's element (or a child element
        // using `selector`). This only works for delegate-able events: not `focus`,
        // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
        delegate: function(eventName, selector, listener) {
          this.$el.on(eventName + ".delegateEvents" + this.cid, selector, listener);
          return this;
        },
        // Clears all callbacks previously bound to the view by `delegateEvents`.
        // You usually don't need to use this, but may wish to if you have multiple
        // Backbone views attached to the same DOM element.
        undelegateEvents: function() {
          if (this.$el)
            this.$el.off(".delegateEvents" + this.cid);
          return this;
        },
        // A finer-grained `undelegateEvents` for removing a single delegated event.
        // `selector` and `listener` are both optional.
        undelegate: function(eventName, selector, listener) {
          this.$el.off(eventName + ".delegateEvents" + this.cid, selector, listener);
          return this;
        },
        // Produces a DOM element to be assigned to your view. Exposed for
        // subclasses using an alternative DOM manipulation API.
        _createElement: function(tagName) {
          return document.createElement(tagName);
        },
        // Ensure that the View has a DOM element to render into.
        // If `this.el` is a string, pass it through `$()`, take the first
        // matching element, and re-assign it to `el`. Otherwise, create
        // an element from the `id`, `className` and `tagName` properties.
        _ensureElement: function() {
          if (!this.el) {
            var attrs = _5.extend({}, _5.result(this, "attributes"));
            if (this.id)
              attrs.id = _5.result(this, "id");
            if (this.className)
              attrs["class"] = _5.result(this, "className");
            this.setElement(this._createElement(_5.result(this, "tagName")));
            this._setAttributes(attrs);
          } else {
            this.setElement(_5.result(this, "el"));
          }
        },
        // Set attributes from a hash on this view's element.  Exposed for
        // subclasses using an alternative DOM manipulation API.
        _setAttributes: function(attributes) {
          this.$el.attr(attributes);
        }
      });
      var addMethod = function(base, length, method, attribute) {
        switch (length) {
          case 1:
            return function() {
              return base[method](this[attribute]);
            };
          case 2:
            return function(value) {
              return base[method](this[attribute], value);
            };
          case 3:
            return function(iteratee2, context) {
              return base[method](this[attribute], cb2(iteratee2, this), context);
            };
          case 4:
            return function(iteratee2, defaultVal, context) {
              return base[method](this[attribute], cb2(iteratee2, this), defaultVal, context);
            };
          default:
            return function() {
              var args = slice2.call(arguments);
              args.unshift(this[attribute]);
              return base[method].apply(base, args);
            };
        }
      };
      var addUnderscoreMethods = function(Class, base, methods, attribute) {
        _5.each(methods, function(length, method) {
          if (base[method])
            Class.prototype[method] = addMethod(base, length, method, attribute);
        });
      };
      var cb2 = function(iteratee2, instance) {
        if (_5.isFunction(iteratee2))
          return iteratee2;
        if (_5.isObject(iteratee2) && !instance._isModel(iteratee2))
          return modelMatcher(iteratee2);
        if (_5.isString(iteratee2))
          return function(model) {
            return model.get(iteratee2);
          };
        return iteratee2;
      };
      var modelMatcher = function(attrs) {
        var matcher2 = _5.matches(attrs);
        return function(model) {
          return matcher2(model.attributes);
        };
      };
      var collectionMethods = {
        forEach: 3,
        each: 3,
        map: 3,
        collect: 3,
        reduce: 0,
        foldl: 0,
        inject: 0,
        reduceRight: 0,
        foldr: 0,
        find: 3,
        detect: 3,
        filter: 3,
        select: 3,
        reject: 3,
        every: 3,
        all: 3,
        some: 3,
        any: 3,
        include: 3,
        includes: 3,
        contains: 3,
        invoke: 0,
        max: 3,
        min: 3,
        toArray: 1,
        size: 1,
        first: 3,
        head: 3,
        take: 3,
        initial: 3,
        rest: 3,
        tail: 3,
        drop: 3,
        last: 3,
        without: 0,
        difference: 0,
        indexOf: 3,
        shuffle: 1,
        lastIndexOf: 3,
        isEmpty: 1,
        chain: 1,
        sample: 3,
        partition: 3,
        groupBy: 3,
        countBy: 3,
        sortBy: 3,
        indexBy: 3,
        findIndex: 3,
        findLastIndex: 3
      };
      var modelMethods = {
        keys: 1,
        values: 1,
        pairs: 1,
        invert: 1,
        pick: 0,
        omit: 0,
        chain: 1,
        isEmpty: 1
      };
      _5.each([
        [Collection, collectionMethods, "models"],
        [Model2, modelMethods, "attributes"]
      ], function(config) {
        var Base = config[0], methods = config[1], attribute = config[2];
        Base.mixin = function(obj) {
          var mappings = _5.reduce(_5.functions(obj), function(memo, name2) {
            memo[name2] = 0;
            return memo;
          }, {});
          addUnderscoreMethods(Base, obj, mappings, attribute);
        };
        addUnderscoreMethods(Base, _5, methods, attribute);
      });
      Backbone3.sync = function(method, model, options) {
        var type2 = methodMap[method];
        _5.defaults(options || (options = {}), {
          emulateHTTP: Backbone3.emulateHTTP,
          emulateJSON: Backbone3.emulateJSON
        });
        var params = { type: type2, dataType: "json" };
        if (!options.url) {
          params.url = _5.result(model, "url") || urlError();
        }
        if (options.data == null && model && (method === "create" || method === "update" || method === "patch")) {
          params.contentType = "application/json";
          params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }
        if (options.emulateJSON) {
          params.contentType = "application/x-www-form-urlencoded";
          params.data = params.data ? { model: params.data } : {};
        }
        if (options.emulateHTTP && (type2 === "PUT" || type2 === "DELETE" || type2 === "PATCH")) {
          params.type = "POST";
          if (options.emulateJSON)
            params.data._method = type2;
          var beforeSend = options.beforeSend;
          options.beforeSend = function(xhr2) {
            xhr2.setRequestHeader("X-HTTP-Method-Override", type2);
            if (beforeSend)
              return beforeSend.apply(this, arguments);
          };
        }
        if (params.type !== "GET" && !options.emulateJSON) {
          params.processData = false;
        }
        var error = options.error;
        options.error = function(xhr2, textStatus, errorThrown) {
          options.textStatus = textStatus;
          options.errorThrown = errorThrown;
          if (error)
            error.call(options.context, xhr2, textStatus, errorThrown);
        };
        var xhr = options.xhr = Backbone3.ajax(_5.extend(params, options));
        model.trigger("request", model, xhr, options);
        return xhr;
      };
      var methodMap = {
        create: "POST",
        update: "PUT",
        patch: "PATCH",
        delete: "DELETE",
        read: "GET"
      };
      Backbone3.ajax = function() {
        return Backbone3.$.ajax.apply(Backbone3.$, arguments);
      };
      var Router = Backbone3.Router = function(options) {
        options || (options = {});
        this.preinitialize.apply(this, arguments);
        if (options.routes)
          this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
      };
      var optionalParam = /\((.*?)\)/g;
      var namedParam = /(\(\?)?:\w+/g;
      var splatParam = /\*\w+/g;
      var escapeRegExp2 = /[\-{}\[\]+?.,\\\^$|#\s]/g;
      _5.extend(Router.prototype, Events, {
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the Router.
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // Manually bind a single named route to a callback. For example:
        //
        //     this.route('search/:query/p:num', 'search', function(query, num) {
        //       ...
        //     });
        //
        route: function(route, name2, callback) {
          if (!_5.isRegExp(route))
            route = this._routeToRegExp(route);
          if (_5.isFunction(name2)) {
            callback = name2;
            name2 = "";
          }
          if (!callback)
            callback = this[name2];
          var router = this;
          Backbone3.history.route(route, function(fragment) {
            var args = router._extractParameters(route, fragment);
            if (router.execute(callback, args, name2) !== false) {
              router.trigger.apply(router, ["route:" + name2].concat(args));
              router.trigger("route", name2, args);
              Backbone3.history.trigger("route", router, name2, args);
            }
          });
          return this;
        },
        // Execute a route handler with the provided parameters.  This is an
        // excellent place to do pre-route setup or post-route cleanup.
        execute: function(callback, args, name2) {
          if (callback)
            callback.apply(this, args);
        },
        // Simple proxy to `Backbone.history` to save a fragment into the history.
        navigate: function(fragment, options) {
          Backbone3.history.navigate(fragment, options);
          return this;
        },
        // Bind all defined routes to `Backbone.history`. We have to reverse the
        // order of the routes here to support behavior where the most general
        // routes can be defined at the bottom of the route map.
        _bindRoutes: function() {
          if (!this.routes)
            return;
          this.routes = _5.result(this, "routes");
          var route, routes = _5.keys(this.routes);
          while ((route = routes.pop()) != null) {
            this.route(route, this.routes[route]);
          }
        },
        // Convert a route string into a regular expression, suitable for matching
        // against the current location hash.
        _routeToRegExp: function(route) {
          route = route.replace(escapeRegExp2, "\\$&").replace(optionalParam, "(?:$1)?").replace(namedParam, function(match, optional) {
            return optional ? match : "([^/?]+)";
          }).replace(splatParam, "([^?]*?)");
          return new RegExp("^" + route + "(?:\\?([\\s\\S]*))?$");
        },
        // Given a route, and a URL fragment that it matches, return the array of
        // extracted decoded parameters. Empty or unmatched parameters will be
        // treated as `null` to normalize cross-browser behavior.
        _extractParameters: function(route, fragment) {
          var params = route.exec(fragment).slice(1);
          return _5.map(params, function(param, i5) {
            if (i5 === params.length - 1)
              return param || null;
            return param ? decodeURIComponent(param) : null;
          });
        }
      });
      var History = Backbone3.History = function() {
        this.handlers = [];
        this.checkUrl = this.checkUrl.bind(this);
        if (typeof window !== "undefined") {
          this.location = window.location;
          this.history = window.history;
        }
      };
      var routeStripper = /^[#\/]|\s+$/g;
      var rootStripper = /^\/+|\/+$/g;
      var pathStripper = /#.*$/;
      History.started = false;
      _5.extend(History.prototype, Events, {
        // The default interval to poll for hash changes, if necessary, is
        // twenty times a second.
        interval: 50,
        // Are we at the app root?
        atRoot: function() {
          var path2 = this.location.pathname.replace(/[^\/]$/, "$&/");
          return path2 === this.root && !this.getSearch();
        },
        // Does the pathname match the root?
        matchRoot: function() {
          var path2 = this.decodeFragment(this.location.pathname);
          var rootPath = path2.slice(0, this.root.length - 1) + "/";
          return rootPath === this.root;
        },
        // Unicode characters in `location.pathname` are percent encoded so they're
        // decoded for comparison. `%25` should not be decoded since it may be part
        // of an encoded parameter.
        decodeFragment: function(fragment) {
          return decodeURI(fragment.replace(/%25/g, "%2525"));
        },
        // In IE6, the hash fragment and search params are incorrect if the
        // fragment contains `?`.
        getSearch: function() {
          var match = this.location.href.replace(/#.*/, "").match(/\?.+/);
          return match ? match[0] : "";
        },
        // Gets the true hash value. Cannot use location.hash directly due to bug
        // in Firefox where location.hash will always be decoded.
        getHash: function(window2) {
          var match = (window2 || this).location.href.match(/#(.*)$/);
          return match ? match[1] : "";
        },
        // Get the pathname and search params, without the root.
        getPath: function() {
          var path2 = this.decodeFragment(
            this.location.pathname + this.getSearch()
          ).slice(this.root.length - 1);
          return path2.charAt(0) === "/" ? path2.slice(1) : path2;
        },
        // Get the cross-browser normalized URL fragment from the path or hash.
        getFragment: function(fragment) {
          if (fragment == null) {
            if (this._usePushState || !this._wantsHashChange) {
              fragment = this.getPath();
            } else {
              fragment = this.getHash();
            }
          }
          return fragment.replace(routeStripper, "");
        },
        // Start the hash change handling, returning `true` if the current URL matches
        // an existing route, and `false` otherwise.
        start: function(options) {
          if (History.started)
            throw new Error("Backbone.history has already been started");
          History.started = true;
          this.options = _5.extend({ root: "/" }, this.options, options);
          this.root = this.options.root;
          this._wantsHashChange = this.options.hashChange !== false;
          this._hasHashChange = "onhashchange" in window && (document.documentMode === void 0 || document.documentMode > 7);
          this._useHashChange = this._wantsHashChange && this._hasHashChange;
          this._wantsPushState = !!this.options.pushState;
          this._hasPushState = !!(this.history && this.history.pushState);
          this._usePushState = this._wantsPushState && this._hasPushState;
          this.fragment = this.getFragment();
          this.root = ("/" + this.root + "/").replace(rootStripper, "/");
          if (this._wantsHashChange && this._wantsPushState) {
            if (!this._hasPushState && !this.atRoot()) {
              var rootPath = this.root.slice(0, -1) || "/";
              this.location.replace(rootPath + "#" + this.getPath());
              return true;
            } else if (this._hasPushState && this.atRoot()) {
              this.navigate(this.getHash(), { replace: true });
            }
          }
          if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
            this.iframe = document.createElement("iframe");
            this.iframe.src = "javascript:0";
            this.iframe.style.display = "none";
            this.iframe.tabIndex = -1;
            var body = document.body;
            var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
            iWindow.document.open();
            iWindow.document.close();
            iWindow.location.hash = "#" + this.fragment;
          }
          var addEventListener = window.addEventListener || function(eventName, listener) {
            return attachEvent("on" + eventName, listener);
          };
          if (this._usePushState) {
            addEventListener("popstate", this.checkUrl, false);
          } else if (this._useHashChange && !this.iframe) {
            addEventListener("hashchange", this.checkUrl, false);
          } else if (this._wantsHashChange) {
            this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
          }
          if (!this.options.silent)
            return this.loadUrl();
        },
        // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
        // but possibly useful for unit testing Routers.
        stop: function() {
          var removeEventListener = window.removeEventListener || function(eventName, listener) {
            return detachEvent("on" + eventName, listener);
          };
          if (this._usePushState) {
            removeEventListener("popstate", this.checkUrl, false);
          } else if (this._useHashChange && !this.iframe) {
            removeEventListener("hashchange", this.checkUrl, false);
          }
          if (this.iframe) {
            document.body.removeChild(this.iframe);
            this.iframe = null;
          }
          if (this._checkUrlInterval)
            clearInterval(this._checkUrlInterval);
          History.started = false;
        },
        // Add a route to be tested when the fragment changes. Routes added later
        // may override previous routes.
        route: function(route, callback) {
          this.handlers.unshift({ route, callback });
        },
        // Checks the current URL to see if it has changed, and if it has,
        // calls `loadUrl`, normalizing across the hidden iframe.
        checkUrl: function(e4) {
          var current = this.getFragment();
          if (current === this.fragment && this.iframe) {
            current = this.getHash(this.iframe.contentWindow);
          }
          if (current === this.fragment)
            return false;
          if (this.iframe)
            this.navigate(current);
          this.loadUrl();
        },
        // Attempt to load the current URL fragment. If a route succeeds with a
        // match, returns `true`. If no defined routes matches the fragment,
        // returns `false`.
        loadUrl: function(fragment) {
          if (!this.matchRoot())
            return false;
          fragment = this.fragment = this.getFragment(fragment);
          return _5.some(this.handlers, function(handler) {
            if (handler.route.test(fragment)) {
              handler.callback(fragment);
              return true;
            }
          });
        },
        // Save a fragment into the hash history, or replace the URL state if the
        // 'replace' option is passed. You are responsible for properly URL-encoding
        // the fragment in advance.
        //
        // The options object can contain `trigger: true` if you wish to have the
        // route callback be fired (not usually desirable), or `replace: true`, if
        // you wish to modify the current URL without adding an entry to the history.
        navigate: function(fragment, options) {
          if (!History.started)
            return false;
          if (!options || options === true)
            options = { trigger: !!options };
          fragment = this.getFragment(fragment || "");
          var rootPath = this.root;
          if (fragment === "" || fragment.charAt(0) === "?") {
            rootPath = rootPath.slice(0, -1) || "/";
          }
          var url = rootPath + fragment;
          fragment = fragment.replace(pathStripper, "");
          var decodedFragment = this.decodeFragment(fragment);
          if (this.fragment === decodedFragment)
            return;
          this.fragment = decodedFragment;
          if (this._usePushState) {
            this.history[options.replace ? "replaceState" : "pushState"]({}, document.title, url);
          } else if (this._wantsHashChange) {
            this._updateHash(this.location, fragment, options.replace);
            if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
              var iWindow = this.iframe.contentWindow;
              if (!options.replace) {
                iWindow.document.open();
                iWindow.document.close();
              }
              this._updateHash(iWindow.location, fragment, options.replace);
            }
          } else {
            return this.location.assign(url);
          }
          if (options.trigger)
            return this.loadUrl(fragment);
        },
        // Update the hash location, either replacing the current entry, or adding
        // a new one to the browser history.
        _updateHash: function(location2, fragment, replace) {
          if (replace) {
            var href = location2.href.replace(/(javascript:|#).*$/, "");
            location2.replace(href + "#" + fragment);
          } else {
            location2.hash = "#" + fragment;
          }
        }
      });
      Backbone3.history = new History();
      var extend3 = function(protoProps, staticProps) {
        var parent = this;
        var child;
        if (protoProps && _5.has(protoProps, "constructor")) {
          child = protoProps.constructor;
        } else {
          child = function() {
            return parent.apply(this, arguments);
          };
        }
        _5.extend(child, parent, staticProps);
        child.prototype = _5.create(parent.prototype, protoProps);
        child.prototype.constructor = child;
        child.__super__ = parent.prototype;
        return child;
      };
      Model2.extend = Collection.extend = Router.extend = View2.extend = History.extend = extend3;
      var urlError = function() {
        throw new Error('A "url" property or function must be specified');
      };
      var wrapError = function(model, options) {
        var error = options.error;
        options.error = function(resp) {
          if (error)
            error.call(options.context, model, resp, options);
          model.trigger("error", model, resp, options);
        };
      };
      return Backbone3;
    });
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/nativeview.js
function matchesFallback(selector) {
  const matches = (this.document || this.ownerDocument).querySelectorAll(selector);
  let i5 = matches.length;
  while (--i5 >= 0 && matches.item(i5) !== this) {
    continue;
  }
  return i5 > -1;
}
var Backbone, ElementProto, matchesSelector, NativeView;
var init_nativeview = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/nativeview.js"() {
    Backbone = __toESM(require_backbone());
    ElementProto = typeof Element !== "undefined" ? Element.prototype : void 0;
    matchesSelector = ElementProto ? ElementProto.matches || ElementProto["webkitMatchesSelector"] || ElementProto["mozMatchesSelector"] || ElementProto["msMatchesSelector"] || ElementProto["oMatchesSelector"] || matchesFallback : matchesFallback;
    NativeView = class extends Backbone.View {
      _removeElement() {
        this.undelegateEvents();
        if (this.el.parentNode) {
          this.el.parentNode.removeChild(this.el);
        }
      }
      // Apply the `element` to the view.
      _setElement(element2) {
        this.el = element2;
      }
      // Set a hash of attributes to the view's `el`. We use the "prop" version
      // if available, falling back to `setAttribute` for the catch-all.
      _setAttributes(attrs) {
        for (const attr in attrs) {
          attr in this.el ? this.el[attr] = attrs[attr] : this.el.setAttribute(attr, attrs[attr]);
        }
      }
      delegate(eventName, selector, listener) {
        if (typeof selector !== "string") {
          listener = selector;
          selector = null;
        }
        if (this._domEvents === void 0) {
          this._domEvents = [];
        }
        const root2 = this.el;
        const handler = selector ? function(e4) {
          let node = e4.target || e4.srcElement;
          for (; node && node !== root2; node = node.parentNode) {
            if (matchesSelector.call(node, selector)) {
              e4.delegateTarget = node;
              if (listener.handleEvent) {
                return listener.handleEvent(e4);
              } else {
                return listener(e4);
              }
            }
          }
        } : listener;
        this.el.addEventListener(eventName, handler, false);
        this._domEvents.push({ eventName, handler, listener, selector });
        return handler;
      }
      undelegate(eventName, selector, listener) {
        if (typeof selector === "function") {
          listener = selector;
          selector = null;
        }
        if (this.el && this._domEvents) {
          const handlers = this._domEvents.slice();
          let i5 = handlers.length;
          while (i5--) {
            const item = handlers[i5];
            const match = item.eventName === eventName && (listener ? item.listener === listener : true) && (selector ? item.selector === selector : true);
            if (!match) {
              continue;
            }
            this.el.removeEventListener(item.eventName, item.handler, false);
            this._domEvents.splice(i5, 1);
          }
        }
        return this;
      }
      // Remove all events created with `delegate` from `el`
      undelegateEvents() {
        if (this.el && this._domEvents) {
          const len = this._domEvents.length;
          for (let i5 = 0; i5 < len; i5++) {
            const item = this._domEvents[i5];
            this.el.removeEventListener(item.eventName, item.handler, false);
          }
          this._domEvents.length = 0;
        }
        return this;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/version.js
var JUPYTER_WIDGETS_VERSION, PROTOCOL_VERSION;
var init_version = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/version.js"() {
    JUPYTER_WIDGETS_VERSION = "2.0.0";
    PROTOCOL_VERSION = "2.1.0";
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/widget.js
function unpack_models(value, manager) {
  if (Array.isArray(value)) {
    const unpacked = [];
    for (const sub_value of value) {
      unpacked.push(unpack_models(sub_value, manager));
    }
    return Promise.all(unpacked);
  } else if (value instanceof Object && typeof value !== "string") {
    const unpacked = {};
    for (const [key, sub_value] of Object.entries(value)) {
      unpacked[key] = unpack_models(sub_value, manager);
    }
    return resolvePromisesDict(unpacked);
  } else if (typeof value === "string" && value.slice(0, 10) === IPY_MODEL_) {
    return manager.get_model(value.slice(10, value.length));
  } else {
    return Promise.resolve(value);
  }
}
function pack_models(value, widget) {
  if (Array.isArray(value)) {
    const model_ids = [];
    for (const model of value) {
      model_ids.push(pack_models(model, widget));
    }
    return model_ids;
  } else if (value instanceof WidgetModel) {
    return `${IPY_MODEL_}${value.model_id}`;
  } else if (value instanceof Object && typeof value !== "string") {
    const packed = {};
    for (const [key, sub_value] of Object.entries(value)) {
      packed[key] = pack_models(sub_value, widget);
    }
  } else {
    return value;
  }
}
var Backbone2, import_jquery, import_coreutils17, IPY_MODEL_, WidgetModel, DOMWidgetModel, WidgetView, JupyterLuminoWidget, JupyterPhosphorWidget, JupyterLuminoPanelWidget, DOMWidgetView;
var init_widget2 = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/widget.js"() {
    init_utils();
    init_backbone_patch();
    Backbone2 = __toESM(require_backbone());
    import_jquery = __toESM(require_jquery());
    init_nativeview();
    import_coreutils17 = __toESM(require_dist());
    init_index_es66();
    init_index_es64();
    init_version();
    IPY_MODEL_ = "IPY_MODEL_";
    WidgetModel = class extends Backbone2.Model {
      /**
       * The default attributes.
       */
      defaults() {
        return {
          _model_module: "@jupyter-widgets/base",
          _model_name: "WidgetModel",
          _model_module_version: JUPYTER_WIDGETS_VERSION,
          _view_module: "@jupyter-widgets/base",
          _view_name: null,
          _view_module_version: JUPYTER_WIDGETS_VERSION,
          _view_count: null
        };
      }
      /**
       * Test to see if the model has been synced with the server.
       *
       * #### Notes
       * As of backbone 1.1, backbone ignores `patch` if it thinks the
       * model has never been pushed.
       */
      isNew() {
        return false;
      }
      /**
       * Constructor
       *
       * Initializes a WidgetModel instance. Called by the Backbone constructor.
       *
       * Parameters
       * ----------
       * widget_manager : WidgetManager instance
       * model_id : string
       *      An ID unique to this model.
       * comm : Comm instance (optional)
       */
      initialize(attributes, options) {
        this._expectedEchoMsgIds = /* @__PURE__ */ new Map();
        this._attrsToUpdate = /* @__PURE__ */ new Set();
        super.initialize(attributes, options);
        this.widget_manager = options.widget_manager;
        this.model_id = options.model_id;
        const comm = options.comm;
        this.views = /* @__PURE__ */ Object.create(null);
        this.state_change = Promise.resolve();
        this._closed = false;
        this._state_lock = null;
        this._msg_buffer = null;
        this._msg_buffer_callbacks = null;
        this._pending_msgs = 0;
        this._buffered_state_diff = {};
        if (comm) {
          this.comm = comm;
          comm.on_close(this._handle_comm_closed.bind(this));
          comm.on_msg(this._handle_comm_msg.bind(this));
          this.comm_live = true;
        } else {
          this.comm_live = false;
        }
      }
      get comm_live() {
        return this._comm_live;
      }
      set comm_live(x4) {
        this._comm_live = x4;
        this.trigger("comm_live_update");
      }
      /**
       * Send a custom msg over the comm.
       */
      send(content, callbacks, buffers) {
        if (this.comm !== void 0) {
          const data = { method: "custom", content };
          this.comm.send(data, callbacks, {}, buffers);
        }
      }
      /**
       * Close model
       *
       * @param comm_closed - true if the comm is already being closed. If false, the comm will be closed.
       *
       * @returns - a promise that is fulfilled when all the associated views have been removed.
       */
      close(comm_closed = false) {
        if (this._closed) {
          return Promise.resolve();
        }
        this._closed = true;
        if (this.comm && !comm_closed) {
          this.comm.close();
        }
        this.stopListening();
        this.trigger("destroy", this);
        if (this.comm) {
          delete this.comm;
        }
        if (this.views) {
          const views = Object.keys(this.views).map((id) => {
            return this.views[id].then((view) => view.remove());
          });
          delete this.views;
          return Promise.all(views).then(() => {
            return;
          });
        }
        return Promise.resolve();
      }
      /**
       * Handle when a widget comm is closed.
       */
      _handle_comm_closed(msg) {
        this.trigger("comm:close");
        this.close(true);
      }
      /**
       * Handle incoming comm msg.
       */
      _handle_comm_msg(msg) {
        const data = msg.content.data;
        const method = data.method;
        switch (method) {
          case "update":
          case "echo_update":
            this.state_change = this.state_change.then(() => {
              var _a, _b, _c;
              const state = data.state;
              const buffer_paths = (_a = data.buffer_paths) !== null && _a !== void 0 ? _a : [];
              const buffers = (_c = (_b = msg.buffers) === null || _b === void 0 ? void 0 : _b.slice(0, buffer_paths.length)) !== null && _c !== void 0 ? _c : [];
              put_buffers(state, buffer_paths, buffers);
              if (msg.parent_header && method === "echo_update") {
                const msgId = msg.parent_header.msg_id;
                const expectedEcho = Object.keys(state).filter((attrName) => this._expectedEchoMsgIds.has(attrName));
                expectedEcho.forEach((attrName) => {
                  const isOldMessage = this._expectedEchoMsgIds.get(attrName) !== msgId;
                  if (isOldMessage) {
                    delete state[attrName];
                  } else {
                    this._expectedEchoMsgIds.delete(attrName);
                    if (this._msg_buffer !== null && Object.prototype.hasOwnProperty.call(this._msg_buffer, attrName)) {
                      delete state[attrName];
                    }
                  }
                });
              }
              return this.constructor._deserialize_state(
                // Combine the state updates, with preference for kernel updates
                state,
                this.widget_manager
              );
            }).then((state) => {
              this.set_state(state);
            }).catch(reject(`Could not process update msg for model id: ${this.model_id}`, true));
            return this.state_change;
          case "custom":
            this.trigger("msg:custom", data.content, msg.buffers);
            return Promise.resolve();
        }
        return Promise.resolve();
      }
      /**
       * Handle when a widget is updated from the backend.
       *
       * This function is meant for internal use only. Values set here will not be propagated on a sync.
       */
      set_state(state) {
        this._state_lock = state;
        try {
          this.set(state);
        } catch (e4) {
          console.error(`Error setting state: ${e4 instanceof Error ? e4.message : e4}`);
        } finally {
          this._state_lock = null;
        }
      }
      /**
       * Get the serializable state of the model.
       *
       * If drop_default is truthy, attributes that are equal to their default
       * values are dropped.
       */
      get_state(drop_defaults) {
        const fullState = this.attributes;
        if (drop_defaults) {
          const d6 = this.defaults;
          const defaults = typeof d6 === "function" ? d6.call(this) : d6;
          const state = {};
          Object.keys(fullState).forEach((key) => {
            if (!isEqual(fullState[key], defaults[key])) {
              state[key] = fullState[key];
            }
          });
          return state;
        } else {
          return Object.assign({}, fullState);
        }
      }
      /**
       * Handle status msgs.
       *
       * execution_state : ('busy', 'idle', 'starting')
       */
      _handle_status(msg) {
        if (this.comm !== void 0) {
          if (msg.content.execution_state === "idle") {
            this._pending_msgs--;
            if (this._pending_msgs < 0) {
              console.error(`Jupyter Widgets message throttle: Pending messages < 0 (=${this._pending_msgs}), which is unexpected. Resetting to 0 to continue.`);
              this._pending_msgs = 0;
            }
            if (this._msg_buffer !== null && this._pending_msgs < 1) {
              const msgId = this.send_sync_message(this._msg_buffer, this._msg_buffer_callbacks);
              this.rememberLastUpdateFor(msgId);
              this._msg_buffer = null;
              this._msg_buffer_callbacks = null;
            }
          }
        }
      }
      /**
       * Create msg callbacks for a comm msg.
       */
      callbacks(view) {
        return this.widget_manager.callbacks(view);
      }
      /**
       * Set one or more values.
       *
       * We just call the super method, in which val and options are optional.
       * Handles both "key", value and {key: value} -style arguments.
       */
      set(key, val, options) {
        const return_value = set.call(this, key, val, options);
        if (this._buffered_state_diff !== void 0) {
          const attrs = this.changedAttributes() || {};
          if (this._state_lock) {
            for (const key2 of Object.keys(this._state_lock)) {
              if (attrs[key2] === this._state_lock[key2]) {
                delete attrs[key2];
              }
            }
          }
          if (this._buffered_state_diff_synced) {
            for (const key2 of Object.keys(this._buffered_state_diff_synced)) {
              if (attrs[key2] === this._buffered_state_diff_synced[key2]) {
                delete attrs[key2];
              }
            }
          }
          this._buffered_state_diff = assign(this._buffered_state_diff, attrs);
        }
        if (this._changing === false) {
          this._buffered_state_diff_synced = {};
        }
        return return_value;
      }
      /**
       * Handle sync to the back-end.  Called when a model.save() is called.
       *
       * Make sure a comm exists.
       *
       * Parameters
       * ----------
       * method : create, update, patch, delete, read
       *   create/update always send the full attribute set
       *   patch - only send attributes listed in options.attrs, and if we
       *   are queuing up messages, combine with previous messages that have
       *   not been sent yet
       * model : the model we are syncing
       *   will normally be the same as `this`
       * options : dict
       *   the `attrs` key, if it exists, gives an {attr: value} dict that
       *   should be synced, otherwise, sync all attributes.
       *
       */
      sync(method, model, options = {}) {
        if (this.comm === void 0) {
          throw "Syncing error: no comm channel defined";
        }
        const attrs = method === "patch" ? options.attrs : model.get_state(options.drop_defaults);
        if (this._state_lock) {
          for (const key of Object.keys(this._state_lock)) {
            if (attrs[key] === this._state_lock[key]) {
              delete attrs[key];
            }
          }
        }
        Object.keys(attrs).forEach((attrName) => {
          this._attrsToUpdate.add(attrName);
        });
        const msgState = this.serialize(attrs);
        if (Object.keys(msgState).length > 0) {
          const callbacks = options.callbacks || this.callbacks();
          if (this._pending_msgs >= 1) {
            switch (method) {
              case "patch":
                this._msg_buffer = assign(this._msg_buffer || {}, msgState);
                break;
              case "update":
              case "create":
                this._msg_buffer = msgState;
                break;
              default:
                throw "unrecognized syncing method";
            }
            this._msg_buffer_callbacks = callbacks;
          } else {
            const msgId = this.send_sync_message(attrs, callbacks);
            this.rememberLastUpdateFor(msgId);
          }
        }
      }
      rememberLastUpdateFor(msgId) {
        this._attrsToUpdate.forEach((attrName) => {
          this._expectedEchoMsgIds.set(attrName, msgId);
        });
        this._attrsToUpdate = /* @__PURE__ */ new Set();
      }
      /**
       * Serialize widget state.
       *
       * A serializer is a function which takes in a state attribute and a widget,
       * and synchronously returns a JSONable object. The returned object will
       * have toJSON called if possible, and the final result should be a
       * primitive object that is a snapshot of the widget state that may have
       * binary array buffers.
       */
      serialize(state) {
        const serializers = this.constructor.serializers || import_coreutils17.JSONExt.emptyObject;
        for (const k of Object.keys(state)) {
          try {
            if (serializers[k] && serializers[k].serialize) {
              state[k] = serializers[k].serialize(state[k], this);
            } else {
              state[k] = JSON.parse(JSON.stringify(state[k]));
            }
            if (state[k] && state[k].toJSON) {
              state[k] = state[k].toJSON();
            }
          } catch (e4) {
            console.error("Error serializing widget state attribute: ", k);
            throw e4;
          }
        }
        return state;
      }
      /**
       * Send a sync message to the kernel.
       *
       * If a message is sent successfully, this returns the message ID of that
       * message. Otherwise it returns an empty string
       */
      send_sync_message(state, callbacks = {}) {
        if (!this.comm) {
          return "";
        }
        try {
          callbacks = {
            shell: Object.assign({}, callbacks.shell),
            iopub: Object.assign({}, callbacks.iopub),
            input: callbacks.input
          };
          const statuscb = callbacks.iopub.status;
          callbacks.iopub.status = (msg) => {
            this._handle_status(msg);
            if (statuscb) {
              statuscb(msg);
            }
          };
          const split = remove_buffers(state);
          const msgId = this.comm.send({
            method: "update",
            state: split.state,
            buffer_paths: split.buffer_paths
          }, callbacks, {}, split.buffers);
          this._pending_msgs++;
          return msgId;
        } catch (e4) {
          console.error("Could not send widget sync message", e4);
        }
        return "";
      }
      /**
       * Push this model's state to the back-end
       *
       * This invokes a Backbone.Sync.
       */
      save_changes(callbacks) {
        if (this.comm_live) {
          const options = { patch: true };
          if (callbacks) {
            options.callbacks = callbacks;
          }
          this.save(this._buffered_state_diff, options);
          if (this._changing) {
            assign(this._buffered_state_diff_synced, this._buffered_state_diff);
          }
          this._buffered_state_diff = {};
        }
      }
      /**
       * on_some_change(['key1', 'key2'], foo, context) differs from
       * on('change:key1 change:key2', foo, context).
       * If the widget attributes key1 and key2 are both modified,
       * the second form will result in foo being called twice
       * while the first will call foo only once.
       */
      on_some_change(keys2, callback, context) {
        this.on("change", (...args) => {
          if (keys2.some(this.hasChanged, this)) {
            callback.apply(context, args);
          }
        }, this);
      }
      /**
       * Serialize the model.  See the deserialization function at the top of this file
       * and the kernel-side serializer/deserializer.
       */
      toJSON(options) {
        return `IPY_MODEL_${this.model_id}`;
      }
      /**
       * Returns a promise for the deserialized state. The second argument
       * is an instance of widget manager, which is required for the
       * deserialization of widget models.
       */
      static _deserialize_state(state, manager) {
        const serializers = this.serializers;
        let deserialized;
        if (serializers) {
          deserialized = {};
          for (const k in state) {
            if (serializers[k] && serializers[k].deserialize) {
              deserialized[k] = serializers[k].deserialize(state[k], manager);
            } else {
              deserialized[k] = state[k];
            }
          }
        } else {
          deserialized = state;
        }
        return resolvePromisesDict(deserialized);
      }
    };
    DOMWidgetModel = class extends WidgetModel {
      defaults() {
        return assign(super.defaults(), {
          _dom_classes: [],
          tabbable: null,
          tooltip: null
          // We do not declare defaults for the layout and style attributes.
          // Those defaults are constructed on the kernel side and synced here
          // as needed, and our code here copes with those attributes being
          // undefined. See
          // https://github.com/jupyter-widgets/ipywidgets/issues/1620 and
          // https://github.com/jupyter-widgets/ipywidgets/pull/1621
        });
      }
    };
    DOMWidgetModel.serializers = Object.assign(Object.assign({}, WidgetModel.serializers), { layout: { deserialize: unpack_models }, style: { deserialize: unpack_models } });
    WidgetView = class extends NativeView {
      /**
       * Public constructor.
       */
      constructor(options) {
        super(options);
      }
      /**
       * Initializer, called at the end of the constructor.
       */
      initialize(parameters) {
        this.listenTo(this.model, "change", (model, options) => {
          const changed = Object.keys(this.model.changedAttributes() || {});
          if (changed[0] === "_view_count" && changed.length === 1) {
            return;
          }
          this.update(options);
        });
        this.options = parameters.options;
        this.once("remove", () => {
          if (typeof this.model.get("_view_count") === "number") {
            this.model.set("_view_count", this.model.get("_view_count") - 1);
            this.model.save_changes();
          }
        });
        this.once("displayed", () => {
          if (typeof this.model.get("_view_count") === "number") {
            this.model.set("_view_count", this.model.get("_view_count") + 1);
            this.model.save_changes();
          }
        });
        this.displayed = new Promise((resolve, reject4) => {
          this.once("displayed", resolve);
          this.model.on("msg:custom", this.handle_message.bind(this));
        });
      }
      /**
       * Handle message sent to the front end.
       *
       * Used to focus or blur the widget.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.el.focus();
        } else if (content.do === "blur") {
          this.el.blur();
        }
      }
      /**
       * Triggered on model change.
       *
       * Update view to be consistent with this.model
       */
      update(options) {
        return;
      }
      /**
       * Render a view
       *
       * @returns the view or a promise to the view.
       */
      render() {
        return;
      }
      create_child_view(child_model, options = {}) {
        options = Object.assign({ parent: this }, options);
        return this.model.widget_manager.create_view(child_model, options).catch(reject("Could not create child view", true));
      }
      /**
       * Create msg callbacks for a comm msg.
       */
      callbacks() {
        return this.model.callbacks(this);
      }
      /**
       * Send a custom msg associated with this view.
       */
      send(content, buffers) {
        this.model.send(content, this.callbacks(), buffers);
      }
      touch() {
        this.model.save_changes(this.callbacks());
      }
      remove() {
        super.remove();
        this.trigger("remove");
        return this;
      }
    };
    JupyterLuminoWidget = class extends Widget {
      constructor(options) {
        const view = options.view;
        delete options.view;
        super(options);
        this._view = view;
      }
      /**
       * Dispose the widget.
       *
       * This causes the view to be destroyed as well with 'remove'
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._view.remove();
        this._view = null;
      }
      /**
       * Process the Lumino message.
       *
       * Any custom Lumino widget used inside a Jupyter widget should override
       * the processMessage function like this.
       */
      processMessage(msg) {
        super.processMessage(msg);
        this._view.processLuminoMessage(msg);
      }
    };
    JupyterPhosphorWidget = JupyterLuminoWidget;
    JupyterLuminoPanelWidget = class extends Panel {
      constructor(options) {
        const view = options.view;
        delete options.view;
        super(options);
        this._view = view;
      }
      /**
       * Process the Lumino message.
       *
       * Any custom Lumino widget used inside a Jupyter widget should override
       * the processMessage function like this.
       */
      processMessage(msg) {
        super.processMessage(msg);
        this._view.processLuminoMessage(msg);
      }
      /**
       * Dispose the widget.
       *
       * This causes the view to be destroyed as well with 'remove'
       */
      dispose() {
        var _a;
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        (_a = this._view) === null || _a === void 0 ? void 0 : _a.remove();
        this._view = null;
      }
    };
    DOMWidgetView = class extends WidgetView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.listenTo(this.model, "change:_dom_classes", (model, new_classes) => {
          const old_classes = model.previous("_dom_classes");
          this.update_classes(old_classes, new_classes);
        });
        this.layoutPromise = Promise.resolve();
        this.listenTo(this.model, "change:layout", (model, value) => {
          this.setLayout(value, model.previous("layout"));
        });
        this.stylePromise = Promise.resolve();
        this.listenTo(this.model, "change:style", (model, value) => {
          this.setStyle(value, model.previous("style"));
        });
        this.displayed.then(() => {
          this.update_classes([], this.model.get("_dom_classes"));
          this.setLayout(this.model.get("layout"));
          this.setStyle(this.model.get("style"));
        });
        this._comm_live_update();
        this.listenTo(this.model, "comm_live_update", () => {
          this._comm_live_update();
        });
        this.listenTo(this.model, "change:tooltip", this.updateTooltip);
        this.updateTooltip();
      }
      setLayout(layout, oldLayout) {
        if (layout) {
          this.layoutPromise = this.layoutPromise.then((oldLayoutView) => {
            if (oldLayoutView) {
              oldLayoutView.unlayout();
              this.stopListening(oldLayoutView.model);
              oldLayoutView.remove();
            }
            return this.create_child_view(layout).then((view) => {
              return this.displayed.then(() => {
                view.trigger("displayed");
                this.listenTo(view.model, "change", () => {
                  MessageLoop.postMessage(this.luminoWidget, Widget.ResizeMessage.UnknownSize);
                });
                MessageLoop.postMessage(this.luminoWidget, Widget.ResizeMessage.UnknownSize);
                this.trigger("layout-changed");
                return view;
              });
            }).catch(reject("Could not add LayoutView to DOMWidgetView", true));
          });
        }
      }
      setStyle(style, oldStyle) {
        if (style) {
          this.stylePromise = this.stylePromise.then((oldStyleView) => {
            if (oldStyleView) {
              oldStyleView.unstyle();
              this.stopListening(oldStyleView.model);
              oldStyleView.remove();
            }
            return this.create_child_view(style).then((view) => {
              return this.displayed.then(() => {
                view.trigger("displayed");
                this.trigger("style-changed");
                return view;
              });
            }).catch(reject("Could not add styleView to DOMWidgetView", true));
          });
        }
      }
      updateTooltip() {
        const title = this.model.get("tooltip");
        if (!title) {
          this.el.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.el.setAttribute("title", title);
        }
      }
      /**
       * Update the DOM classes applied to an element, default to this.el.
       */
      update_classes(old_classes, new_classes, el) {
        if (el === void 0) {
          el = this.el;
        }
        difference(old_classes, new_classes).map(function(c6) {
          if (el.classList) {
            el.classList.remove(c6);
          } else {
            el.setAttribute("class", el.getAttribute("class").replace(c6, ""));
          }
        });
        difference(new_classes, old_classes).map(function(c6) {
          if (el.classList) {
            el.classList.add(c6);
          } else {
            el.setAttribute("class", el.getAttribute("class").concat(" ", c6));
          }
        });
      }
      /**
       * Update the DOM classes applied to the widget based on a single
       * trait's value.
       *
       * Given a trait value classes map, this function automatically
       * handles applying the appropriate classes to the widget element
       * and removing classes that are no longer valid.
       *
       * Parameters
       * ----------
       * class_map: dictionary
       *  Dictionary of trait values to class lists.
       *  Example:
       *      {
       *          success: ['alert', 'alert-success'],
       *          info: ['alert', 'alert-info'],
       *          warning: ['alert', 'alert-warning'],
       *          danger: ['alert', 'alert-danger']
       *      };
       * trait_name: string
       *  Name of the trait to check the value of.
       * el: optional DOM element handle, defaults to this.el
       *  Element that the classes are applied to.
       */
      update_mapped_classes(class_map, trait_name, el) {
        let key = this.model.previous(trait_name);
        const old_classes = class_map[key] ? class_map[key] : [];
        key = this.model.get(trait_name);
        const new_classes = class_map[key] ? class_map[key] : [];
        this.update_classes(old_classes, new_classes, el || this.el);
      }
      set_mapped_classes(class_map, trait_name, el) {
        const key = this.model.get(trait_name);
        const new_classes = class_map[key] ? class_map[key] : [];
        this.update_classes([], new_classes, el || this.el);
      }
      _setElement(el) {
        if (this.luminoWidget) {
          this.luminoWidget.dispose();
        }
        this.$el = el instanceof import_jquery.default ? el : (0, import_jquery.default)(el);
        this.el = this.$el[0];
        this.luminoWidget = new JupyterLuminoWidget({
          node: el,
          view: this
        });
      }
      remove() {
        if (this.luminoWidget) {
          this.luminoWidget.dispose();
        }
        return super.remove();
      }
      processLuminoMessage(msg) {
        switch (msg.type) {
          case "after-attach":
            this.trigger("displayed");
            break;
          case "show":
            this.trigger("shown");
            break;
        }
      }
      _comm_live_update() {
        if (this.model.comm_live) {
          this.luminoWidget.removeClass("jupyter-widgets-disconnected");
        } else {
          this.luminoWidget.addClass("jupyter-widgets-disconnected");
        }
      }
      updateTabindex() {
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.el.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.el.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.el.removeAttribute("tabIndex");
        }
      }
      /**
       * @deprecated Use {@link luminoWidget} instead (Since 8.0).
       */
      get pWidget() {
        return this.luminoWidget;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/manager.js
var init_manager = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/manager.js"() {
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/widget_layout.js
var css_properties, LayoutModel, LayoutView;
var init_widget_layout = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/widget_layout.js"() {
    init_utils();
    init_widget2();
    css_properties = {
      align_content: null,
      align_items: null,
      align_self: null,
      border_top: null,
      border_right: null,
      border_bottom: null,
      border_left: null,
      bottom: null,
      display: null,
      flex: null,
      flex_flow: null,
      height: null,
      justify_content: null,
      justify_items: null,
      left: null,
      margin: null,
      max_height: null,
      max_width: null,
      min_height: null,
      min_width: null,
      overflow: null,
      order: null,
      padding: null,
      right: null,
      top: null,
      visibility: null,
      width: null,
      // image-specific
      object_fit: null,
      object_position: null,
      // container
      grid_auto_columns: null,
      grid_auto_flow: null,
      grid_auto_rows: null,
      grid_gap: null,
      grid_template_rows: null,
      grid_template_columns: null,
      grid_template_areas: null,
      // items
      grid_row: null,
      grid_column: null,
      grid_area: null
    };
    LayoutModel = class extends WidgetModel {
      defaults() {
        return assign(super.defaults(), {
          _model_name: "LayoutModel",
          _view_name: "LayoutView"
        }, css_properties);
      }
    };
    LayoutView = class extends WidgetView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        this._traitNames = [];
        super.initialize(parameters);
        for (const key of Object.keys(css_properties)) {
          this.registerTrait(key);
        }
      }
      /**
       * Register a CSS trait that is known by the model
       * @param trait
       */
      registerTrait(trait) {
        this._traitNames.push(trait);
        this.listenTo(this.model, "change:" + trait, (model, value) => {
          this.handleChange(trait, value);
        });
        this.handleChange(trait, this.model.get(trait));
      }
      /**
       * Get the the name of the css property from the trait name
       * @param  model attribute name
       * @return css property name
       */
      css_name(trait) {
        return trait.replace(/_/g, "-");
      }
      /**
       * Handles when a trait value changes
       */
      handleChange(trait, value) {
        const parent = this.options.parent;
        if (parent) {
          if (value === null) {
            parent.el.style.removeProperty(this.css_name(trait));
          } else {
            parent.el.style.setProperty(this.css_name(trait), value);
          }
        } else {
          console.warn("Style not applied because a parent view does not exist");
        }
      }
      /**
       * Remove the styling from the parent view.
       */
      unlayout() {
        const parent = this.options.parent;
        this._traitNames.forEach((trait) => {
          if (parent) {
            parent.el.style.removeProperty(this.css_name(trait));
          } else {
            console.warn("Style not removed because a parent view does not exist");
          }
        }, this);
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/widget_style.js
var StyleModel, StyleView;
var init_widget_style = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/widget_style.js"() {
    init_utils();
    init_widget2();
    StyleModel = class extends WidgetModel {
      defaults() {
        const Derived = this.constructor;
        return assign(super.defaults(), {
          _model_name: "StyleModel",
          _view_name: "StyleView"
        }, Object.keys(Derived.styleProperties).reduce((obj, key) => {
          obj[key] = Derived.styleProperties[key].default;
          return obj;
        }, {}));
      }
    };
    StyleModel.styleProperties = {};
    StyleView = class extends WidgetView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        this._traitNames = [];
        super.initialize(parameters);
        const ModelType = this.model.constructor;
        for (const key of Object.keys(ModelType.styleProperties)) {
          this.registerTrait(key);
        }
        this.style();
      }
      /**
       * Register a CSS trait that is known by the model
       * @param trait
       */
      registerTrait(trait) {
        this._traitNames.push(trait);
        this.listenTo(this.model, "change:" + trait, (model, value) => {
          this.handleChange(trait, value);
        });
      }
      /**
       * Handles when a trait value changes
       */
      handleChange(trait, value) {
        const parent = this.options.parent;
        if (parent) {
          const ModelType = this.model.constructor;
          const styleProperties = ModelType.styleProperties;
          const attribute = styleProperties[trait].attribute;
          const selector = styleProperties[trait].selector;
          const elements = selector ? parent.el.querySelectorAll(selector) : [parent.el];
          if (value === null) {
            for (let i5 = 0; i5 !== elements.length; ++i5) {
              elements[i5].style.removeProperty(attribute);
            }
          } else {
            for (let i5 = 0; i5 !== elements.length; ++i5) {
              elements[i5].style.setProperty(attribute, value);
            }
          }
        } else {
          console.warn("Style not applied because a parent view does not exist");
        }
      }
      /**
       * Apply styles for all registered traits
       */
      style() {
        for (const trait of this._traitNames) {
          this.handleChange(trait, this.model.get(trait));
        }
      }
      /**
       * Remove the styling from the parent view.
       */
      unstyle() {
        const parent = this.options.parent;
        const ModelType = this.model.constructor;
        const styleProperties = ModelType.styleProperties;
        this._traitNames.forEach((trait) => {
          if (parent) {
            const attribute = styleProperties[trait].attribute;
            const selector = styleProperties[trait].selector;
            const elements = selector ? parent.el.querySelectorAll(selector) : [parent.el];
            for (let i5 = 0; i5 !== elements.length; ++i5) {
              elements[i5].style.removeProperty(attribute);
            }
          } else {
            console.warn("Style not removed because a parent view does not exist");
          }
        }, this);
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/services-shim.js
var shims;
var init_services_shim = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/services-shim.js"() {
    (function(shims2) {
      let services;
      (function(services2) {
        class CommManager {
          constructor(jsServicesKernel) {
            this.targets = /* @__PURE__ */ Object.create(null);
            this.comms = /* @__PURE__ */ Object.create(null);
            this.init_kernel(jsServicesKernel);
          }
          /**
           * Hookup kernel events.
           * @param  {Kernel.IKernel} jsServicesKernel - @jupyterlab/services Kernel.IKernel instance
           */
          init_kernel(jsServicesKernel) {
            this.kernel = jsServicesKernel;
            this.jsServicesKernel = jsServicesKernel;
          }
          /**
           * Creates a new connected comm
           */
          async new_comm(target_name, data, callbacks, metadata, comm_id, buffers) {
            const c6 = this.jsServicesKernel.createComm(target_name, comm_id);
            const comm = new Comm(c6);
            this.register_comm(comm);
            comm.open(data, callbacks, metadata, buffers);
            return comm;
          }
          /**
           * Register a comm target
           * @param  {string} target_name
           * @param  {(Comm, object) => void} f - callback that is called when the
           *                         comm is made.  Signature of f(comm, msg).
           */
          register_target(target_name, f6) {
            const handle = this.jsServicesKernel.registerCommTarget(target_name, (jsServicesComm, msg) => {
              const comm = new Comm(jsServicesComm);
              this.register_comm(comm);
              try {
                return f6(comm, msg);
              } catch (e4) {
                comm.close();
                console.error(e4);
                console.error(new Error("Exception opening new comm"));
              }
            });
            this.targets[target_name] = handle;
          }
          /**
           * Unregisters a comm target
           * @param  {string} target_name
           */
          unregister_target(target_name, f6) {
            const handle = this.targets[target_name];
            handle.dispose();
            delete this.targets[target_name];
          }
          /**
           * Register a comm in the mapping
           */
          register_comm(comm) {
            this.comms[comm.comm_id] = Promise.resolve(comm);
            comm.kernel = this.kernel;
            return comm.comm_id;
          }
        }
        services2.CommManager = CommManager;
        class Comm {
          constructor(jsServicesComm) {
            this.jsServicesComm = jsServicesComm;
          }
          /**
           * Comm id
           * @return {string}
           */
          get comm_id() {
            return this.jsServicesComm.commId;
          }
          /**
           * Target name
           * @return {string}
           */
          get target_name() {
            return this.jsServicesComm.targetName;
          }
          /**
           * Opens a sibling comm in the backend
           * @param  data
           * @param  callbacks
           * @param  metadata
           * @return msg id
           */
          open(data, callbacks, metadata, buffers) {
            const future = this.jsServicesComm.open(data, metadata, buffers);
            this._hookupCallbacks(future, callbacks);
            return future.msg.header.msg_id;
          }
          /**
           * Sends a message to the sibling comm in the backend
           * @param  data
           * @param  callbacks
           * @param  metadata
           * @param  buffers
           * @return message id
           */
          send(data, callbacks, metadata, buffers) {
            const future = this.jsServicesComm.send(data, metadata, buffers);
            this._hookupCallbacks(future, callbacks);
            return future.msg.header.msg_id;
          }
          /**
           * Closes the sibling comm in the backend
           * @param  data
           * @param  callbacks
           * @param  metadata
           * @return msg id
           */
          close(data, callbacks, metadata, buffers) {
            const future = this.jsServicesComm.close(data, metadata, buffers);
            this._hookupCallbacks(future, callbacks);
            return future.msg.header.msg_id;
          }
          /**
           * Register a message handler
           * @param  callback, which is given a message
           */
          on_msg(callback) {
            this.jsServicesComm.onMsg = callback.bind(this);
          }
          /**
           * Register a handler for when the comm is closed by the backend
           * @param  callback, which is given a message
           */
          on_close(callback) {
            this.jsServicesComm.onClose = callback.bind(this);
          }
          /**
           * Hooks callback object up with @jupyterlab/services IKernelFuture
           * @param  @jupyterlab/services IKernelFuture instance
           * @param  callbacks
           */
          _hookupCallbacks(future, callbacks) {
            if (callbacks) {
              future.onReply = function(msg) {
                if (callbacks.shell && callbacks.shell.reply) {
                  callbacks.shell.reply(msg);
                }
              };
              future.onStdin = function(msg) {
                if (callbacks.input) {
                  callbacks.input(msg);
                }
              };
              future.onIOPub = function(msg) {
                if (callbacks.iopub) {
                  if (callbacks.iopub.status && msg.header.msg_type === "status") {
                    callbacks.iopub.status(msg);
                  } else if (callbacks.iopub.clear_output && msg.header.msg_type === "clear_output") {
                    callbacks.iopub.clear_output(msg);
                  } else if (callbacks.iopub.output) {
                    switch (msg.header.msg_type) {
                      case "display_data":
                      case "execute_result":
                      case "stream":
                      case "error":
                        callbacks.iopub.output(msg);
                        break;
                      default:
                        break;
                    }
                  }
                }
              };
            }
          }
        }
        services2.Comm = Comm;
      })(services = shims2.services || (shims2.services = {}));
    })(shims || (shims = {}));
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/viewlist.js
var ViewList;
var init_viewlist = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/viewlist.js"() {
    ViewList = class {
      constructor(create_view, remove_view, context) {
        this.initialize(create_view, remove_view, context);
      }
      initialize(create_view, remove_view, context) {
        this._handler_context = context || this;
        this._models = [];
        this.views = [];
        this._create_view = create_view;
        this._remove_view = remove_view || function(view) {
          view.remove();
        };
      }
      /**
       * the create_view, remove_view, and context arguments override the defaults
       * specified when the list is created.
       * after this function, the .views attribute is a list of promises for views
       * if you want to perform some action on the list of views, do something like
       * `Promise.all(myviewlist.views).then(function(views) {...});`
       */
      update(new_models, create_view, remove_view, context) {
        const remove2 = remove_view || this._remove_view;
        const create2 = create_view || this._create_view;
        context = context || this._handler_context;
        let i5 = 0;
        for (; i5 < new_models.length; i5++) {
          if (i5 >= this._models.length || new_models[i5] !== this._models[i5]) {
            break;
          }
        }
        const first_removed = i5;
        const removed = this.views.splice(first_removed, this.views.length - first_removed);
        for (let j2 = 0; j2 < removed.length; j2++) {
          removed[j2].then(function(view) {
            remove2.call(context, view);
          });
        }
        for (; i5 < new_models.length; i5++) {
          this.views.push(Promise.resolve(create2.call(context, new_models[i5], i5)));
        }
        this._models = new_models.slice();
        return Promise.all(this.views);
      }
      /**
       * removes every view in the list; convenience function for `.update([])`
       * that should be faster
       * returns a promise that resolves after this removal is done
       */
      remove() {
        return Promise.all(this.views).then((views) => {
          views.forEach((value) => this._remove_view.call(this._handler_context, value));
          this.views = [];
          this._models = [];
        });
      }
      /**
       * Dispose this viewlist.
       *
       * A synchronous function which just deletes references to child views. This
       * function does not call .remove() on child views because that is
       * asynchronous. Use this in cases where child views will be removed in
       * another way.
       */
      dispose() {
        this.views = null;
        this._models = null;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/registry.js
var import_coreutils18, IJupyterWidgetRegistry;
var init_registry2 = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/registry.js"() {
    import_coreutils18 = __toESM(require_dist());
    IJupyterWidgetRegistry = new import_coreutils18.Token("jupyter.extensions.jupyterWidgetRegistry");
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/errorwidget.js
function createErrorWidgetModel(error, msg) {
  class ErrorWidget extends DOMWidgetModel {
    constructor(attributes, options) {
      attributes = Object.assign(Object.assign({}, attributes), { _view_name: "ErrorWidgetView", _view_module: "@jupyter-widgets/base", _model_module_version: JUPYTER_WIDGETS_VERSION, _view_module_version: JUPYTER_WIDGETS_VERSION, msg, error });
      super(attributes, options);
      this.comm_live = true;
    }
  }
  return ErrorWidget;
}
function createErrorWidgetView(error, msg) {
  return class InnerErrorWidgetView extends ErrorWidgetView {
    generateErrorMessage() {
      return {
        msg,
        stack: String(error instanceof Error ? error.stack : error)
      };
    }
  };
}
var ErrorWidgetView;
var init_errorwidget = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/errorwidget.js"() {
    init_widget2();
    init_version();
    init_utils();
    ErrorWidgetView = class extends DOMWidgetView {
      generateErrorMessage() {
        return {
          msg: this.model.get("msg"),
          stack: String(this.model.get("error").stack)
        };
      }
      render() {
        const { msg, stack } = this.generateErrorMessage();
        this.el.classList.add("jupyter-widgets");
        const content = document.createElement("div");
        content.classList.add("jupyter-widgets-error-widget", "icon-error");
        content.innerHTML = BROKEN_FILE_SVG_ICON;
        const text = document.createElement("pre");
        text.style.textAlign = "center";
        text.innerText = "Click to show javascript error.";
        content.append(text);
        this.el.appendChild(content);
        let width;
        let height;
        this.el.onclick = () => {
          if (content.classList.contains("icon-error")) {
            height = height || content.clientHeight;
            width = width || content.clientWidth;
            content.classList.remove("icon-error");
            content.innerHTML = `
        <pre>[Open Browser Console for more detailed log - Double click to close this message]
${msg}
${stack}</pre>
        `;
            content.style.height = `${height}px`;
            content.style.width = `${width}px`;
            content.classList.add("text-error");
          }
        };
        this.el.ondblclick = () => {
          if (content.classList.contains("text-error")) {
            content.classList.remove("text-error");
            content.innerHTML = BROKEN_FILE_SVG_ICON;
            content.append(text);
            content.classList.add("icon-error");
          }
        };
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/index.js
var lib_exports3 = {};
__export(lib_exports3, {
  BROKEN_FILE_SVG_ICON: () => BROKEN_FILE_SVG_ICON,
  DOMWidgetModel: () => DOMWidgetModel,
  DOMWidgetView: () => DOMWidgetView,
  ErrorWidgetView: () => ErrorWidgetView,
  IJupyterWidgetRegistry: () => IJupyterWidgetRegistry,
  JUPYTER_WIDGETS_VERSION: () => JUPYTER_WIDGETS_VERSION,
  JupyterLuminoPanelWidget: () => JupyterLuminoPanelWidget,
  JupyterLuminoWidget: () => JupyterLuminoWidget,
  JupyterPhosphorWidget: () => JupyterPhosphorWidget,
  LayoutModel: () => LayoutModel,
  LayoutView: () => LayoutView,
  PROTOCOL_VERSION: () => PROTOCOL_VERSION,
  StyleModel: () => StyleModel,
  StyleView: () => StyleView,
  ViewList: () => ViewList,
  WidgetModel: () => WidgetModel,
  WidgetView: () => WidgetView,
  assign: () => assign,
  createErrorWidgetModel: () => createErrorWidgetModel,
  createErrorWidgetView: () => createErrorWidgetView,
  difference: () => difference,
  isEqual: () => isEqual,
  isObject: () => isObject,
  isSerializable: () => isSerializable,
  pack_models: () => pack_models,
  put_buffers: () => put_buffers,
  reject: () => reject,
  remove_buffers: () => remove_buffers,
  resolvePromisesDict: () => resolvePromisesDict,
  shims: () => shims,
  unpack_models: () => unpack_models,
  uuid: () => uuid
});
var init_lib10 = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/index.js"() {
    init_widget2();
    init_manager();
    init_widget_layout();
    init_widget_style();
    init_services_shim();
    init_viewlist();
    init_version();
    init_utils();
    init_registry2();
    init_errorwidget();
  }
});

// ../../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray2;
    exports2.fromByteArray = fromByteArray2;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i5 = 0, len = code3.length; i5 < len; ++i5) {
      lookup[i5] = code3[i5];
      revLookup[code3.charCodeAt(i5)] = i5;
    }
    var i5;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray2(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i6;
      for (i6 = 0; i6 < len2; i6 += 4) {
        tmp = revLookup[b64.charCodeAt(i6)] << 18 | revLookup[b64.charCodeAt(i6 + 1)] << 12 | revLookup[b64.charCodeAt(i6 + 2)] << 6 | revLookup[b64.charCodeAt(i6 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i6)] << 2 | revLookup[b64.charCodeAt(i6 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i6)] << 10 | revLookup[b64.charCodeAt(i6 + 1)] << 4 | revLookup[b64.charCodeAt(i6 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i6 = start; i6 < end; i6 += 3) {
        tmp = (uint8[i6] << 16 & 16711680) + (uint8[i6 + 1] << 8 & 65280) + (uint8[i6 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i6 = 0, len22 = len2 - extraBytes; i6 < len22; i6 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i6, i6 + maxChunkLength > len22 ? len22 : i6 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/@jupyter-widgets/base-manager/lib/utils.js
function hexToBuffer(hex) {
  const x4 = new Uint8Array(hex.length / 2);
  for (let i5 = 0; i5 < hex.length; i5 += 2) {
    x4[i5 / 2] = parseInt(hex.slice(i5, i5 + 2), 16);
  }
  return x4.buffer;
}
function bufferToBase64(buffer) {
  return (0, import_base64_js.fromByteArray)(new Uint8Array(buffer));
}
function base64ToBuffer(base64) {
  return (0, import_base64_js.toByteArray)(base64).buffer;
}
var import_base64_js;
var init_utils2 = __esm({
  "../../node_modules/@jupyter-widgets/base-manager/lib/utils.js"() {
    import_base64_js = __toESM(require_base64_js());
  }
});

// ../../node_modules/@jupyter-widgets/base-manager/lib/latex.js
function removeMath2(text) {
  const math = [];
  let start = null;
  let end = null;
  let last2 = null;
  let braces = 0;
  let deTilde;
  const hasCodeSpans = /`/.test(text);
  if (hasCodeSpans) {
    text = text.replace(/~/g, "~T").replace(/(^|[^\\])(`+)([^\n]*?[^`\n])\2(?!`)/gm, (wholematch) => wholematch.replace(/\$/g, "~D"));
    deTilde = (text2) => {
      return text2.replace(/~([TD])/g, (wholematch, character) => character === "T" ? "~" : inline3);
    };
  } else {
    deTilde = (text2) => {
      return text2;
    };
  }
  let blocks = text.replace(/\r\n?/g, "\n").split(MATHSPLIT2);
  for (let i5 = 1, m4 = blocks.length; i5 < m4; i5 += 2) {
    const block = blocks[i5];
    if (block.charAt(0) === "@") {
      blocks[i5] = "@@" + math.length + "@@";
      math.push(block);
    } else if (start !== null) {
      if (block === end) {
        if (braces) {
          last2 = i5;
        } else {
          blocks = processMath2(start, i5, deTilde, math, blocks);
          start = null;
          end = null;
          last2 = null;
        }
      } else if (block.match(/\n.*\n/)) {
        if (last2 !== null) {
          i5 = last2;
          blocks = processMath2(start, i5, deTilde, math, blocks);
        }
        start = null;
        end = null;
        last2 = null;
        braces = 0;
      } else if (block === "{") {
        braces++;
      } else if (block === "}" && braces) {
        braces--;
      }
    } else {
      if (block === inline3 || block === "$$") {
        start = i5;
        end = block;
        braces = 0;
      } else if (block === "\\\\(" || block === "\\\\[") {
        start = i5;
        end = block.slice(-1) === "(" ? "\\\\)" : "\\\\]";
        braces = 0;
      } else if (block.substr(1, 5) === "begin") {
        start = i5;
        end = "\\end" + block.substr(6);
        braces = 0;
      }
    }
  }
  if (start !== null && last2 !== null) {
    blocks = processMath2(start, last2, deTilde, math, blocks);
    start = null;
    end = null;
    last2 = null;
  }
  return { text: deTilde(blocks.join("")), math };
}
function replaceMath2(text, math) {
  const process2 = (match, n4) => {
    let group2 = math[n4];
    if (group2.substr(0, 3) === "\\\\(" && group2.substr(group2.length - 3) === "\\\\)") {
      group2 = "\\(" + group2.substring(3, group2.length - 3) + "\\)";
    } else if (group2.substr(0, 3) === "\\\\[" && group2.substr(group2.length - 3) === "\\\\]") {
      group2 = "\\[" + group2.substring(3, group2.length - 3) + "\\]";
    }
    return group2;
  };
  return text.replace(/@@(\d+)@@/g, process2);
}
function processMath2(i5, j2, preProcess, math, blocks) {
  let block = blocks.slice(i5, j2 + 1).join("").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  if (navigator && navigator.appName === "Microsoft Internet Explorer") {
    block = block.replace(/(%[^\n]*)\n/g, "$1<br/>\n");
  }
  while (j2 > i5) {
    blocks[j2] = "";
    j2--;
  }
  blocks[i5] = "@@" + math.length + "@@";
  if (preProcess) {
    block = preProcess(block);
  }
  math.push(block);
  return blocks;
}
var inline3, MATHSPLIT2;
var init_latex2 = __esm({
  "../../node_modules/@jupyter-widgets/base-manager/lib/latex.js"() {
    inline3 = "$";
    MATHSPLIT2 = /(\$\$?|\\(?:begin|end)\{[a-z]*\*?\}|\\[{}$]|[{}]|(?:\n\s*)+|@@\d+@@|\\\\(?:\(|\)|\[|\]))/i;
  }
});

// ../../node_modules/htmlparser2/node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS({
  "../../node_modules/htmlparser2/node_modules/entities/lib/generated/decode-data-html.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = new Uint16Array(
      // prettier-ignore
      '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c6) {
        return c6.charCodeAt(0);
      })
    );
  }
});

// ../../node_modules/htmlparser2/node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS({
  "../../node_modules/htmlparser2/node_modules/entities/lib/generated/decode-data-xml.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = new Uint16Array(
      // prettier-ignore
      "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c6) {
        return c6.charCodeAt(0);
      })
    );
  }
});

// ../../node_modules/htmlparser2/node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "../../node_modules/htmlparser2/node_modules/entities/lib/decode_codepoint.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
    var decodeMap = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function replaceCodePoint(codePoint) {
      var _a2;
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return 65533;
      }
      return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
    }
    exports2.replaceCodePoint = replaceCodePoint;
    function decodeCodePoint(codePoint) {
      return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
    }
    exports2.default = decodeCodePoint;
  }
});

// ../../node_modules/htmlparser2/node_modules/entities/lib/decode.js
var require_decode = __commonJS({
  "../../node_modules/htmlparser2/node_modules/entities/lib/decode.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
    var decode_data_html_js_1 = __importDefault2(require_decode_data_html());
    exports2.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault2(require_decode_data_xml());
    exports2.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
    exports2.decodeCodePoint = decode_codepoint_js_1.default;
    var decode_codepoint_js_2 = require_decode_codepoint();
    Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.replaceCodePoint;
    } });
    Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.fromCodePoint;
    } });
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
      CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
      CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
      CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
      CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
      CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
      CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
      CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
      CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
      CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
      CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
    })(CharCodes || (CharCodes = {}));
    var TO_LOWER_BIT = 32;
    var BinTrieFlags;
    (function(BinTrieFlags2) {
      BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
    function isNumber(code3) {
      return code3 >= CharCodes.ZERO && code3 <= CharCodes.NINE;
    }
    function isHexadecimalCharacter(code3) {
      return code3 >= CharCodes.UPPER_A && code3 <= CharCodes.UPPER_F || code3 >= CharCodes.LOWER_A && code3 <= CharCodes.LOWER_F;
    }
    function isAsciiAlphaNumeric(code3) {
      return code3 >= CharCodes.UPPER_A && code3 <= CharCodes.UPPER_Z || code3 >= CharCodes.LOWER_A && code3 <= CharCodes.LOWER_Z || isNumber(code3);
    }
    function isEntityInAttributeInvalidEnd(code3) {
      return code3 === CharCodes.EQUALS || isAsciiAlphaNumeric(code3);
    }
    var EntityDecoderState;
    (function(EntityDecoderState2) {
      EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
    })(EntityDecoderState || (EntityDecoderState = {}));
    var DecodingMode;
    (function(DecodingMode2) {
      DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
      DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
      DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
    })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
    var EntityDecoder = (
      /** @class */
      function() {
        function EntityDecoder2(decodeTree, emitCodePoint, errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }
        EntityDecoder2.prototype.startEntity = function(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        };
        EntityDecoder2.prototype.write = function(str2, offset2) {
          switch (this.state) {
            case EntityDecoderState.EntityStart: {
              if (str2.charCodeAt(offset2) === CharCodes.NUM) {
                this.state = EntityDecoderState.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(str2, offset2 + 1);
              }
              this.state = EntityDecoderState.NamedEntity;
              return this.stateNamedEntity(str2, offset2);
            }
            case EntityDecoderState.NumericStart: {
              return this.stateNumericStart(str2, offset2);
            }
            case EntityDecoderState.NumericDecimal: {
              return this.stateNumericDecimal(str2, offset2);
            }
            case EntityDecoderState.NumericHex: {
              return this.stateNumericHex(str2, offset2);
            }
            case EntityDecoderState.NamedEntity: {
              return this.stateNamedEntity(str2, offset2);
            }
          }
        };
        EntityDecoder2.prototype.stateNumericStart = function(str2, offset2) {
          if (offset2 >= str2.length) {
            return -1;
          }
          if ((str2.charCodeAt(offset2) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str2, offset2 + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(str2, offset2);
        };
        EntityDecoder2.prototype.addToNumericResult = function(str2, start, end, base) {
          if (start !== end) {
            var digitCount = end - start;
            this.result = this.result * Math.pow(base, digitCount) + parseInt(str2.substr(start, digitCount), base);
            this.consumed += digitCount;
          }
        };
        EntityDecoder2.prototype.stateNumericHex = function(str2, offset2) {
          var startIdx = offset2;
          while (offset2 < str2.length) {
            var char = str2.charCodeAt(offset2);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
              offset2 += 1;
            } else {
              this.addToNumericResult(str2, startIdx, offset2, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(str2, startIdx, offset2, 16);
          return -1;
        };
        EntityDecoder2.prototype.stateNumericDecimal = function(str2, offset2) {
          var startIdx = offset2;
          while (offset2 < str2.length) {
            var char = str2.charCodeAt(offset2);
            if (isNumber(char)) {
              offset2 += 1;
            } else {
              this.addToNumericResult(str2, startIdx, offset2, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(str2, startIdx, offset2, 10);
          return -1;
        };
        EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
          var _a;
          if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
          }
          this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
          if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        };
        EntityDecoder2.prototype.stateNamedEntity = function(str2, offset2) {
          var decodeTree = this.decodeTree;
          var current = decodeTree[this.treeIndex];
          var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset2 < str2.length; offset2++, this.excess++) {
            var char = str2.charCodeAt(offset2);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
              (valueLength === 0 || // And there should be no invalid characters.
              isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes.SEMI) {
                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
              }
              if (this.decodeMode !== DecodingMode.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        };
        EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
          var _a;
          var _b = this, result2 = _b.result, decodeTree = _b.decodeTree;
          var valueLength = (decodeTree[result2] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result2, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
        };
        EntityDecoder2.prototype.emitNamedEntityData = function(result2, valueLength, consumed) {
          var decodeTree = this.decodeTree;
          this.emitCodePoint(valueLength === 1 ? decodeTree[result2] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result2 + 1], consumed);
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result2 + 2], consumed);
          }
          return consumed;
        };
        EntityDecoder2.prototype.end = function() {
          var _a;
          switch (this.state) {
            case EntityDecoderState.NamedEntity: {
              return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            }
            case EntityDecoderState.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            case EntityDecoderState.EntityStart: {
              return 0;
            }
          }
        };
        return EntityDecoder2;
      }()
    );
    exports2.EntityDecoder = EntityDecoder;
    function getDecoder(decodeTree) {
      var ret = "";
      var decoder = new EntityDecoder(decodeTree, function(str2) {
        return ret += (0, decode_codepoint_js_1.fromCodePoint)(str2);
      });
      return function decodeWithTrie(str2, decodeMode) {
        var lastIndex = 0;
        var offset2 = 0;
        while ((offset2 = str2.indexOf("&", offset2)) >= 0) {
          ret += str2.slice(lastIndex, offset2);
          decoder.startEntity(decodeMode);
          var len = decoder.write(
            str2,
            // Skip the "&"
            offset2 + 1
          );
          if (len < 0) {
            lastIndex = offset2 + decoder.end();
            break;
          }
          lastIndex = offset2 + len;
          offset2 = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result2 = ret + str2.slice(lastIndex);
        ret = "";
        return result2;
      };
    }
    function determineBranch(decodeTree, current, nodeIdx, char) {
      var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
      }
      var lo = nodeIdx;
      var hi = lo + branchCount - 1;
      while (lo <= hi) {
        var mid = lo + hi >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo = mid + 1;
        } else if (midVal > char) {
          hi = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports2.determineBranch = determineBranch;
    var htmlDecoder = getDecoder(decode_data_html_js_1.default);
    var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
    function decodeHTML(str2, mode) {
      if (mode === void 0) {
        mode = DecodingMode.Legacy;
      }
      return htmlDecoder(str2, mode);
    }
    exports2.decodeHTML = decodeHTML;
    function decodeHTMLAttribute(str2) {
      return htmlDecoder(str2, DecodingMode.Attribute);
    }
    exports2.decodeHTMLAttribute = decodeHTMLAttribute;
    function decodeHTMLStrict(str2) {
      return htmlDecoder(str2, DecodingMode.Strict);
    }
    exports2.decodeHTMLStrict = decodeHTMLStrict;
    function decodeXML(str2) {
      return xmlDecoder(str2, DecodingMode.Strict);
    }
    exports2.decodeXML = decodeXML;
  }
});

// ../../node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer = __commonJS({
  "../../node_modules/htmlparser2/lib/Tokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QuoteType = void 0;
    var decode_js_1 = require_decode();
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
      CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
      CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
      CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
      CharCodes2[CharCodes2["Space"] = 32] = "Space";
      CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
      CharCodes2[CharCodes2["Number"] = 35] = "Number";
      CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
      CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
      CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
      CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
      CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
      CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
      CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
      CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
      CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
      CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
      CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
      CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
      CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
      CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
      CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
      CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
      CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
      CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
      CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
      CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
    })(CharCodes || (CharCodes = {}));
    var State2;
    (function(State3) {
      State3[State3["Text"] = 1] = "Text";
      State3[State3["BeforeTagName"] = 2] = "BeforeTagName";
      State3[State3["InTagName"] = 3] = "InTagName";
      State3[State3["InSelfClosingTag"] = 4] = "InSelfClosingTag";
      State3[State3["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
      State3[State3["InClosingTagName"] = 6] = "InClosingTagName";
      State3[State3["AfterClosingTagName"] = 7] = "AfterClosingTagName";
      State3[State3["BeforeAttributeName"] = 8] = "BeforeAttributeName";
      State3[State3["InAttributeName"] = 9] = "InAttributeName";
      State3[State3["AfterAttributeName"] = 10] = "AfterAttributeName";
      State3[State3["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
      State3[State3["InAttributeValueDq"] = 12] = "InAttributeValueDq";
      State3[State3["InAttributeValueSq"] = 13] = "InAttributeValueSq";
      State3[State3["InAttributeValueNq"] = 14] = "InAttributeValueNq";
      State3[State3["BeforeDeclaration"] = 15] = "BeforeDeclaration";
      State3[State3["InDeclaration"] = 16] = "InDeclaration";
      State3[State3["InProcessingInstruction"] = 17] = "InProcessingInstruction";
      State3[State3["BeforeComment"] = 18] = "BeforeComment";
      State3[State3["CDATASequence"] = 19] = "CDATASequence";
      State3[State3["InSpecialComment"] = 20] = "InSpecialComment";
      State3[State3["InCommentLike"] = 21] = "InCommentLike";
      State3[State3["BeforeSpecialS"] = 22] = "BeforeSpecialS";
      State3[State3["SpecialStartSequence"] = 23] = "SpecialStartSequence";
      State3[State3["InSpecialTag"] = 24] = "InSpecialTag";
      State3[State3["BeforeEntity"] = 25] = "BeforeEntity";
      State3[State3["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
      State3[State3["InNamedEntity"] = 27] = "InNamedEntity";
      State3[State3["InNumericEntity"] = 28] = "InNumericEntity";
      State3[State3["InHexEntity"] = 29] = "InHexEntity";
    })(State2 || (State2 = {}));
    function isWhitespace2(c6) {
      return c6 === CharCodes.Space || c6 === CharCodes.NewLine || c6 === CharCodes.Tab || c6 === CharCodes.FormFeed || c6 === CharCodes.CarriageReturn;
    }
    function isEndOfTagSection(c6) {
      return c6 === CharCodes.Slash || c6 === CharCodes.Gt || isWhitespace2(c6);
    }
    function isNumber(c6) {
      return c6 >= CharCodes.Zero && c6 <= CharCodes.Nine;
    }
    function isASCIIAlpha(c6) {
      return c6 >= CharCodes.LowerA && c6 <= CharCodes.LowerZ || c6 >= CharCodes.UpperA && c6 <= CharCodes.UpperZ;
    }
    function isHexDigit(c6) {
      return c6 >= CharCodes.UpperA && c6 <= CharCodes.UpperF || c6 >= CharCodes.LowerA && c6 <= CharCodes.LowerF;
    }
    var QuoteType;
    (function(QuoteType2) {
      QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
      QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
      QuoteType2[QuoteType2["Single"] = 2] = "Single";
      QuoteType2[QuoteType2["Double"] = 3] = "Double";
    })(QuoteType = exports2.QuoteType || (exports2.QuoteType = {}));
    var Sequences = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      CdataEnd: new Uint8Array([93, 93, 62]),
      CommentEnd: new Uint8Array([45, 45, 62]),
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
      // `</title`
    };
    var Tokenizer = (
      /** @class */
      function() {
        function Tokenizer2(_a, cbs) {
          var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
          this.cbs = cbs;
          this.state = State2.Text;
          this.buffer = "";
          this.sectionStart = 0;
          this.index = 0;
          this.baseState = State2.Text;
          this.isSpecial = false;
          this.running = true;
          this.offset = 0;
          this.currentSequence = void 0;
          this.sequenceIndex = 0;
          this.trieIndex = 0;
          this.trieCurrent = 0;
          this.entityResult = 0;
          this.entityExcess = 0;
          this.xmlMode = xmlMode;
          this.decodeEntities = decodeEntities;
          this.entityTrie = xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree;
        }
        Tokenizer2.prototype.reset = function() {
          this.state = State2.Text;
          this.buffer = "";
          this.sectionStart = 0;
          this.index = 0;
          this.baseState = State2.Text;
          this.currentSequence = void 0;
          this.running = true;
          this.offset = 0;
        };
        Tokenizer2.prototype.write = function(chunk2) {
          this.offset += this.buffer.length;
          this.buffer = chunk2;
          this.parse();
        };
        Tokenizer2.prototype.end = function() {
          if (this.running)
            this.finish();
        };
        Tokenizer2.prototype.pause = function() {
          this.running = false;
        };
        Tokenizer2.prototype.resume = function() {
          this.running = true;
          if (this.index < this.buffer.length + this.offset) {
            this.parse();
          }
        };
        Tokenizer2.prototype.getIndex = function() {
          return this.index;
        };
        Tokenizer2.prototype.getSectionStart = function() {
          return this.sectionStart;
        };
        Tokenizer2.prototype.stateText = function(c6) {
          if (c6 === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
            if (this.index > this.sectionStart) {
              this.cbs.ontext(this.sectionStart, this.index);
            }
            this.state = State2.BeforeTagName;
            this.sectionStart = this.index;
          } else if (this.decodeEntities && c6 === CharCodes.Amp) {
            this.state = State2.BeforeEntity;
          }
        };
        Tokenizer2.prototype.stateSpecialStartSequence = function(c6) {
          var isEnd = this.sequenceIndex === this.currentSequence.length;
          var isMatch2 = isEnd ? (
            // If we are at the end of the sequence, make sure the tag name has ended
            isEndOfTagSection(c6)
          ) : (
            // Otherwise, do a case-insensitive comparison
            (c6 | 32) === this.currentSequence[this.sequenceIndex]
          );
          if (!isMatch2) {
            this.isSpecial = false;
          } else if (!isEnd) {
            this.sequenceIndex++;
            return;
          }
          this.sequenceIndex = 0;
          this.state = State2.InTagName;
          this.stateInTagName(c6);
        };
        Tokenizer2.prototype.stateInSpecialTag = function(c6) {
          if (this.sequenceIndex === this.currentSequence.length) {
            if (c6 === CharCodes.Gt || isWhitespace2(c6)) {
              var endOfText = this.index - this.currentSequence.length;
              if (this.sectionStart < endOfText) {
                var actualIndex = this.index;
                this.index = endOfText;
                this.cbs.ontext(this.sectionStart, endOfText);
                this.index = actualIndex;
              }
              this.isSpecial = false;
              this.sectionStart = endOfText + 2;
              this.stateInClosingTagName(c6);
              return;
            }
            this.sequenceIndex = 0;
          }
          if ((c6 | 32) === this.currentSequence[this.sequenceIndex]) {
            this.sequenceIndex += 1;
          } else if (this.sequenceIndex === 0) {
            if (this.currentSequence === Sequences.TitleEnd) {
              if (this.decodeEntities && c6 === CharCodes.Amp) {
                this.state = State2.BeforeEntity;
              }
            } else if (this.fastForwardTo(CharCodes.Lt)) {
              this.sequenceIndex = 1;
            }
          } else {
            this.sequenceIndex = Number(c6 === CharCodes.Lt);
          }
        };
        Tokenizer2.prototype.stateCDATASequence = function(c6) {
          if (c6 === Sequences.Cdata[this.sequenceIndex]) {
            if (++this.sequenceIndex === Sequences.Cdata.length) {
              this.state = State2.InCommentLike;
              this.currentSequence = Sequences.CdataEnd;
              this.sequenceIndex = 0;
              this.sectionStart = this.index + 1;
            }
          } else {
            this.sequenceIndex = 0;
            this.state = State2.InDeclaration;
            this.stateInDeclaration(c6);
          }
        };
        Tokenizer2.prototype.fastForwardTo = function(c6) {
          while (++this.index < this.buffer.length + this.offset) {
            if (this.buffer.charCodeAt(this.index - this.offset) === c6) {
              return true;
            }
          }
          this.index = this.buffer.length + this.offset - 1;
          return false;
        };
        Tokenizer2.prototype.stateInCommentLike = function(c6) {
          if (c6 === this.currentSequence[this.sequenceIndex]) {
            if (++this.sequenceIndex === this.currentSequence.length) {
              if (this.currentSequence === Sequences.CdataEnd) {
                this.cbs.oncdata(this.sectionStart, this.index, 2);
              } else {
                this.cbs.oncomment(this.sectionStart, this.index, 2);
              }
              this.sequenceIndex = 0;
              this.sectionStart = this.index + 1;
              this.state = State2.Text;
            }
          } else if (this.sequenceIndex === 0) {
            if (this.fastForwardTo(this.currentSequence[0])) {
              this.sequenceIndex = 1;
            }
          } else if (c6 !== this.currentSequence[this.sequenceIndex - 1]) {
            this.sequenceIndex = 0;
          }
        };
        Tokenizer2.prototype.isTagStartChar = function(c6) {
          return this.xmlMode ? !isEndOfTagSection(c6) : isASCIIAlpha(c6);
        };
        Tokenizer2.prototype.startSpecial = function(sequence, offset2) {
          this.isSpecial = true;
          this.currentSequence = sequence;
          this.sequenceIndex = offset2;
          this.state = State2.SpecialStartSequence;
        };
        Tokenizer2.prototype.stateBeforeTagName = function(c6) {
          if (c6 === CharCodes.ExclamationMark) {
            this.state = State2.BeforeDeclaration;
            this.sectionStart = this.index + 1;
          } else if (c6 === CharCodes.Questionmark) {
            this.state = State2.InProcessingInstruction;
            this.sectionStart = this.index + 1;
          } else if (this.isTagStartChar(c6)) {
            var lower = c6 | 32;
            this.sectionStart = this.index;
            if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
              this.startSpecial(Sequences.TitleEnd, 3);
            } else {
              this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State2.BeforeSpecialS : State2.InTagName;
            }
          } else if (c6 === CharCodes.Slash) {
            this.state = State2.BeforeClosingTagName;
          } else {
            this.state = State2.Text;
            this.stateText(c6);
          }
        };
        Tokenizer2.prototype.stateInTagName = function(c6) {
          if (isEndOfTagSection(c6)) {
            this.cbs.onopentagname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c6);
          }
        };
        Tokenizer2.prototype.stateBeforeClosingTagName = function(c6) {
          if (isWhitespace2(c6)) {
          } else if (c6 === CharCodes.Gt) {
            this.state = State2.Text;
          } else {
            this.state = this.isTagStartChar(c6) ? State2.InClosingTagName : State2.InSpecialComment;
            this.sectionStart = this.index;
          }
        };
        Tokenizer2.prototype.stateInClosingTagName = function(c6) {
          if (c6 === CharCodes.Gt || isWhitespace2(c6)) {
            this.cbs.onclosetag(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State2.AfterClosingTagName;
            this.stateAfterClosingTagName(c6);
          }
        };
        Tokenizer2.prototype.stateAfterClosingTagName = function(c6) {
          if (c6 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.state = State2.Text;
            this.baseState = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeAttributeName = function(c6) {
          if (c6 === CharCodes.Gt) {
            this.cbs.onopentagend(this.index);
            if (this.isSpecial) {
              this.state = State2.InSpecialTag;
              this.sequenceIndex = 0;
            } else {
              this.state = State2.Text;
            }
            this.baseState = this.state;
            this.sectionStart = this.index + 1;
          } else if (c6 === CharCodes.Slash) {
            this.state = State2.InSelfClosingTag;
          } else if (!isWhitespace2(c6)) {
            this.state = State2.InAttributeName;
            this.sectionStart = this.index;
          }
        };
        Tokenizer2.prototype.stateInSelfClosingTag = function(c6) {
          if (c6 === CharCodes.Gt) {
            this.cbs.onselfclosingtag(this.index);
            this.state = State2.Text;
            this.baseState = State2.Text;
            this.sectionStart = this.index + 1;
            this.isSpecial = false;
          } else if (!isWhitespace2(c6)) {
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c6);
          }
        };
        Tokenizer2.prototype.stateInAttributeName = function(c6) {
          if (c6 === CharCodes.Eq || isEndOfTagSection(c6)) {
            this.cbs.onattribname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State2.AfterAttributeName;
            this.stateAfterAttributeName(c6);
          }
        };
        Tokenizer2.prototype.stateAfterAttributeName = function(c6) {
          if (c6 === CharCodes.Eq) {
            this.state = State2.BeforeAttributeValue;
          } else if (c6 === CharCodes.Slash || c6 === CharCodes.Gt) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c6);
          } else if (!isWhitespace2(c6)) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State2.InAttributeName;
            this.sectionStart = this.index;
          }
        };
        Tokenizer2.prototype.stateBeforeAttributeValue = function(c6) {
          if (c6 === CharCodes.DoubleQuote) {
            this.state = State2.InAttributeValueDq;
            this.sectionStart = this.index + 1;
          } else if (c6 === CharCodes.SingleQuote) {
            this.state = State2.InAttributeValueSq;
            this.sectionStart = this.index + 1;
          } else if (!isWhitespace2(c6)) {
            this.sectionStart = this.index;
            this.state = State2.InAttributeValueNq;
            this.stateInAttributeValueNoQuotes(c6);
          }
        };
        Tokenizer2.prototype.handleInAttributeValue = function(c6, quote) {
          if (c6 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
            this.state = State2.BeforeAttributeName;
          } else if (this.decodeEntities && c6 === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State2.BeforeEntity;
          }
        };
        Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function(c6) {
          this.handleInAttributeValue(c6, CharCodes.DoubleQuote);
        };
        Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function(c6) {
          this.handleInAttributeValue(c6, CharCodes.SingleQuote);
        };
        Tokenizer2.prototype.stateInAttributeValueNoQuotes = function(c6) {
          if (isWhitespace2(c6) || c6 === CharCodes.Gt) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(QuoteType.Unquoted, this.index);
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c6);
          } else if (this.decodeEntities && c6 === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State2.BeforeEntity;
          }
        };
        Tokenizer2.prototype.stateBeforeDeclaration = function(c6) {
          if (c6 === CharCodes.OpeningSquareBracket) {
            this.state = State2.CDATASequence;
            this.sequenceIndex = 0;
          } else {
            this.state = c6 === CharCodes.Dash ? State2.BeforeComment : State2.InDeclaration;
          }
        };
        Tokenizer2.prototype.stateInDeclaration = function(c6) {
          if (c6 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.ondeclaration(this.sectionStart, this.index);
            this.state = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateInProcessingInstruction = function(c6) {
          if (c6 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.onprocessinginstruction(this.sectionStart, this.index);
            this.state = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeComment = function(c6) {
          if (c6 === CharCodes.Dash) {
            this.state = State2.InCommentLike;
            this.currentSequence = Sequences.CommentEnd;
            this.sequenceIndex = 2;
            this.sectionStart = this.index + 1;
          } else {
            this.state = State2.InDeclaration;
          }
        };
        Tokenizer2.prototype.stateInSpecialComment = function(c6) {
          if (c6 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.oncomment(this.sectionStart, this.index, 0);
            this.state = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeSpecialS = function(c6) {
          var lower = c6 | 32;
          if (lower === Sequences.ScriptEnd[3]) {
            this.startSpecial(Sequences.ScriptEnd, 4);
          } else if (lower === Sequences.StyleEnd[3]) {
            this.startSpecial(Sequences.StyleEnd, 4);
          } else {
            this.state = State2.InTagName;
            this.stateInTagName(c6);
          }
        };
        Tokenizer2.prototype.stateBeforeEntity = function(c6) {
          this.entityExcess = 1;
          this.entityResult = 0;
          if (c6 === CharCodes.Number) {
            this.state = State2.BeforeNumericEntity;
          } else if (c6 === CharCodes.Amp) {
          } else {
            this.trieIndex = 0;
            this.trieCurrent = this.entityTrie[0];
            this.state = State2.InNamedEntity;
            this.stateInNamedEntity(c6);
          }
        };
        Tokenizer2.prototype.stateInNamedEntity = function(c6) {
          this.entityExcess += 1;
          this.trieIndex = (0, decode_js_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c6);
          if (this.trieIndex < 0) {
            this.emitNamedEntity();
            this.index--;
            return;
          }
          this.trieCurrent = this.entityTrie[this.trieIndex];
          var masked = this.trieCurrent & decode_js_1.BinTrieFlags.VALUE_LENGTH;
          if (masked) {
            var valueLength = (masked >> 14) - 1;
            if (!this.allowLegacyEntity() && c6 !== CharCodes.Semi) {
              this.trieIndex += valueLength;
            } else {
              var entityStart = this.index - this.entityExcess + 1;
              if (entityStart > this.sectionStart) {
                this.emitPartial(this.sectionStart, entityStart);
              }
              this.entityResult = this.trieIndex;
              this.trieIndex += valueLength;
              this.entityExcess = 0;
              this.sectionStart = this.index + 1;
              if (valueLength === 0) {
                this.emitNamedEntity();
              }
            }
          }
        };
        Tokenizer2.prototype.emitNamedEntity = function() {
          this.state = this.baseState;
          if (this.entityResult === 0) {
            return;
          }
          var valueLength = (this.entityTrie[this.entityResult] & decode_js_1.BinTrieFlags.VALUE_LENGTH) >> 14;
          switch (valueLength) {
            case 1: {
              this.emitCodePoint(this.entityTrie[this.entityResult] & ~decode_js_1.BinTrieFlags.VALUE_LENGTH);
              break;
            }
            case 2: {
              this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
              break;
            }
            case 3: {
              this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
              this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
            }
          }
        };
        Tokenizer2.prototype.stateBeforeNumericEntity = function(c6) {
          if ((c6 | 32) === CharCodes.LowerX) {
            this.entityExcess++;
            this.state = State2.InHexEntity;
          } else {
            this.state = State2.InNumericEntity;
            this.stateInNumericEntity(c6);
          }
        };
        Tokenizer2.prototype.emitNumericEntity = function(strict) {
          var entityStart = this.index - this.entityExcess - 1;
          var numberStart = entityStart + 2 + Number(this.state === State2.InHexEntity);
          if (numberStart !== this.index) {
            if (entityStart > this.sectionStart) {
              this.emitPartial(this.sectionStart, entityStart);
            }
            this.sectionStart = this.index + Number(strict);
            this.emitCodePoint((0, decode_js_1.replaceCodePoint)(this.entityResult));
          }
          this.state = this.baseState;
        };
        Tokenizer2.prototype.stateInNumericEntity = function(c6) {
          if (c6 === CharCodes.Semi) {
            this.emitNumericEntity(true);
          } else if (isNumber(c6)) {
            this.entityResult = this.entityResult * 10 + (c6 - CharCodes.Zero);
            this.entityExcess++;
          } else {
            if (this.allowLegacyEntity()) {
              this.emitNumericEntity(false);
            } else {
              this.state = this.baseState;
            }
            this.index--;
          }
        };
        Tokenizer2.prototype.stateInHexEntity = function(c6) {
          if (c6 === CharCodes.Semi) {
            this.emitNumericEntity(true);
          } else if (isNumber(c6)) {
            this.entityResult = this.entityResult * 16 + (c6 - CharCodes.Zero);
            this.entityExcess++;
          } else if (isHexDigit(c6)) {
            this.entityResult = this.entityResult * 16 + ((c6 | 32) - CharCodes.LowerA + 10);
            this.entityExcess++;
          } else {
            if (this.allowLegacyEntity()) {
              this.emitNumericEntity(false);
            } else {
              this.state = this.baseState;
            }
            this.index--;
          }
        };
        Tokenizer2.prototype.allowLegacyEntity = function() {
          return !this.xmlMode && (this.baseState === State2.Text || this.baseState === State2.InSpecialTag);
        };
        Tokenizer2.prototype.cleanup = function() {
          if (this.running && this.sectionStart !== this.index) {
            if (this.state === State2.Text || this.state === State2.InSpecialTag && this.sequenceIndex === 0) {
              this.cbs.ontext(this.sectionStart, this.index);
              this.sectionStart = this.index;
            } else if (this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueNq) {
              this.cbs.onattribdata(this.sectionStart, this.index);
              this.sectionStart = this.index;
            }
          }
        };
        Tokenizer2.prototype.shouldContinue = function() {
          return this.index < this.buffer.length + this.offset && this.running;
        };
        Tokenizer2.prototype.parse = function() {
          while (this.shouldContinue()) {
            var c6 = this.buffer.charCodeAt(this.index - this.offset);
            switch (this.state) {
              case State2.Text: {
                this.stateText(c6);
                break;
              }
              case State2.SpecialStartSequence: {
                this.stateSpecialStartSequence(c6);
                break;
              }
              case State2.InSpecialTag: {
                this.stateInSpecialTag(c6);
                break;
              }
              case State2.CDATASequence: {
                this.stateCDATASequence(c6);
                break;
              }
              case State2.InAttributeValueDq: {
                this.stateInAttributeValueDoubleQuotes(c6);
                break;
              }
              case State2.InAttributeName: {
                this.stateInAttributeName(c6);
                break;
              }
              case State2.InCommentLike: {
                this.stateInCommentLike(c6);
                break;
              }
              case State2.InSpecialComment: {
                this.stateInSpecialComment(c6);
                break;
              }
              case State2.BeforeAttributeName: {
                this.stateBeforeAttributeName(c6);
                break;
              }
              case State2.InTagName: {
                this.stateInTagName(c6);
                break;
              }
              case State2.InClosingTagName: {
                this.stateInClosingTagName(c6);
                break;
              }
              case State2.BeforeTagName: {
                this.stateBeforeTagName(c6);
                break;
              }
              case State2.AfterAttributeName: {
                this.stateAfterAttributeName(c6);
                break;
              }
              case State2.InAttributeValueSq: {
                this.stateInAttributeValueSingleQuotes(c6);
                break;
              }
              case State2.BeforeAttributeValue: {
                this.stateBeforeAttributeValue(c6);
                break;
              }
              case State2.BeforeClosingTagName: {
                this.stateBeforeClosingTagName(c6);
                break;
              }
              case State2.AfterClosingTagName: {
                this.stateAfterClosingTagName(c6);
                break;
              }
              case State2.BeforeSpecialS: {
                this.stateBeforeSpecialS(c6);
                break;
              }
              case State2.InAttributeValueNq: {
                this.stateInAttributeValueNoQuotes(c6);
                break;
              }
              case State2.InSelfClosingTag: {
                this.stateInSelfClosingTag(c6);
                break;
              }
              case State2.InDeclaration: {
                this.stateInDeclaration(c6);
                break;
              }
              case State2.BeforeDeclaration: {
                this.stateBeforeDeclaration(c6);
                break;
              }
              case State2.BeforeComment: {
                this.stateBeforeComment(c6);
                break;
              }
              case State2.InProcessingInstruction: {
                this.stateInProcessingInstruction(c6);
                break;
              }
              case State2.InNamedEntity: {
                this.stateInNamedEntity(c6);
                break;
              }
              case State2.BeforeEntity: {
                this.stateBeforeEntity(c6);
                break;
              }
              case State2.InHexEntity: {
                this.stateInHexEntity(c6);
                break;
              }
              case State2.InNumericEntity: {
                this.stateInNumericEntity(c6);
                break;
              }
              default: {
                this.stateBeforeNumericEntity(c6);
              }
            }
            this.index++;
          }
          this.cleanup();
        };
        Tokenizer2.prototype.finish = function() {
          if (this.state === State2.InNamedEntity) {
            this.emitNamedEntity();
          }
          if (this.sectionStart < this.index) {
            this.handleTrailingData();
          }
          this.cbs.onend();
        };
        Tokenizer2.prototype.handleTrailingData = function() {
          var endIndex = this.buffer.length + this.offset;
          if (this.state === State2.InCommentLike) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, endIndex, 0);
            } else {
              this.cbs.oncomment(this.sectionStart, endIndex, 0);
            }
          } else if (this.state === State2.InNumericEntity && this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else if (this.state === State2.InHexEntity && this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else if (this.state === State2.InTagName || this.state === State2.BeforeAttributeName || this.state === State2.BeforeAttributeValue || this.state === State2.AfterAttributeName || this.state === State2.InAttributeName || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueNq || this.state === State2.InClosingTagName) {
          } else {
            this.cbs.ontext(this.sectionStart, endIndex);
          }
        };
        Tokenizer2.prototype.emitPartial = function(start, endIndex) {
          if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
            this.cbs.onattribdata(start, endIndex);
          } else {
            this.cbs.ontext(start, endIndex);
          }
        };
        Tokenizer2.prototype.emitCodePoint = function(cp) {
          if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
            this.cbs.onattribentity(cp);
          } else {
            this.cbs.ontextentity(cp);
          }
        };
        return Tokenizer2;
      }()
    );
    exports2.default = Tokenizer;
  }
});

// ../../node_modules/htmlparser2/lib/Parser.js
var require_Parser = __commonJS({
  "../../node_modules/htmlparser2/lib/Parser.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Parser = void 0;
    var Tokenizer_js_1 = __importStar(require_Tokenizer());
    var decode_js_1 = require_decode();
    var formTags = /* @__PURE__ */ new Set([
      "input",
      "option",
      "optgroup",
      "select",
      "button",
      "datalist",
      "textarea"
    ]);
    var pTag = /* @__PURE__ */ new Set(["p"]);
    var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
    var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
    var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
    var openImpliesClose = /* @__PURE__ */ new Map([
      ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
      ["th", /* @__PURE__ */ new Set(["th"])],
      ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
      ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
      ["li", /* @__PURE__ */ new Set(["li"])],
      ["p", pTag],
      ["h1", pTag],
      ["h2", pTag],
      ["h3", pTag],
      ["h4", pTag],
      ["h5", pTag],
      ["h6", pTag],
      ["select", formTags],
      ["input", formTags],
      ["output", formTags],
      ["button", formTags],
      ["datalist", formTags],
      ["textarea", formTags],
      ["option", /* @__PURE__ */ new Set(["option"])],
      ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
      ["dd", ddtTags],
      ["dt", ddtTags],
      ["address", pTag],
      ["article", pTag],
      ["aside", pTag],
      ["blockquote", pTag],
      ["details", pTag],
      ["div", pTag],
      ["dl", pTag],
      ["fieldset", pTag],
      ["figcaption", pTag],
      ["figure", pTag],
      ["footer", pTag],
      ["form", pTag],
      ["header", pTag],
      ["hr", pTag],
      ["main", pTag],
      ["nav", pTag],
      ["ol", pTag],
      ["pre", pTag],
      ["section", pTag],
      ["table", pTag],
      ["ul", pTag],
      ["rt", rtpTags],
      ["rp", rtpTags],
      ["tbody", tableSectionTags],
      ["tfoot", tableSectionTags]
    ]);
    var voidElements = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
    var htmlIntegrationElements = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignobject",
      "desc",
      "title"
    ]);
    var reNameEnd = /\s|\//;
    var Parser = (
      /** @class */
      function() {
        function Parser2(cbs, options) {
          if (options === void 0) {
            options = {};
          }
          var _a, _b, _c, _d, _e;
          this.options = options;
          this.startIndex = 0;
          this.endIndex = 0;
          this.openTagStart = 0;
          this.tagname = "";
          this.attribname = "";
          this.attribvalue = "";
          this.attribs = null;
          this.stack = [];
          this.foreignContext = [];
          this.buffers = [];
          this.bufferOffset = 0;
          this.writeIndex = 0;
          this.ended = false;
          this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
          this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
          this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
          this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
          (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
        }
        Parser2.prototype.ontext = function(start, endIndex) {
          var _a, _b;
          var data = this.getSlice(start, endIndex);
          this.endIndex = endIndex - 1;
          (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
          this.startIndex = endIndex;
        };
        Parser2.prototype.ontextentity = function(cp) {
          var _a, _b;
          var index2 = this.tokenizer.getSectionStart();
          this.endIndex = index2 - 1;
          (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
          this.startIndex = index2;
        };
        Parser2.prototype.isVoidElement = function(name2) {
          return !this.options.xmlMode && voidElements.has(name2);
        };
        Parser2.prototype.onopentagname = function(start, endIndex) {
          this.endIndex = endIndex;
          var name2 = this.getSlice(start, endIndex);
          if (this.lowerCaseTagNames) {
            name2 = name2.toLowerCase();
          }
          this.emitOpenTag(name2);
        };
        Parser2.prototype.emitOpenTag = function(name2) {
          var _a, _b, _c, _d;
          this.openTagStart = this.startIndex;
          this.tagname = name2;
          var impliesClose = !this.options.xmlMode && openImpliesClose.get(name2);
          if (impliesClose) {
            while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
              var element2 = this.stack.pop();
              (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element2, true);
            }
          }
          if (!this.isVoidElement(name2)) {
            this.stack.push(name2);
            if (foreignContextElements.has(name2)) {
              this.foreignContext.push(true);
            } else if (htmlIntegrationElements.has(name2)) {
              this.foreignContext.push(false);
            }
          }
          (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name2);
          if (this.cbs.onopentag)
            this.attribs = {};
        };
        Parser2.prototype.endOpenTag = function(isImplied) {
          var _a, _b;
          this.startIndex = this.openTagStart;
          if (this.attribs) {
            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
            this.attribs = null;
          }
          if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
            this.cbs.onclosetag(this.tagname, true);
          }
          this.tagname = "";
        };
        Parser2.prototype.onopentagend = function(endIndex) {
          this.endIndex = endIndex;
          this.endOpenTag(false);
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onclosetag = function(start, endIndex) {
          var _a, _b, _c, _d, _e, _f;
          this.endIndex = endIndex;
          var name2 = this.getSlice(start, endIndex);
          if (this.lowerCaseTagNames) {
            name2 = name2.toLowerCase();
          }
          if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
            this.foreignContext.pop();
          }
          if (!this.isVoidElement(name2)) {
            var pos = this.stack.lastIndexOf(name2);
            if (pos !== -1) {
              if (this.cbs.onclosetag) {
                var count = this.stack.length - pos;
                while (count--) {
                  this.cbs.onclosetag(this.stack.pop(), count !== 0);
                }
              } else
                this.stack.length = pos;
            } else if (!this.options.xmlMode && name2 === "p") {
              this.emitOpenTag("p");
              this.closeCurrentTag(true);
            }
          } else if (!this.options.xmlMode && name2 === "br") {
            (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
            (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
            (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onselfclosingtag = function(endIndex) {
          this.endIndex = endIndex;
          if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag(false);
            this.startIndex = endIndex + 1;
          } else {
            this.onopentagend(endIndex);
          }
        };
        Parser2.prototype.closeCurrentTag = function(isOpenImplied) {
          var _a, _b;
          var name2 = this.tagname;
          this.endOpenTag(isOpenImplied);
          if (this.stack[this.stack.length - 1] === name2) {
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name2, !isOpenImplied);
            this.stack.pop();
          }
        };
        Parser2.prototype.onattribname = function(start, endIndex) {
          this.startIndex = start;
          var name2 = this.getSlice(start, endIndex);
          this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
        };
        Parser2.prototype.onattribdata = function(start, endIndex) {
          this.attribvalue += this.getSlice(start, endIndex);
        };
        Parser2.prototype.onattribentity = function(cp) {
          this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
        };
        Parser2.prototype.onattribend = function(quote, endIndex) {
          var _a, _b;
          this.endIndex = endIndex;
          (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double ? '"' : quote === Tokenizer_js_1.QuoteType.Single ? "'" : quote === Tokenizer_js_1.QuoteType.NoValue ? void 0 : null);
          if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
          }
          this.attribvalue = "";
        };
        Parser2.prototype.getInstructionName = function(value) {
          var index2 = value.search(reNameEnd);
          var name2 = index2 < 0 ? value : value.substr(0, index2);
          if (this.lowerCaseTagNames) {
            name2 = name2.toLowerCase();
          }
          return name2;
        };
        Parser2.prototype.ondeclaration = function(start, endIndex) {
          this.endIndex = endIndex;
          var value = this.getSlice(start, endIndex);
          if (this.cbs.onprocessinginstruction) {
            var name2 = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("!".concat(name2), "!".concat(value));
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onprocessinginstruction = function(start, endIndex) {
          this.endIndex = endIndex;
          var value = this.getSlice(start, endIndex);
          if (this.cbs.onprocessinginstruction) {
            var name2 = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("?".concat(name2), "?".concat(value));
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.oncomment = function(start, endIndex, offset2) {
          var _a, _b, _c, _d;
          this.endIndex = endIndex;
          (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset2));
          (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.oncdata = function(start, endIndex, offset2) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
          this.endIndex = endIndex;
          var value = this.getSlice(start, endIndex - offset2);
          if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
          } else {
            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onend = function() {
          var _a, _b;
          if (this.cbs.onclosetag) {
            this.endIndex = this.startIndex;
            for (var index2 = this.stack.length; index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
              ;
          }
          (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        Parser2.prototype.reset = function() {
          var _a, _b, _c, _d;
          (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
          this.tokenizer.reset();
          this.tagname = "";
          this.attribname = "";
          this.attribs = null;
          this.stack.length = 0;
          this.startIndex = 0;
          this.endIndex = 0;
          (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
          this.buffers.length = 0;
          this.bufferOffset = 0;
          this.writeIndex = 0;
          this.ended = false;
        };
        Parser2.prototype.parseComplete = function(data) {
          this.reset();
          this.end(data);
        };
        Parser2.prototype.getSlice = function(start, end) {
          while (start - this.bufferOffset >= this.buffers[0].length) {
            this.shiftBuffer();
          }
          var slice2 = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
          while (end - this.bufferOffset > this.buffers[0].length) {
            this.shiftBuffer();
            slice2 += this.buffers[0].slice(0, end - this.bufferOffset);
          }
          return slice2;
        };
        Parser2.prototype.shiftBuffer = function() {
          this.bufferOffset += this.buffers[0].length;
          this.writeIndex--;
          this.buffers.shift();
        };
        Parser2.prototype.write = function(chunk2) {
          var _a, _b;
          if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
            return;
          }
          this.buffers.push(chunk2);
          if (this.tokenizer.running) {
            this.tokenizer.write(chunk2);
            this.writeIndex++;
          }
        };
        Parser2.prototype.end = function(chunk2) {
          var _a, _b;
          if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
            return;
          }
          if (chunk2)
            this.write(chunk2);
          this.ended = true;
          this.tokenizer.end();
        };
        Parser2.prototype.pause = function() {
          this.tokenizer.pause();
        };
        Parser2.prototype.resume = function() {
          this.tokenizer.resume();
          while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
            this.tokenizer.write(this.buffers[this.writeIndex++]);
          }
          if (this.ended)
            this.tokenizer.end();
        };
        Parser2.prototype.parseChunk = function(chunk2) {
          this.write(chunk2);
        };
        Parser2.prototype.done = function(chunk2) {
          this.end(chunk2);
        };
        return Parser2;
      }()
    );
    exports2.Parser = Parser;
  }
});

// ../../node_modules/domhandler/lib/node.js
var require_node = __commonJS({
  "../../node_modules/domhandler/lib/node.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d6, b4) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
          d7.__proto__ = b5;
        } || function(d7, b5) {
          for (var p3 in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p3))
              d7[p3] = b5[p3];
        };
        return extendStatics(d6, b4);
      };
      return function(d6, b4) {
        if (typeof b4 !== "function" && b4 !== null)
          throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
        extendStatics(d6, b4);
        function __() {
          this.constructor = d6;
        }
        d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t10) {
        for (var s7, i5 = 1, n4 = arguments.length; i5 < n4; i5++) {
          s7 = arguments[i5];
          for (var p3 in s7)
            if (Object.prototype.hasOwnProperty.call(s7, p3))
              t10[p3] = s7[p3];
        }
        return t10;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloneNode = exports2.hasChildren = exports2.isDocument = exports2.isDirective = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = exports2.Element = exports2.Document = exports2.CDATA = exports2.NodeWithChildren = exports2.ProcessingInstruction = exports2.Comment = exports2.Text = exports2.DataNode = exports2.Node = void 0;
    var domelementtype_1 = require_lib();
    var Node2 = (
      /** @class */
      function() {
        function Node3() {
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node3.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true
        });
        Node3.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node3;
      }()
    );
    exports2.Node = Node2;
    var DataNode = (
      /** @class */
      function(_super) {
        __extends(DataNode2, _super);
        function DataNode2(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode2.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode2;
      }(Node2)
    );
    exports2.DataNode = DataNode;
    var Text = (
      /** @class */
      function(_super) {
        __extends(Text2, _super);
        function Text2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Text;
          return _this;
        }
        Object.defineProperty(Text2.prototype, "nodeType", {
          get: function() {
            return 3;
          },
          enumerable: false,
          configurable: true
        });
        return Text2;
      }(DataNode)
    );
    exports2.Text = Text;
    var Comment = (
      /** @class */
      function(_super) {
        __extends(Comment2, _super);
        function Comment2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Comment;
          return _this;
        }
        Object.defineProperty(Comment2.prototype, "nodeType", {
          get: function() {
            return 8;
          },
          enumerable: false,
          configurable: true
        });
        return Comment2;
      }(DataNode)
    );
    exports2.Comment = Comment;
    var ProcessingInstruction = (
      /** @class */
      function(_super) {
        __extends(ProcessingInstruction2, _super);
        function ProcessingInstruction2(name2, data) {
          var _this = _super.call(this, data) || this;
          _this.name = name2;
          _this.type = domelementtype_1.ElementType.Directive;
          return _this;
        }
        Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        return ProcessingInstruction2;
      }(DataNode)
    );
    exports2.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren = (
      /** @class */
      function(_super) {
        __extends(NodeWithChildren2, _super);
        function NodeWithChildren2(children) {
          var _this = _super.call(this) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true
        });
        return NodeWithChildren2;
      }(Node2)
    );
    exports2.NodeWithChildren = NodeWithChildren;
    var CDATA = (
      /** @class */
      function(_super) {
        __extends(CDATA2, _super);
        function CDATA2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.CDATA;
          return _this;
        }
        Object.defineProperty(CDATA2.prototype, "nodeType", {
          get: function() {
            return 4;
          },
          enumerable: false,
          configurable: true
        });
        return CDATA2;
      }(NodeWithChildren)
    );
    exports2.CDATA = CDATA;
    var Document2 = (
      /** @class */
      function(_super) {
        __extends(Document3, _super);
        function Document3() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Root;
          return _this;
        }
        Object.defineProperty(Document3.prototype, "nodeType", {
          get: function() {
            return 9;
          },
          enumerable: false,
          configurable: true
        });
        return Document3;
      }(NodeWithChildren)
    );
    exports2.Document = Document2;
    var Element2 = (
      /** @class */
      function(_super) {
        __extends(Element3, _super);
        function Element3(name2, attribs, children, type2) {
          if (children === void 0) {
            children = [];
          }
          if (type2 === void 0) {
            type2 = name2 === "script" ? domelementtype_1.ElementType.Script : name2 === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, children) || this;
          _this.name = name2;
          _this.attribs = attribs;
          _this.type = type2;
          return _this;
        }
        Object.defineProperty(Element3.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element3.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.name;
          },
          set: function(name2) {
            this.name = name2;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element3.prototype, "attributes", {
          get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name2) {
              var _a, _b;
              return {
                name: name2,
                value: _this.attribs[name2],
                namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name2],
                prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
              };
            });
          },
          enumerable: false,
          configurable: true
        });
        return Element3;
      }(NodeWithChildren)
    );
    exports2.Element = Element2;
    function isTag(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports2.isTag = isTag;
    function isCDATA(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports2.isCDATA = isCDATA;
    function isText(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports2.isText = isText;
    function isComment(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports2.isComment = isComment;
    function isDirective(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports2.isDirective = isDirective;
    function isDocument(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports2.isDocument = isDocument;
    function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports2.hasChildren = hasChildren;
    function cloneNode(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result2;
      if (isText(node)) {
        result2 = new Text(node.data);
      } else if (isComment(node)) {
        result2 = new Comment(node.data);
      } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element2(node.name, __assign2({}, node.attribs), children);
        children.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign2({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign2({}, node["x-attribsPrefix"]);
        }
        result2 = clone_1;
      } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new CDATA(children);
        children.forEach(function(child) {
          return child.parent = clone_2;
        });
        result2 = clone_2;
      } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document2(children);
        children.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result2 = clone_3;
      } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result2 = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result2.startIndex = node.startIndex;
      result2.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result2.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result2;
    }
    exports2.cloneNode = cloneNode;
    function cloneChildren(childs) {
      var children = childs.map(function(child) {
        return cloneNode(child, true);
      });
      for (var i5 = 1; i5 < children.length; i5++) {
        children[i5].prev = children[i5 - 1];
        children[i5 - 1].next = children[i5];
      }
      return children;
    }
  }
});

// ../../node_modules/domhandler/lib/index.js
var require_lib9 = __commonJS({
  "../../node_modules/domhandler/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomHandler = void 0;
    var domelementtype_1 = require_lib();
    var node_js_1 = require_node();
    __exportStar(require_node(), exports2);
    var defaultOpts = {
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = (
      /** @class */
      function() {
        function DomHandler2(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler2.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler2.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler2.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler2.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler2.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler2.prototype.onopentag = function(name2, attribs) {
          var type2 = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element2 = new node_js_1.Element(name2, attribs, void 0, type2);
          this.addNode(element2);
          this.tagStack.push(element2);
        };
        DomHandler2.prototype.ontext = function(data) {
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler2.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_js_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler2.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.oncdatastart = function() {
          var text = new node_js_1.Text("");
          var node = new node_js_1.CDATA([text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler2.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.onprocessinginstruction = function(name2, data) {
          var node = new node_js_1.ProcessingInstruction(name2, data);
          this.addNode(node);
        };
        DomHandler2.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler2.prototype.addNode = function(node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler2;
      }()
    );
    exports2.DomHandler = DomHandler;
    exports2.default = DomHandler;
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html2 = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/generated/decode-data-html.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = new Uint16Array(
      // prettier-ignore
      '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c6) {
        return c6.charCodeAt(0);
      })
    );
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml2 = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/generated/decode-data-xml.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = new Uint16Array(
      // prettier-ignore
      "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c6) {
        return c6.charCodeAt(0);
      })
    );
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint2 = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
    var decodeMap = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function replaceCodePoint(codePoint) {
      var _a2;
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return 65533;
      }
      return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
    }
    exports2.replaceCodePoint = replaceCodePoint;
    function decodeCodePoint(codePoint) {
      return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
    }
    exports2.default = decodeCodePoint;
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/decode.js
var require_decode2 = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/decode.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
    var decode_data_html_js_1 = __importDefault2(require_decode_data_html2());
    exports2.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault2(require_decode_data_xml2());
    exports2.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importStar(require_decode_codepoint2());
    exports2.decodeCodePoint = decode_codepoint_js_1.default;
    var decode_codepoint_js_2 = require_decode_codepoint2();
    Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.replaceCodePoint;
    } });
    Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.fromCodePoint;
    } });
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
      CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
      CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
      CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
      CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
      CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
      CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
      CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
      CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
      CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
      CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
    })(CharCodes || (CharCodes = {}));
    var TO_LOWER_BIT = 32;
    var BinTrieFlags;
    (function(BinTrieFlags2) {
      BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
    function isNumber(code3) {
      return code3 >= CharCodes.ZERO && code3 <= CharCodes.NINE;
    }
    function isHexadecimalCharacter(code3) {
      return code3 >= CharCodes.UPPER_A && code3 <= CharCodes.UPPER_F || code3 >= CharCodes.LOWER_A && code3 <= CharCodes.LOWER_F;
    }
    function isAsciiAlphaNumeric(code3) {
      return code3 >= CharCodes.UPPER_A && code3 <= CharCodes.UPPER_Z || code3 >= CharCodes.LOWER_A && code3 <= CharCodes.LOWER_Z || isNumber(code3);
    }
    function isEntityInAttributeInvalidEnd(code3) {
      return code3 === CharCodes.EQUALS || isAsciiAlphaNumeric(code3);
    }
    var EntityDecoderState;
    (function(EntityDecoderState2) {
      EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
    })(EntityDecoderState || (EntityDecoderState = {}));
    var DecodingMode;
    (function(DecodingMode2) {
      DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
      DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
      DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
    })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
    var EntityDecoder = (
      /** @class */
      function() {
        function EntityDecoder2(decodeTree, emitCodePoint, errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }
        EntityDecoder2.prototype.startEntity = function(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        };
        EntityDecoder2.prototype.write = function(str2, offset2) {
          switch (this.state) {
            case EntityDecoderState.EntityStart: {
              if (str2.charCodeAt(offset2) === CharCodes.NUM) {
                this.state = EntityDecoderState.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(str2, offset2 + 1);
              }
              this.state = EntityDecoderState.NamedEntity;
              return this.stateNamedEntity(str2, offset2);
            }
            case EntityDecoderState.NumericStart: {
              return this.stateNumericStart(str2, offset2);
            }
            case EntityDecoderState.NumericDecimal: {
              return this.stateNumericDecimal(str2, offset2);
            }
            case EntityDecoderState.NumericHex: {
              return this.stateNumericHex(str2, offset2);
            }
            case EntityDecoderState.NamedEntity: {
              return this.stateNamedEntity(str2, offset2);
            }
          }
        };
        EntityDecoder2.prototype.stateNumericStart = function(str2, offset2) {
          if (offset2 >= str2.length) {
            return -1;
          }
          if ((str2.charCodeAt(offset2) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str2, offset2 + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(str2, offset2);
        };
        EntityDecoder2.prototype.addToNumericResult = function(str2, start, end, base) {
          if (start !== end) {
            var digitCount = end - start;
            this.result = this.result * Math.pow(base, digitCount) + parseInt(str2.substr(start, digitCount), base);
            this.consumed += digitCount;
          }
        };
        EntityDecoder2.prototype.stateNumericHex = function(str2, offset2) {
          var startIdx = offset2;
          while (offset2 < str2.length) {
            var char = str2.charCodeAt(offset2);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
              offset2 += 1;
            } else {
              this.addToNumericResult(str2, startIdx, offset2, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(str2, startIdx, offset2, 16);
          return -1;
        };
        EntityDecoder2.prototype.stateNumericDecimal = function(str2, offset2) {
          var startIdx = offset2;
          while (offset2 < str2.length) {
            var char = str2.charCodeAt(offset2);
            if (isNumber(char)) {
              offset2 += 1;
            } else {
              this.addToNumericResult(str2, startIdx, offset2, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(str2, startIdx, offset2, 10);
          return -1;
        };
        EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
          var _a;
          if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
          }
          this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
          if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        };
        EntityDecoder2.prototype.stateNamedEntity = function(str2, offset2) {
          var decodeTree = this.decodeTree;
          var current = decodeTree[this.treeIndex];
          var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset2 < str2.length; offset2++, this.excess++) {
            var char = str2.charCodeAt(offset2);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
              (valueLength === 0 || // And there should be no invalid characters.
              isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes.SEMI) {
                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
              }
              if (this.decodeMode !== DecodingMode.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        };
        EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
          var _a;
          var _b = this, result2 = _b.result, decodeTree = _b.decodeTree;
          var valueLength = (decodeTree[result2] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result2, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
        };
        EntityDecoder2.prototype.emitNamedEntityData = function(result2, valueLength, consumed) {
          var decodeTree = this.decodeTree;
          this.emitCodePoint(valueLength === 1 ? decodeTree[result2] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result2 + 1], consumed);
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result2 + 2], consumed);
          }
          return consumed;
        };
        EntityDecoder2.prototype.end = function() {
          var _a;
          switch (this.state) {
            case EntityDecoderState.NamedEntity: {
              return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            }
            case EntityDecoderState.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            case EntityDecoderState.EntityStart: {
              return 0;
            }
          }
        };
        return EntityDecoder2;
      }()
    );
    exports2.EntityDecoder = EntityDecoder;
    function getDecoder(decodeTree) {
      var ret = "";
      var decoder = new EntityDecoder(decodeTree, function(str2) {
        return ret += (0, decode_codepoint_js_1.fromCodePoint)(str2);
      });
      return function decodeWithTrie(str2, decodeMode) {
        var lastIndex = 0;
        var offset2 = 0;
        while ((offset2 = str2.indexOf("&", offset2)) >= 0) {
          ret += str2.slice(lastIndex, offset2);
          decoder.startEntity(decodeMode);
          var len = decoder.write(
            str2,
            // Skip the "&"
            offset2 + 1
          );
          if (len < 0) {
            lastIndex = offset2 + decoder.end();
            break;
          }
          lastIndex = offset2 + len;
          offset2 = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result2 = ret + str2.slice(lastIndex);
        ret = "";
        return result2;
      };
    }
    function determineBranch(decodeTree, current, nodeIdx, char) {
      var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
      }
      var lo = nodeIdx;
      var hi = lo + branchCount - 1;
      while (lo <= hi) {
        var mid = lo + hi >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo = mid + 1;
        } else if (midVal > char) {
          hi = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports2.determineBranch = determineBranch;
    var htmlDecoder = getDecoder(decode_data_html_js_1.default);
    var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
    function decodeHTML(str2, mode) {
      if (mode === void 0) {
        mode = DecodingMode.Legacy;
      }
      return htmlDecoder(str2, mode);
    }
    exports2.decodeHTML = decodeHTML;
    function decodeHTMLAttribute(str2) {
      return htmlDecoder(str2, DecodingMode.Attribute);
    }
    exports2.decodeHTMLAttribute = decodeHTMLAttribute;
    function decodeHTMLStrict(str2) {
      return htmlDecoder(str2, DecodingMode.Strict);
    }
    exports2.decodeHTMLStrict = decodeHTMLStrict;
    function decodeXML(str2) {
      return xmlDecoder(str2, DecodingMode.Strict);
    }
    exports2.decodeXML = decodeXML;
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/generated/encode-html.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function restoreDiff(arr) {
      for (var i5 = 1; i5 < arr.length; i5++) {
        arr[i5][0] += arr[i5 - 1][0] + 1;
      }
      return arr;
    }
    exports2.default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/escape.js
var require_escape = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/escape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
    exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var xmlCodeMap = /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"]
    ]);
    exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? function(str2, index2) {
      return str2.codePointAt(index2);
    } : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(c6, index2) {
        return (c6.charCodeAt(index2) & 64512) === 55296 ? (c6.charCodeAt(index2) - 55296) * 1024 + c6.charCodeAt(index2 + 1) - 56320 + 65536 : c6.charCodeAt(index2);
      }
    );
    function encodeXML(str2) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = exports2.xmlReplacer.exec(str2)) !== null) {
        var i5 = match.index;
        var char = str2.charCodeAt(i5);
        var next = xmlCodeMap.get(char);
        if (next !== void 0) {
          ret += str2.substring(lastIdx, i5) + next;
          lastIdx = i5 + 1;
        } else {
          ret += "".concat(str2.substring(lastIdx, i5), "&#x").concat((0, exports2.getCodePoint)(str2, i5).toString(16), ";");
          lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
        }
      }
      return ret + str2.substr(lastIdx);
    }
    exports2.encodeXML = encodeXML;
    exports2.escape = encodeXML;
    function getEscaper(regex, map4) {
      return function escape2(data) {
        var match;
        var lastIdx = 0;
        var result2 = "";
        while (match = regex.exec(data)) {
          if (lastIdx !== match.index) {
            result2 += data.substring(lastIdx, match.index);
          }
          result2 += map4.get(match[0].charCodeAt(0));
          lastIdx = match.index + 1;
        }
        return result2 + data.substring(lastIdx);
      };
    }
    exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
    exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"]
    ]));
    exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"]
    ]));
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/encode.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeNonAsciiHTML = exports2.encodeHTML = void 0;
    var encode_html_js_1 = __importDefault2(require_encode_html());
    var escape_js_1 = require_escape();
    var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
    function encodeHTML(data) {
      return encodeHTMLTrieRe(htmlReplacer, data);
    }
    exports2.encodeHTML = encodeHTML;
    function encodeNonAsciiHTML(data) {
      return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
    }
    exports2.encodeNonAsciiHTML = encodeNonAsciiHTML;
    function encodeHTMLTrieRe(regExp, str2) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = regExp.exec(str2)) !== null) {
        var i5 = match.index;
        ret += str2.substring(lastIdx, i5);
        var char = str2.charCodeAt(i5);
        var next = encode_html_js_1.default.get(char);
        if (typeof next === "object") {
          if (i5 + 1 < str2.length) {
            var nextChar = str2.charCodeAt(i5 + 1);
            var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
            if (value !== void 0) {
              ret += value;
              lastIdx = regExp.lastIndex += 1;
              continue;
            }
          }
          next = next.v;
        }
        if (next !== void 0) {
          ret += next;
          lastIdx = i5 + 1;
        } else {
          var cp = (0, escape_js_1.getCodePoint)(str2, i5);
          ret += "&#x".concat(cp.toString(16), ";");
          lastIdx = regExp.lastIndex += Number(cp !== char);
        }
      }
      return ret + str2.substr(lastIdx);
    }
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/index.js
var require_lib10 = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLAttribute = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.DecodingMode = exports2.EntityDecoder = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = exports2.EncodingMode = exports2.EntityLevel = void 0;
    var decode_js_1 = require_decode2();
    var encode_js_1 = require_encode();
    var escape_js_1 = require_escape();
    var EntityLevel;
    (function(EntityLevel2) {
      EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
      EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
    })(EntityLevel = exports2.EntityLevel || (exports2.EntityLevel = {}));
    var EncodingMode;
    (function(EncodingMode2) {
      EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
      EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
      EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
      EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
      EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
    })(EncodingMode = exports2.EncodingMode || (exports2.EncodingMode = {}));
    function decode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var level = typeof options === "number" ? options : options.level;
      if (level === EntityLevel.HTML) {
        var mode = typeof options === "object" ? options.mode : void 0;
        return (0, decode_js_1.decodeHTML)(data, mode);
      }
      return (0, decode_js_1.decodeXML)(data);
    }
    exports2.decode = decode;
    function decodeStrict(data, options) {
      var _a;
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_1.DecodingMode.Strict;
      return decode(data, opts);
    }
    exports2.decodeStrict = decodeStrict;
    function encode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      if (opts.mode === EncodingMode.UTF8)
        return (0, escape_js_1.escapeUTF8)(data);
      if (opts.mode === EncodingMode.Attribute)
        return (0, escape_js_1.escapeAttribute)(data);
      if (opts.mode === EncodingMode.Text)
        return (0, escape_js_1.escapeText)(data);
      if (opts.level === EntityLevel.HTML) {
        if (opts.mode === EncodingMode.ASCII) {
          return (0, encode_js_1.encodeNonAsciiHTML)(data);
        }
        return (0, encode_js_1.encodeHTML)(data);
      }
      return (0, escape_js_1.encodeXML)(data);
    }
    exports2.encode = encode;
    var escape_js_2 = require_escape();
    Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
      return escape_js_2.encodeXML;
    } });
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
      return escape_js_2.escapeUTF8;
    } });
    Object.defineProperty(exports2, "escapeAttribute", { enumerable: true, get: function() {
      return escape_js_2.escapeAttribute;
    } });
    Object.defineProperty(exports2, "escapeText", { enumerable: true, get: function() {
      return escape_js_2.escapeText;
    } });
    var encode_js_2 = require_encode();
    Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    var decode_js_2 = require_decode2();
    Object.defineProperty(exports2, "EntityDecoder", { enumerable: true, get: function() {
      return decode_js_2.EntityDecoder;
    } });
    Object.defineProperty(exports2, "DecodingMode", { enumerable: true, get: function() {
      return decode_js_2.DecodingMode;
    } });
    Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
    Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeHTMLAttribute", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLAttribute;
    } });
    Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
  }
});

// ../../node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS({
  "../../node_modules/dom-serializer/lib/foreignNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attributeNames = exports2.elementNames = void 0;
    exports2.elementNames = new Map([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "textPath"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
    exports2.attributeNames = new Map([
      "definitionURL",
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPathUnits",
      "diffuseConstant",
      "edgeMode",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
  }
});

// ../../node_modules/dom-serializer/lib/index.js
var require_lib11 = __commonJS({
  "../../node_modules/dom-serializer/lib/index.js"(exports2) {
    "use strict";
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t10) {
        for (var s7, i5 = 1, n4 = arguments.length; i5 < n4; i5++) {
          s7 = arguments[i5];
          for (var p3 in s7)
            if (Object.prototype.hasOwnProperty.call(s7, p3))
              t10[p3] = s7[p3];
        }
        return t10;
      };
      return __assign2.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.render = void 0;
    var ElementType = __importStar(require_lib());
    var entities_1 = require_lib10();
    var foreignNames_js_1 = require_foreignNames();
    var unencodedElements = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function replaceQuotes(value) {
      return value.replace(/"/g, "&quot;");
    }
    function formatAttributes(attributes, opts) {
      var _a;
      if (!attributes)
        return;
      var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
      return Object.keys(attributes).map(function(key) {
        var _a2, _b;
        var value = (_a2 = attributes[key]) !== null && _a2 !== void 0 ? _a2 : "";
        if (opts.xmlMode === "foreign") {
          key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
          return key;
        }
        return "".concat(key, '="').concat(encode(value), '"');
      }).join(" ");
    }
    var singleTag = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function render(node, options) {
      if (options === void 0) {
        options = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i5 = 0; i5 < nodes.length; i5++) {
        output += renderNode(nodes[i5], options);
      }
      return output;
    }
    exports2.render = render;
    exports2.default = render;
    function renderNode(node, options) {
      switch (node.type) {
        case ElementType.Root:
          return render(node.children, options);
        case ElementType.Doctype:
        case ElementType.Directive:
          return renderDirective(node);
        case ElementType.Comment:
          return renderComment(node);
        case ElementType.CDATA:
          return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
          return renderTag(node, options);
        case ElementType.Text:
          return renderText2(node, options);
      }
    }
    var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag(elem, opts) {
      var _a;
      if (opts.xmlMode === "foreign") {
        elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
          opts = __assign2(__assign2({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign2(__assign2({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<".concat(elem.name);
      var attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
        tag += " ".concat(attribs);
      }
      if (elem.children.length === 0 && (opts.xmlMode ? (
        // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
        opts.selfClosingTags !== false
      ) : (
        // User explicitly asked for self-closing tags, even in HTML mode
        opts.selfClosingTags && singleTag.has(elem.name)
      ))) {
        if (!opts.xmlMode)
          tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
          tag += "</".concat(elem.name, ">");
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<".concat(elem.data, ">");
    }
    function renderText2(elem, opts) {
      var _a;
      var data = elem.data || "";
      if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
        data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[".concat(elem.children[0].data, "]]>");
    }
    function renderComment(elem) {
      return "<!--".concat(elem.data, "-->");
    }
  }
});

// ../../node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/domutils/lib/stringify.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.innerText = exports2.textContent = exports2.getText = exports2.getInnerHTML = exports2.getOuterHTML = void 0;
    var domhandler_1 = require_lib9();
    var dom_serializer_1 = __importDefault2(require_lib11());
    var domelementtype_1 = require_lib();
    function getOuterHTML(node, options) {
      return (0, dom_serializer_1.default)(node, options);
    }
    exports2.getOuterHTML = getOuterHTML;
    function getInnerHTML(node, options) {
      return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
        return getOuterHTML(node2, options);
      }).join("") : "";
    }
    exports2.getInnerHTML = getInnerHTML;
    function getText(node) {
      if (Array.isArray(node))
        return node.map(getText).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
      if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports2.getText = getText;
    function textContent(node) {
      if (Array.isArray(node))
        return node.map(textContent).join("");
      if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports2.textContent = textContent;
    function innerText(node) {
      if (Array.isArray(node))
        return node.map(innerText).join("");
      if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports2.innerText = innerText;
  }
});

// ../../node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "../../node_modules/domutils/lib/traversal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prevElementSibling = exports2.nextElementSibling = exports2.getName = exports2.hasAttrib = exports2.getAttributeValue = exports2.getSiblings = exports2.getParent = exports2.getChildren = void 0;
    var domhandler_1 = require_lib9();
    function getChildren(elem) {
      return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
    }
    exports2.getChildren = getChildren;
    function getParent(elem) {
      return elem.parent || null;
    }
    exports2.getParent = getParent;
    function getSiblings(elem) {
      var _a, _b;
      var parent = getParent(elem);
      if (parent != null)
        return getChildren(parent);
      var siblings = [elem];
      var prev = elem.prev, next = elem.next;
      while (prev != null) {
        siblings.unshift(prev);
        _a = prev, prev = _a.prev;
      }
      while (next != null) {
        siblings.push(next);
        _b = next, next = _b.next;
      }
      return siblings;
    }
    exports2.getSiblings = getSiblings;
    function getAttributeValue(elem, name2) {
      var _a;
      return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name2];
    }
    exports2.getAttributeValue = getAttributeValue;
    function hasAttrib(elem, name2) {
      return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
    }
    exports2.hasAttrib = hasAttrib;
    function getName(elem) {
      return elem.name;
    }
    exports2.getName = getName;
    function nextElementSibling(elem) {
      var _a;
      var next = elem.next;
      while (next !== null && !(0, domhandler_1.isTag)(next))
        _a = next, next = _a.next;
      return next;
    }
    exports2.nextElementSibling = nextElementSibling;
    function prevElementSibling(elem) {
      var _a;
      var prev = elem.prev;
      while (prev !== null && !(0, domhandler_1.isTag)(prev))
        _a = prev, prev = _a.prev;
      return prev;
    }
    exports2.prevElementSibling = prevElementSibling;
  }
});

// ../../node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "../../node_modules/domutils/lib/manipulation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepend = exports2.prependChild = exports2.append = exports2.appendChild = exports2.replaceElement = exports2.removeElement = void 0;
    function removeElement(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        var childsIndex = childs.lastIndexOf(elem);
        if (childsIndex >= 0) {
          childs.splice(childsIndex, 1);
        }
      }
      elem.next = null;
      elem.prev = null;
      elem.parent = null;
    }
    exports2.removeElement = removeElement;
    function replaceElement(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
        elem.parent = null;
      }
    }
    exports2.replaceElement = replaceElement;
    function appendChild(parent, child) {
      removeElement(child);
      child.next = null;
      child.parent = parent;
      if (parent.children.push(child) > 1) {
        var sibling = parent.children[parent.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    exports2.appendChild = appendChild;
    function append(elem, next) {
      removeElement(next);
      var parent = elem.parent;
      var currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    }
    exports2.append = append;
    function prependChild(parent, child) {
      removeElement(child);
      child.parent = parent;
      child.prev = null;
      if (parent.children.unshift(child) !== 1) {
        var sibling = parent.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    exports2.prependChild = prependChild;
    function prepend(elem, prev) {
      removeElement(prev);
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    }
    exports2.prepend = prepend;
  }
});

// ../../node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "../../node_modules/domutils/lib/querying.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findAll = exports2.existsOne = exports2.findOne = exports2.findOneChild = exports2.find = exports2.filter = void 0;
    var domhandler_1 = require_lib9();
    function filter2(test, node, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return find2(test, Array.isArray(node) ? node : [node], recurse, limit);
    }
    exports2.filter = filter2;
    function find2(test, nodes, recurse, limit) {
      var result2 = [];
      var nodeStack = [nodes];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (indexStack.length === 1) {
            return result2;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (test(elem)) {
          result2.push(elem);
          if (--limit <= 0)
            return result2;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    exports2.find = find2;
    function findOneChild(test, nodes) {
      return nodes.find(test);
    }
    exports2.findOneChild = findOneChild;
    function findOne(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var elem = null;
      for (var i5 = 0; i5 < nodes.length && !elem; i5++) {
        var node = nodes[i5];
        if (!(0, domhandler_1.isTag)(node)) {
          continue;
        } else if (test(node)) {
          elem = node;
        } else if (recurse && node.children.length > 0) {
          elem = findOne(test, node.children, true);
        }
      }
      return elem;
    }
    exports2.findOne = findOne;
    function existsOne(test, nodes) {
      return nodes.some(function(checked) {
        return (0, domhandler_1.isTag)(checked) && (test(checked) || existsOne(test, checked.children));
      });
    }
    exports2.existsOne = existsOne;
    function findAll(test, nodes) {
      var result2 = [];
      var nodeStack = [nodes];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (nodeStack.length === 1) {
            return result2;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (!(0, domhandler_1.isTag)(elem))
          continue;
        if (test(elem))
          result2.push(elem);
        if (elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    exports2.findAll = findAll;
  }
});

// ../../node_modules/domutils/lib/legacy.js
var require_legacy = __commonJS({
  "../../node_modules/domutils/lib/legacy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getElementsByTagType = exports2.getElementsByTagName = exports2.getElementById = exports2.getElements = exports2.testElement = void 0;
    var domhandler_1 = require_lib9();
    var querying_js_1 = require_querying();
    var Checks = {
      tag_name: function(name2) {
        if (typeof name2 === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && name2(elem.name);
          };
        } else if (name2 === "*") {
          return domhandler_1.isTag;
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name2;
        };
      },
      tag_type: function(type2) {
        if (typeof type2 === "function") {
          return function(elem) {
            return type2(elem.type);
          };
        }
        return function(elem) {
          return elem.type === type2;
        };
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && data(elem.data);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
      };
    }
    function combineFuncs(a4, b4) {
      return function(elem) {
        return a4(elem) || b4(elem);
      };
    }
    function compileTest(options) {
      var funcs = Object.keys(options).map(function(key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    function testElement(options, node) {
      var test = compileTest(options);
      return test ? test(node) : true;
    }
    exports2.testElement = testElement;
    function getElements(options, nodes, recurse, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var test = compileTest(options);
      return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
    }
    exports2.getElements = getElements;
    function getElementById(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes))
        nodes = [nodes];
      return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    exports2.getElementById = getElementById;
    function getElementsByTagName(tagName, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
    }
    exports2.getElementsByTagName = getElementsByTagName;
    function getElementsByTagType(type2, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_type"](type2), nodes, recurse, limit);
    }
    exports2.getElementsByTagType = getElementsByTagType;
  }
});

// ../../node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS({
  "../../node_modules/domutils/lib/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uniqueSort = exports2.compareDocumentPosition = exports2.DocumentPosition = exports2.removeSubsets = void 0;
    var domhandler_1 = require_lib9();
    function removeSubsets(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    exports2.removeSubsets = removeSubsets;
    var DocumentPosition;
    (function(DocumentPosition2) {
      DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
      DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
      DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
      DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
      DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
    })(DocumentPosition = exports2.DocumentPosition || (exports2.DocumentPosition = {}));
    function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return DocumentPosition.DISCONNECTED;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
        }
        return DocumentPosition.FOLLOWING;
      }
      if (sharedParent === nodeA) {
        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
      }
      return DocumentPosition.PRECEDING;
    }
    exports2.compareDocumentPosition = compareDocumentPosition;
    function uniqueSort(nodes) {
      nodes = nodes.filter(function(node, i5, arr) {
        return !arr.includes(node, i5 + 1);
      });
      nodes.sort(function(a4, b4) {
        var relative = compareDocumentPosition(a4, b4);
        if (relative & DocumentPosition.PRECEDING) {
          return -1;
        } else if (relative & DocumentPosition.FOLLOWING) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
    exports2.uniqueSort = uniqueSort;
  }
});

// ../../node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS({
  "../../node_modules/domutils/lib/feeds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFeed = void 0;
    var stringify_js_1 = require_stringify();
    var legacy_js_1 = require_legacy();
    function getFeed(doc) {
      var feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
    }
    exports2.getFeed = getFeed;
    function getAtomFeed(feedRoot) {
      var _a;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
          var _a2;
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "id", children);
          addConditionally(entry, "title", "title", children);
          var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
          if (href2) {
            entry.link = href2;
          }
          var description = fetch2("summary", children) || fetch2("content", children);
          if (description) {
            entry.description = description;
          }
          var pubDate = fetch2("updated", children);
          if (pubDate) {
            entry.pubDate = new Date(pubDate);
          }
          return entry;
        })
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
      if (href) {
        feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      var updated = fetch2("updated", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed(feedRoot) {
      var _a, _b;
      var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "guid", children);
          addConditionally(entry, "title", "title", children);
          addConditionally(entry, "link", "link", children);
          addConditionally(entry, "description", "description", children);
          var pubDate = fetch2("pubDate", children) || fetch2("dc:date", children);
          if (pubDate)
            entry.pubDate = new Date(pubDate);
          return entry;
        })
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      var updated = fetch2("lastBuildDate", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function getMediaElements(where2) {
      return (0, legacy_js_1.getElementsByTagName)("media:content", where2).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
          medium: attribs["medium"],
          isDefault: !!attribs["isDefault"]
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
          var attrib = MEDIA_KEYS_STRING_1[_i];
          if (attribs[attrib]) {
            media[attrib] = attribs[attrib];
          }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
          var attrib = MEDIA_KEYS_INT_1[_a];
          if (attribs[attrib]) {
            media[attrib] = parseInt(attribs[attrib], 10);
          }
        }
        if (attribs["expression"]) {
          media.expression = attribs["expression"];
        }
        return media;
      });
    }
    function getOneElement(tagName, node) {
      return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch2(tagName, where2, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where2, recurse, 1)).trim();
    }
    function addConditionally(obj, prop, tagName, where2, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val = fetch2(tagName, where2, recurse);
      if (val)
        obj[prop] = val;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
  }
});

// ../../node_modules/domutils/lib/index.js
var require_lib12 = __commonJS({
  "../../node_modules/domutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding(exports3, m4, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
    __exportStar(require_stringify(), exports2);
    __exportStar(require_traversal(), exports2);
    __exportStar(require_manipulation(), exports2);
    __exportStar(require_querying(), exports2);
    __exportStar(require_legacy(), exports2);
    __exportStar(require_helpers(), exports2);
    __exportStar(require_feeds(), exports2);
    var domhandler_1 = require_lib9();
    Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  }
});

// ../../node_modules/htmlparser2/lib/index.js
var require_lib13 = __commonJS({
  "../../node_modules/htmlparser2/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomUtils = exports2.parseFeed = exports2.getFeed = exports2.ElementType = exports2.Tokenizer = exports2.createDomStream = exports2.parseDOM = exports2.parseDocument = exports2.DefaultHandler = exports2.DomHandler = exports2.Parser = void 0;
    var Parser_js_1 = require_Parser();
    var Parser_js_2 = require_Parser();
    Object.defineProperty(exports2, "Parser", { enumerable: true, get: function() {
      return Parser_js_2.Parser;
    } });
    var domhandler_1 = require_lib9();
    var domhandler_2 = require_lib9();
    Object.defineProperty(exports2, "DomHandler", { enumerable: true, get: function() {
      return domhandler_2.DomHandler;
    } });
    Object.defineProperty(exports2, "DefaultHandler", { enumerable: true, get: function() {
      return domhandler_2.DomHandler;
    } });
    function parseDocument(data, options) {
      var handler = new domhandler_1.DomHandler(void 0, options);
      new Parser_js_1.Parser(handler, options).end(data);
      return handler.root;
    }
    exports2.parseDocument = parseDocument;
    function parseDOM(data, options) {
      return parseDocument(data, options).children;
    }
    exports2.parseDOM = parseDOM;
    function createDomStream(callback, options, elementCallback) {
      var handler = new domhandler_1.DomHandler(callback, options, elementCallback);
      return new Parser_js_1.Parser(handler, options);
    }
    exports2.createDomStream = createDomStream;
    var Tokenizer_js_1 = require_Tokenizer();
    Object.defineProperty(exports2, "Tokenizer", { enumerable: true, get: function() {
      return __importDefault2(Tokenizer_js_1).default;
    } });
    exports2.ElementType = __importStar(require_lib());
    var domutils_1 = require_lib12();
    var domutils_2 = require_lib12();
    Object.defineProperty(exports2, "getFeed", { enumerable: true, get: function() {
      return domutils_2.getFeed;
    } });
    var parseFeedDefaultOptions = { xmlMode: true };
    function parseFeed(feed, options) {
      if (options === void 0) {
        options = parseFeedDefaultOptions;
      }
      return (0, domutils_1.getFeed)(parseDOM(feed, options));
    }
    exports2.parseFeed = parseFeed;
    exports2.DomUtils = __importStar(require_lib12());
  }
});

// ../../node_modules/sanitize-html/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "../../node_modules/sanitize-html/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// ../../node_modules/sanitize-html/index.js
var require_sanitize_html = __commonJS({
  "../../node_modules/sanitize-html/index.js"(exports2, module2) {
    var htmlparser = require_lib13();
    var escapeStringRegexp = require_escape_string_regexp();
    var { isPlainObject } = require_is_plain_object();
    var deepmerge = require_cjs();
    var parseSrcset = require_parse_srcset();
    var { parse: postcssParse } = require_postcss();
    var mediaTags = [
      "img",
      "audio",
      "video",
      "picture",
      "svg",
      "object",
      "map",
      "iframe",
      "embed"
    ];
    var vulnerableTags = ["script", "style"];
    function each3(obj, cb2) {
      if (obj) {
        Object.keys(obj).forEach(function(key) {
          cb2(obj[key], key);
        });
      }
    }
    function has3(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    function filter2(a4, cb2) {
      const n4 = [];
      each3(a4, function(v2) {
        if (cb2(v2)) {
          n4.push(v2);
        }
      });
      return n4;
    }
    function isEmptyObject(obj) {
      for (const key in obj) {
        if (has3(obj, key)) {
          return false;
        }
      }
      return true;
    }
    function stringifySrcset(parsedSrcset) {
      return parsedSrcset.map(function(part) {
        if (!part.url) {
          throw new Error("URL missing");
        }
        return part.url + (part.w ? ` ${part.w}w` : "") + (part.h ? ` ${part.h}h` : "") + (part.d ? ` ${part.d}x` : "");
      }).join(", ");
    }
    module2.exports = sanitizeHtml;
    var VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;
    function sanitizeHtml(html, options, _recursing) {
      if (html == null) {
        return "";
      }
      if (typeof html === "number") {
        html = html.toString();
      }
      let result2 = "";
      let tempResult = "";
      function Frame(tag, attribs) {
        const that = this;
        this.tag = tag;
        this.attribs = attribs || {};
        this.tagPosition = result2.length;
        this.text = "";
        this.mediaChildren = [];
        this.updateParentNodeText = function() {
          if (stack.length) {
            const parentFrame = stack[stack.length - 1];
            parentFrame.text += that.text;
          }
        };
        this.updateParentNodeMediaChildren = function() {
          if (stack.length && mediaTags.includes(this.tag)) {
            const parentFrame = stack[stack.length - 1];
            parentFrame.mediaChildren.push(this.tag);
          }
        };
      }
      options = Object.assign({}, sanitizeHtml.defaults, options);
      options.parser = Object.assign({}, htmlParserDefaults, options.parser);
      const tagAllowed = function(name2) {
        return options.allowedTags === false || (options.allowedTags || []).indexOf(name2) > -1;
      };
      vulnerableTags.forEach(function(tag) {
        if (tagAllowed(tag) && !options.allowVulnerableTags) {
          console.warn(`

\u26A0\uFE0F Your \`allowedTags\` option includes, \`${tag}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
        }
      });
      const nonTextTagsArray = options.nonTextTags || [
        "script",
        "style",
        "textarea",
        "option"
      ];
      let allowedAttributesMap;
      let allowedAttributesGlobMap;
      if (options.allowedAttributes) {
        allowedAttributesMap = {};
        allowedAttributesGlobMap = {};
        each3(options.allowedAttributes, function(attributes, tag) {
          allowedAttributesMap[tag] = [];
          const globRegex = [];
          attributes.forEach(function(obj) {
            if (typeof obj === "string" && obj.indexOf("*") >= 0) {
              globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
            } else {
              allowedAttributesMap[tag].push(obj);
            }
          });
          if (globRegex.length) {
            allowedAttributesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
          }
        });
      }
      const allowedClassesMap = {};
      const allowedClassesGlobMap = {};
      const allowedClassesRegexMap = {};
      each3(options.allowedClasses, function(classes, tag) {
        if (allowedAttributesMap) {
          if (!has3(allowedAttributesMap, tag)) {
            allowedAttributesMap[tag] = [];
          }
          allowedAttributesMap[tag].push("class");
        }
        allowedClassesMap[tag] = classes;
        if (Array.isArray(classes)) {
          const globRegex = [];
          allowedClassesMap[tag] = [];
          allowedClassesRegexMap[tag] = [];
          classes.forEach(function(obj) {
            if (typeof obj === "string" && obj.indexOf("*") >= 0) {
              globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
            } else if (obj instanceof RegExp) {
              allowedClassesRegexMap[tag].push(obj);
            } else {
              allowedClassesMap[tag].push(obj);
            }
          });
          if (globRegex.length) {
            allowedClassesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
          }
        }
      });
      const transformTagsMap = {};
      let transformTagsAll;
      each3(options.transformTags, function(transform, tag) {
        let transFun;
        if (typeof transform === "function") {
          transFun = transform;
        } else if (typeof transform === "string") {
          transFun = sanitizeHtml.simpleTransform(transform);
        }
        if (tag === "*") {
          transformTagsAll = transFun;
        } else {
          transformTagsMap[tag] = transFun;
        }
      });
      let depth;
      let stack;
      let skipMap;
      let transformMap;
      let skipText;
      let skipTextDepth;
      let addedText = false;
      initializeState();
      const parser = new htmlparser.Parser({
        onopentag: function(name2, attribs) {
          if (options.enforceHtmlBoundary && name2 === "html") {
            initializeState();
          }
          if (skipText) {
            skipTextDepth++;
            return;
          }
          const frame = new Frame(name2, attribs);
          stack.push(frame);
          let skip = false;
          const hasText = !!frame.text;
          let transformedTag;
          if (has3(transformTagsMap, name2)) {
            transformedTag = transformTagsMap[name2](name2, attribs);
            frame.attribs = attribs = transformedTag.attribs;
            if (transformedTag.text !== void 0) {
              frame.innerText = transformedTag.text;
            }
            if (name2 !== transformedTag.tagName) {
              frame.name = name2 = transformedTag.tagName;
              transformMap[depth] = transformedTag.tagName;
            }
          }
          if (transformTagsAll) {
            transformedTag = transformTagsAll(name2, attribs);
            frame.attribs = attribs = transformedTag.attribs;
            if (name2 !== transformedTag.tagName) {
              frame.name = name2 = transformedTag.tagName;
              transformMap[depth] = transformedTag.tagName;
            }
          }
          if (!tagAllowed(name2) || options.disallowedTagsMode === "recursiveEscape" && !isEmptyObject(skipMap) || options.nestingLimit != null && depth >= options.nestingLimit) {
            skip = true;
            skipMap[depth] = true;
            if (options.disallowedTagsMode === "discard" || options.disallowedTagsMode === "completelyDiscard") {
              if (nonTextTagsArray.indexOf(name2) !== -1) {
                skipText = true;
                skipTextDepth = 1;
              }
            }
            skipMap[depth] = true;
          }
          depth++;
          if (skip) {
            if (options.disallowedTagsMode === "discard" || options.disallowedTagsMode === "completelyDiscard") {
              return;
            }
            tempResult = result2;
            result2 = "";
          }
          result2 += "<" + name2;
          if (name2 === "script") {
            if (options.allowedScriptHostnames || options.allowedScriptDomains) {
              frame.innerText = "";
            }
          }
          if (!allowedAttributesMap || has3(allowedAttributesMap, name2) || allowedAttributesMap["*"]) {
            each3(attribs, function(value, a4) {
              if (!VALID_HTML_ATTRIBUTE_NAME.test(a4)) {
                delete frame.attribs[a4];
                return;
              }
              if (value === "" && !options.allowedEmptyAttributes.includes(a4) && (options.nonBooleanAttributes.includes(a4) || options.nonBooleanAttributes.includes("*"))) {
                delete frame.attribs[a4];
                return;
              }
              let passedAllowedAttributesMapCheck = false;
              if (!allowedAttributesMap || has3(allowedAttributesMap, name2) && allowedAttributesMap[name2].indexOf(a4) !== -1 || allowedAttributesMap["*"] && allowedAttributesMap["*"].indexOf(a4) !== -1 || has3(allowedAttributesGlobMap, name2) && allowedAttributesGlobMap[name2].test(a4) || allowedAttributesGlobMap["*"] && allowedAttributesGlobMap["*"].test(a4)) {
                passedAllowedAttributesMapCheck = true;
              } else if (allowedAttributesMap && allowedAttributesMap[name2]) {
                for (const o10 of allowedAttributesMap[name2]) {
                  if (isPlainObject(o10) && o10.name && o10.name === a4) {
                    passedAllowedAttributesMapCheck = true;
                    let newValue = "";
                    if (o10.multiple === true) {
                      const splitStrArray = value.split(" ");
                      for (const s7 of splitStrArray) {
                        if (o10.values.indexOf(s7) !== -1) {
                          if (newValue === "") {
                            newValue = s7;
                          } else {
                            newValue += " " + s7;
                          }
                        }
                      }
                    } else if (o10.values.indexOf(value) >= 0) {
                      newValue = value;
                    }
                    value = newValue;
                  }
                }
              }
              if (passedAllowedAttributesMapCheck) {
                if (options.allowedSchemesAppliedToAttributes.indexOf(a4) !== -1) {
                  if (naughtyHref(name2, value)) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (name2 === "script" && a4 === "src") {
                  let allowed = true;
                  try {
                    const parsed = parseUrl(value);
                    if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                      const allowedHostname = (options.allowedScriptHostnames || []).find(function(hostname) {
                        return hostname === parsed.url.hostname;
                      });
                      const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {
                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                      });
                      allowed = allowedHostname || allowedDomain;
                    }
                  } catch (e4) {
                    allowed = false;
                  }
                  if (!allowed) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (name2 === "iframe" && a4 === "src") {
                  let allowed = true;
                  try {
                    const parsed = parseUrl(value);
                    if (parsed.isRelativeUrl) {
                      allowed = has3(options, "allowIframeRelativeUrls") ? options.allowIframeRelativeUrls : !options.allowedIframeHostnames && !options.allowedIframeDomains;
                    } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {
                      const allowedHostname = (options.allowedIframeHostnames || []).find(function(hostname) {
                        return hostname === parsed.url.hostname;
                      });
                      const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {
                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                      });
                      allowed = allowedHostname || allowedDomain;
                    }
                  } catch (e4) {
                    allowed = false;
                  }
                  if (!allowed) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (a4 === "srcset") {
                  try {
                    let parsed = parseSrcset(value);
                    parsed.forEach(function(value2) {
                      if (naughtyHref("srcset", value2.url)) {
                        value2.evil = true;
                      }
                    });
                    parsed = filter2(parsed, function(v2) {
                      return !v2.evil;
                    });
                    if (!parsed.length) {
                      delete frame.attribs[a4];
                      return;
                    } else {
                      value = stringifySrcset(filter2(parsed, function(v2) {
                        return !v2.evil;
                      }));
                      frame.attribs[a4] = value;
                    }
                  } catch (e4) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (a4 === "class") {
                  const allowedSpecificClasses = allowedClassesMap[name2];
                  const allowedWildcardClasses = allowedClassesMap["*"];
                  const allowedSpecificClassesGlob = allowedClassesGlobMap[name2];
                  const allowedSpecificClassesRegex = allowedClassesRegexMap[name2];
                  const allowedWildcardClassesGlob = allowedClassesGlobMap["*"];
                  const allowedClassesGlobs = [
                    allowedSpecificClassesGlob,
                    allowedWildcardClassesGlob
                  ].concat(allowedSpecificClassesRegex).filter(function(t10) {
                    return t10;
                  });
                  if (allowedSpecificClasses && allowedWildcardClasses) {
                    value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);
                  } else {
                    value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);
                  }
                  if (!value.length) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (a4 === "style") {
                  if (options.parseStyleAttributes) {
                    try {
                      const abstractSyntaxTree = postcssParse(name2 + " {" + value + "}", { map: false });
                      const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);
                      value = stringifyStyleAttributes(filteredAST);
                      if (value.length === 0) {
                        delete frame.attribs[a4];
                        return;
                      }
                    } catch (e4) {
                      if (typeof window !== "undefined") {
                        console.warn('Failed to parse "' + name2 + " {" + value + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`);
                      }
                      delete frame.attribs[a4];
                      return;
                    }
                  } else if (options.allowedStyles) {
                    throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
                  }
                }
                result2 += " " + a4;
                if (value && value.length) {
                  result2 += '="' + escapeHtml(value, true) + '"';
                } else if (options.allowedEmptyAttributes.includes(a4)) {
                  result2 += '=""';
                }
              } else {
                delete frame.attribs[a4];
              }
            });
          }
          if (options.selfClosing.indexOf(name2) !== -1) {
            result2 += " />";
          } else {
            result2 += ">";
            if (frame.innerText && !hasText && !options.textFilter) {
              result2 += escapeHtml(frame.innerText);
              addedText = true;
            }
          }
          if (skip) {
            result2 = tempResult + escapeHtml(result2);
            tempResult = "";
          }
        },
        ontext: function(text) {
          if (skipText) {
            return;
          }
          const lastFrame = stack[stack.length - 1];
          let tag;
          if (lastFrame) {
            tag = lastFrame.tag;
            text = lastFrame.innerText !== void 0 ? lastFrame.innerText : text;
          }
          if (options.disallowedTagsMode === "completelyDiscard" && !tagAllowed(tag)) {
            text = "";
          } else if ((options.disallowedTagsMode === "discard" || options.disallowedTagsMode === "completelyDiscard") && (tag === "script" || tag === "style")) {
            result2 += text;
          } else {
            const escaped = escapeHtml(text, false);
            if (options.textFilter && !addedText) {
              result2 += options.textFilter(escaped, tag);
            } else if (!addedText) {
              result2 += escaped;
            }
          }
          if (stack.length) {
            const frame = stack[stack.length - 1];
            frame.text += text;
          }
        },
        onclosetag: function(name2, isImplied) {
          if (skipText) {
            skipTextDepth--;
            if (!skipTextDepth) {
              skipText = false;
            } else {
              return;
            }
          }
          const frame = stack.pop();
          if (!frame) {
            return;
          }
          if (frame.tag !== name2) {
            stack.push(frame);
            return;
          }
          skipText = options.enforceHtmlBoundary ? name2 === "html" : false;
          depth--;
          const skip = skipMap[depth];
          if (skip) {
            delete skipMap[depth];
            if (options.disallowedTagsMode === "discard" || options.disallowedTagsMode === "completelyDiscard") {
              frame.updateParentNodeText();
              return;
            }
            tempResult = result2;
            result2 = "";
          }
          if (transformMap[depth]) {
            name2 = transformMap[depth];
            delete transformMap[depth];
          }
          if (options.exclusiveFilter && options.exclusiveFilter(frame)) {
            result2 = result2.substr(0, frame.tagPosition);
            return;
          }
          frame.updateParentNodeMediaChildren();
          frame.updateParentNodeText();
          if (
            // Already output />
            options.selfClosing.indexOf(name2) !== -1 || // Escaped tag, closing tag is implied
            isImplied && !tagAllowed(name2) && ["escape", "recursiveEscape"].indexOf(options.disallowedTagsMode) >= 0
          ) {
            if (skip) {
              result2 = tempResult;
              tempResult = "";
            }
            return;
          }
          result2 += "</" + name2 + ">";
          if (skip) {
            result2 = tempResult + escapeHtml(result2);
            tempResult = "";
          }
          addedText = false;
        }
      }, options.parser);
      parser.write(html);
      parser.end();
      return result2;
      function initializeState() {
        result2 = "";
        depth = 0;
        stack = [];
        skipMap = {};
        transformMap = {};
        skipText = false;
        skipTextDepth = 0;
      }
      function escapeHtml(s7, quote) {
        if (typeof s7 !== "string") {
          s7 = s7 + "";
        }
        if (options.parser.decodeEntities) {
          s7 = s7.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
          if (quote) {
            s7 = s7.replace(/"/g, "&quot;");
          }
        }
        s7 = s7.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        if (quote) {
          s7 = s7.replace(/"/g, "&quot;");
        }
        return s7;
      }
      function naughtyHref(name2, href) {
        href = href.replace(/[\x00-\x20]+/g, "");
        while (true) {
          const firstIndex = href.indexOf("<!--");
          if (firstIndex === -1) {
            break;
          }
          const lastIndex = href.indexOf("-->", firstIndex + 4);
          if (lastIndex === -1) {
            break;
          }
          href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);
        }
        const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
        if (!matches) {
          if (href.match(/^[/\\]{2}/)) {
            return !options.allowProtocolRelative;
          }
          return false;
        }
        const scheme = matches[1].toLowerCase();
        if (has3(options.allowedSchemesByTag, name2)) {
          return options.allowedSchemesByTag[name2].indexOf(scheme) === -1;
        }
        return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;
      }
      function parseUrl(value) {
        value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//");
        if (value.startsWith("relative:")) {
          throw new Error("relative: exploit attempt");
        }
        let base = "relative://relative-site";
        for (let i5 = 0; i5 < 100; i5++) {
          base += `/${i5}`;
        }
        const parsed = new URL(value, base);
        const isRelativeUrl = parsed && parsed.hostname === "relative-site" && parsed.protocol === "relative:";
        return {
          isRelativeUrl,
          url: parsed
        };
      }
      function filterCss(abstractSyntaxTree, allowedStyles) {
        if (!allowedStyles) {
          return abstractSyntaxTree;
        }
        const astRules = abstractSyntaxTree.nodes[0];
        let selectedRule;
        if (allowedStyles[astRules.selector] && allowedStyles["*"]) {
          selectedRule = deepmerge(
            allowedStyles[astRules.selector],
            allowedStyles["*"]
          );
        } else {
          selectedRule = allowedStyles[astRules.selector] || allowedStyles["*"];
        }
        if (selectedRule) {
          abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
        }
        return abstractSyntaxTree;
      }
      function stringifyStyleAttributes(filteredAST) {
        return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes, attrObject) {
          extractedAttributes.push(
            `${attrObject.prop}:${attrObject.value}${attrObject.important ? " !important" : ""}`
          );
          return extractedAttributes;
        }, []).join(";");
      }
      function filterDeclarations(selectedRule) {
        return function(allowedDeclarationsList, attributeObject) {
          if (has3(selectedRule, attributeObject.prop)) {
            const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
              return regularExpression.test(attributeObject.value);
            });
            if (matchesRegex) {
              allowedDeclarationsList.push(attributeObject);
            }
          }
          return allowedDeclarationsList;
        };
      }
      function filterClasses(classes, allowed, allowedGlobs) {
        if (!allowed) {
          return classes;
        }
        classes = classes.split(/\s+/);
        return classes.filter(function(clss) {
          return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {
            return glob.test(clss);
          });
        }).join(" ");
      }
    }
    var htmlParserDefaults = {
      decodeEntities: true
    };
    sanitizeHtml.defaults = {
      allowedTags: [
        // Sections derived from MDN element categories and limited to the more
        // benign categories.
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
        // Content sectioning
        "address",
        "article",
        "aside",
        "footer",
        "header",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hgroup",
        "main",
        "nav",
        "section",
        // Text content
        "blockquote",
        "dd",
        "div",
        "dl",
        "dt",
        "figcaption",
        "figure",
        "hr",
        "li",
        "main",
        "ol",
        "p",
        "pre",
        "ul",
        // Inline text semantics
        "a",
        "abbr",
        "b",
        "bdi",
        "bdo",
        "br",
        "cite",
        "code",
        "data",
        "dfn",
        "em",
        "i",
        "kbd",
        "mark",
        "q",
        "rb",
        "rp",
        "rt",
        "rtc",
        "ruby",
        "s",
        "samp",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "time",
        "u",
        "var",
        "wbr",
        // Table content
        "caption",
        "col",
        "colgroup",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "tr"
      ],
      // Tags that cannot be boolean
      nonBooleanAttributes: [
        "abbr",
        "accept",
        "accept-charset",
        "accesskey",
        "action",
        "allow",
        "alt",
        "as",
        "autocapitalize",
        "autocomplete",
        "blocking",
        "charset",
        "cite",
        "class",
        "color",
        "cols",
        "colspan",
        "content",
        "contenteditable",
        "coords",
        "crossorigin",
        "data",
        "datetime",
        "decoding",
        "dir",
        "dirname",
        "download",
        "draggable",
        "enctype",
        "enterkeyhint",
        "fetchpriority",
        "for",
        "form",
        "formaction",
        "formenctype",
        "formmethod",
        "formtarget",
        "headers",
        "height",
        "hidden",
        "high",
        "href",
        "hreflang",
        "http-equiv",
        "id",
        "imagesizes",
        "imagesrcset",
        "inputmode",
        "integrity",
        "is",
        "itemid",
        "itemprop",
        "itemref",
        "itemtype",
        "kind",
        "label",
        "lang",
        "list",
        "loading",
        "low",
        "max",
        "maxlength",
        "media",
        "method",
        "min",
        "minlength",
        "name",
        "nonce",
        "optimum",
        "pattern",
        "ping",
        "placeholder",
        "popover",
        "popovertarget",
        "popovertargetaction",
        "poster",
        "preload",
        "referrerpolicy",
        "rel",
        "rows",
        "rowspan",
        "sandbox",
        "scope",
        "shape",
        "size",
        "sizes",
        "slot",
        "span",
        "spellcheck",
        "src",
        "srcdoc",
        "srclang",
        "srcset",
        "start",
        "step",
        "style",
        "tabindex",
        "target",
        "title",
        "translate",
        "type",
        "usemap",
        "value",
        "width",
        "wrap",
        // Event handlers
        "onauxclick",
        "onafterprint",
        "onbeforematch",
        "onbeforeprint",
        "onbeforeunload",
        "onbeforetoggle",
        "onblur",
        "oncancel",
        "oncanplay",
        "oncanplaythrough",
        "onchange",
        "onclick",
        "onclose",
        "oncontextlost",
        "oncontextmenu",
        "oncontextrestored",
        "oncopy",
        "oncuechange",
        "oncut",
        "ondblclick",
        "ondrag",
        "ondragend",
        "ondragenter",
        "ondragleave",
        "ondragover",
        "ondragstart",
        "ondrop",
        "ondurationchange",
        "onemptied",
        "onended",
        "onerror",
        "onfocus",
        "onformdata",
        "onhashchange",
        "oninput",
        "oninvalid",
        "onkeydown",
        "onkeypress",
        "onkeyup",
        "onlanguagechange",
        "onload",
        "onloadeddata",
        "onloadedmetadata",
        "onloadstart",
        "onmessage",
        "onmessageerror",
        "onmousedown",
        "onmouseenter",
        "onmouseleave",
        "onmousemove",
        "onmouseout",
        "onmouseover",
        "onmouseup",
        "onoffline",
        "ononline",
        "onpagehide",
        "onpageshow",
        "onpaste",
        "onpause",
        "onplay",
        "onplaying",
        "onpopstate",
        "onprogress",
        "onratechange",
        "onreset",
        "onresize",
        "onrejectionhandled",
        "onscroll",
        "onscrollend",
        "onsecuritypolicyviolation",
        "onseeked",
        "onseeking",
        "onselect",
        "onslotchange",
        "onstalled",
        "onstorage",
        "onsubmit",
        "onsuspend",
        "ontimeupdate",
        "ontoggle",
        "onunhandledrejection",
        "onunload",
        "onvolumechange",
        "onwaiting",
        "onwheel"
      ],
      disallowedTagsMode: "discard",
      allowedAttributes: {
        a: ["href", "name", "target"],
        // We don't currently allow img itself by default, but
        // these attributes would make sense if we did.
        img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
      },
      allowedEmptyAttributes: [
        "alt"
      ],
      // Lots of these won't come up by default because we don't allow them
      selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
      // URL schemes we permit
      allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
      allowedSchemesByTag: {},
      allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
      allowProtocolRelative: true,
      enforceHtmlBoundary: false,
      parseStyleAttributes: true
    };
    sanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge2) {
      merge2 = merge2 === void 0 ? true : merge2;
      newAttribs = newAttribs || {};
      return function(tagName, attribs) {
        let attrib;
        if (merge2) {
          for (attrib in newAttribs) {
            attribs[attrib] = newAttribs[attrib];
          }
        } else {
          attribs = newAttribs;
        }
        return {
          tagName: newTagName,
          attribs
        };
      };
    };
  }
});

// ../../node_modules/@jupyter-widgets/base-manager/lib/manager-base.js
function default_inline_sanitize(s7) {
  const allowedTags = [
    "a",
    "abbr",
    "b",
    "code",
    "em",
    "i",
    "img",
    "li",
    "ol",
    "span",
    "strong",
    "ul"
  ];
  const allowedAttributes = {
    "*": ["aria-*", "class", "style", "title"],
    a: ["href"],
    img: ["src"],
    style: ["media", "type"]
  };
  return (0, import_sanitize_html.default)(s7, {
    allowedTags,
    allowedAttributes
  });
}
function serialize_state(models, options = {}) {
  const state = {};
  models.forEach((model) => {
    const model_id = model.model_id;
    const split = remove_buffers(model.serialize(model.get_state(options.drop_defaults)));
    const buffers = split.buffers.map((buffer, index2) => {
      return {
        data: bufferToBase64(buffer),
        path: split.buffer_paths[index2],
        encoding: "base64"
      };
    });
    state[model_id] = {
      model_name: model.name,
      model_module: model.module,
      model_module_version: model.get("_model_module_version"),
      state: split.state
    };
    if (buffers.length > 0) {
      state[model_id].buffers = buffers;
    }
  });
  return { version_major: 2, version_minor: 0, state };
}
var import_coreutils19, import_sanitize_html, PROTOCOL_MAJOR_VERSION, CONTROL_COMM_TARGET, CONTROL_COMM_PROTOCOL_VERSION, CONTROL_COMM_TIMEOUT, ManagerBase;
var init_manager_base = __esm({
  "../../node_modules/@jupyter-widgets/base-manager/lib/manager-base.js"() {
    init_lib10();
    import_coreutils19 = __toESM(require_dist());
    init_lib10();
    init_utils2();
    init_latex2();
    import_sanitize_html = __toESM(require_sanitize_html());
    PROTOCOL_MAJOR_VERSION = PROTOCOL_VERSION.split(".", 1)[0];
    CONTROL_COMM_TARGET = "jupyter.widget.control";
    CONTROL_COMM_PROTOCOL_VERSION = "1.0.0";
    CONTROL_COMM_TIMEOUT = 4e3;
    ManagerBase = class {
      constructor() {
        this.comm_target_name = "jupyter.widget";
        this._models = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Modifies view options. Generally overloaded in custom widget manager
       * implementations.
       */
      setViewOptions(options = {}) {
        return options;
      }
      create_view(model, options = {}) {
        const id = uuid();
        const viewPromise = model.state_change = model.state_change.then(async () => {
          const _view_name = model.get("_view_name");
          const _view_module = model.get("_view_module");
          try {
            const ViewType = await this.loadViewClass(_view_name, _view_module, model.get("_view_module_version"));
            const view = new ViewType({
              model,
              options: this.setViewOptions(options)
            });
            view.listenTo(model, "destroy", view.remove);
            await view.render();
            view.once("remove", () => {
              if (model.views) {
                delete model.views[id];
              }
            });
            return view;
          } catch (e4) {
            console.error(`Could not create a view for model id ${model.model_id}`);
            const msg = `Failed to create view for '${_view_name}' from module '${_view_module}' with model '${model.name}' from module '${model.module}'`;
            const ModelCls = createErrorWidgetModel(e4, msg);
            const errorModel = new ModelCls();
            const view = new ErrorWidgetView({
              model: errorModel,
              options: this.setViewOptions(options)
            });
            await view.render();
            return view;
          }
        });
        if (model.views) {
          model.views[id] = viewPromise;
        }
        return viewPromise;
      }
      /**
       * callback handlers specific to a view
       */
      callbacks(view) {
        return {};
      }
      /**
       * Get a promise for a model by model id.
       *
       * #### Notes
       * If the model is not found, the returned Promise object is rejected.
       *
       * If you would like to synchronously test if a model exists, use .has_model().
       */
      async get_model(model_id) {
        const modelPromise = this._models[model_id];
        if (modelPromise === void 0) {
          throw new Error("widget model not found");
        }
        return modelPromise;
      }
      /**
       * Returns true if the given model is registered, otherwise false.
       *
       * #### Notes
       * This is a synchronous way to check if a model is registered.
       */
      has_model(model_id) {
        return this._models[model_id] !== void 0;
      }
      /**
       * Handle when a comm is opened.
       */
      handle_comm_open(comm, msg) {
        const protocolVersion = (msg.metadata || {})["version"] || "";
        if (protocolVersion.split(".", 1)[0] !== PROTOCOL_MAJOR_VERSION) {
          const error = `Wrong widget protocol version: received protocol version '${protocolVersion}', but was expecting major version '${PROTOCOL_MAJOR_VERSION}'`;
          console.error(error);
          return Promise.reject(error);
        }
        const data = msg.content.data;
        const buffer_paths = data.buffer_paths || [];
        const buffers = msg.buffers || [];
        put_buffers(data.state, buffer_paths, buffers);
        return this.new_model({
          model_name: data.state["_model_name"],
          model_module: data.state["_model_module"],
          model_module_version: data.state["_model_module_version"],
          comm
        }, data.state).catch(reject("Could not create a model.", true));
      }
      /**
       * Create a comm and new widget model.
       * @param  options - same options as new_model but comm is not
       *                          required and additional options are available.
       * @param  serialized_state - serialized model attributes.
       */
      new_widget(options, serialized_state = {}) {
        let commPromise;
        if (options.view_name === void 0 || options.view_module === void 0 || options.view_module_version === void 0) {
          return Promise.reject("new_widget(...) must be given view information in the options.");
        }
        if (options.comm) {
          commPromise = Promise.resolve(options.comm);
        } else {
          commPromise = this._create_comm(this.comm_target_name, options.model_id, {
            state: {
              _model_module: options.model_module,
              _model_module_version: options.model_module_version,
              _model_name: options.model_name,
              _view_module: options.view_module,
              _view_module_version: options.view_module_version,
              _view_name: options.view_name
            }
          }, { version: PROTOCOL_VERSION });
        }
        const options_clone = Object.assign({}, options);
        return commPromise.then((comm) => {
          options_clone.comm = comm;
          const widget_model = this.new_model(options_clone, serialized_state);
          return widget_model.then((model) => {
            model.sync("create", model);
            return model;
          });
        }, () => {
          if (!options_clone.model_id) {
            options_clone.model_id = uuid();
          }
          return this.new_model(options_clone, serialized_state);
        });
      }
      register_model(model_id, modelPromise) {
        this._models[model_id] = modelPromise;
        modelPromise.then((model) => {
          model.once("comm:close", () => {
            delete this._models[model_id];
          });
        });
      }
      /**
       * Create and return a promise for a new widget model
       *
       * @param options - the options for creating the model.
       * @param serialized_state - attribute values for the model.
       *
       * @example
       * widget_manager.new_model({
       *      model_name: 'IntSlider',
       *      model_module: '@jupyter-widgets/controls',
       *      model_module_version: '1.0.0',
       *      model_id: 'u-u-i-d'
       * }).then((model) => { console.log('Create success!', model); },
       *  (err) => {console.error(err)});
       *
       */
      async new_model(options, serialized_state = {}) {
        var _a, _b;
        const model_id = (_a = options.model_id) !== null && _a !== void 0 ? _a : (_b = options.comm) === null || _b === void 0 ? void 0 : _b.comm_id;
        if (!model_id) {
          throw new Error("Neither comm nor model_id provided in options object. At least one must exist.");
        }
        options.model_id = model_id;
        const modelPromise = this._make_model(options, serialized_state);
        this.register_model(model_id, modelPromise);
        return await modelPromise;
      }
      /**
       * Fetch all widgets states from the kernel using the control comm channel
       * If this fails (control comm handler not implemented kernel side),
       * it will fall back to `_loadFromKernelModels`.
       *
       * This is a utility function that can be used in subclasses.
       */
      async _loadFromKernel() {
        let data;
        let buffers;
        try {
          const initComm = await this._create_comm(CONTROL_COMM_TARGET, uuid(), {}, { version: CONTROL_COMM_PROTOCOL_VERSION });
          await new Promise((resolve, reject4) => {
            initComm.on_msg((msg) => {
              data = msg["content"]["data"];
              if (data.method !== "update_states") {
                console.warn(`
              Unknown ${data.method} message on the Control channel
            `);
                return;
              }
              buffers = (msg.buffers || []).map((b4) => {
                if (b4 instanceof DataView) {
                  return b4;
                } else {
                  return new DataView(b4 instanceof ArrayBuffer ? b4 : b4.buffer);
                }
              });
              resolve(null);
            });
            initComm.on_close(() => reject4("Control comm was closed too early"));
            initComm.send({ method: "request_states" }, {});
            setTimeout(() => reject4("Control comm did not respond in time"), CONTROL_COMM_TIMEOUT);
          });
          initComm.close();
        } catch (error) {
          console.warn('Failed to fetch ipywidgets through the "jupyter.widget.control" comm channel, fallback to fetching individual model state. Reason:', error);
          return this._loadFromKernelModels();
        }
        const states = data.states;
        const bufferPaths = {};
        const bufferGroups = {};
        for (let i5 = 0; i5 < data.buffer_paths.length; i5++) {
          const [widget_id, ...path2] = data.buffer_paths[i5];
          const b4 = buffers[i5];
          if (!bufferPaths[widget_id]) {
            bufferPaths[widget_id] = [];
            bufferGroups[widget_id] = [];
          }
          bufferPaths[widget_id].push(path2);
          bufferGroups[widget_id].push(b4);
        }
        const widget_comms = await Promise.all(Object.keys(states).map(async (widget_id) => {
          const comm = this.has_model(widget_id) ? void 0 : await this._create_comm("jupyter.widget", widget_id);
          return { widget_id, comm };
        }));
        await Promise.all(widget_comms.map(async ({ widget_id, comm }) => {
          const state = states[widget_id];
          if (widget_id in bufferPaths) {
            put_buffers(state, bufferPaths[widget_id], bufferGroups[widget_id]);
          }
          try {
            if (comm) {
              await this.new_model({
                model_name: state.model_name,
                model_module: state.model_module,
                model_module_version: state.model_module_version,
                model_id: widget_id,
                comm
              }, state.state);
            } else {
              const model = await this.get_model(widget_id);
              const deserializedState = await model.constructor._deserialize_state(state.state, this);
              model.set_state(deserializedState);
            }
          } catch (error) {
            console.error(error);
          }
        }));
      }
      /**
       * Old implementation of fetching widget models one by one using
       * the request_state message on each comm.
       *
       * This is a utility function that can be used in subclasses.
       */
      async _loadFromKernelModels() {
        const comm_ids = await this._get_comm_info();
        const widgets_info = await Promise.all(Object.keys(comm_ids).map(async (comm_id) => {
          if (this.has_model(comm_id)) {
            return;
          }
          const comm = await this._create_comm(this.comm_target_name, comm_id);
          let msg_id = "";
          const info = new import_coreutils19.PromiseDelegate();
          comm.on_msg((msg) => {
            if (msg.parent_header.msg_id === msg_id && msg.header.msg_type === "comm_msg" && msg.content.data.method === "update") {
              const data = msg.content.data;
              const buffer_paths = data.buffer_paths || [];
              const buffers = msg.buffers || [];
              put_buffers(data.state, buffer_paths, buffers);
              info.resolve({ comm, msg });
            }
          });
          msg_id = comm.send({
            method: "request_state"
          }, this.callbacks(void 0));
          return info.promise;
        }));
        await Promise.all(widgets_info.map(async (widget_info) => {
          if (!widget_info) {
            return;
          }
          const content = widget_info.msg.content;
          await this.new_model({
            model_name: content.data.state._model_name,
            model_module: content.data.state._model_module,
            model_module_version: content.data.state._model_module_version,
            comm: widget_info.comm
          }, content.data.state);
        }));
      }
      async _make_model(options, serialized_state = {}) {
        const model_id = options.model_id;
        const model_promise = this.loadModelClass(options.model_name, options.model_module, options.model_module_version);
        let ModelType;
        const makeErrorModel = (error, msg) => {
          const Cls = createErrorWidgetModel(error, msg);
          const widget_model2 = new Cls();
          return widget_model2;
        };
        try {
          ModelType = await model_promise;
        } catch (error) {
          const msg = "Could not instantiate widget";
          console.error(msg);
          return makeErrorModel(error, msg);
        }
        if (!ModelType) {
          const msg = "Could not instantiate widget";
          console.error(msg);
          const error = new Error(`Cannot find model module ${options.model_module}@${options.model_module_version}, ${options.model_name}`);
          return makeErrorModel(error, msg);
        }
        let widget_model;
        try {
          const attributes = await ModelType._deserialize_state(serialized_state, this);
          const modelOptions = {
            widget_manager: this,
            model_id,
            comm: options.comm
          };
          widget_model = new ModelType(attributes, modelOptions);
        } catch (error) {
          console.error(error);
          const msg = `Model class '${options.model_name}' from module '${options.model_module}' is loaded but can not be instantiated`;
          widget_model = makeErrorModel(error, msg);
        }
        widget_model.name = options.model_name;
        widget_model.module = options.model_module;
        return widget_model;
      }
      /**
       * Close all widgets and empty the widget state.
       * @return Promise that resolves when the widget state is cleared.
       */
      clear_state() {
        return resolvePromisesDict(this._models).then((models) => {
          Object.keys(models).forEach((id) => models[id].close());
          this._models = /* @__PURE__ */ Object.create(null);
        });
      }
      /**
       * Asynchronously get the state of the widget manager.
       *
       * This includes all of the widget models, and follows the format given in
       * the @jupyter-widgets/schema package.
       *
       * @param options - The options for what state to return.
       * @returns Promise for a state dictionary
       */
      get_state(options = {}) {
        const modelPromises = Object.keys(this._models).map((id) => this._models[id]);
        return Promise.all(modelPromises).then((models) => {
          return serialize_state(models, options);
        });
      }
      /**
       * Set the widget manager state.
       *
       * @param state - a Javascript object conforming to the application/vnd.jupyter.widget-state+json spec.
       *
       * Reconstructs all of the widget models in the state, merges that with the
       * current manager state, and then attempts to redisplay the widgets in the
       * state.
       */
      set_state(state) {
        if (!(state.version_major && state.version_major <= 2)) {
          throw "Unsupported widget state format";
        }
        const models = state.state;
        const all_models = this._get_comm_info().then((live_comms) => {
          return Promise.all(Object.keys(models).map((model_id) => {
            const decode = {
              base64: base64ToBuffer,
              hex: hexToBuffer
            };
            const model = models[model_id];
            const modelState = model.state;
            if (model.buffers) {
              const bufferPaths = model.buffers.map((b4) => b4.path);
              const buffers = model.buffers.map((b4) => new DataView(decode[b4.encoding](b4.data)));
              put_buffers(model.state, bufferPaths, buffers);
            }
            if (this.has_model(model_id)) {
              return this.get_model(model_id).then((model2) => {
                return model2.constructor._deserialize_state(modelState || {}, this).then((attributes) => {
                  model2.set_state(attributes);
                  return model2;
                });
              });
            }
            const modelCreate = {
              model_id,
              model_name: model.model_name,
              model_module: model.model_module,
              model_module_version: model.model_module_version
            };
            if (Object.prototype.hasOwnProperty.call(live_comms, "model_id")) {
              return this._create_comm(this.comm_target_name, model_id).then((comm) => {
                modelCreate.comm = comm;
                return this.new_model(modelCreate);
              });
            } else {
              return this.new_model(modelCreate, modelState);
            }
          }));
        });
        return all_models;
      }
      /**
       * Disconnect the widget manager from the kernel, setting each model's comm
       * as dead.
       */
      disconnect() {
        Object.keys(this._models).forEach((i5) => {
          this._models[i5].then((model) => {
            model.comm_live = false;
          });
        });
      }
      /**
       * Resolve a URL relative to the current notebook location.
       *
       * The default implementation just returns the original url.
       */
      resolveUrl(url) {
        return Promise.resolve(url);
      }
      inline_sanitize(source) {
        const parts = removeMath2(source);
        const sanitized = default_inline_sanitize(parts["text"]);
        return replaceMath2(sanitized, parts["math"]);
      }
      async loadModelClass(className, moduleName, moduleVersion) {
        try {
          const promise = this.loadClass(className, moduleName, moduleVersion);
          await promise;
          return promise;
        } catch (error) {
          console.error(error);
          const msg = `Failed to load model class '${className}' from module '${moduleName}'`;
          return createErrorWidgetModel(error, msg);
        }
      }
      async loadViewClass(className, moduleName, moduleVersion) {
        try {
          const promise = this.loadClass(className, moduleName, moduleVersion);
          await promise;
          return promise;
        } catch (error) {
          console.error(error);
          const msg = `Failed to load view class '${className}' from module '${moduleName}'`;
          return createErrorWidgetView(error, msg);
        }
      }
      /**
       * Filter serialized widget state to remove any ID's already present in manager.
       *
       * @param {*} state Serialized state to filter
       *
       * @returns {*} A copy of the state, with its 'state' attribute filtered
       */
      filterExistingModelState(serialized_state) {
        let models = serialized_state.state;
        models = Object.keys(models).filter((model_id) => !this.has_model(model_id)).reduce((res, model_id) => {
          res[model_id] = models[model_id];
          return res;
        }, {});
        return Object.assign(Object.assign({}, serialized_state), { state: models });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base-manager/lib/index.js
var init_lib11 = __esm({
  "../../node_modules/@jupyter-widgets/base-manager/lib/index.js"() {
    init_manager_base();
    init_utils2();
  }
});

// ../../node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "../../node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// ../../node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "../../node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// ../../node_modules/semver/internal/re.js
var require_re = __commonJS({
  "../../node_modules/semver/internal/re.js"(exports2, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t10 = exports2.t = {};
    var R2 = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max3] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max3}}`).split(`${token}+`).join(`${token}{1,${max3}}`);
      }
      return value;
    };
    var createToken = (name2, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index2 = R2++;
      debug(name2, index2, value);
      t10[name2] = index2;
      src[index2] = value;
      re[index2] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t10.NUMERICIDENTIFIER]})\\.(${src[t10.NUMERICIDENTIFIER]})\\.(${src[t10.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t10.NUMERICIDENTIFIERLOOSE]})\\.(${src[t10.NUMERICIDENTIFIERLOOSE]})\\.(${src[t10.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t10.NUMERICIDENTIFIER]}|${src[t10.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t10.NUMERICIDENTIFIERLOOSE]}|${src[t10.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t10.PRERELEASEIDENTIFIER]}(?:\\.${src[t10.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t10.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t10.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t10.BUILDIDENTIFIER]}(?:\\.${src[t10.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t10.MAINVERSION]}${src[t10.PRERELEASE]}?${src[t10.BUILD]}?`);
    createToken("FULL", `^${src[t10.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t10.MAINVERSIONLOOSE]}${src[t10.PRERELEASELOOSE]}?${src[t10.BUILD]}?`);
    createToken("LOOSE", `^${src[t10.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t10.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t10.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t10.XRANGEIDENTIFIER]})(?:\\.(${src[t10.XRANGEIDENTIFIER]})(?:\\.(${src[t10.XRANGEIDENTIFIER]})(?:${src[t10.PRERELEASE]})?${src[t10.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t10.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t10.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t10.XRANGEIDENTIFIERLOOSE]})(?:${src[t10.PRERELEASELOOSE]})?${src[t10.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t10.GTLT]}\\s*${src[t10.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t10.GTLT]}\\s*${src[t10.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t10.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t10.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t10.LONETILDE]}${src[t10.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t10.LONETILDE]}${src[t10.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t10.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t10.LONECARET]}${src[t10.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t10.LONECARET]}${src[t10.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t10.GTLT]}\\s*(${src[t10.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t10.GTLT]}\\s*(${src[t10.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t10.GTLT]}\\s*(${src[t10.LOOSEPLAIN]}|${src[t10.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t10.XRANGEPLAIN]})\\s+-\\s+(${src[t10.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t10.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t10.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// ../../node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "../../node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// ../../node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "../../node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a4, b4) => {
      const anum = numeric.test(a4);
      const bnum = numeric.test(b4);
      if (anum && bnum) {
        a4 = +a4;
        b4 = +b4;
      }
      return a4 === b4 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a4 < b4 ? -1 : 1;
    };
    var rcompareIdentifiers = (a4, b4) => compareIdentifiers(b4, a4);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// ../../node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "../../node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t: t10 } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m4 = version2.trim().match(options.loose ? re[t10.LOOSE] : re[t10.FULL]);
        if (!m4) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m4[1];
        this.minor = +m4[2];
        this.patch = +m4[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m4[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m4[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m4[5] ? m4[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i5 = 0;
        do {
          const a4 = this.prerelease[i5];
          const b4 = other.prerelease[i5];
          debug("prerelease compare", i5, a4, b4);
          if (a4 === void 0 && b4 === void 0) {
            return 0;
          } else if (b4 === void 0) {
            return 1;
          } else if (a4 === void 0) {
            return -1;
          } else if (a4 === b4) {
            continue;
          } else {
            return compareIdentifiers(a4, b4);
          }
        } while (++i5);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i5 = 0;
        do {
          const a4 = this.build[i5];
          const b4 = other.build[i5];
          debug("prerelease compare", i5, a4, b4);
          if (a4 === void 0 && b4 === void 0) {
            return 0;
          } else if (b4 === void 0) {
            return 1;
          } else if (a4 === void 0) {
            return -1;
          } else if (a4 === b4) {
            continue;
          } else {
            return compareIdentifiers(a4, b4);
          }
        } while (++i5);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i5 = this.prerelease.length;
              while (--i5 >= 0) {
                if (typeof this.prerelease[i5] === "number") {
                  this.prerelease[i5]++;
                  i5 = -2;
                }
              }
              if (i5 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// ../../node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "../../node_modules/semver/functions/parse.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse4 = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse4;
  }
});

// ../../node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "../../node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse4 = require_parse();
    var valid2 = (version2, options) => {
      const v2 = parse4(version2, options);
      return v2 ? v2.version : null;
    };
    module2.exports = valid2;
  }
});

// ../../node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "../../node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse4 = require_parse();
    var clean = (version2, options) => {
      const s7 = parse4(version2.trim().replace(/^[=v]+/, ""), options);
      return s7 ? s7.version : null;
    };
    module2.exports = clean;
  }
});

// ../../node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "../../node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// ../../node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "../../node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse4 = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse4(version1, null, true);
      const v2 = parse4(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// ../../node_modules/semver/functions/major.js
var require_major = __commonJS({
  "../../node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major = (a4, loose) => new SemVer(a4, loose).major;
    module2.exports = major;
  }
});

// ../../node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "../../node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a4, loose) => new SemVer(a4, loose).minor;
    module2.exports = minor;
  }
});

// ../../node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "../../node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a4, loose) => new SemVer(a4, loose).patch;
    module2.exports = patch;
  }
});

// ../../node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "../../node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse4 = require_parse();
    var prerelease = (version2, options) => {
      const parsed = parse4(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// ../../node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "../../node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare2 = (a4, b4, loose) => new SemVer(a4, loose).compare(new SemVer(b4, loose));
    module2.exports = compare2;
  }
});

// ../../node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "../../node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare2 = require_compare();
    var rcompare = (a4, b4, loose) => compare2(b4, a4, loose);
    module2.exports = rcompare;
  }
});

// ../../node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "../../node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare2 = require_compare();
    var compareLoose = (a4, b4) => compare2(a4, b4, true);
    module2.exports = compareLoose;
  }
});

// ../../node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "../../node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a4, b4, loose) => {
      const versionA = new SemVer(a4, loose);
      const versionB = new SemVer(b4, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// ../../node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "../../node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a4, b4) => compareBuild(a4, b4, loose));
    module2.exports = sort;
  }
});

// ../../node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "../../node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a4, b4) => compareBuild(b4, a4, loose));
    module2.exports = rsort;
  }
});

// ../../node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "../../node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare2 = require_compare();
    var gt = (a4, b4, loose) => compare2(a4, b4, loose) > 0;
    module2.exports = gt;
  }
});

// ../../node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "../../node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare2 = require_compare();
    var lt = (a4, b4, loose) => compare2(a4, b4, loose) < 0;
    module2.exports = lt;
  }
});

// ../../node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "../../node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare2 = require_compare();
    var eq2 = (a4, b4, loose) => compare2(a4, b4, loose) === 0;
    module2.exports = eq2;
  }
});

// ../../node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "../../node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare2 = require_compare();
    var neq = (a4, b4, loose) => compare2(a4, b4, loose) !== 0;
    module2.exports = neq;
  }
});

// ../../node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "../../node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare2 = require_compare();
    var gte = (a4, b4, loose) => compare2(a4, b4, loose) >= 0;
    module2.exports = gte;
  }
});

// ../../node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "../../node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare2 = require_compare();
    var lte = (a4, b4, loose) => compare2(a4, b4, loose) <= 0;
    module2.exports = lte;
  }
});

// ../../node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "../../node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq2 = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a4, op, b4, loose) => {
      switch (op) {
        case "===":
          if (typeof a4 === "object") {
            a4 = a4.version;
          }
          if (typeof b4 === "object") {
            b4 = b4.version;
          }
          return a4 === b4;
        case "!==":
          if (typeof a4 === "object") {
            a4 = a4.version;
          }
          if (typeof b4 === "object") {
            b4 = b4.version;
          }
          return a4 !== b4;
        case "":
        case "=":
        case "==":
          return eq2(a4, b4, loose);
        case "!=":
          return neq(a4, b4, loose);
        case ">":
          return gt(a4, b4, loose);
        case ">=":
          return gte(a4, b4, loose);
        case "<":
          return lt(a4, b4, loose);
        case "<=":
          return lte(a4, b4, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// ../../node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "../../node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse4 = require_parse();
    var { safeRe: re, t: t10 } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(re[t10.COERCE]);
      } else {
        let next;
        while ((next = re[t10.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t10.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t10.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse4(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// ../../node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "../../node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// ../../node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "../../node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node2;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i5 = 0, l7 = arguments.length; i5 < l7; i5++) {
          self2.push(arguments[i5]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i5 = 0, l7 = arguments.length; i5 < l7; i5++) {
        push2(this, arguments[i5]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i5 = 0, l7 = arguments.length; i5 < l7; i5++) {
        unshift(this, arguments[i5]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i5 = 0; walker !== null; i5++) {
        fn.call(thisp, walker.value, i5, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i5 = this.length - 1; walker !== null; i5--) {
        fn.call(thisp, walker.value, i5, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n4) {
      for (var i5 = 0, walker = this.head; walker !== null && i5 < n4; i5++) {
        walker = walker.next;
      }
      if (i5 === n4 && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n4) {
      for (var i5 = 0, walker = this.tail; walker !== null && i5 < n4; i5++) {
        walker = walker.prev;
      }
      if (i5 === n4 && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial2) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial2;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i5 = 0; walker !== null; i5++) {
        acc = fn(acc, walker.value, i5);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial2) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial2;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i5 = this.length - 1; walker !== null; i5--) {
        acc = fn(acc, walker.value, i5);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i5 = 0, walker = this.head; walker !== null; i5++) {
        arr[i5] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i5 = 0, walker = this.tail; walker !== null; i5++) {
        arr[i5] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i5 = 0, walker = this.head; walker !== null && i5 < from; i5++) {
        walker = walker.next;
      }
      for (; walker !== null && i5 < to; i5++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i5 = this.length, walker = this.tail; walker !== null && i5 > to; i5--) {
        walker = walker.prev;
      }
      for (; walker !== null && i5 > from; i5--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i5 = 0, walker = this.head; walker !== null && i5 < start; i5++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i5 = 0; walker && i5 < deleteCount; i5++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i5 = 0; i5 < nodes.length; i5++) {
        walker = insert(this, walker, nodes[i5]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p3 = walker.prev;
        walker.prev = walker.next;
        walker.next = p3;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push2(self2, item) {
      self2.tail = new Node2(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node2(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node2(value, prev, next, list) {
      if (!(this instanceof Node2)) {
        return new Node2(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// ../../node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../../node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max3 = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim2(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim2(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim2(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h4) => h4);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim2(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim2(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get2(this, key, true);
      }
      peek(key) {
        return get2(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l7 = arr.length - 1; l7 >= 0; l7--) {
          const hit = arr[l7];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get2(this, key, false));
      }
    };
    var get2 = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim2 = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// ../../node_modules/semver/classes/range.js
var require_range = __commonJS({
  "../../node_modules/semver/classes/range.js"(exports2, module2) {
    var Range = class {
      constructor(range2, options) {
        options = parseOptions(options);
        if (range2 instanceof Range) {
          if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
            return range2;
          } else {
            return new Range(range2.raw, options);
          }
        }
        if (range2 instanceof Comparator) {
          this.raw = range2.value;
          this.set = [[range2]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range2.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r4) => this.parseRange(r4.trim())).filter((c6) => c6.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first2 = this.set[0];
          this.set = this.set.filter((c6) => !isNullSet(c6[0]));
          if (this.set.length === 0) {
            this.set = [first2];
          } else if (this.set.length > 1) {
            for (const c6 of this.set) {
              if (c6.length === 1 && isAny(c6[0])) {
                this.set = [c6];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range2) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range2;
        const cached = cache2.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t10.HYPHENRANGELOOSE] : re[t10.HYPHENRANGE];
        range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range2);
        range2 = range2.replace(re[t10.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range2);
        range2 = range2.replace(re[t10.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range2);
        range2 = range2.replace(re[t10.CARETTRIM], caretTrimReplace);
        debug("caret trim", range2);
        let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t10.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result2 = [...rangeMap.values()];
        cache2.set(memoKey, result2);
        return result2;
      }
      intersects(range2, options) {
        if (!(range2 instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i5 = 0; i5 < this.set.length; i5++) {
          if (testSet(this.set[i5], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache2 = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t: t10,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c6) => c6.value === "<0.0.0-0";
    var isAny = (c6) => c6.value === "";
    var isSatisfiable = (comparators, options) => {
      let result2 = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result2 && remainingComparators.length) {
        result2 = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result2;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c6) => replaceTilde(c6, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r4 = options.loose ? re[t10.TILDELOOSE] : re[t10.TILDE];
      return comp.replace(r4, (_5, M4, m4, p3, pr) => {
        debug("tilde", comp, _5, M4, m4, p3, pr);
        let ret;
        if (isX(M4)) {
          ret = "";
        } else if (isX(m4)) {
          ret = `>=${M4}.0.0 <${+M4 + 1}.0.0-0`;
        } else if (isX(p3)) {
          ret = `>=${M4}.${m4}.0 <${M4}.${+m4 + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M4}.${m4}.${p3}-${pr} <${M4}.${+m4 + 1}.0-0`;
        } else {
          ret = `>=${M4}.${m4}.${p3} <${M4}.${+m4 + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c6) => replaceCaret(c6, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r4 = options.loose ? re[t10.CARETLOOSE] : re[t10.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r4, (_5, M4, m4, p3, pr) => {
        debug("caret", comp, _5, M4, m4, p3, pr);
        let ret;
        if (isX(M4)) {
          ret = "";
        } else if (isX(m4)) {
          ret = `>=${M4}.0.0${z2} <${+M4 + 1}.0.0-0`;
        } else if (isX(p3)) {
          if (M4 === "0") {
            ret = `>=${M4}.${m4}.0${z2} <${M4}.${+m4 + 1}.0-0`;
          } else {
            ret = `>=${M4}.${m4}.0${z2} <${+M4 + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M4 === "0") {
            if (m4 === "0") {
              ret = `>=${M4}.${m4}.${p3}-${pr} <${M4}.${m4}.${+p3 + 1}-0`;
            } else {
              ret = `>=${M4}.${m4}.${p3}-${pr} <${M4}.${+m4 + 1}.0-0`;
            }
          } else {
            ret = `>=${M4}.${m4}.${p3}-${pr} <${+M4 + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M4 === "0") {
            if (m4 === "0") {
              ret = `>=${M4}.${m4}.${p3}${z2} <${M4}.${m4}.${+p3 + 1}-0`;
            } else {
              ret = `>=${M4}.${m4}.${p3}${z2} <${M4}.${+m4 + 1}.0-0`;
            }
          } else {
            ret = `>=${M4}.${m4}.${p3} <${+M4 + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c6) => replaceXRange(c6, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r4 = options.loose ? re[t10.XRANGELOOSE] : re[t10.XRANGE];
      return comp.replace(r4, (ret, gtlt, M4, m4, p3, pr) => {
        debug("xRange", comp, ret, gtlt, M4, m4, p3, pr);
        const xM = isX(M4);
        const xm = xM || isX(m4);
        const xp = xm || isX(p3);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m4 = 0;
          }
          p3 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M4 = +M4 + 1;
              m4 = 0;
              p3 = 0;
            } else {
              m4 = +m4 + 1;
              p3 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M4 = +M4 + 1;
            } else {
              m4 = +m4 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M4}.${m4}.${p3}${pr}`;
        } else if (xm) {
          ret = `>=${M4}.0.0${pr} <${+M4 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M4}.${m4}.0${pr} <${M4}.${+m4 + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t10.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t10.GTE0PRE : t10.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set3, version2, options) => {
      for (let i5 = 0; i5 < set3.length; i5++) {
        if (!set3[i5].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i5 = 0; i5 < set3.length; i5++) {
          debug(set3[i5].semver);
          if (set3[i5].semver === Comparator.ANY) {
            continue;
          }
          if (set3[i5].semver.prerelease.length > 0) {
            const allowed = set3[i5].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "../../node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r4 = this.options.loose ? re[t10.COMPARATORLOOSE] : re[t10.COMPARATOR];
        const m4 = comp.match(r4);
        if (!m4) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m4[1] !== void 0 ? m4[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m4[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m4[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t: t10 } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// ../../node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "../../node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range = require_range();
    var satisfies = (version2, range2, options) => {
      try {
        range2 = new Range(range2, options);
      } catch (er) {
        return false;
      }
      return range2.test(version2);
    };
    module2.exports = satisfies;
  }
});

// ../../node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "../../node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range = require_range();
    var toComparators = (range2, options) => new Range(range2, options).set.map((comp) => comp.map((c6) => c6.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// ../../node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "../../node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying2 = (versions, range2, options) => {
      let max3 = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v2) => {
        if (rangeObj.test(v2)) {
          if (!max3 || maxSV.compare(v2) === -1) {
            max3 = v2;
            maxSV = new SemVer(max3, options);
          }
        }
      });
      return max3;
    };
    module2.exports = maxSatisfying2;
  }
});

// ../../node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "../../node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range2, options) => {
      let min3 = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v2) => {
        if (rangeObj.test(v2)) {
          if (!min3 || minSV.compare(v2) === 1) {
            min3 = v2;
            minSV = new SemVer(min3, options);
          }
        }
      });
      return min3;
    };
    module2.exports = minSatisfying;
  }
});

// ../../node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "../../node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range2, loose) => {
      range2 = new Range(range2, loose);
      let minver = new SemVer("0.0.0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i5 = 0; i5 < range2.set.length; ++i5) {
        const comparators = range2.set[i5];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range2.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// ../../node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "../../node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range = require_range();
    var validRange = (range2, options) => {
      try {
        return new Range(range2, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// ../../node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "../../node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range2, hilo, options) => {
      version2 = new SemVer(version2, options);
      range2 = new Range(range2, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range2, options)) {
        return false;
      }
      for (let i5 = 0; i5 < range2.set.length; ++i5) {
        const comparators = range2.set[i5];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// ../../node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "../../node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version2, range2, options) => outside(version2, range2, ">", options);
    module2.exports = gtr;
  }
});

// ../../node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "../../node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version2, range2, options) => outside(version2, range2, "<", options);
    module2.exports = ltr;
  }
});

// ../../node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "../../node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range = require_range();
    var intersects = (r1, r22, options) => {
      r1 = new Range(r1, options);
      r22 = new Range(r22, options);
      return r1.intersects(r22, options);
    };
    module2.exports = intersects;
  }
});

// ../../node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "../../node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    module2.exports = (versions, range2, options) => {
      const set3 = [];
      let first2 = null;
      let prev = null;
      const v2 = versions.sort((a4, b4) => compare2(a4, b4, options));
      for (const version2 of v2) {
        const included = satisfies(version2, range2, options);
        if (included) {
          prev = version2;
          if (!first2) {
            first2 = version2;
          }
        } else {
          if (prev) {
            set3.push([first2, prev]);
          }
          prev = null;
          first2 = null;
        }
      }
      if (first2) {
        set3.push([first2, null]);
      }
      const ranges = [];
      for (const [min3, max3] of set3) {
        if (min3 === max3) {
          ranges.push(min3);
        } else if (!max3 && min3 === v2[0]) {
          ranges.push("*");
        } else if (!max3) {
          ranges.push(`>=${min3}`);
        } else if (min3 === v2[0]) {
          ranges.push(`<=${max3}`);
        } else {
          ranges.push(`${min3} - ${max3}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range2.raw === "string" ? range2.raw : String(range2);
      return simplified.length < original.length ? simplified : range2;
    };
  }
});

// ../../node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "../../node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c6 of sub) {
        if (c6.operator === ">" || c6.operator === ">=") {
          gt = higherGT(gt, c6, options);
        } else if (c6.operator === "<" || c6.operator === "<=") {
          lt = lowerLT(lt, c6, options);
        } else {
          eqSet.add(c6.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare2(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq2 of eqSet) {
        if (gt && !satisfies(eq2, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq2, String(lt), options)) {
          return null;
        }
        for (const c6 of dom) {
          if (!satisfies(eq2, String(c6), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c6 of dom) {
        hasDomGT = hasDomGT || c6.operator === ">" || c6.operator === ">=";
        hasDomLT = hasDomLT || c6.operator === "<" || c6.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c6.semver.prerelease && c6.semver.prerelease.length && c6.semver.major === needDomGTPre.major && c6.semver.minor === needDomGTPre.minor && c6.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c6.operator === ">" || c6.operator === ">=") {
            higher = higherGT(gt, c6, options);
            if (higher === c6 && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c6), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c6.semver.prerelease && c6.semver.prerelease.length && c6.semver.major === needDomLTPre.major && c6.semver.minor === needDomLTPre.minor && c6.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c6.operator === "<" || c6.operator === "<=") {
            lower = lowerLT(lt, c6, options);
            if (lower === c6 && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c6), options)) {
            return false;
          }
        }
        if (!c6.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a4, b4, options) => {
      if (!a4) {
        return b4;
      }
      const comp = compare2(a4.semver, b4.semver, options);
      return comp > 0 ? a4 : comp < 0 ? b4 : b4.operator === ">" && a4.operator === ">=" ? b4 : a4;
    };
    var lowerLT = (a4, b4, options) => {
      if (!a4) {
        return b4;
      }
      const comp = compare2(a4.semver, b4.semver, options);
      return comp < 0 ? a4 : comp > 0 ? b4 : b4.operator === "<" && a4.operator === "<=" ? b4 : a4;
    };
    module2.exports = subset;
  }
});

// ../../node_modules/semver/index.js
var require_semver2 = __commonJS({
  "../../node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse4 = require_parse();
    var valid2 = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare2 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq2 = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying2 = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse4,
      valid: valid2,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare: compare2,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq: eq2,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying: maxSatisfying2,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/semvercache.js
var import_semver, SemVerCache;
var init_semvercache = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/semvercache.js"() {
    import_semver = __toESM(require_semver2());
    SemVerCache = class {
      constructor() {
        this._cache = /* @__PURE__ */ Object.create(null);
      }
      set(key, version2, object2) {
        if (!(key in this._cache)) {
          this._cache[key] = /* @__PURE__ */ Object.create(null);
        }
        if (!(version2 in this._cache[key])) {
          this._cache[key][version2] = object2;
        } else {
          throw `Version ${version2} of key ${key} already registered.`;
        }
      }
      get(key, semver) {
        if (key in this._cache) {
          const versions = this._cache[key];
          const best = (0, import_semver.maxSatisfying)(Object.keys(versions), semver);
          if (best !== null) {
            return versions[best];
          }
        }
      }
      getAllVersions(key) {
        if (key in this._cache) {
          return this._cache[key];
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/manager.js
var import_semver2, WIDGET_STATE_MIMETYPE, LabWidgetManager, KernelWidgetManager, WidgetManager;
var init_manager2 = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/manager.js"() {
    init_lib10();
    init_lib11();
    init_index_es6();
    import_semver2 = __toESM(require_semver2());
    init_semvercache();
    WIDGET_STATE_MIMETYPE = "application/vnd.jupyter.widget-state+json";
    LabWidgetManager = class extends ManagerBase {
      constructor(rendermime) {
        super();
        this._handleCommOpen = async (comm, msg) => {
          const oldComm = new shims.services.Comm(comm);
          await this.handle_comm_open(oldComm, msg);
        };
        this._restored = new Signal(this);
        this._restoredStatus = false;
        this._kernelRestoreInProgress = false;
        this._isDisposed = false;
        this._registry = new SemVerCache();
        this._modelsSync = /* @__PURE__ */ new Map();
        this._onUnhandledIOPubMessage = new Signal(this);
        this._rendermime = rendermime;
      }
      /**
       * Default callback handler to emit unhandled kernel messages.
       */
      callbacks(view) {
        return {
          iopub: {
            output: (msg) => {
              this._onUnhandledIOPubMessage.emit(msg);
            }
          }
        };
      }
      /**
       * Register a new kernel
       */
      _handleKernelChanged({ oldValue, newValue }) {
        if (oldValue) {
          oldValue.removeCommTarget(this.comm_target_name, this._handleCommOpen);
        }
        if (newValue) {
          newValue.registerCommTarget(this.comm_target_name, this._handleCommOpen);
        }
      }
      /**
       * Disconnect the widget manager from the kernel, setting each model's comm
       * as dead.
       */
      disconnect() {
        super.disconnect();
        this._restoredStatus = false;
      }
      async _loadFromKernel() {
        var _a;
        if (!this.kernel) {
          throw new Error("Kernel not set");
        }
        if (((_a = this.kernel) === null || _a === void 0 ? void 0 : _a.handleComms) === false) {
          return;
        }
        return super._loadFromKernel();
      }
      /**
       * Create a comm.
       */
      async _create_comm(target_name, model_id, data, metadata, buffers) {
        const kernel = this.kernel;
        if (!kernel) {
          throw new Error("No current kernel");
        }
        const comm = kernel.createComm(target_name, model_id);
        if (data || metadata) {
          comm.open(data, metadata, buffers);
        }
        return new shims.services.Comm(comm);
      }
      /**
       * Get the currently-registered comms.
       */
      async _get_comm_info() {
        const kernel = this.kernel;
        if (!kernel) {
          throw new Error("No current kernel");
        }
        const reply = await kernel.requestCommInfo({
          target_name: this.comm_target_name
        });
        if (reply.content.status === "ok") {
          return reply.content.comms;
        } else {
          return {};
        }
      }
      /**
       * Get whether the manager is disposed.
       *
       * #### Notes
       * This is a read-only property.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        if (this._commRegistration) {
          this._commRegistration.dispose();
        }
      }
      /**
       * Resolve a URL relative to the current notebook location.
       */
      async resolveUrl(url) {
        return url;
      }
      /**
       * Load a class and return a promise to the loaded object.
       */
      async loadClass(className, moduleName, moduleVersion) {
        if ((moduleName === "@jupyter-widgets/base" || moduleName === "@jupyter-widgets/controls") && (0, import_semver2.valid)(moduleVersion)) {
          moduleVersion = `^${moduleVersion}`;
        }
        const allVersions = this._registry.getAllVersions(moduleName);
        if (!allVersions) {
          throw new Error(`No version of module ${moduleName} is registered`);
        }
        const mod = this._registry.get(moduleName, moduleVersion);
        if (!mod) {
          const registeredVersionList = Object.keys(allVersions);
          throw new Error(`Module ${moduleName}, version ${moduleVersion} is not registered, however,         ${registeredVersionList.join(",")} ${registeredVersionList.length > 1 ? "are" : "is"}`);
        }
        let module2;
        if (typeof mod === "function") {
          module2 = await mod();
        } else {
          module2 = await mod;
        }
        const cls = module2[className];
        if (!cls) {
          throw new Error(`Class ${className} not found in module ${moduleName}`);
        }
        return cls;
      }
      get rendermime() {
        return this._rendermime;
      }
      /**
       * A signal emitted when state is restored to the widget manager.
       *
       * #### Notes
       * This indicates that previously-unavailable widget models might be available now.
       */
      get restored() {
        return this._restored;
      }
      /**
       * Whether the state has been restored yet or not.
       */
      get restoredStatus() {
        return this._restoredStatus;
      }
      /**
       * A signal emitted for unhandled iopub kernel messages.
       *
       */
      get onUnhandledIOPubMessage() {
        return this._onUnhandledIOPubMessage;
      }
      register(data) {
        this._registry.set(data.name, data.version, data.exports);
      }
      /**
       * Register a widget model.
       */
      register_model(model_id, modelPromise) {
        super.register_model(model_id, modelPromise);
        modelPromise.then((model) => {
          this._modelsSync.set(model_id, model);
          model.once("comm:close", () => {
            this._modelsSync.delete(model_id);
          });
        });
      }
      /**
       * Close all widgets and empty the widget state.
       * @return Promise that resolves when the widget state is cleared.
       */
      async clear_state() {
        await super.clear_state();
        this._modelsSync = /* @__PURE__ */ new Map();
      }
      /**
       * Synchronously get the state of the live widgets in the widget manager.
       *
       * This includes all of the live widget models, and follows the format given in
       * the @jupyter-widgets/schema package.
       *
       * @param options - The options for what state to return.
       * @returns A state dictionary
       */
      get_state_sync(options = {}) {
        const models = [];
        for (const model of this._modelsSync.values()) {
          if (model.comm_live) {
            models.push(model);
          }
        }
        return serialize_state(models, options);
      }
    };
    KernelWidgetManager = class extends LabWidgetManager {
      constructor(kernel, rendermime) {
        super(rendermime);
        this._kernel = kernel;
        kernel.statusChanged.connect((sender, args) => {
          this._handleKernelStatusChange(args);
        });
        kernel.connectionStatusChanged.connect((sender, args) => {
          this._handleKernelConnectionStatusChange(args);
        });
        this._handleKernelChanged({
          name: "kernel",
          oldValue: null,
          newValue: kernel
        });
        this.restoreWidgets();
      }
      _handleKernelConnectionStatusChange(status) {
        if (status === "connected") {
          if (!this._kernelRestoreInProgress) {
            this.restoreWidgets();
          }
        }
      }
      _handleKernelStatusChange(status) {
        if (status === "restarting") {
          this.disconnect();
        }
      }
      /**
       * Restore widgets from kernel and saved state.
       */
      async restoreWidgets() {
        try {
          this._kernelRestoreInProgress = true;
          await this._loadFromKernel();
          this._restoredStatus = true;
          this._restored.emit();
        } catch (err) {
        }
        this._kernelRestoreInProgress = false;
      }
      /**
       * Dispose the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._kernel = null;
        super.dispose();
      }
      get kernel() {
        return this._kernel;
      }
    };
    WidgetManager = class extends LabWidgetManager {
      constructor(context, rendermime, settings) {
        var _a, _b;
        super(rendermime);
        this._context = context;
        context.sessionContext.kernelChanged.connect((sender, args) => {
          this._handleKernelChanged(args);
        });
        context.sessionContext.statusChanged.connect((sender, args) => {
          this._handleKernelStatusChange(args);
        });
        context.sessionContext.connectionStatusChanged.connect((sender, args) => {
          this._handleKernelConnectionStatusChange(args);
        });
        if ((_a = context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) {
          this._handleKernelChanged({
            name: "kernel",
            oldValue: null,
            newValue: (_b = context.sessionContext.session) === null || _b === void 0 ? void 0 : _b.kernel
          });
        }
        this.restoreWidgets(this._context.model);
        this._settings = settings;
        context.saveState.connect((sender, saveState) => {
          if (saveState === "started" && settings.saveState) {
            this._saveState();
          }
        });
      }
      /**
       * Save the widget state to the context model.
       */
      _saveState() {
        const state = this.get_state_sync({ drop_defaults: true });
        if (this._context.model.setMetadata) {
          this._context.model.setMetadata("widgets", {
            "application/vnd.jupyter.widget-state+json": state
          });
        } else {
          this._context.model.metadata.set("widgets", {
            "application/vnd.jupyter.widget-state+json": state
          });
        }
      }
      _handleKernelConnectionStatusChange(status) {
        if (status === "connected") {
          if (!this._kernelRestoreInProgress) {
            this.restoreWidgets(this._context.model, {
              loadKernel: true,
              loadNotebook: false
            });
          }
        }
      }
      _handleKernelStatusChange(status) {
        if (status === "restarting") {
          this.disconnect();
        }
      }
      /**
       * Restore widgets from kernel and saved state.
       */
      async restoreWidgets(notebook, { loadKernel, loadNotebook } = { loadKernel: true, loadNotebook: true }) {
        try {
          await this.context.sessionContext.ready;
          if (loadKernel) {
            try {
              this._kernelRestoreInProgress = true;
              await this._loadFromKernel();
            } finally {
              this._kernelRestoreInProgress = false;
            }
          }
          if (loadNotebook) {
            await this._loadFromNotebook(notebook);
          }
          this._restoredStatus = true;
          this._restored.emit();
        } catch (err) {
        }
      }
      /**
       * Load widget state from notebook metadata
       */
      async _loadFromNotebook(notebook) {
        const widget_md = notebook.getMetadata ? notebook.getMetadata("widgets") : (
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore JupyterLab 3 support
          notebook.metadata.get("widgets")
        );
        if (widget_md && widget_md[WIDGET_STATE_MIMETYPE]) {
          let state = widget_md[WIDGET_STATE_MIMETYPE];
          state = this.filterExistingModelState(state);
          await this.set_state(state);
        }
      }
      /**
       * Dispose the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._context = null;
        super.dispose();
      }
      /**
       * Resolve a URL relative to the current notebook location.
       */
      async resolveUrl(url) {
        const partial2 = await this.context.urlResolver.resolveUrl(url);
        return this.context.urlResolver.getDownloadUrl(partial2);
      }
      get context() {
        return this._context;
      }
      get kernel() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this._context.sessionContext) === null || _a === void 0 ? void 0 : _a.session) === null || _b === void 0 ? void 0 : _b.kernel) !== null && _c !== void 0 ? _c : null;
      }
      /**
       * Register a widget model.
       */
      register_model(model_id, modelPromise) {
        super.register_model(model_id, modelPromise);
        this.setDirty();
      }
      /**
       * Close all widgets and empty the widget state.
       * @return Promise that resolves when the widget state is cleared.
       */
      async clear_state() {
        await super.clear_state();
        this.setDirty();
      }
      /**
       * Set the dirty state of the notebook model if applicable.
       *
       * TODO: perhaps should also set dirty when any model changes any data
       */
      setDirty() {
        if (this._settings.saveState) {
          this._context.model.dirty = true;
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/output/lib/output.js
var OUTPUT_WIDGET_VERSION, OutputModel2, OutputView;
var init_output = __esm({
  "../../node_modules/@jupyter-widgets/output/lib/output.js"() {
    init_lib10();
    OUTPUT_WIDGET_VERSION = "1.0.0";
    OutputModel2 = class extends DOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "OutputModel", _view_name: "OutputView", _model_module: "@jupyter-widgets/output", _view_module: "@jupyter-widgets/output", _model_module_version: OUTPUT_WIDGET_VERSION, _view_module_version: OUTPUT_WIDGET_VERSION });
      }
    };
    OutputView = class extends DOMWidgetView {
    };
  }
});

// ../../node_modules/@jupyter-widgets/output/lib/index.js
var init_lib12 = __esm({
  "../../node_modules/@jupyter-widgets/output/lib/index.js"() {
    init_output();
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/output.js
var output_exports = {};
__export(output_exports, {
  OUTPUT_WIDGET_VERSION: () => OUTPUT_WIDGET_VERSION2,
  OutputModel: () => OutputModel3,
  OutputView: () => OutputView2
});
var import_jquery2, OUTPUT_WIDGET_VERSION2, OutputModel3, OutputView2;
var init_output2 = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/output.js"() {
    init_lib12();
    init_lib10();
    init_manager2();
    init_lib9();
    import_jquery2 = __toESM(require_jquery());
    OUTPUT_WIDGET_VERSION2 = OUTPUT_WIDGET_VERSION;
    OutputModel3 = class extends OutputModel2 {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { msg_id: "", outputs: [] });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this._outputs = new OutputAreaModel({ trusted: true });
        this._msgHook = (msg) => {
          this.add(msg);
          return false;
        };
        if (this.widget_manager instanceof WidgetManager) {
          this.widget_manager.context.sessionContext.kernelChanged.connect((sender, args) => {
            this._handleKernelChanged(args);
          });
        }
        this.listenTo(this, "change:msg_id", this.reset_msg_id);
        this.listenTo(this, "change:outputs", this.setOutputs);
        this.setOutputs();
      }
      /**
       * Register a new kernel
       */
      _handleKernelChanged({ oldValue }) {
        const msgId = this.get("msg_id");
        if (msgId && oldValue) {
          oldValue.removeMessageHook(msgId, this._msgHook);
          this.set("msg_id", null);
        }
      }
      /**
       * Reset the message id.
       */
      reset_msg_id() {
        const kernel = this.widget_manager.kernel;
        const msgId = this.get("msg_id");
        const oldMsgId = this.previous("msg_id");
        if (oldMsgId && kernel) {
          kernel.removeMessageHook(oldMsgId, this._msgHook);
        }
        if (msgId && kernel) {
          kernel.registerMessageHook(msgId, this._msgHook);
        }
      }
      add(msg) {
        const msgType = msg.header.msg_type;
        switch (msgType) {
          case "execute_result":
          case "display_data":
          case "stream":
          case "error": {
            const model = msg.content;
            model.output_type = msgType;
            this._outputs.add(model);
            break;
          }
          case "clear_output":
            this.clear_output(msg.content.wait);
            break;
          default:
            break;
        }
        this.set("outputs", this._outputs.toJSON(), { newMessage: true });
        this.save_changes();
      }
      clear_output(wait = false) {
        this._outputs.clear(wait);
      }
      get outputs() {
        return this._outputs;
      }
      setOutputs(model, value, options) {
        if (!(options && options.newMessage)) {
          this.clear_output();
          this._outputs.fromJSON(JSON.parse(JSON.stringify(this.get("outputs"))));
        }
      }
    };
    OutputView2 = class extends OutputView {
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoPanelWidget({ view: this });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery2.default)(this.luminoWidget.node);
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this._outputView = new OutputArea({
          rendermime: this.model.widget_manager.rendermime,
          contentFactory: OutputArea.defaultContentFactory,
          model: this.model.outputs
        });
        this.luminoWidget.insertWidget(0, this._outputView);
        this.luminoWidget.addClass("jupyter-widgets");
        this.luminoWidget.addClass("widget-output");
        this.update();
      }
      remove() {
        this._outputView.dispose();
        return super.remove();
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/version.js
var JUPYTER_CONTROLS_VERSION;
var init_version2 = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/version.js"() {
    JUPYTER_CONTROLS_VERSION = "2.0.0";
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/index.js
var init_lib13 = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/index.js"() {
    init_output2();
    init_manager2();
    init_renderer();
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/utils.js
function typeset(element2, text) {
  if (text !== void 0) {
    element2.textContent = text;
  }
  if (window.MathJax !== void 0) {
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, element2]);
  }
}
function escape_html(text) {
  const esc = document.createElement("div");
  esc.textContent = text;
  return esc.innerHTML;
}
function reject3(message, log) {
  return function promiseRejection(error) {
    if (log) {
      console.error(new Error(message));
    }
    throw error;
  };
}
var init_utils3 = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/utils.js"() {
    init_lib10();
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_description.js
var DescriptionStyleModel, DescriptionModel, DescriptionView, LabeledDOMWidgetModel, LabeledDOMWidgetView;
var init_widget_description = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_description.js"() {
    init_lib10();
    init_utils3();
    init_version2();
    DescriptionStyleModel = class extends StyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "DescriptionStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    DescriptionStyleModel.styleProperties = {
      description_width: {
        selector: ".widget-label",
        attribute: "width",
        default: null
      }
    };
    DescriptionModel = class extends DOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "DescriptionModel", _view_name: "DescriptionView", _view_module: "@jupyter-widgets/controls", _model_module: "@jupyter-widgets/controls", _view_module_version: JUPYTER_CONTROLS_VERSION, _model_module_version: JUPYTER_CONTROLS_VERSION, description: "", description_allow_html: false });
      }
    };
    DescriptionView = class extends DOMWidgetView {
      render() {
        this.label = document.createElement("label");
        this.el.appendChild(this.label);
        this.label.className = "widget-label";
        this.label.style.display = "none";
        this.listenTo(this.model, "change:description", this.updateDescription);
        this.listenTo(this.model, "change:description_allow_html", this.updateDescription);
        this.listenTo(this.model, "change:tabbable", this.updateTabindex);
        this.updateDescription();
        this.updateTabindex();
        this.updateTooltip();
      }
      typeset(element2, text) {
        this.displayed.then(() => {
          var _a, _b, _c;
          if ((_b = (_a = window.MathJax) === null || _a === void 0 ? void 0 : _a.Hub) === null || _b === void 0 ? void 0 : _b.Queue) {
            return typeset(element2, text);
          }
          const widget_manager = this.model.widget_manager;
          const latexTypesetter = (_c = widget_manager._rendermime) === null || _c === void 0 ? void 0 : _c.latexTypesetter;
          if (latexTypesetter) {
            if (text !== void 0) {
              element2.textContent = text;
            }
            latexTypesetter.typeset(element2);
          }
        });
      }
      updateDescription() {
        const description = this.model.get("description");
        if (description.length === 0) {
          this.label.style.display = "none";
        } else {
          if (this.model.get("description_allow_html")) {
            this.label.innerHTML = this.model.widget_manager.inline_sanitize(description);
          } else {
            this.label.textContent = description;
          }
          this.typeset(this.label);
          this.label.style.display = "";
        }
      }
      updateTooltip() {
        if (!this.label)
          return;
        this.label.title = this.model.get("tooltip");
      }
    };
    LabeledDOMWidgetModel = class extends DescriptionModel {
    };
    LabeledDOMWidgetView = class extends DescriptionView {
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_core.js
var CoreWidgetModel, CoreDOMWidgetModel, CoreDescriptionModel;
var init_widget_core = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_core.js"() {
    init_lib10();
    init_widget_description();
    init_version2();
    CoreWidgetModel = class extends WidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "CoreWidgetModel", _view_module: "@jupyter-widgets/controls", _model_module: "@jupyter-widgets/controls", _view_module_version: JUPYTER_CONTROLS_VERSION, _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    CoreDOMWidgetModel = class extends DOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "CoreDOMWidgetModel", _view_module: "@jupyter-widgets/controls", _model_module: "@jupyter-widgets/controls", _view_module_version: JUPYTER_CONTROLS_VERSION, _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    CoreDescriptionModel = class extends DescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "CoreDescriptionModel", _view_module: "@jupyter-widgets/controls", _model_module: "@jupyter-widgets/controls", _view_module_version: JUPYTER_CONTROLS_VERSION, _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_link.js
var DirectionalLinkModel, LinkModel;
var init_widget_link = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_link.js"() {
    init_lib10();
    init_widget_core();
    DirectionalLinkModel = class extends CoreWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { target: void 0, source: void 0, _model_name: "DirectionalLinkModel" });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this.on("change", this.updateBindings, this);
        this.updateBindings();
      }
      updateValue(sourceModel, sourceAttr, targetModel, targetAttr) {
        if (this._updating) {
          return;
        }
        this._updating = true;
        try {
          if (targetModel) {
            targetModel.set(targetAttr, sourceModel.get(sourceAttr));
            targetModel.save_changes();
          }
        } finally {
          this._updating = false;
        }
      }
      updateBindings() {
        this.cleanup();
        [this.sourceModel, this.sourceAttr] = this.get("source") || [null, null];
        [this.targetModel, this.targetAttr] = this.get("target") || [null, null];
        if (this.sourceModel) {
          this.listenTo(this.sourceModel, "change:" + this.sourceAttr, () => {
            this.updateValue(this.sourceModel, this.sourceAttr, this.targetModel, this.targetAttr);
          });
          this.updateValue(this.sourceModel, this.sourceAttr, this.targetModel, this.targetAttr);
          this.listenToOnce(this.sourceModel, "destroy", this.cleanup);
        }
        if (this.targetModel) {
          this.listenToOnce(this.targetModel, "destroy", this.cleanup);
        }
      }
      cleanup() {
        if (this.sourceModel) {
          this.stopListening(this.sourceModel, "change:" + this.sourceAttr, void 0);
          this.stopListening(this.sourceModel, "destroy", void 0);
        }
        if (this.targetModel) {
          this.stopListening(this.targetModel, "destroy", void 0);
        }
      }
    };
    DirectionalLinkModel.serializers = Object.assign(Object.assign({}, CoreWidgetModel.serializers), { target: { deserialize: unpack_models }, source: { deserialize: unpack_models } });
    LinkModel = class extends DirectionalLinkModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "LinkModel" });
      }
      updateBindings() {
        super.updateBindings();
        if (this.targetModel) {
          this.listenTo(this.targetModel, "change:" + this.targetAttr, () => {
            this.updateValue(this.targetModel, this.targetAttr, this.sourceModel, this.sourceAttr);
          });
        }
      }
      cleanup() {
        super.cleanup();
        if (this.targetModel) {
          this.stopListening(this.targetModel, "change:" + this.targetAttr, void 0);
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_bool.js
var CheckboxStyleModel, ToggleButtonStyleModel, BoolModel, CheckboxModel, CheckboxView, ToggleButtonModel, ToggleButtonView, ValidModel, ValidView;
var init_widget_bool = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_bool.js"() {
    init_lib10();
    init_widget_core();
    init_widget_description();
    CheckboxStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "CheckboxStyleModel" });
      }
    };
    CheckboxStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { background: {
      selector: "",
      attribute: "background",
      default: null
    } });
    ToggleButtonStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ToggleButtonStyleModel" });
      }
    };
    ToggleButtonStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { font_family: {
      selector: "",
      attribute: "font-family",
      default: ""
    }, font_size: {
      selector: "",
      attribute: "font-size",
      default: ""
    }, font_style: {
      selector: "",
      attribute: "font-style",
      default: ""
    }, font_variant: {
      selector: "",
      attribute: "font-variant",
      default: ""
    }, font_weight: {
      selector: "",
      attribute: "font-weight",
      default: ""
    }, text_color: {
      selector: "",
      attribute: "color",
      default: ""
    }, text_decoration: {
      selector: "",
      attribute: "text-decoration",
      default: ""
    } });
    BoolModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: false, disabled: false, _model_name: "BoolModel" });
      }
    };
    CheckboxModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { indent: true, style: null, _view_name: "CheckboxView", _model_name: "CheckboxModel" });
      }
    };
    CheckboxView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-checkbox");
        this.label.innerHTML = "&#8203;";
        this.checkboxLabel = document.createElement("label");
        this.checkboxLabel.classList.add("widget-label-basic");
        this.el.appendChild(this.checkboxLabel);
        this.checkbox = document.createElement("input");
        this.checkbox.setAttribute("type", "checkbox");
        this.checkboxLabel.appendChild(this.checkbox);
        this.descriptionSpan = document.createElement("span");
        this.checkboxLabel.appendChild(this.descriptionSpan);
        this.listenTo(this.model, "change:indent", this.updateIndent);
        this.listenTo(this.model, "change:tabbable", this.updateTabindex);
        this.update();
        this.updateDescription();
        this.updateIndent();
        this.updateTabindex();
        this.updateTooltip();
      }
      /**
       * Overridden from super class
       *
       * Update the description span (rather than the label) since
       * we want the description to the right of the checkbox.
       */
      updateDescription() {
        if (this.checkboxLabel == null) {
          return;
        }
        const description = this.model.get("description");
        if (this.model.get("description_allow_html")) {
          this.descriptionSpan.innerHTML = this.model.widget_manager.inline_sanitize(description);
        } else {
          this.descriptionSpan.textContent = description;
        }
        this.typeset(this.descriptionSpan);
        this.descriptionSpan.title = description;
        this.checkbox.title = description;
      }
      /**
       * Update the visibility of the label in the super class
       * to provide the optional indent.
       */
      updateIndent() {
        const indent = this.model.get("indent");
        this.label.style.display = indent ? "" : "none";
      }
      updateTabindex() {
        if (!this.checkbox) {
          return;
        }
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.checkbox.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.checkbox.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.checkbox.removeAttribute("tabIndex");
        }
      }
      updateTooltip() {
        if (!this.checkbox)
          return;
        const title = this.model.get("tooltip");
        if (!title) {
          this.checkbox.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.checkbox.setAttribute("title", title);
        }
      }
      events() {
        return {
          'click input[type="checkbox"]': "_handle_click"
        };
      }
      /**
       * Handles when the checkbox is clicked.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      _handle_click() {
        const value = this.model.get("value");
        this.model.set("value", !value, { updated_view: this });
        this.touch();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        this.checkbox.checked = this.model.get("value");
        if (options === void 0 || options.updated_view != this) {
          this.checkbox.disabled = this.model.get("disabled");
        }
        return super.update();
      }
      /**
       * Handle message sent to the front end.
       *
       * Used to focus or blur the widget.
       */
      handle_message(content) {
        if (content.do == "focus") {
          this.checkbox.focus();
        } else if (content.do == "blur") {
          this.checkbox.blur();
        }
      }
    };
    ToggleButtonModel = class extends BoolModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "ToggleButtonView", _model_name: "ToggleButtonModel", tooltip: "", icon: "", button_style: "", style: null });
      }
    };
    ToggleButtonView = class extends DOMWidgetView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("jupyter-button");
        this.el.classList.add("widget-toggle-button");
        this.listenTo(this.model, "change:button_style", this.update_button_style);
        this.listenTo(this.model, "change:tabbable", this.updateTabindex);
        this.set_button_style();
        this.update();
      }
      update_button_style() {
        this.update_mapped_classes(ToggleButtonView.class_map, "button_style");
      }
      set_button_style() {
        this.set_mapped_classes(ToggleButtonView.class_map, "button_style");
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (this.model.get("value")) {
          this.el.classList.add("mod-active");
        } else {
          this.el.classList.remove("mod-active");
        }
        if (options === void 0 || options.updated_view !== this) {
          this.el.disabled = this.model.get("disabled");
          this.el.setAttribute("tabbable", this.model.get("tabbable"));
          this.el.setAttribute("title", this.model.get("tooltip"));
          const description = this.model.get("description");
          const icon = this.model.get("icon");
          if (description.trim().length === 0 && icon.trim().length === 0) {
            this.el.innerHTML = "&nbsp;";
          } else {
            this.el.textContent = "";
            if (icon.trim().length) {
              const i5 = document.createElement("i");
              this.el.appendChild(i5);
              i5.classList.add("fa");
              i5.classList.add("fa-" + icon);
            }
            this.el.appendChild(document.createTextNode(description));
          }
        }
        this.updateTabindex();
        return super.update();
      }
      events() {
        return {
          // Dictionary of events and their handlers.
          click: "_handle_click"
        };
      }
      /**
       * Handles and validates user input.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      _handle_click(event) {
        event.preventDefault();
        const value = this.model.get("value");
        this.model.set("value", !value, { updated_view: this });
        this.touch();
      }
      preinitialize() {
        this.tagName = "button";
      }
    };
    ToggleButtonView.class_map = {
      primary: ["mod-primary"],
      success: ["mod-success"],
      info: ["mod-info"],
      warning: ["mod-warning"],
      danger: ["mod-danger"]
    };
    ValidModel = class extends BoolModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { readout: "Invalid", _view_name: "ValidView", _model_name: "ValidModel" });
      }
    };
    ValidView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-valid");
        this.el.classList.add("widget-inline-hbox");
        this.icon = document.createElement("i");
        this.icon.classList.add("fa", "fa-fw");
        this.el.appendChild(this.icon);
        this.readout = document.createElement("span");
        this.readout.classList.add("widget-valid-readout");
        this.readout.classList.add("widget-readout");
        this.el.appendChild(this.readout);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.el.classList.remove("mod-valid");
        this.el.classList.remove("mod-invalid");
        this.icon.classList.remove("fa-check");
        this.icon.classList.remove("fa-times");
        this.readout.textContent = this.model.get("readout");
        if (this.model.get("value")) {
          this.el.classList.add("mod-valid");
          this.icon.classList.add("fa-check");
        } else {
          this.el.classList.add("mod-invalid");
          this.icon.classList.add("fa-times");
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_button.js
var ButtonStyleModel, ButtonModel, ButtonView;
var init_widget_button = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_button.js"() {
    init_lib10();
    init_widget_core();
    init_version2();
    ButtonStyleModel = class extends StyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ButtonStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    ButtonStyleModel.styleProperties = {
      button_color: {
        selector: "",
        attribute: "background-color",
        default: null
      },
      font_family: {
        selector: "",
        attribute: "font-family",
        default: ""
      },
      font_size: {
        selector: "",
        attribute: "font-size",
        default: ""
      },
      font_style: {
        selector: "",
        attribute: "font-style",
        default: ""
      },
      font_variant: {
        selector: "",
        attribute: "font-variant",
        default: ""
      },
      font_weight: {
        selector: "",
        attribute: "font-weight",
        default: ""
      },
      text_color: {
        selector: "",
        attribute: "color",
        default: ""
      },
      text_decoration: {
        selector: "",
        attribute: "text-decoration",
        default: ""
      }
    };
    ButtonModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { description: "", tooltip: "", disabled: false, icon: "", button_style: "", _view_name: "ButtonView", _model_name: "ButtonModel", style: null });
      }
    };
    ButtonView = class extends DOMWidgetView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("jupyter-button");
        this.el.classList.add("widget-button");
        this.listenTo(this.model, "change:button_style", this.update_button_style);
        this.listenTo(this.model, "change:tabbable", this.updateTabindex);
        this.set_button_style();
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.el.disabled = this.model.get("disabled");
        this.updateTabindex();
        const tooltip = this.model.get("tooltip");
        const description = this.model.get("description");
        const icon = this.model.get("icon");
        this.el.setAttribute("title", tooltip !== null && tooltip !== void 0 ? tooltip : description);
        if (description.length || icon.length) {
          this.el.textContent = "";
          if (icon.length) {
            const i5 = document.createElement("i");
            i5.classList.add("fa");
            i5.classList.add(...icon.split(/[\s]+/).filter(Boolean).map((v2) => `fa-${v2}`));
            if (description.length === 0) {
              i5.classList.add("center");
            }
            this.el.appendChild(i5);
          }
          this.el.appendChild(document.createTextNode(description));
        }
        return super.update();
      }
      update_button_style() {
        this.update_mapped_classes(ButtonView.class_map, "button_style");
      }
      set_button_style() {
        this.set_mapped_classes(ButtonView.class_map, "button_style");
      }
      /**
       * Dictionary of events and handlers
       */
      events() {
        return { click: "_handle_click" };
      }
      /**
       * Handles when the button is clicked.
       */
      _handle_click(event) {
        event.preventDefault();
        this.send({ event: "click" });
      }
      preinitialize() {
        this.tagName = "button";
      }
    };
    ButtonView.class_map = {
      primary: ["mod-primary"],
      success: ["mod-success"],
      info: ["mod-info"],
      warning: ["mod-warning"],
      danger: ["mod-danger"]
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_box.js
var import_jquery3, BoxModel, HBoxModel, VBoxModel, BoxView, HBoxView, VBoxView, GridBoxView, GridBoxModel;
var init_widget_box = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_box.js"() {
    init_lib10();
    init_widget_core();
    init_index_es65();
    init_index_es66();
    init_index_es64();
    import_jquery3 = __toESM(require_jquery());
    BoxModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "BoxView", _model_name: "BoxModel", children: [], box_style: "" });
      }
    };
    BoxModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { children: { deserialize: unpack_models } });
    HBoxModel = class extends BoxModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "HBoxView", _model_name: "HBoxModel" });
      }
    };
    VBoxModel = class extends BoxModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "VBoxView", _model_name: "VBoxModel" });
      }
    };
    BoxView = class extends DOMWidgetView {
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoPanelWidget({ view: this });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery3.default)(this.luminoWidget.node);
      }
      initialize(parameters) {
        super.initialize(parameters);
        this.children_views = new ViewList(this.add_child_model, null, this);
        this.listenTo(this.model, "change:children", this.update_children);
        this.listenTo(this.model, "change:box_style", this.update_box_style);
        this.luminoWidget.addClass("jupyter-widgets");
        this.luminoWidget.addClass("widget-container");
        this.luminoWidget.addClass("widget-box");
      }
      render() {
        super.render();
        this.update_children();
        this.set_box_style();
      }
      update_children() {
        var _a;
        (_a = this.children_views) === null || _a === void 0 ? void 0 : _a.update(this.model.get("children")).then((views) => {
          views.forEach((view) => {
            MessageLoop.postMessage(view.luminoWidget, Widget.ResizeMessage.UnknownSize);
          });
        });
      }
      update_box_style() {
        this.update_mapped_classes(BoxView.class_map, "box_style");
      }
      set_box_style() {
        this.set_mapped_classes(BoxView.class_map, "box_style");
      }
      add_child_model(model) {
        const dummy = new Widget();
        this.luminoWidget.addWidget(dummy);
        return this.create_child_view(model).then((view) => {
          const i5 = ArrayExt.firstIndexOf(this.luminoWidget.widgets, dummy);
          this.luminoWidget.insertWidget(i5, view.luminoWidget);
          dummy.dispose();
          return view;
        }).catch(reject("Could not add child view to box", true));
      }
      remove() {
        this.children_views = null;
        super.remove();
      }
    };
    BoxView.class_map = {
      success: ["alert", "alert-success"],
      info: ["alert", "alert-info"],
      warning: ["alert", "alert-warning"],
      danger: ["alert", "alert-danger"]
    };
    HBoxView = class extends BoxView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.luminoWidget.addClass("widget-hbox");
      }
    };
    VBoxView = class extends BoxView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.luminoWidget.addClass("widget-vbox");
      }
    };
    GridBoxView = class extends BoxView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.luminoWidget.addClass("widget-gridbox");
        this.luminoWidget.removeClass("widget-box");
      }
    };
    GridBoxModel = class extends BoxModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "GridBoxView", _model_name: "GridBoxModel" });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_image.js
var ImageModel, ImageView;
var init_widget_image = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_image.js"() {
    init_lib10();
    init_widget_core();
    ImageModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ImageModel", _view_name: "ImageView", format: "png", width: "", height: "", value: new DataView(new ArrayBuffer(0)) });
      }
    };
    ImageModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { value: {
      serialize: (value) => {
        return new DataView(value.buffer.slice(0));
      }
    } });
    ImageView = class extends DOMWidgetView {
      render() {
        super.render();
        this.luminoWidget.addClass("jupyter-widgets");
        this.luminoWidget.addClass("widget-image");
        this.update();
      }
      update() {
        let url;
        const format2 = this.model.get("format");
        const value = this.model.get("value");
        if (format2 !== "url") {
          const blob = new Blob([value], {
            type: `image/${this.model.get("format")}`
          });
          url = URL.createObjectURL(blob);
        } else {
          url = new TextDecoder("utf-8").decode(value.buffer);
        }
        const oldurl = this.el.src;
        this.el.src = url;
        if (oldurl) {
          URL.revokeObjectURL(oldurl);
        }
        const width = this.model.get("width");
        if (width !== void 0 && width.length > 0) {
          this.el.setAttribute("width", width);
        } else {
          this.el.removeAttribute("width");
        }
        const height = this.model.get("height");
        if (height !== void 0 && height.length > 0) {
          this.el.setAttribute("height", height);
        } else {
          this.el.removeAttribute("height");
        }
        return super.update();
      }
      remove() {
        if (this.el.src) {
          URL.revokeObjectURL(this.el.src);
        }
        super.remove();
      }
      preinitialize() {
        this.tagName = "img";
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_video.js
var VideoModel, VideoView;
var init_widget_video = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_video.js"() {
    init_lib10();
    init_widget_core();
    VideoModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "VideoModel", _view_name: "VideoView", format: "mp4", width: "", height: "", autoplay: true, loop: true, controls: true, value: new DataView(new ArrayBuffer(0)) });
      }
    };
    VideoModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { value: {
      serialize: (value) => {
        return new DataView(value.buffer.slice(0));
      }
    } });
    VideoView = class extends DOMWidgetView {
      render() {
        super.render();
        this.luminoWidget.addClass("jupyter-widgets");
        this.luminoWidget.addClass("widget-image");
        this.update();
      }
      update() {
        let url;
        const format2 = this.model.get("format");
        const value = this.model.get("value");
        if (format2 !== "url") {
          const blob = new Blob([value], {
            type: `video/${this.model.get("format")}`
          });
          url = URL.createObjectURL(blob);
        } else {
          url = new TextDecoder("utf-8").decode(value.buffer);
        }
        const oldurl = this.el.src;
        this.el.src = url;
        if (oldurl) {
          URL.revokeObjectURL(oldurl);
        }
        const width = this.model.get("width");
        if (width !== void 0 && width.length > 0) {
          this.el.setAttribute("width", width);
        } else {
          this.el.removeAttribute("width");
        }
        const height = this.model.get("height");
        if (height !== void 0 && height.length > 0) {
          this.el.setAttribute("height", height);
        } else {
          this.el.removeAttribute("height");
        }
        this.el.loop = this.model.get("loop");
        this.el.autoplay = this.model.get("autoplay");
        this.el.controls = this.model.get("controls");
        return super.update();
      }
      remove() {
        if (this.el.src) {
          URL.revokeObjectURL(this.el.src);
        }
        super.remove();
      }
      preinitialize() {
        this.tagName = "video";
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_audio.js
var AudioModel, AudioView;
var init_widget_audio = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_audio.js"() {
    init_lib10();
    init_widget_core();
    AudioModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "AudioModel", _view_name: "AudioView", format: "mp3", autoplay: true, loop: true, controls: true, value: new DataView(new ArrayBuffer(0)) });
      }
    };
    AudioModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { value: {
      serialize: (value) => {
        return new DataView(value.buffer.slice(0));
      }
    } });
    AudioView = class extends DOMWidgetView {
      render() {
        super.render();
        this.luminoWidget.addClass("jupyter-widgets");
        this.update();
      }
      update() {
        let url;
        const format2 = this.model.get("format");
        const value = this.model.get("value");
        if (format2 !== "url") {
          const blob = new Blob([value], {
            type: `audio/${this.model.get("format")}`
          });
          url = URL.createObjectURL(blob);
        } else {
          url = new TextDecoder("utf-8").decode(value.buffer);
        }
        const oldurl = this.el.src;
        this.el.src = url;
        if (oldurl) {
          URL.revokeObjectURL(oldurl);
        }
        this.el.loop = this.model.get("loop");
        this.el.autoplay = this.model.get("autoplay");
        this.el.controls = this.model.get("controls");
        return super.update();
      }
      remove() {
        if (this.el.src) {
          URL.revokeObjectURL(this.el.src);
        }
        super.remove();
      }
      preinitialize() {
        this.tagName = "audio";
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_color.js
function color2hex(color2) {
  return named_colors[color2.toLowerCase()] || rgb3_to_rgb6(color2);
}
function rgb3_to_rgb6(rgb) {
  if (rgb.length === 7) {
    return rgb;
  } else {
    return "#" + rgb.charAt(1) + rgb.charAt(1) + rgb.charAt(2) + rgb.charAt(2) + rgb.charAt(3) + rgb.charAt(3);
  }
}
var named_colors, ColorPickerModel, ColorPickerView;
var init_widget_color = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_color.js"() {
    init_widget_core();
    init_widget_description();
    init_utils3();
    named_colors = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgrey: "#a9a9a9",
      darkgreen: "#006400",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      grey: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgreen: "#90ee90",
      lightgray: "#d3d3d3",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    ColorPickerModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: "black", concise: false, _model_name: "ColorPickerModel", _view_name: "ColorPickerView" });
      }
    };
    ColorPickerView = class extends DescriptionView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-colorpicker");
        this._color_container = document.createElement("div");
        this._color_container.className = "widget-inline-hbox widget-colorpicker-input";
        this.el.appendChild(this._color_container);
        this._textbox = document.createElement("input");
        this._textbox.setAttribute("type", "text");
        this._textbox.id = this.label.htmlFor = uuid();
        this._color_container.appendChild(this._textbox);
        this._textbox.value = this.model.get("value");
        this._colorpicker = document.createElement("input");
        this._colorpicker.setAttribute("type", "color");
        this._color_container.appendChild(this._colorpicker);
        this.listenTo(this.model, "change:value", this._update_value);
        this.listenTo(this.model, "change:concise", this._update_concise);
        this._update_concise();
        this._update_value();
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view != this) {
          const disabled = this.model.get("disabled");
          this._textbox.disabled = disabled;
          this._colorpicker.disabled = disabled;
        }
        return super.update();
      }
      events() {
        void this._picker_change;
        void this._text_change;
        return {
          'change [type="color"]': "_picker_change",
          'change [type="text"]': "_text_change"
        };
      }
      _update_value() {
        const value = this.model.get("value");
        this._colorpicker.value = color2hex(value);
        this._textbox.value = value;
      }
      _update_concise() {
        const concise = this.model.get("concise");
        if (concise) {
          this.el.classList.add("concise");
          this._textbox.style.display = "none";
        } else {
          this.el.classList.remove("concise");
          this._textbox.style.display = "";
        }
      }
      _picker_change() {
        this.model.set("value", this._colorpicker.value);
        this.touch();
      }
      _text_change() {
        const value = this._validate_color(this._textbox.value, this.model.get("value"));
        this.model.set("value", value);
        this.touch();
      }
      _validate_color(color2, fallback) {
        return color2.match(/#[a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?$/) || named_colors[color2.toLowerCase()] ? color2 : fallback;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_date.js
function serialize_date(value) {
  if (value === null) {
    return null;
  } else {
    return {
      year: value.getUTCFullYear(),
      month: value.getUTCMonth(),
      date: value.getUTCDate()
    };
  }
}
function deserialize_date(value) {
  if (value === null) {
    return null;
  } else {
    const date = /* @__PURE__ */ new Date();
    date.setUTCFullYear(value.year, value.month, value.date);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
}
var DatePickerModel, DatePickerView;
var init_widget_date = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_date.js"() {
    init_widget_description();
    init_widget_core();
    init_utils3();
    DatePickerModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: null, _model_name: "DatePickerModel", _view_name: "DatePickerView" });
      }
    };
    DatePickerModel.serializers = Object.assign(Object.assign({}, CoreDescriptionModel.serializers), { value: {
      serialize: serialize_date,
      deserialize: deserialize_date
    } });
    DatePickerView = class extends DescriptionView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-datepicker");
        this._datepicker = document.createElement("input");
        this._datepicker.setAttribute("type", "date");
        this._datepicker.id = this.label.htmlFor = uuid();
        this.el.appendChild(this._datepicker);
        this.listenTo(this.model, "change:value", this._update_value);
        this._update_value();
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          this._datepicker.disabled = this.model.get("disabled");
        }
        return super.update();
      }
      events() {
        void this._picker_change;
        void this._picker_focusout;
        return {
          'change [type="date"]': "_picker_change",
          'focusout [type="date"]': "_picker_focusout"
        };
      }
      _update_value() {
        const value = this.model.get("value");
        this._datepicker.valueAsDate = value;
      }
      _picker_change() {
        if (!this._datepicker.validity.badInput) {
          this.model.set("value", this._datepicker.valueAsDate);
          this.touch();
        }
      }
      _picker_focusout() {
        if (this._datepicker.validity.badInput) {
          this.model.set("value", null);
          this.touch();
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_time.js
function serialize_time(value) {
  if (value === null) {
    return null;
  } else {
    const res = PARSER.exec(value);
    if (res === null) {
      return null;
    }
    return {
      hours: Math.min(23, parseInt(res[1], 10)),
      minutes: Math.min(59, parseInt(res[2], 10)),
      seconds: res[4] ? Math.min(59, parseInt(res[4], 10)) : 0,
      milliseconds: res[6] ? parseInt(res[6], 10) : 0
    };
  }
}
function deserialize_time(value) {
  if (value === null) {
    return null;
  } else {
    const parts = [
      `${value.hours.toString().padStart(2, "0")}:${value.minutes.toString().padStart(2, "0")}`
    ];
    if (value.seconds > 0 || value.milliseconds > 0) {
      parts.push(`:${value.seconds.toString().padStart(2, "0")}`);
      if (value.milliseconds > 0) {
        parts.push(`.${value.milliseconds.toString().padStart(3, "0")}`);
      }
    }
    return parts.join("");
  }
}
var PARSER, time_serializers, TimeModel, TimeView;
var init_widget_time = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_time.js"() {
    init_utils3();
    init_widget_description();
    init_widget_core();
    PARSER = /(\d\d):(\d\d)(:(\d\d)(.(\d{1,3})\d*)?)?/;
    time_serializers = {
      serialize: serialize_time,
      deserialize: deserialize_time
    };
    TimeModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: TimeModel.model_name, _view_name: TimeModel.view_name, value: null, disabled: false, min: null, max: null, step: 60 });
      }
    };
    TimeModel.serializers = Object.assign(Object.assign({}, CoreDescriptionModel.serializers), { value: time_serializers, min: time_serializers, max: time_serializers });
    TimeModel.model_name = "TimeModel";
    TimeModel.view_name = "TimeView";
    TimeView = class extends DescriptionView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-timepicker");
        this._timepicker = document.createElement("input");
        this._timepicker.setAttribute("type", "time");
        this._timepicker.id = this.label.htmlFor = uuid();
        this.el.appendChild(this._timepicker);
        this.listenTo(this.model, "change:value", this._update_value);
        this.listenTo(this.model, "change", this.update2);
        this._update_value();
        this.update2();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update2(model, options) {
        if (options === void 0 || options.updated_view !== this) {
          this._timepicker.disabled = this.model.get("disabled");
          this._timepicker.min = this.model.get("min");
          this._timepicker.max = this.model.get("max");
          this._timepicker.step = this.model.get("step");
        }
        return super.update();
      }
      events() {
        void this._picker_change;
        void this._picker_focusout;
        return {
          'change [type="time"]': "_picker_change",
          'focusout [type="time"]': "_picker_focusout"
        };
      }
      _update_value(model, newValue, options) {
        if (options === void 0 || options.updated_view !== this) {
          this._timepicker.value = this.model.get("value");
        }
      }
      _picker_change() {
        if (!this._timepicker.validity.badInput) {
          this.model.set("value", this._timepicker.value, { updated_view: this });
          this.touch();
        }
      }
      _picker_focusout() {
        if (this._timepicker.validity.badInput) {
          this.model.set("value", null, { updated_view: this });
          this.touch();
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_datetime.js
function serialize_datetime(value) {
  if (value === null) {
    return null;
  } else {
    return {
      year: value.getUTCFullYear(),
      month: value.getUTCMonth(),
      date: value.getUTCDate(),
      hours: value.getUTCHours(),
      minutes: value.getUTCMinutes(),
      seconds: value.getUTCSeconds(),
      milliseconds: value.getUTCMilliseconds()
    };
  }
}
function deserialize_datetime(value) {
  if (value === null) {
    return null;
  } else {
    const date = /* @__PURE__ */ new Date();
    date.setUTCFullYear(value.year, value.month, value.date);
    date.setUTCHours(value.hours, value.minutes, value.seconds, value.milliseconds);
    return date;
  }
}
function serialize_naive(value) {
  if (value === null) {
    return null;
  } else {
    return {
      year: value.getFullYear(),
      month: value.getMonth(),
      date: value.getDate(),
      hours: value.getHours(),
      minutes: value.getMinutes(),
      seconds: value.getSeconds(),
      milliseconds: value.getMilliseconds()
    };
  }
}
function deserialize_naive(value) {
  if (value === null) {
    return null;
  } else {
    const date = /* @__PURE__ */ new Date();
    date.setFullYear(value.year, value.month, value.date);
    date.setHours(value.hours, value.minutes, value.seconds, value.milliseconds);
    return date;
  }
}
var datetime_serializers, DatetimeModel, DatetimeView, Private18, naive_serializers, NaiveDatetimeModel;
var init_widget_datetime = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_datetime.js"() {
    init_utils3();
    init_widget_description();
    init_widget_core();
    init_widget_time();
    datetime_serializers = {
      serialize: serialize_datetime,
      deserialize: deserialize_datetime
    };
    DatetimeModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "DatetimeModel", _view_name: "DatetimeView", value: null, disabled: false, min: null, max: null });
      }
    };
    DatetimeModel.serializers = Object.assign(Object.assign({}, CoreDescriptionModel.serializers), { value: datetime_serializers, min: datetime_serializers, max: datetime_serializers });
    DatetimeView = class extends DescriptionView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-datetimepicker");
        const test = document.createElement("input");
        test.type = "datetime-local";
        if (test.type === "text") {
          this._datepicker = document.createElement("input");
          this._datepicker.setAttribute("type", "date");
          this._datepicker.id = this.label.htmlFor = uuid();
          this._timepicker = document.createElement("input");
          this._timepicker.setAttribute("type", "time");
          this._timepicker.id = uuid();
          this.el.appendChild(this._datepicker);
          this.el.appendChild(this._timepicker);
        } else {
          this._datetimepicker = test;
          this._datetimepicker.id = this.label.htmlFor = uuid();
          this.el.appendChild(this._datetimepicker);
        }
        this.listenTo(this.model, "change:value", this._update_value);
        this.listenTo(this.model, "change", this.update2);
        this._update_value();
        this.update2();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update2(model, options) {
        if (options === void 0 || options.updated_view !== this) {
          const min3 = this.model.get("min");
          const max3 = this.model.get("max");
          if (this._datetimepicker) {
            this._datetimepicker.disabled = this.model.get("disabled");
            this._datetimepicker.min = Private18.dt_as_dt_string(min3);
            this._datetimepicker.max = Private18.dt_as_dt_string(max3);
          } else {
            this._datepicker.disabled = this.model.get("disabled");
            this._datepicker.min = Private18.dt_as_date_string(min3);
            this._datepicker.max = Private18.dt_as_date_string(max3);
            this._timepicker.disabled = this.model.get("disabled");
          }
        }
      }
      events() {
        void this._picker_change;
        void this._picker_focusout;
        return {
          'change [type="date"]': "_picker_change",
          'change [type="time"]': "_picker_change",
          'change [type="datetime-local"]': "_picker_change",
          'focusout [type="date"]': "_picker_focusout",
          'focusout [type="datetime-local"]': "_picker_focusout",
          'focusout [type="time"]': "_picker_focusout"
        };
      }
      _update_value(model, newValue, options) {
        if (options === void 0 || options.updated_view !== this) {
          const value = this.model.get("value");
          if (this._datetimepicker) {
            this._datetimepicker.value = Private18.dt_as_dt_string(value);
          } else {
            this._datepicker.valueAsDate = value;
            this._timepicker.value = Private18.dt_as_time_string(value);
          }
        }
      }
      _picker_change() {
        if (this._datetimepicker) {
          if (!this._datetimepicker.validity.badInput) {
            const v2 = this._datetimepicker.value;
            let date = v2 ? new Date(v2) : null;
            if (date && isNaN(date.valueOf())) {
              date = null;
            }
            this.model.set("value", date, { updated_view: this });
            this.touch();
          }
        } else {
          if (!this._datepicker.validity.badInput && !this._timepicker.validity.badInput) {
            const date = this._datepicker.valueAsDate;
            const time = serialize_time(this._timepicker.value);
            if (date !== null && time !== null) {
              date.setHours(time.hours, time.minutes, time.seconds, time.milliseconds);
            }
            this.model.set("value", time !== null && date, { updated_view: this });
            this.touch();
          }
        }
      }
      _picker_focusout() {
        const pickers = [this._datetimepicker, this._datepicker, this._timepicker];
        if (pickers.some((p3) => p3 && p3.validity.badInput)) {
          this.model.set("value", null);
          this.touch();
        }
      }
    };
    (function(Private19) {
      function dt_as_dt_string(value) {
        if (value === null) {
          return "";
        }
        const parts = [];
        parts.push(`${value.getFullYear().toString().padStart(4, "0")}`);
        parts.push(`-${(value.getMonth() + 1).toString().padStart(2, "0")}`);
        parts.push(`-${value.getDate().toString().padStart(2, "0")}`);
        parts.push(`T${value.getHours().toString().padStart(2, "0")}`);
        parts.push(`:${value.getMinutes().toString().padStart(2, "0")}`);
        if (value.getSeconds() > 0 || value.getMilliseconds() > 0) {
          parts.push(`:${value.getSeconds().toString().padStart(2, "0")}`);
          if (value.getMilliseconds() > 0) {
            parts.push(`.${value.getMilliseconds().toString().padStart(3, "0")}`);
          }
        }
        return parts.join("");
      }
      Private19.dt_as_dt_string = dt_as_dt_string;
      function dt_as_date_string(value) {
        return value ? dt_as_dt_string(value).split("T", 2)[0] : "";
      }
      Private19.dt_as_date_string = dt_as_date_string;
      function dt_as_time_string(value) {
        return value ? dt_as_dt_string(value).split("T", 2)[1] : "";
      }
      Private19.dt_as_time_string = dt_as_time_string;
    })(Private18 || (Private18 = {}));
    naive_serializers = {
      serialize: serialize_naive,
      deserialize: deserialize_naive
    };
    NaiveDatetimeModel = class extends DatetimeModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "NaiveDatetimeModel" });
      }
    };
    NaiveDatetimeModel.serializers = Object.assign(Object.assign({}, CoreDescriptionModel.serializers), { value: naive_serializers, min: naive_serializers, max: naive_serializers });
  }
});

// ../../node_modules/nouislider/dist/nouislider.js
var require_nouislider = __commonJS({
  "../../node_modules/nouislider/dist/nouislider.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.noUiSlider = {}));
    })(exports2, function(exports3) {
      "use strict";
      exports3.PipsMode = void 0;
      (function(PipsMode) {
        PipsMode["Range"] = "range";
        PipsMode["Steps"] = "steps";
        PipsMode["Positions"] = "positions";
        PipsMode["Count"] = "count";
        PipsMode["Values"] = "values";
      })(exports3.PipsMode || (exports3.PipsMode = {}));
      exports3.PipsType = void 0;
      (function(PipsType) {
        PipsType[PipsType["None"] = -1] = "None";
        PipsType[PipsType["NoValue"] = 0] = "NoValue";
        PipsType[PipsType["LargeValue"] = 1] = "LargeValue";
        PipsType[PipsType["SmallValue"] = 2] = "SmallValue";
      })(exports3.PipsType || (exports3.PipsType = {}));
      function isValidFormatter(entry) {
        return isValidPartialFormatter(entry) && typeof entry.from === "function";
      }
      function isValidPartialFormatter(entry) {
        return typeof entry === "object" && typeof entry.to === "function";
      }
      function removeElement(el) {
        el.parentElement.removeChild(el);
      }
      function isSet(value) {
        return value !== null && value !== void 0;
      }
      function preventDefault(e4) {
        e4.preventDefault();
      }
      function unique(array) {
        return array.filter(function(a4) {
          return !this[a4] ? this[a4] = true : false;
        }, {});
      }
      function closest(value, to) {
        return Math.round(value / to) * to;
      }
      function offset2(elem, orientation) {
        var rect = elem.getBoundingClientRect();
        var doc = elem.ownerDocument;
        var docElem = doc.documentElement;
        var pageOffset = getPageOffset(doc);
        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
          pageOffset.x = 0;
        }
        return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;
      }
      function isNumeric(a4) {
        return typeof a4 === "number" && !isNaN(a4) && isFinite(a4);
      }
      function addClassFor(element2, className, duration) {
        if (duration > 0) {
          addClass(element2, className);
          setTimeout(function() {
            removeClass(element2, className);
          }, duration);
        }
      }
      function limit(a4) {
        return Math.max(Math.min(a4, 100), 0);
      }
      function asArray(a4) {
        return Array.isArray(a4) ? a4 : [a4];
      }
      function countDecimals(numStr) {
        numStr = String(numStr);
        var pieces = numStr.split(".");
        return pieces.length > 1 ? pieces[1].length : 0;
      }
      function addClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
          el.classList.add(className);
        } else {
          el.className += " " + className;
        }
      }
      function removeClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
          el.classList.remove(className);
        } else {
          el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
        }
      }
      function hasClass(el, className) {
        return el.classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className);
      }
      function getPageOffset(doc) {
        var supportPageOffset = window.pageXOffset !== void 0;
        var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
        var x4 = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;
        var y3 = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;
        return {
          x: x4,
          y: y3
        };
      }
      function getActions() {
        return window.navigator.pointerEnabled ? {
          start: "pointerdown",
          move: "pointermove",
          end: "pointerup"
        } : window.navigator.msPointerEnabled ? {
          start: "MSPointerDown",
          move: "MSPointerMove",
          end: "MSPointerUp"
        } : {
          start: "mousedown touchstart",
          move: "mousemove touchmove",
          end: "mouseup touchend"
        };
      }
      function getSupportsPassive() {
        var supportsPassive = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassive = true;
            }
          });
          window.addEventListener("test", null, opts);
        } catch (e4) {
        }
        return supportsPassive;
      }
      function getSupportsTouchActionNone() {
        return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
      }
      function subRangeRatio(pa, pb) {
        return 100 / (pb - pa);
      }
      function fromPercentage(range2, value, startRange) {
        return value * 100 / (range2[startRange + 1] - range2[startRange]);
      }
      function toPercentage(range2, value) {
        return fromPercentage(range2, range2[0] < 0 ? value + Math.abs(range2[0]) : value - range2[0], 0);
      }
      function isPercentage(range2, value) {
        return value * (range2[1] - range2[0]) / 100 + range2[0];
      }
      function getJ(value, arr) {
        var j2 = 1;
        while (value >= arr[j2]) {
          j2 += 1;
        }
        return j2;
      }
      function toStepping(xVal, xPct, value) {
        if (value >= xVal.slice(-1)[0]) {
          return 100;
        }
        var j2 = getJ(value, xVal);
        var va = xVal[j2 - 1];
        var vb = xVal[j2];
        var pa = xPct[j2 - 1];
        var pb = xPct[j2];
        return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);
      }
      function fromStepping(xVal, xPct, value) {
        if (value >= 100) {
          return xVal.slice(-1)[0];
        }
        var j2 = getJ(value, xPct);
        var va = xVal[j2 - 1];
        var vb = xVal[j2];
        var pa = xPct[j2 - 1];
        var pb = xPct[j2];
        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
      }
      function getStep(xPct, xSteps, snap, value) {
        if (value === 100) {
          return value;
        }
        var j2 = getJ(value, xPct);
        var a4 = xPct[j2 - 1];
        var b4 = xPct[j2];
        if (snap) {
          if (value - a4 > (b4 - a4) / 2) {
            return b4;
          }
          return a4;
        }
        if (!xSteps[j2 - 1]) {
          return value;
        }
        return xPct[j2 - 1] + closest(value - xPct[j2 - 1], xSteps[j2 - 1]);
      }
      var Spectrum = (
        /** @class */
        function() {
          function Spectrum2(entry, snap, singleStep) {
            this.xPct = [];
            this.xVal = [];
            this.xSteps = [];
            this.xNumSteps = [];
            this.xHighestCompleteStep = [];
            this.xSteps = [singleStep || false];
            this.xNumSteps = [false];
            this.snap = snap;
            var index2;
            var ordered = [];
            Object.keys(entry).forEach(function(index3) {
              ordered.push([asArray(entry[index3]), index3]);
            });
            ordered.sort(function(a4, b4) {
              return a4[0][0] - b4[0][0];
            });
            for (index2 = 0; index2 < ordered.length; index2++) {
              this.handleEntryPoint(ordered[index2][1], ordered[index2][0]);
            }
            this.xNumSteps = this.xSteps.slice(0);
            for (index2 = 0; index2 < this.xNumSteps.length; index2++) {
              this.handleStepPoint(index2, this.xNumSteps[index2]);
            }
          }
          Spectrum2.prototype.getDistance = function(value) {
            var index2;
            var distances = [];
            for (index2 = 0; index2 < this.xNumSteps.length - 1; index2++) {
              var step = this.xNumSteps[index2];
              if (step && value / step % 1 !== 0) {
                throw new Error("noUiSlider: 'limit', 'margin' and 'padding' of " + this.xPct[index2] + "% range must be divisible by step.");
              }
              distances[index2] = fromPercentage(this.xVal, value, index2);
            }
            return distances;
          };
          Spectrum2.prototype.getAbsoluteDistance = function(value, distances, direction) {
            var xPct_index = 0;
            if (value < this.xPct[this.xPct.length - 1]) {
              while (value > this.xPct[xPct_index + 1]) {
                xPct_index++;
              }
            } else if (value === this.xPct[this.xPct.length - 1]) {
              xPct_index = this.xPct.length - 2;
            }
            if (!direction && value === this.xPct[xPct_index + 1]) {
              xPct_index++;
            }
            if (distances === null) {
              distances = [];
            }
            var start_factor;
            var rest_factor = 1;
            var rest_rel_distance = distances[xPct_index];
            var range_pct = 0;
            var rel_range_distance = 0;
            var abs_distance_counter = 0;
            var range_counter = 0;
            if (direction) {
              start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
            } else {
              start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
            }
            while (rest_rel_distance > 0) {
              range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter];
              if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
                rel_range_distance = range_pct * start_factor;
                rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter];
                start_factor = 1;
              } else {
                rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor;
                rest_factor = 0;
              }
              if (direction) {
                abs_distance_counter = abs_distance_counter - rel_range_distance;
                if (this.xPct.length + range_counter >= 1) {
                  range_counter--;
                }
              } else {
                abs_distance_counter = abs_distance_counter + rel_range_distance;
                if (this.xPct.length - range_counter >= 1) {
                  range_counter++;
                }
              }
              rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
            }
            return value + abs_distance_counter;
          };
          Spectrum2.prototype.toStepping = function(value) {
            value = toStepping(this.xVal, this.xPct, value);
            return value;
          };
          Spectrum2.prototype.fromStepping = function(value) {
            return fromStepping(this.xVal, this.xPct, value);
          };
          Spectrum2.prototype.getStep = function(value) {
            value = getStep(this.xPct, this.xSteps, this.snap, value);
            return value;
          };
          Spectrum2.prototype.getDefaultStep = function(value, isDown, size3) {
            var j2 = getJ(value, this.xPct);
            if (value === 100 || isDown && value === this.xPct[j2 - 1]) {
              j2 = Math.max(j2 - 1, 1);
            }
            return (this.xVal[j2] - this.xVal[j2 - 1]) / size3;
          };
          Spectrum2.prototype.getNearbySteps = function(value) {
            var j2 = getJ(value, this.xPct);
            return {
              stepBefore: {
                startValue: this.xVal[j2 - 2],
                step: this.xNumSteps[j2 - 2],
                highestStep: this.xHighestCompleteStep[j2 - 2]
              },
              thisStep: {
                startValue: this.xVal[j2 - 1],
                step: this.xNumSteps[j2 - 1],
                highestStep: this.xHighestCompleteStep[j2 - 1]
              },
              stepAfter: {
                startValue: this.xVal[j2],
                step: this.xNumSteps[j2],
                highestStep: this.xHighestCompleteStep[j2]
              }
            };
          };
          Spectrum2.prototype.countStepDecimals = function() {
            var stepDecimals = this.xNumSteps.map(countDecimals);
            return Math.max.apply(null, stepDecimals);
          };
          Spectrum2.prototype.hasNoSize = function() {
            return this.xVal[0] === this.xVal[this.xVal.length - 1];
          };
          Spectrum2.prototype.convert = function(value) {
            return this.getStep(this.toStepping(value));
          };
          Spectrum2.prototype.handleEntryPoint = function(index2, value) {
            var percentage;
            if (index2 === "min") {
              percentage = 0;
            } else if (index2 === "max") {
              percentage = 100;
            } else {
              percentage = parseFloat(index2);
            }
            if (!isNumeric(percentage) || !isNumeric(value[0])) {
              throw new Error("noUiSlider: 'range' value isn't numeric.");
            }
            this.xPct.push(percentage);
            this.xVal.push(value[0]);
            var value1 = Number(value[1]);
            if (!percentage) {
              if (!isNaN(value1)) {
                this.xSteps[0] = value1;
              }
            } else {
              this.xSteps.push(isNaN(value1) ? false : value1);
            }
            this.xHighestCompleteStep.push(0);
          };
          Spectrum2.prototype.handleStepPoint = function(i5, n4) {
            if (!n4) {
              return;
            }
            if (this.xVal[i5] === this.xVal[i5 + 1]) {
              this.xSteps[i5] = this.xHighestCompleteStep[i5] = this.xVal[i5];
              return;
            }
            this.xSteps[i5] = fromPercentage([this.xVal[i5], this.xVal[i5 + 1]], n4, 0) / subRangeRatio(this.xPct[i5], this.xPct[i5 + 1]);
            var totalSteps = (this.xVal[i5 + 1] - this.xVal[i5]) / this.xNumSteps[i5];
            var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
            var step = this.xVal[i5] + this.xNumSteps[i5] * highestStep;
            this.xHighestCompleteStep[i5] = step;
          };
          return Spectrum2;
        }()
      );
      var defaultFormatter = {
        to: function(value) {
          return value === void 0 ? "" : value.toFixed(2);
        },
        from: Number
      };
      var cssClasses = {
        target: "target",
        base: "base",
        origin: "origin",
        handle: "handle",
        handleLower: "handle-lower",
        handleUpper: "handle-upper",
        touchArea: "touch-area",
        horizontal: "horizontal",
        vertical: "vertical",
        background: "background",
        connect: "connect",
        connects: "connects",
        ltr: "ltr",
        rtl: "rtl",
        textDirectionLtr: "txt-dir-ltr",
        textDirectionRtl: "txt-dir-rtl",
        draggable: "draggable",
        drag: "state-drag",
        tap: "state-tap",
        active: "active",
        tooltip: "tooltip",
        pips: "pips",
        pipsHorizontal: "pips-horizontal",
        pipsVertical: "pips-vertical",
        marker: "marker",
        markerHorizontal: "marker-horizontal",
        markerVertical: "marker-vertical",
        markerNormal: "marker-normal",
        markerLarge: "marker-large",
        markerSub: "marker-sub",
        value: "value",
        valueHorizontal: "value-horizontal",
        valueVertical: "value-vertical",
        valueNormal: "value-normal",
        valueLarge: "value-large",
        valueSub: "value-sub"
      };
      var INTERNAL_EVENT_NS = {
        tooltips: ".__tooltips",
        aria: ".__aria"
      };
      function testStep(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'step' is not numeric.");
        }
        parsed.singleStep = entry;
      }
      function testKeyboardPageMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
        }
        parsed.keyboardPageMultiplier = entry;
      }
      function testKeyboardMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
        }
        parsed.keyboardMultiplier = entry;
      }
      function testKeyboardDefaultStep(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
        }
        parsed.keyboardDefaultStep = entry;
      }
      function testRange(parsed, entry) {
        if (typeof entry !== "object" || Array.isArray(entry)) {
          throw new Error("noUiSlider: 'range' is not an object.");
        }
        if (entry.min === void 0 || entry.max === void 0) {
          throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
        }
        parsed.spectrum = new Spectrum(entry, parsed.snap || false, parsed.singleStep);
      }
      function testStart(parsed, entry) {
        entry = asArray(entry);
        if (!Array.isArray(entry) || !entry.length) {
          throw new Error("noUiSlider: 'start' option is incorrect.");
        }
        parsed.handles = entry.length;
        parsed.start = entry;
      }
      function testSnap(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'snap' option must be a boolean.");
        }
        parsed.snap = entry;
      }
      function testAnimate(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'animate' option must be a boolean.");
        }
        parsed.animate = entry;
      }
      function testAnimationDuration(parsed, entry) {
        if (typeof entry !== "number") {
          throw new Error("noUiSlider: 'animationDuration' option must be a number.");
        }
        parsed.animationDuration = entry;
      }
      function testConnect(parsed, entry) {
        var connect = [false];
        var i5;
        if (entry === "lower") {
          entry = [true, false];
        } else if (entry === "upper") {
          entry = [false, true];
        }
        if (entry === true || entry === false) {
          for (i5 = 1; i5 < parsed.handles; i5++) {
            connect.push(entry);
          }
          connect.push(false);
        } else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {
          throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
        } else {
          connect = entry;
        }
        parsed.connect = connect;
      }
      function testOrientation(parsed, entry) {
        switch (entry) {
          case "horizontal":
            parsed.ort = 0;
            break;
          case "vertical":
            parsed.ort = 1;
            break;
          default:
            throw new Error("noUiSlider: 'orientation' option is invalid.");
        }
      }
      function testMargin(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'margin' option must be numeric.");
        }
        if (entry === 0) {
          return;
        }
        parsed.margin = parsed.spectrum.getDistance(entry);
      }
      function testLimit(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'limit' option must be numeric.");
        }
        parsed.limit = parsed.spectrum.getDistance(entry);
        if (!parsed.limit || parsed.handles < 2) {
          throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
        }
      }
      function testPadding(parsed, entry) {
        var index2;
        if (!isNumeric(entry) && !Array.isArray(entry)) {
          throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
        }
        if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {
          throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
        }
        if (entry === 0) {
          return;
        }
        if (!Array.isArray(entry)) {
          entry = [entry, entry];
        }
        parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];
        for (index2 = 0; index2 < parsed.spectrum.xNumSteps.length - 1; index2++) {
          if (parsed.padding[0][index2] < 0 || parsed.padding[1][index2] < 0) {
            throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
          }
        }
        var totalPadding = entry[0] + entry[1];
        var firstValue = parsed.spectrum.xVal[0];
        var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];
        if (totalPadding / (lastValue - firstValue) > 1) {
          throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
        }
      }
      function testDirection(parsed, entry) {
        switch (entry) {
          case "ltr":
            parsed.dir = 0;
            break;
          case "rtl":
            parsed.dir = 1;
            break;
          default:
            throw new Error("noUiSlider: 'direction' option was not recognized.");
        }
      }
      function testBehaviour(parsed, entry) {
        if (typeof entry !== "string") {
          throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
        }
        var tap2 = entry.indexOf("tap") >= 0;
        var drag = entry.indexOf("drag") >= 0;
        var fixed = entry.indexOf("fixed") >= 0;
        var snap = entry.indexOf("snap") >= 0;
        var hover = entry.indexOf("hover") >= 0;
        var unconstrained = entry.indexOf("unconstrained") >= 0;
        var dragAll = entry.indexOf("drag-all") >= 0;
        if (fixed) {
          if (parsed.handles !== 2) {
            throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
          }
          testMargin(parsed, parsed.start[1] - parsed.start[0]);
        }
        if (unconstrained && (parsed.margin || parsed.limit)) {
          throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
        }
        parsed.events = {
          tap: tap2 || snap,
          drag,
          dragAll,
          fixed,
          snap,
          hover,
          unconstrained
        };
      }
      function testTooltips(parsed, entry) {
        if (entry === false) {
          return;
        }
        if (entry === true || isValidPartialFormatter(entry)) {
          parsed.tooltips = [];
          for (var i5 = 0; i5 < parsed.handles; i5++) {
            parsed.tooltips.push(entry);
          }
        } else {
          entry = asArray(entry);
          if (entry.length !== parsed.handles) {
            throw new Error("noUiSlider: must pass a formatter for all handles.");
          }
          entry.forEach(function(formatter) {
            if (typeof formatter !== "boolean" && !isValidPartialFormatter(formatter)) {
              throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
            }
          });
          parsed.tooltips = entry;
        }
      }
      function testHandleAttributes(parsed, entry) {
        if (entry.length !== parsed.handles) {
          throw new Error("noUiSlider: must pass a attributes for all handles.");
        }
        parsed.handleAttributes = entry;
      }
      function testAriaFormat(parsed, entry) {
        if (!isValidPartialFormatter(entry)) {
          throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
        }
        parsed.ariaFormat = entry;
      }
      function testFormat(parsed, entry) {
        if (!isValidFormatter(entry)) {
          throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
        }
        parsed.format = entry;
      }
      function testKeyboardSupport(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
        }
        parsed.keyboardSupport = entry;
      }
      function testDocumentElement(parsed, entry) {
        parsed.documentElement = entry;
      }
      function testCssPrefix(parsed, entry) {
        if (typeof entry !== "string" && entry !== false) {
          throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
        }
        parsed.cssPrefix = entry;
      }
      function testCssClasses(parsed, entry) {
        if (typeof entry !== "object") {
          throw new Error("noUiSlider: 'cssClasses' must be an object.");
        }
        if (typeof parsed.cssPrefix === "string") {
          parsed.cssClasses = {};
          Object.keys(entry).forEach(function(key) {
            parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
          });
        } else {
          parsed.cssClasses = entry;
        }
      }
      function testOptions(options) {
        var parsed = {
          margin: null,
          limit: null,
          padding: null,
          animate: true,
          animationDuration: 300,
          ariaFormat: defaultFormatter,
          format: defaultFormatter
        };
        var tests = {
          step: { r: false, t: testStep },
          keyboardPageMultiplier: { r: false, t: testKeyboardPageMultiplier },
          keyboardMultiplier: { r: false, t: testKeyboardMultiplier },
          keyboardDefaultStep: { r: false, t: testKeyboardDefaultStep },
          start: { r: true, t: testStart },
          connect: { r: true, t: testConnect },
          direction: { r: true, t: testDirection },
          snap: { r: false, t: testSnap },
          animate: { r: false, t: testAnimate },
          animationDuration: { r: false, t: testAnimationDuration },
          range: { r: true, t: testRange },
          orientation: { r: false, t: testOrientation },
          margin: { r: false, t: testMargin },
          limit: { r: false, t: testLimit },
          padding: { r: false, t: testPadding },
          behaviour: { r: true, t: testBehaviour },
          ariaFormat: { r: false, t: testAriaFormat },
          format: { r: false, t: testFormat },
          tooltips: { r: false, t: testTooltips },
          keyboardSupport: { r: true, t: testKeyboardSupport },
          documentElement: { r: false, t: testDocumentElement },
          cssPrefix: { r: true, t: testCssPrefix },
          cssClasses: { r: true, t: testCssClasses },
          handleAttributes: { r: false, t: testHandleAttributes }
        };
        var defaults = {
          connect: false,
          direction: "ltr",
          behaviour: "tap",
          orientation: "horizontal",
          keyboardSupport: true,
          cssPrefix: "noUi-",
          cssClasses,
          keyboardPageMultiplier: 5,
          keyboardMultiplier: 1,
          keyboardDefaultStep: 10
        };
        if (options.format && !options.ariaFormat) {
          options.ariaFormat = options.format;
        }
        Object.keys(tests).forEach(function(name2) {
          if (!isSet(options[name2]) && defaults[name2] === void 0) {
            if (tests[name2].r) {
              throw new Error("noUiSlider: '" + name2 + "' is required.");
            }
            return;
          }
          tests[name2].t(parsed, !isSet(options[name2]) ? defaults[name2] : options[name2]);
        });
        parsed.pips = options.pips;
        var d6 = document.createElement("div");
        var msPrefix = d6.style.msTransform !== void 0;
        var noPrefix = d6.style.transform !== void 0;
        parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";
        var styles = [
          ["left", "top"],
          ["right", "bottom"]
        ];
        parsed.style = styles[parsed.dir][parsed.ort];
        return parsed;
      }
      function scope(target, options, originalOptions) {
        var actions = getActions();
        var supportsTouchActionNone = getSupportsTouchActionNone();
        var supportsPassive = supportsTouchActionNone && getSupportsPassive();
        var scope_Target = target;
        var scope_Base;
        var scope_Handles;
        var scope_Connects;
        var scope_Pips;
        var scope_Tooltips;
        var scope_Spectrum = options.spectrum;
        var scope_Values = [];
        var scope_Locations = [];
        var scope_HandleNumbers = [];
        var scope_ActiveHandlesCount = 0;
        var scope_Events = {};
        var scope_Document = target.ownerDocument;
        var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
        var scope_Body = scope_Document.body;
        var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;
        function addNodeTo(addTarget, className) {
          var div = scope_Document.createElement("div");
          if (className) {
            addClass(div, className);
          }
          addTarget.appendChild(div);
          return div;
        }
        function addOrigin(base, handleNumber) {
          var origin = addNodeTo(base, options.cssClasses.origin);
          var handle = addNodeTo(origin, options.cssClasses.handle);
          addNodeTo(handle, options.cssClasses.touchArea);
          handle.setAttribute("data-handle", String(handleNumber));
          if (options.keyboardSupport) {
            handle.setAttribute("tabindex", "0");
            handle.addEventListener("keydown", function(event) {
              return eventKeydown(event, handleNumber);
            });
          }
          if (options.handleAttributes !== void 0) {
            var attributes_1 = options.handleAttributes[handleNumber];
            Object.keys(attributes_1).forEach(function(attribute) {
              handle.setAttribute(attribute, attributes_1[attribute]);
            });
          }
          handle.setAttribute("role", "slider");
          handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");
          if (handleNumber === 0) {
            addClass(handle, options.cssClasses.handleLower);
          } else if (handleNumber === options.handles - 1) {
            addClass(handle, options.cssClasses.handleUpper);
          }
          return origin;
        }
        function addConnect(base, add) {
          if (!add) {
            return false;
          }
          return addNodeTo(base, options.cssClasses.connect);
        }
        function addElements(connectOptions, base) {
          var connectBase = addNodeTo(base, options.cssClasses.connects);
          scope_Handles = [];
          scope_Connects = [];
          scope_Connects.push(addConnect(connectBase, connectOptions[0]));
          for (var i5 = 0; i5 < options.handles; i5++) {
            scope_Handles.push(addOrigin(base, i5));
            scope_HandleNumbers[i5] = i5;
            scope_Connects.push(addConnect(connectBase, connectOptions[i5 + 1]));
          }
        }
        function addSlider(addTarget) {
          addClass(addTarget, options.cssClasses.target);
          if (options.dir === 0) {
            addClass(addTarget, options.cssClasses.ltr);
          } else {
            addClass(addTarget, options.cssClasses.rtl);
          }
          if (options.ort === 0) {
            addClass(addTarget, options.cssClasses.horizontal);
          } else {
            addClass(addTarget, options.cssClasses.vertical);
          }
          var textDirection = getComputedStyle(addTarget).direction;
          if (textDirection === "rtl") {
            addClass(addTarget, options.cssClasses.textDirectionRtl);
          } else {
            addClass(addTarget, options.cssClasses.textDirectionLtr);
          }
          return addNodeTo(addTarget, options.cssClasses.base);
        }
        function addTooltip(handle, handleNumber) {
          if (!options.tooltips || !options.tooltips[handleNumber]) {
            return false;
          }
          return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
        }
        function isSliderDisabled() {
          return scope_Target.hasAttribute("disabled");
        }
        function isHandleDisabled(handleNumber) {
          var handleOrigin = scope_Handles[handleNumber];
          return handleOrigin.hasAttribute("disabled");
        }
        function removeTooltips() {
          if (scope_Tooltips) {
            removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
            scope_Tooltips.forEach(function(tooltip) {
              if (tooltip) {
                removeElement(tooltip);
              }
            });
            scope_Tooltips = null;
          }
        }
        function tooltips() {
          removeTooltips();
          scope_Tooltips = scope_Handles.map(addTooltip);
          bindEvent("update" + INTERNAL_EVENT_NS.tooltips, function(values2, handleNumber, unencoded) {
            if (!scope_Tooltips || !options.tooltips) {
              return;
            }
            if (scope_Tooltips[handleNumber] === false) {
              return;
            }
            var formattedValue = values2[handleNumber];
            if (options.tooltips[handleNumber] !== true) {
              formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
            }
            scope_Tooltips[handleNumber].innerHTML = formattedValue;
          });
        }
        function aria() {
          removeEvent("update" + INTERNAL_EVENT_NS.aria);
          bindEvent("update" + INTERNAL_EVENT_NS.aria, function(values2, handleNumber, unencoded, tap2, positions) {
            scope_HandleNumbers.forEach(function(index2) {
              var handle = scope_Handles[index2];
              var min3 = checkHandlePosition(scope_Locations, index2, 0, true, true, true);
              var max3 = checkHandlePosition(scope_Locations, index2, 100, true, true, true);
              var now = positions[index2];
              var text = String(options.ariaFormat.to(unencoded[index2]));
              min3 = scope_Spectrum.fromStepping(min3).toFixed(1);
              max3 = scope_Spectrum.fromStepping(max3).toFixed(1);
              now = scope_Spectrum.fromStepping(now).toFixed(1);
              handle.children[0].setAttribute("aria-valuemin", min3);
              handle.children[0].setAttribute("aria-valuemax", max3);
              handle.children[0].setAttribute("aria-valuenow", now);
              handle.children[0].setAttribute("aria-valuetext", text);
            });
          });
        }
        function getGroup(pips2) {
          if (pips2.mode === exports3.PipsMode.Range || pips2.mode === exports3.PipsMode.Steps) {
            return scope_Spectrum.xVal;
          }
          if (pips2.mode === exports3.PipsMode.Count) {
            if (pips2.values < 2) {
              throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
            }
            var interval = pips2.values - 1;
            var spread = 100 / interval;
            var values2 = [];
            while (interval--) {
              values2[interval] = interval * spread;
            }
            values2.push(100);
            return mapToRange(values2, pips2.stepped);
          }
          if (pips2.mode === exports3.PipsMode.Positions) {
            return mapToRange(pips2.values, pips2.stepped);
          }
          if (pips2.mode === exports3.PipsMode.Values) {
            if (pips2.stepped) {
              return pips2.values.map(function(value) {
                return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
              });
            }
            return pips2.values;
          }
          return [];
        }
        function mapToRange(values2, stepped) {
          return values2.map(function(value) {
            return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
          });
        }
        function generateSpread(pips2) {
          function safeIncrement(value, increment) {
            return Number((value + increment).toFixed(7));
          }
          var group2 = getGroup(pips2);
          var indexes = {};
          var firstInRange = scope_Spectrum.xVal[0];
          var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
          var ignoreFirst = false;
          var ignoreLast = false;
          var prevPct = 0;
          group2 = unique(group2.slice().sort(function(a4, b4) {
            return a4 - b4;
          }));
          if (group2[0] !== firstInRange) {
            group2.unshift(firstInRange);
            ignoreFirst = true;
          }
          if (group2[group2.length - 1] !== lastInRange) {
            group2.push(lastInRange);
            ignoreLast = true;
          }
          group2.forEach(function(current, index2) {
            var step;
            var i5;
            var q2;
            var low = current;
            var high = group2[index2 + 1];
            var newPct;
            var pctDifference;
            var pctPos;
            var type2;
            var steps;
            var realSteps;
            var stepSize;
            var isSteps = pips2.mode === exports3.PipsMode.Steps;
            if (isSteps) {
              step = scope_Spectrum.xNumSteps[index2];
            }
            if (!step) {
              step = high - low;
            }
            if (high === void 0) {
              high = low;
            }
            step = Math.max(step, 1e-7);
            for (i5 = low; i5 <= high; i5 = safeIncrement(i5, step)) {
              newPct = scope_Spectrum.toStepping(i5);
              pctDifference = newPct - prevPct;
              steps = pctDifference / (pips2.density || 1);
              realSteps = Math.round(steps);
              stepSize = pctDifference / realSteps;
              for (q2 = 1; q2 <= realSteps; q2 += 1) {
                pctPos = prevPct + q2 * stepSize;
                indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];
              }
              type2 = group2.indexOf(i5) > -1 ? exports3.PipsType.LargeValue : isSteps ? exports3.PipsType.SmallValue : exports3.PipsType.NoValue;
              if (!index2 && ignoreFirst && i5 !== high) {
                type2 = 0;
              }
              if (!(i5 === high && ignoreLast)) {
                indexes[newPct.toFixed(5)] = [i5, type2];
              }
              prevPct = newPct;
            }
          });
          return indexes;
        }
        function addMarking(spread, filterFunc, formatter) {
          var _a, _b;
          var element2 = scope_Document.createElement("div");
          var valueSizeClasses = (_a = {}, _a[exports3.PipsType.None] = "", _a[exports3.PipsType.NoValue] = options.cssClasses.valueNormal, _a[exports3.PipsType.LargeValue] = options.cssClasses.valueLarge, _a[exports3.PipsType.SmallValue] = options.cssClasses.valueSub, _a);
          var markerSizeClasses = (_b = {}, _b[exports3.PipsType.None] = "", _b[exports3.PipsType.NoValue] = options.cssClasses.markerNormal, _b[exports3.PipsType.LargeValue] = options.cssClasses.markerLarge, _b[exports3.PipsType.SmallValue] = options.cssClasses.markerSub, _b);
          var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];
          var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];
          addClass(element2, options.cssClasses.pips);
          addClass(element2, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);
          function getClasses4(type2, source) {
            var a4 = source === options.cssClasses.value;
            var orientationClasses = a4 ? valueOrientationClasses : markerOrientationClasses;
            var sizeClasses = a4 ? valueSizeClasses : markerSizeClasses;
            return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type2];
          }
          function addSpread(offset3, value, type2) {
            type2 = filterFunc ? filterFunc(value, type2) : type2;
            if (type2 === exports3.PipsType.None) {
              return;
            }
            var node = addNodeTo(element2, false);
            node.className = getClasses4(type2, options.cssClasses.marker);
            node.style[options.style] = offset3 + "%";
            if (type2 > exports3.PipsType.NoValue) {
              node = addNodeTo(element2, false);
              node.className = getClasses4(type2, options.cssClasses.value);
              node.setAttribute("data-value", String(value));
              node.style[options.style] = offset3 + "%";
              node.innerHTML = String(formatter.to(value));
            }
          }
          Object.keys(spread).forEach(function(offset3) {
            addSpread(offset3, spread[offset3][0], spread[offset3][1]);
          });
          return element2;
        }
        function removePips() {
          if (scope_Pips) {
            removeElement(scope_Pips);
            scope_Pips = null;
          }
        }
        function pips(pips2) {
          removePips();
          var spread = generateSpread(pips2);
          var filter2 = pips2.filter;
          var format2 = pips2.format || {
            to: function(value) {
              return String(Math.round(value));
            }
          };
          scope_Pips = scope_Target.appendChild(addMarking(spread, filter2, format2));
          return scope_Pips;
        }
        function baseSize() {
          var rect = scope_Base.getBoundingClientRect();
          var alt = "offset" + ["Width", "Height"][options.ort];
          return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
        }
        function attachEvent2(events2, element2, callback, data) {
          var method = function(event) {
            var e4 = fixEvent(event, data.pageOffset, data.target || element2);
            if (!e4) {
              return false;
            }
            if (isSliderDisabled() && !data.doNotReject) {
              return false;
            }
            if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {
              return false;
            }
            if (events2 === actions.start && e4.buttons !== void 0 && e4.buttons > 1) {
              return false;
            }
            if (data.hover && e4.buttons) {
              return false;
            }
            if (!supportsPassive) {
              e4.preventDefault();
            }
            e4.calcPoint = e4.points[options.ort];
            callback(e4, data);
            return;
          };
          var methods = [];
          events2.split(" ").forEach(function(eventName) {
            element2.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);
            methods.push([eventName, method]);
          });
          return methods;
        }
        function fixEvent(e4, pageOffset, eventTarget) {
          var touch = e4.type.indexOf("touch") === 0;
          var mouse = e4.type.indexOf("mouse") === 0;
          var pointer = e4.type.indexOf("pointer") === 0;
          var x4 = 0;
          var y3 = 0;
          if (e4.type.indexOf("MSPointer") === 0) {
            pointer = true;
          }
          if (e4.type === "mousedown" && !e4.buttons && !e4.touches) {
            return false;
          }
          if (touch) {
            var isTouchOnTarget = function(checkTouch) {
              var target2 = checkTouch.target;
              return target2 === eventTarget || eventTarget.contains(target2) || e4.composed && e4.composedPath().shift() === eventTarget;
            };
            if (e4.type === "touchstart") {
              var targetTouches = Array.prototype.filter.call(e4.touches, isTouchOnTarget);
              if (targetTouches.length > 1) {
                return false;
              }
              x4 = targetTouches[0].pageX;
              y3 = targetTouches[0].pageY;
            } else {
              var targetTouch = Array.prototype.find.call(e4.changedTouches, isTouchOnTarget);
              if (!targetTouch) {
                return false;
              }
              x4 = targetTouch.pageX;
              y3 = targetTouch.pageY;
            }
          }
          pageOffset = pageOffset || getPageOffset(scope_Document);
          if (mouse || pointer) {
            x4 = e4.clientX + pageOffset.x;
            y3 = e4.clientY + pageOffset.y;
          }
          e4.pageOffset = pageOffset;
          e4.points = [x4, y3];
          e4.cursor = mouse || pointer;
          return e4;
        }
        function calcPointToPercentage(calcPoint) {
          var location2 = calcPoint - offset2(scope_Base, options.ort);
          var proposal = location2 * 100 / baseSize();
          proposal = limit(proposal);
          return options.dir ? 100 - proposal : proposal;
        }
        function getClosestHandle(clickedPosition) {
          var smallestDifference = 100;
          var handleNumber = false;
          scope_Handles.forEach(function(handle, index2) {
            if (isHandleDisabled(index2)) {
              return;
            }
            var handlePosition = scope_Locations[index2];
            var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);
            var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;
            var isCloser = differenceWithThisHandle < smallestDifference;
            var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;
            if (isCloser || isCloserAfter || clickAtEdge) {
              handleNumber = index2;
              smallestDifference = differenceWithThisHandle;
            }
          });
          return handleNumber;
        }
        function documentLeave(event, data) {
          if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) {
            eventEnd(event, data);
          }
        }
        function eventMove(event, data) {
          if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {
            return eventEnd(event, data);
          }
          var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);
          var proposal = movement * 100 / data.baseSize;
          moveHandles(movement > 0, proposal, data.locations, data.handleNumbers, data.connect);
        }
        function eventEnd(event, data) {
          if (data.handle) {
            removeClass(data.handle, options.cssClasses.active);
            scope_ActiveHandlesCount -= 1;
          }
          data.listeners.forEach(function(c6) {
            scope_DocumentElement.removeEventListener(c6[0], c6[1]);
          });
          if (scope_ActiveHandlesCount === 0) {
            removeClass(scope_Target, options.cssClasses.drag);
            setZindex();
            if (event.cursor) {
              scope_Body.style.cursor = "";
              scope_Body.removeEventListener("selectstart", preventDefault);
            }
          }
          data.handleNumbers.forEach(function(handleNumber) {
            fireEvent("change", handleNumber);
            fireEvent("set", handleNumber);
            fireEvent("end", handleNumber);
          });
        }
        function eventStart(event, data) {
          if (data.handleNumbers.some(isHandleDisabled)) {
            return;
          }
          var handle;
          if (data.handleNumbers.length === 1) {
            var handleOrigin = scope_Handles[data.handleNumbers[0]];
            handle = handleOrigin.children[0];
            scope_ActiveHandlesCount += 1;
            addClass(handle, options.cssClasses.active);
          }
          event.stopPropagation();
          var listeners = [];
          var moveEvent = attachEvent2(actions.move, scope_DocumentElement, eventMove, {
            // The event target has changed so we need to propagate the original one so that we keep
            // relying on it to extract target touches.
            target: event.target,
            handle,
            connect: data.connect,
            listeners,
            startCalcPoint: event.calcPoint,
            baseSize: baseSize(),
            pageOffset: event.pageOffset,
            handleNumbers: data.handleNumbers,
            buttonsProperty: event.buttons,
            locations: scope_Locations.slice()
          });
          var endEvent = attachEvent2(actions.end, scope_DocumentElement, eventEnd, {
            target: event.target,
            handle,
            listeners,
            doNotReject: true,
            handleNumbers: data.handleNumbers
          });
          var outEvent = attachEvent2("mouseout", scope_DocumentElement, documentLeave, {
            target: event.target,
            handle,
            listeners,
            doNotReject: true,
            handleNumbers: data.handleNumbers
          });
          listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));
          if (event.cursor) {
            scope_Body.style.cursor = getComputedStyle(event.target).cursor;
            if (scope_Handles.length > 1) {
              addClass(scope_Target, options.cssClasses.drag);
            }
            scope_Body.addEventListener("selectstart", preventDefault, false);
          }
          data.handleNumbers.forEach(function(handleNumber) {
            fireEvent("start", handleNumber);
          });
        }
        function eventTap(event) {
          event.stopPropagation();
          var proposal = calcPointToPercentage(event.calcPoint);
          var handleNumber = getClosestHandle(proposal);
          if (handleNumber === false) {
            return;
          }
          if (!options.events.snap) {
            addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
          }
          setHandle(handleNumber, proposal, true, true);
          setZindex();
          fireEvent("slide", handleNumber, true);
          fireEvent("update", handleNumber, true);
          if (!options.events.snap) {
            fireEvent("change", handleNumber, true);
            fireEvent("set", handleNumber, true);
          } else {
            eventStart(event, { handleNumbers: [handleNumber] });
          }
        }
        function eventHover(event) {
          var proposal = calcPointToPercentage(event.calcPoint);
          var to = scope_Spectrum.getStep(proposal);
          var value = scope_Spectrum.fromStepping(to);
          Object.keys(scope_Events).forEach(function(targetEvent) {
            if ("hover" === targetEvent.split(".")[0]) {
              scope_Events[targetEvent].forEach(function(callback) {
                callback.call(scope_Self, value);
              });
            }
          });
        }
        function eventKeydown(event, handleNumber) {
          if (isSliderDisabled() || isHandleDisabled(handleNumber)) {
            return false;
          }
          var horizontalKeys = ["Left", "Right"];
          var verticalKeys = ["Down", "Up"];
          var largeStepKeys = ["PageDown", "PageUp"];
          var edgeKeys = ["Home", "End"];
          if (options.dir && !options.ort) {
            horizontalKeys.reverse();
          } else if (options.ort && !options.dir) {
            verticalKeys.reverse();
            largeStepKeys.reverse();
          }
          var key = event.key.replace("Arrow", "");
          var isLargeDown = key === largeStepKeys[0];
          var isLargeUp = key === largeStepKeys[1];
          var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
          var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
          var isMin = key === edgeKeys[0];
          var isMax = key === edgeKeys[1];
          if (!isDown && !isUp && !isMin && !isMax) {
            return true;
          }
          event.preventDefault();
          var to;
          if (isUp || isDown) {
            var direction = isDown ? 0 : 1;
            var steps = getNextStepsForHandle(handleNumber);
            var step = steps[direction];
            if (step === null) {
              return false;
            }
            if (step === false) {
              step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);
            }
            if (isLargeUp || isLargeDown) {
              step *= options.keyboardPageMultiplier;
            } else {
              step *= options.keyboardMultiplier;
            }
            step = Math.max(step, 1e-7);
            step = (isDown ? -1 : 1) * step;
            to = scope_Values[handleNumber] + step;
          } else if (isMax) {
            to = options.spectrum.xVal[options.spectrum.xVal.length - 1];
          } else {
            to = options.spectrum.xVal[0];
          }
          setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);
          fireEvent("slide", handleNumber);
          fireEvent("update", handleNumber);
          fireEvent("change", handleNumber);
          fireEvent("set", handleNumber);
          return false;
        }
        function bindSliderEvents(behaviour) {
          if (!behaviour.fixed) {
            scope_Handles.forEach(function(handle, index2) {
              attachEvent2(actions.start, handle.children[0], eventStart, {
                handleNumbers: [index2]
              });
            });
          }
          if (behaviour.tap) {
            attachEvent2(actions.start, scope_Base, eventTap, {});
          }
          if (behaviour.hover) {
            attachEvent2(actions.move, scope_Base, eventHover, {
              hover: true
            });
          }
          if (behaviour.drag) {
            scope_Connects.forEach(function(connect, index2) {
              if (connect === false || index2 === 0 || index2 === scope_Connects.length - 1) {
                return;
              }
              var handleBefore = scope_Handles[index2 - 1];
              var handleAfter = scope_Handles[index2];
              var eventHolders = [connect];
              var handlesToDrag = [handleBefore, handleAfter];
              var handleNumbersToDrag = [index2 - 1, index2];
              addClass(connect, options.cssClasses.draggable);
              if (behaviour.fixed) {
                eventHolders.push(handleBefore.children[0]);
                eventHolders.push(handleAfter.children[0]);
              }
              if (behaviour.dragAll) {
                handlesToDrag = scope_Handles;
                handleNumbersToDrag = scope_HandleNumbers;
              }
              eventHolders.forEach(function(eventHolder) {
                attachEvent2(actions.start, eventHolder, eventStart, {
                  handles: handlesToDrag,
                  handleNumbers: handleNumbersToDrag,
                  connect
                });
              });
            });
          }
        }
        function bindEvent(namespacedEvent, callback) {
          scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
          scope_Events[namespacedEvent].push(callback);
          if (namespacedEvent.split(".")[0] === "update") {
            scope_Handles.forEach(function(a4, index2) {
              fireEvent("update", index2);
            });
          }
        }
        function isInternalNamespace(namespace) {
          return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
        }
        function removeEvent(namespacedEvent) {
          var event = namespacedEvent && namespacedEvent.split(".")[0];
          var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;
          Object.keys(scope_Events).forEach(function(bind) {
            var tEvent = bind.split(".")[0];
            var tNamespace = bind.substring(tEvent.length);
            if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {
              if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {
                delete scope_Events[bind];
              }
            }
          });
        }
        function fireEvent(eventName, handleNumber, tap2) {
          Object.keys(scope_Events).forEach(function(targetEvent) {
            var eventType = targetEvent.split(".")[0];
            if (eventName === eventType) {
              scope_Events[targetEvent].forEach(function(callback) {
                callback.call(
                  // Use the slider public API as the scope ('this')
                  scope_Self,
                  // Return values as array, so arg_1[arg_2] is always valid.
                  scope_Values.map(options.format.to),
                  // Handle index, 0 or 1
                  handleNumber,
                  // Un-formatted slider values
                  scope_Values.slice(),
                  // Event is fired by tap, true or false
                  tap2 || false,
                  // Left offset of the handle, in relation to the slider
                  scope_Locations.slice(),
                  // add the slider public API to an accessible parameter when this is unavailable
                  scope_Self
                );
              });
            }
          });
        }
        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {
          var distance;
          if (scope_Handles.length > 1 && !options.events.unconstrained) {
            if (lookBackward && handleNumber > 0) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, false);
              to = Math.max(to, distance);
            }
            if (lookForward && handleNumber < scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, true);
              to = Math.min(to, distance);
            }
          }
          if (scope_Handles.length > 1 && options.limit) {
            if (lookBackward && handleNumber > 0) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, false);
              to = Math.min(to, distance);
            }
            if (lookForward && handleNumber < scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, true);
              to = Math.max(to, distance);
            }
          }
          if (options.padding) {
            if (handleNumber === 0) {
              distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], false);
              to = Math.max(to, distance);
            }
            if (handleNumber === scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], true);
              to = Math.min(to, distance);
            }
          }
          to = scope_Spectrum.getStep(to);
          to = limit(to);
          if (to === reference[handleNumber] && !getValue) {
            return false;
          }
          return to;
        }
        function inRuleOrder(v2, a4) {
          var o10 = options.ort;
          return (o10 ? a4 : v2) + ", " + (o10 ? v2 : a4);
        }
        function moveHandles(upward, proposal, locations, handleNumbers, connect) {
          var proposals = locations.slice();
          var firstHandle = handleNumbers[0];
          var b4 = [!upward, upward];
          var f6 = [upward, !upward];
          handleNumbers = handleNumbers.slice();
          if (upward) {
            handleNumbers.reverse();
          }
          if (handleNumbers.length > 1) {
            handleNumbers.forEach(function(handleNumber, o10) {
              var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b4[o10], f6[o10], false);
              if (to === false) {
                proposal = 0;
              } else {
                proposal = to - proposals[handleNumber];
                proposals[handleNumber] = to;
              }
            });
          } else {
            b4 = f6 = [true];
          }
          var state = false;
          handleNumbers.forEach(function(handleNumber, o10) {
            state = setHandle(handleNumber, locations[handleNumber] + proposal, b4[o10], f6[o10]) || state;
          });
          if (state) {
            handleNumbers.forEach(function(handleNumber) {
              fireEvent("update", handleNumber);
              fireEvent("slide", handleNumber);
            });
            if (connect != void 0) {
              fireEvent("drag", firstHandle);
            }
          }
        }
        function transformDirection(a4, b4) {
          return options.dir ? 100 - a4 - b4 : a4;
        }
        function updateHandlePosition(handleNumber, to) {
          scope_Locations[handleNumber] = to;
          scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
          var translation = 10 * (transformDirection(to, 0) - scope_DirOffset);
          var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";
          scope_Handles[handleNumber].style[options.transformRule] = translateRule;
          updateConnect(handleNumber);
          updateConnect(handleNumber + 1);
        }
        function setZindex() {
          scope_HandleNumbers.forEach(function(handleNumber) {
            var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
            var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
            scope_Handles[handleNumber].style.zIndex = String(zIndex);
          });
        }
        function setHandle(handleNumber, to, lookBackward, lookForward, exactInput) {
          if (!exactInput) {
            to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);
          }
          if (to === false) {
            return false;
          }
          updateHandlePosition(handleNumber, to);
          return true;
        }
        function updateConnect(index2) {
          if (!scope_Connects[index2]) {
            return;
          }
          var l7 = 0;
          var h4 = 100;
          if (index2 !== 0) {
            l7 = scope_Locations[index2 - 1];
          }
          if (index2 !== scope_Connects.length - 1) {
            h4 = scope_Locations[index2];
          }
          var connectWidth = h4 - l7;
          var translateRule = "translate(" + inRuleOrder(transformDirection(l7, connectWidth) + "%", "0") + ")";
          var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
          scope_Connects[index2].style[options.transformRule] = translateRule + " " + scaleRule;
        }
        function resolveToValue(to, handleNumber) {
          if (to === null || to === false || to === void 0) {
            return scope_Locations[handleNumber];
          }
          if (typeof to === "number") {
            to = String(to);
          }
          to = options.format.from(to);
          if (to !== false) {
            to = scope_Spectrum.toStepping(to);
          }
          if (to === false || isNaN(to)) {
            return scope_Locations[handleNumber];
          }
          return to;
        }
        function valueSet(input, fireSetEvent, exactInput) {
          var values2 = asArray(input);
          var isInit = scope_Locations[0] === void 0;
          fireSetEvent = fireSetEvent === void 0 ? true : fireSetEvent;
          if (options.animate && !isInit) {
            addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
          }
          scope_HandleNumbers.forEach(function(handleNumber) {
            setHandle(handleNumber, resolveToValue(values2[handleNumber], handleNumber), true, false, exactInput);
          });
          var i5 = scope_HandleNumbers.length === 1 ? 0 : 1;
          if (isInit && scope_Spectrum.hasNoSize()) {
            exactInput = true;
            scope_Locations[0] = 0;
            if (scope_HandleNumbers.length > 1) {
              var space_1 = 100 / (scope_HandleNumbers.length - 1);
              scope_HandleNumbers.forEach(function(handleNumber) {
                scope_Locations[handleNumber] = handleNumber * space_1;
              });
            }
          }
          for (; i5 < scope_HandleNumbers.length; ++i5) {
            scope_HandleNumbers.forEach(function(handleNumber) {
              setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
            });
          }
          setZindex();
          scope_HandleNumbers.forEach(function(handleNumber) {
            fireEvent("update", handleNumber);
            if (values2[handleNumber] !== null && fireSetEvent) {
              fireEvent("set", handleNumber);
            }
          });
        }
        function valueReset(fireSetEvent) {
          valueSet(options.start, fireSetEvent);
        }
        function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {
          handleNumber = Number(handleNumber);
          if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {
            throw new Error("noUiSlider: invalid handle number, got: " + handleNumber);
          }
          setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);
          fireEvent("update", handleNumber);
          if (fireSetEvent) {
            fireEvent("set", handleNumber);
          }
        }
        function valueGet(unencoded) {
          if (unencoded === void 0) {
            unencoded = false;
          }
          if (unencoded) {
            return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);
          }
          var values2 = scope_Values.map(options.format.to);
          if (values2.length === 1) {
            return values2[0];
          }
          return values2;
        }
        function destroy() {
          removeEvent(INTERNAL_EVENT_NS.aria);
          removeEvent(INTERNAL_EVENT_NS.tooltips);
          Object.keys(options.cssClasses).forEach(function(key) {
            removeClass(scope_Target, options.cssClasses[key]);
          });
          while (scope_Target.firstChild) {
            scope_Target.removeChild(scope_Target.firstChild);
          }
          delete scope_Target.noUiSlider;
        }
        function getNextStepsForHandle(handleNumber) {
          var location2 = scope_Locations[handleNumber];
          var nearbySteps = scope_Spectrum.getNearbySteps(location2);
          var value = scope_Values[handleNumber];
          var increment = nearbySteps.thisStep.step;
          var decrement = null;
          if (options.snap) {
            return [
              value - nearbySteps.stepBefore.startValue || null,
              nearbySteps.stepAfter.startValue - value || null
            ];
          }
          if (increment !== false) {
            if (value + increment > nearbySteps.stepAfter.startValue) {
              increment = nearbySteps.stepAfter.startValue - value;
            }
          }
          if (value > nearbySteps.thisStep.startValue) {
            decrement = nearbySteps.thisStep.step;
          } else if (nearbySteps.stepBefore.step === false) {
            decrement = false;
          } else {
            decrement = value - nearbySteps.stepBefore.highestStep;
          }
          if (location2 === 100) {
            increment = null;
          } else if (location2 === 0) {
            decrement = null;
          }
          var stepDecimals = scope_Spectrum.countStepDecimals();
          if (increment !== null && increment !== false) {
            increment = Number(increment.toFixed(stepDecimals));
          }
          if (decrement !== null && decrement !== false) {
            decrement = Number(decrement.toFixed(stepDecimals));
          }
          return [decrement, increment];
        }
        function getNextSteps() {
          return scope_HandleNumbers.map(getNextStepsForHandle);
        }
        function updateOptions(optionsToUpdate, fireSetEvent) {
          var v2 = valueGet();
          var updateAble = [
            "margin",
            "limit",
            "padding",
            "range",
            "animate",
            "snap",
            "step",
            "format",
            "pips",
            "tooltips"
          ];
          updateAble.forEach(function(name2) {
            if (optionsToUpdate[name2] !== void 0) {
              originalOptions[name2] = optionsToUpdate[name2];
            }
          });
          var newOptions = testOptions(originalOptions);
          updateAble.forEach(function(name2) {
            if (optionsToUpdate[name2] !== void 0) {
              options[name2] = newOptions[name2];
            }
          });
          scope_Spectrum = newOptions.spectrum;
          options.margin = newOptions.margin;
          options.limit = newOptions.limit;
          options.padding = newOptions.padding;
          if (options.pips) {
            pips(options.pips);
          } else {
            removePips();
          }
          if (options.tooltips) {
            tooltips();
          } else {
            removeTooltips();
          }
          scope_Locations = [];
          valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v2, fireSetEvent);
        }
        function setupSlider() {
          scope_Base = addSlider(scope_Target);
          addElements(options.connect, scope_Base);
          bindSliderEvents(options.events);
          valueSet(options.start);
          if (options.pips) {
            pips(options.pips);
          }
          if (options.tooltips) {
            tooltips();
          }
          aria();
        }
        setupSlider();
        var scope_Self = {
          destroy,
          steps: getNextSteps,
          on: bindEvent,
          off: removeEvent,
          get: valueGet,
          set: valueSet,
          setHandle: valueSetHandle,
          reset: valueReset,
          // Exposed for unit testing, don't use this in your application.
          __moveHandles: function(upward, proposal, handleNumbers) {
            moveHandles(upward, proposal, scope_Locations, handleNumbers);
          },
          options: originalOptions,
          updateOptions,
          target: scope_Target,
          removePips,
          removeTooltips,
          getPositions: function() {
            return scope_Locations.slice();
          },
          getTooltips: function() {
            return scope_Tooltips;
          },
          getOrigins: function() {
            return scope_Handles;
          },
          pips
          // Issue #594
        };
        return scope_Self;
      }
      function initialize(target, originalOptions) {
        if (!target || !target.nodeName) {
          throw new Error("noUiSlider: create requires a single element, got: " + target);
        }
        if (target.noUiSlider) {
          throw new Error("noUiSlider: Slider was already initialized.");
        }
        var options = testOptions(originalOptions);
        var api = scope(target, options, originalOptions);
        target.noUiSlider = api;
        return api;
      }
      var nouislider = {
        // Exposed for unit testing, don't use this in your application.
        __spectrum: Spectrum,
        // A reference to the default classes, allows global changes.
        // Use the cssClasses option for changes to one slider.
        cssClasses,
        create: initialize
      };
      exports3.create = initialize;
      exports3.cssClasses = cssClasses;
      exports3["default"] = nouislider;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_int.js
var import_nouislider, IntModel, BoundedIntModel, SliderStyleModel, IntSliderModel, IntRangeSliderModel, BaseIntSliderView, IntRangeSliderView, IntSliderView, IntTextModel, BoundedIntTextModel, IntTextView, ProgressStyleModel, IntProgressModel, ProgressView, PlayModel, PlayView;
var init_widget_int = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_int.js"() {
    init_widget_core();
    init_widget_description();
    init_lib10();
    init_utils3();
    init_src();
    import_nouislider = __toESM(require_nouislider());
    IntModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "IntModel", value: 0 });
      }
    };
    BoundedIntModel = class extends IntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "BoundedIntModel", max: 100, min: 0 });
      }
    };
    SliderStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SliderStyleModel" });
      }
    };
    SliderStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { handle_color: {
      selector: ".noUi-handle",
      attribute: "background-color",
      default: null
    } });
    IntSliderModel = class extends BoundedIntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "IntSliderModel", _view_name: "IntSliderView", step: 1, orientation: "horizontal", readout: true, readout_format: "d", continuous_update: true, style: null, disabled: false });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this.on("change:readout_format", this.update_readout_format, this);
        this.update_readout_format();
      }
      update_readout_format() {
        this.readout_formatter = format(this.get("readout_format"));
      }
    };
    IntRangeSliderModel = class extends IntSliderModel {
    };
    BaseIntSliderView = class extends DescriptionView {
      constructor() {
        super(...arguments);
        this._parse_value = parseInt;
      }
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-slider");
        this.el.classList.add("widget-hslider");
        this.$slider = document.createElement("div");
        this.$slider.classList.add("slider");
        this.slider_container = document.createElement("div");
        this.slider_container.classList.add("slider-container");
        this.slider_container.appendChild(this.$slider);
        this.el.appendChild(this.slider_container);
        this.readout = document.createElement("div");
        this.el.appendChild(this.readout);
        this.readout.classList.add("widget-readout");
        this.readout.contentEditable = "true";
        this.readout.style.display = "none";
        this.createSlider();
        this.model.on("change:orientation", this.regenSlider, this);
        this.model.on("change:max", this.updateSliderOptions, this);
        this.model.on("change:min", this.updateSliderOptions, this);
        this.model.on("change:step", this.updateSliderOptions, this);
        this.model.on("change:value", this.updateSliderValue, this);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          if (this.model.get("disabled")) {
            this.readout.contentEditable = "false";
            this.$slider.setAttribute("disabled", true);
          } else {
            this.readout.contentEditable = "true";
            this.$slider.removeAttribute("disabled");
          }
          const orientation = this.model.get("orientation");
          if (orientation === "vertical") {
            this.el.classList.remove("widget-hslider");
            this.el.classList.add("widget-vslider");
            this.el.classList.remove("widget-inline-hbox");
            this.el.classList.add("widget-inline-vbox");
          } else {
            this.el.classList.remove("widget-vslider");
            this.el.classList.add("widget-hslider");
            this.el.classList.remove("widget-inline-vbox");
            this.el.classList.add("widget-inline-hbox");
          }
          const readout = this.model.get("readout");
          if (readout) {
            this.readout.style.display = "";
            this.displayed.then(() => {
              if (this.readout_overflow()) {
                this.readout.classList.add("overflow");
              } else {
                this.readout.classList.remove("overflow");
              }
            });
          } else {
            this.readout.style.display = "none";
          }
        }
        return super.update();
      }
      /**
       * Returns true if the readout box content overflows.
       */
      readout_overflow() {
        return this.readout.scrollWidth > this.readout.clientWidth;
      }
      events() {
        return {
          // Dictionary of events and their handlers.
          "blur [contentEditable=true]": "handleTextChange",
          "keydown [contentEditable=true]": "handleKeyDown"
        };
      }
      handleKeyDown(e4) {
        if (e4.keyCode === 13) {
          e4.preventDefault();
          this.handleTextChange();
        }
      }
      /**
       * Create a new noUiSlider object
       */
      createSlider() {
        const orientation = this.model.get("orientation");
        const behavior = this.model.get("behavior");
        import_nouislider.default.create(this.$slider, {
          start: this.model.get("value"),
          connect: true,
          behaviour: behavior,
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: this.model.get("step"),
          animate: false,
          orientation,
          direction: orientation === "horizontal" ? "ltr" : "rtl",
          format: {
            from: (value) => Number(value),
            to: (value) => this._validate_slide_value(value)
          }
        });
        this.$slider.noUiSlider.on("update", (values2, handle) => {
          this.handleSliderUpdateEvent(values2, handle);
        });
        this.$slider.noUiSlider.on("change", (values2, handle) => {
          this.handleSliderChangeEvent(values2, handle);
        });
      }
      /**
       * Recreate/Regenerate a slider object
       * noUiSlider does not support in-place mutation of the orientation
       * state. We therefore need to destroy the current instance
       * and create a new one with the new properties. This is
       * handled in a separate function and has a dedicated event
       * handler.
       */
      regenSlider(e4) {
        this.$slider.noUiSlider.destroy();
        this.createSlider();
      }
      /**
       * Validate the value of the slider before sending it to the back-end
       * and applying it to the other views on the page.
       */
      _validate_slide_value(x4) {
        return Math.round(x4);
      }
    };
    IntRangeSliderView = class extends BaseIntSliderView {
      constructor() {
        super(...arguments);
        this._range_regex = /^\s*([+-]?\d+)\s*[-:–]\s*([+-]?\d+)/;
      }
      update(options) {
        super.update(options);
        const value = this.model.get("value");
        this.readout.textContent = this.valueToString(value);
        if (this.model.get("value") !== value) {
          this.model.set("value", value, { updated_view: this });
          this.touch();
        }
      }
      /**
       * Write value to a string
       */
      valueToString(value) {
        const format2 = this.model.readout_formatter;
        return value.map(function(v2) {
          return format2(v2);
        }).join(" \u2013 ");
      }
      /**
       * Parse value from a string
       */
      stringToValue(text) {
        if (text === null) {
          return null;
        }
        const match = this._range_regex.exec(text);
        if (match) {
          return [this._parse_value(match[1]), this._parse_value(match[2])];
        } else {
          return null;
        }
      }
      handleTextChange() {
        let value = this.stringToValue(this.readout.textContent);
        const vmin = this.model.get("min");
        const vmax = this.model.get("max");
        if (value === null || isNaN(value[0]) || isNaN(value[1]) || value[0] > value[1]) {
          this.readout.textContent = this.valueToString(this.model.get("value"));
        } else {
          value = [
            Math.max(Math.min(value[0], vmax), vmin),
            Math.max(Math.min(value[1], vmax), vmin)
          ];
          if (value[0] !== this.model.get("value")[0] || value[1] !== this.model.get("value")[1]) {
            this.readout.textContent = this.valueToString(value);
            this.model.set("value", value);
            this.touch();
          } else {
            this.readout.textContent = this.valueToString(this.model.get("value"));
          }
        }
      }
      /**
       * Called when the slider handle is released after dragging,
       * or by tapping or moving by the arrow keys.
       */
      handleSliderChangeEvent(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.readout.textContent = this.valueToString(actual_value);
        this.handleSliderChanged(values2, handle);
      }
      /**
       * Called whilst the slider is dragged, tapped or moved by the arrow keys.
       */
      handleSliderUpdateEvent(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.readout.textContent = this.valueToString(actual_value);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      handleSliderChanged(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.model.set("value", actual_value, { updated_view: this });
        this.touch();
      }
      updateSliderOptions(e4) {
        this.$slider.noUiSlider.updateOptions({
          start: this.model.get("value"),
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: this.model.get("step")
        });
      }
      updateSliderValue(model, _5, options) {
        if (options.updated_view === this) {
          return;
        }
        const prev_value = this.$slider.noUiSlider.get();
        const value = this.model.get("value");
        if (prev_value[0] !== value[0] || prev_value[1] !== value[1]) {
          this.$slider.noUiSlider.set(value);
        }
      }
    };
    IntSliderView = class extends BaseIntSliderView {
      update(options) {
        super.update(options);
        const min3 = this.model.get("min");
        const max3 = this.model.get("max");
        let value = this.model.get("value");
        if (value > max3) {
          value = max3;
        } else if (value < min3) {
          value = min3;
        }
        this.readout.textContent = this.valueToString(value);
        if (this.model.get("value") !== value) {
          this.model.set("value", value, { updated_view: this });
          this.touch();
        }
      }
      valueToString(value) {
        const format2 = this.model.readout_formatter;
        return format2(value);
      }
      stringToValue(text) {
        return this._parse_value(text);
      }
      handleTextChange() {
        var _a;
        let value = this.stringToValue((_a = this.readout.textContent) !== null && _a !== void 0 ? _a : "");
        const vmin = this.model.get("min");
        const vmax = this.model.get("max");
        if (isNaN(value)) {
          this.readout.textContent = this.valueToString(this.model.get("value"));
        } else {
          value = Math.max(Math.min(value, vmax), vmin);
          if (value !== this.model.get("value")) {
            this.readout.textContent = this.valueToString(value);
            this.model.set("value", value);
            this.touch();
          } else {
            this.readout.textContent = this.valueToString(this.model.get("value"));
          }
        }
      }
      handleSliderChangeEvent(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.readout.textContent = this.valueToString(actual_value);
        this.handleSliderChanged(values2, handle);
      }
      handleSliderUpdateEvent(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.readout.textContent = this.valueToString(actual_value);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      handleSliderChanged(values2, handle) {
        const actual_value = this._validate_slide_value(values2[handle]);
        const model_value = this.model.get("value");
        if (parseFloat(model_value) !== actual_value) {
          this.model.set("value", actual_value, { updated_view: this });
          this.touch();
        }
      }
      updateSliderOptions(e4) {
        this.$slider.noUiSlider.updateOptions({
          start: this.model.get("value"),
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: this.model.get("step")
        });
      }
      updateSliderValue(model, _5, options) {
        if (options.updated_view === this) {
          return;
        }
        const prev_value = this.$slider.noUiSlider.get();
        const value = this.model.get("value");
        if (prev_value !== value) {
          this.$slider.noUiSlider.set(value);
        }
      }
    };
    IntTextModel = class extends IntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "IntTextModel", _view_name: "IntTextView", disabled: false, continuous_update: false });
      }
    };
    BoundedIntTextModel = class extends BoundedIntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "BoundedIntTextModel", _view_name: "IntTextView", disabled: false, continuous_update: false, step: 1 });
      }
    };
    IntTextView = class extends DescriptionView {
      constructor() {
        super(...arguments);
        this._parse_value = parseInt;
        this._default_step = "1";
      }
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-text");
        this.textbox = document.createElement("input");
        this.textbox.type = "number";
        this.textbox.required = true;
        this.textbox.id = this.label.htmlFor = uuid();
        this.el.appendChild(this.textbox);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          const value = this.model.get("value");
          if (this._parse_value(this.textbox.value) !== value) {
            this.textbox.value = value.toString();
          }
          if (this.model.get("min") !== void 0) {
            this.textbox.min = this.model.get("min");
          }
          if (this.model.get("max") !== void 0) {
            this.textbox.max = this.model.get("max");
          }
          if (this.model.get("step") !== void 0 && this.model.get("step") !== null) {
            this.textbox.step = this.model.get("step");
          } else {
            this.textbox.step = this._default_step;
          }
          this.textbox.disabled = this.model.get("disabled");
        }
        return super.update();
      }
      events() {
        return {
          "keydown input": "handleKeyDown",
          "keypress input": "handleKeypress",
          "keyup input": "handleKeyUp",
          "input input": "handleChanging",
          "change input": "handleChanged"
        };
      }
      /**
       * Handle key down
       *
       * Stop propagation so the event isn't sent to the application.
       */
      handleKeyDown(e4) {
        e4.stopPropagation();
      }
      /**
       * Handles key press
       */
      handleKeypress(e4) {
        if (/[e,. ]/.test(String.fromCharCode(e4.keyCode))) {
          e4.preventDefault();
        }
      }
      /**
       * Handle key up
       */
      handleKeyUp(e4) {
        if (e4.altKey || e4.ctrlKey) {
          return;
        }
        const target = e4.target;
        let value = target.value;
        value = value.replace(/[e,.\s]/g, "");
        if (value.length >= 1) {
          const subvalue = value.substr(1);
          value = value[0] + subvalue.replace(/[+-]/g, "");
        }
        if (target.value !== value) {
          e4.preventDefault();
          target.value = value;
        }
      }
      /**
       * Call the submit handler if continuous update is true and we are not
       * obviously incomplete.
       */
      handleChanging(e4) {
        const target = e4.target;
        const trimmed = target.value.trim();
        if (trimmed === "" || ["-", "-.", ".", "+.", "+"].indexOf(trimmed) >= 0) {
          return;
        }
        if (this.model.get("continuous_update")) {
          this.handleChanged(e4);
        }
      }
      /**
       * Applies validated input.
       */
      handleChanged(e4) {
        const target = e4.target;
        let numericalValue = this._parse_value(target.value);
        if (isNaN(numericalValue)) {
          target.value = this.model.get("value");
        } else {
          let boundedValue = numericalValue;
          if (this.model.get("max") !== void 0) {
            boundedValue = Math.min(this.model.get("max"), boundedValue);
          }
          if (this.model.get("min") !== void 0) {
            boundedValue = Math.max(this.model.get("min"), boundedValue);
          }
          if (boundedValue !== numericalValue) {
            target.value = boundedValue;
            numericalValue = boundedValue;
          }
          if (numericalValue !== this.model.get("value")) {
            this.model.set("value", numericalValue, { updated_view: this });
            this.touch();
          }
        }
      }
    };
    ProgressStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ProgressStyleModel" });
      }
    };
    ProgressStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { bar_color: {
      selector: ".progress-bar",
      attribute: "background-color",
      default: null
    } });
    IntProgressModel = class extends BoundedIntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "IntProgressModel", _view_name: "ProgressView", orientation: "horizontal", bar_style: "", style: null });
      }
    };
    ProgressView = class extends DescriptionView {
      initialize(parameters) {
        super.initialize(parameters);
        this.listenTo(this.model, "change:bar_style", this.update_bar_style);
        this.luminoWidget.addClass("jupyter-widgets");
      }
      render() {
        super.render();
        const orientation = this.model.get("orientation");
        const className = orientation === "horizontal" ? "widget-hprogress" : "widget-vprogress";
        this.el.classList.add(className);
        this.progress = document.createElement("div");
        this.progress.classList.add("progress");
        this.progress.style.position = "relative";
        this.el.appendChild(this.progress);
        this.bar = document.createElement("div");
        this.bar.classList.add("progress-bar");
        this.bar.style.position = "absolute";
        this.bar.style.bottom = "0px";
        this.bar.style.left = "0px";
        this.progress.appendChild(this.bar);
        this.update();
        this.set_bar_style();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        const value = this.model.get("value");
        const max3 = this.model.get("max");
        const min3 = this.model.get("min");
        const orientation = this.model.get("orientation");
        const percent = 100 * (value - min3) / (max3 - min3);
        if (orientation === "horizontal") {
          this.el.classList.remove("widget-inline-vbox");
          this.el.classList.remove("widget-vprogress");
          this.el.classList.add("widget-inline-hbox");
          this.el.classList.add("widget-hprogress");
          this.bar.style.width = percent + "%";
          this.bar.style.height = "100%";
        } else {
          this.el.classList.remove("widget-inline-hbox");
          this.el.classList.remove("widget-hprogress");
          this.el.classList.add("widget-inline-vbox");
          this.el.classList.add("widget-vprogress");
          this.bar.style.width = "100%";
          this.bar.style.height = percent + "%";
        }
        return super.update();
      }
      update_bar_style() {
        this.update_mapped_classes(ProgressView.class_map, "bar_style", this.bar);
      }
      set_bar_style() {
        this.set_mapped_classes(ProgressView.class_map, "bar_style", this.bar);
      }
    };
    ProgressView.class_map = {
      success: ["progress-bar-success"],
      info: ["progress-bar-info"],
      warning: ["progress-bar-warning"],
      danger: ["progress-bar-danger"]
    };
    PlayModel = class extends BoundedIntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "PlayModel", _view_name: "PlayView", repeat: false, playing: false, show_repeat: true, interval: 100, step: 1, disabled: false });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
      }
      loop() {
        if (!this.get("playing")) {
          return;
        }
        const next_value = this.get("value") + this.get("step");
        if (next_value <= this.get("max")) {
          this.set("value", next_value);
          this.schedule_next();
        } else {
          if (this.get("repeat")) {
            this.set("value", this.get("min"));
            this.schedule_next();
          } else {
            this.pause();
          }
        }
        this.save_changes();
      }
      schedule_next() {
        this._timerId = window.setTimeout(this.loop.bind(this), this.get("interval"));
      }
      stop() {
        this.pause();
        this.set("value", this.get("min"));
        this.save_changes();
      }
      pause() {
        window.clearTimeout(this._timerId);
        this._timerId = void 0;
        this.set("playing", false);
        this.save_changes();
      }
      animate() {
        if (this._timerId !== void 0) {
          return;
        }
        if (this.get("value") === this.get("max")) {
          this.set("value", this.get("min"));
          this.schedule_next();
          this.save_changes();
        } else {
          this.loop();
        }
        this.save_changes();
      }
      play() {
        this.set("playing", !this.get("playing"));
        this.save_changes();
      }
      repeat() {
        this.set("repeat", !this.get("repeat"));
        this.save_changes();
      }
    };
    PlayView = class extends DOMWidgetView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-play");
        this.playPauseButton = document.createElement("button");
        this.stopButton = document.createElement("button");
        this.repeatButton = document.createElement("button");
        this.playPauseButton.className = "jupyter-button";
        this.stopButton.className = "jupyter-button";
        this.repeatButton.className = "jupyter-button";
        this.el.appendChild(this.playPauseButton);
        this.el.appendChild(this.stopButton);
        this.el.appendChild(this.repeatButton);
        const playIcon = document.createElement("i");
        playIcon.className = "fa fa-play";
        this.playPauseButton.appendChild(playIcon);
        const stopIcon = document.createElement("i");
        stopIcon.className = "fa fa-stop";
        this.stopButton.appendChild(stopIcon);
        const repeatIcon = document.createElement("i");
        repeatIcon.className = "fa fa-retweet";
        this.repeatButton.appendChild(repeatIcon);
        this.playPauseButton.onclick = this.model.play.bind(this.model);
        this.stopButton.onclick = this.model.stop.bind(this.model);
        this.repeatButton.onclick = this.model.repeat.bind(this.model);
        this.listenTo(this.model, "change:playing", this.onPlayingChanged);
        this.listenTo(this.model, "change:repeat", this.updateRepeat);
        this.listenTo(this.model, "change:show_repeat", this.updateRepeat);
        this.updatePlaying();
        this.updateRepeat();
        this.update();
      }
      update() {
        const disabled = this.model.get("disabled");
        this.playPauseButton.disabled = disabled;
        this.stopButton.disabled = disabled;
        this.repeatButton.disabled = disabled;
        this.updatePlaying();
      }
      onPlayingChanged() {
        this.updatePlaying();
        const previous = this.model.previous("playing");
        const current = this.model.get("playing");
        if (!previous && current) {
          this.model.animate();
        } else {
          this.model.pause();
        }
      }
      updatePlaying() {
        const playing = this.model.get("playing");
        const icon = this.playPauseButton.getElementsByTagName("i")[0];
        if (playing) {
          icon.className = "fa fa-pause";
        } else {
          icon.className = "fa fa-play";
        }
      }
      updateRepeat() {
        const repeat2 = this.model.get("repeat");
        this.repeatButton.style.display = this.model.get("show_repeat") ? this.playPauseButton.style.display : "none";
        if (repeat2) {
          this.repeatButton.classList.add("mod-active");
        } else {
          this.repeatButton.classList.remove("mod-active");
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_float.js
var import_nouislider2, FloatModel, BoundedFloatModel, FloatSliderModel, FloatLogSliderModel, FloatRangeSliderModel, FloatSliderView, FloatLogSliderView, FloatRangeSliderView, FloatTextModel, BoundedFloatTextModel, FloatTextView, FloatProgressModel;
var init_widget_float = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_float.js"() {
    init_widget_core();
    init_widget_int();
    init_src();
    import_nouislider2 = __toESM(require_nouislider());
    FloatModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatModel", value: 0 });
      }
    };
    BoundedFloatModel = class extends FloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "BoundedFloatModel", max: 100, min: 0 });
      }
    };
    FloatSliderModel = class extends BoundedFloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatSliderModel", _view_name: "FloatSliderView", step: 1, orientation: "horizontal", _range: false, readout: true, readout_format: ".2f", slider_color: null, continuous_update: true, disabled: false });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this.on("change:readout_format", this.update_readout_format, this);
        this.update_readout_format();
      }
      update_readout_format() {
        this.readout_formatter = format(this.get("readout_format"));
      }
    };
    FloatLogSliderModel = class extends BoundedFloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatLogSliderModel", _view_name: "FloatLogSliderView", step: 0.1, orientation: "horizontal", _range: false, readout: true, readout_format: ".3g", slider_color: null, continuous_update: true, disabled: false, base: 10, value: 1, min: 0, max: 4 });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this.on("change:readout_format", this.update_readout_format, this);
        this.update_readout_format();
      }
      update_readout_format() {
        this.readout_formatter = format(this.get("readout_format"));
      }
    };
    FloatRangeSliderModel = class extends FloatSliderModel {
    };
    FloatSliderView = class extends IntSliderView {
      constructor() {
        super(...arguments);
        this._parse_value = parseFloat;
      }
      /**
       * Validate the value of the slider before sending it to the back-end
       * and applying it to the other views on the page.
       */
      _validate_slide_value(x4) {
        return x4;
      }
    };
    FloatLogSliderView = class extends BaseIntSliderView {
      constructor() {
        super(...arguments);
        this._parse_value = parseFloat;
      }
      update(options) {
        super.update(options);
        const value = this.model.get("value");
        this.readout.textContent = this.valueToString(value);
      }
      /**
       * Convert from value to exponent
       *
       * @param value the widget value
       * @returns the log-value between the min/max exponents
       */
      logCalc(value) {
        const min3 = this.model.get("min");
        const max3 = this.model.get("max");
        const base = this.model.get("base");
        let log_value = Math.log(value) / Math.log(base);
        if (log_value > max3) {
          log_value = max3;
        } else if (log_value < min3) {
          log_value = min3;
        }
        return log_value;
      }
      createSlider() {
        var _a;
        const orientation = this.model.get("orientation");
        const behavior = this.model.get("behavior");
        import_nouislider2.default.create(this.$slider, {
          start: this.logCalc(this.model.get("value")),
          behaviour: behavior,
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: (_a = this.model.get("step")) !== null && _a !== void 0 ? _a : void 0,
          animate: false,
          orientation,
          direction: orientation === "horizontal" ? "ltr" : "rtl",
          format: {
            from: (value) => Number(value),
            to: (value) => value
          }
        });
        this.$slider.noUiSlider.on("update", (values2, handle) => {
          this.handleSliderUpdateEvent(values2, handle);
        });
        this.$slider.noUiSlider.on("change", (values2, handle) => {
          this.handleSliderChangeEvent(values2, handle);
        });
      }
      /**
       * Write value to a string
       */
      valueToString(value) {
        const format2 = this.model.readout_formatter;
        return format2(value);
      }
      /**
       * Parse value from a string
       */
      stringToValue(text) {
        return text === null ? NaN : this._parse_value(text);
      }
      /**
       * this handles the entry of text into the contentEditable label first, the
       * value is checked if it contains a parseable value then it is clamped
       * within the min-max range of the slider finally, the model is updated if
       * the value is to be changed
       *
       * if any of these conditions are not met, the text is reset
       */
      handleTextChange() {
        let value = this.stringToValue(this.readout.textContent);
        const vmin = this.model.get("min");
        const vmax = this.model.get("max");
        const base = this.model.get("base");
        if (isNaN(value)) {
          this.readout.textContent = this.valueToString(this.model.get("value"));
        } else {
          value = Math.max(Math.min(value, Math.pow(base, vmax)), Math.pow(base, vmin));
          if (value !== this.model.get("value")) {
            this.readout.textContent = this.valueToString(value);
            this.model.set("value", value);
            this.touch();
          } else {
            this.readout.textContent = this.valueToString(this.model.get("value"));
          }
        }
      }
      /**
       * Called whilst the slider is dragged, tapped or moved by the arrow keys.
       */
      handleSliderUpdateEvent(values2, handle) {
        const base = this.model.get("base");
        const actual_value = Math.pow(base, this._validate_slide_value(values2[0]));
        this.readout.textContent = this.valueToString(actual_value);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      /**
       * Called when the slider handle is released after dragging,
       * or by tapping or moving by the arrow keys.
       */
      handleSliderChangeEvent(values2, handle) {
        const base = this.model.get("base");
        const actual_value = Math.pow(base, this._validate_slide_value(values2[0]));
        this.readout.textContent = this.valueToString(actual_value);
        this.handleSliderChanged(values2, handle);
      }
      /**
       * Called when the slider value has changed.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleSliderChanged(values2, handle) {
        if (this._updating_slider) {
          return;
        }
        const base = this.model.get("base");
        const actual_value = Math.pow(base, this._validate_slide_value(values2[0]));
        this.model.set("value", actual_value, { updated_view: this });
        this.touch();
      }
      updateSliderValue(model, value, options) {
        if (options.updated_view === this) {
          return;
        }
        const log_value = this.logCalc(this.model.get("value"));
        this.$slider.noUiSlider.set(log_value);
      }
      updateSliderOptions(e4) {
        this.$slider.noUiSlider.updateOptions({
          start: this.logCalc(this.model.get("value")),
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: this.model.get("step")
        });
      }
      _validate_slide_value(x4) {
        return x4;
      }
    };
    FloatRangeSliderView = class extends IntRangeSliderView {
      constructor() {
        super(...arguments);
        this._parse_value = parseFloat;
        this._range_regex = /^\s*([+-]?(?:\d*\.?\d+|\d+\.)(?:[eE][-:]?\d+)?)\s*[-:–]\s*([+-]?(?:\d*\.?\d+|\d+\.)(?:[eE][+-]?\d+)?)/;
      }
      /**
       * Validate the value of the slider before sending it to the back-end
       * and applying it to the other views on the page.
       */
      _validate_slide_value(x4) {
        return x4;
      }
    };
    FloatTextModel = class extends FloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatTextModel", _view_name: "FloatTextView", disabled: false, continuous_update: false });
      }
    };
    BoundedFloatTextModel = class extends BoundedFloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "BoundedFloatTextModel", _view_name: "FloatTextView", disabled: false, continuous_update: false, step: 0.1 });
      }
    };
    FloatTextView = class extends IntTextView {
      constructor() {
        super(...arguments);
        this._parse_value = parseFloat;
        this._default_step = "any";
      }
      /**
       * Handle key press
       */
      handleKeypress(e4) {
        e4.stopPropagation();
      }
      /**
       * Handle key up
       */
      handleKeyUp(e4) {
      }
    };
    FloatProgressModel = class extends BoundedFloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatProgressModel", _view_name: "ProgressView", orientation: "horizontal", bar_style: "", style: null });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_controller.js
var import_jquery4, ControllerButtonModel, ControllerButtonView, ControllerAxisModel, ControllerAxisView, ControllerModel, ControllerView;
var init_widget_controller = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_controller.js"() {
    init_widget_core();
    init_lib10();
    init_index_es64();
    init_index_es65();
    init_utils3();
    import_jquery4 = __toESM(require_jquery());
    ControllerButtonModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ControllerButtonModel", _view_name: "ControllerButtonView", value: 0, pressed: false });
      }
    };
    ControllerButtonView = class extends DOMWidgetView {
      render() {
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-controller-button");
        this.el.style.width = "fit-content";
        this.support = document.createElement("div");
        this.support.style.position = "relative";
        this.support.style.margin = "1px";
        this.support.style.width = "16px";
        this.support.style.height = "16px";
        this.support.style.border = "1px solid black";
        this.support.style.background = "lightgray";
        this.el.appendChild(this.support);
        this.bar = document.createElement("div");
        this.bar.style.position = "absolute";
        this.bar.style.width = "100%";
        this.bar.style.bottom = "0px";
        this.bar.style.background = "gray";
        this.support.appendChild(this.bar);
        this.update();
        this.label = document.createElement("div");
        this.label.textContent = this.model.get("description");
        this.label.style.textAlign = "center";
        this.el.appendChild(this.label);
      }
      update() {
        this.bar.style.height = 100 * this.model.get("value") + "%";
      }
    };
    ControllerAxisModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ControllerAxisModel", _view_name: "ControllerAxisView", value: 0 });
      }
    };
    ControllerAxisView = class extends DOMWidgetView {
      render() {
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-controller-axis");
        this.el.style.width = "16px";
        this.el.style.padding = "4px";
        this.support = document.createElement("div");
        this.support.style.position = "relative";
        this.support.style.margin = "1px";
        this.support.style.width = "4px";
        this.support.style.height = "64px";
        this.support.style.border = "1px solid black";
        this.support.style.background = "lightgray";
        this.bullet = document.createElement("div");
        this.bullet.style.position = "absolute";
        this.bullet.style.margin = "-3px";
        this.bullet.style.boxSizing = "unset";
        this.bullet.style.width = "10px";
        this.bullet.style.height = "10px";
        this.bullet.style.background = "gray";
        this.label = document.createElement("div");
        this.label.textContent = this.model.get("description");
        this.label.style.textAlign = "center";
        this.support.appendChild(this.bullet);
        this.el.appendChild(this.support);
        this.el.appendChild(this.label);
        this.update();
      }
      update() {
        this.bullet.style.top = 50 * (this.model.get("value") + 1) + "%";
      }
    };
    ControllerModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ControllerModel", _view_name: "ControllerView", index: 0, name: "", mapping: "", connected: false, timestamp: 0, buttons: [], axes: [] });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        if (navigator.getGamepads === void 0) {
          this.readout = "This browser does not support gamepads.";
          console.error(this.readout);
        } else {
          this.readout = "Connect gamepad and press any button.";
          if (this.get("connected")) {
            this.update_loop();
          } else {
            this.wait_loop();
          }
        }
      }
      /**
       * Waits for a gamepad to be connected at the provided index.
       * Once one is connected, it will start the update loop, which
       * populates the update of axes and button values.
       */
      wait_loop() {
        const index2 = this.get("index");
        const pad = navigator.getGamepads()[index2];
        if (pad) {
          this.setup(pad).then((controls) => {
            this.set(controls);
            this.save_changes();
            window.requestAnimationFrame(this.update_loop.bind(this));
          });
        } else {
          window.requestAnimationFrame(this.wait_loop.bind(this));
        }
      }
      /**
       * Given a native gamepad object, returns a promise for a dictionary of
       * controls, of the form
       * {
       *     buttons: list of Button models,
       *     axes: list of Axis models,
       * }
       */
      setup(pad) {
        this.set({
          name: pad.id,
          mapping: pad.mapping,
          connected: pad.connected,
          timestamp: pad.timestamp
        });
        return resolvePromisesDict({
          buttons: Promise.all(pad.buttons.map((btn, index2) => {
            return this._create_button_model(index2);
          })),
          axes: Promise.all(pad.axes.map((axis, index2) => {
            return this._create_axis_model(index2);
          }))
        });
      }
      /**
       * Update axes and buttons values, until the gamepad is disconnected.
       * When the gamepad is disconnected, this.reset_gamepad is called.
       */
      update_loop() {
        const index2 = this.get("index");
        const id = this.get("name");
        const pad = navigator.getGamepads()[index2];
        if (pad && index2 === pad.index && id === pad.id) {
          this.set({
            timestamp: pad.timestamp,
            connected: pad.connected
          });
          this.save_changes();
          this.get("buttons").forEach(function(model, index3) {
            model.set({
              value: pad.buttons[index3].value,
              pressed: pad.buttons[index3].pressed
            });
            model.save_changes();
          });
          this.get("axes").forEach(function(model, index3) {
            model.set("value", pad.axes[index3]);
            model.save_changes();
          });
          window.requestAnimationFrame(this.update_loop.bind(this));
        } else {
          this.reset_gamepad();
        }
      }
      /**
       * Resets the gamepad attributes, and start the wait_loop.
       */
      reset_gamepad() {
        this.get("buttons").forEach(function(button) {
          button.close();
        });
        this.get("axes").forEach(function(axis) {
          axis.close();
        });
        this.set({
          name: "",
          mapping: "",
          connected: false,
          timestamp: 0,
          buttons: [],
          axes: []
        });
        this.save_changes();
        window.requestAnimationFrame(this.wait_loop.bind(this));
      }
      /**
       * Creates a gamepad button widget.
       */
      _create_button_model(index2) {
        return this.widget_manager.new_widget({
          model_name: "ControllerButtonModel",
          model_module: "@jupyter-widgets/controls",
          model_module_version: this.get("_model_module_version"),
          view_name: "ControllerButtonView",
          view_module: "@jupyter-widgets/controls",
          view_module_version: this.get("_view_module_version")
        }).then(function(model) {
          model.set("description", index2);
          return model;
        });
      }
      /**
       * Creates a gamepad axis widget.
       */
      _create_axis_model(index2) {
        return this.widget_manager.new_widget({
          model_name: "ControllerAxisModel",
          model_module: "@jupyter-widgets/controls",
          model_module_version: this.get("_model_module_version"),
          view_name: "ControllerAxisView",
          view_module: "@jupyter-widgets/controls",
          view_module_version: this.get("_view_module_version")
        }).then(function(model) {
          model.set("description", index2);
          return model;
        });
      }
    };
    ControllerModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { buttons: { deserialize: unpack_models }, axes: { deserialize: unpack_models } });
    ControllerView = class extends DOMWidgetView {
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoPanelWidget({ view: this });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery4.default)(this.luminoWidget.node);
      }
      initialize(parameters) {
        super.initialize(parameters);
        this.button_views = new ViewList(this.add_button, null, this);
        this.listenTo(this.model, "change:buttons", (model, value) => {
          this.button_views.update(value);
        });
        this.axis_views = new ViewList(this.add_axis, null, this);
        this.listenTo(this.model, "change:axes", (model, value) => {
          this.axis_views.update(value);
        });
        this.listenTo(this.model, "change:name", this.update_label);
      }
      render() {
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-controller");
        this.label = document.createElement("div");
        this.el.appendChild(this.label);
        this.axis_box = new Panel();
        this.axis_box.node.style.display = "flex";
        this.luminoWidget.addWidget(this.axis_box);
        this.button_box = new Panel();
        this.button_box.node.style.display = "flex";
        this.luminoWidget.addWidget(this.button_box);
        this.button_views.update(this.model.get("buttons"));
        this.axis_views.update(this.model.get("axes"));
        this.update_label();
      }
      update_label() {
        this.label.textContent = this.model.get("name") || this.model.readout;
      }
      add_button(model) {
        const dummy = new Widget();
        this.button_box.addWidget(dummy);
        return this.create_child_view(model).then((view) => {
          const i5 = ArrayExt.firstIndexOf(this.button_box.widgets, dummy);
          this.button_box.insertWidget(i5, view.luminoWidget);
          dummy.dispose();
          return view;
        }).catch(reject("Could not add child button view to controller", true));
      }
      add_axis(model) {
        const dummy = new Widget();
        this.axis_box.addWidget(dummy);
        return this.create_child_view(model).then((view) => {
          const i5 = ArrayExt.firstIndexOf(this.axis_box.widgets, dummy);
          this.axis_box.insertWidget(i5, view.luminoWidget);
          dummy.dispose();
          return view;
        }).catch(reject("Could not add child axis view to controller", true));
      }
      remove() {
        super.remove();
        this.button_views.remove();
        this.axis_views.remove();
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_selection.js
var import_nouislider3, SelectionModel, SelectionView, DropdownModel, DropdownView, SelectModel, SelectView, RadioButtonsModel, RadioButtonsView, ToggleButtonsStyleModel, ToggleButtonsModel, ToggleButtonsView, SelectionSliderModel, SelectionSliderView, MultipleSelectionModel, SelectMultipleModel, SelectMultipleView, SelectionRangeSliderModel, SelectionRangeSliderView;
var init_widget_selection = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_selection.js"() {
    init_widget_core();
    init_widget_description();
    init_utils3();
    import_nouislider3 = __toESM(require_nouislider());
    init_utils3();
    SelectionModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectionModel", index: "", _options_labels: [], disabled: false });
      }
    };
    SelectionView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        super.update();
        if (this.listbox) {
          this.listbox.disabled = this.model.get("disabled");
        }
        this.updateTabindex();
        this.updateTooltip();
      }
      updateTabindex() {
        if (!this.listbox) {
          return;
        }
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.listbox.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.listbox.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.listbox.removeAttribute("tabIndex");
        }
      }
      updateTooltip() {
        if (!this.listbox)
          return;
        const title = this.model.get("tooltip");
        if (!title) {
          this.listbox.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.listbox.setAttribute("title", title);
        }
      }
    };
    DropdownModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "DropdownModel", _view_name: "DropdownView", button_style: "" });
      }
    };
    DropdownView = class extends SelectionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-dropdown");
        this.listbox = document.createElement("select");
        this.listbox.id = this.label.htmlFor = uuid();
        this.el.appendChild(this.listbox);
        this._updateOptions();
        this.update();
      }
      /**
       * Update the contents of this view
       */
      update(options) {
        if ((options === null || options === void 0 ? void 0 : options.updated_view) !== this) {
          const optsChanged = this.model.hasChanged("_options_labels");
          if (optsChanged) {
            this._updateOptions();
          }
        }
        const index2 = this.model.get("index");
        this.listbox.selectedIndex = index2 === null ? -1 : index2;
        return super.update();
      }
      _updateOptions() {
        this.listbox.textContent = "";
        const items = this.model.get("_options_labels");
        for (let i5 = 0; i5 < items.length; i5++) {
          const item = items[i5];
          const option = document.createElement("option");
          option.textContent = item.replace(/ /g, "\xA0");
          option.setAttribute("data-value", encodeURIComponent(item));
          option.value = item;
          this.listbox.appendChild(option);
        }
      }
      events() {
        return {
          "change select": "_handle_change"
        };
      }
      /**
       * Handle when a new value is selected.
       */
      _handle_change() {
        this.model.set("index", this.listbox.selectedIndex === -1 ? null : this.listbox.selectedIndex, { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.listbox.focus();
        } else if (content.do === "blur") {
          this.listbox.blur();
        }
      }
    };
    SelectModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectModel", _view_name: "SelectView", rows: 5 });
      }
    };
    SelectView = class extends SelectionView {
      /**
       * Public constructor.
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.listbox = document.createElement("select");
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-select");
        this.listbox.id = this.label.htmlFor = uuid();
        this.el.appendChild(this.listbox);
        this._updateOptions();
        this.update();
        this.updateSelection();
      }
      /**
       * Update the contents of this view
       */
      update(options) {
        if ((options === null || options === void 0 ? void 0 : options.updated_view) !== this) {
          const optsChange = this.model.hasChanged("_options_labels");
          const idxChange = this.model.hasChanged("index");
          if (optsChange || idxChange) {
            const idx = this.model.get("index");
            if (optsChange) {
              this._updateOptions();
            }
            this.updateSelection(idx);
          }
        }
        super.update();
        let rows = this.model.get("rows");
        if (rows === null) {
          rows = "";
        }
        this.listbox.setAttribute("size", rows);
      }
      updateSelection(index2) {
        index2 = index2 || this.model.get("index");
        this.listbox.selectedIndex = index2 === null ? -1 : index2;
      }
      _updateOptions() {
        this.listbox.textContent = "";
        const items = this.model.get("_options_labels");
        for (let i5 = 0; i5 < items.length; i5++) {
          const item = items[i5];
          const option = document.createElement("option");
          option.textContent = item.replace(/ /g, "\xA0");
          option.setAttribute("data-value", encodeURIComponent(item));
          option.value = item;
          this.listbox.appendChild(option);
        }
      }
      events() {
        return {
          "change select": "_handle_change"
        };
      }
      /**
       * Handle when a new value is selected.
       */
      _handle_change() {
        this.model.set("index", this.listbox.selectedIndex, { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do == "focus") {
          this.listbox.focus();
        } else if (content.do == "blur") {
          this.listbox.blur();
        }
      }
    };
    RadioButtonsModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "RadioButtonsModel", _view_name: "RadioButtonsView", tooltips: [], icons: [], button_style: "" });
      }
    };
    RadioButtonsView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-radio");
        this.container = document.createElement("div");
        this.el.appendChild(this.container);
        this.container.classList.add("widget-radio-box");
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        const items = this.model.get("_options_labels");
        const radios = Array.from(this.container.querySelectorAll('input[type="radio"]')).map((x4) => x4.value);
        let stale = items.length !== radios.length;
        if (!stale) {
          for (let i5 = 0, len = items.length; i5 < len; ++i5) {
            if (radios[i5] !== items[i5]) {
              stale = true;
              break;
            }
          }
        }
        if (stale && (options === void 0 || options.updated_view !== this)) {
          this.container.textContent = "";
          items.forEach((item, index2) => {
            const label = document.createElement("label");
            label.textContent = item;
            this.container.appendChild(label);
            const radio = document.createElement("input");
            radio.setAttribute("type", "radio");
            radio.value = index2.toString();
            radio.setAttribute("data-value", encodeURIComponent(item));
            label.appendChild(radio);
          });
        }
        items.forEach((item, index2) => {
          const item_query = 'input[data-value="' + encodeURIComponent(item) + '"]';
          const radio = this.container.querySelectorAll(item_query);
          if (radio.length > 0) {
            const radio_el = radio[0];
            radio_el.checked = this.model.get("index") === index2;
            radio_el.disabled = this.model.get("disabled");
          }
        });
        setTimeout(this.adjustPadding, 0, this);
        return super.update(options);
      }
      /**
       * Adjust Padding to Multiple of Line Height
       *
       * Adjust margins so that the overall height
       * is a multiple of a single line height.
       *
       * This widget needs it because radio options
       * are spaced tighter than individual widgets
       * yet we would like the full widget line up properly
       * when displayed side-by-side with other widgets.
       */
      adjustPadding(e4) {
        const elStyles = window.getComputedStyle(e4.el);
        const margins = parseInt(elStyles.marginTop, 10) + parseInt(elStyles.marginBottom, 10);
        const lineHeight = e4.label.offsetHeight + margins;
        const cStyles = window.getComputedStyle(e4.container);
        const containerMargin = parseInt(cStyles.marginBottom, 10);
        const diff = (e4.el.offsetHeight + margins - containerMargin) % lineHeight;
        const extraMargin = diff === 0 ? 0 : lineHeight - diff;
        e4.container.style.marginBottom = extraMargin + "px";
      }
      events() {
        return {
          'click input[type="radio"]': "_handle_click"
        };
      }
      /**
       * Handle when a value is clicked.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      _handle_click(event) {
        const target = event.target;
        this.model.set("index", parseInt(target.value, 10), { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do == "focus") {
          const firstItem = this.container.firstElementChild;
          firstItem.focus();
        } else if (content.do == "blur") {
          for (let i5 = 0; i5 < this.container.children.length; i5++) {
            const item = this.container.children[i5];
            item.blur();
          }
        }
      }
    };
    ToggleButtonsStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ToggleButtonsStyleModel" });
      }
    };
    ToggleButtonsStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { button_width: {
      selector: ".widget-toggle-button",
      attribute: "width",
      default: null
    }, font_weight: {
      selector: ".widget-toggle-button",
      attribute: "font-weight",
      default: ""
    } });
    ToggleButtonsModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ToggleButtonsModel", _view_name: "ToggleButtonsView" });
      }
    };
    ToggleButtonsView = class extends DescriptionView {
      initialize(options) {
        this._css_state = {};
        super.initialize(options);
        this.listenTo(this.model, "change:button_style", this.update_button_style);
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-toggle-buttons");
        this.buttongroup = document.createElement("div");
        this.el.appendChild(this.buttongroup);
        this.update();
        this.set_button_style();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        const items = this.model.get("_options_labels");
        const icons = this.model.get("icons") || [];
        const previous_icons = this.model.previous("icons") || [];
        const previous_bstyle = ToggleButtonsView.classMap[this.model.previous("button_style")] || "";
        const tooltips = this.model.get("tooltips") || [];
        const disabled = this.model.get("disabled");
        const buttons = this.buttongroup.querySelectorAll("button");
        const values2 = Array.from(buttons).map((x4) => x4.value);
        let stale = false;
        for (let i5 = 0, len = items.length; i5 < len; ++i5) {
          if (values2[i5] !== items[i5] || icons[i5] !== previous_icons[i5]) {
            stale = true;
            break;
          }
        }
        if (stale && (options === void 0 || options.updated_view !== this)) {
          this.buttongroup.textContent = "";
          items.forEach((item, index2) => {
            let item_html;
            const empty = item.trim().length === 0 && (!icons[index2] || icons[index2].trim().length === 0);
            if (empty) {
              item_html = "&nbsp;";
            } else {
              item_html = escape_html(item);
            }
            const icon = document.createElement("i");
            const button = document.createElement("button");
            if (icons[index2]) {
              icon.className = "fa fa-" + icons[index2];
            }
            button.setAttribute("type", "button");
            button.className = "widget-toggle-button jupyter-button";
            if (previous_bstyle) {
              button.classList.add(previous_bstyle);
            }
            button.innerHTML = item_html;
            button.setAttribute("data-value", encodeURIComponent(item));
            button.setAttribute("value", index2.toString());
            button.appendChild(icon);
            button.disabled = disabled;
            if (tooltips[index2]) {
              button.setAttribute("title", tooltips[index2]);
            }
            this.update_style_traits(button);
            this.buttongroup.appendChild(button);
          });
        }
        items.forEach((item, index2) => {
          const item_query = '[data-value="' + encodeURIComponent(item) + '"]';
          const button = this.buttongroup.querySelector(item_query);
          if (this.model.get("index") === index2) {
            button.classList.add("mod-active");
          } else {
            button.classList.remove("mod-active");
          }
        });
        this.stylePromise.then(function(style) {
          if (style) {
            style.style();
          }
        });
        return super.update(options);
      }
      update_style_traits(button) {
        for (const name2 in this._css_state) {
          if (Object.prototype.hasOwnProperty.call(this._css_state, "name")) {
            if (name2 === "margin") {
              this.buttongroup.style[name2] = this._css_state[name2];
            } else if (name2 !== "width") {
              if (button) {
                button.style[name2] = this._css_state[name2];
              } else {
                const buttons = this.buttongroup.querySelectorAll("button");
                if (buttons.length) {
                  buttons[0].style[name2] = this._css_state[name2];
                }
              }
            }
          }
        }
      }
      update_button_style() {
        const buttons = this.buttongroup.querySelectorAll("button");
        for (let i5 = 0; i5 < buttons.length; i5++) {
          this.update_mapped_classes(ToggleButtonsView.classMap, "button_style", buttons[i5]);
        }
      }
      set_button_style() {
        const buttons = this.buttongroup.querySelectorAll("button");
        for (let i5 = 0; i5 < buttons.length; i5++) {
          this.set_mapped_classes(ToggleButtonsView.classMap, "button_style", buttons[i5]);
        }
      }
      events() {
        return {
          "click button": "_handle_click"
        };
      }
      /**
       * Handle when a value is clicked.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      _handle_click(event) {
        const target = event.target;
        this.model.set("index", parseInt(target.value, 10), { updated_view: this });
        this.touch();
        this.send({ event: "click" });
      }
    };
    (function(ToggleButtonsView2) {
      ToggleButtonsView2.classMap = {
        primary: ["mod-primary"],
        success: ["mod-success"],
        info: ["mod-info"],
        warning: ["mod-warning"],
        danger: ["mod-danger"]
      };
    })(ToggleButtonsView || (ToggleButtonsView = {}));
    SelectionSliderModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectionSliderModel", _view_name: "SelectionSliderView", orientation: "horizontal", readout: true, continuous_update: true });
      }
    };
    SelectionSliderView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-hslider");
        this.el.classList.add("widget-slider");
        this.$slider = document.createElement("div");
        this.$slider.classList.add("slider");
        this.slider_container = document.createElement("div");
        this.slider_container.classList.add("slider-container");
        this.slider_container.appendChild(this.$slider);
        this.el.appendChild(this.slider_container);
        this.readout = document.createElement("div");
        this.el.appendChild(this.readout);
        this.readout.classList.add("widget-readout");
        this.readout.style.display = "none";
        this.createSlider();
        this.model.on("change:orientation", this.regenSlider, this);
        this.model.on("change:index", this.updateSliderValue, this);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if ((options === null || options === void 0 ? void 0 : options.updated_view) !== this) {
          this.updateSliderOptions(this.model);
          const orientation = this.model.get("orientation");
          const disabled = this.model.get("disabled");
          if (disabled) {
            this.readout.contentEditable = "false";
            this.$slider.setAttribute("disabled", true);
          } else {
            this.readout.contentEditable = "true";
            this.$slider.removeAttribute("disabled");
          }
          if (orientation === "vertical") {
            this.el.classList.remove("widget-hslider");
            this.el.classList.remove("widget-inline-hbox");
            this.el.classList.add("widget-vslider");
            this.el.classList.add("widget-inline-vbox");
          } else {
            this.el.classList.remove("widget-vslider");
            this.el.classList.remove("widget-inline-vbox");
            this.el.classList.add("widget-hslider");
            this.el.classList.add("widget-inline-hbox");
          }
          const readout = this.model.get("readout");
          if (readout) {
            this.readout.style.display = "";
          } else {
            this.readout.style.display = "none";
          }
          this.updateSelection();
        }
        return super.update(options);
      }
      regenSlider(e4) {
        this.$slider.noUiSlider.destroy();
        this.createSlider();
      }
      createSlider() {
        const labels = this.model.get("_options_labels");
        const min3 = 0;
        const max3 = labels.length - 1;
        const orientation = this.model.get("orientation");
        const behavior = this.model.get("behavior");
        import_nouislider3.default.create(this.$slider, {
          start: this.model.get("index"),
          connect: true,
          behaviour: behavior,
          range: {
            min: min3,
            max: max3
          },
          step: 1,
          animate: false,
          orientation,
          direction: orientation === "horizontal" ? "ltr" : "rtl",
          format: {
            from: (value) => Number(value),
            to: (value) => Math.round(value)
          }
        });
        this.$slider.noUiSlider.on("update", (values2, handle) => {
          this.handleSliderUpdateEvent(values2, handle);
        });
        this.$slider.noUiSlider.on("change", (values2, handle) => {
          this.handleSliderChangeEvent(values2, handle);
        });
      }
      events() {
        return {
          slide: "handleSliderChange",
          slidestop: "handleSliderChanged"
        };
      }
      updateSelection() {
        const index2 = this.model.get("index");
        this.updateReadout(index2);
      }
      updateReadout(index2) {
        const value = this.model.get("_options_labels")[index2];
        this.readout.textContent = value;
      }
      /**
       * Called whilst the slider is dragged, tapped or moved by the arrow keys.
       */
      handleSliderUpdateEvent(values2, handle) {
        const index2 = values2[0];
        this.updateReadout(index2);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      /**
       * Called when the slider handle is released after dragging,
       * or by tapping or moving by the arrow keys.
       */
      handleSliderChangeEvent(values2, handle) {
        const index2 = values2[0];
        this.updateReadout(index2);
        this.handleSliderChanged(values2, handle);
      }
      /**
       * Called when the slider value has changed.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleSliderChanged(values2, handle) {
        const index2 = values2[0];
        this.updateReadout(index2);
        this.model.set("index", index2, { updated_view: this });
        this.touch();
      }
      updateSliderOptions(e4) {
        const labels = this.model.get("_options_labels");
        const min3 = 0;
        const max3 = labels.length - 1;
        this.$slider.noUiSlider.updateOptions({
          start: this.model.get("index"),
          range: {
            min: min3,
            max: max3
          },
          step: 1
        });
      }
      updateSliderValue(model, _5, options) {
        if (options.updated_view === this) {
          return;
        }
        const prev_index = this.$slider.noUiSlider.get();
        const index2 = this.model.get("index");
        if (prev_index !== index2) {
          this.$slider.noUiSlider.set(index2);
        }
      }
    };
    MultipleSelectionModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "MultipleSelectionModel" });
      }
    };
    SelectMultipleModel = class extends MultipleSelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectMultipleModel", _view_name: "SelectMultipleView", rows: null });
      }
    };
    SelectMultipleView = class extends SelectView {
      /**
       * Public constructor.
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.listbox.multiple = true;
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-select-multiple");
      }
      updateSelection() {
        const selected = this.model.get("index") || [];
        const listboxOptions = this.listbox.options;
        this.listbox.selectedIndex = -1;
        selected.forEach((i5) => {
          listboxOptions[i5].selected = true;
        });
      }
      /**
       * Handle when a new value is selected.
       */
      _handle_change() {
        const index2 = Array.prototype.map.call(this.listbox.selectedOptions || [], function(option) {
          return option.index;
        });
        this.model.set("index", index2, { updated_view: this });
        this.touch();
      }
    };
    SelectionRangeSliderModel = class extends MultipleSelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectionSliderModel", _view_name: "SelectionSliderView", orientation: "horizontal", readout: true, continuous_update: true });
      }
    };
    SelectionRangeSliderView = class extends SelectionSliderView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
      }
      updateSelection(index2) {
        index2 = index2 || this.model.get("index");
        this.updateReadout(index2);
      }
      updateReadout(index2) {
        const labels = this.model.get("_options_labels");
        const minValue = labels[index2[0]];
        const maxValue = labels[index2[1]];
        this.readout.textContent = `${minValue}-${maxValue}`;
      }
      /**
       * Called when the slider value is changing.
       */
      handleSliderUpdateEvent(values2, handle) {
        const intValues = values2.map(Math.trunc);
        this.updateReadout(intValues);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      /**
       * Called when the slider value has changed.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleSliderChanged(values2, handle) {
        const intValues = values2.map(Math.round);
        this.updateReadout(intValues);
        this.model.set("index", intValues.slice(), { updated_view: this });
        this.touch();
      }
      updateSliderValue(model, _5, options) {
        if (options.updated_view === this) {
          return;
        }
        const prev_index = this.$slider.noUiSlider.get().map(Math.round);
        const index2 = this.model.get("index").map(Math.round);
        if (prev_index[0] !== index2[0] || prev_index[1] !== index2[1]) {
          this.$slider.noUiSlider.set(index2);
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/lumino/tabpanel.js
var EventedPanel, TabPanel;
var init_tabpanel = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/lumino/tabpanel.js"() {
    init_index_es66();
    init_index_es6();
    init_index_es67();
    init_index_es64();
    EventedPanel = class extends Panel {
      constructor() {
        super(...arguments);
        this._widgetRemoved = new Signal(this);
      }
      /**
       * A signal emitted when a widget is removed from the panel.
       */
      get widgetRemoved() {
        return this._widgetRemoved;
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        this._widgetRemoved.emit(msg.child);
      }
    };
    TabPanel = class extends Widget {
      /**
       * Construct a new tab panel.
       *
       * @param options - The options for initializing the tab panel.
       */
      constructor(options = {}) {
        super();
        this._currentChanged = new Signal(this);
        this.addClass("jupyter-widget-TabPanel");
        this.tabBar = new TabBar(options);
        this.tabBar.addClass("jupyter-widget-TabPanel-tabBar");
        this.tabContents = new EventedPanel();
        this.tabContents.addClass("jupyter-widget-TabPanel-tabContents");
        this.tabBar.tabMoved.connect(this._onTabMoved, this);
        this.tabBar.currentChanged.connect(this._onCurrentChanged, this);
        this.tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);
        this.tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);
        this.tabContents.widgetRemoved.connect(this._onWidgetRemoved, this);
        const layout = new PanelLayout();
        layout.addWidget(this.tabBar);
        layout.addWidget(this.tabContents);
        this.layout = layout;
      }
      /**
       * A signal emitted when the current tab is changed.
       *
       * #### Notes
       * This signal is emitted when the currently selected tab is changed
       * either through user or programmatic interaction.
       *
       * Notably, this signal is not emitted when the index of the current
       * tab changes due to tabs being inserted, removed, or moved. It is
       * only emitted when the actual current tab node is changed.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * Get the index of the currently selected tab.
       *
       * #### Notes
       * This will be `null` if no tab is selected.
       */
      get currentIndex() {
        const currentIndex = this.tabBar.currentIndex;
        return currentIndex === -1 ? null : currentIndex;
      }
      /**
       * Set the index of the currently selected tab.
       *
       * #### Notes
       * If the index is out of range, it will be set to `null`.
       */
      set currentIndex(value) {
        this.tabBar.currentIndex = value === null ? -1 : value;
      }
      /**
       * Get the currently selected widget.
       *
       * #### Notes
       * This will be `null` if there is no selected tab.
       */
      get currentWidget() {
        const title = this.tabBar.currentTitle;
        return title ? title.owner : null;
      }
      /**
       * Set the currently selected widget.
       *
       * #### Notes
       * If the widget is not in the panel, it will be set to `null`.
       */
      set currentWidget(value) {
        this.tabBar.currentTitle = value ? value.title : null;
      }
      /**
       * Get the whether the tabs are movable by the user.
       *
       * #### Notes
       * Tabs can always be moved programmatically.
       */
      get tabsMovable() {
        return this.tabBar.tabsMovable;
      }
      /**
       * Set the whether the tabs are movable by the user.
       *
       * #### Notes
       * Tabs can always be moved programmatically.
       */
      set tabsMovable(value) {
        this.tabBar.tabsMovable = value;
      }
      /**
       * A read-only array of the widgets in the panel.
       */
      get widgets() {
        return this.tabContents.widgets;
      }
      /**
       * Add a widget to the end of the tab panel.
       *
       * @param widget - The widget to add to the tab panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       *
       * The widget's `title` is used to populate the tab.
       */
      addWidget(widget) {
        this.insertWidget(this.widgets.length, widget);
      }
      /**
       * Insert a widget into the tab panel at a specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the tab panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       *
       * The widget's `title` is used to populate the tab.
       */
      insertWidget(index2, widget) {
        if (widget !== this.currentWidget) {
          widget.hide();
        }
        this.tabContents.insertWidget(index2, widget);
        this.tabBar.insertTab(index2, widget.title);
      }
      /**
       * Handle the `currentChanged` signal from the tab bar.
       */
      _onCurrentChanged(sender, args) {
        const { previousIndex, previousTitle, currentIndex, currentTitle } = args;
        const previousWidget = previousTitle ? previousTitle.owner : null;
        const currentWidget = currentTitle ? currentTitle.owner : null;
        if (previousWidget) {
          previousWidget.hide();
        }
        if (currentWidget) {
          currentWidget.show();
        }
        this._currentChanged.emit({
          previousIndex,
          previousWidget,
          currentIndex,
          currentWidget
        });
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop.flush();
        }
      }
      /**
       * Handle the `tabActivateRequested` signal from the tab bar.
       */
      _onTabActivateRequested(sender, args) {
        args.title.owner.activate();
      }
      /**
       * Handle the `tabCloseRequested` signal from the tab bar.
       */
      _onTabCloseRequested(sender, args) {
        args.title.owner.close();
      }
      /**
       * Handle the `tabMoved` signal from the tab bar.
       */
      _onTabMoved(sender, args) {
        this.tabContents.insertWidget(args.toIndex, args.title.owner);
      }
      /**
       * Handle the `widgetRemoved` signal from the stacked panel.
       */
      _onWidgetRemoved(sender, widget) {
        this.tabBar.removeTab(widget.title);
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/lumino/currentselection.js
var Selection;
var init_currentselection = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/lumino/currentselection.js"() {
    init_index_es65();
    init_index_es6();
    Selection = class {
      constructor(sequence, options = {}) {
        this._array = null;
        this._value = null;
        this._previousValue = null;
        this._selectionChanged = new Signal(this);
        this._array = sequence;
        this._insertBehavior = options.insertBehavior || "select-item-if-needed";
        this._removeBehavior = options.removeBehavior || "select-item-after";
      }
      /**
       * A signal emitted when the current item is changed.
       *
       * #### Notes
       * This signal is emitted when the currently selected item is changed either
       * through user or programmatic interaction.
       *
       * Notably, this signal is not emitted when the index of the current item
       * changes due to other items being inserted, removed, or moved, but the
       * current item remains the same. It is only emitted when the actual current
       * item is changed.
       */
      get selectionChanged() {
        return this._selectionChanged;
      }
      /**
       * Adjust for setting an item.
       *
       * This should be called *after* the set.
       *
       * @param index - The index set.
       * @param oldValue - The old value at the index.
       */
      adjustSelectionForSet(index2) {
        const pi = this.index;
        const pv = this.value;
        if (index2 !== pi) {
          return;
        }
        this._updateSelectedValue();
        const cv = this.value;
        this._previousValue = null;
        if (pv !== cv) {
          this._selectionChanged.emit({
            previousIndex: pi,
            previousValue: pv,
            currentIndex: pi,
            currentValue: cv
          });
        }
      }
      /**
       * Get the currently selected item.
       *
       * #### Notes
       * This will be `null` if no item is selected.
       */
      get value() {
        return this._value;
      }
      /**
       * Set the currently selected item.
       *
       * #### Notes
       * If the item does not exist in the vector, the currentValue will be set to
       * `null`. This selects the first entry equal to the desired item.
       */
      set value(value) {
        if (value === null || this._array === null) {
          this.index = null;
        } else {
          this.index = ArrayExt.firstIndexOf(this._array, value);
        }
      }
      /**
       * Get the index of the currently selected item.
       *
       * #### Notes
       * This will be `null` if no item is selected.
       */
      get index() {
        return this._index;
      }
      /**
       * Set the index of the currently selected tab.
       *
       * @param index - The index to select.
       *
       * #### Notes
       * If the value is out of range, the index will be set to `null`, which
       * indicates no item is selected.
       */
      set index(index2) {
        let i5;
        if (index2 !== null && this._array !== null) {
          i5 = Math.floor(index2);
          if (i5 < 0 || i5 >= this._array.length) {
            i5 = null;
          }
        } else {
          i5 = null;
        }
        if (this._index === i5) {
          return;
        }
        const pi = this._index;
        const pv = this._value;
        this._index = i5;
        this._updateSelectedValue();
        this._previousValue = pv;
        this._selectionChanged.emit({
          previousIndex: pi,
          previousValue: pv,
          currentIndex: i5,
          currentValue: this._value
        });
      }
      /**
       * Get the selection behavior when inserting a tab.
       */
      get insertBehavior() {
        return this._insertBehavior;
      }
      /**
       * Set the selection behavior when inserting a tab.
       */
      set insertBehavior(value) {
        this._insertBehavior = value;
      }
      /**
       * Get the selection behavior when removing a tab.
       */
      get removeBehavior() {
        return this._removeBehavior;
      }
      /**
       * Set the selection behavior when removing a tab.
       */
      set removeBehavior(value) {
        this._removeBehavior = value;
      }
      /**
       * Adjust the current index for a tab insert operation.
       *
       * @param i - The new index of the inserted item.
       * @param j - The inserted item.
       *
       * #### Notes
       * This method accounts for the tab bar's insertion behavior when adjusting
       * the current index and emitting the changed signal. This should be called
       * after the insertion.
       */
      adjustSelectionForInsert(i5, item) {
        const cv = this._value;
        const ci = this._index;
        const bh = this._insertBehavior;
        if (bh === "select-item" || bh === "select-item-if-needed" && ci === null) {
          this._index = i5;
          this._value = item;
          this._previousValue = cv;
          this._selectionChanged.emit({
            previousIndex: ci,
            previousValue: cv,
            currentIndex: i5,
            currentValue: item
          });
          return;
        }
        if (ci !== null && ci >= i5) {
          this._index++;
        }
      }
      /**
       * Clear the selection and history.
       */
      clearSelection() {
        const pi = this._index;
        const pv = this._value;
        this._index = null;
        this._value = null;
        this._previousValue = null;
        if (pi === null) {
          return;
        }
        this._selectionChanged.emit({
          previousIndex: pi,
          previousValue: pv,
          currentIndex: this._index,
          currentValue: this._value
        });
      }
      /**
       * Adjust the current index for an item remove operation.
       *
       * @param i - The former index of the removed item.
       * @param item - The removed item.
       *
       * #### Notes
       * This method accounts for the remove behavior when adjusting the current
       * index and emitting the changed signal. It should be called after the item
       * is removed.
       */
      adjustSelectionForRemove(i5, item) {
        if (this._index === null) {
          return;
        }
        const ci = this._index;
        const bh = this._removeBehavior;
        if (ci !== i5) {
          if (ci > i5) {
            this._index--;
          }
          return;
        }
        if (!this._array || this._array.length === 0) {
          this._index = null;
          this._value = null;
          this._previousValue = null;
          this._selectionChanged.emit({
            previousIndex: i5,
            previousValue: item,
            currentIndex: this._index,
            currentValue: this._value
          });
          return;
        }
        if (bh === "select-item-after") {
          this._index = Math.min(i5, this._array.length - 1);
          this._updateSelectedValue();
          this._previousValue = null;
          this._selectionChanged.emit({
            previousIndex: i5,
            previousValue: item,
            currentIndex: this._index,
            currentValue: this._value
          });
          return;
        }
        if (bh === "select-item-before") {
          this._index = Math.max(0, i5 - 1);
          this._updateSelectedValue();
          this._previousValue = null;
          this._selectionChanged.emit({
            previousIndex: i5,
            previousValue: item,
            currentIndex: this._index,
            currentValue: this._value
          });
          return;
        }
        if (bh === "select-previous-item") {
          if (this._previousValue) {
            this.value = this._previousValue;
          } else {
            this._index = Math.min(i5, this._array.length - 1);
            this._updateSelectedValue();
          }
          this._previousValue = null;
          this._selectionChanged.emit({
            previousIndex: i5,
            previousValue: item,
            currentIndex: this._index,
            currentValue: this.value
          });
          return;
        }
        this._index = null;
        this._value = null;
        this._previousValue = null;
        this._selectionChanged.emit({
          previousIndex: i5,
          previousValue: item,
          currentIndex: this._index,
          currentValue: this._value
        });
      }
      /**
       * Set the current value based on the current index.
       */
      _updateSelectedValue() {
        const i5 = this._index;
        this._value = i5 !== null && this._array ? this._array[i5] : null;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/lumino/accordion.js
var COLLAPSE_CLASS, COLLAPSE_HEADER_CLASS, COLLAPSE_CONTENTS_CLASS, COLLAPSE_CLASS_OPEN, Collapse, ACCORDION_CLASS, ACCORDION_CHILD_CLASS, ACCORDION_CHILD_ACTIVE_CLASS, Accordion;
var init_accordion = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/lumino/accordion.js"() {
    init_index_es65();
    init_index_es6();
    init_index_es64();
    init_currentselection();
    COLLAPSE_CLASS = "jupyter-widget-Collapse";
    COLLAPSE_HEADER_CLASS = "jupyter-widget-Collapse-header";
    COLLAPSE_CONTENTS_CLASS = "jupyter-widget-Collapse-contents";
    COLLAPSE_CLASS_OPEN = "jupyter-widget-Collapse-open";
    Collapse = class extends Widget {
      constructor(options) {
        super(options);
        this._collapseChanged = new Signal(this);
        this.addClass(COLLAPSE_CLASS);
        this._header = new Widget();
        this._header.addClass(COLLAPSE_HEADER_CLASS);
        this._header.node.addEventListener("click", this);
        const icon = document.createElement("i");
        icon.classList.add("fa", "fa-fw", "fa-caret-right");
        this._header.node.appendChild(icon);
        this._header.node.appendChild(document.createElement("span"));
        this._content = new Panel();
        this._content.addClass(COLLAPSE_CONTENTS_CLASS);
        const layout = new PanelLayout();
        this.layout = layout;
        layout.addWidget(this._header);
        layout.addWidget(this._content);
        if (options.widget) {
          this.widget = options.widget;
        }
        this.collapsed = false;
      }
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._header = null;
        this._widget = null;
        this._content = null;
      }
      get widget() {
        return this._widget;
      }
      set widget(widget) {
        const oldWidget = this._widget;
        if (oldWidget) {
          oldWidget.disposed.disconnect(this._onChildDisposed, this);
          oldWidget.title.changed.disconnect(this._onTitleChanged, this);
          oldWidget.parent = null;
        }
        this._widget = widget;
        widget.disposed.connect(this._onChildDisposed, this);
        widget.title.changed.connect(this._onTitleChanged, this);
        this._onTitleChanged(widget.title);
        this._content.addWidget(widget);
      }
      get collapsed() {
        return this._collapsed;
      }
      set collapsed(value) {
        if (value === this._collapsed) {
          return;
        }
        if (value) {
          this._collapse();
        } else {
          this._uncollapse();
        }
      }
      toggle() {
        this.collapsed = !this.collapsed;
      }
      get collapseChanged() {
        return this._collapseChanged;
      }
      _collapse() {
        this._collapsed = true;
        if (this._content) {
          this._content.hide();
        }
        this.removeClass(COLLAPSE_CLASS_OPEN);
        this._header.node.children[0].classList.add("fa-caret-right");
        this._header.node.children[0].classList.remove("fa-caret-down");
        this._collapseChanged.emit(void 0);
      }
      _uncollapse() {
        this._collapsed = false;
        if (this._content) {
          this._content.show();
        }
        this.addClass(COLLAPSE_CLASS_OPEN);
        this._header.node.children[0].classList.add("fa-caret-down");
        this._header.node.children[0].classList.remove("fa-caret-right");
        this._collapseChanged.emit(void 0);
      }
      /**
       * Handle the DOM events for the Collapse widget.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          default:
            break;
        }
      }
      _evtClick(event) {
        this.toggle();
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        this._header.node.children[1].textContent = this._widget.title.label;
      }
      _onChildDisposed(sender) {
        this.dispose();
      }
    };
    ACCORDION_CLASS = "jupyter-widget-Accordion";
    ACCORDION_CHILD_CLASS = "jupyter-widget-Accordion-child";
    ACCORDION_CHILD_ACTIVE_CLASS = "jupyter-widget-Accordion-child-active";
    Accordion = class extends Panel {
      constructor(options) {
        super(options);
        this._selection = new Selection(this.widgets);
        this._selection.selectionChanged.connect(this._onSelectionChanged, this);
        this.addClass(ACCORDION_CLASS);
      }
      /**
       * A read-only sequence of the widgets in the panel.
       *
       * #### Notes
       * This is a read-only property.
       */
      /*  get widgets(): ISequence<Widget> {
          return new ArraySequence(toArray(map((this.layout as PanelLayout).widgets, (w: Collapse) => w.widget)));
        }
      */
      get collapseWidgets() {
        return this.layout.widgets;
      }
      get selection() {
        return this._selection;
      }
      indexOf(widget) {
        return ArrayExt.findFirstIndex(this.collapseWidgets, (w4) => w4.widget === widget);
      }
      /**
       * Add a widget to the end of the accordion.
       *
       * @param widget - The widget to add to the accordion.
       *
       * @returns The Collapse widget wrapping the added widget.
       *
       * #### Notes
       * The widget will be wrapped in a CollapsedWidget.
       */
      addWidget(widget) {
        const collapse = this._wrapWidget(widget);
        collapse.collapsed = true;
        super.addWidget(collapse);
        this._selection.adjustSelectionForInsert(this.widgets.length - 1, collapse);
        return collapse;
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the accordion.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index2, widget) {
        const collapse = this._wrapWidget(widget);
        collapse.collapsed = true;
        super.insertWidget(index2, collapse);
        this._selection.adjustSelectionForInsert(index2, collapse);
      }
      removeWidget(widget) {
        const index2 = this.indexOf(widget);
        if (index2 >= 0) {
          const collapse = this.collapseWidgets[index2];
          widget.parent = null;
          collapse.dispose();
          this._selection.adjustSelectionForRemove(index2, null);
        }
      }
      _wrapWidget(widget) {
        const collapse = new Collapse({ widget });
        collapse.addClass(ACCORDION_CHILD_CLASS);
        collapse.collapseChanged.connect(this._onCollapseChange, this);
        return collapse;
      }
      _onCollapseChange(sender) {
        if (!sender.collapsed) {
          this._selection.value = sender;
        } else if (this._selection.value === sender && sender.collapsed) {
          this._selection.value = null;
        }
      }
      _onSelectionChanged(sender, change) {
        const pv = change.previousValue;
        const cv = change.currentValue;
        if (pv) {
          pv.collapsed = true;
          pv.removeClass(ACCORDION_CHILD_ACTIVE_CLASS);
        }
        if (cv) {
          cv.collapsed = false;
          cv.addClass(ACCORDION_CHILD_ACTIVE_CLASS);
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_selectioncontainer.js
var import_jquery5, SelectionContainerModel, AccordionModel, JupyterLuminoAccordionWidget, AccordionView, TabModel, JupyterLuminoTabPanelWidget, TabView, StackModel, StackView;
var init_widget_selectioncontainer = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_selectioncontainer.js"() {
    init_lib10();
    init_widget_box();
    init_tabpanel();
    init_accordion();
    init_index_es64();
    init_index_es65();
    init_index_es66();
    import_jquery5 = __toESM(require_jquery());
    SelectionContainerModel = class extends BoxModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectionContainerModel", selected_index: null, titles: [] });
      }
    };
    AccordionModel = class extends SelectionContainerModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "AccordionModel", _view_name: "AccordionView" });
      }
    };
    JupyterLuminoAccordionWidget = class extends Accordion {
      constructor(options) {
        const view = options.view;
        delete options.view;
        super(options);
        this._view = view;
      }
      /**
       * Process the Lumino message.
       *
       * Any custom Lumino widget used inside a Jupyter widget should override
       * the processMessage function like this.
       */
      processMessage(msg) {
        var _a;
        super.processMessage(msg);
        (_a = this._view) === null || _a === void 0 ? void 0 : _a.processLuminoMessage(msg);
      }
      /**
       * Dispose the widget.
       *
       * This causes the view to be destroyed as well with 'remove'
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._view.remove();
        this._view = null;
      }
    };
    AccordionView = class extends DOMWidgetView {
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoAccordionWidget({ view: this });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery5.default)(this.luminoWidget.node);
      }
      initialize(parameters) {
        super.initialize(parameters);
        this.children_views = new ViewList(this.add_child_view, this.remove_child_view, this);
        this.listenTo(this.model, "change:children", () => this.updateChildren());
        this.listenTo(this.model, "change:selected_index", () => this.update_selected_index());
        this.listenTo(this.model, "change:titles", () => this.update_titles());
      }
      /**
       * Called when view is rendered.
       */
      render() {
        var _a;
        super.render();
        const accordion = this.luminoWidget;
        accordion.addClass("jupyter-widgets");
        accordion.addClass("widget-accordion");
        accordion.addClass("widget-container");
        accordion.selection.selectionChanged.connect((sender) => {
          if (!this.updatingChildren) {
            this.model.set("selected_index", accordion.selection.index);
            this.touch();
          }
        });
        (_a = this.children_views) === null || _a === void 0 ? void 0 : _a.update(this.model.get("children"));
        this.update_titles();
        this.update_selected_index();
      }
      /**
       * Update children
       */
      updateChildren() {
        var _a;
        this.updatingChildren = true;
        this.luminoWidget.selection.index = null;
        (_a = this.children_views) === null || _a === void 0 ? void 0 : _a.update(this.model.get("children"));
        this.update_selected_index();
        this.updatingChildren = false;
      }
      /**
       * Set header titles
       */
      update_titles() {
        const collapsed = this.luminoWidget.collapseWidgets;
        const titles = this.model.get("titles");
        for (let i5 = 0; i5 < collapsed.length; i5++) {
          if (titles[i5] !== void 0) {
            collapsed[i5].widget.title.label = titles[i5];
          }
        }
      }
      /**
       * Make the rendering and selected index consistent.
       */
      update_selected_index() {
        this.luminoWidget.selection.index = this.model.get("selected_index");
      }
      /**
       * Called when a child is removed from children list.
       */
      remove_child_view(view) {
        this.luminoWidget.removeWidget(view.luminoWidget);
        view.remove();
      }
      /**
       * Called when a child is added to children list.
       */
      add_child_view(model, index2) {
        const accordion = this.luminoWidget;
        const placeholder2 = new Widget();
        placeholder2.title.label = this.model.get("titles")[index2] || "";
        accordion.addWidget(placeholder2);
        return this.create_child_view(model).then((view) => {
          const widget = view.luminoWidget;
          widget.title.label = placeholder2.title.label;
          const collapse = accordion.collapseWidgets[accordion.indexOf(placeholder2)];
          collapse.widget = widget;
          placeholder2.dispose();
          return view;
        }).catch(reject("Could not add child view to box", true));
      }
      remove() {
        this.children_views = null;
        super.remove();
      }
    };
    TabModel = class extends SelectionContainerModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "TabModel", _view_name: "TabView" });
      }
    };
    JupyterLuminoTabPanelWidget = class extends TabPanel {
      constructor(options) {
        const view = options.view;
        delete options.view;
        super(options);
        this._view = view;
        MessageLoop.installMessageHook(this.tabContents, (handler, msg) => {
          this._view.processLuminoMessage(msg);
          return true;
        });
      }
      /**
       * Dispose the widget.
       *
       * This causes the view to be destroyed as well with 'remove'
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._view.remove();
        this._view = null;
      }
    };
    TabView = class extends DOMWidgetView {
      constructor() {
        super(...arguments);
        this.updatingTabs = false;
      }
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoTabPanelWidget({
          view: this
        });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery5.default)(this.luminoWidget.node);
      }
      /**
       * Public constructor.
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.childrenViews = new ViewList(this.addChildView, (view) => {
          view.remove();
        }, this);
        this.listenTo(this.model, "change:children", () => this.updateTabs());
        this.listenTo(this.model, "change:titles", () => this.updateTitles());
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        const tabs = this.luminoWidget;
        tabs.addClass("jupyter-widgets");
        tabs.addClass("widget-container");
        tabs.addClass("jupyter-widget-tab");
        tabs.addClass("widget-tab");
        tabs.tabsMovable = true;
        tabs.tabBar.insertBehavior = "none";
        tabs.tabBar.currentChanged.connect(this._onTabChanged, this);
        tabs.tabBar.tabMoved.connect(this._onTabMoved, this);
        tabs.tabBar.addClass("widget-tab-bar");
        tabs.tabContents.addClass("widget-tab-contents");
        tabs.tabBar.tabsMovable = false;
        this.updateTabs();
        this.update();
      }
      /**
       * Render tab views based on the current model's children.
       */
      updateTabs() {
        var _a;
        this.updatingTabs = true;
        this.luminoWidget.currentIndex = null;
        (_a = this.childrenViews) === null || _a === void 0 ? void 0 : _a.update(this.model.get("children"));
        this.luminoWidget.currentIndex = this.model.get("selected_index");
        this.updatingTabs = false;
      }
      /**
       * Called when a child is added to children list.
       */
      addChildView(model, index2) {
        const label = this.model.get("titles")[index2] || "";
        const tabs = this.luminoWidget;
        const placeholder2 = new Widget();
        placeholder2.title.label = label;
        tabs.addWidget(placeholder2);
        return this.create_child_view(model).then((view) => {
          const widget = view.luminoWidget;
          widget.title.label = placeholder2.title.label;
          widget.title.closable = false;
          const i5 = ArrayExt.firstIndexOf(tabs.widgets, placeholder2);
          tabs.insertWidget(i5 + 1, widget);
          placeholder2.dispose();
          return view;
        }).catch(reject("Could not add child view to box", true));
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.updateSelectedIndex();
        return super.update();
      }
      /**
       * Updates the tab page titles.
       */
      updateTitles() {
        const titles = this.model.get("titles") || [];
        each(this.luminoWidget.widgets, (widget, i5) => {
          widget.title.label = titles[i5] || "";
        });
      }
      /**
       * Updates the selected index.
       */
      updateSelectedIndex() {
        this.luminoWidget.currentIndex = this.model.get("selected_index");
      }
      remove() {
        this.childrenViews = null;
        super.remove();
      }
      _onTabChanged(sender, args) {
        if (!this.updatingTabs) {
          const i5 = args.currentIndex;
          this.model.set("selected_index", i5 === -1 ? null : i5);
          this.touch();
        }
      }
      /**
       * Handle the `tabMoved` signal from the tab bar.
       */
      _onTabMoved(sender, args) {
        const children = this.model.get("children").slice();
        ArrayExt.move(children, args.fromIndex, args.toIndex);
        this.model.set("children", children);
        this.touch();
      }
    };
    StackModel = class extends SelectionContainerModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "StackModel", _view_name: "StackView" });
      }
    };
    StackView = class extends BoxView {
      initialize(parameters) {
        super.initialize(parameters);
        this.listenTo(this.model, "change:selected_index", this.update_children);
      }
      update_children() {
        var _a;
        let child;
        if (this.model.get("selected_index") === null) {
          child = [];
        } else {
          child = [this.model.get("children")[this.model.get("selected_index")]];
        }
        (_a = this.children_views) === null || _a === void 0 ? void 0 : _a.update(child).then((views) => {
          views.forEach((view) => {
            MessageLoop.postMessage(view.luminoWidget, Widget.ResizeMessage.UnknownSize);
          });
        });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_tagsinput.js
function trim(value) {
  return value.replace(/^\s+|\s+$/g, "");
}
function clamp2(value, min3, max3) {
  return Math.min(Math.max(value, min3), max3);
}
function removeChildren(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
}
var Selection2, TagsInputBaseModel, TagsInputBaseView, TagsInputModel, TagsInputView, ColorsInputModel, ColorsInputView, NumbersInputModel, NumbersInputView, FloatsInputModel, FloatsInputView, IntsInputModel, IntsInputView;
var init_widget_tagsinput = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_tagsinput.js"() {
    init_src2();
    init_src();
    init_widget_core();
    init_lib10();
    Selection2 = class {
      constructor(start, dx, max3) {
        this.start = start;
        this.dx = dx;
        this.max = max3;
      }
      /**
       * Check if a given index is currently selected.
       */
      isSelected(index2) {
        let min3;
        let max3;
        if (this.dx >= 0) {
          min3 = this.start;
          max3 = this.start + this.dx;
        } else {
          min3 = this.start + this.dx;
          max3 = this.start;
        }
        return min3 <= index2 && index2 < max3;
      }
      /**
       * Update selection
       */
      updateSelection(dx) {
        this.dx += dx;
        if (this.start + this.dx > this.max) {
          this.dx = this.max - this.start;
        }
        if (this.start + this.dx < 0) {
          this.dx = -this.start;
        }
      }
    };
    TagsInputBaseModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: [], placeholder: "\u200B", allowed_tags: null, allow_duplicates: true });
      }
    };
    TagsInputBaseView = class extends DOMWidgetView {
      constructor() {
        super(...arguments);
        this.hoveredTag = null;
        this.hoveredTagIndex = null;
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("jupyter-widget-tagsinput");
        this.taginputWrapper = document.createElement("div");
        if (this.model.get("value").length) {
          this.taginputWrapper.style.display = "none";
        } else {
          this.taginputWrapper.style.display = "inline-block";
        }
        this.datalistID = uuid();
        this.taginput = document.createElement("input");
        this.taginput.classList.add("jupyter-widget-tag");
        this.taginput.classList.add("jupyter-widget-taginput");
        this.taginput.setAttribute("list", this.datalistID);
        this.taginput.setAttribute("type", "text");
        this.autocompleteList = document.createElement("datalist");
        this.autocompleteList.id = this.datalistID;
        this.updateAutocomplete();
        this.model.on("change:allowed_tags", this.updateAutocomplete.bind(this));
        this.updatePlaceholder();
        this.model.on("change:placeholder", this.updatePlaceholder.bind(this));
        this.taginputWrapper.classList.add("widget-text");
        this.taginputWrapper.appendChild(this.taginput);
        this.taginputWrapper.appendChild(this.autocompleteList);
        this.el.onclick = this.focus.bind(this);
        this.el.ondrop = (event) => {
          const index2 = this.hoveredTagIndex == null ? this.tags.length : this.hoveredTagIndex;
          return this.ondrop(event, index2);
        };
        this.el.ondragover = this.ondragover.bind(this);
        this.taginput.onchange = this.handleValueAdded.bind(this);
        this.taginput.oninput = this.resizeInput.bind(this);
        this.taginput.onkeydown = this.handleKeyEvent.bind(this);
        this.taginput.onblur = this.loseFocus.bind(this);
        this.resizeInput();
        this.inputIndex = this.model.get("value").length;
        this.selection = null;
        this.preventLoosingFocus = false;
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.preventLoosingFocus = true;
        removeChildren(this.el);
        this.tags = [];
        const value = this.model.get("value");
        for (const idx in value) {
          const index2 = parseInt(idx);
          const tag = this.createTag(value[index2], index2, this.selection != null && this.selection.isSelected(index2));
          tag.draggable = true;
          tag.ondragstart = ((index3, value2) => {
            return (event) => {
              this.ondragstart(event, index3, value2, this.model.model_id);
            };
          })(index2, value[index2]);
          tag.ondrop = ((index3) => {
            return (event) => {
              this.ondrop(event, index3);
            };
          })(index2);
          tag.ondragover = this.ondragover.bind(this);
          tag.ondragenter = ((index3) => {
            return (event) => {
              this.ondragenter(event, index3);
            };
          })(index2);
          tag.ondragend = this.ondragend.bind(this);
          this.tags.push(tag);
          this.el.appendChild(tag);
        }
        this.el.insertBefore(this.taginputWrapper, this.el.children[this.inputIndex]);
        if (this.model.get("value").length) {
          this.taginputWrapper.style.display = "none";
        } else {
          this.taginputWrapper.style.display = "inline-block";
        }
        this.preventLoosingFocus = false;
        return super.update();
      }
      /**
       * Update the auto-completion list
       */
      updateAutocomplete() {
        removeChildren(this.autocompleteList);
        const allowedTags = this.model.get("allowed_tags");
        for (const tag of allowedTags) {
          const option = document.createElement("option");
          option.value = tag;
          this.autocompleteList.appendChild(option);
        }
      }
      /**
       * Update the auto-completion list
       */
      updatePlaceholder() {
        this.taginput.placeholder = this.model.get("placeholder");
        this.resizeInput();
      }
      /**
       * Update the tags, called when the selection has changed and we need to update the tags CSS
       */
      updateTags() {
        const value = this.model.get("value");
        for (const idx in this.tags) {
          const index2 = parseInt(idx);
          this.updateTag(this.tags[index2], value[index2], index2, this.selection != null && this.selection.isSelected(index2));
        }
      }
      /**
       * Handle a new value is added from the input element
       */
      handleValueAdded(event) {
        const newTagValue = trim(this.taginput.value);
        const tagIndex = this.inputIndex;
        if (newTagValue == "") {
          return;
        }
        this.inputIndex++;
        const tagAdded = this.addTag(tagIndex, newTagValue);
        if (tagAdded) {
          this.taginput.value = "";
          this.resizeInput();
          this.focus();
        }
      }
      /**
       * Add a new tag with a value of `tagValue` at the `index` position
       * Return true if the tag was correctly added, false otherwise
       */
      addTag(index2, tagValue) {
        const value = this.model.get("value");
        let newTagValue;
        try {
          newTagValue = this.validateValue(tagValue);
        } catch (error) {
          return false;
        }
        const allowedTagValues = this.model.get("allowed_tags");
        if (allowedTagValues.length && !allowedTagValues.includes(newTagValue)) {
          return false;
        }
        if (!this.model.get("allow_duplicates") && value.includes(newTagValue)) {
          return false;
        }
        this.selection = null;
        const newValue = [...value];
        newValue.splice(index2, 0, newTagValue);
        this.model.set("value", newValue);
        this.model.save_changes();
        return true;
      }
      /**
       * Resize the input element
       */
      resizeInput() {
        let content;
        if (this.taginput.value.length != 0) {
          content = this.taginput.value;
        } else {
          content = this.model.get("placeholder");
        }
        const size3 = content.length + 1;
        this.taginput.setAttribute("size", String(size3));
      }
      /**
       * Handle key events on the input element
       */
      handleKeyEvent(event) {
        const valueLength = this.model.get("value").length;
        if (this.taginput.value.length) {
          return;
        }
        const currentElement = this.inputIndex;
        switch (event.key) {
          case "ArrowLeft":
            if (event.ctrlKey && event.shiftKey) {
              this.select(currentElement, -currentElement);
            }
            if (!event.ctrlKey && event.shiftKey) {
              this.select(currentElement, -1);
            }
            if (event.ctrlKey) {
              this.inputIndex = 0;
            } else {
              this.inputIndex--;
            }
            break;
          case "ArrowRight":
            if (event.ctrlKey && event.shiftKey) {
              this.select(currentElement, valueLength - currentElement);
            }
            if (!event.ctrlKey && event.shiftKey) {
              this.select(currentElement, 1);
            }
            if (event.ctrlKey) {
              this.inputIndex = valueLength;
            } else {
              this.inputIndex++;
            }
            break;
          case "Backspace":
            if (this.selection) {
              this.removeSelectedTags();
            } else {
              this.removeTag(this.inputIndex - 1);
            }
            break;
          case "Delete":
            if (this.selection) {
              this.removeSelectedTags();
            } else {
              this.removeTag(this.inputIndex);
            }
            break;
          default:
            return;
            break;
        }
        if (!event.shiftKey) {
          this.selection = null;
        }
        this.inputIndex = clamp2(this.inputIndex, 0, valueLength);
        this.update();
        this.focus();
      }
      /**
       * Function that gets called when a tag with a given `value` is being dragged.
       */
      ondragstart(event, index2, tagValue, origin) {
        if (event.dataTransfer == null) {
          return;
        }
        event.dataTransfer.setData("index", String(index2));
        event.dataTransfer.setData("tagValue", String(tagValue));
        event.dataTransfer.setData("origin", origin);
      }
      /**
       * Function that gets called when a tag has been dragged on the tag at the `index` position.
       */
      ondrop(event, index2) {
        if (event.dataTransfer == null) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        const draggedTagValue = event.dataTransfer.getData("tagValue");
        const draggedTagindex = parseInt(event.dataTransfer.getData("index"));
        const sameOrigin = event.dataTransfer.getData("origin") == this.model.model_id;
        if (isNaN(draggedTagindex)) {
          return;
        }
        if (sameOrigin) {
          const value = this.model.get("value");
          const newValue = [...value];
          if (draggedTagindex < index2) {
            index2--;
          }
          newValue.splice(draggedTagindex, 1);
          newValue.splice(index2, 0, draggedTagValue);
          this.model.set("value", newValue);
          this.model.save_changes();
          return;
        }
        this.addTag(index2, draggedTagValue);
      }
      ondragover(event) {
        event.preventDefault();
      }
      ondragenter(event, index2) {
        if (this.hoveredTag != null && this.hoveredTag != this.tags[index2]) {
          this.hoveredTag.style.marginLeft = "1px";
        }
        this.hoveredTag = this.tags[index2];
        this.hoveredTagIndex = index2;
        this.hoveredTag.style.marginLeft = "30px";
      }
      ondragend() {
        if (this.hoveredTag != null) {
          this.hoveredTag.style.marginLeft = "1px";
        }
        this.hoveredTag = null;
        this.hoveredTagIndex = null;
      }
      /**
       * Select tags from `start` to `start + dx` not included.
       */
      select(start, dx) {
        const valueLength = this.model.get("value").length;
        if (!this.selection) {
          this.selection = new Selection2(start, dx, valueLength);
        } else {
          this.selection.updateSelection(dx);
        }
      }
      /**
       * Remove all the selected tags.
       */
      removeSelectedTags() {
        const value = [...this.model.get("value")];
        const valueLength = value.length;
        for (let idx = valueLength - 1; idx >= 0; idx--) {
          if (this.selection != null && this.selection.isSelected(idx)) {
            value.splice(idx, 1);
            if (idx < this.inputIndex) {
              this.inputIndex--;
            }
          }
        }
        this.model.set("value", value);
        this.model.save_changes();
      }
      /**
       * Remove a tag given its index in the list
       */
      removeTag(tagIndex) {
        const value = [...this.model.get("value")];
        value.splice(tagIndex, 1);
        if (tagIndex < this.inputIndex) {
          this.inputIndex--;
        }
        this.model.set("value", value);
        this.model.save_changes();
      }
      /**
       * Focus on the input element
       */
      focus() {
        this.taginputWrapper.style.display = "inline-block";
        this.taginput.focus();
      }
      /**
       * Lose focus on the input element
       */
      loseFocus() {
        if (this.preventLoosingFocus) {
          return;
        }
        if (this.model.get("value").length) {
          this.taginputWrapper.style.display = "none";
        }
        this.selection = null;
        this.updateTags();
      }
      preinitialize() {
        this.tagName = "div";
      }
      /**
       * Validate an input tag typed by the user, returning the correct tag type. This should be overridden in subclasses.
       */
      validateValue(value) {
        return value;
      }
    };
    TagsInputModel = class extends TagsInputBaseModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: [], tag_style: "", _view_name: "TagsInputView", _model_name: "TagsInputModel" });
      }
    };
    TagsInputView = class extends TagsInputBaseView {
      /**
       * Create the string tag
       */
      createTag(value, index2, selected) {
        const tag = document.createElement("div");
        const style = this.model.get("tag_style");
        tag.classList.add("jupyter-widget-tag");
        tag.classList.add(TagsInputView.class_map[style]);
        if (selected) {
          tag.classList.add("mod-active");
        }
        tag.appendChild(document.createTextNode(this.getTagText(value)));
        const i5 = document.createElement("i");
        i5.classList.add("fa");
        i5.classList.add("fa-times");
        i5.classList.add("jupyter-widget-tag-close");
        tag.appendChild(i5);
        i5.onmousedown = ((index3) => {
          return () => {
            this.removeTag(index3);
            this.loseFocus();
          };
        })(index2);
        return tag;
      }
      /**
       * Returns the text that should be displayed in the tag element
       */
      getTagText(value) {
        return value;
      }
      /**
       * Update a given tag
       */
      updateTag(tag, value, index2, selected) {
        if (selected) {
          tag.classList.add("mod-active");
        } else {
          tag.classList.remove("mod-active");
        }
      }
    };
    TagsInputView.class_map = {
      primary: "mod-primary",
      success: "mod-success",
      info: "mod-info",
      warning: "mod-warning",
      danger: "mod-danger"
    };
    ColorsInputModel = class extends TagsInputBaseModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: [], _view_name: "ColorsInputView", _model_name: "ColorsInputModel" });
      }
    };
    ColorsInputView = class extends TagsInputBaseView {
      /**
       * Create the Color tag
       */
      createTag(value, index2, selected) {
        const tag = document.createElement("div");
        const color2 = value;
        const darkerColor = color(value).darker().toString();
        tag.classList.add("jupyter-widget-tag");
        tag.classList.add("jupyter-widget-colortag");
        if (!selected) {
          tag.style.backgroundColor = color2;
        } else {
          tag.classList.add("mod-active");
          tag.style.backgroundColor = darkerColor;
        }
        const i5 = document.createElement("i");
        i5.classList.add("fa");
        i5.classList.add("fa-times");
        i5.classList.add("jupyter-widget-tag-close");
        tag.appendChild(i5);
        i5.onmousedown = ((index3) => {
          return () => {
            this.removeTag(index3);
            this.loseFocus();
          };
        })(index2);
        return tag;
      }
      /**
       * Update a given tag
       */
      updateTag(tag, value, index2, selected) {
        const color2 = value;
        const darkerColor = color(value).darker().toString();
        if (!selected) {
          tag.classList.remove("mod-active");
          tag.style.backgroundColor = color2;
        } else {
          tag.classList.add("mod-active");
          tag.style.backgroundColor = darkerColor;
        }
      }
      /**
       * Validate an input tag typed by the user, returning the correct tag type. This should be overridden in subclasses.
       */
      validateValue(value) {
        if (color(value) == null) {
          throw value + " is not a valid Color";
        }
        return value;
      }
    };
    NumbersInputModel = class extends TagsInputModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { min: null, max: null });
      }
    };
    NumbersInputView = class extends TagsInputView {
      render() {
        this.model.on("change:format", () => {
          this.formatter = format(this.model.get("format"));
          this.update();
        });
        this.formatter = format(this.model.get("format"));
        super.render();
      }
      /**
       * Returns the text that should be displayed in the tag element
       */
      getTagText(value) {
        return this.formatter(this.parseNumber(value));
      }
      /**
       * Validate an input tag typed by the user, returning the correct tag type. This should be overridden in subclasses.
       */
      validateValue(value) {
        const parsed = this.parseNumber(value);
        const min3 = this.model.get("min");
        const max3 = this.model.get("max");
        if (isNaN(parsed) || min3 != null && parsed < min3 || max3 != null && parsed > max3) {
          throw value + " is not a valid number, it should be in the range [" + min3 + ", " + max3 + "]";
        }
        return parsed;
      }
    };
    FloatsInputModel = class extends NumbersInputModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "FloatsInputView", _model_name: "FloatsInputModel", format: ".1f" });
      }
    };
    FloatsInputView = class extends NumbersInputView {
      parseNumber(value) {
        return parseFloat(value);
      }
    };
    IntsInputModel = class extends NumbersInputModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "IntsInputView", _model_name: "IntsInputModel", format: "d" });
      }
    };
    IntsInputView = class extends NumbersInputView {
      parseNumber(value) {
        const int2 = parseInt(value);
        if (int2 != parseFloat(value)) {
          throw value + " should be an integer";
        }
        return int2;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_string.js
var INVALID_VALUE_CLASS, StringStyleModel, HTMLStyleModel, HTMLMathStyleModel, LabelStyleModel, TextStyleModel, StringModel, StringView, HTMLModel, HTMLView, HTMLMathModel, HTMLMathView, LabelModel, LabelView, TextareaModel, TextareaView, TextModel, TextView, PasswordModel, PasswordView, ComboboxModel, ComboboxView;
var init_widget_string = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_string.js"() {
    init_widget_core();
    init_widget_description();
    init_utils3();
    init_version2();
    INVALID_VALUE_CLASS = "jpwidgets-invalidComboValue";
    StringStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "StringStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    StringStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { background: {
      selector: "",
      attribute: "background",
      default: null
    }, font_size: {
      selector: "",
      attribute: "font-size",
      default: ""
    }, text_color: {
      selector: "",
      attribute: "color",
      default: ""
    } });
    HTMLStyleModel = class extends StringStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "HTMLStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    HTMLStyleModel.styleProperties = Object.assign({}, StringStyleModel.styleProperties);
    HTMLMathStyleModel = class extends StringStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "HTMLMathStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    HTMLMathStyleModel.styleProperties = Object.assign({}, StringStyleModel.styleProperties);
    LabelStyleModel = class extends StringStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "LabelStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    LabelStyleModel.styleProperties = Object.assign(Object.assign({}, StringStyleModel.styleProperties), { font_family: {
      selector: "",
      attribute: "font-family",
      default: ""
    }, font_style: {
      selector: "",
      attribute: "font-style",
      default: ""
    }, font_variant: {
      selector: "",
      attribute: "font-variant",
      default: ""
    }, font_weight: {
      selector: "",
      attribute: "font-weight",
      default: ""
    }, text_decoration: {
      selector: "",
      attribute: "text-decoration",
      default: ""
    } });
    TextStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "TextStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    TextStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { background: {
      selector: ".widget-input",
      attribute: "background",
      default: null
    }, font_size: {
      selector: ".widget-input",
      attribute: "font-size",
      default: ""
    }, text_color: {
      selector: ".widget-input",
      attribute: "color",
      default: ""
    } });
    StringModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: "", disabled: false, placeholder: "\u200B", _model_name: "StringModel" });
      }
    };
    StringView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
      }
    };
    HTMLModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "HTMLView", _model_name: "HTMLModel" });
      }
    };
    HTMLView = class extends StringView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-html");
        this.content = document.createElement("div");
        this.content.classList.add("widget-html-content");
        this.el.appendChild(this.content);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.content.innerHTML = this.model.get("value");
        return super.update();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.content.focus();
        } else if (content.do === "blur") {
          this.content.blur();
        }
      }
    };
    HTMLMathModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "HTMLMathView", _model_name: "HTMLMathModel" });
      }
    };
    HTMLMathView = class extends StringView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-htmlmath");
        this.content = document.createElement("div");
        this.content.classList.add("widget-htmlmath-content");
        this.el.appendChild(this.content);
        this.update();
      }
      /**
       * Update the contents of this view
       */
      update() {
        this.content.innerHTML = this.model.get("value");
        this.typeset(this.content);
        return super.update();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.content.focus();
        } else if (content.do === "blur") {
          this.content.blur();
        }
      }
    };
    LabelModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "LabelView", _model_name: "LabelModel" });
      }
    };
    LabelView = class extends StringView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-label");
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.typeset(this.el, this.model.get("value"));
        return super.update();
      }
    };
    TextareaModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "TextareaView", _model_name: "TextareaModel", rows: null, continuous_update: true });
      }
    };
    TextareaView = class extends StringView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-textarea");
        this.textbox = document.createElement("textarea");
        this.textbox.setAttribute("rows", "5");
        this.textbox.id = this.label.htmlFor = uuid();
        this.textbox.classList.add("widget-input");
        this.el.appendChild(this.textbox);
        this.update();
        this.listenTo(this.model, "change:placeholder", (model, value, options) => {
          this.update_placeholder(value);
        });
        this.update_placeholder();
        this.updateTooltip();
      }
      update_placeholder(value) {
        const v2 = value || this.model.get("placeholder");
        this.textbox.setAttribute("placeholder", v2.toString());
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          this.textbox.value = this.model.get("value");
          let rows = this.model.get("rows");
          if (rows === null) {
            rows = "";
          }
          this.textbox.setAttribute("rows", rows);
          this.textbox.disabled = this.model.get("disabled");
        }
        this.updateTabindex();
        this.updateTooltip();
        return super.update();
      }
      updateTabindex() {
        if (!this.textbox) {
          return;
        }
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.textbox.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.textbox.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.textbox.removeAttribute("tabIndex");
        }
      }
      updateTooltip() {
        if (!this.textbox)
          return;
        const title = this.model.get("tooltip");
        if (!title) {
          this.textbox.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.textbox.setAttribute("title", title);
        }
      }
      events() {
        return {
          "keydown input": "handleKeyDown",
          "keypress input": "handleKeypress",
          "input textarea": "handleChanging",
          "change textarea": "handleChanged"
        };
      }
      /**
       * Handle key down
       *
       * Stop propagation so the event isn't sent to the application.
       */
      handleKeyDown(e4) {
        e4.stopPropagation();
      }
      /**
       * Handles key press
       *
       * Stop propagation so the keypress isn't sent to the application.
       */
      handleKeypress(e4) {
        e4.stopPropagation();
      }
      /**
       * Triggered on input change
       */
      handleChanging(e4) {
        if (this.model.get("continuous_update")) {
          this.handleChanged(e4);
        }
      }
      /**
       * Sync the value with the kernel.
       *
       * @param e Event
       */
      handleChanged(e4) {
        const target = e4.target;
        this.model.set("value", target.value, { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.textbox.focus();
        } else if (content.do === "blur") {
          this.textbox.blur();
        }
      }
    };
    TextModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "TextView", _model_name: "TextModel", continuous_update: true });
      }
    };
    TextView = class extends StringView {
      constructor() {
        super(...arguments);
        this.inputType = "text";
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-text");
        this.textbox = document.createElement("input");
        this.textbox.setAttribute("type", this.inputType);
        this.textbox.id = this.label.htmlFor = uuid();
        this.textbox.classList.add("widget-input");
        this.el.appendChild(this.textbox);
        this.update();
        this.listenTo(this.model, "change:placeholder", (model, value, options) => {
          this.update_placeholder(value);
        });
        this.update_placeholder();
        this.updateTabindex();
        this.updateTooltip();
      }
      update_placeholder(value) {
        this.textbox.setAttribute("placeholder", value || this.model.get("placeholder"));
      }
      updateTabindex() {
        if (!this.textbox) {
          return;
        }
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.textbox.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.textbox.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.textbox.removeAttribute("tabIndex");
        }
      }
      updateTooltip() {
        if (!this.textbox)
          return;
        const title = this.model.get("tooltip");
        if (!title) {
          this.textbox.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.textbox.setAttribute("title", title);
        }
      }
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          if (this.textbox.value !== this.model.get("value")) {
            this.textbox.value = this.model.get("value");
          }
          this.textbox.disabled = this.model.get("disabled");
        }
        return super.update();
      }
      events() {
        return {
          "keydown input": "handleKeyDown",
          "keypress input": "handleKeypress",
          "input input": "handleChanging",
          "change input": "handleChanged"
        };
      }
      /**
       * Handle key down
       *
       * Stop propagation so the keypress isn't sent to the application.
       */
      handleKeyDown(e4) {
        e4.stopPropagation();
      }
      /**
       * Handles text submission
       */
      handleKeypress(e4) {
        e4.stopPropagation();
        if (e4.keyCode === 13) {
          this.send({ event: "submit" });
        }
      }
      /**
       * Handles user input.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleChanging(e4) {
        if (this.model.get("continuous_update")) {
          this.handleChanged(e4);
        }
      }
      /**
       * Handles user input.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleChanged(e4) {
        const target = e4.target;
        this.model.set("value", target.value, { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.textbox.focus();
        } else if (content.do === "blur") {
          this.textbox.blur();
        }
      }
    };
    PasswordModel = class extends TextModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "PasswordView", _model_name: "PasswordModel" });
      }
    };
    PasswordView = class extends TextView {
      constructor() {
        super(...arguments);
        this.inputType = "password";
      }
    };
    ComboboxModel = class extends TextModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ComboboxModel", _view_name: "ComboboxView", options: [], ensure_options: false });
      }
    };
    ComboboxView = class extends TextView {
      constructor() {
        super(...arguments);
        this.isInitialRender = true;
      }
      render() {
        this.datalist = document.createElement("datalist");
        this.datalist.id = uuid();
        super.render();
        this.textbox.setAttribute("list", this.datalist.id);
        this.el.appendChild(this.datalist);
        this.updateTooltip();
      }
      update(options) {
        super.update(options);
        if (!this.datalist) {
          return;
        }
        const valid2 = this.isValid(this.model.get("value"));
        this.highlightValidState(valid2);
        if (options !== void 0 && options.updated_view || !this.model.hasChanged("options") && !this.isInitialRender) {
          return;
        }
        this.isInitialRender = false;
        const opts = this.model.get("options");
        const optionFragment = document.createDocumentFragment();
        for (const v2 of opts) {
          const o10 = document.createElement("option");
          o10.value = v2;
          optionFragment.appendChild(o10);
        }
        this.datalist.replaceChildren(...optionFragment.children);
      }
      isValid(value) {
        if (true === this.model.get("ensure_option")) {
          const options = this.model.get("options");
          if (options.indexOf(value) === -1) {
            return false;
          }
        }
        return true;
      }
      handleChanging(e4) {
        const target = e4.target;
        const valid2 = this.isValid(target.value);
        this.highlightValidState(valid2);
        if (valid2) {
          super.handleChanging(e4);
        }
      }
      handleChanged(e4) {
        const target = e4.target;
        const valid2 = this.isValid(target.value);
        this.highlightValidState(valid2);
        if (valid2) {
          super.handleChanged(e4);
        }
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.textbox.focus();
        } else if (content.do === "blur") {
          this.textbox.blur();
        }
      }
      highlightValidState(valid2) {
        this.textbox.classList.toggle(INVALID_VALUE_CLASS, !valid2);
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_upload.js
var FileUploadModel, FileUploadView;
var init_widget_upload = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_upload.js"() {
    init_widget_core();
    init_lib10();
    FileUploadModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FileUploadModel", _view_name: "FileUploadView", accept: "", description: "Upload", disabled: false, icon: "upload", button_style: "", multiple: false, value: [], error: "", style: null });
      }
    };
    FileUploadModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), {
      // use a dummy serializer for value to circumvent the default serializer.
      value: { serialize: (x4) => x4 }
    });
    FileUploadView = class extends DOMWidgetView {
      preinitialize() {
        this.tagName = "button";
      }
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-upload");
        this.el.classList.add("jupyter-button");
        this.fileInput = document.createElement("input");
        this.fileInput.type = "file";
        this.fileInput.style.display = "none";
        this.el.addEventListener("click", () => {
          this.fileInput.click();
        });
        this.fileInput.addEventListener("click", () => {
          this.fileInput.value = "";
        });
        this.fileInput.addEventListener("change", () => {
          var _a;
          const promisesFile = [];
          Array.from((_a = this.fileInput.files) !== null && _a !== void 0 ? _a : []).forEach((file) => {
            promisesFile.push(new Promise((resolve, reject4) => {
              const fileReader = new FileReader();
              fileReader.onload = () => {
                const content = fileReader.result;
                resolve({
                  content,
                  name: file.name,
                  type: file.type,
                  size: file.size,
                  last_modified: file.lastModified
                });
              };
              fileReader.onerror = () => {
                reject4();
              };
              fileReader.onabort = fileReader.onerror;
              fileReader.readAsArrayBuffer(file);
            }));
          });
          Promise.all(promisesFile).then((files) => {
            this.model.set({
              value: files,
              error: ""
            });
            this.touch();
          }).catch((err) => {
            console.error("error in file upload: %o", err);
            this.model.set({
              error: err
            });
            this.touch();
          });
        });
        this.listenTo(this.model, "change:button_style", this.update_button_style);
        this.set_button_style();
        this.update();
      }
      update() {
        this.el.disabled = this.model.get("disabled");
        this.el.setAttribute("title", this.model.get("tooltip"));
        const value = this.model.get("value");
        const description = `${this.model.get("description")} (${value.length})`;
        const icon = this.model.get("icon");
        if (description.length || icon.length) {
          this.el.textContent = "";
          if (icon.length) {
            const i5 = document.createElement("i");
            i5.classList.add("fa");
            i5.classList.add("fa-" + icon);
            if (description.length === 0) {
              i5.classList.add("center");
            }
            this.el.appendChild(i5);
          }
          this.el.appendChild(document.createTextNode(description));
        }
        this.fileInput.accept = this.model.get("accept");
        this.fileInput.multiple = this.model.get("multiple");
        return super.update();
      }
      update_button_style() {
        this.update_mapped_classes(FileUploadView.class_map, "button_style", this.el);
      }
      set_button_style() {
        this.set_mapped_classes(FileUploadView.class_map, "button_style", this.el);
      }
    };
    FileUploadView.class_map = {
      primary: ["mod-primary"],
      success: ["mod-success"],
      info: ["mod-info"],
      warning: ["mod-warning"],
      danger: ["mod-danger"]
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/package.json
var require_package = __commonJS({
  "../../node_modules/@jupyter-widgets/controls/package.json"(exports2, module2) {
    module2.exports = {
      name: "@jupyter-widgets/controls",
      version: "5.0.8",
      description: "Jupyter interactive widgets",
      repository: {
        type: "git",
        url: "https://github.com/jupyter-widgets/ipywidgets.git"
      },
      license: "BSD-3-Clause",
      author: "Project Jupyter",
      main: "lib/index.js",
      typings: "lib/index.d.ts",
      files: [
        "lib/**/*.d.ts",
        "lib/**/*.js",
        "css/*.css",
        "dist/"
      ],
      scripts: {
        build: "npm run build:src && npm run build:css",
        "build:css": "lessc css/nouislider.less css/nouislider.css && postcss --use postcss-import --use postcss-cssnext -o css/widgets.built.css css/widgets.css",
        "build:src": "tsc --build",
        "build:test": "tsc --build test && webpack --config test/webpack.conf.js",
        clean: "npm run clean:src",
        "clean:src": "rimraf lib && rimraf tsconfig.tsbuildinfo",
        prepublish: "npm run clean && npm run build",
        test: "npm run test:unit",
        "test:coverage": "npm run build:test && webpack --config test/webpack-cov.conf.js && karma start test/karma-cov.conf.js",
        "test:unit": "npm run test:unit:firefox && npm run test:unit:chrome",
        "test:unit:chrome": "npm run test:unit:default -- --browsers=Chrome",
        "test:unit:default": "npm run build:test && karma start test/karma.conf.js --log-level debug",
        "test:unit:firefox": "npm run test:unit:default -- --browsers=Firefox",
        "test:unit:firefox:headless": "npm run test:unit:default -- --browsers=FirefoxHeadless",
        "test:unit:ie": "npm run test:unit:default -- --browsers=IE"
      },
      dependencies: {
        "@jupyter-widgets/base": "^6.0.7",
        "@lumino/algorithm": "^1.9.1 || ^2.1",
        "@lumino/domutils": "^1.8.1 || ^2.1",
        "@lumino/messaging": "^1.10.1 || ^2.1",
        "@lumino/signaling": "^1.10.1 || ^2.1",
        "@lumino/widgets": "^1.30.0 || ^2.1",
        "d3-color": "^3.0.1",
        "d3-format": "^3.0.1",
        jquery: "^3.1.1",
        nouislider: "15.4.0"
      },
      devDependencies: {
        "@jupyterlab/services": "^6.0.0 || ^7.0.0",
        "@types/d3-color": "^3.0.2",
        "@types/d3-format": "^3.0.1",
        "@types/expect.js": "^0.3.29",
        "@types/jquery": "^3.5.16",
        "@types/mathjax": "^0.0.37",
        "@types/mocha": "^9.0.0",
        "@types/node": "^17.0.2",
        chai: "^4.0.0",
        "css-loader": "^6.5.1",
        "expect.js": "^0.3.1",
        "istanbul-instrumenter-loader": "^3.0.1",
        karma: "^6.3.3",
        "karma-chrome-launcher": "^3.1.0",
        "karma-coverage": "^2.0.3",
        "karma-firefox-launcher": "^2.1.1",
        "karma-ie-launcher": "^1.0.0",
        "karma-mocha": "^2.0.1",
        "karma-mocha-reporter": "^2.2.5",
        "karma-webpack": "^5.0.0",
        less: "^4.1.2",
        mocha: "^9.0.0",
        "npm-run-all": "^4.1.5",
        postcss: "^8.3.2",
        "postcss-cli": "^9.1.0",
        "postcss-cssnext": "^3.1.0",
        "postcss-import": "^14.0.2",
        "postcss-loader": "^6.1.0",
        rimraf: "^3.0.2",
        sinon: "^12.0.1",
        "sinon-chai": "^3.3.0",
        "style-loader": "^3.3.1",
        typescript: "~4.9.4",
        webpack: "^5.65.0"
      },
      gitHead: "e6ec1be15e75f57fb354a0dbc98f8d8857cfd645"
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/index.js
var lib_exports5 = {};
__export(lib_exports5, {
  AccordionModel: () => AccordionModel,
  AccordionView: () => AccordionView,
  AudioModel: () => AudioModel,
  AudioView: () => AudioView,
  BaseIntSliderView: () => BaseIntSliderView,
  BoolModel: () => BoolModel,
  BoundedFloatModel: () => BoundedFloatModel,
  BoundedFloatTextModel: () => BoundedFloatTextModel,
  BoundedIntModel: () => BoundedIntModel,
  BoundedIntTextModel: () => BoundedIntTextModel,
  BoxModel: () => BoxModel,
  BoxView: () => BoxView,
  ButtonModel: () => ButtonModel,
  ButtonStyleModel: () => ButtonStyleModel,
  ButtonView: () => ButtonView,
  CheckboxModel: () => CheckboxModel,
  CheckboxStyleModel: () => CheckboxStyleModel,
  CheckboxView: () => CheckboxView,
  ColorPickerModel: () => ColorPickerModel,
  ColorPickerView: () => ColorPickerView,
  ColorsInputModel: () => ColorsInputModel,
  ColorsInputView: () => ColorsInputView,
  ComboboxModel: () => ComboboxModel,
  ComboboxView: () => ComboboxView,
  ControllerAxisModel: () => ControllerAxisModel,
  ControllerAxisView: () => ControllerAxisView,
  ControllerButtonModel: () => ControllerButtonModel,
  ControllerButtonView: () => ControllerButtonView,
  ControllerModel: () => ControllerModel,
  ControllerView: () => ControllerView,
  DatePickerModel: () => DatePickerModel,
  DatePickerView: () => DatePickerView,
  DatetimeModel: () => DatetimeModel,
  DatetimeView: () => DatetimeView,
  DescriptionModel: () => DescriptionModel,
  DescriptionStyleModel: () => DescriptionStyleModel,
  DescriptionView: () => DescriptionView,
  DirectionalLinkModel: () => DirectionalLinkModel,
  DropdownModel: () => DropdownModel,
  DropdownView: () => DropdownView,
  FileUploadModel: () => FileUploadModel,
  FileUploadView: () => FileUploadView,
  FloatLogSliderModel: () => FloatLogSliderModel,
  FloatLogSliderView: () => FloatLogSliderView,
  FloatModel: () => FloatModel,
  FloatProgressModel: () => FloatProgressModel,
  FloatRangeSliderModel: () => FloatRangeSliderModel,
  FloatRangeSliderView: () => FloatRangeSliderView,
  FloatSliderModel: () => FloatSliderModel,
  FloatSliderView: () => FloatSliderView,
  FloatTextModel: () => FloatTextModel,
  FloatTextView: () => FloatTextView,
  FloatsInputModel: () => FloatsInputModel,
  FloatsInputView: () => FloatsInputView,
  GridBoxModel: () => GridBoxModel,
  GridBoxView: () => GridBoxView,
  HBoxModel: () => HBoxModel,
  HBoxView: () => HBoxView,
  HTMLMathModel: () => HTMLMathModel,
  HTMLMathStyleModel: () => HTMLMathStyleModel,
  HTMLMathView: () => HTMLMathView,
  HTMLModel: () => HTMLModel,
  HTMLStyleModel: () => HTMLStyleModel,
  HTMLView: () => HTMLView,
  ImageModel: () => ImageModel,
  ImageView: () => ImageView,
  IntModel: () => IntModel,
  IntProgressModel: () => IntProgressModel,
  IntRangeSliderModel: () => IntRangeSliderModel,
  IntRangeSliderView: () => IntRangeSliderView,
  IntSliderModel: () => IntSliderModel,
  IntSliderView: () => IntSliderView,
  IntTextModel: () => IntTextModel,
  IntTextView: () => IntTextView,
  IntsInputModel: () => IntsInputModel,
  IntsInputView: () => IntsInputView,
  JUPYTER_CONTROLS_VERSION: () => JUPYTER_CONTROLS_VERSION,
  JupyterLuminoAccordionWidget: () => JupyterLuminoAccordionWidget,
  JupyterLuminoTabPanelWidget: () => JupyterLuminoTabPanelWidget,
  LabelModel: () => LabelModel,
  LabelStyleModel: () => LabelStyleModel,
  LabelView: () => LabelView,
  LabeledDOMWidgetModel: () => LabeledDOMWidgetModel,
  LabeledDOMWidgetView: () => LabeledDOMWidgetView,
  LinkModel: () => LinkModel,
  MultipleSelectionModel: () => MultipleSelectionModel,
  NaiveDatetimeModel: () => NaiveDatetimeModel,
  PasswordModel: () => PasswordModel,
  PasswordView: () => PasswordView,
  PlayModel: () => PlayModel,
  PlayView: () => PlayView,
  ProgressStyleModel: () => ProgressStyleModel,
  ProgressView: () => ProgressView,
  RadioButtonsModel: () => RadioButtonsModel,
  RadioButtonsView: () => RadioButtonsView,
  SelectModel: () => SelectModel,
  SelectMultipleModel: () => SelectMultipleModel,
  SelectMultipleView: () => SelectMultipleView,
  SelectView: () => SelectView,
  SelectionContainerModel: () => SelectionContainerModel,
  SelectionModel: () => SelectionModel,
  SelectionRangeSliderModel: () => SelectionRangeSliderModel,
  SelectionRangeSliderView: () => SelectionRangeSliderView,
  SelectionSliderModel: () => SelectionSliderModel,
  SelectionSliderView: () => SelectionSliderView,
  SelectionView: () => SelectionView,
  SliderStyleModel: () => SliderStyleModel,
  StackModel: () => StackModel,
  StackView: () => StackView,
  StringModel: () => StringModel,
  StringView: () => StringView,
  TabModel: () => TabModel,
  TabView: () => TabView,
  TagsInputModel: () => TagsInputModel,
  TagsInputView: () => TagsInputView,
  TextModel: () => TextModel,
  TextStyleModel: () => TextStyleModel,
  TextView: () => TextView,
  TextareaModel: () => TextareaModel,
  TextareaView: () => TextareaView,
  TimeModel: () => TimeModel,
  TimeView: () => TimeView,
  ToggleButtonModel: () => ToggleButtonModel,
  ToggleButtonStyleModel: () => ToggleButtonStyleModel,
  ToggleButtonView: () => ToggleButtonView,
  ToggleButtonsModel: () => ToggleButtonsModel,
  ToggleButtonsStyleModel: () => ToggleButtonsStyleModel,
  ToggleButtonsView: () => ToggleButtonsView,
  VBoxModel: () => VBoxModel,
  VBoxView: () => VBoxView,
  ValidModel: () => ValidModel,
  ValidView: () => ValidView,
  VideoModel: () => VideoModel,
  VideoView: () => VideoView,
  datetime_serializers: () => datetime_serializers,
  deserialize_date: () => deserialize_date,
  deserialize_datetime: () => deserialize_datetime,
  deserialize_naive: () => deserialize_naive,
  deserialize_time: () => deserialize_time,
  escape_html: () => escape_html,
  naive_serializers: () => naive_serializers,
  reject: () => reject3,
  resolvePromisesDict: () => resolvePromisesDict,
  serialize_date: () => serialize_date,
  serialize_datetime: () => serialize_datetime,
  serialize_naive: () => serialize_naive,
  serialize_time: () => serialize_time,
  time_serializers: () => time_serializers,
  typeset: () => typeset,
  uuid: () => uuid,
  version: () => version
});
var version;
var init_lib14 = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/index.js"() {
    init_utils3();
    init_version2();
    init_widget_link();
    init_widget_bool();
    init_widget_button();
    init_widget_box();
    init_widget_image();
    init_widget_video();
    init_widget_audio();
    init_widget_color();
    init_widget_date();
    init_widget_datetime();
    init_widget_time();
    init_widget_int();
    init_widget_float();
    init_widget_controller();
    init_widget_selection();
    init_widget_selectioncontainer();
    init_widget_tagsinput();
    init_widget_string();
    init_widget_description();
    init_widget_upload();
    version = require_package().version;
  }
});

// ../../node_modules/thebe-core/node_modules/nanoid/url-alphabet/index.js
var init_url_alphabet = __esm({
  "../../node_modules/thebe-core/node_modules/nanoid/url-alphabet/index.js"() {
  }
});

// ../../node_modules/thebe-core/node_modules/nanoid/index.browser.js
var random2, customRandom, customAlphabet;
var init_index_browser = __esm({
  "../../node_modules/thebe-core/node_modules/nanoid/index.browser.js"() {
    init_url_alphabet();
    random2 = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
    customRandom = (alphabet, defaultSize, getRandom) => {
      let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
      let step = -~(1.6 * mask * defaultSize / alphabet.length);
      return (size3 = defaultSize) => {
        let id = "";
        while (true) {
          let bytes = getRandom(step);
          let j2 = step;
          while (j2--) {
            id += alphabet[bytes[j2] & mask] || "";
            if (id.length === size3)
              return id;
          }
        }
      };
    };
    customAlphabet = (alphabet, size3 = 21) => customRandom(alphabet, size3, random2);
  }
});

// ../../node_modules/thebe-core/dist/esm/utils.js
function shortId() {
  return nanoid();
}
function ensureString2(maybeString) {
  if (Array.isArray(maybeString))
    return maybeString.join("\n");
  return maybeString;
}
function isMimeBundle({ output_type }) {
  return output_type === "display_data" || output_type === "execute_result";
}
function placeholder(plainText) {
  return `
<div class="thebe-ipywidgets-placeholder">
  <div class="thebe-ipywidgets-placeholder-image"></div>
  <div class="thebe-ipywidgets-placeholder-message"><code>ipywidgets</code> - a Jupyter kernel connection is required to fully display this output.</div>
  ${plainText && `<pre>${plainText}</pre>`}
</div>
`;
}
function stripWidgets(outputs, hideWidgets = true, placeholderFn = placeholder) {
  return outputs.map((output) => {
    if (!isMimeBundle(output))
      return output;
    const _a = output.data, _b = WIDGET_MIMETYPE, widgets = _a[_b], others = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
    if (!widgets)
      return output;
    let data = output.data;
    if (hideWidgets)
      data = Object.assign({}, others);
    if (placeholderFn && !("text/html" in data))
      data["text/html"] = placeholderFn(ensureString2(data["text/plain"]));
    const stripped = Object.assign(Object.assign({}, output), { data });
    return stripped;
  });
}
var nanoid;
var init_utils4 = __esm({
  "../../node_modules/thebe-core/dist/esm/utils.js"() {
    init_tslib_es6();
    init_index_browser();
    init_manager3();
    nanoid = customAlphabet("1234567890abcdef", 8);
  }
});

// ../../node_modules/thebe-core/dist/esm/requireJsLoader.js
function fetchAndLoadInFrame(baseUrl) {
  return __awaiter(this, void 0, void 0, function* () {
    if (typeof document === "undefined")
      throw new Error("Cannot load requirejs outside of the browser");
    const res = yield fetch(REQUIREJS_URL);
    if (!res.ok) {
      throw new Error(`Could not fetch requirejs ${res.status} ${res.statusText}`);
    }
    const requireJsSource = yield res.text();
    return new Promise((resolve, reject4) => {
      const iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.onload = () => {
        const contentWindow = iframe.contentWindow;
        if (!contentWindow)
          return reject4("Cannot load in isolated: no contentWindow, origin error?");
        contentWindow.window.eval(requireJsSource);
        const requirejs2 = {
          require: contentWindow.window.require,
          define: contentWindow.window.define
        };
        if (!requirejs2.require || !requirejs2.define)
          return reject4("Require.js loading did not result in `require` and `define` objects attachment to window");
        requirejs2.require.config({ baseUrl });
        resolve(requirejs2);
        iframe.onload = null;
      };
      document.body.appendChild(iframe);
    });
  });
}
var REQUIREJS_CDN_URL, REQUIREJS_URL, RequireJsLoader;
var init_requireJsLoader = __esm({
  "../../node_modules/thebe-core/dist/esm/requireJsLoader.js"() {
    init_tslib_es6();
    REQUIREJS_CDN_URL = "https://cdn.jsdelivr.net/npm/";
    REQUIREJS_URL = "https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js";
    RequireJsLoader = class {
      constructor(baseUrl) {
        this.baseUrl = baseUrl !== null && baseUrl !== void 0 ? baseUrl : REQUIREJS_CDN_URL;
        this.requested = false;
        this.resolveFn = () => ({});
        this.ready = new Promise((resolve) => this.resolveFn = resolve);
      }
      load(postLoadFn) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.requested) {
            this.requested = true;
            this.requirejs = yield fetchAndLoadInFrame(this.baseUrl);
            yield postLoadFn === null || postLoadFn === void 0 ? void 0 : postLoadFn(this.requirejs.require, this.requirejs.define);
            this.resolveFn(this.requirejs);
          }
          return this.ready;
        });
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/loader.js
function requirePromise(requirejs2, moduleName) {
  return new Promise((resolve, reject4) => requirejs2.require([`${moduleName}`], resolve, reject4));
}
function moduleNameToCDNUrl(moduleName, moduleVersion) {
  let packageName = moduleName;
  let fileName = "index";
  let index2 = moduleName.indexOf("/");
  if (index2 !== -1 && moduleName[0] === "@") {
    index2 = moduleName.indexOf("/", index2 + 1);
  }
  if (index2 !== -1) {
    fileName = moduleName.substr(index2 + 1);
    packageName = moduleName.substr(0, index2);
  }
  return `${cdn}${packageName}@${moduleVersion}/dist/${fileName}`;
}
function requireFromCDN(requirejs2, moduleName, moduleVersion) {
  return __awaiter(this, void 0, void 0, function* () {
    const url = moduleNameToCDNUrl(moduleName, moduleVersion);
    const conf = { paths: {} };
    conf.paths[moduleName] = url;
    requirejs2.require.config(conf);
    try {
      const module2 = yield requirePromise(requirejs2, moduleName);
      return module2;
    } catch (err) {
      console.error(`thebe:loader requirejs error on cdn require`, err);
      throw err;
    }
  });
}
function requireLoader(requirejs2, moduleName, moduleVersion, useCDNOnly = false) {
  return __awaiter(this, void 0, void 0, function* () {
    console.debug(`thebe:loader loading ${moduleName}@${moduleVersion}`);
    if (useCDNOnly) {
      return requireFromCDN(requirejs2, moduleName, moduleVersion);
    } else {
      if (requirejs2.require.defined(moduleName)) {
        return requirePromise(requirejs2, moduleName);
      }
      console.debug(`thebe:loader falling back to ${cdn} for ${moduleName}@${moduleVersion}`);
      return requireFromCDN(requirejs2, moduleName, moduleVersion);
    }
  });
}
var cdn;
var init_loader = __esm({
  "../../node_modules/thebe-core/dist/esm/loader.js"() {
    init_tslib_es6();
    cdn = "https://cdn.jsdelivr.net/npm/";
  }
});

// ../../node_modules/thebe-core/dist/esm/manager.js
var WIDGET_MIMETYPE, ThebeManager;
var init_manager3 = __esm({
  "../../node_modules/thebe-core/dist/esm/manager.js"() {
    init_tslib_es6();
    init_index_es64();
    init_index_es66();
    init_lib13();
    init_lib10();
    init_lib14();
    init_utils4();
    init_requireJsLoader();
    init_loader();
    WIDGET_MIMETYPE = "application/vnd.jupyter.widget-view+json";
    ThebeManager = class extends KernelWidgetManager {
      constructor(kernel, rendermime) {
        super(kernel, rendermime);
        this.id = shortId();
        this.addWidgetFactories();
        this._registerWidgets();
        this._loader = new RequireJsLoader();
      }
      addWidgetFactories() {
        this.rendermime.addFactory({
          safe: false,
          mimeTypes: [WIDGET_MIMETYPE],
          createRenderer: (options) => new WidgetRenderer(options, this)
        }, 1);
      }
      removeWidgetFactories() {
        this.rendermime.removeMimeType(WIDGET_MIMETYPE);
      }
      /**
       * TODO implement a reasonable method for thebe-core that can load serialized widget state
       * see: https://github.dev/voila-dashboards/voila/blob/7090eb3e30c0c4aa25c2b7d5d2d45e8de1333b3b/packages/voila/src/manager.ts#L52
       *
       */
      build_widgets() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("ThebeManager:build_widgets not implmented");
        });
      }
      display_view(msg, view, options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (options.el) {
            Widget.attach(view.luminoWidget, options.el);
          }
          if (view.el) {
            view.el.setAttribute("data-thebe-jupyter-widget", "");
            view.el.addEventListener("jupyterWidgetResize", () => {
              MessageLoop.postMessage(view.luminoWidget, Widget.ResizeMessage.UnknownSize);
            });
          }
          return view.luminoWidget;
        });
      }
      loadClass(className, moduleName, moduleVersion) {
        const _super = Object.create(null, {
          loadClass: { get: () => super.loadClass }
        });
        return __awaiter(this, void 0, void 0, function* () {
          if (!this._loader.requested) {
            console.debug(`thebe:manager:loadClass initial requirejs load ${this.id}`);
            this._loader.load((require2, define2) => {
              define2("@jupyter-widgets/base", lib_exports3);
              define2("@jupyter-widgets/controls", lib_exports5);
              define2("@jupyter-widgets/output", output_exports);
            });
          }
          console.debug(`thebe:manager:loadClass ${moduleName}@${moduleVersion}`);
          const rjs = yield this._loader.ready;
          if (moduleName === "@jupyter-widgets/base" || moduleName === "@jupyter-widgets/controls" || moduleName === "@jupyter-widgets/output") {
            return _super.loadClass.call(this, className, moduleName, moduleVersion);
          } else {
            let mod;
            try {
              mod = yield requireLoader(rjs, moduleName, moduleVersion);
            } catch (err) {
              console.error(`thebe:manager:loadClass loader error`, err);
              throw err;
            }
            if (mod[className]) {
              return mod[className];
            } else {
              console.error(`thebe:manager:loadClass ${className} not found in module ${moduleName}@${moduleVersion}`);
              throw new Error(`Class ${className} not found in module ${moduleName}@${moduleVersion}`);
            }
          }
        });
      }
      _registerWidgets() {
        this.register({
          name: "@jupyter-widgets/base",
          version: JUPYTER_WIDGETS_VERSION,
          exports: lib_exports3
          // TODO improve typing
        });
        this.register({
          name: "@jupyter-widgets/controls",
          version: JUPYTER_CONTROLS_VERSION,
          exports: lib_exports5
          // TODO improve typing
        });
        this.register({
          name: "@jupyter-widgets/output",
          version: output_exports.OUTPUT_WIDGET_VERSION,
          exports: output_exports
        });
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/emitter.js
var EventEmitter;
var init_emitter = __esm({
  "../../node_modules/thebe-core/dist/esm/emitter.js"() {
    init_events();
    EventEmitter = class {
      constructor(id, config, subject, object2) {
        this._id = id;
        this._config = config;
        this._subject = subject;
        this._object = object2;
      }
      triggerStatus({ status, message }) {
        console.debug(`${status} ${message}`);
        this._config.events.trigger(ThebeEventType.status, {
          subject: this._subject,
          id: this._id,
          object: this._object,
          status,
          message
        });
      }
      triggerError({ status, message }) {
        console.debug(`Error [${this._subject}][${this._id}] ${message}`);
        this._config.events.trigger(ThebeEventType.error, {
          subject: this._subject,
          id: this._id,
          object: this._object,
          status,
          message
        });
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/session.js
var ThebeSession, session_default;
var init_session = __esm({
  "../../node_modules/thebe-core/dist/esm/session.js"() {
    init_tslib_es6();
    init_events();
    init_manager3();
    init_emitter();
    ThebeSession = class {
      constructor(server, connection, rendermime) {
        var _a;
        this.server = server;
        this.connection = connection;
        this.events = new EventEmitter(this.connection.id, server.config, EventSubject.session, this);
        if (this.connection.kernel == null)
          throw Error("ThebeSession - kernel is null");
        this.manager = new ThebeManager(this.connection.kernel, rendermime);
        this.connection.statusChanged.connect((_5, s7) => {
          let status;
          switch (s7) {
            case "starting":
            case "restarting":
            case "autorestarting":
              status = SessionStatusEvent.starting;
              break;
            case "idle":
            case "busy":
              status = SessionStatusEvent.ready;
              break;
            case "terminating":
            case "dead":
            default:
              status = SessionStatusEvent.shutdown;
              break;
          }
          this.events.triggerStatus({
            status,
            message: `kernel ${this.connection.name} status changed to ${status}[${s7}]`
          });
          if (s7 === "dead") {
            this.events.triggerError({
              status: ErrorStatusEvent.session,
              message: `kernel ${this.connection.name} is dead`
            });
            this.dispose();
          }
        });
        this.connection.disposed.connect(() => {
          this.events.triggerStatus({
            status: SessionStatusEvent.shutdown,
            message: `kernel ${this.connection.name} disposed`
          });
        });
        this.events.triggerStatus({
          status: SessionStatusEvent.ready,
          message: `ThebeSession created, kernel '${(_a = this.connection.kernel) === null || _a === void 0 ? void 0 : _a.name}' available`
        });
      }
      get id() {
        return this.connection.id;
      }
      get kernel() {
        var _a;
        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.kernel;
      }
      get path() {
        return this.connection.path;
      }
      get name() {
        return this.connection.name;
      }
      restart() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          console.debug(`requesting restart for kernel ${this.id}`);
          const p3 = (_a = this.connection.kernel) === null || _a === void 0 ? void 0 : _a.restart();
          this.events.triggerStatus({
            status: SessionStatusEvent.starting,
            message: `Kernel restart requested`
          });
          yield p3;
          this.events.triggerStatus({
            status: SessionStatusEvent.ready,
            message: `session restarted, kernel '${(_b = this.connection.kernel) === null || _b === void 0 ? void 0 : _b.name}' available`
          });
        });
      }
      shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.connection.isDisposed)
            return;
          yield this.connection.shutdown();
          this.events.triggerStatus({
            status: SessionStatusEvent.shutdown,
            message: `session ${this.name}`
          });
          this.dispose();
        });
      }
      dispose() {
        if (!this.connection.isDisposed)
          this.connection.dispose();
      }
    };
    session_default = ThebeSession;
  }
});

// ../../node_modules/thebe-core/dist/esm/server.js
function responseToJson(res) {
  return __awaiter(this, void 0, void 0, function* () {
    if (!res.ok)
      throw Error(`${res.status} - ${res.statusText}`);
    const json2 = yield res.json();
    return json2;
  });
}
function errorAsString(errorLike) {
  if (typeof errorLike === "string")
    return errorLike;
  if (errorLike.message)
    return errorLike.message;
  if (errorLike.status && errorLike.statusText)
    return `${errorLike.status} - ${errorLike.statusText}`;
  return JSON.stringify(errorLike);
}
var import_services3, ThebeServer, server_default;
var init_server = __esm({
  "../../node_modules/thebe-core/dist/esm/server.js"() {
    init_tslib_es6();
    init_url();
    init_sessions();
    import_services3 = __toESM(require_lib4());
    init_session();
    init_utils4();
    init_events();
    init_emitter();
    ThebeServer = class {
      constructor(config) {
        this.id = shortId();
        this.config = config;
        this.events = new EventEmitter(this.id, config, EventSubject.server, this);
        this.ready = new Promise((resolve, reject4) => {
          this.resolveReadyFn = resolve;
          this.rejectReadyFn = reject4;
        });
        this._isDisposed = false;
      }
      get isBinder() {
        return !!this.binderUrls;
      }
      get isReady() {
        var _a, _b;
        return (_b = (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.isReady) !== null && _b !== void 0 ? _b : false;
      }
      get isDisposed() {
        return this._isDisposed;
      }
      get settings() {
        var _a;
        return (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.serverSettings;
      }
      shutdownSession(id) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          return (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.shutdown(id);
        });
      }
      shutdownAllSessions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          return (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.shutdownAll();
        });
      }
      check() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const resp = yield ThebeServer.status((_b = (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.serverSettings) !== null && _b !== void 0 ? _b : this.config.serverSettings);
          return resp.ok;
        });
      }
      dispose() {
        var _a, _b, _c, _d;
        if (this._isDisposed)
          return;
        if (!((_a = this.serviceManager) === null || _a === void 0 ? void 0 : _a.isDisposed))
          (_b = this.serviceManager) === null || _b === void 0 ? void 0 : _b.dispose();
        if (!((_c = this.sessionManager) === null || _c === void 0 ? void 0 : _c.isDisposed))
          (_d = this.sessionManager) === null || _d === void 0 ? void 0 : _d.dispose();
        this._isDisposed = true;
      }
      startNewSession(rendermime, kernelOptions) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.ready;
          if (!this.sessionManager) {
            throw Error("Requesting session from a server, with no SessionManager available");
          }
          yield this.sessionManager.ready;
          const path2 = (_a = kernelOptions === null || kernelOptions === void 0 ? void 0 : kernelOptions.path) !== null && _a !== void 0 ? _a : this.config.kernels.path;
          let name2 = "thebe.ipynb";
          const match = path2.match(/\/*([a-zA-Z0-9-]+.ipynb)$/);
          if (match) {
            name2 = match[1];
          }
          const connection = yield (_b = this.sessionManager) === null || _b === void 0 ? void 0 : _b.startNew({
            name: name2,
            path: path2,
            type: "notebook",
            kernel: {
              name: (_c = kernelOptions === null || kernelOptions === void 0 ? void 0 : kernelOptions.kernelName) !== null && _c !== void 0 ? _c : this.config.kernels.kernelName
            }
          });
          return new session_default(this, connection, rendermime);
        });
      }
      listRunningSessions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.ready;
          const iter = (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.running();
          const models = [];
          let result2 = iter === null || iter === void 0 ? void 0 : iter.next();
          while (result2 && !result2.done) {
            models.push(result2.value);
            result2 = iter === null || iter === void 0 ? void 0 : iter.next();
          }
          return models;
        });
      }
      refreshRunningSessions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.ready;
          yield (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.refreshRunning();
          return this.listRunningSessions();
        });
      }
      connectToExistingSession(model, rendermime) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.ready;
          if (!this.sessionManager) {
            throw Error("Requesting session from a server, with no SessionManager available");
          }
          yield this.sessionManager.ready;
          const connection = (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.connectTo({ model });
          return new session_default(this, connection, rendermime);
        });
      }
      clearSavedBinderSessions() {
        return __awaiter(this, void 0, void 0, function* () {
          const urls = this.makeBinderUrls();
          window.localStorage.removeItem(urls.storageKey);
        });
      }
      /**
       * Connect to a Jupyter server directly
       *
       */
      connectToJupyterServer() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          console.debug("thebe:api:connectToJupyterServer:serverSettings:", this.config.serverSettings);
          const serverSettings = import_services3.ServerConnection.makeSettings(this.config.serverSettings);
          try {
            this.events.triggerStatus({
              status: ServerStatusEvent.launching,
              message: `Checking server url`
            });
            yield ThebeServer.status(serverSettings);
            this.events.triggerStatus({
              status: ServerStatusEvent.launching,
              message: `Server reachable`
            });
          } catch (err) {
            const message = `Server not reachable (${serverSettings.baseUrl}) - ${err}`;
            this.events.triggerError({
              status: ErrorStatusEvent.error,
              message
            });
            (_a = this.rejectReadyFn) === null || _a === void 0 ? void 0 : _a.call(this, message);
            return;
          }
          const kernelManager = new import_services3.KernelManager({ serverSettings });
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Created KernelManager`
          });
          this.sessionManager = new import_services3.SessionManager({
            kernelManager,
            serverSettings
          });
          this.sessionManager.connectionFailure.connect((_5, err) => {
            this.events.triggerError({
              status: ErrorStatusEvent.server,
              message: `connection failure: ${err}`
            });
          });
          this.sessionManager.runningChanged.connect((_5, models) => {
            this.events.triggerStatus({
              status: ServerStatusEvent.ready,
              message: `${models.length} running sessions changed: ${models.map((m4) => m4.name).join(",")}`
            });
          });
          this.events.triggerStatus({
            status: ServerStatusEvent.ready,
            message: `Created SessionManager`
          });
          return this.sessionManager.ready.then(() => {
            var _a2;
            this.userServerUrl = `${serverSettings.baseUrl}?token=${serverSettings.token}`;
            this.events.triggerStatus({
              status: ServerStatusEvent.ready,
              message: `Server connection ready`
            });
            (_a2 = this.resolveReadyFn) === null || _a2 === void 0 ? void 0 : _a2.call(this, this);
          }, (err) => {
            var _a2;
            return (_a2 = this.rejectReadyFn) === null || _a2 === void 0 ? void 0 : _a2.call(this, errorAsString(err));
          });
        });
      }
      /**
       * Connect to Jupyterlite Server
       */
      connectToJupyterLiteServer(config) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Connecting to JupyterLite`
          });
          if (!window.thebeLite)
            throw new Error(`thebe-lite is not available at window.thebeLite - load this onto your page before loading thebe or thebe-core.`);
          const serviceManager = yield window.thebeLite.startJupyterLiteServer(config);
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Started JupyterLite server`
          });
          console.debug("thebe:api:connectToJupyterLiteServer:serverSettings:", serviceManager.serverSettings);
          this.sessionManager = serviceManager.sessions;
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Received SessionMananger from JupyterLite`
          });
          return (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.ready.then(() => {
            var _a2;
            this.userServerUrl = `${serviceManager.serverSettings.baseUrl}?token=${serviceManager.serverSettings.token}`;
            this.events.triggerStatus({
              status: ServerStatusEvent.ready,
              message: `Server connection established`
            });
            (_a2 = this.resolveReadyFn) === null || _a2 === void 0 ? void 0 : _a2.call(this, this);
          }, (err) => {
            var _a2;
            return (_a2 = this.rejectReadyFn) === null || _a2 === void 0 ? void 0 : _a2.call(this, errorAsString(err));
          });
        });
      }
      makeBinderUrls() {
        var _a;
        return makeBinderUrls(this.config, (_a = this.repoProviders) !== null && _a !== void 0 ? _a : WELL_KNOWN_REPO_PROVIDERS);
      }
      checkForSavedBinderSession() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const { storageKey } = makeBinderUrls(this.config, (_a = this.repoProviders) !== null && _a !== void 0 ? _a : WELL_KNOWN_REPO_PROVIDERS);
            return getExistingServer(this.config.savedSessions, storageKey);
          } catch (err) {
            this.events.triggerError({
              status: ErrorStatusEvent.error,
              message: `${err} - Failed to check for saved session.`
            });
            return null;
          }
        });
      }
      /**
       * Connect to a Binder instance in order to
       * access a Jupyter server that can provide kernels
       *
       * @param ctx
       * @param opts
       * @returns
       */
      connectToServerViaBinder(customProviders) {
        return __awaiter(this, void 0, void 0, function* () {
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Connecting to binderhub at ${this.config.binder.binderUrl}`
          });
          this.repoProviders = [...WELL_KNOWN_REPO_PROVIDERS, ...customProviders !== null && customProviders !== void 0 ? customProviders : []];
          try {
            this.binderUrls = makeBinderUrls(this.config, this.repoProviders);
          } catch (err) {
            this.events.triggerError({
              status: ErrorStatusEvent.error,
              message: `${err} - Failed to connect to binderhub at ${this.config.binder.binderUrl}`
            });
            return;
          }
          const urls = this.binderUrls;
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Binder build url is ${urls.build}`
          });
          if (this.config.savedSessions.enabled) {
            console.debug("thebe:server:connectToServerViaBinder Checking for saved session...");
            const existingSettings = yield this.checkForSavedBinderSession();
            if (existingSettings) {
              const serverSettings = import_services3.ServerConnection.makeSettings(existingSettings);
              const kernelManager = new import_services3.KernelManager({ serverSettings });
              this.events.triggerStatus({
                status: ServerStatusEvent.launching,
                message: `Created KernelManager`
              });
              this.sessionManager = new import_services3.SessionManager({
                kernelManager,
                serverSettings
              });
              this.events.triggerStatus({
                status: ServerStatusEvent.launching,
                message: `Created KernelManager`
              });
              return this.sessionManager.ready.then(() => {
                var _a;
                this.userServerUrl = `${serverSettings.baseUrl}?token=${serverSettings.token}`;
                this.events.triggerStatus({
                  status: ServerStatusEvent.ready,
                  message: `Re-connected to binder server`
                });
                (_a = this.resolveReadyFn) === null || _a === void 0 ? void 0 : _a.call(this, this);
              }, (err) => {
                var _a;
                return (_a = this.rejectReadyFn) === null || _a === void 0 ? void 0 : _a.call(this, errorAsString(err));
              });
            }
          }
          const state = {
            status: ServerStatusEvent.launching
          };
          const es = new EventSource(urls.build);
          this.events.triggerStatus({
            status: state.status,
            message: `Opened connection to binder: ${urls.build}`
          });
          es.onerror = (evt) => {
            var _a;
            console.error(`Lost connection to binder: ${urls.build}`, evt);
            es === null || es === void 0 ? void 0 : es.close();
            state.status = ErrorStatusEvent.error;
            const data = evt === null || evt === void 0 ? void 0 : evt.data;
            const phase = data ? data.phase : "unknown";
            const message = `Lost connection to binder: ${urls.build}
phase: ${phase} - ${data ? data.message : "no message"}`;
            this.events.triggerError({
              status: ErrorStatusEvent.error,
              message
            });
            (_a = this.rejectReadyFn) === null || _a === void 0 ? void 0 : _a.call(this, message);
          };
          es.onmessage = (evt) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const msg = JSON.parse(evt.data);
            const phase = (_b = (_a = msg.phase) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : "";
            switch (phase) {
              case "failed":
                es === null || es === void 0 ? void 0 : es.close();
                state.status = ErrorStatusEvent.error;
                this.events.triggerError({
                  status: ErrorStatusEvent.error,
                  message: `Binder: failed to build - ${urls.build} - ${msg.message}`
                });
                (_c = this.rejectReadyFn) === null || _c === void 0 ? void 0 : _c.call(this, msg.message);
                break;
              case "ready":
                {
                  es === null || es === void 0 ? void 0 : es.close();
                  const settings = {
                    baseUrl: msg.url,
                    wsUrl: "ws" + msg.url.slice(4),
                    token: msg.token,
                    appendToken: true
                  };
                  const serverSettings = import_services3.ServerConnection.makeSettings(settings);
                  const kernelManager = new import_services3.KernelManager({ serverSettings });
                  this.sessionManager = new import_services3.SessionManager({
                    kernelManager,
                    serverSettings
                  });
                  if (this.config.savedSessions.enabled) {
                    saveServerInfo(urls.storageKey, this.id, serverSettings);
                    console.debug(`thebe:server:connectToServerViaBinder Saved session for ${this.id} at ${urls.build}`);
                  }
                  yield this.sessionManager.ready;
                  this.userServerUrl = `${msg.url}?token=${msg.token}`;
                  state.status = ServerStatusEvent.ready;
                  this.events.triggerStatus({
                    status: state.status,
                    message: `Binder server is ready: ${msg.message}`
                  });
                  (_d = this.resolveReadyFn) === null || _d === void 0 ? void 0 : _d.call(this, this);
                }
                break;
              default:
                this.events.triggerStatus({
                  status: state.status,
                  message: `Binder is: ${phase} - ${msg.message}`
                });
            }
          });
        });
      }
      //
      // ServerRestAPI Implementation
      //
      getFetchUrl(relativeUrl) {
        var _a, _b;
        if (!this.sessionManager)
          throw new Error("Must connect to a server before requesting KernelSpecs");
        if (!((_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.serverSettings))
          throw new Error("No server settings available in session manager");
        const settings = (_b = this.sessionManager) === null || _b === void 0 ? void 0 : _b.serverSettings;
        const baseUrl = new URL(settings.baseUrl);
        const url = new URL(`${baseUrl.pathname}${relativeUrl}`.replace("//", "/"), baseUrl.origin);
        url.searchParams.append("token", settings.token);
        return url;
      }
      static status(serverSettings) {
        return import_services3.ServerConnection.makeRequest(`${serverSettings.baseUrl}api/status`, {}, import_services3.ServerConnection.makeSettings(serverSettings));
      }
      getKernelSpecs() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.sessionManager)
            throw new Error("Must connect to a server before requesting KernelSpecs");
          return import_services3.KernelSpecAPI.getSpecs(import_services3.ServerConnection.makeSettings((_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.serverSettings));
        });
      }
      getContents(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.getFetchUrl(`/api/contents/${opts.path}`);
          if (opts.type)
            url.searchParams.append("type", opts.type);
          if (opts.format)
            url.searchParams.append("format", opts.format);
          url.searchParams.append("content", opts.returnContent ? "1" : "0");
          return responseToJson(yield fetch(url));
        });
      }
      duplicateFile(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.getFetchUrl(`/api/contents/${opts.path}`);
          const { copy_from, ext, type: type2 } = opts;
          return responseToJson(yield fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ copy_from, ext, type: type2 })
          }));
        });
      }
      createDirectory(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.getFetchUrl(`/api/contents/${opts.path}`);
          return responseToJson(yield fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ type: "directory" })
          }));
        });
      }
      renameContents(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { path: path2, newPath } = opts;
          const url = this.getFetchUrl(`/api/contents/${path2}`);
          return responseToJson(yield fetch(url, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ path: newPath })
          }));
        });
      }
      uploadFile(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { path: path2, content, format: format2, type: type2 } = opts;
          const url = this.getFetchUrl(`/api/contents/${path2}`);
          console.debug("thebe:api:server:uploadFile", url);
          return responseToJson(yield fetch(url, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              path: path2,
              content,
              format: format2 !== null && format2 !== void 0 ? format2 : "json",
              type: type2 !== null && type2 !== void 0 ? type2 : "notebook"
            })
          }));
        });
      }
    };
    server_default = ThebeServer;
  }
});

// ../../node_modules/@jupyterlab/mathjax2/node_modules/@lumino/coreutils/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/@jupyterlab/mathjax2/node_modules/@lumino/coreutils/dist/index.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.lumino_coreutils = {}));
    })(exports2, function(exports3) {
      "use strict";
      exports3.JSONExt = void 0;
      (function(JSONExt13) {
        JSONExt13.emptyObject = Object.freeze({});
        JSONExt13.emptyArray = Object.freeze([]);
        function isPrimitive(value) {
          return value === null || typeof value === "boolean" || typeof value === "number" || typeof value === "string";
        }
        JSONExt13.isPrimitive = isPrimitive;
        function isArray(value) {
          return Array.isArray(value);
        }
        JSONExt13.isArray = isArray;
        function isObject5(value) {
          return !isPrimitive(value) && !isArray(value);
        }
        JSONExt13.isObject = isObject5;
        function deepEqual2(first2, second) {
          if (first2 === second) {
            return true;
          }
          if (isPrimitive(first2) || isPrimitive(second)) {
            return false;
          }
          var a1 = isArray(first2);
          var a22 = isArray(second);
          if (a1 !== a22) {
            return false;
          }
          if (a1 && a22) {
            return deepArrayEqual(first2, second);
          }
          return deepObjectEqual(first2, second);
        }
        JSONExt13.deepEqual = deepEqual2;
        function deepCopy(value) {
          if (isPrimitive(value)) {
            return value;
          }
          if (isArray(value)) {
            return deepArrayCopy(value);
          }
          return deepObjectCopy(value);
        }
        JSONExt13.deepCopy = deepCopy;
        function deepArrayEqual(first2, second) {
          if (first2 === second) {
            return true;
          }
          if (first2.length !== second.length) {
            return false;
          }
          for (var i5 = 0, n4 = first2.length; i5 < n4; ++i5) {
            if (!deepEqual2(first2[i5], second[i5])) {
              return false;
            }
          }
          return true;
        }
        function deepObjectEqual(first2, second) {
          if (first2 === second) {
            return true;
          }
          for (var key in first2) {
            if (first2[key] !== void 0 && !(key in second)) {
              return false;
            }
          }
          for (var key in second) {
            if (second[key] !== void 0 && !(key in first2)) {
              return false;
            }
          }
          for (var key in first2) {
            var firstValue = first2[key];
            var secondValue = second[key];
            if (firstValue === void 0 && secondValue === void 0) {
              continue;
            }
            if (firstValue === void 0 || secondValue === void 0) {
              return false;
            }
            if (!deepEqual2(firstValue, secondValue)) {
              return false;
            }
          }
          return true;
        }
        function deepArrayCopy(value) {
          var result2 = new Array(value.length);
          for (var i5 = 0, n4 = value.length; i5 < n4; ++i5) {
            result2[i5] = deepCopy(value[i5]);
          }
          return result2;
        }
        function deepObjectCopy(value) {
          var result2 = {};
          for (var key in value) {
            var subvalue = value[key];
            if (subvalue === void 0) {
              continue;
            }
            result2[key] = deepCopy(subvalue);
          }
          return result2;
        }
      })(exports3.JSONExt || (exports3.JSONExt = {}));
      var MimeData = (
        /** @class */
        function() {
          function MimeData2() {
            this._types = [];
            this._values = [];
          }
          MimeData2.prototype.types = function() {
            return this._types.slice();
          };
          MimeData2.prototype.hasData = function(mime) {
            return this._types.indexOf(mime) !== -1;
          };
          MimeData2.prototype.getData = function(mime) {
            var i5 = this._types.indexOf(mime);
            return i5 !== -1 ? this._values[i5] : void 0;
          };
          MimeData2.prototype.setData = function(mime, data) {
            this.clearData(mime);
            this._types.push(mime);
            this._values.push(data);
          };
          MimeData2.prototype.clearData = function(mime) {
            var i5 = this._types.indexOf(mime);
            if (i5 !== -1) {
              this._types.splice(i5, 1);
              this._values.splice(i5, 1);
            }
          };
          MimeData2.prototype.clear = function() {
            this._types.length = 0;
            this._values.length = 0;
          };
          return MimeData2;
        }()
      );
      var PromiseDelegate5 = (
        /** @class */
        function() {
          function PromiseDelegate6() {
            var _this = this;
            this.promise = new Promise(function(resolve, reject4) {
              _this._resolve = resolve;
              _this._reject = reject4;
            });
          }
          PromiseDelegate6.prototype.resolve = function(value) {
            var resolve = this._resolve;
            resolve(value);
          };
          PromiseDelegate6.prototype.reject = function(reason) {
            var reject4 = this._reject;
            reject4(reason);
          };
          return PromiseDelegate6;
        }()
      );
      var Token3 = (
        /** @class */
        function() {
          function Token4(name2) {
            this.name = name2;
            this._tokenStructuralPropertyT = null;
          }
          return Token4;
        }()
      );
      function fallbackRandomValues(buffer) {
        var value = 0;
        for (var i5 = 0, n4 = buffer.length; i5 < n4; ++i5) {
          if (i5 % 4 === 0) {
            value = Math.random() * 4294967295 >>> 0;
          }
          buffer[i5] = value & 255;
          value >>>= 8;
        }
      }
      exports3.Random = void 0;
      (function(Random) {
        Random.getRandomValues = function() {
          var crypto2 = typeof window !== "undefined" && (window.crypto || window.msCrypto) || null;
          if (crypto2 && typeof crypto2.getRandomValues === "function") {
            return function getRandomValues(buffer) {
              return crypto2.getRandomValues(buffer);
            };
          }
          return fallbackRandomValues;
        }();
      })(exports3.Random || (exports3.Random = {}));
      function uuid4Factory(getRandomValues) {
        var bytes = new Uint8Array(16);
        var lut = new Array(256);
        for (var i5 = 0; i5 < 16; ++i5) {
          lut[i5] = "0" + i5.toString(16);
        }
        for (var i5 = 16; i5 < 256; ++i5) {
          lut[i5] = i5.toString(16);
        }
        return function uuid4() {
          getRandomValues(bytes);
          bytes[6] = 64 | bytes[6] & 15;
          bytes[8] = 128 | bytes[8] & 63;
          return lut[bytes[0]] + lut[bytes[1]] + lut[bytes[2]] + lut[bytes[3]] + "-" + lut[bytes[4]] + lut[bytes[5]] + "-" + lut[bytes[6]] + lut[bytes[7]] + "-" + lut[bytes[8]] + lut[bytes[9]] + "-" + lut[bytes[10]] + lut[bytes[11]] + lut[bytes[12]] + lut[bytes[13]] + lut[bytes[14]] + lut[bytes[15]];
        };
      }
      exports3.UUID = void 0;
      (function(UUID3) {
        UUID3.uuid4 = uuid4Factory(exports3.Random.getRandomValues);
      })(exports3.UUID || (exports3.UUID = {}));
      exports3.MimeData = MimeData;
      exports3.PromiseDelegate = PromiseDelegate5;
      exports3.Token = Token3;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/@jupyterlab/mathjax2/lib/index.js
var import_coreutils20, MathJaxTypesetter;
var init_lib15 = __esm({
  "../../node_modules/@jupyterlab/mathjax2/lib/index.js"() {
    import_coreutils20 = __toESM(require_dist2());
    MathJaxTypesetter = class {
      /**
       * Create a new MathJax typesetter.
       */
      constructor(options) {
        this._initPromise = new import_coreutils20.PromiseDelegate();
        this._initialized = false;
        this._url = options.url;
        this._config = options.config;
      }
      /**
       * Typeset the math in a node.
       *
       * #### Notes
       * MathJax schedules the typesetting asynchronously,
       * but there are not currently any callbacks or Promises
       * firing when it is done.
       */
      typeset(node) {
        if (!this._initialized) {
          this._init();
        }
        void this._initPromise.promise.then(() => {
          MathJax.Hub.Queue(["Typeset", MathJax.Hub, node]);
          try {
            MathJax.Hub.Queue(["Require", MathJax.Ajax, "[MathJax]/extensions/TeX/AMSmath.js"], () => {
              MathJax.InputJax.TeX.resetEquationNumbers();
            });
          } catch (e4) {
            console.error("Error queueing resetEquationNumbers:", e4);
          }
        });
      }
      /**
       * Initialize MathJax.
       */
      _init() {
        const head = document.getElementsByTagName("head")[0];
        const script = document.createElement("script");
        script.type = "text/javascript";
        script.src = `${this._url}?config=${this._config}&amp;delayStartupUntil=configured`;
        script.charset = "utf-8";
        head.appendChild(script);
        script.addEventListener("load", () => {
          this._onLoad();
        });
        this._initialized = true;
      }
      /**
       * Handle MathJax loading.
       */
      _onLoad() {
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [
              ["$", "$"],
              ["\\(", "\\)"]
            ],
            displayMath: [
              ["$$", "$$"],
              ["\\[", "\\]"]
            ],
            processEscapes: true,
            processEnvironments: true
          },
          // Center justify equations in code and markdown cells. Elsewhere
          // we use CSS to left justify single line equations in code cells.
          displayAlign: "center",
          CommonHTML: {
            linebreaks: { automatic: true }
          },
          "HTML-CSS": {
            availableFonts: [],
            imageFont: null,
            preferredFont: null,
            webFont: "STIX-Web",
            styles: { ".MathJax_Display": { margin: 0 } },
            linebreaks: { automatic: true }
          },
          skipStartupTypeset: true,
          messageStyle: "none"
        });
        MathJax.Hub.Register.StartupHook("End Config", () => {
          var _a, _b, _c, _d, _e, _f;
          (_c = (_b = (_a = MathJax.Hub) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.MathEvents) === null || _c === void 0 ? true : delete _c.styles[".MathJax_Hover_Arrow:hover span"];
          (_f = (_e = (_d = MathJax.Hub) === null || _d === void 0 ? void 0 : _d.config) === null || _e === void 0 ? void 0 : _e.MathMenu) === null || _f === void 0 ? true : delete _f.styles[".MathJax_MenuClose:hover span"];
        });
        MathJax.Hub.Configured();
        this._initPromise.resolve(void 0);
      }
    };
  }
});

// ../../node_modules/@jupyterlab/javascript-extension/lib/index.js
function evalInContext(code, element, document, window) {
  return eval(code);
}
var TEXT_JAVASCRIPT_MIMETYPE, APPLICATION_JAVASCRIPT_MIMETYPE, ExperimentalRenderedJavascript, rendererFactory, extension, lib_default;
var init_lib16 = __esm({
  "../../node_modules/@jupyterlab/javascript-extension/lib/index.js"() {
    init_lib6();
    TEXT_JAVASCRIPT_MIMETYPE = "text/javascript";
    APPLICATION_JAVASCRIPT_MIMETYPE = "application/javascript";
    ExperimentalRenderedJavascript = class extends RenderedJavaScript {
      render(model) {
        const trans = this.translator.load("jupyterlab");
        const renderJavascript = () => {
          try {
            const data = model.data[this.mimeType];
            if (data) {
              evalInContext(data, this.node, document, window);
            }
            return Promise.resolve();
          } catch (error) {
            return Promise.reject(error);
          }
        };
        if (!model.trusted) {
          const pre = document.createElement("pre");
          pre.textContent = trans.__("Are you sure that you want to run arbitrary Javascript within your JupyterLab session?");
          const button = document.createElement("button");
          button.textContent = trans.__("Run");
          this.node.appendChild(pre);
          this.node.appendChild(button);
          button.onclick = (event) => {
            this.node.textContent = "";
            void renderJavascript();
          };
          return Promise.resolve();
        }
        return renderJavascript();
      }
    };
    rendererFactory = {
      safe: false,
      mimeTypes: [TEXT_JAVASCRIPT_MIMETYPE, APPLICATION_JAVASCRIPT_MIMETYPE],
      createRenderer: (options) => new ExperimentalRenderedJavascript(options)
    };
    extension = {
      id: "@jupyterlab/javascript-extension:factory",
      description: "Adds renderer for JavaScript content.",
      rendererFactory,
      rank: 0,
      dataType: "string"
    };
    lib_default = extension;
  }
});

// ../../node_modules/@jupyterlab/json-extension/lib/index.js
var React46, import_client, CSS_CLASS, MIME_TYPE, MIME_TYPES_JSONL, RenderedJSON, rendererFactory2;
var init_lib17 = __esm({
  "../../node_modules/@jupyterlab/json-extension/lib/index.js"() {
    init_lib2();
    init_lib();
    init_index_es64();
    React46 = __toESM(require_react());
    import_client = __toESM(require_client());
    CSS_CLASS = "jp-RenderedJSON";
    MIME_TYPE = "application/json";
    MIME_TYPES_JSONL = [
      "text/jsonl",
      "application/jsonl",
      "application/json-lines"
    ];
    RenderedJSON = class extends Widget {
      /**
       * Create a new widget for rendering JSON.
       */
      constructor(options) {
        super();
        this._rootDOM = null;
        this.addClass(CSS_CLASS);
        this.addClass("CodeMirror");
        this._mimeType = options.mimeType;
        this.translator = options.translator || nullTranslator;
      }
      [Printing.symbol]() {
        return () => Printing.printWidget(this);
      }
      /**
       * Render JSON into this widget's node.
       */
      async renderModel(model) {
        const { Component } = await import("/build/_shared/component-PWDF436Y.js");
        let data;
        if (MIME_TYPES_JSONL.indexOf(this._mimeType) >= 0) {
          const lines = (model.data[this._mimeType] || "").trim().split(/\n/);
          data = JSON.parse(`[${lines.join(",")}]`);
        } else {
          data = model.data[this._mimeType] || {};
        }
        const metadata = model.metadata[this._mimeType] || {};
        if (this._rootDOM === null) {
          this._rootDOM = (0, import_client.createRoot)(this.node);
        }
        return new Promise((resolve, reject4) => {
          this._rootDOM.render(React46.createElement(Component, { data, metadata, translator: this.translator, forwardedRef: () => resolve() }));
        });
      }
      /**
       * Called before the widget is detached from the DOM.
       */
      onBeforeDetach(msg) {
        if (this._rootDOM) {
          this._rootDOM.unmount();
          this._rootDOM = null;
        }
      }
    };
    rendererFactory2 = {
      safe: true,
      mimeTypes: [MIME_TYPE, ...MIME_TYPES_JSONL],
      createRenderer: (options) => new RenderedJSON(options)
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/config.js
var Config;
var init_config = __esm({
  "../../node_modules/thebe-core/dist/esm/config.js"() {
    init_options();
    init_events();
    Config = class {
      constructor(opts = {}, extraConfig) {
        var _a, _b, _c, _d, _e, _f, _g;
        this._events = (_a = extraConfig === null || extraConfig === void 0 ? void 0 : extraConfig.events) !== null && _a !== void 0 ? _a : new ThebeEvents();
        this._options = {
          mathjaxUrl: (_b = opts.mathjaxUrl) !== null && _b !== void 0 ? _b : "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js",
          mathjaxConfig: (_c = opts.mathjaxConfig) !== null && _c !== void 0 ? _c : "TeX-AMS_CHTML-full,Safe"
        };
        this._binderOptions = makeBinderOptions((_d = opts.binderOptions) !== null && _d !== void 0 ? _d : {});
        this._savedSessions = makeSavedSessionOptions((_e = opts.savedSessionOptions) !== null && _e !== void 0 ? _e : {});
        this._kernelOptions = makeKernelOptions((_f = opts.kernelOptions) !== null && _f !== void 0 ? _f : {});
        this._serverSettings = makeServerSettings((_g = opts.serverSettings) !== null && _g !== void 0 ? _g : {});
        console.debug("thebe:config:constructor", this);
      }
      get events() {
        return this._events;
      }
      get base() {
        return this._options;
      }
      get mathjax() {
        return {
          mathjaxUrl: this._options.mathjaxUrl,
          mathjaxConfig: this._options.mathjaxConfig
        };
      }
      get binder() {
        return this._binderOptions;
      }
      get savedSessions() {
        return this._savedSessions;
      }
      get kernels() {
        return this._kernelOptions;
      }
      get serverSettings() {
        return this._serverSettings;
      }
      set serverSettings(newSettings) {
        this._serverSettings = newSettings;
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/options.js
function makeBinderOptions(opts) {
  return Object.assign({ repo: "executablebooks/thebe-binder-base", ref: "HEAD", binderUrl: "https://mybinder.org", repoProvider: "github" }, opts);
}
function makeSavedSessionOptions(opts) {
  return Object.assign({ enabled: true, maxAge: 86400, storagePrefix: "thebe-binder" }, opts);
}
function makeKernelOptions(opts) {
  var _a, _b;
  return {
    path: (_a = opts.path) !== null && _a !== void 0 ? _a : "/",
    kernelName: (_b = opts.kernelName) !== null && _b !== void 0 ? _b : "python"
  };
}
function makeServerSettings(settings) {
  var _a, _b;
  const baseUrl = (_a = settings.baseUrl) !== null && _a !== void 0 ? _a : "http://localhost:8888";
  const wsUrl = (_b = settings.wsUrl) !== null && _b !== void 0 ? _b : baseUrl.replace(/^http/, "ws");
  return Object.assign(Object.assign({ token: shortId(), appendToken: true }, settings), {
    wsUrl,
    baseUrl
  });
}
function makeMathjaxOptions(opts) {
  return Object.assign({ mathjaxUrl: "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js", mathjaxConfig: "TeX-AMS_CHTML-full,Safe" }, opts);
}
function makeConfiguration(options, events2) {
  return new Config(options, { events: events2 });
}
function ensureCoreOptions(options, events2) {
  const config = new Config(options, { events: events2 });
  return Object.assign(Object.assign({}, config.base), { binderOptions: config.binder, savedSessionOptions: config.savedSessions, kernelOptions: config.kernels, serverSettings: config.serverSettings });
}
var init_options = __esm({
  "../../node_modules/thebe-core/dist/esm/options.js"() {
    init_config();
    init_utils4();
  }
});

// ../../node_modules/thebe-core/dist/esm/rendermime.js
function getRenderers(mathjax) {
  if (RENDERERS == null) {
    RENDERERS = EXTENDED_FACTORIES.filter((f6) => {
      if (f6.mimeTypes.indexOf("text/latex") >= 0) {
        if (mathjax.mathjaxUrl) {
          return true;
        } else {
          console.debug("thebe:getRenderers MathJax unavailable");
          return false;
        }
      } else {
        return true;
      }
    });
  }
  let latexTypesetter;
  if (mathjax.mathjaxUrl && mathjax.mathjaxConfig) {
    latexTypesetter = new MathJaxTypesetter({
      url: mathjax.mathjaxUrl,
      config: mathjax.mathjaxConfig
    });
  }
  return {
    initialFactories: [...RENDERERS],
    latexTypesetter
  };
}
function makeRenderMimeRegistry(mathjax) {
  const rendermime = new RenderMimeRegistry(getRenderers(mathjax !== null && mathjax !== void 0 ? mathjax : makeMathjaxOptions()));
  rendermime.addFactory(rendererFactory2, 10);
  return rendermime;
}
var EXTENDED_FACTORIES, RENDERERS;
var init_rendermime = __esm({
  "../../node_modules/thebe-core/dist/esm/rendermime.js"() {
    init_lib6();
    init_lib15();
    init_lib16();
    init_lib17();
    init_options();
    EXTENDED_FACTORIES = [
      htmlRendererFactory,
      markdownRendererFactory,
      latexRendererFactory,
      svgRendererFactory,
      imageRendererFactory,
      rendererFactory,
      textRendererFactory
    ];
    RENDERERS = null;
  }
});

// ../../node_modules/thebe-core/dist/esm/passive.js
var PassiveCellRenderer, passive_default;
var init_passive = __esm({
  "../../node_modules/thebe-core/dist/esm/passive.js"() {
    init_rendermime();
    init_lib9();
    init_options();
    init_index_es64();
    init_index_es66();
    PassiveCellRenderer = class {
      constructor(id, rendermime, mathjax) {
        this.id = id;
        this.rendermime = rendermime !== null && rendermime !== void 0 ? rendermime : makeRenderMimeRegistry(mathjax !== null && mathjax !== void 0 ? mathjax : makeMathjaxOptions());
        this.model = new OutputAreaModel({ trusted: true });
        this.area = new OutputArea({
          model: this.model,
          rendermime: this.rendermime
        });
      }
      /**
       * Serialize the model state to JSON
       */
      get outputs() {
        return this.model.toJSON();
      }
      get isAttachedToDOM() {
        return this.area.isAttached;
      }
      attachToDOM(el, strict = false) {
        if (!this.area || !el) {
          console.error(`thebe:renderer:attachToDOM - could not attach to DOM - area: ${this.area}, el: ${el}`);
          return;
        }
        if (this.area.isAttached) {
          console.debug(`thebe:renderer:attachToDOM - already attached`);
          if (strict)
            return;
        } else {
          console.debug(`thebe:renderer:attachToDOM ${this.id} - appending existing contents`);
          if (el.innerHTML) {
            this.area.model.add({
              output_type: "display_data",
              data: {
                "text/html": el.innerHTML
              }
            });
          }
        }
        el.textContent = "";
        const div = document.createElement("div");
        div.style.position = "relative";
        div.className = "thebe-output";
        el.append(div);
        MessageLoop.sendMessage(this.area, Widget.Msg.BeforeAttach);
        div.appendChild(this.area.node);
        MessageLoop.sendMessage(this.area, Widget.Msg.AfterAttach);
      }
      setOutputText(text) {
        if (!this.area)
          return;
        this.area.model.clear(true);
        this.area.model.add({
          output_type: "stream",
          name: "stdout",
          text
        });
      }
      /**
       * Clears the output area model
       *
       * @returns
       */
      clear() {
        if (!this.area)
          return;
        this.area.model.clear();
      }
      /**
       * Will trigger the output to render an error with text taken from the optional argument
       *
       * @param error
       * @returns
       */
      clearOnError(error) {
        if (!this.area)
          return;
        this.area.model.clear();
        this.area.model.add({
          output_type: "stream",
          name: "stderr",
          text: `Failed to execute. ${error !== null && error !== void 0 ? error : ""} Please refresh the page.`
        });
      }
      /**
       * Render output data directly from json
       *
       * @param outputs - serialised jupyter outputs
       * @returns
       */
      render(outputs) {
        this.model.fromJSON(outputs);
      }
    };
    passive_default = PassiveCellRenderer;
  }
});

// ../../node_modules/thebe-core/dist/esm/cell.js
var ThebeCodeCell, cell_default;
var init_cell = __esm({
  "../../node_modules/thebe-core/dist/esm/cell.js"() {
    init_tslib_es6();
    init_passive();
    init_events();
    init_emitter();
    init_utils4();
    ThebeCodeCell = class extends passive_default {
      constructor(id, notebookId, source, config, metadata, rendermime) {
        super(id, rendermime);
        this.kind = "code";
        this.events = new EventEmitter(id, config, EventSubject.cell, this);
        this.notebookId = notebookId;
        this.source = source;
        this.metadata = metadata;
        this.busy = false;
        this.executionCount = null;
        this.initialOutputs = [];
        console.debug("thebe:cell constructor", this);
      }
      static fromICodeCell(icc, notebookId, config, rendermime) {
        var _a;
        const cell = new ThebeCodeCell((_a = icc.id) !== null && _a !== void 0 ? _a : shortId(), notebookId, ensureString2(icc.source), config, icc.metadata, rendermime);
        Object.assign(cell.metadata, icc.metadata);
        return cell;
      }
      get isBusy() {
        return this.busy;
      }
      get isAttached() {
        return this.session !== void 0;
      }
      get tags() {
        var _a;
        return (_a = this.metadata.tags) !== null && _a !== void 0 ? _a : [];
      }
      /**
       * Attaches to the session and adds the widgets factory to the rendermine registry
       * call this version if using ThebeCell in isolation, otherwise call ThebeNotebook::attachSession
       *
       * @param session
       */
      attachSession(session) {
        this.session = session;
        this.events.triggerStatus({
          status: CellStatusEvent.attached,
          message: "Attached to session"
        });
      }
      /**
       * Detaches from the session and removes the widgets factory from the rendermine registry
       * call this version if using ThebeCell in isolation, otherwise call ThebeNotebook::detachSession
       *
       */
      detachSession() {
        this.session = void 0;
        this.events.triggerStatus({
          status: CellStatusEvent.detached,
          message: "Detached from session"
        });
      }
      setAsBusy() {
        console.debug(`thebe:renderer:message:busy ${this.id}`);
        this.busy = true;
        this.events.triggerStatus({
          status: CellStatusEvent.executing,
          message: "Executing..."
        });
      }
      setAsIdle() {
        console.debug(`thebe:renderer:message:completed ${this.id}`);
        this.busy = false;
        this.events.triggerStatus({
          status: CellStatusEvent.idle,
          message: "Completed"
        });
      }
      /**
       * reset the DOM representation of the cell to the initial state
       * along with the execution count
       *
       * @param hideWidgets boolean - if true, hide widgets
       */
      initOutputs(initialOutputs) {
        this.initialOutputs = initialOutputs;
        this.render(initialOutputs);
        this.executionCount = null;
      }
      /**
       * reset the DOM representation of the cell to the initial state
       * along with the execution count
       *
       * @param hideWidgets boolean - if true, hide widgets
       */
      reset() {
        this.render(this.initialOutputs);
        this.executionCount = null;
      }
      /**
       * TODO
       *  - pass execute_count or timestamp or something back to redux on success/failure?
       *
       * @param source?
       * @returns
       */
      execute(source) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.session || !this.session.kernel) {
            console.warn("Attempting to execute on a cell without an attached kernel");
            return null;
          }
          const code3 = source !== null && source !== void 0 ? source : this.source;
          try {
            console.debug(`thebe:renderer:execute ${this.id}`);
            if (!this.isBusy)
              this.setAsBusy();
            this.area.future = this.session.kernel.requestExecute({ code: code3 });
            const reply = yield this.area.future.done;
            this.executionCount = reply.content.execution_count;
            let executeErrors;
            for (let i5 = 0; i5 < this.model.length; i5++) {
              const out = this.model.get(i5);
              console.debug("thebecell:execute:output", { out: out.toJSON() });
              if (out.type === "error") {
                const json2 = out.toJSON();
                if (json2.ename === "stderr") {
                  this.events.triggerError({
                    status: ErrorStatusEvent.warning,
                    message: errorToMessage(json2)
                  });
                } else {
                  if (!executeErrors)
                    executeErrors = [json2];
                  else
                    executeErrors === null || executeErrors === void 0 ? void 0 : executeErrors.push(json2);
                  this.events.triggerError({
                    status: ErrorStatusEvent.executeError,
                    message: errorToMessage(json2)
                  });
                }
              }
            }
            this.setAsIdle();
            return {
              id: this.id,
              height: this.area.node.offsetHeight,
              width: this.area.node.offsetWidth,
              error: executeErrors
            };
          } catch (err) {
            console.error("thebe:renderer:execute Error:", err);
            this.clearOnError(err);
            this.events.triggerError(err.message);
            return null;
          }
        });
      }
    };
    cell_default = ThebeCodeCell;
  }
});

// ../../node_modules/thebe-core/dist/esm/markdown.js
var ThebeMarkdownCell;
var init_markdown = __esm({
  "../../node_modules/thebe-core/dist/esm/markdown.js"() {
    init_tslib_es6();
    init_passive();
    init_utils4();
    ThebeMarkdownCell = class extends passive_default {
      constructor(id, notebookId, source, metadata, rendermime) {
        super(id, rendermime);
        this.kind = "markdown";
        this.id = id;
        this.notebookId = notebookId;
        this.source = source;
        this.busy = false;
        this.metadata = metadata;
      }
      static fromICell(ic, notebookId, rendermime) {
        const cell = new ThebeMarkdownCell(typeof ic.id === "string" ? ic.id : shortId(), notebookId, ensureString2(ic.source), ic.metadata, rendermime);
        return cell;
      }
      get isAttachedToDOM() {
        return false;
      }
      get isBusy() {
        return false;
      }
      get isAttached() {
        return false;
      }
      get executionCount() {
        return null;
      }
      setAsBusy() {
      }
      setAsIdle() {
      }
      initOutputs(initialOutputs) {
      }
      reset() {
      }
      attachToDOM(el) {
      }
      attachSession(session) {
      }
      detachSession() {
      }
      setOutputText(text) {
      }
      clear() {
      }
      clearOnError(error) {
      }
      messageBusy() {
      }
      messageCompleted() {
      }
      messageError(message) {
      }
      render(outputs) {
      }
      get tags() {
        return [];
      }
      get outputs() {
        return [];
      }
      execute(source) {
        return __awaiter(this, void 0, void 0, function* () {
          return { id: this.id, height: 0, width: 0 };
        });
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/notebook.js
var ThebeNotebook, notebook_default;
var init_notebook = __esm({
  "../../node_modules/thebe-core/dist/esm/notebook.js"() {
    init_tslib_es6();
    init_cell();
    init_utils4();
    init_events();
    init_emitter();
    init_markdown();
    ThebeNotebook = class {
      constructor(id, config, rendermime) {
        this.id = id;
        this.events = new EventEmitter(id, config, EventSubject.notebook, this);
        this.cells = [];
        this.metadata = {};
        this.rendermime = rendermime;
        console.debug("thebe:notebook constructor", this);
      }
      static fromCodeBlocks(blocks, config, rendermime) {
        const id = shortId();
        const notebook = new ThebeNotebook(id, config, rendermime);
        notebook.cells = blocks.map((c6) => {
          const metadata = {};
          const cell = new cell_default(c6.id, id, c6.source, config, metadata, notebook.rendermime);
          console.debug(`thebe:notebook:fromCodeBlocks Initializing cell ${c6.id}`);
          return cell;
        });
        return notebook;
      }
      static fromIpynb(ipynb, config, rendermime) {
        const notebook = new ThebeNotebook(shortId(), config, rendermime);
        Object.assign(notebook.metadata, ipynb.metadata);
        notebook.cells = ipynb.cells.map((c6) => {
          if (c6.cell_type === "code")
            return cell_default.fromICodeCell(c6, notebook.id, config, notebook.rendermime);
          return ThebeMarkdownCell.fromICell(c6, notebook.id, notebook.rendermime);
        });
        return notebook;
      }
      get parameters() {
        const p3 = this.findCells("parameters");
        if (!p3 || (p3 === null || p3 === void 0 ? void 0 : p3.length) === 0)
          return void 0;
        if (p3.length > 1)
          console.warn(`Mulitple parameter cells found in notebook ${this.id}`);
        return p3;
      }
      get widgets() {
        var _a;
        return (_a = this.findCells("widget")) !== null && _a !== void 0 ? _a : [];
      }
      get last() {
        if (this.cells.length === 0)
          throw new Error("empty notebook");
        return this.cells[this.cells.length - 1];
      }
      get markdown() {
        return this.cells.filter((c6) => c6.kind === "markdown");
      }
      get code() {
        return this.cells.filter((c6) => c6.kind === "code");
      }
      /**
       * reset the notebook to its initial state by resetting each cell
       *
       * @param hideWidgets boolean
       */
      reset() {
        this.cells.forEach((cell) => cell.reset());
      }
      numCells() {
        var _a, _b;
        return (_b = (_a = this.cells) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      }
      findCells(tag) {
        const found2 = this.cells.filter((c6) => c6.tags.includes(tag));
        return found2.length > 0 ? found2 : void 0;
      }
      getCell(idx) {
        if (!this.cells)
          throw Error("Dag not initialized");
        if (idx >= this.cells.length)
          throw Error(`Notebook.cells index out of range: ${idx}:${this.cells.length}`);
        return this.cells[idx];
      }
      getCellById(id) {
        var _a;
        const cell = (_a = this.cells) === null || _a === void 0 ? void 0 : _a.find((c6) => c6.id === id);
        return cell;
      }
      lastCell() {
        if (!this.cells)
          throw Error("Notebook not initialized");
        return this.cells[this.cells.length - 1];
      }
      updateParameters(newSource, interpolate = false) {
        if (interpolate)
          throw new Error("Not implemented yet");
        if (this.parameters)
          this.parameters[0].source = newSource;
      }
      waitForKernel(kernel) {
        return __awaiter(this, void 0, void 0, function* () {
          return kernel.then((k) => {
            this.attachSession(k);
            return k;
          });
        });
      }
      attachSession(session) {
        var _a;
        if (!session.kernel)
          throw Error("ThebeNotebook - cannot connect to session, no kernel");
        this.session = session;
        (_a = this.cells) === null || _a === void 0 ? void 0 : _a.forEach((cell) => cell.session = session);
        this.events.triggerStatus({
          status: NotebookStatusEvent.attached,
          message: "Attached to session"
        });
      }
      detachSession() {
        var _a;
        (_a = this.cells) === null || _a === void 0 ? void 0 : _a.map((cell) => cell.session = void 0);
        this.session = void 0;
        this.events.triggerStatus({
          status: NotebookStatusEvent.detached,
          message: "Detached from session"
        });
      }
      clear() {
        this.cells.forEach((cell) => cell.clear());
      }
      executeUpTo(cellId, stopOnError = false, preprocessor) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.cells)
            return [];
          this.events.triggerStatus({
            status: NotebookStatusEvent.executing,
            message: `executeUpTo ${cellId}`
          });
          const idx = this.cells.findIndex((c6) => c6.id === cellId);
          if (idx === -1)
            return [];
          const cellsToExecute = this.cells.slice(0, idx + 1);
          cellsToExecute.map((cell) => cell.setAsBusy());
          const result2 = yield this.executeCells(cellsToExecute.map((c6) => c6.id), stopOnError, preprocessor);
          this.events.triggerStatus({
            status: NotebookStatusEvent.idle,
            message: `executeUpTo ${cellId}`
          });
          return result2;
        });
      }
      executeOnly(cellId, preprocessor) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.cells)
            return null;
          this.events.triggerStatus({
            status: NotebookStatusEvent.executing,
            message: `executeOnly ${cellId}`
          });
          const result2 = yield this.executeCells([cellId], false, preprocessor);
          this.events.triggerStatus({
            status: NotebookStatusEvent.idle,
            message: `executeUpTo ${cellId}`
          });
          return result2[0];
        });
      }
      executeCells(cellIds, stopOnError = false, preprocessor) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.cells)
            return [];
          this.events.triggerStatus({
            status: NotebookStatusEvent.executing,
            message: `executeCells ${cellIds.length} cells`
          });
          const cells = this.cells.filter((c6) => {
            const found2 = cellIds.find((id) => id === c6.id);
            if (!found2) {
              console.warn(`Cell ${c6.id} not found in notebook`);
            }
            return Boolean(found2);
          });
          let result2 = [];
          if (stopOnError) {
            let skipRemaining = false;
            for (const cell of cells) {
              if (skipRemaining)
                continue;
              const cellReturn = yield cell.execute(preprocessor ? preprocessor(cell.source) : cell.source);
              if (cellReturn == null || cellReturn.error)
                skipRemaining = true;
              result2.push(cellReturn);
            }
          } else {
            result2 = yield Promise.all(cells.map((cell) => cell.execute(preprocessor ? preprocessor(cell.source) : cell.source)));
          }
          this.events.triggerStatus({
            status: NotebookStatusEvent.idle,
            message: `executeCells executed ${cellIds.length} cells`
          });
          return result2;
        });
      }
      executeAll(stopOnError = false, preprocessor) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.cells)
            return [];
          this.events.triggerStatus({
            status: NotebookStatusEvent.executing,
            message: `executeAll`
          });
          this.cells.map((cell) => cell.setAsBusy());
          const result2 = yield this.executeCells(this.cells.map((c6) => c6.id), stopOnError, preprocessor);
          this.events.triggerStatus({
            status: NotebookStatusEvent.idle,
            message: `executeAll`
          });
          return result2;
        });
      }
    };
    notebook_default = ThebeNotebook;
  }
});

// ../../node_modules/thebe-core/dist/esm/thebe/api.js
function connectToBinder(config) {
  const server = new server_default(config);
  console.debug(`thebe:api:connect binder \u{1F4E1}`, config.binder);
  server.connectToServerViaBinder();
  return server;
}
function connectToJupyter(config) {
  const server = new server_default(config);
  console.debug(`thebe:api:connect direct \u{1F50C}`, config.serverSettings);
  server.connectToJupyterServer();
  return server;
}
function connectToJupyterLite(config) {
  const server = new server_default(config);
  console.debug(`thebe:api:connect JupyterLite \u{1F918}`);
  server.connectToJupyterLiteServer();
  return server;
}
function makeEvents() {
  return new ThebeEvents();
}
function makeServer(config) {
  return new server_default(config);
}
function setupNotebookFromBlocks(blocks, config, rendermime) {
  return notebook_default.fromCodeBlocks(blocks, config, rendermime);
}
function setupNotebookFromIpynb(ipynb, config, rendermime) {
  return notebook_default.fromIpynb(ipynb, config, rendermime);
}
function setupThebeCore() {
  var _a;
  console.debug(`thebe:api:setupThebeCore`, { coreModule: esm_exports });
  window.thebeCore = Object.assign((_a = window.thebeCore) !== null && _a !== void 0 ? _a : {}, {
    module: esm_exports,
    api: {
      makeConfiguration,
      makeEvents,
      makeServer,
      makeRenderMimeRegistry,
      connectToBinder,
      connectToJupyter,
      connectToJupyterLite,
      setupNotebookFromBlocks,
      setupNotebookFromIpynb
    }
  });
}
var init_api = __esm({
  "../../node_modules/thebe-core/dist/esm/thebe/api.js"() {
    init_server();
    init_notebook();
    init_events();
    init_options();
    init_rendermime();
    init_esm();
  }
});

// ../../node_modules/thebe-core/dist/esm/thebe/entrypoint.js
var init_entrypoint = __esm({
  "../../node_modules/thebe-core/dist/esm/thebe/entrypoint.js"() {
    init_api();
    if (typeof window !== "undefined")
      setupThebeCore();
  }
});

// ../../node_modules/thebe-core/dist/esm/types.js
var init_types = __esm({
  "../../node_modules/thebe-core/dist/esm/types.js"() {
  }
});

// ../../node_modules/thebe-core/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  CellStatusEvent: () => CellStatusEvent,
  Config: () => Config,
  ErrorStatusEvent: () => ErrorStatusEvent,
  EventSubject: () => EventSubject,
  KernelStatusEvent: () => KernelStatusEvent,
  NotebookStatusEvent: () => NotebookStatusEvent,
  PassiveCellRenderer: () => passive_default,
  ServerStatusEvent: () => ServerStatusEvent,
  SessionStatusEvent: () => SessionStatusEvent,
  ThebeCodeCell: () => cell_default,
  ThebeEventType: () => ThebeEventType,
  ThebeEvents: () => ThebeEvents,
  ThebeManager: () => ThebeManager,
  ThebeMarkdownCell: () => ThebeMarkdownCell,
  ThebeNotebook: () => notebook_default,
  ThebeServer: () => server_default,
  ThebeSession: () => session_default,
  WIDGET_MIMETYPE: () => WIDGET_MIMETYPE,
  clearAllSavedSessions: () => clearAllSavedSessions,
  clearSavedSession: () => clearSavedSession,
  connectToBinder: () => connectToBinder,
  connectToJupyter: () => connectToJupyter,
  connectToJupyterLite: () => connectToJupyterLite,
  ensureCoreOptions: () => ensureCoreOptions,
  ensureString: () => ensureString2,
  errorToMessage: () => errorToMessage,
  getRenderers: () => getRenderers,
  isMimeBundle: () => isMimeBundle,
  makeBinderOptions: () => makeBinderOptions,
  makeConfiguration: () => makeConfiguration,
  makeEvents: () => makeEvents,
  makeKernelOptions: () => makeKernelOptions,
  makeMathjaxOptions: () => makeMathjaxOptions,
  makeRenderMimeRegistry: () => makeRenderMimeRegistry,
  makeSavedSessionOptions: () => makeSavedSessionOptions,
  makeServer: () => makeServer,
  makeServerSettings: () => makeServerSettings,
  placeholder: () => placeholder,
  setupNotebookFromBlocks: () => setupNotebookFromBlocks,
  setupNotebookFromIpynb: () => setupNotebookFromIpynb,
  setupThebeCore: () => setupThebeCore,
  shortId: () => shortId,
  stripWidgets: () => stripWidgets
});
var init_esm = __esm({
  "../../node_modules/thebe-core/dist/esm/index.js"() {
    init_server();
    init_session();
    init_notebook();
    init_cell();
    init_markdown();
    init_passive();
    init_options();
    init_events();
    init_api();
    init_entrypoint();
    init_utils4();
    init_manager3();
    init_rendermime();
    init_types();
    init_config();
    init_sessions();
  }
});

// ../../node_modules/thebe-react/dist/ThebeLoaderProvider.js
var require_ThebeLoaderProvider = __commonJS({
  "../../node_modules/thebe-react/dist/ThebeLoaderProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useThebeLoader = exports2.ThebeBundleLoaderProvider = exports2.ThebeLoaderProvider = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importStar(require_react());
    var ThebeLoaderContext = react_1.default.createContext(void 0);
    function ThebeLoaderProvider({ start, children }) {
      const [startLoad, setStartLoad] = (0, react_1.useState)(start);
      const [loading, setLoading] = (0, react_1.useState)(false);
      const [core2, setCore] = (0, react_1.useState)();
      const [error, setError] = (0, react_1.useState)();
      (0, react_1.useEffect)(() => {
        if (!startLoad || core2)
          return;
        setLoading(true);
        console.debug("importing thebe-core...");
        Promise.resolve().then(() => tslib_1.__importStar((init_esm(), __toCommonJS(esm_exports)))).then((thebeCore) => {
          console.debug("thebe-core loaded");
          setCore(thebeCore);
          setLoading(false);
        }).catch(({ message }) => {
          console.debug(`thebe-core load failed ${message}`);
          setError(message);
          setLoading(false);
        });
      }, [startLoad]);
      return (0, jsx_runtime_1.jsx)(ThebeLoaderContext.Provider, Object.assign({ value: { core: core2, error, loading, load: () => setStartLoad(true) } }, { children: (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children }) }));
    }
    exports2.ThebeLoaderProvider = ThebeLoaderProvider;
    function ThebeBundleLoaderProvider2({ start, loadThebeLite, publicPath, children, options = {} }) {
      const [startLoad, setStartLoad] = (0, react_1.useState)(start);
      const [loading, setLoading] = (0, react_1.useState)(false);
      const [core2, setCore] = (0, react_1.useState)();
      const [error, setError] = (0, react_1.useState)();
      (0, react_1.useEffect)(() => {
        var _a;
        if (!startLoad || core2)
          return;
        setLoading(true);
        console.debug("importing thebe-core...");
        if (typeof document !== "undefined" && typeof window !== "undefined") {
          try {
            if (!window.thebeCore) {
              const script = document.createElement("script");
              script.setAttribute("src", `${publicPath !== null && publicPath !== void 0 ? publicPath : ""}/thebe-core.min.js`);
              script.setAttribute("async", "true");
              script.setAttribute("type", "text/javascript");
              document.head.appendChild(script);
            }
            if (loadThebeLite) {
              const liteScript = document.createElement("script");
              liteScript.setAttribute("src", `${publicPath !== null && publicPath !== void 0 ? publicPath : ""}/thebe-lite.min.js`);
              liteScript.setAttribute("async", "true");
              liteScript.setAttribute("type", "text/javascript");
              document.head.appendChild(liteScript);
            }
            let attempts = 0;
            const timer = setInterval(() => {
              var _a2, _b;
              if (window.thebeCore && (window.thebeLite || !loadThebeLite)) {
                setLoading(false);
                setCore((_a2 = window.thebeCore) === null || _a2 === void 0 ? void 0 : _a2.module);
                console.debug("thebe-core loaded");
                if (window.thebeLite)
                  console.debug("thebe-lite loaded");
                clearInterval(timer);
              }
              if (attempts > ((_b = options === null || options === void 0 ? void 0 : options.attempts) !== null && _b !== void 0 ? _b : 50)) {
                setError("thebe-core load failed");
                setLoading(false);
                clearInterval(timer);
                console.warn("thebe load timed out");
                if (!window.thebeCore)
                  console.debug("thebe-core failed to load");
                if (!window.thebeLite)
                  console.debug("thebe-lite failed to load");
              }
              attempts += 1;
            }, (_a = options === null || options === void 0 ? void 0 : options.delay) !== null && _a !== void 0 ? _a : 300);
          } catch (err) {
            setError(err);
            setLoading(false);
          }
        }
      }, [startLoad]);
      return (0, jsx_runtime_1.jsx)(ThebeLoaderContext.Provider, Object.assign({ value: { core: core2, error, loading, load: () => setStartLoad(true) } }, { children: (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children }) }));
    }
    exports2.ThebeBundleLoaderProvider = ThebeBundleLoaderProvider2;
    function useThebeLoader4() {
      const context = react_1.default.useContext(ThebeLoaderContext);
      return context !== null && context !== void 0 ? context : { loading: false, load: () => ({}) };
    }
    exports2.useThebeLoader = useThebeLoader4;
  }
});

// ../../node_modules/thebe-react/dist/ThebeServerProvider.js
var require_ThebeServerProvider = __commonJS({
  "../../node_modules/thebe-react/dist/ThebeServerProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useThebeServer = exports2.useDisposeThebeServer = exports2.useThebeConfig = exports2.ThebeServerProvider = exports2.ThebeServerContext = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importStar(require_react());
    var ThebeLoaderProvider_1 = require_ThebeLoaderProvider();
    exports2.ThebeServerContext = react_1.default.createContext(void 0);
    function ThebeServerProvider2({ connect = true, config, options, useBinder, useJupyterLite, customConnectFn, customRepoProviders, events: events2, children }) {
      var _a;
      const { core: core2 } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const [doConnect, setDoConnect] = (0, react_1.useState)(connect);
      const [connecting, setConnecting] = (0, react_1.useState)(false);
      const [server, setServer] = (0, react_1.useState)();
      const [ready, setReady] = (0, react_1.useState)(false);
      const [error, setError] = (0, react_1.useState)();
      const thebeConfig = (0, react_1.useMemo)(() => config !== null && config !== void 0 ? config : core2 === null || core2 === void 0 ? void 0 : core2.makeConfiguration(options !== null && options !== void 0 ? options : {}, events2), [core2, options]);
      (0, react_1.useEffect)(() => {
        if (!core2 || !thebeConfig || server)
          return;
        const svr = new core2.ThebeServer(thebeConfig);
        const handler = (evt, data) => {
          const subjects = [
            core2.EventSubject.server,
            core2.EventSubject.session,
            core2.EventSubject.kernel
          ];
          if (data.subject && subjects.includes(data.subject)) {
            setError(`${data.status} - ${data.message}`);
          }
        };
        thebeConfig.events.on(core2.ThebeEventType.error, handler);
        setServer(svr);
      }, [core2, thebeConfig, server]);
      const connectToServer = () => {
        if (!server)
          return;
        setConnecting(true);
        if (customConnectFn)
          customConnectFn(server);
        else if (useBinder)
          server.connectToServerViaBinder(customRepoProviders);
        else if (useJupyterLite)
          server.connectToJupyterLiteServer({
            litePluginSettings: {
              "@jupyterlite/pyodide-kernel-extension:kernel": {
                pipliteUrls: ["https://unpkg.com/@jupyterlite/pyodide-kernel@0.2.3/pypi/all.json"],
                pipliteWheelUrl: "https://unpkg.com/@jupyterlite/pyodide-kernel@0.2.3/pypi/piplite-0.2.3-py3-none-any.whl"
              }
            }
          });
        else
          server.connectToJupyterServer();
        server.ready.then(() => {
          setConnecting(false);
          setReady(true);
        }, () => {
          setConnecting(false);
          setReady(false);
        });
        return server.ready;
      };
      (0, react_1.useEffect)(() => {
        if (!core2 || !thebeConfig)
          return;
        if (!server || !doConnect)
          return;
        if (server.isReady && server.userServerUrl)
          return;
        connectToServer();
      }, [server, doConnect]);
      return (0, jsx_runtime_1.jsx)(exports2.ThebeServerContext.Provider, Object.assign({ value: {
        config: thebeConfig,
        events: events2 !== null && events2 !== void 0 ? events2 : thebeConfig === null || thebeConfig === void 0 ? void 0 : thebeConfig.events,
        server,
        connecting,
        ready: ((_a = server === null || server === void 0 ? void 0 : server.isReady) !== null && _a !== void 0 ? _a : false) && ready,
        connect: connectToServer,
        disconnect: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (core2 && thebeConfig && server) {
            server.dispose();
            setServer(new core2.ThebeServer(thebeConfig));
          }
          setReady(false);
          setDoConnect(false);
          setConnecting(false);
          setError(void 0);
        }),
        error
      } }, { children }));
    }
    exports2.ThebeServerProvider = ThebeServerProvider2;
    function useThebeConfig3() {
      const serverContext = (0, react_1.useContext)(exports2.ThebeServerContext);
      if (serverContext === void 0) {
        throw new Error("useThebeServer must be used inside a ThebeServerProvider");
      }
      return { config: serverContext.config };
    }
    exports2.useThebeConfig = useThebeConfig3;
    function useDisposeThebeServer() {
      const [disposed, setDisposed] = (0, react_1.useState)(false);
      const serverContext = (0, react_1.useContext)(exports2.ThebeServerContext);
      if (serverContext === void 0) {
        throw new Error("useThebeServer must be used inside a ThebeServerProvider");
      }
      const { server, ready } = serverContext;
      (0, react_1.useEffect)(() => {
        if (!server || !ready)
          return;
        Promise.resolve().then(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield server.shutdownAllSessions();
          server.dispose();
          setDisposed(true);
        }));
      }, [ready, server]);
      return disposed;
    }
    exports2.useDisposeThebeServer = useDisposeThebeServer;
    function useThebeServer5() {
      const thebe = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { core: core2 } = thebe !== null && thebe !== void 0 ? thebe : {};
      const serverContext = (0, react_1.useContext)(exports2.ThebeServerContext);
      const { config, events: events2, server, connecting, ready, connect, disconnect, error } = serverContext !== null && serverContext !== void 0 ? serverContext : {
        ready: false,
        connecting: false
      };
      const [eventCallbacks, setEventCallbacks] = (0, react_1.useState)([]);
      const subscribe = (0, react_1.useCallback)((fn) => {
        if (!core2 || !config || !server)
          return;
        const callbackFn = (evt, data) => {
          const subjects = [
            core2.EventSubject.server,
            core2.EventSubject.session,
            core2.EventSubject.kernel
          ];
          if (data.subject && subjects.includes(data.subject))
            fn(data);
        };
        config === null || config === void 0 ? void 0 : config.events.on(core2.ThebeEventType.status, callbackFn);
        setEventCallbacks([...eventCallbacks, callbackFn]);
      }, [config, server]);
      const unsubAll = (0, react_1.useCallback)(() => {
        if (!core2)
          return;
        eventCallbacks.forEach((cb2) => {
          config === null || config === void 0 ? void 0 : config.events.off(core2.ThebeEventType.status, cb2);
        });
        setEventCallbacks([]);
      }, [config, server]);
      return serverContext ? {
        config,
        events: events2,
        server,
        connecting,
        ready,
        error,
        connect,
        disconnect,
        subscribe,
        unsubAll
      } : { connecting: false, ready: false };
    }
    exports2.useThebeServer = useThebeServer5;
  }
});

// ../../node_modules/thebe-react/dist/ThebeRenderMimeRegistryProvider.js
var require_ThebeRenderMimeRegistryProvider = __commonJS({
  "../../node_modules/thebe-react/dist/ThebeRenderMimeRegistryProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useRenderMimeRegistry = exports2.ThebeRenderMimeRegistryProvider = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importDefault(require_react());
    var ThebeLoaderProvider_1 = require_ThebeLoaderProvider();
    var ThebeServerProvider_1 = require_ThebeServerProvider();
    var RenderMimeRegistryContext = react_1.default.createContext(void 0);
    function ThebeRenderMimeRegistryProvider({ children }) {
      const { core: core2 } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config } = (0, ThebeServerProvider_1.useThebeConfig)();
      const rendermime = react_1.default.useMemo(() => core2 === null || core2 === void 0 ? void 0 : core2.makeRenderMimeRegistry(config === null || config === void 0 ? void 0 : config.mathjax), [core2, config]);
      return (0, jsx_runtime_1.jsx)(RenderMimeRegistryContext.Provider, Object.assign({ value: { rendermime } }, { children }));
    }
    exports2.ThebeRenderMimeRegistryProvider = ThebeRenderMimeRegistryProvider;
    function useRenderMimeRegistry() {
      const context = react_1.default.useContext(RenderMimeRegistryContext);
      return context === null || context === void 0 ? void 0 : context.rendermime;
    }
    exports2.useRenderMimeRegistry = useRenderMimeRegistry;
  }
});

// ../../node_modules/thebe-react/dist/ThebeSessionProvider.js
var require_ThebeSessionProvider = __commonJS({
  "../../node_modules/thebe-react/dist/ThebeSessionProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useThebeSession = exports2.ThebeSessionProvider = exports2.ThebeSessionContext = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importStar(require_react());
    var ThebeServerProvider_1 = require_ThebeServerProvider();
    var ThebeRenderMimeRegistryProvider_1 = require_ThebeRenderMimeRegistryProvider();
    var ThebeLoaderProvider_1 = require_ThebeLoaderProvider();
    exports2.ThebeSessionContext = react_1.default.createContext(void 0);
    function ThebeSessionProvider({ start = true, path: path2, shutdownOnUnmount = false, children }) {
      const { core: core2 } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config, server, ready: serverReady } = (0, ThebeServerProvider_1.useThebeServer)();
      const rendermime = (0, ThebeRenderMimeRegistryProvider_1.useRenderMimeRegistry)();
      const [doStart, setDoStart] = (0, react_1.useState)(start);
      const [starting, setStarting] = (0, react_1.useState)(false);
      const [session, setSession] = (0, react_1.useState)();
      const [ready, setReady] = (0, react_1.useState)(false);
      const [error, setError] = (0, react_1.useState)();
      const [unsubscribe, setUnsubscribe] = (0, react_1.useState)();
      (0, react_1.useEffect)(() => {
        if (!server || !serverReady || !doStart || starting || ready)
          return;
        startSession();
      }, [ready, doStart, starting, server, serverReady]);
      (0, react_1.useEffect)(() => {
        if (!core2 || !config || !session)
          return;
        const handler = (evt, data) => {
          const subjects = [core2.EventSubject.session, core2.EventSubject.kernel];
          if (data.subject && subjects.includes(data.subject) && data.status === "shutdown" && data.id === session.id) {
            setError(`session ${session.path} - ${data.status} - ${data.message}`);
          }
        };
        setUnsubscribe(config.events.on(core2.ThebeEventType.status, handler));
      }, [core2, config, session]);
      const startSession = () => {
        if (!rendermime)
          throw new Error("ThebeSessionProvider requires a RenderMimeRegistryProvider");
        setStarting(true);
        server === null || server === void 0 ? void 0 : server.startNewSession(rendermime, { path: path2 }).then((sesh) => {
          setStarting(false);
          if (sesh == null) {
            server === null || server === void 0 ? void 0 : server.getKernelSpecs().then((specs) => {
              setError(`Could not start a session - available kernels: ${Object.keys(specs.kernelspecs)}`);
            });
            return;
          }
          setSession(sesh);
          setReady(true);
        }, (err) => {
          setError(typeof err === "object" ? err.message : JSON.stringify(err));
          setReady(false);
          setDoStart(false);
          setStarting(false);
        });
      };
      (0, react_1.useEffect)(() => {
        return () => {
          if (shutdownOnUnmount) {
            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();
            setUnsubscribe(void 0);
            session === null || session === void 0 ? void 0 : session.shutdown().then(() => {
              setReady(false);
              setStarting(false);
              setError(void 0);
            });
          }
        };
      }, [session]);
      return (0, jsx_runtime_1.jsx)(exports2.ThebeSessionContext.Provider, Object.assign({ value: {
        path: path2,
        starting,
        ready,
        session,
        // eslint-disable-next-line @typescript-eslint/no-shadow
        start: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!!session && ready) {
            yield session.restart();
          } else {
            startSession();
          }
        }),
        shutdown: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (session) {
            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();
            setUnsubscribe(void 0);
            yield session.shutdown();
            setSession(void 0);
            setReady(false);
            setStarting(false);
            setError(void 0);
          }
        }),
        error
      } }, { children }));
    }
    exports2.ThebeSessionProvider = ThebeSessionProvider;
    function useThebeSession() {
      const sessionContext = (0, react_1.useContext)(exports2.ThebeSessionContext);
      return sessionContext !== null && sessionContext !== void 0 ? sessionContext : { starting: false, ready: false };
    }
    exports2.useThebeSession = useThebeSession;
  }
});

// ../../node_modules/thebe-react/dist/hooks/notebook.js
var require_notebook = __commonJS({
  "../../node_modules/thebe-react/dist/hooks/notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useNotebookfromSourceLegacy = exports2.useNotebookFromSource = exports2.useNotebook = exports2.useNotebookBase = exports2.findErrors = void 0;
    var react_1 = require_react();
    var ThebeServerProvider_1 = require_ThebeServerProvider();
    var ThebeLoaderProvider_1 = require_ThebeLoaderProvider();
    var ThebeSessionProvider_1 = require_ThebeSessionProvider();
    var ThebeRenderMimeRegistryProvider_1 = require_ThebeRenderMimeRegistryProvider();
    function findErrors2(execReturns) {
      return execReturns.reduce((acc, retval, index2) => {
        if (retval === null || retval === void 0 ? void 0 : retval.error) {
          if (acc == null)
            return [Object.assign(Object.assign({}, retval), { index: index2 })];
          else
            return [...acc, Object.assign(Object.assign({}, retval), { index: index2 })];
        }
        return acc;
      }, null);
    }
    exports2.findErrors = findErrors2;
    function useNotebookBase() {
      const { session, ready: sessionReady } = (0, ThebeSessionProvider_1.useThebeSession)();
      const [notebook, setNotebook] = (0, react_1.useState)();
      const [refs, setRefs] = (0, react_1.useState)([]);
      const [sessionAttached, setSessionAttached] = (0, react_1.useState)(false);
      const [executing, setExecuting] = (0, react_1.useState)(false);
      const [executed, setExecuted] = (0, react_1.useState)(false);
      const [errors, setErrors] = (0, react_1.useState)(null);
      (0, react_1.useEffect)(() => {
        if (!notebook || !session || !sessionReady)
          return;
        console.debug(`thebe-react: attaching notebook to session`, { notebook, session });
        notebook.attachSession(session);
        setSessionAttached(true);
      }, [notebook, session, sessionReady]);
      const executeAll = (options) => {
        var _a, _b;
        if (!notebook)
          throw new Error("executeAll called before notebook available");
        if (!session)
          throw new Error("executeAll called before session available");
        (_a = options === null || options === void 0 ? void 0 : options.before) === null || _a === void 0 ? void 0 : _a.call(options);
        setExecuting(true);
        return notebook.executeAll((_b = options === null || options === void 0 ? void 0 : options.stopOnError) !== null && _b !== void 0 ? _b : true, options === null || options === void 0 ? void 0 : options.preprocessor).then((execReturns) => {
          var _a2;
          (_a2 = options === null || options === void 0 ? void 0 : options.after) === null || _a2 === void 0 ? void 0 : _a2.call(options);
          const errs = findErrors2(execReturns);
          if (errs != null)
            setErrors(errs);
          setExecuted(true);
          setExecuting(false);
          return execReturns;
        });
      };
      const executeSome = (predicate, options) => {
        var _a, _b;
        if (!notebook)
          throw new Error("executeSome called before notebook available");
        if (!session)
          throw new Error("executeAll called before session available");
        (_a = options === null || options === void 0 ? void 0 : options.before) === null || _a === void 0 ? void 0 : _a.call(options);
        setExecuting(true);
        const filteredCells = notebook.cells.filter(predicate).map((c6) => c6.id);
        return notebook.executeCells(filteredCells, (_b = options === null || options === void 0 ? void 0 : options.stopOnError) !== null && _b !== void 0 ? _b : true, options === null || options === void 0 ? void 0 : options.preprocessor).then((execReturns) => {
          var _a2;
          (_a2 = options === null || options === void 0 ? void 0 : options.after) === null || _a2 === void 0 ? void 0 : _a2.call(options);
          const errs = findErrors2(execReturns);
          if (errs != null)
            setErrors(errs);
          setExecuted(true);
          setExecuting(false);
          return execReturns;
        });
      };
      const clear = () => {
        if (!notebook)
          throw new Error("clear called before notebook available");
        notebook.clear();
        setExecuted(false);
      };
      return {
        ready: !!notebook && sessionAttached,
        attached: sessionAttached,
        executing,
        executed,
        errors,
        notebook,
        setNotebook,
        refs,
        setRefs,
        executeAll,
        executeSome,
        clear,
        session
      };
    }
    exports2.useNotebookBase = useNotebookBase;
    function useNotebook(name2, fetchNotebook, opts = { refsForWidgetsOnly: true }) {
      var _a, _b;
      const { core: core2 } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config } = (0, ThebeServerProvider_1.useThebeConfig)();
      const rendermime = (0, ThebeRenderMimeRegistryProvider_1.useRenderMimeRegistry)();
      const [loading, setLoading] = (0, react_1.useState)(false);
      if (!rendermime)
        throw new Error("ThebeSessionProvider requires a RenderMimeRegistryProvider");
      const { ready, attached, executing, executed, errors, notebook, setNotebook, refs, setRefs, executeAll, executeSome, clear, session } = useNotebookBase();
      (0, react_1.useEffect)(() => {
        if (!core2 || !config)
          return;
        setLoading(true);
        fetchNotebook(name2).then((ipynb) => {
          return core2 === null || core2 === void 0 ? void 0 : core2.ThebeNotebook.fromIpynb(ipynb, config, rendermime);
        }).then((nb) => {
          var _a2, _b2;
          const cells = (opts === null || opts === void 0 ? void 0 : opts.refsForWidgetsOnly) ? (_a2 = nb === null || nb === void 0 ? void 0 : nb.widgets) !== null && _a2 !== void 0 ? _a2 : [] : (_b2 = nb === null || nb === void 0 ? void 0 : nb.cells) !== null && _b2 !== void 0 ? _b2 : [];
          setRefs(Array(cells.length).fill(null).map((_5, idx) => (node) => {
            console.debug(`new ref[${idx}] - attaching to dom...`, node);
            if (node != null)
              cells[idx].attachToDOM(node);
          }));
          setNotebook(nb);
          setLoading(false);
        });
      }, [core2, config]);
      return {
        ready,
        loading,
        attached,
        executing,
        executed,
        errors,
        notebook,
        cellRefs: refs,
        cellIds: (opts.refsForWidgetsOnly ? (_a = notebook === null || notebook === void 0 ? void 0 : notebook.widgets) !== null && _a !== void 0 ? _a : [] : (_b = notebook === null || notebook === void 0 ? void 0 : notebook.cells) !== null && _b !== void 0 ? _b : []).map((c6) => c6.id),
        executeAll,
        executeSome,
        clear,
        session
      };
    }
    exports2.useNotebook = useNotebook;
    function useNotebookFromSource(sourceCode, opts = { refsForWidgetsOnly: true }) {
      var _a, _b;
      const { core: core2 } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config } = (0, ThebeServerProvider_1.useThebeConfig)();
      const rendermime = (0, ThebeRenderMimeRegistryProvider_1.useRenderMimeRegistry)();
      const [loading, setLoading] = (0, react_1.useState)(false);
      if (!rendermime)
        throw new Error("ThebeSessionProvider requires a RenderMimeRegistryProvider");
      const { ready, attached, executing, executed, errors, notebook, setNotebook, refs, setRefs, executeAll, executeSome, clear, session } = useNotebookBase();
      (0, react_1.useEffect)(() => {
        var _a2, _b2;
        if (!core2 || !config || loading || notebook)
          return;
        setLoading(true);
        const nb = core2.ThebeNotebook.fromCodeBlocks(sourceCode.map((source) => ({ id: core2 === null || core2 === void 0 ? void 0 : core2.shortId(), source })), config, rendermime);
        const cells = (opts === null || opts === void 0 ? void 0 : opts.refsForWidgetsOnly) ? (_a2 = nb === null || nb === void 0 ? void 0 : nb.widgets) !== null && _a2 !== void 0 ? _a2 : [] : (_b2 = nb === null || nb === void 0 ? void 0 : nb.cells) !== null && _b2 !== void 0 ? _b2 : [];
        setRefs(Array(cells.length).fill(null).map((_5, idx) => (node) => {
          console.debug(`new ref[${idx}] - attaching to dom...`, node);
          if (node != null)
            cells[idx].attachToDOM(node);
        }));
        setNotebook(nb);
        setLoading(false);
      }, [core2, notebook, loading]);
      return {
        ready,
        loading,
        attached,
        executing,
        executed,
        errors,
        notebook,
        cellRefs: refs,
        cellIds: (opts.refsForWidgetsOnly ? (_a = notebook === null || notebook === void 0 ? void 0 : notebook.widgets) !== null && _a !== void 0 ? _a : [] : (_b = notebook === null || notebook === void 0 ? void 0 : notebook.cells) !== null && _b !== void 0 ? _b : []).map((c6) => c6.id),
        executeAll,
        executeSome,
        clear,
        session
      };
    }
    exports2.useNotebookFromSource = useNotebookFromSource;
    function useNotebookfromSourceLegacy(sourceCode) {
      const { core: core2 } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config } = (0, ThebeServerProvider_1.useThebeConfig)();
      const rendermime = (0, ThebeRenderMimeRegistryProvider_1.useRenderMimeRegistry)();
      if (!rendermime)
        throw new Error("ThebeSessionProvider requires a RenderMimeRegistryProvider");
      const [busy, setBusy] = (0, react_1.useState)(false);
      const [notebook, setNotebook] = (0, react_1.useState)();
      const [_5, setReRender] = (0, react_1.useState)({});
      const [cellRefs] = (0, react_1.useState)(Array(sourceCode.length).fill(void 0).map(() => (0, react_1.createRef)()));
      (0, react_1.useEffect)(() => {
        if (!core2 || !config || notebook)
          return;
        setNotebook(core2.ThebeNotebook.fromCodeBlocks(sourceCode.map((source) => ({ id: core2 === null || core2 === void 0 ? void 0 : core2.shortId(), source })), config, rendermime));
      }, [core2, notebook]);
      const execute = () => {
        if (!notebook)
          throw new Error("execute called before notebook available");
        setBusy(true);
        notebook.executeAll().then(() => {
          setBusy(false);
        });
      };
      const attach = (session) => {
        if (session.kernel == null)
          return;
        if (!notebook) {
          console.warn("attach called before notebook available");
          return;
        }
        notebook === null || notebook === void 0 ? void 0 : notebook.detachSession();
        notebook === null || notebook === void 0 ? void 0 : notebook.attachSession(session);
        notebook === null || notebook === void 0 ? void 0 : notebook.cells.forEach((cell, idx) => {
          var _a;
          if (cellRefs[idx].current)
            cell.attachToDOM((_a = cellRefs[idx].current) !== null && _a !== void 0 ? _a : void 0);
        });
      };
      return {
        notebook,
        busy,
        execute,
        attach,
        cellRefs,
        rerender: () => setReRender({})
      };
    }
    exports2.useNotebookfromSourceLegacy = useNotebookfromSourceLegacy;
  }
});

// ../../node_modules/thebe-react/dist/hooks/interpolate.js
var require_interpolate = __commonJS({
  "../../node_modules/thebe-react/dist/hooks/interpolate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.interpolatorFactoryFn = exports2.PYTHON_PARAM = void 0;
    exports2.PYTHON_PARAM = /^(.*)=([^;]*);*\s*#\|*\s*@param\s*(.*)$/;
    function interpolatorFactoryFn(parameterMap) {
      return (source) => {
        const params = new Set(Object.keys(parameterMap));
        const lines = source.split("\n");
        const interpolated = lines.map((line) => {
          if (exports2.PYTHON_PARAM.test(line)) {
            const match = line.match(exports2.PYTHON_PARAM);
            if (match != null) {
              const [_5, variable, value, schemaString] = match;
              let schema2 = {};
              try {
                if (schemaString !== "")
                  schema2 = JSON.parse(schemaString);
              } catch (err) {
                console.error("Could not parse schema from", line, err);
              }
              if (params.has(variable.trim())) {
                return `${variable}= ${parameterMap[variable.trim()]} #| @param${schema2 ? ` ${JSON.stringify(Object.assign(Object.assign({}, schema2), { last: value }))}` : ""}`;
              }
            }
          }
          return line;
        });
        return interpolated.join("\n");
      };
    }
    exports2.interpolatorFactoryFn = interpolatorFactoryFn;
  }
});

// ../../node_modules/thebe-react/dist/hooks/index.js
var require_hooks = __commonJS({
  "../../node_modules/thebe-react/dist/hooks/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_notebook(), exports2);
    tslib_1.__exportStar(require_interpolate(), exports2);
  }
});

// ../../node_modules/thebe-react/dist/index.js
var require_dist3 = __commonJS({
  "../../node_modules/thebe-react/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_OutputAreaByRef(), exports2);
    tslib_1.__exportStar(require_ThebeLoaderProvider(), exports2);
    tslib_1.__exportStar(require_ThebeServerProvider(), exports2);
    tslib_1.__exportStar(require_ThebeSessionProvider(), exports2);
    tslib_1.__exportStar(require_ThebeRenderMimeRegistryProvider(), exports2);
    tslib_1.__exportStar(require_hooks(), exports2);
  }
});

// ../../node_modules/anser/lib/index.js
var require_lib14 = __commonJS({
  "../../node_modules/anser/lib/index.js"(exports2, module2) {
    "use strict";
    var _createClass2 = function() {
      function defineProperties(target, props) {
        for (var i5 = 0; i5 < props.length; i5++) {
          var descriptor = props[i5];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ANSI_COLORS = [[{ color: "0, 0, 0", "class": "ansi-black" }, { color: "187, 0, 0", "class": "ansi-red" }, { color: "0, 187, 0", "class": "ansi-green" }, { color: "187, 187, 0", "class": "ansi-yellow" }, { color: "0, 0, 187", "class": "ansi-blue" }, { color: "187, 0, 187", "class": "ansi-magenta" }, { color: "0, 187, 187", "class": "ansi-cyan" }, { color: "255,255,255", "class": "ansi-white" }], [{ color: "85, 85, 85", "class": "ansi-bright-black" }, { color: "255, 85, 85", "class": "ansi-bright-red" }, { color: "0, 255, 0", "class": "ansi-bright-green" }, { color: "255, 255, 85", "class": "ansi-bright-yellow" }, { color: "85, 85, 255", "class": "ansi-bright-blue" }, { color: "255, 85, 255", "class": "ansi-bright-magenta" }, { color: "85, 255, 255", "class": "ansi-bright-cyan" }, { color: "255, 255, 255", "class": "ansi-bright-white" }]];
    var Anser2 = function() {
      _createClass2(Anser3, null, [{
        key: "escapeForHtml",
        /**
         * Anser.escapeForHtml
         * Escape the input HTML.
         *
         * This does the minimum escaping of text to make it compliant with HTML.
         * In particular, the '&','<', and '>' characters are escaped. This should
         * be run prior to `ansiToHtml`.
         *
         * @name Anser.escapeForHtml
         * @function
         * @param {String} txt The input text (containing the ANSI snippets).
         * @returns {String} The escaped html.
         */
        value: function escapeForHtml(txt) {
          return new Anser3().escapeForHtml(txt);
        }
        /**
         * Anser.linkify
         * Adds the links in the HTML.
         *
         * This replaces any links in the text with anchor tags that display the
         * link. The links should have at least one whitespace character
         * surrounding it. Also, you should apply this after you have run
         * `ansiToHtml` on the text.
         *
         * @name Anser.linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML containing the <a> tags (unescaped).
         */
      }, {
        key: "linkify",
        value: function linkify(txt) {
          return new Anser3().linkify(txt);
        }
        /**
         * Anser.ansiToHtml
         * This replaces ANSI terminal escape codes with SPAN tags that wrap the
         * content.
         *
         * This function only interprets ANSI SGR (Select Graphic Rendition) codes
         * that can be represented in HTML.
         * For example, cursor movement codes are ignored and hidden from output.
         * The default style uses colors that are very close to the prescribed
         * standard. The standard assumes that the text will have a black
         * background. These colors are set as inline styles on the SPAN tags.
         *
         * Another option is to set `use_classes: true` in the options argument.
         * This will instead set classes on the spans so the colors can be set via
         * CSS. The class names used are of the format `ansi-*-fg/bg` and
         * `ansi-bright-*-fg/bg` where `*` is the color name,
         * i.e black/red/green/yellow/blue/magenta/cyan/white.
         *
         * @name Anser.ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
          return new Anser3().ansiToHtml(txt, options);
        }
        /**
         * Anser.ansiToJson
         * Converts ANSI input into JSON output.
         *
         * @name Anser.ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
          return new Anser3().ansiToJson(txt, options);
        }
        /**
         * Anser.ansiToText
         * Converts ANSI input into text output.
         *
         * @name Anser.ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */
      }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
          return new Anser3().ansiToText(txt);
        }
        /**
         * Anser
         * The `Anser` class.
         *
         * @name Anser
         * @function
         * @returns {Anser}
         */
      }]);
      function Anser3() {
        _classCallCheck2(this, Anser3);
        this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
        this.bright = 0;
        this.decorations = [];
      }
      _createClass2(Anser3, [{
        key: "setupPalette",
        value: function setupPalette() {
          this.PALETTE_COLORS = [];
          for (var i5 = 0; i5 < 2; ++i5) {
            for (var j2 = 0; j2 < 8; ++j2) {
              this.PALETTE_COLORS.push(ANSI_COLORS[i5][j2].color);
            }
          }
          var levels = [0, 95, 135, 175, 215, 255];
          var format2 = function format3(r5, g5, b5) {
            return levels[r5] + ", " + levels[g5] + ", " + levels[b5];
          };
          var r4 = void 0, g4 = void 0, b4 = void 0;
          for (var _r = 0; _r < 6; ++_r) {
            for (var _g = 0; _g < 6; ++_g) {
              for (var _b = 0; _b < 6; ++_b) {
                this.PALETTE_COLORS.push(format2(_r, _g, _b));
              }
            }
          }
          var level = 8;
          for (var _i = 0; _i < 24; ++_i, level += 10) {
            this.PALETTE_COLORS.push(format2(level, level, level));
          }
        }
        /**
         * escapeForHtml
         * Escapes the input text.
         *
         * @name escapeForHtml
         * @function
         * @param {String} txt The input text.
         * @returns {String} The escpaed HTML output.
         */
      }, {
        key: "escapeForHtml",
        value: function escapeForHtml(txt) {
          return txt.replace(/[&<>\"]/gm, function(str2) {
            return str2 == "&" ? "&amp;" : str2 == '"' ? "&quot;" : str2 == "<" ? "&lt;" : str2 == ">" ? "&gt;" : "";
          });
        }
        /**
         * linkify
         * Adds HTML link elements.
         *
         * @name linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML output containing link elements.
         */
      }, {
        key: "linkify",
        value: function linkify(txt) {
          return txt.replace(/(https?:\/\/[^\s]+)/gm, function(str2) {
            return '<a href="' + str2 + '">' + str2 + "</a>";
          });
        }
        /**
         * ansiToHtml
         * Converts ANSI input into HTML output.
         *
         * @name ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
          return this.process(txt, options, true);
        }
        /**
         * ansiToJson
         * Converts ANSI input into HTML output.
         *
         * @name ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The JSON output.
         */
      }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
          options = options || {};
          options.json = true;
          options.clearLine = false;
          return this.process(txt, options, true);
        }
        /**
         * ansiToText
         * Converts ANSI input into HTML output.
         *
         * @name ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */
      }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
          return this.process(txt, {}, false);
        }
        /**
         * process
         * Processes the input.
         *
         * @name process
         * @function
         * @param {String} txt The input text.
         * @param {Object} options An object passed to `processChunk` method, extended with:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup
         */
      }, {
        key: "process",
        value: function process2(txt, options, markup) {
          var _this = this;
          var self2 = this;
          var raw_text_chunks = txt.split(/\033\[/);
          var first_chunk = raw_text_chunks.shift();
          if (options === void 0 || options === null) {
            options = {};
          }
          options.clearLine = /\r/.test(txt);
          var color_chunks = raw_text_chunks.map(function(chunk2) {
            return _this.processChunk(chunk2, options, markup);
          });
          if (options && options.json) {
            var first2 = self2.processChunkJson("");
            first2.content = first_chunk;
            first2.clearLine = options.clearLine;
            color_chunks.unshift(first2);
            if (options.remove_empty) {
              color_chunks = color_chunks.filter(function(c6) {
                return !c6.isEmpty();
              });
            }
            return color_chunks;
          } else {
            color_chunks.unshift(first_chunk);
          }
          return color_chunks.join("");
        }
        /**
         * processChunkJson
         * Processes the current chunk into json output.
         *
         * @name processChunkJson
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object} The result object:
         *
         *  - `content` (String): The text.
         *  - `fg` (String|null): The foreground color.
         *  - `bg` (String|null): The background color.
         *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
         *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
         *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
         *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
         *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
         *
         */
      }, {
        key: "processChunkJson",
        value: function processChunkJson(text, options, markup) {
          options = typeof options == "undefined" ? {} : options;
          var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
          var key = options.key = use_classes ? "class" : "color";
          var result2 = {
            content: text,
            fg: null,
            bg: null,
            fg_truecolor: null,
            bg_truecolor: null,
            isInverted: false,
            clearLine: options.clearLine,
            decoration: null,
            decorations: [],
            was_processed: false,
            isEmpty: function isEmpty2() {
              return !result2.content;
            }
          };
          var matches = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);
          if (!matches)
            return result2;
          var orig_txt = result2.content = matches[4];
          var nums = matches[2].split(";");
          if (matches[1] !== "" || matches[3] !== "m") {
            return result2;
          }
          if (!markup) {
            return result2;
          }
          var self2 = this;
          while (nums.length > 0) {
            var num_str = nums.shift();
            var num = parseInt(num_str);
            if (isNaN(num) || num === 0) {
              self2.fg = self2.bg = null;
              self2.decorations = [];
            } else if (num === 1) {
              self2.decorations.push("bold");
            } else if (num === 2) {
              self2.decorations.push("dim");
            } else if (num === 3) {
              self2.decorations.push("italic");
            } else if (num === 4) {
              self2.decorations.push("underline");
            } else if (num === 5) {
              self2.decorations.push("blink");
            } else if (num === 7) {
              self2.decorations.push("reverse");
            } else if (num === 8) {
              self2.decorations.push("hidden");
            } else if (num === 9) {
              self2.decorations.push("strikethrough");
            } else if (num === 21) {
              self2.removeDecoration("bold");
            } else if (num === 22) {
              self2.removeDecoration("bold");
              self2.removeDecoration("dim");
            } else if (num === 23) {
              self2.removeDecoration("italic");
            } else if (num === 24) {
              self2.removeDecoration("underline");
            } else if (num === 25) {
              self2.removeDecoration("blink");
            } else if (num === 27) {
              self2.removeDecoration("reverse");
            } else if (num === 28) {
              self2.removeDecoration("hidden");
            } else if (num === 29) {
              self2.removeDecoration("strikethrough");
            } else if (num === 39) {
              self2.fg = null;
            } else if (num === 49) {
              self2.bg = null;
            } else if (num >= 30 && num < 38) {
              self2.fg = ANSI_COLORS[0][num % 10][key];
            } else if (num >= 90 && num < 98) {
              self2.fg = ANSI_COLORS[1][num % 10][key];
            } else if (num >= 40 && num < 48) {
              self2.bg = ANSI_COLORS[0][num % 10][key];
            } else if (num >= 100 && num < 108) {
              self2.bg = ANSI_COLORS[1][num % 10][key];
            } else if (num === 38 || num === 48) {
              var is_foreground = num === 38;
              if (nums.length >= 1) {
                var mode = nums.shift();
                if (mode === "5" && nums.length >= 1) {
                  var palette_index = parseInt(nums.shift());
                  if (palette_index >= 0 && palette_index <= 255) {
                    if (!use_classes) {
                      if (!this.PALETTE_COLORS) {
                        self2.setupPalette();
                      }
                      if (is_foreground) {
                        self2.fg = this.PALETTE_COLORS[palette_index];
                      } else {
                        self2.bg = this.PALETTE_COLORS[palette_index];
                      }
                    } else {
                      var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                      if (is_foreground) {
                        self2.fg = klass;
                      } else {
                        self2.bg = klass;
                      }
                    }
                  }
                } else if (mode === "2" && nums.length >= 3) {
                  var r4 = parseInt(nums.shift());
                  var g4 = parseInt(nums.shift());
                  var b4 = parseInt(nums.shift());
                  if (r4 >= 0 && r4 <= 255 && g4 >= 0 && g4 <= 255 && b4 >= 0 && b4 <= 255) {
                    var color2 = r4 + ", " + g4 + ", " + b4;
                    if (!use_classes) {
                      if (is_foreground) {
                        self2.fg = color2;
                      } else {
                        self2.bg = color2;
                      }
                    } else {
                      if (is_foreground) {
                        self2.fg = "ansi-truecolor";
                        self2.fg_truecolor = color2;
                      } else {
                        self2.bg = "ansi-truecolor";
                        self2.bg_truecolor = color2;
                      }
                    }
                  }
                }
              }
            }
          }
          if (self2.fg === null && self2.bg === null && self2.decorations.length === 0) {
            return result2;
          } else {
            var styles = [];
            var classes = [];
            var data = {};
            result2.fg = self2.fg;
            result2.bg = self2.bg;
            result2.fg_truecolor = self2.fg_truecolor;
            result2.bg_truecolor = self2.bg_truecolor;
            result2.decorations = self2.decorations;
            result2.decoration = self2.decorations.slice(-1).pop() || null;
            result2.was_processed = true;
            return result2;
          }
        }
        /**
         * processChunk
         * Processes the current chunk of text.
         *
         * @name processChunk
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
         */
      }, {
        key: "processChunk",
        value: function processChunk(text, options, markup) {
          var _this2 = this;
          options = options || {};
          var jsonChunk = this.processChunkJson(text, options, markup);
          var use_classes = options.use_classes;
          jsonChunk.decorations = jsonChunk.decorations.filter(function(decoration) {
            if (decoration === "reverse") {
              if (!jsonChunk.fg) {
                jsonChunk.fg = ANSI_COLORS[0][7][use_classes ? "class" : "color"];
              }
              if (!jsonChunk.bg) {
                jsonChunk.bg = ANSI_COLORS[0][0][use_classes ? "class" : "color"];
              }
              var tmpFg = jsonChunk.fg;
              jsonChunk.fg = jsonChunk.bg;
              jsonChunk.bg = tmpFg;
              var tmpFgTrue = jsonChunk.fg_truecolor;
              jsonChunk.fg_truecolor = jsonChunk.bg_truecolor;
              jsonChunk.bg_truecolor = tmpFgTrue;
              jsonChunk.isInverted = true;
              return false;
            }
            return true;
          });
          if (options.json) {
            return jsonChunk;
          }
          if (jsonChunk.isEmpty()) {
            return "";
          }
          if (!jsonChunk.was_processed) {
            return jsonChunk.content;
          }
          var colors = [];
          var decorations = [];
          var textDecorations = [];
          var data = {};
          var render_data = function render_data2(data2) {
            var fragments = [];
            var key = void 0;
            for (key in data2) {
              if (data2.hasOwnProperty(key)) {
                fragments.push("data-" + key + '="' + _this2.escapeForHtml(data2[key]) + '"');
              }
            }
            return fragments.length > 0 ? " " + fragments.join(" ") : "";
          };
          if (jsonChunk.isInverted) {
            data["ansi-is-inverted"] = "true";
          }
          if (jsonChunk.fg) {
            if (use_classes) {
              colors.push(jsonChunk.fg + "-fg");
              if (jsonChunk.fg_truecolor !== null) {
                data["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
                jsonChunk.fg_truecolor = null;
              }
            } else {
              colors.push("color:rgb(" + jsonChunk.fg + ")");
            }
          }
          if (jsonChunk.bg) {
            if (use_classes) {
              colors.push(jsonChunk.bg + "-bg");
              if (jsonChunk.bg_truecolor !== null) {
                data["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
                jsonChunk.bg_truecolor = null;
              }
            } else {
              colors.push("background-color:rgb(" + jsonChunk.bg + ")");
            }
          }
          jsonChunk.decorations.forEach(function(decoration) {
            if (use_classes) {
              decorations.push("ansi-" + decoration);
              return;
            }
            if (decoration === "bold") {
              decorations.push("font-weight:bold");
            } else if (decoration === "dim") {
              decorations.push("opacity:0.5");
            } else if (decoration === "italic") {
              decorations.push("font-style:italic");
            } else if (decoration === "hidden") {
              decorations.push("visibility:hidden");
            } else if (decoration === "strikethrough") {
              textDecorations.push("line-through");
            } else {
              textDecorations.push(decoration);
            }
          });
          if (textDecorations.length) {
            decorations.push("text-decoration:" + textDecorations.join(" "));
          }
          if (use_classes) {
            return '<span class="' + colors.concat(decorations).join(" ") + '"' + render_data(data) + ">" + jsonChunk.content + "</span>";
          } else {
            return '<span style="' + colors.concat(decorations).join(";") + '"' + render_data(data) + ">" + jsonChunk.content + "</span>";
          }
        }
      }, {
        key: "removeDecoration",
        value: function removeDecoration(decoration) {
          var index2 = this.decorations.indexOf(decoration);
          if (index2 >= 0) {
            this.decorations.splice(index2, 1);
          }
        }
      }]);
      return Anser3;
    }();
    module2.exports = Anser2;
  }
});

// ../../node_modules/escape-carriage/index.js
var require_escape_carriage = __commonJS({
  "../../node_modules/escape-carriage/index.js"(exports2, module2) {
    function escapeCarriageReturn2(txt) {
      if (!txt)
        return "";
      if (!/\r/.test(txt))
        return txt;
      txt = txt.replace(/\r+\n/gm, "\n");
      while (/\r./.test(txt)) {
        txt = txt.replace(/^([^\r\n]*)\r+([^\r\n]+)/gm, function(_5, base, insert) {
          return insert + base.slice(insert.length);
        });
      }
      return txt;
    }
    function findLongestString(arr) {
      var longest = 0;
      for (var i5 = 0; i5 < arr.length; i5++) {
        if (arr[longest].length <= arr[i5].length) {
          longest = i5;
        }
      }
      return longest;
    }
    function escapeSingleLineSafe(txt) {
      if (!/\r/.test(txt))
        return txt;
      var arr = txt.split("\r");
      var res = [];
      while (arr.length > 0) {
        var longest = findLongestString(arr);
        res.push(arr[longest]);
        arr = arr.slice(longest + 1);
      }
      return res.join("\r");
    }
    function escapeCarriageReturnSafe(txt) {
      if (!txt)
        return "";
      if (!/\r/.test(txt))
        return txt;
      if (!/\n/.test(txt))
        return escapeSingleLineSafe(txt);
      txt = txt.replace(/\r+\n/gm, "\n");
      var idx = txt.lastIndexOf("\n");
      return escapeCarriageReturn2(txt.slice(0, idx)) + "\n" + escapeSingleLineSafe(txt.slice(idx + 1));
    }
    module2.exports = escapeCarriageReturn2;
    module2.exports.escapeCarriageReturn = escapeCarriageReturn2;
    module2.exports.escapeCarriageReturnSafe = escapeCarriageReturnSafe;
  }
});

// ../../node_modules/lodash.throttle/index.js
var require_lodash2 = __commonJS({
  "../../node_modules/lodash.throttle/index.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root2.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject5(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result2 = func.apply(thisArg, args);
        return result2;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result2;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result3 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result3, maxWait - timeSinceLastInvoke) : result3;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result2;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result2 : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result2;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle3(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject5(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce2(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject5(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject5(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject5(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary2 = reIsBinary.test(value);
      return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = throttle3;
  }
});

// ../../node_modules/spdx-license-ids/index.json
var require_spdx_license_ids = __commonJS({
  "../../node_modules/spdx-license-ids/index.json"(exports2, module2) {
    module2.exports = [
      "0BSD",
      "AAL",
      "ADSL",
      "AFL-1.1",
      "AFL-1.2",
      "AFL-2.0",
      "AFL-2.1",
      "AFL-3.0",
      "AGPL-1.0-only",
      "AGPL-1.0-or-later",
      "AGPL-3.0-only",
      "AGPL-3.0-or-later",
      "AMDPLPA",
      "AML",
      "AMPAS",
      "ANTLR-PD",
      "ANTLR-PD-fallback",
      "APAFML",
      "APL-1.0",
      "APSL-1.0",
      "APSL-1.1",
      "APSL-1.2",
      "APSL-2.0",
      "ASWF-Digital-Assets-1.0",
      "ASWF-Digital-Assets-1.1",
      "Abstyles",
      "AdaCore-doc",
      "Adobe-2006",
      "Adobe-Glyph",
      "Afmparse",
      "Aladdin",
      "Apache-1.0",
      "Apache-1.1",
      "Apache-2.0",
      "App-s2p",
      "Arphic-1999",
      "Artistic-1.0",
      "Artistic-1.0-Perl",
      "Artistic-1.0-cl8",
      "Artistic-2.0",
      "BSD-1-Clause",
      "BSD-2-Clause",
      "BSD-2-Clause-Patent",
      "BSD-2-Clause-Views",
      "BSD-3-Clause",
      "BSD-3-Clause-Attribution",
      "BSD-3-Clause-Clear",
      "BSD-3-Clause-LBNL",
      "BSD-3-Clause-Modification",
      "BSD-3-Clause-No-Military-License",
      "BSD-3-Clause-No-Nuclear-License",
      "BSD-3-Clause-No-Nuclear-License-2014",
      "BSD-3-Clause-No-Nuclear-Warranty",
      "BSD-3-Clause-Open-MPI",
      "BSD-4-Clause",
      "BSD-4-Clause-Shortened",
      "BSD-4-Clause-UC",
      "BSD-4.3RENO",
      "BSD-4.3TAHOE",
      "BSD-Advertising-Acknowledgement",
      "BSD-Attribution-HPND-disclaimer",
      "BSD-Protection",
      "BSD-Source-Code",
      "BSL-1.0",
      "BUSL-1.1",
      "Baekmuk",
      "Bahyph",
      "Barr",
      "Beerware",
      "BitTorrent-1.0",
      "BitTorrent-1.1",
      "Bitstream-Charter",
      "Bitstream-Vera",
      "BlueOak-1.0.0",
      "Boehm-GC",
      "Borceux",
      "Brian-Gladman-3-Clause",
      "C-UDA-1.0",
      "CAL-1.0",
      "CAL-1.0-Combined-Work-Exception",
      "CATOSL-1.1",
      "CC-BY-1.0",
      "CC-BY-2.0",
      "CC-BY-2.5",
      "CC-BY-2.5-AU",
      "CC-BY-3.0",
      "CC-BY-3.0-AT",
      "CC-BY-3.0-DE",
      "CC-BY-3.0-IGO",
      "CC-BY-3.0-NL",
      "CC-BY-3.0-US",
      "CC-BY-4.0",
      "CC-BY-NC-1.0",
      "CC-BY-NC-2.0",
      "CC-BY-NC-2.5",
      "CC-BY-NC-3.0",
      "CC-BY-NC-3.0-DE",
      "CC-BY-NC-4.0",
      "CC-BY-NC-ND-1.0",
      "CC-BY-NC-ND-2.0",
      "CC-BY-NC-ND-2.5",
      "CC-BY-NC-ND-3.0",
      "CC-BY-NC-ND-3.0-DE",
      "CC-BY-NC-ND-3.0-IGO",
      "CC-BY-NC-ND-4.0",
      "CC-BY-NC-SA-1.0",
      "CC-BY-NC-SA-2.0",
      "CC-BY-NC-SA-2.0-DE",
      "CC-BY-NC-SA-2.0-FR",
      "CC-BY-NC-SA-2.0-UK",
      "CC-BY-NC-SA-2.5",
      "CC-BY-NC-SA-3.0",
      "CC-BY-NC-SA-3.0-DE",
      "CC-BY-NC-SA-3.0-IGO",
      "CC-BY-NC-SA-4.0",
      "CC-BY-ND-1.0",
      "CC-BY-ND-2.0",
      "CC-BY-ND-2.5",
      "CC-BY-ND-3.0",
      "CC-BY-ND-3.0-DE",
      "CC-BY-ND-4.0",
      "CC-BY-SA-1.0",
      "CC-BY-SA-2.0",
      "CC-BY-SA-2.0-UK",
      "CC-BY-SA-2.1-JP",
      "CC-BY-SA-2.5",
      "CC-BY-SA-3.0",
      "CC-BY-SA-3.0-AT",
      "CC-BY-SA-3.0-DE",
      "CC-BY-SA-3.0-IGO",
      "CC-BY-SA-4.0",
      "CC-PDDC",
      "CC0-1.0",
      "CDDL-1.0",
      "CDDL-1.1",
      "CDL-1.0",
      "CDLA-Permissive-1.0",
      "CDLA-Permissive-2.0",
      "CDLA-Sharing-1.0",
      "CECILL-1.0",
      "CECILL-1.1",
      "CECILL-2.0",
      "CECILL-2.1",
      "CECILL-B",
      "CECILL-C",
      "CERN-OHL-1.1",
      "CERN-OHL-1.2",
      "CERN-OHL-P-2.0",
      "CERN-OHL-S-2.0",
      "CERN-OHL-W-2.0",
      "CFITSIO",
      "CMU-Mach",
      "CNRI-Jython",
      "CNRI-Python",
      "CNRI-Python-GPL-Compatible",
      "COIL-1.0",
      "CPAL-1.0",
      "CPL-1.0",
      "CPOL-1.02",
      "CUA-OPL-1.0",
      "Caldera",
      "ClArtistic",
      "Clips",
      "Community-Spec-1.0",
      "Condor-1.1",
      "Cornell-Lossless-JPEG",
      "Crossword",
      "CrystalStacker",
      "Cube",
      "D-FSL-1.0",
      "DL-DE-BY-2.0",
      "DOC",
      "DRL-1.0",
      "DSDP",
      "Dotseqn",
      "ECL-1.0",
      "ECL-2.0",
      "EFL-1.0",
      "EFL-2.0",
      "EPICS",
      "EPL-1.0",
      "EPL-2.0",
      "EUDatagrid",
      "EUPL-1.0",
      "EUPL-1.1",
      "EUPL-1.2",
      "Elastic-2.0",
      "Entessa",
      "ErlPL-1.1",
      "Eurosym",
      "FDK-AAC",
      "FSFAP",
      "FSFUL",
      "FSFULLR",
      "FSFULLRWD",
      "FTL",
      "Fair",
      "Frameworx-1.0",
      "FreeBSD-DOC",
      "FreeImage",
      "GD",
      "GFDL-1.1-invariants-only",
      "GFDL-1.1-invariants-or-later",
      "GFDL-1.1-no-invariants-only",
      "GFDL-1.1-no-invariants-or-later",
      "GFDL-1.1-only",
      "GFDL-1.1-or-later",
      "GFDL-1.2-invariants-only",
      "GFDL-1.2-invariants-or-later",
      "GFDL-1.2-no-invariants-only",
      "GFDL-1.2-no-invariants-or-later",
      "GFDL-1.2-only",
      "GFDL-1.2-or-later",
      "GFDL-1.3-invariants-only",
      "GFDL-1.3-invariants-or-later",
      "GFDL-1.3-no-invariants-only",
      "GFDL-1.3-no-invariants-or-later",
      "GFDL-1.3-only",
      "GFDL-1.3-or-later",
      "GL2PS",
      "GLWTPL",
      "GPL-1.0-only",
      "GPL-1.0-or-later",
      "GPL-2.0-only",
      "GPL-2.0-or-later",
      "GPL-3.0-only",
      "GPL-3.0-or-later",
      "Giftware",
      "Glide",
      "Glulxe",
      "Graphics-Gems",
      "HP-1986",
      "HPND",
      "HPND-Markus-Kuhn",
      "HPND-export-US",
      "HPND-sell-variant",
      "HPND-sell-variant-MIT-disclaimer",
      "HTMLTIDY",
      "HaskellReport",
      "Hippocratic-2.1",
      "IBM-pibs",
      "ICU",
      "IEC-Code-Components-EULA",
      "IJG",
      "IJG-short",
      "IPA",
      "IPL-1.0",
      "ISC",
      "ImageMagick",
      "Imlib2",
      "Info-ZIP",
      "Inner-Net-2.0",
      "Intel",
      "Intel-ACPI",
      "Interbase-1.0",
      "JPL-image",
      "JPNIC",
      "JSON",
      "Jam",
      "JasPer-2.0",
      "Kazlib",
      "Knuth-CTAN",
      "LAL-1.2",
      "LAL-1.3",
      "LGPL-2.0-only",
      "LGPL-2.0-or-later",
      "LGPL-2.1-only",
      "LGPL-2.1-or-later",
      "LGPL-3.0-only",
      "LGPL-3.0-or-later",
      "LGPLLR",
      "LOOP",
      "LPL-1.0",
      "LPL-1.02",
      "LPPL-1.0",
      "LPPL-1.1",
      "LPPL-1.2",
      "LPPL-1.3a",
      "LPPL-1.3c",
      "LZMA-SDK-9.11-to-9.20",
      "LZMA-SDK-9.22",
      "Latex2e",
      "Latex2e-translated-notice",
      "Leptonica",
      "LiLiQ-P-1.1",
      "LiLiQ-R-1.1",
      "LiLiQ-Rplus-1.1",
      "Libpng",
      "Linux-OpenIB",
      "Linux-man-pages-1-para",
      "Linux-man-pages-copyleft",
      "Linux-man-pages-copyleft-2-para",
      "Linux-man-pages-copyleft-var",
      "MIT",
      "MIT-0",
      "MIT-CMU",
      "MIT-Festival",
      "MIT-Modern-Variant",
      "MIT-Wu",
      "MIT-advertising",
      "MIT-enna",
      "MIT-feh",
      "MIT-open-group",
      "MITNFA",
      "MPL-1.0",
      "MPL-1.1",
      "MPL-2.0",
      "MPL-2.0-no-copyleft-exception",
      "MS-LPL",
      "MS-PL",
      "MS-RL",
      "MTLL",
      "MakeIndex",
      "Martin-Birgmeier",
      "Minpack",
      "MirOS",
      "Motosoto",
      "MulanPSL-1.0",
      "MulanPSL-2.0",
      "Multics",
      "Mup",
      "NAIST-2003",
      "NASA-1.3",
      "NBPL-1.0",
      "NCGL-UK-2.0",
      "NCSA",
      "NGPL",
      "NICTA-1.0",
      "NIST-PD",
      "NIST-PD-fallback",
      "NIST-Software",
      "NLOD-1.0",
      "NLOD-2.0",
      "NLPL",
      "NOSL",
      "NPL-1.0",
      "NPL-1.1",
      "NPOSL-3.0",
      "NRL",
      "NTP",
      "NTP-0",
      "Naumen",
      "Net-SNMP",
      "NetCDF",
      "Newsletr",
      "Nokia",
      "Noweb",
      "O-UDA-1.0",
      "OCCT-PL",
      "OCLC-2.0",
      "ODC-By-1.0",
      "ODbL-1.0",
      "OFFIS",
      "OFL-1.0",
      "OFL-1.0-RFN",
      "OFL-1.0-no-RFN",
      "OFL-1.1",
      "OFL-1.1-RFN",
      "OFL-1.1-no-RFN",
      "OGC-1.0",
      "OGDL-Taiwan-1.0",
      "OGL-Canada-2.0",
      "OGL-UK-1.0",
      "OGL-UK-2.0",
      "OGL-UK-3.0",
      "OGTSL",
      "OLDAP-1.1",
      "OLDAP-1.2",
      "OLDAP-1.3",
      "OLDAP-1.4",
      "OLDAP-2.0",
      "OLDAP-2.0.1",
      "OLDAP-2.1",
      "OLDAP-2.2",
      "OLDAP-2.2.1",
      "OLDAP-2.2.2",
      "OLDAP-2.3",
      "OLDAP-2.4",
      "OLDAP-2.5",
      "OLDAP-2.6",
      "OLDAP-2.7",
      "OLDAP-2.8",
      "OLFL-1.3",
      "OML",
      "OPL-1.0",
      "OPL-UK-3.0",
      "OPUBL-1.0",
      "OSET-PL-2.1",
      "OSL-1.0",
      "OSL-1.1",
      "OSL-2.0",
      "OSL-2.1",
      "OSL-3.0",
      "OpenPBS-2.3",
      "OpenSSL",
      "PDDL-1.0",
      "PHP-3.0",
      "PHP-3.01",
      "PSF-2.0",
      "Parity-6.0.0",
      "Parity-7.0.0",
      "Plexus",
      "PolyForm-Noncommercial-1.0.0",
      "PolyForm-Small-Business-1.0.0",
      "PostgreSQL",
      "Python-2.0",
      "Python-2.0.1",
      "QPL-1.0",
      "QPL-1.0-INRIA-2004",
      "Qhull",
      "RHeCos-1.1",
      "RPL-1.1",
      "RPL-1.5",
      "RPSL-1.0",
      "RSA-MD",
      "RSCPL",
      "Rdisc",
      "Ruby",
      "SAX-PD",
      "SCEA",
      "SGI-B-1.0",
      "SGI-B-1.1",
      "SGI-B-2.0",
      "SGP4",
      "SHL-0.5",
      "SHL-0.51",
      "SISSL",
      "SISSL-1.2",
      "SMLNJ",
      "SMPPL",
      "SNIA",
      "SPL-1.0",
      "SSH-OpenSSH",
      "SSH-short",
      "SSPL-1.0",
      "SWL",
      "Saxpath",
      "SchemeReport",
      "Sendmail",
      "Sendmail-8.23",
      "SimPL-2.0",
      "Sleepycat",
      "Spencer-86",
      "Spencer-94",
      "Spencer-99",
      "SugarCRM-1.1.3",
      "SunPro",
      "Symlinks",
      "TAPR-OHL-1.0",
      "TCL",
      "TCP-wrappers",
      "TMate",
      "TORQUE-1.1",
      "TOSL",
      "TPDL",
      "TPL-1.0",
      "TTWL",
      "TU-Berlin-1.0",
      "TU-Berlin-2.0",
      "TermReadKey",
      "UCAR",
      "UCL-1.0",
      "UPL-1.0",
      "Unicode-DFS-2015",
      "Unicode-DFS-2016",
      "Unicode-TOU",
      "UnixCrypt",
      "Unlicense",
      "VOSTROM",
      "VSL-1.0",
      "Vim",
      "W3C",
      "W3C-19980720",
      "W3C-20150513",
      "WTFPL",
      "Watcom-1.0",
      "Widget-Workshop",
      "Wsuipa",
      "X11",
      "X11-distribute-modifications-variant",
      "XFree86-1.1",
      "XSkat",
      "Xdebug-1.03",
      "Xerox",
      "Xfig",
      "Xnet",
      "YPL-1.0",
      "YPL-1.1",
      "ZPL-1.1",
      "ZPL-2.0",
      "ZPL-2.1",
      "Zed",
      "Zend-2.0",
      "Zimbra-1.3",
      "Zimbra-1.4",
      "Zlib",
      "blessing",
      "bzip2-1.0.6",
      "checkmk",
      "copyleft-next-0.3.0",
      "copyleft-next-0.3.1",
      "curl",
      "diffmark",
      "dtoa",
      "dvipdfm",
      "eGenix",
      "etalab-2.0",
      "gSOAP-1.3b",
      "gnuplot",
      "iMatix",
      "libpng-2.0",
      "libselinux-1.0",
      "libtiff",
      "libutil-David-Nugent",
      "metamail",
      "mpi-permissive",
      "mpich2",
      "mplus",
      "psfrag",
      "psutils",
      "snprintf",
      "w3m",
      "xinetd",
      "xlock",
      "xpp",
      "zlib-acknowledgement"
    ];
  }
});

// ../../node_modules/spdx-license-ids/deprecated.json
var require_deprecated = __commonJS({
  "../../node_modules/spdx-license-ids/deprecated.json"(exports2, module2) {
    module2.exports = [
      "AGPL-1.0",
      "AGPL-3.0",
      "BSD-2-Clause-FreeBSD",
      "BSD-2-Clause-NetBSD",
      "GFDL-1.1",
      "GFDL-1.2",
      "GFDL-1.3",
      "GPL-1.0",
      "GPL-2.0",
      "GPL-2.0-with-GCC-exception",
      "GPL-2.0-with-autoconf-exception",
      "GPL-2.0-with-bison-exception",
      "GPL-2.0-with-classpath-exception",
      "GPL-2.0-with-font-exception",
      "GPL-3.0",
      "GPL-3.0-with-GCC-exception",
      "GPL-3.0-with-autoconf-exception",
      "LGPL-2.0",
      "LGPL-2.1",
      "LGPL-3.0",
      "Nunit",
      "StandardML-NJ",
      "bzip2-1.0.5",
      "eCos-2.0",
      "wxWindows"
    ];
  }
});

// ../../node_modules/spdx-exceptions/index.json
var require_spdx_exceptions = __commonJS({
  "../../node_modules/spdx-exceptions/index.json"(exports2, module2) {
    module2.exports = [
      "389-exception",
      "Autoconf-exception-2.0",
      "Autoconf-exception-3.0",
      "Bison-exception-2.2",
      "Bootloader-exception",
      "Classpath-exception-2.0",
      "CLISP-exception-2.0",
      "DigiRule-FOSS-exception",
      "eCos-exception-2.0",
      "Fawkes-Runtime-exception",
      "FLTK-exception",
      "Font-exception-2.0",
      "freertos-exception-2.0",
      "GCC-exception-2.0",
      "GCC-exception-3.1",
      "gnu-javamail-exception",
      "GPL-3.0-linking-exception",
      "GPL-3.0-linking-source-exception",
      "GPL-CC-1.0",
      "i2p-gpl-java-exception",
      "Libtool-exception",
      "Linux-syscall-note",
      "LLVM-exception",
      "LZMA-exception",
      "mif-exception",
      "Nokia-Qt-exception-1.1",
      "OCaml-LGPL-linking-exception",
      "OCCT-exception-1.0",
      "OpenJDK-assembly-exception-1.0",
      "openvpn-openssl-exception",
      "PS-or-PDF-font-exception-20170817",
      "Qt-GPL-exception-1.0",
      "Qt-LGPL-exception-1.1",
      "Qwt-exception-1.0",
      "Swift-exception",
      "u-boot-exception-2.0",
      "Universal-FOSS-exception-1.0",
      "WxWindows-exception-3.1"
    ];
  }
});

// ../../node_modules/spdx-expression-parse/scan.js
var require_scan = __commonJS({
  "../../node_modules/spdx-expression-parse/scan.js"(exports2, module2) {
    "use strict";
    var licenses2 = [].concat(require_spdx_license_ids()).concat(require_deprecated());
    var exceptions = require_spdx_exceptions();
    module2.exports = function(source) {
      var index2 = 0;
      function hasMore() {
        return index2 < source.length;
      }
      function read(value) {
        if (value instanceof RegExp) {
          var chars = source.slice(index2);
          var match = chars.match(value);
          if (match) {
            index2 += match[0].length;
            return match[0];
          }
        } else {
          if (source.indexOf(value, index2) === index2) {
            index2 += value.length;
            return value;
          }
        }
      }
      function skipWhitespace() {
        read(/[ ]*/);
      }
      function operator() {
        var string;
        var possibilities = ["WITH", "AND", "OR", "(", ")", ":", "+"];
        for (var i5 = 0; i5 < possibilities.length; i5++) {
          string = read(possibilities[i5]);
          if (string) {
            break;
          }
        }
        if (string === "+" && index2 > 1 && source[index2 - 2] === " ") {
          throw new Error("Space before `+`");
        }
        return string && {
          type: "OPERATOR",
          string
        };
      }
      function idstring() {
        return read(/[A-Za-z0-9-.]+/);
      }
      function expectIdstring() {
        var string = idstring();
        if (!string) {
          throw new Error("Expected idstring at offset " + index2);
        }
        return string;
      }
      function documentRef() {
        if (read("DocumentRef-")) {
          var string = expectIdstring();
          return { type: "DOCUMENTREF", string };
        }
      }
      function licenseRef() {
        if (read("LicenseRef-")) {
          var string = expectIdstring();
          return { type: "LICENSEREF", string };
        }
      }
      function identifier() {
        var begin = index2;
        var string = idstring();
        if (licenses2.indexOf(string) !== -1) {
          return {
            type: "LICENSE",
            string
          };
        } else if (exceptions.indexOf(string) !== -1) {
          return {
            type: "EXCEPTION",
            string
          };
        }
        index2 = begin;
      }
      function parseToken() {
        return operator() || documentRef() || licenseRef() || identifier();
      }
      var tokens = [];
      while (hasMore()) {
        skipWhitespace();
        if (!hasMore()) {
          break;
        }
        var token = parseToken();
        if (!token) {
          throw new Error("Unexpected `" + source[index2] + "` at offset " + index2);
        }
        tokens.push(token);
      }
      return tokens;
    };
  }
});

// ../../node_modules/spdx-expression-parse/parse.js
var require_parse2 = __commonJS({
  "../../node_modules/spdx-expression-parse/parse.js"(exports2, module2) {
    "use strict";
    module2.exports = function(tokens) {
      var index2 = 0;
      function hasMore() {
        return index2 < tokens.length;
      }
      function token() {
        return hasMore() ? tokens[index2] : null;
      }
      function next() {
        if (!hasMore()) {
          throw new Error();
        }
        index2++;
      }
      function parseOperator(operator) {
        var t10 = token();
        if (t10 && t10.type === "OPERATOR" && operator === t10.string) {
          next();
          return t10.string;
        }
      }
      function parseWith() {
        if (parseOperator("WITH")) {
          var t10 = token();
          if (t10 && t10.type === "EXCEPTION") {
            next();
            return t10.string;
          }
          throw new Error("Expected exception after `WITH`");
        }
      }
      function parseLicenseRef() {
        var begin = index2;
        var string = "";
        var t10 = token();
        if (t10.type === "DOCUMENTREF") {
          next();
          string += "DocumentRef-" + t10.string + ":";
          if (!parseOperator(":")) {
            throw new Error("Expected `:` after `DocumentRef-...`");
          }
        }
        t10 = token();
        if (t10.type === "LICENSEREF") {
          next();
          string += "LicenseRef-" + t10.string;
          return { license: string };
        }
        index2 = begin;
      }
      function parseLicense() {
        var t10 = token();
        if (t10 && t10.type === "LICENSE") {
          next();
          var node2 = { license: t10.string };
          if (parseOperator("+")) {
            node2.plus = true;
          }
          var exception2 = parseWith();
          if (exception2) {
            node2.exception = exception2;
          }
          return node2;
        }
      }
      function parseParenthesizedExpression() {
        var left = parseOperator("(");
        if (!left) {
          return;
        }
        var expr = parseExpression();
        if (!parseOperator(")")) {
          throw new Error("Expected `)`");
        }
        return expr;
      }
      function parseAtom() {
        return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();
      }
      function makeBinaryOpParser(operator, nextParser) {
        return function parseBinaryOp() {
          var left = nextParser();
          if (!left) {
            return;
          }
          if (!parseOperator(operator)) {
            return left;
          }
          var right = parseBinaryOp();
          if (!right) {
            throw new Error("Expected expression");
          }
          return {
            left,
            conjunction: operator.toLowerCase(),
            right
          };
        };
      }
      var parseAnd = makeBinaryOpParser("AND", parseAtom);
      var parseExpression = makeBinaryOpParser("OR", parseAnd);
      var node = parseExpression();
      if (!node || hasMore()) {
        throw new Error("Syntax error");
      }
      return node;
    };
  }
});

// ../../node_modules/spdx-expression-parse/index.js
var require_spdx_expression_parse = __commonJS({
  "../../node_modules/spdx-expression-parse/index.js"(exports2, module2) {
    "use strict";
    var scan = require_scan();
    var parse4 = require_parse2();
    module2.exports = function(source) {
      return parse4(scan(source));
    };
  }
});

// ../../node_modules/spdx-correct/index.js
var require_spdx_correct = __commonJS({
  "../../node_modules/spdx-correct/index.js"(exports2, module2) {
    var parse4 = require_spdx_expression_parse();
    var spdxLicenseIds = require_spdx_license_ids();
    function valid2(string) {
      try {
        parse4(string);
        return true;
      } catch (error) {
        return false;
      }
    }
    function sortTranspositions(a4, b4) {
      var length = b4[0].length - a4[0].length;
      if (length !== 0)
        return length;
      return a4[0].toUpperCase().localeCompare(b4[0].toUpperCase());
    }
    var transpositions = [
      ["APGL", "AGPL"],
      ["Gpl", "GPL"],
      ["GLP", "GPL"],
      ["APL", "Apache"],
      ["ISD", "ISC"],
      ["GLP", "GPL"],
      ["IST", "ISC"],
      ["Claude", "Clause"],
      [" or later", "+"],
      [" International", ""],
      ["GNU", "GPL"],
      ["GUN", "GPL"],
      ["+", ""],
      ["GNU GPL", "GPL"],
      ["GNU LGPL", "LGPL"],
      ["GNU/GPL", "GPL"],
      ["GNU GLP", "GPL"],
      ["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL"],
      ["GNU Lesser General Public License", "LGPL"],
      ["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
      ["GNU Lesser General Public License", "LGPL-2.1"],
      ["LESSER GENERAL PUBLIC LICENSE", "LGPL"],
      ["Lesser General Public License", "LGPL"],
      ["LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
      ["Lesser General Public License", "LGPL-2.1"],
      ["GNU General Public License", "GPL"],
      ["Gnu public license", "GPL"],
      ["GNU Public License", "GPL"],
      ["GNU GENERAL PUBLIC LICENSE", "GPL"],
      ["MTI", "MIT"],
      ["Mozilla Public License", "MPL"],
      ["Universal Permissive License", "UPL"],
      ["WTH", "WTF"],
      ["WTFGPL", "WTFPL"],
      ["-License", ""]
    ].sort(sortTranspositions);
    var TRANSPOSED = 0;
    var CORRECT = 1;
    var transforms = [
      // e.g. 'mit'
      function(argument) {
        return argument.toUpperCase();
      },
      // e.g. 'MIT '
      function(argument) {
        return argument.trim();
      },
      // e.g. 'M.I.T.'
      function(argument) {
        return argument.replace(/\./g, "");
      },
      // e.g. 'Apache- 2.0'
      function(argument) {
        return argument.replace(/\s+/g, "");
      },
      // e.g. 'CC BY 4.0''
      function(argument) {
        return argument.replace(/\s+/g, "-");
      },
      // e.g. 'LGPLv2.1'
      function(argument) {
        return argument.replace("v", "-");
      },
      // e.g. 'Apache 2.0'
      function(argument) {
        return argument.replace(/,?\s*(\d)/, "-$1");
      },
      // e.g. 'GPL 2'
      function(argument) {
        return argument.replace(/,?\s*(\d)/, "-$1.0");
      },
      // e.g. 'Apache Version 2.0'
      function(argument) {
        return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2");
      },
      // e.g. 'Apache Version 2'
      function(argument) {
        return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2.0");
      },
      // e.g. 'ZLIB'
      function(argument) {
        return argument[0].toUpperCase() + argument.slice(1);
      },
      // e.g. 'MPL/2.0'
      function(argument) {
        return argument.replace("/", "-");
      },
      // e.g. 'Apache 2'
      function(argument) {
        return argument.replace(/\s*V\s*(\d)/, "-$1").replace(/(\d)$/, "$1.0");
      },
      // e.g. 'GPL-2.0', 'GPL-3.0'
      function(argument) {
        if (argument.indexOf("3.0") !== -1) {
          return argument + "-or-later";
        } else {
          return argument + "-only";
        }
      },
      // e.g. 'GPL-2.0-'
      function(argument) {
        return argument + "only";
      },
      // e.g. 'GPL2'
      function(argument) {
        return argument.replace(/(\d)$/, "-$1.0");
      },
      // e.g. 'BSD 3'
      function(argument) {
        return argument.replace(/(-| )?(\d)$/, "-$2-Clause");
      },
      // e.g. 'BSD clause 3'
      function(argument) {
        return argument.replace(/(-| )clause(-| )(\d)/, "-$3-Clause");
      },
      // e.g. 'New BSD license'
      function(argument) {
        return argument.replace(/\b(Modified|New|Revised)(-| )?BSD((-| )License)?/i, "BSD-3-Clause");
      },
      // e.g. 'Simplified BSD license'
      function(argument) {
        return argument.replace(/\bSimplified(-| )?BSD((-| )License)?/i, "BSD-2-Clause");
      },
      // e.g. 'Free BSD license'
      function(argument) {
        return argument.replace(/\b(Free|Net)(-| )?BSD((-| )License)?/i, "BSD-2-Clause-$1BSD");
      },
      // e.g. 'Clear BSD license'
      function(argument) {
        return argument.replace(/\bClear(-| )?BSD((-| )License)?/i, "BSD-3-Clause-Clear");
      },
      // e.g. 'Old BSD License'
      function(argument) {
        return argument.replace(/\b(Old|Original)(-| )?BSD((-| )License)?/i, "BSD-4-Clause");
      },
      // e.g. 'BY-NC-4.0'
      function(argument) {
        return "CC-" + argument;
      },
      // e.g. 'BY-NC'
      function(argument) {
        return "CC-" + argument + "-4.0";
      },
      // e.g. 'Attribution-NonCommercial'
      function(argument) {
        return argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "");
      },
      // e.g. 'Attribution-NonCommercial'
      function(argument) {
        return "CC-" + argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "") + "-4.0";
      }
    ];
    var licensesWithVersions = spdxLicenseIds.map(function(id) {
      var match = /^(.*)-\d+\.\d+$/.exec(id);
      return match ? [match[0], match[1]] : [id, null];
    }).reduce(function(objectMap, item) {
      var key = item[1];
      objectMap[key] = objectMap[key] || [];
      objectMap[key].push(item[0]);
      return objectMap;
    }, {});
    var licensesWithOneVersion = Object.keys(licensesWithVersions).map(function makeEntries(key) {
      return [key, licensesWithVersions[key]];
    }).filter(function identifySoleVersions(item) {
      return (
        // Licenses has just one valid version suffix.
        item[1].length === 1 && item[0] !== null && // APL will be considered Apache, rather than APL-1.0
        item[0] !== "APL"
      );
    }).map(function createLastResorts(item) {
      return [item[0], item[1][0]];
    });
    licensesWithVersions = void 0;
    var lastResorts = [
      ["UNLI", "Unlicense"],
      ["WTF", "WTFPL"],
      ["2 CLAUSE", "BSD-2-Clause"],
      ["2-CLAUSE", "BSD-2-Clause"],
      ["3 CLAUSE", "BSD-3-Clause"],
      ["3-CLAUSE", "BSD-3-Clause"],
      ["AFFERO", "AGPL-3.0-or-later"],
      ["AGPL", "AGPL-3.0-or-later"],
      ["APACHE", "Apache-2.0"],
      ["ARTISTIC", "Artistic-2.0"],
      ["Affero", "AGPL-3.0-or-later"],
      ["BEER", "Beerware"],
      ["BOOST", "BSL-1.0"],
      ["BSD", "BSD-2-Clause"],
      ["CDDL", "CDDL-1.1"],
      ["ECLIPSE", "EPL-1.0"],
      ["FUCK", "WTFPL"],
      ["GNU", "GPL-3.0-or-later"],
      ["LGPL", "LGPL-3.0-or-later"],
      ["GPLV1", "GPL-1.0-only"],
      ["GPL-1", "GPL-1.0-only"],
      ["GPLV2", "GPL-2.0-only"],
      ["GPL-2", "GPL-2.0-only"],
      ["GPL", "GPL-3.0-or-later"],
      ["MIT +NO-FALSE-ATTRIBS", "MITNFA"],
      ["MIT", "MIT"],
      ["MPL", "MPL-2.0"],
      ["X11", "X11"],
      ["ZLIB", "Zlib"]
    ].concat(licensesWithOneVersion).sort(sortTranspositions);
    var SUBSTRING = 0;
    var IDENTIFIER = 1;
    var validTransformation = function(identifier) {
      for (var i5 = 0; i5 < transforms.length; i5++) {
        var transformed = transforms[i5](identifier).trim();
        if (transformed !== identifier && valid2(transformed)) {
          return transformed;
        }
      }
      return null;
    };
    var validLastResort = function(identifier) {
      var upperCased = identifier.toUpperCase();
      for (var i5 = 0; i5 < lastResorts.length; i5++) {
        var lastResort = lastResorts[i5];
        if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) {
          return lastResort[IDENTIFIER];
        }
      }
      return null;
    };
    var anyCorrection = function(identifier, check) {
      for (var i5 = 0; i5 < transpositions.length; i5++) {
        var transposition = transpositions[i5];
        var transposed = transposition[TRANSPOSED];
        if (identifier.indexOf(transposed) > -1) {
          var corrected = identifier.replace(
            transposed,
            transposition[CORRECT]
          );
          var checked = check(corrected);
          if (checked !== null) {
            return checked;
          }
        }
      }
      return null;
    };
    module2.exports = function(identifier, options) {
      options = options || {};
      var upgrade = options.upgrade === void 0 ? true : !!options.upgrade;
      function postprocess(value) {
        return upgrade ? upgradeGPLs(value) : value;
      }
      var validArugment = typeof identifier === "string" && identifier.trim().length !== 0;
      if (!validArugment) {
        throw Error("Invalid argument. Expected non-empty string.");
      }
      identifier = identifier.trim();
      if (valid2(identifier)) {
        return postprocess(identifier);
      }
      var noPlus = identifier.replace(/\+$/, "").trim();
      if (valid2(noPlus)) {
        return postprocess(noPlus);
      }
      var transformed = validTransformation(identifier);
      if (transformed !== null) {
        return postprocess(transformed);
      }
      transformed = anyCorrection(identifier, function(argument) {
        if (valid2(argument)) {
          return argument;
        }
        return validTransformation(argument);
      });
      if (transformed !== null) {
        return postprocess(transformed);
      }
      transformed = validLastResort(identifier);
      if (transformed !== null) {
        return postprocess(transformed);
      }
      transformed = anyCorrection(identifier, validLastResort);
      if (transformed !== null) {
        return postprocess(transformed);
      }
      return null;
    };
    function upgradeGPLs(value) {
      if ([
        "GPL-1.0",
        "LGPL-1.0",
        "AGPL-1.0",
        "GPL-2.0",
        "LGPL-2.0",
        "AGPL-2.0",
        "LGPL-2.1"
      ].indexOf(value) !== -1) {
        return value + "-only";
      } else if ([
        "GPL-1.0+",
        "GPL-2.0+",
        "GPL-3.0+",
        "LGPL-2.0+",
        "LGPL-2.1+",
        "LGPL-3.0+",
        "AGPL-1.0+",
        "AGPL-3.0+"
      ].indexOf(value) !== -1) {
        return value.replace(/\+$/, "-or-later");
      } else if (["GPL-3.0", "LGPL-3.0", "AGPL-3.0"].indexOf(value) !== -1) {
        return value + "-or-later";
      } else {
        return value;
      }
    }
  }
});

// empty-module:~/utils/loaders.server
var require_loaders = __commonJS({
  "empty-module:~/utils/loaders.server"(exports2, module2) {
    module2.exports = {};
  }
});

// ../../packages/providers/dist/hooks.js
var import_react = __toESM(require_react(), 1);
function useMediaQuery(query) {
  const ssr = typeof document === "undefined";
  const getMatches = (match) => {
    if (ssr)
      return false;
    return window.matchMedia(match).matches;
  };
  const [matches, setMatches] = (0, import_react.useState)(getMatches(query));
  function handleChange() {
    setMatches(getMatches(query));
  }
  (0, import_react.useEffect)(() => {
    if (ssr)
      return;
    const matchMedia = window.matchMedia(query);
    handleChange();
    matchMedia.addEventListener("change", handleChange);
    return () => {
      matchMedia.removeEventListener("change", handleChange);
    };
  }, [query]);
  return matches;
}

// ../../packages/providers/dist/theme.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);

// ../../node_modules/nbtx/dist/esm/minify/utils.js
function walkOutputs(outputs, func) {
  outputs.forEach((output) => {
    if ("data" in output && output.data) {
      Object.entries(output.data).forEach(([, bundle]) => {
        func(bundle);
      });
    } else {
      func(output);
    }
  });
}
function ensureString(maybeString, joinWith = "") {
  if (!maybeString)
    return "";
  if (typeof maybeString === "string")
    return maybeString;
  if (maybeString.join)
    return maybeString.join(joinWith);
  return maybeString;
}

// ../../node_modules/nbtx/dist/esm/minify/convert.js
var __rest2 = function(s7, e4) {
  var t10 = {};
  for (var p3 in s7)
    if (Object.prototype.hasOwnProperty.call(s7, p3) && e4.indexOf(p3) < 0)
      t10[p3] = s7[p3];
  if (s7 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i5 = 0, p3 = Object.getOwnPropertySymbols(s7); i5 < p3.length; i5++) {
      if (e4.indexOf(p3[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s7, p3[i5]))
        t10[p3[i5]] = s7[p3[i5]];
    }
  return t10;
};
function convertToIOutputs(minified, outputCache) {
  return minified.map((m4) => {
    switch (m4.output_type) {
      case "stream": {
        const { hash } = m4, rest2 = __rest2(m4, ["hash"]);
        if (hash && outputCache[hash]) {
          return Object.assign(Object.assign({}, rest2), { text: outputCache[hash][0] });
        }
        return rest2;
      }
      case "error": {
        const { hash, traceback } = m4, rest2 = __rest2(m4, ["hash", "traceback"]);
        if (hash && outputCache[hash]) {
          return Object.assign(Object.assign({}, rest2), { traceback: [outputCache[hash][0]] });
        }
        return Object.assign(Object.assign({}, rest2), { traceback: [traceback] });
      }
      default: {
        return Object.assign(Object.assign({}, m4), { data: Object.entries(m4.data).reduce((acc, [mimetype, payload]) => {
          let { content } = payload;
          const { hash } = payload;
          if (hash && outputCache[hash]) {
            [content] = outputCache[hash];
          }
          if (content && mimetype !== "application/javascript" && mimetype.startsWith("application/")) {
            try {
              content = JSON.parse(content);
            } catch (e4) {
              console.debug(`${mimetype} is not json parsable, leaving as is`);
            }
          }
          if (content && mimetype.startsWith("image/") && !mimetype.startsWith("image/svg") && content.startsWith("data:") && content.includes(";base64,")) {
            const [data] = content.split(";base64,").reverse();
            content = data;
          }
          if (!content)
            return acc;
          return Object.assign(Object.assign({}, acc), { [mimetype]: content });
        }, {}) });
      }
    }
  });
}

// ../../node_modules/nbtx/dist/esm/types.js
var KnownCellOutputMimeTypes;
(function(KnownCellOutputMimeTypes2) {
  KnownCellOutputMimeTypes2["TextPlain"] = "text/plain";
  KnownCellOutputMimeTypes2["TextHtml"] = "text/html";
  KnownCellOutputMimeTypes2["TextLatex"] = "text/latex";
  KnownCellOutputMimeTypes2["ImagePng"] = "image/png";
  KnownCellOutputMimeTypes2["ImageBmp"] = "image/bmp";
  KnownCellOutputMimeTypes2["ImageJpeg"] = "image/jpeg";
  KnownCellOutputMimeTypes2["ImageSvg"] = "image/svg+xml";
  KnownCellOutputMimeTypes2["ImageGif"] = "image/gif";
  KnownCellOutputMimeTypes2["AppJson"] = "application/json";
  KnownCellOutputMimeTypes2["AppGeoJson"] = "application/geo+json";
  KnownCellOutputMimeTypes2["AppPlotly"] = "application/vnd.plotly.v1+json";
  KnownCellOutputMimeTypes2["AppVega"] = "application/vnd.vega.v5+json";
  KnownCellOutputMimeTypes2["AppVegaLite"] = "application/vnd.vegalite.v3+json";
  KnownCellOutputMimeTypes2["AppVirtualDom"] = "application/vdom.v1+json";
  KnownCellOutputMimeTypes2["AppJavascript"] = "application/javascript";
  KnownCellOutputMimeTypes2["AppWidgetView"] = "application/vnd.jupyter.widget-view+json";
  KnownCellOutputMimeTypes2["AppWidgetState"] = "application/vnd.jupyter.widget-state+json";
  KnownCellOutputMimeTypes2["AppBokehLoad"] = "application/vnd.bokehjs_load.v0+json";
  KnownCellOutputMimeTypes2["AppBokehExec"] = "application/vnd.bokehjs_exec.v0+json";
})(KnownCellOutputMimeTypes || (KnownCellOutputMimeTypes = {}));
var CELL_TYPES;
(function(CELL_TYPES2) {
  CELL_TYPES2["raw"] = "raw";
  CELL_TYPES2["markdown"] = "markdown";
  CELL_TYPES2["code"] = "code";
})(CELL_TYPES || (CELL_TYPES = {}));

// ../../packages/common/dist/utils.js
function getProject(config, projectSlug) {
  var _a, _b;
  if (!config)
    return void 0;
  if (!projectSlug)
    return (_a = config.projects) === null || _a === void 0 ? void 0 : _a[0];
  const project = (_b = config.projects) === null || _b === void 0 ? void 0 : _b.find((p3) => p3.slug === projectSlug);
  return project;
}
function getProjectHeadings(config, projectSlug, opts = { addGroups: false }) {
  const project = getProject(config, projectSlug);
  if (!project)
    return void 0;
  const headings = [
    {
      title: project.title,
      short_title: project.short_title,
      slug: project.index,
      path: project.slug ? `/${project.slug}` : "/",
      level: "index"
    },
    ...project.pages.map((p3) => {
      if (!("slug" in p3))
        return p3;
      return { ...p3, path: projectSlug ? `/${project.slug}/${p3.slug}` : `/${p3.slug}` };
    })
  ];
  if (opts.addGroups) {
    let lastTitle = project.short_title || project.title;
    return headings.map((heading) => {
      if (!heading.slug || heading.level === "index") {
        lastTitle = heading.short_title || heading.title;
      }
      return { ...heading, group: lastTitle };
    });
  }
  return headings;
}

// ../../packages/common/dist/types.js
var Theme;
(function(Theme2) {
  Theme2["light"] = "light";
  Theme2["dark"] = "dark";
})(Theme || (Theme = {}));
var ErrorStatus;
(function(ErrorStatus2) {
  ErrorStatus2["noSite"] = "Site was not found";
  ErrorStatus2["noArticle"] = "Article was not found";
})(ErrorStatus || (ErrorStatus = {}));

// ../../packages/providers/dist/theme.js
var __rest3 = function(s7, e4) {
  var t10 = {};
  for (var p3 in s7)
    if (Object.prototype.hasOwnProperty.call(s7, p3) && e4.indexOf(p3) < 0)
      t10[p3] = s7[p3];
  if (s7 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i5 = 0, p3 = Object.getOwnPropertySymbols(s7); i5 < p3.length; i5++) {
      if (e4.indexOf(p3[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s7, p3[i5]))
        t10[p3[i5]] = s7[p3[i5]];
    }
  return t10;
};
function HtmlLink(_a) {
  var { to, className, children, prefetch } = _a, props = __rest3(_a, ["to", "className", "children", "prefetch"]);
  return (0, import_jsx_runtime.jsx)("a", Object.assign({ href: to, className }, props, { children }));
}
function HtmlNavLink(_a) {
  var { to, className, children, prefetch } = _a, props = __rest3(_a, ["to", "className", "children", "prefetch"]);
  const staticClass = typeof className === "function" ? className({ isActive: false }) : className;
  return (0, import_jsx_runtime.jsx)("a", Object.assign({ href: to, className: staticClass }, props, { children }));
}
function isTheme(value) {
  return typeof value === "string" && Object.values(Theme).includes(value);
}
var ThemeContext = import_react2.default.createContext(void 0);
ThemeContext.displayName = "ThemeContext";
var prefersLightMQ = "(prefers-color-scheme: light)";
function ThemeProvider({ children, theme: startingTheme = Theme.light, renderers: renderers2, Link: Link2, top, NavLink: NavLink2 }) {
  const [theme, setTheme] = import_react2.default.useState(() => {
    if (startingTheme) {
      if (isTheme(startingTheme))
        return startingTheme;
      else
        return null;
    }
    if (typeof document === "undefined")
      return null;
    return window.matchMedia(prefersLightMQ).matches ? Theme.light : Theme.dark;
  });
  const nextTheme = import_react2.default.useCallback((next) => {
    if (!next || next === theme || !isTheme(next))
      return;
    if (typeof document !== "undefined") {
      document.getElementsByTagName("html")[0].className = next;
    }
    const xmlhttp = new XMLHttpRequest();
    xmlhttp.open("POST", "/api/theme");
    xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
    xmlhttp.send(JSON.stringify({ theme: next }));
    setTheme(next);
  }, [theme]);
  return (0, import_jsx_runtime.jsx)(ThemeContext.Provider, { value: { theme, setTheme: nextTheme, renderers: renderers2, Link: Link2, NavLink: NavLink2, top }, children });
}
function useTheme() {
  const context = import_react2.default.useContext(ThemeContext);
  if (context === void 0) {
    const error = "useTheme should be used within a ThemeProvider";
    const throwError2 = () => {
      throw new Error(error);
    };
    console.error(error);
    return {
      theme: Theme.light,
      isLight: true,
      isDark: false,
      setTheme: throwError2,
      nextTheme: throwError2
    };
  }
  const { theme, setTheme } = context;
  const isDark = theme === Theme.dark;
  const isLight = theme === Theme.light;
  const nextTheme = import_react2.default.useCallback(() => {
    const next = theme === Theme.light ? Theme.dark : Theme.light;
    setTheme(next);
  }, [theme]);
  return { theme, isLight, isDark, setTheme, nextTheme };
}
function useNodeRenderers() {
  const context = import_react2.default.useContext(ThemeContext);
  const { renderers: renderers2 } = context !== null && context !== void 0 ? context : {};
  return renderers2 !== null && renderers2 !== void 0 ? renderers2 : {};
}
function useLinkProvider() {
  const context = import_react2.default.useContext(ThemeContext);
  const { Link: Link2 } = context !== null && context !== void 0 ? context : {};
  return Link2 !== null && Link2 !== void 0 ? Link2 : HtmlLink;
}
function useNavLinkProvider() {
  const context = import_react2.default.useContext(ThemeContext);
  const { NavLink: NavLink2 } = context !== null && context !== void 0 ? context : {};
  return NavLink2 !== null && NavLink2 !== void 0 ? NavLink2 : HtmlNavLink;
}
function useThemeTop() {
  const context = import_react2.default.useContext(ThemeContext);
  const { top } = context !== null && context !== void 0 ? context : {};
  return top || 0;
}

// ../../packages/providers/dist/grid.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var Context = import_react3.default.createContext(void 0);
Context.displayName = "GridSystemContext";
function useGridSystemProvider() {
  const context = import_react3.default.useContext(Context);
  const { gridSystem } = context !== null && context !== void 0 ? context : {};
  return gridSystem || "article-grid";
}

// ../../packages/providers/dist/references.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
var ReferencesContext = import_react4.default.createContext({});
function ReferencesProvider({ references, frontmatter, children }) {
  return (0, import_jsx_runtime3.jsx)(ReferencesContext.Provider, { value: { references, frontmatter }, children });
}
function useReferences() {
  const data = (0, import_react4.useContext)(ReferencesContext);
  return data === null || data === void 0 ? void 0 : data.references;
}

// ../../packages/providers/dist/baseurl.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var BaseUrlContext = import_react5.default.createContext({});
function BaseUrlProvider({ baseurl, children }) {
  return (0, import_jsx_runtime4.jsx)(BaseUrlContext.Provider, { value: { baseurl }, children });
}
function useBaseurl() {
  const data = (0, import_react5.useContext)(BaseUrlContext);
  return data === null || data === void 0 ? void 0 : data.baseurl;
}
function withBaseurl(url, baseurl) {
  if (baseurl)
    return baseurl + url;
  return url;
}

// ../../packages/providers/dist/ui.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var UiContext = (0, import_react6.createContext)(void 0);
function UiStateProvider({ children }) {
  const wide = useMediaQuery("(min-width: 1280px)");
  const [state, setState] = (0, import_react6.useState)({ isNavOpen: false });
  (0, import_react6.useEffect)(() => {
    if (wide)
      setState(Object.assign(Object.assign({}, state), { isNavOpen: false }));
  }, [wide]);
  return (0, import_jsx_runtime5.jsx)(UiContext.Provider, { value: [state, setState], children });
}
function useNavOpen() {
  var _a, _b;
  const [state, setState] = (_a = (0, import_react6.useContext)(UiContext)) !== null && _a !== void 0 ? _a : [];
  const setOpen = (open) => {
    if (open === (state === null || state === void 0 ? void 0 : state.isNavOpen))
      return;
    setState === null || setState === void 0 ? void 0 : setState(Object.assign(Object.assign({}, state), { isNavOpen: open }));
  };
  return [(_b = state === null || state === void 0 ? void 0 : state.isNavOpen) !== null && _b !== void 0 ? _b : false, setOpen];
}

// ../../packages/providers/dist/site.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var SiteContext = import_react7.default.createContext(void 0);
function SiteProvider({ config, children }) {
  return (0, import_jsx_runtime6.jsx)(SiteContext.Provider, { value: config, children });
}
function useSiteManifest() {
  const config = (0, import_react7.useContext)(SiteContext);
  return config;
}

// ../../packages/providers/dist/tabs.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var TabContext = (0, import_react8.createContext)(void 0);
function TabStateProvider({ children }) {
  const [state, setState] = (0, import_react8.useState)("");
  return (0, import_jsx_runtime7.jsx)(TabContext.Provider, { value: [state, setState], children });
}
function useTabSet() {
  return (0, import_react8.useContext)(TabContext);
}

// ../../packages/providers/dist/xref.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
var XRefContext = (0, import_react9.createContext)(void 0);
function useXRefState() {
  var _a;
  const state = (_a = (0, import_react9.useContext)(XRefContext)) !== null && _a !== void 0 ? _a : { inCrossRef: false, remote: false };
  return state;
}
function XRefProvider({ remote, url, dataUrl, children }) {
  const parent = useXRefState();
  const value = {
    inCrossRef: true,
    remote: remote !== null && remote !== void 0 ? remote : parent.remote,
    url: url !== null && url !== void 0 ? url : parent.url,
    dataUrl: dataUrl !== null && dataUrl !== void 0 ? dataUrl : parent.dataUrl
  };
  if (value.remote && !value.url) {
    value.remote = false;
  }
  return (0, import_jsx_runtime8.jsx)(XRefContext.Provider, { value, children });
}

// ../../packages/providers/dist/project.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var ProjectContext = import_react10.default.createContext(void 0);
function ProjectProvider({ project, children }) {
  var _a;
  const config = useSiteManifest();
  return (0, import_jsx_runtime9.jsx)(ProjectContext.Provider, { value: project !== null && project !== void 0 ? project : (_a = config === null || config === void 0 ? void 0 : config.projects) === null || _a === void 0 ? void 0 : _a[0], children });
}
function useProjectManifest() {
  const config = (0, import_react10.useContext)(ProjectContext);
  return config;
}

// ../../packages/myst-to-react/dist/basic.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react30 = __toESM(require_react(), 1);

// ../../packages/myst-to-react/dist/heading.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_classnames = __toESM(require_classnames(), 1);

// ../../packages/myst-to-react/dist/MyST.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
function DefaultComponent({ node }) {
  if (!node.children)
    return (0, import_jsx_runtime10.jsx)("span", { children: node.value });
  return (0, import_jsx_runtime10.jsx)("div", { children: (0, import_jsx_runtime10.jsx)(MyST, { ast: node.children }) });
}
function MyST({ ast }) {
  var _a, _b;
  const renderers2 = useNodeRenderers();
  if (!ast || ast.length === 0)
    return null;
  if (!Array.isArray(ast)) {
    const Component = (_b = (_a = renderers2[ast.type]) !== null && _a !== void 0 ? _a : renderers2["DefaultComponent"]) !== null && _b !== void 0 ? _b : DefaultComponent;
    return (0, import_jsx_runtime10.jsx)(Component, { node: ast }, ast.key);
  }
  return (0, import_jsx_runtime10.jsx)(import_jsx_runtime10.Fragment, { children: ast === null || ast === void 0 ? void 0 : ast.map((node) => {
    var _a2;
    const Component = (_a2 = renderers2[node.type]) !== null && _a2 !== void 0 ? _a2 : DefaultComponent;
    return (0, import_jsx_runtime10.jsx)(Component, { node }, node.key);
  }) });
}

// ../../packages/myst-to-react/dist/heading.js
function HashLink({ id, kind, title = `Link to this ${kind}`, children = "\xB6", hover, className = "font-normal", hideInPopup }) {
  const { inCrossRef } = useXRefState();
  if (inCrossRef || !id) {
    return hideInPopup ? null : (0, import_jsx_runtime11.jsx)("span", { className: (0, import_classnames.default)("select-none", className), children });
  }
  const scroll = (evt) => {
    evt.preventDefault();
    const el = document.getElementById(id);
    el === null || el === void 0 ? void 0 : el.scrollIntoView({ behavior: "smooth" });
    history.replaceState(void 0, "", `#${id}`);
  };
  return (0, import_jsx_runtime11.jsx)("a", { className: (0, import_classnames.default)("select-none no-underline text-inherit hover:text-inherit", className, {
    "transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70": hover,
    "hover:underline": !hover
  }), onClick: scroll, href: `#${id}`, title, "aria-label": title, children });
}
var Heading = ({ node }) => {
  const { enumerator, depth, key, identifier, html_id } = node;
  const id = html_id || identifier || key;
  const textContent = (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [enumerator && (0, import_jsx_runtime11.jsx)("span", { className: "mr-3 select-none", children: enumerator }), (0, import_jsx_runtime11.jsx)("span", { className: "heading-text", children: (0, import_jsx_runtime11.jsx)(MyST, { ast: node.children }) }), (0, import_jsx_runtime11.jsx)(HashLink, { id, kind: "Section", className: "px-2 font-normal", hover: true, hideInPopup: true })] });
  return (0, import_react11.createElement)(`h${depth}`, {
    id,
    className: "relative group"
  }, textContent);
};
var HEADING_RENDERERS = {
  heading: Heading
};
var heading_default = HEADING_RENDERERS;

// ../../packages/myst-to-react/dist/basic.js
var import_classnames4 = __toESM(require_classnames(), 1);

// ../../packages/myst-to-react/dist/components/CopyIcon.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowDownTrayIcon.js
var React7 = __toESM(require_react(), 1);
function ArrowDownTrayIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React7.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React7.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React7.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3"
  }));
}
var ForwardRef = React7.forwardRef(ArrowDownTrayIcon);
var ArrowDownTrayIcon_default = ForwardRef;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowLeftIcon.js
var React8 = __toESM(require_react(), 1);
function ArrowLeftIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React8.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React8.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React8.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18"
  }));
}
var ForwardRef2 = React8.forwardRef(ArrowLeftIcon);
var ArrowLeftIcon_default = ForwardRef2;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowRightCircleIcon.js
var React9 = __toESM(require_react(), 1);
function ArrowRightCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React9.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React9.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React9.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12.75 15l3-3m0 0l-3-3m3 3h-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
  }));
}
var ForwardRef3 = React9.forwardRef(ArrowRightCircleIcon);
var ArrowRightCircleIcon_default = ForwardRef3;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowRightIcon.js
var React10 = __toESM(require_react(), 1);
function ArrowRightIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React10.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React10.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React10.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3"
  }));
}
var ForwardRef4 = React10.forwardRef(ArrowRightIcon);
var ArrowRightIcon_default = ForwardRef4;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowTopRightOnSquareIcon.js
var React11 = __toESM(require_react(), 1);
function ArrowTopRightOnSquareIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React11.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React11.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React11.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"
  }));
}
var ForwardRef5 = React11.forwardRef(ArrowTopRightOnSquareIcon);
var ArrowTopRightOnSquareIcon_default = ForwardRef5;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowUturnLeftIcon.js
var React12 = __toESM(require_react(), 1);
function ArrowUturnLeftIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React12.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React12.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React12.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3"
  }));
}
var ForwardRef6 = React12.forwardRef(ArrowUturnLeftIcon);
var ArrowUturnLeftIcon_default = ForwardRef6;

// ../../node_modules/@heroicons/react/24/outline/esm/BoltIcon.js
var React13 = __toESM(require_react(), 1);
function BoltIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React13.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React13.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React13.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M3.75 13.5l10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75z"
  }));
}
var ForwardRef7 = React13.forwardRef(BoltIcon);
var BoltIcon_default = ForwardRef7;

// ../../node_modules/@heroicons/react/24/outline/esm/CheckCircleIcon.js
var React14 = __toESM(require_react(), 1);
function CheckCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React14.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React14.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React14.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
  }));
}
var ForwardRef8 = React14.forwardRef(CheckCircleIcon);
var CheckCircleIcon_default = ForwardRef8;

// ../../node_modules/@heroicons/react/24/outline/esm/CheckIcon.js
var React15 = __toESM(require_react(), 1);
function CheckIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React15.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React15.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React15.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M4.5 12.75l6 6 9-13.5"
  }));
}
var ForwardRef9 = React15.forwardRef(CheckIcon);
var CheckIcon_default = ForwardRef9;

// ../../node_modules/@heroicons/react/24/outline/esm/DocumentDuplicateIcon.js
var React16 = __toESM(require_react(), 1);
function DocumentDuplicateIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React16.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React16.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React16.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 01-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 011.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 00-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 01-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 00-3.375-3.375h-1.5a1.125 1.125 0 01-1.125-1.125v-1.5a3.375 3.375 0 00-3.375-3.375H9.75"
  }));
}
var ForwardRef10 = React16.forwardRef(DocumentDuplicateIcon);
var DocumentDuplicateIcon_default = ForwardRef10;

// ../../node_modules/@heroicons/react/24/outline/esm/DocumentIcon.js
var React17 = __toESM(require_react(), 1);
function DocumentIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React17.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React17.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React17.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m2.25 0H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z"
  }));
}
var ForwardRef11 = React17.forwardRef(DocumentIcon);
var DocumentIcon_default = ForwardRef11;

// ../../node_modules/@heroicons/react/24/outline/esm/ExclamationCircleIcon.js
var React18 = __toESM(require_react(), 1);
function ExclamationCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React18.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React18.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React18.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z"
  }));
}
var ForwardRef12 = React18.forwardRef(ExclamationCircleIcon);
var ExclamationCircleIcon_default = ForwardRef12;

// ../../node_modules/@heroicons/react/24/outline/esm/ExclamationTriangleIcon.js
var React19 = __toESM(require_react(), 1);
function ExclamationTriangleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React19.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React19.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React19.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z"
  }));
}
var ForwardRef13 = React19.forwardRef(ExclamationTriangleIcon);
var ExclamationTriangleIcon_default = ForwardRef13;

// ../../node_modules/@heroicons/react/24/outline/esm/InformationCircleIcon.js
var React20 = __toESM(require_react(), 1);
function InformationCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React20.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React20.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React20.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z"
  }));
}
var ForwardRef14 = React20.forwardRef(InformationCircleIcon);
var InformationCircleIcon_default = ForwardRef14;

// ../../node_modules/@heroicons/react/24/outline/esm/LightBulbIcon.js
var React21 = __toESM(require_react(), 1);
function LightBulbIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React21.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React21.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React21.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 18v-5.25m0 0a6.01 6.01 0 001.5-.189m-1.5.189a6.01 6.01 0 01-1.5-.189m3.75 7.478a12.06 12.06 0 01-4.5 0m3.75 2.383a14.406 14.406 0 01-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 10-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"
  }));
}
var ForwardRef15 = React21.forwardRef(LightBulbIcon);
var LightBulbIcon_default = ForwardRef15;

// ../../node_modules/@heroicons/react/24/outline/esm/LinkIcon.js
var React22 = __toESM(require_react(), 1);
function LinkIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React22.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React22.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React22.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"
  }));
}
var ForwardRef16 = React22.forwardRef(LinkIcon);
var LinkIcon_default = ForwardRef16;

// ../../node_modules/@heroicons/react/24/outline/esm/MegaphoneIcon.js
var React23 = __toESM(require_react(), 1);
function MegaphoneIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React23.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React23.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React23.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M10.34 15.84c-.688-.06-1.386-.09-2.09-.09H7.5a4.5 4.5 0 110-9h.75c.704 0 1.402-.03 2.09-.09m0 9.18c.253.962.584 1.892.985 2.783.247.55.06 1.21-.463 1.511l-.657.38c-.551.318-1.26.117-1.527-.461a20.845 20.845 0 01-1.44-4.282m3.102.069a18.03 18.03 0 01-.59-4.59c0-1.586.205-3.124.59-4.59m0 9.18a23.848 23.848 0 018.835 2.535M10.34 6.66a23.847 23.847 0 008.835-2.535m0 0A23.74 23.74 0 0018.795 3m.38 1.125a23.91 23.91 0 011.014 5.395m-1.014 8.855c-.118.38-.245.754-.38 1.125m.38-1.125a23.91 23.91 0 001.014-5.395m0-3.46c.495.413.811 1.035.811 1.73 0 .695-.316 1.317-.811 1.73m0-3.46a24.347 24.347 0 010 3.46"
  }));
}
var ForwardRef17 = React23.forwardRef(MegaphoneIcon);
var MegaphoneIcon_default = ForwardRef17;

// ../../node_modules/@heroicons/react/24/outline/esm/MinusCircleIcon.js
var React24 = __toESM(require_react(), 1);
function MinusCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React24.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React24.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React24.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M15 12H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z"
  }));
}
var ForwardRef18 = React24.forwardRef(MinusCircleIcon);
var MinusCircleIcon_default = ForwardRef18;

// ../../node_modules/@heroicons/react/24/outline/esm/PencilSquareIcon.js
var React25 = __toESM(require_react(), 1);
function PencilSquareIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React25.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React25.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React25.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10"
  }));
}
var ForwardRef19 = React25.forwardRef(PencilSquareIcon);
var PencilSquareIcon_default = ForwardRef19;

// ../../node_modules/@heroicons/react/24/outline/esm/PlayCircleIcon.js
var React26 = __toESM(require_react(), 1);
function PlayCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React26.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React26.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React26.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
  }), /* @__PURE__ */ React26.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M15.91 11.672a.375.375 0 010 .656l-5.603 3.113a.375.375 0 01-.557-.328V8.887c0-.286.307-.466.557-.327l5.603 3.112z"
  }));
}
var ForwardRef20 = React26.forwardRef(PlayCircleIcon);
var PlayCircleIcon_default = ForwardRef20;

// ../../node_modules/@heroicons/react/24/outline/esm/PlusCircleIcon.js
var React27 = __toESM(require_react(), 1);
function PlusCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React27.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React27.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React27.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 9v6m3-3H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z"
  }));
}
var ForwardRef21 = React27.forwardRef(PlusCircleIcon);
var PlusCircleIcon_default = ForwardRef21;

// ../../node_modules/@heroicons/react/24/outline/esm/PowerIcon.js
var React28 = __toESM(require_react(), 1);
function PowerIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React28.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React28.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React28.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M5.636 5.636a9 9 0 1012.728 0M12 3v9"
  }));
}
var ForwardRef22 = React28.forwardRef(PowerIcon);
var PowerIcon_default = ForwardRef22;

// ../../node_modules/@heroicons/react/24/outline/esm/ScaleIcon.js
var React29 = __toESM(require_react(), 1);
function ScaleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React29.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React29.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React29.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 3v17.25m0 0c-1.472 0-2.882.265-4.185.75M12 20.25c1.472 0 2.882.265 4.185.75M18.75 4.97A48.416 48.416 0 0012 4.5c-2.291 0-4.545.16-6.75.47m13.5 0c1.01.143 2.01.317 3 .52m-3-.52l2.62 10.726c.122.499-.106 1.028-.589 1.202a5.988 5.988 0 01-2.031.352 5.988 5.988 0 01-2.031-.352c-.483-.174-.711-.703-.59-1.202L18.75 4.971zm-16.5.52c.99-.203 1.99-.377 3-.52m0 0l2.62 10.726c.122.499-.106 1.028-.589 1.202a5.989 5.989 0 01-2.031.352 5.989 5.989 0 01-2.031-.352c-.483-.174-.711-.703-.59-1.202L5.25 4.971z"
  }));
}
var ForwardRef23 = React29.forwardRef(ScaleIcon);
var ScaleIcon_default = ForwardRef23;

// ../../node_modules/@heroicons/react/24/outline/esm/SunIcon.js
var React30 = __toESM(require_react(), 1);
function SunIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React30.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React30.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React30.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z"
  }));
}
var ForwardRef24 = React30.forwardRef(SunIcon);
var SunIcon_default = ForwardRef24;

// ../../packages/myst-to-react/dist/components/CopyIcon.js
var import_react12 = __toESM(require_react(), 1);
var import_classnames2 = __toESM(require_classnames(), 1);
function CopyIcon({ text, className }) {
  const [copied, setCopied] = (0, import_react12.useState)(false);
  const onClick = () => {
    if (copied)
      return;
    navigator.clipboard.writeText(text).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 3e3);
    });
  };
  return (0, import_jsx_runtime12.jsx)("button", { title: copied ? "Copied!!" : "Copy to Clipboard", className: (0, import_classnames2.default)("inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2", "transition-color duration-200 ease-in-out", {
    "text-blue-400 hover:text-blue-500": !copied,
    "text-green-500 hover:text-green-500": copied
  }, className), onClick, "aria-pressed": copied ? "true" : "false", "aria-label": "Copy code to clipboard", children: copied ? (0, import_jsx_runtime12.jsx)(CheckIcon_default, { width: 24, height: 24, className: "text-success" }) : (0, import_jsx_runtime12.jsx)(DocumentDuplicateIcon_default, { width: 24, height: 24 }) });
}

// ../../packages/myst-to-react/dist/components/HoverPopover.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react29 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-hover-card/dist/index.mjs
init_extends();
var import_react28 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/primitive/dist/index.mjs
function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented)
      return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
  };
}

// ../../node_modules/@radix-ui/react-context/dist/index.mjs
var import_react13 = __toESM(require_react(), 1);
function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
    const BaseContext = /* @__PURE__ */ (0, import_react13.createContext)(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [
      ...defaultContexts,
      defaultContext
    ];
    function Provider(props) {
      const { scope, children, ...context } = props;
      const Context2 = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = (0, import_react13.useMemo)(
        () => context,
        Object.values(context)
      );
      return /* @__PURE__ */ (0, import_react13.createElement)(Context2.Provider, {
        value
      }, children);
    }
    function useContext11(consumerName, scope) {
      const Context2 = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context = (0, import_react13.useContext)(Context2);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider.displayName = rootComponentName + "Provider";
    return [
      Provider,
      useContext11
    ];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return /* @__PURE__ */ (0, import_react13.createContext)(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
      return (0, import_react13.useMemo)(
        () => ({
          [`__scope${scopeName}`]: {
            ...scope,
            [scopeName]: contexts
          }
        }),
        [
          scope,
          contexts
        ]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [
    $c512c27ab02ef895$export$fd42f52fd3ae1109,
    $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)
  ];
}
function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope1 = () => {
    const scopeHooks = scopes.map(
      (createScope) => ({
        useScope: createScope(),
        scopeName: createScope.scopeName
      })
    );
    return function useComposedScopes(overrideScopes) {
      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return {
          ...nextScopes,
          ...currentScope
        };
      }, {});
      return (0, import_react13.useMemo)(
        () => ({
          [`__scope${baseScope.scopeName}`]: nextScopes1
        }),
        [
          nextScopes1
        ]
      );
    };
  };
  createScope1.scopeName = baseScope.scopeName;
  return createScope1;
}

// ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var import_react15 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var import_react14 = __toESM(require_react(), 1);
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
  const callbackRef = (0, import_react14.useRef)(callback);
  (0, import_react14.useEffect)(() => {
    callbackRef.current = callback;
  });
  return (0, import_react14.useMemo)(
    () => (...args) => {
      var _callbackRef$current;
      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
    },
    []
  );
}

// ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {
} }) {
  const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value1 = isControlled ? prop : uncontrolledProp;
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  const setValue = (0, import_react15.useCallback)((nextValue) => {
    if (isControlled) {
      const setter = nextValue;
      const value = typeof nextValue === "function" ? setter(prop) : nextValue;
      if (value !== prop)
        handleChange(value);
    } else
      setUncontrolledProp(nextValue);
  }, [
    isControlled,
    prop,
    setUncontrolledProp,
    handleChange
  ]);
  return [
    value1,
    setValue
  ];
}
function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {
  const uncontrolledState = (0, import_react15.useState)(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = (0, import_react15.useRef)(value);
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  (0, import_react15.useEffect)(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [
    value,
    prevValueRef,
    handleChange
  ]);
  return uncontrolledState;
}

// ../../node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var import_react16 = __toESM(require_react(), 1);
function $6ed0406888f73fc4$var$setRef(ref, value) {
  if (typeof ref === "function")
    ref(value);
  else if (ref !== null && ref !== void 0)
    ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
  return (0, import_react16.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);
}

// ../../node_modules/@radix-ui/react-popper/dist/index.mjs
init_extends();
var import_react23 = __toESM(require_react(), 1);

// ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

// ../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware2.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x4,
    y: y3
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i5 = 0; i5 < validMiddleware.length; i5++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i5];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x4,
      y: y3,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x4 = nextX != null ? nextX : x4;
    y3 = nextY != null ? nextY : y3;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x4,
          y: y3
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i5 = -1;
      continue;
    }
  }
  return {
    x: x4,
    y: y3,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x4,
    y: y3,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element2 = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element2))) != null ? _await$platform$isEle : true) ? element2 : element2.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x4,
    y: y3
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x4,
      y: y3,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element: element2,
      padding = 0
    } = evaluate(options, state) || {};
    if (element2 == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x4,
      y: y3
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element2);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element2));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max3 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max3);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max3 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d6) => d6.overflows[0] <= 0).sort((a4, b4) => a4.overflows[1] - b4.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d6) => [d6.placement, d6.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a4, b4) => a4[1] - b4[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      const {
        x: x4,
        y: y3
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      return {
        x: x4 + diffCoords.x,
        y: y3 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x4,
        y: y3,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x5,
              y: y4
            } = _ref;
            return {
              x: x5,
              y: y4
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x4,
        y: y3
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x4,
          y: limitedCoords.y - y3
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x4,
        y: y3,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x4,
        y: y3
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../../node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element2) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element2);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element2) {
  return ["table", "td", "th"].includes(getNodeName(element2));
}
function isContainingBlock(element2) {
  const webkit = isWebKit();
  const css = getComputedStyle2(element2);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element2) {
  let currentNode = getParentNode(element2);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}
function getNodeScroll(element2) {
  if (isElement(element2)) {
    return {
      scrollLeft: element2.scrollLeft,
      scrollTop: element2.scrollTop
    };
  }
  return {
    scrollLeft: element2.pageXOffset,
    scrollTop: element2.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result2 = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result2) ? result2.host : result2;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element2) {
  const css = getComputedStyle2(element2);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element2);
  const offsetWidth = hasOffset ? element2.offsetWidth : width;
  const offsetHeight = hasOffset ? element2.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element2) {
  return !isElement(element2) ? element2.contextElement : element2;
}
function getScale(element2) {
  const domElement = unwrapElement(element2);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $8
  } = getCssDimensions(domElement);
  let x4 = ($8 ? round(rect.width) : rect.width) / width;
  let y3 = ($8 ? round(rect.height) : rect.height) / height;
  if (!x4 || !Number.isFinite(x4)) {
    x4 = 1;
  }
  if (!y3 || !Number.isFinite(y3)) {
    y3 = 1;
  }
  return {
    x: x4,
    y: y3
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element2) {
  const win = getWindow(element2);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element2, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element2)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element2, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element2.getBoundingClientRect();
  const domElement = unwrapElement(element2);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element2);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x4 = (clientRect.left + visualOffsets.x) / scale.x;
  let y3 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x4 *= iframeScale.x;
      y3 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x4 += left;
      y3 += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x4,
    y: y3
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element2) {
  return Array.from(element2.getClientRects());
}
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getNodeScroll(element2).scrollLeft;
}
function getDocumentRect(element2) {
  const html = getDocumentElement(element2);
  const scroll = getNodeScroll(element2);
  const body = element2.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x4 = -scroll.scrollLeft + getWindowScrollBarX(element2);
  const y3 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x4 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getViewportRect(element2, strategy) {
  const win = getWindow(element2);
  const html = getDocumentElement(element2);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x4 = 0;
  let y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x4 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getInnerBoundingClientRect(element2, strategy) {
  const clientRect = getBoundingClientRect(element2, true, strategy === "fixed");
  const top = clientRect.top + element2.clientTop;
  const left = clientRect.left + element2.clientLeft;
  const scale = isHTMLElement(element2) ? getScale(element2) : createCoords(1);
  const width = element2.clientWidth * scale.x;
  const height = element2.clientHeight * scale.y;
  const x4 = left * scale.x;
  const y3 = top * scale.y;
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getClientRectFromClippingAncestor(element2, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element2, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element2));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element2);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element2, stopNode) {
  const parentNode = getParentNode(element2);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element2, cache2) {
  const cachedResult = cache2.get(element2);
  if (cachedResult) {
    return cachedResult;
  }
  let result2 = getOverflowAncestors(element2, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element2).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element2) : element2;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element2, currentNode);
    if (shouldDropCurrentNode) {
      result2 = result2.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element2, result2);
  return result2;
}
function getClippingRect(_ref) {
  let {
    element: element2,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element2, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element2, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element2, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element2) {
  return getCssDimensions(element2);
}
function getRectRelativeToOffsetParent(element2, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element2, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element2, polyfill) {
  if (!isHTMLElement(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element2);
  }
  return element2.offsetParent;
}
function getOffsetParent(element2, polyfill) {
  const window2 = getWindow(element2);
  if (!isHTMLElement(element2)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element2, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}
var getElementRects = async function(_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(floating)
    }
  };
};
function isRTL(element2) {
  return getComputedStyle2(element2).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element2, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element2);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element2.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e4) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element2);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React31 = __toESM(require_react(), 1);
var import_react17 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var arrow2 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element: element2,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element2 && isRef(element2)) {
        if (element2.current != null) {
          return arrow({
            element: element2.current,
            padding
          }).fn(state);
        }
        return {};
      } else if (element2) {
        return arrow({
          element: element2,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var index = typeof document !== "undefined" ? import_react17.useLayoutEffect : import_react17.useEffect;
function deepEqual(a4, b4) {
  if (a4 === b4) {
    return true;
  }
  if (typeof a4 !== typeof b4) {
    return false;
  }
  if (typeof a4 === "function" && a4.toString() === b4.toString()) {
    return true;
  }
  let length, i5, keys2;
  if (a4 && b4 && typeof a4 == "object") {
    if (Array.isArray(a4)) {
      length = a4.length;
      if (length != b4.length)
        return false;
      for (i5 = length; i5-- !== 0; ) {
        if (!deepEqual(a4[i5], b4[i5])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a4);
    length = keys2.length;
    if (length !== Object.keys(b4).length) {
      return false;
    }
    for (i5 = length; i5-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b4, keys2[i5])) {
        return false;
      }
    }
    for (i5 = length; i5-- !== 0; ) {
      const key = keys2[i5];
      if (key === "_owner" && a4.$$typeof) {
        continue;
      }
      if (!deepEqual(a4[key], b4[key])) {
        return false;
      }
    }
    return true;
  }
  return a4 !== a4 && b4 !== b4;
}
function getDPR(element2) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element2.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element2, value) {
  const dpr = getDPR(element2);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React31.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React31.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React31.useState(middleware2);
  if (!deepEqual(latestMiddleware, middleware2)) {
    setLatestMiddleware(middleware2);
  }
  const [_reference, _setReference] = React31.useState(null);
  const [_floating, _setFloating] = React31.useState(null);
  const setReference = React31.useCallback((node) => {
    if (node != referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, [_setReference]);
  const setFloating = React31.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, [_setFloating]);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React31.useRef(null);
  const floatingRef = React31.useRef(null);
  const dataRef = React31.useRef(data);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const update = React31.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React31.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      } else {
        update();
      }
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef]);
  const refs = React31.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React31.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React31.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x4 = roundByDPR(elements.floating, data.x);
    const y3 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x4 + "px, " + y3 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x4,
      top: y3
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React31.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}

// ../../node_modules/@radix-ui/react-arrow/dist/index.mjs
init_extends();
var import_react20 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-primitive/dist/index.mjs
init_extends();
var import_react19 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);

// ../../node_modules/@radix-ui/react-slot/dist/index.mjs
init_extends();
var import_react18 = __toESM(require_react(), 1);
var $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ (0, import_react18.forwardRef)((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = import_react18.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (import_react18.Children.count(newElement) > 1)
          return import_react18.Children.only(null);
        return /* @__PURE__ */ (0, import_react18.isValidElement)(newElement) ? newElement.props.children : null;
      } else
        return child;
    });
    return /* @__PURE__ */ (0, import_react18.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ (0, import_react18.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react18.cloneElement)(newElement, void 0, newChildren) : null);
  }
  return /* @__PURE__ */ (0, import_react18.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
var $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ (0, import_react18.forwardRef)((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ (0, import_react18.isValidElement)(children))
    return /* @__PURE__ */ (0, import_react18.cloneElement)(children, {
      ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
      ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref) : children.ref
    });
  return import_react18.Children.count(children) > 1 ? import_react18.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
var $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
  return /* @__PURE__ */ (0, import_react18.createElement)(import_react18.Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable(child) {
  return /* @__PURE__ */ (0, import_react18.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue)
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      else if (slotPropValue)
        overrideProps[propName] = slotPropValue;
    } else if (propName === "style")
      overrideProps[propName] = {
        ...slotPropValue,
        ...childPropValue
      };
    else if (propName === "className")
      overrideProps[propName] = [
        slotPropValue,
        childPropValue
      ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}

// ../../node_modules/@radix-ui/react-primitive/dist/index.mjs
var $8927f6f2acc4f386$var$NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node) => {
  const Node2 = /* @__PURE__ */ (0, import_react19.forwardRef)((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node;
    (0, import_react19.useEffect)(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []);
    return /* @__PURE__ */ (0, import_react19.createElement)(Comp, _extends({}, primitiveProps, {
      ref: forwardedRef
    }));
  });
  Node2.displayName = `Primitive.${node}`;
  return {
    ...primitive,
    [node]: Node2
  };
}, {});
function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {
  if (target)
    (0, import_react_dom.flushSync)(
      () => target.dispatchEvent(event)
    );
}

// ../../node_modules/@radix-ui/react-arrow/dist/index.mjs
var $7e8f5cd07187803e$export$21b07c8f274aebd5 = /* @__PURE__ */ (0, import_react20.forwardRef)((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ (0, import_react20.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.svg, _extends({}, arrowProps, {
    ref: forwardedRef,
    width,
    height,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none"
  }), props.asChild ? children : /* @__PURE__ */ (0, import_react20.createElement)("polygon", {
    points: "0,0 30,0 15,10"
  }));
});
var $7e8f5cd07187803e$export$be92b6f5f03c0fe9 = $7e8f5cd07187803e$export$21b07c8f274aebd5;

// ../../node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var import_react21 = __toESM(require_react(), 1);
var $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react21.useLayoutEffect : () => {
};

// ../../node_modules/@radix-ui/react-use-size/dist/index.mjs
var import_react22 = __toESM(require_react(), 1);
function $db6c3485150b8e66$export$1ab7ae714698c4b8(element2) {
  const [size3, setSize] = (0, import_react22.useState)(void 0);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (element2) {
      setSize({
        width: element2.offsetWidth,
        height: element2.offsetHeight
      });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries))
          return;
        if (!entries.length)
          return;
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element2.offsetWidth;
          height = element2.offsetHeight;
        }
        setSize({
          width,
          height
        });
      });
      resizeObserver.observe(element2, {
        box: "border-box"
      });
      return () => resizeObserver.unobserve(element2);
    } else
      setSize(void 0);
  }, [
    element2
  ]);
  return size3;
}

// ../../node_modules/@radix-ui/react-popper/dist/index.mjs
var $cf1ac5d9fe0e8206$var$POPPER_NAME = "Popper";
var [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME);
var [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);
var $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = (0, import_react23.useState)(null);
  return /* @__PURE__ */ (0, import_react23.createElement)($cf1ac5d9fe0e8206$var$PopperProvider, {
    scope: __scopePopper,
    anchor,
    onAnchorChange: setAnchor
  }, children);
};
var $cf1ac5d9fe0e8206$var$ANCHOR_NAME = "PopperAnchor";
var $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = /* @__PURE__ */ (0, import_react23.forwardRef)((props, forwardedRef) => {
  const { __scopePopper, virtualRef, ...anchorProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME, __scopePopper);
  const ref = (0, import_react23.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  (0, import_react23.useEffect)(() => {
    context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);
  });
  return virtualRef ? null : /* @__PURE__ */ (0, import_react23.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, anchorProps, {
    ref: composedRefs
  }));
});
var $cf1ac5d9fe0e8206$var$CONTENT_NAME = "PopperContent";
var [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);
var $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /* @__PURE__ */ (0, import_react23.forwardRef)((props, forwardedRef) => {
  var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$trans, _middlewareData$trans2, _middlewareData$hide;
  const { __scopePopper, side = "bottom", sideOffset = 0, align = "center", alignOffset = 0, arrowPadding = 0, avoidCollisions = true, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = "partial", hideWhenDetached = false, updatePositionStrategy = "optimized", onPlaced, ...contentProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
  const [content, setContent] = (0, import_react23.useState)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setContent(node)
  );
  const [arrow3, setArrow] = (0, import_react23.useState)(null);
  const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow3);
  const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
  const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
  const desiredPlacement = side + (align !== "center" ? "-" + align : "");
  const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...collisionPaddingProp
  };
  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
    collisionBoundary
  ];
  const hasExplicitBoundaries = boundary.length > 0;
  const detectOverflowOptions = {
    padding: collisionPadding,
    boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),
    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
    altBoundary: hasExplicitBoundaries
  };
  const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
    strategy: "fixed",
    placement: desiredPlacement,
    whileElementsMounted: (...args) => {
      const cleanup = autoUpdate(...args, {
        animationFrame: updatePositionStrategy === "always"
      });
      return cleanup;
    },
    elements: {
      reference: context.anchor
    },
    middleware: [
      offset({
        mainAxis: sideOffset + arrowHeight,
        alignmentAxis: alignOffset
      }),
      avoidCollisions && shift({
        mainAxis: true,
        crossAxis: false,
        limiter: sticky === "partial" ? limitShift() : void 0,
        ...detectOverflowOptions
      }),
      avoidCollisions && flip({
        ...detectOverflowOptions
      }),
      size({
        ...detectOverflowOptions,
        apply: ({ elements, rects, availableWidth, availableHeight }) => {
          const { width: anchorWidth, height: anchorHeight } = rects.reference;
          const contentStyle = elements.floating.style;
          contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
          contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
          contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
          contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
        }
      }),
      arrow3 && arrow2({
        element: arrow3,
        padding: arrowPadding
      }),
      $cf1ac5d9fe0e8206$var$transformOrigin({
        arrowWidth,
        arrowHeight
      }),
      hideWhenDetached && hide({
        strategy: "referenceHidden",
        ...detectOverflowOptions
      })
    ]
  });
  const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
  const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPlaced);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (isPositioned)
      handlePlaced === null || handlePlaced === void 0 || handlePlaced();
  }, [
    isPositioned,
    handlePlaced
  ]);
  const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
  const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
  const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
  const [contentZIndex, setContentZIndex] = (0, import_react23.useState)();
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (content)
      setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [
    content
  ]);
  return /* @__PURE__ */ (0, import_react23.createElement)("div", {
    ref: refs.setFloating,
    "data-radix-popper-content-wrapper": "",
    style: {
      ...floatingStyles,
      transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
      // keep off the page when measuring
      minWidth: "max-content",
      zIndex: contentZIndex,
      ["--radix-popper-transform-origin"]: [
        (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
        (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
      ].join(" ")
    },
    dir: props.dir
  }, /* @__PURE__ */ (0, import_react23.createElement)($cf1ac5d9fe0e8206$var$PopperContentProvider, {
    scope: __scopePopper,
    placedSide,
    onArrowChange: setArrow,
    arrowX,
    arrowY,
    shouldHideArrow: cannotCenterArrow
  }, /* @__PURE__ */ (0, import_react23.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    "data-side": placedSide,
    "data-align": placedAlign
  }, contentProps, {
    ref: composedRefs,
    style: {
      ...contentProps.style,
      // if the PopperContent hasn't been placed yet (not all measurements done)
      // we prevent animations so that users's animation don't kick in too early referring wrong sides
      animation: !isPositioned ? "none" : void 0,
      // hide the content if using the hide middleware and should be hidden
      opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0
    }
  }))));
});
var $cf1ac5d9fe0e8206$var$ARROW_NAME = "PopperArrow";
var $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0 = /* @__PURE__ */ (0, import_react23.forwardRef)(function $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd02(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = $cf1ac5d9fe0e8206$var$useContentContext($cf1ac5d9fe0e8206$var$ARROW_NAME, __scopePopper);
  const baseSide = $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ (0, import_react23.createElement)("span", {
      ref: contentContext.onArrowChange,
      style: {
        position: "absolute",
        left: contentContext.arrowX,
        top: contentContext.arrowY,
        [baseSide]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[contentContext.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: `rotate(180deg)`,
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[contentContext.placedSide],
        visibility: contentContext.shouldHideArrow ? "hidden" : void 0
      }
    }, /* @__PURE__ */ (0, import_react23.createElement)($7e8f5cd07187803e$export$be92b6f5f03c0fe9, _extends({}, arrowProps, {
      ref: forwardedRef,
      style: {
        ...arrowProps.style,
        // ensures the element can be measured correctly (mostly for if SVG)
        display: "block"
      }
    })))
  );
});
function $cf1ac5d9fe0e8206$var$isNotNull(value) {
  return value !== null;
}
var $cf1ac5d9fe0e8206$var$transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
    const noArrowAlign = {
      start: "0%",
      center: "50%",
      end: "100%"
    }[placedAlign];
    const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
    const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
    let x4 = "";
    let y3 = "";
    if (placedSide === "bottom") {
      x4 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y3 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x4 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y3 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x4 = `${-arrowHeight}px`;
      y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x4 = `${rects.floating.width + arrowHeight}px`;
      y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return {
      data: {
        x: x4,
        y: y3
      }
    };
  }
});
function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [
    side,
    align
  ];
}
var $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9;
var $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d;
var $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;
var $cf1ac5d9fe0e8206$export$21b07c8f274aebd5 = $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0;

// ../../node_modules/@radix-ui/react-portal/dist/index.mjs
init_extends();
var import_react24 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
var $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ (0, import_react24.forwardRef)((props, forwardedRef) => {
  var _globalThis$document;
  const { container = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body, ...portalProps } = props;
  return container ? /* @__PURE__ */ import_react_dom3.default.createPortal(/* @__PURE__ */ (0, import_react24.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, portalProps, {
    ref: forwardedRef
  })), container) : null;
});

// ../../node_modules/@radix-ui/react-presence/dist/index.mjs
var import_react25 = __toESM(require_react(), 1);
var import_react_dom4 = __toESM(require_react_dom(), 1);
function $fe963b355347cc68$export$3e6543de14f8614f(initialState, machine) {
  return (0, import_react25.useReducer)((state, event) => {
    const nextState = machine[state][event];
    return nextState !== null && nextState !== void 0 ? nextState : state;
  }, initialState);
}
var $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {
  const { present, children } = props;
  const presence = $921a889cee6df7e8$var$usePresence(present);
  const child = typeof children === "function" ? children({
    present: presence.isPresent
  }) : import_react25.Children.only(children);
  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? /* @__PURE__ */ (0, import_react25.cloneElement)(child, {
    ref
  }) : null;
};
$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
function $921a889cee6df7e8$var$usePresence(present) {
  const [node1, setNode] = (0, import_react25.useState)();
  const stylesRef = (0, import_react25.useRef)({});
  const prevPresentRef = (0, import_react25.useRef)(present);
  const prevAnimationNameRef = (0, import_react25.useRef)("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  (0, import_react25.useEffect)(() => {
    const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [
    state
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles);
      if (present)
        send("MOUNT");
      else if (currentAnimationName === "none" || (styles === null || styles === void 0 ? void 0 : styles.display) === "none")
        send("UNMOUNT");
      else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating)
          send("ANIMATION_OUT");
        else
          send("UNMOUNT");
      }
      prevPresentRef.current = present;
    }
  }, [
    present,
    send
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (node1) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node1 && isCurrentAnimation)
          (0, import_react_dom4.flushSync)(
            () => send("ANIMATION_END")
          );
      };
      const handleAnimationStart = (event) => {
        if (event.target === node1)
          prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
      };
      node1.addEventListener("animationstart", handleAnimationStart);
      node1.addEventListener("animationcancel", handleAnimationEnd);
      node1.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node1.removeEventListener("animationstart", handleAnimationStart);
        node1.removeEventListener("animationcancel", handleAnimationEnd);
        node1.removeEventListener("animationend", handleAnimationEnd);
      };
    } else
      send("ANIMATION_END");
  }, [
    node1,
    send
  ]);
  return {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(state),
    ref: (0, import_react25.useCallback)((node) => {
      if (node)
        stylesRef.current = getComputedStyle(node);
      setNode(node);
    }, [])
  };
}
function $921a889cee6df7e8$var$getAnimationName(styles) {
  return (styles === null || styles === void 0 ? void 0 : styles.animationName) || "none";
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
init_extends();
var import_react27 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var import_react26 = __toESM(require_react(), 1);
function $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);
  (0, import_react26.useEffect)(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape")
        onEscapeKeyDown(event);
    };
    ownerDocument.addEventListener("keydown", handleKeyDown);
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown);
  }, [
    onEscapeKeyDown,
    ownerDocument
  ]);
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var $5cb92bef7577960e$var$CONTEXT_UPDATE = "dismissableLayer.update";
var $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var $5cb92bef7577960e$var$FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var $5cb92bef7577960e$var$originalBodyPointerEvents;
var $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ (0, import_react27.createContext)({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ (0, import_react27.forwardRef)((props, forwardedRef) => {
  var _node$ownerDocument;
  const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;
  const context = (0, import_react27.useContext)($5cb92bef7577960e$var$DismissableLayerContext);
  const [node1, setNode] = (0, import_react27.useState)(null);
  const ownerDocument = (_node$ownerDocument = node1 === null || node1 === void 0 ? void 0 : node1.ownerDocument) !== null && _node$ownerDocument !== void 0 ? _node$ownerDocument : globalThis === null || globalThis === void 0 ? void 0 : globalThis.document;
  const [, force] = (0, import_react27.useState)({});
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setNode(node)
  );
  const layers = Array.from(context.layers);
  const [highestLayerWithOutsidePointerEventsDisabled] = [
    ...context.layersWithOutsidePointerEventsDisabled
  ].slice(-1);
  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
  const index2 = node1 ? layers.indexOf(node1) : -1;
  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
  const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
  const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {
    const target = event.target;
    const isPointerDownOnBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (!isPointerEventsEnabled || isPointerDownOnBranch)
      return;
    onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented)
      onDismiss === null || onDismiss === void 0 || onDismiss();
  }, ownerDocument);
  const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {
    const target = event.target;
    const isFocusInBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (isFocusInBranch)
      return;
    onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented)
      onDismiss === null || onDismiss === void 0 || onDismiss();
  }, ownerDocument);
  $addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {
    const isHighestLayer = index2 === context.layers.size - 1;
    if (!isHighestLayer)
      return;
    onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }, ownerDocument);
  (0, import_react27.useEffect)(() => {
    if (!node1)
      return;
    if (disableOutsidePointerEvents) {
      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
        $5cb92bef7577960e$var$originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
        ownerDocument.body.style.pointerEvents = "none";
      }
      context.layersWithOutsidePointerEventsDisabled.add(node1);
    }
    context.layers.add(node1);
    $5cb92bef7577960e$var$dispatchUpdate();
    return () => {
      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1)
        ownerDocument.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;
    };
  }, [
    node1,
    ownerDocument,
    disableOutsidePointerEvents,
    context
  ]);
  (0, import_react27.useEffect)(() => {
    return () => {
      if (!node1)
        return;
      context.layers.delete(node1);
      context.layersWithOutsidePointerEventsDisabled.delete(node1);
      $5cb92bef7577960e$var$dispatchUpdate();
    };
  }, [
    node1,
    context
  ]);
  (0, import_react27.useEffect)(() => {
    const handleUpdate = () => force({});
    document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
    return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
  }, []);
  return /* @__PURE__ */ (0, import_react27.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, layerProps, {
    ref: composedRefs,
    style: {
      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
      ...props.style
    },
    onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),
    onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),
    onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
  }));
});
function $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);
  const isPointerInsideReactTreeRef = (0, import_react27.useRef)(false);
  const handleClickRef = (0, import_react27.useRef)(() => {
  });
  (0, import_react27.useEffect)(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent = function() {
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {
            discrete: true
          });
        };
        const eventDetail = {
          originalEvent: event
        };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;
          ownerDocument.addEventListener("click", handleClickRef.current, {
            once: true
          });
        } else
          handleAndDispatchPointerDownOutsideEvent();
      } else
        ownerDocument.removeEventListener("click", handleClickRef.current);
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [
    ownerDocument,
    handlePointerDownOutside
  ]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function $5cb92bef7577960e$var$useFocusOutside(onFocusOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);
  const isFocusInsideReactTreeRef = (0, import_react27.useRef)(false);
  (0, import_react27.useEffect)(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = {
          originalEvent: event
        };
        $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [
    ownerDocument,
    handleFocusOutside
  ]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function $5cb92bef7577960e$var$dispatchUpdate() {
  const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name2, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name2, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler)
    target.addEventListener(name2, handler, {
      once: true
    });
  if (discrete)
    $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);
  else
    target.dispatchEvent(event);
}

// ../../node_modules/@radix-ui/react-hover-card/dist/index.mjs
var $cef8881cdc69808e$var$originalBodyUserSelect;
var $cef8881cdc69808e$var$HOVERCARD_NAME = "HoverCard";
var [$cef8881cdc69808e$var$createHoverCardContext, $cef8881cdc69808e$export$47b6998a836b7260] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cef8881cdc69808e$var$HOVERCARD_NAME, [
  $cf1ac5d9fe0e8206$export$722aac194ae923
]);
var $cef8881cdc69808e$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
var [$cef8881cdc69808e$var$HoverCardProvider, $cef8881cdc69808e$var$useHoverCardContext] = $cef8881cdc69808e$var$createHoverCardContext($cef8881cdc69808e$var$HOVERCARD_NAME);
var $cef8881cdc69808e$export$57a077cc9fbe653e = (props) => {
  const { __scopeHoverCard, children, open: openProp, defaultOpen, onOpenChange, openDelay = 700, closeDelay = 300 } = props;
  const popperScope = $cef8881cdc69808e$var$usePopperScope(__scopeHoverCard);
  const openTimerRef = (0, import_react28.useRef)(0);
  const closeTimerRef = (0, import_react28.useRef)(0);
  const hasSelectionRef = (0, import_react28.useRef)(false);
  const isPointerDownOnContentRef = (0, import_react28.useRef)(false);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  const handleOpen = (0, import_react28.useCallback)(() => {
    clearTimeout(closeTimerRef.current);
    openTimerRef.current = window.setTimeout(
      () => setOpen(true),
      openDelay
    );
  }, [
    openDelay,
    setOpen
  ]);
  const handleClose = (0, import_react28.useCallback)(() => {
    clearTimeout(openTimerRef.current);
    if (!hasSelectionRef.current && !isPointerDownOnContentRef.current)
      closeTimerRef.current = window.setTimeout(
        () => setOpen(false),
        closeDelay
      );
  }, [
    closeDelay,
    setOpen
  ]);
  const handleDismiss = (0, import_react28.useCallback)(
    () => setOpen(false),
    [
      setOpen
    ]
  );
  (0, import_react28.useEffect)(() => {
    return () => {
      clearTimeout(openTimerRef.current);
      clearTimeout(closeTimerRef.current);
    };
  }, []);
  return /* @__PURE__ */ (0, import_react28.createElement)($cef8881cdc69808e$var$HoverCardProvider, {
    scope: __scopeHoverCard,
    open,
    onOpenChange: setOpen,
    onOpen: handleOpen,
    onClose: handleClose,
    onDismiss: handleDismiss,
    hasSelectionRef,
    isPointerDownOnContentRef
  }, /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, children));
};
var $cef8881cdc69808e$var$TRIGGER_NAME = "HoverCardTrigger";
var $cef8881cdc69808e$export$ef9f7fd8e4ba882f = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const { __scopeHoverCard, ...triggerProps } = props;
  const context = $cef8881cdc69808e$var$useHoverCardContext($cef8881cdc69808e$var$TRIGGER_NAME, __scopeHoverCard);
  const popperScope = $cef8881cdc69808e$var$usePopperScope(__scopeHoverCard);
  return /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({
    asChild: true
  }, popperScope), /* @__PURE__ */ (0, import_react28.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.a, _extends({
    "data-state": context.open ? "open" : "closed"
  }, triggerProps, {
    ref: forwardedRef,
    onPointerEnter: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerEnter, $cef8881cdc69808e$var$excludeTouch(context.onOpen)),
    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $cef8881cdc69808e$var$excludeTouch(context.onClose)),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, context.onOpen),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, context.onClose),
    onTouchStart: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onTouchStart,
      (event) => event.preventDefault()
    )
  })));
});
var $cef8881cdc69808e$var$PORTAL_NAME = "HoverCardPortal";
var [$cef8881cdc69808e$var$PortalProvider, $cef8881cdc69808e$var$usePortalContext] = $cef8881cdc69808e$var$createHoverCardContext($cef8881cdc69808e$var$PORTAL_NAME, {
  forceMount: void 0
});
var $cef8881cdc69808e$export$b384c6e0a789f88b = (props) => {
  const { __scopeHoverCard, forceMount, children, container } = props;
  const context = $cef8881cdc69808e$var$useHoverCardContext($cef8881cdc69808e$var$PORTAL_NAME, __scopeHoverCard);
  return /* @__PURE__ */ (0, import_react28.createElement)($cef8881cdc69808e$var$PortalProvider, {
    scope: __scopeHoverCard,
    forceMount
  }, /* @__PURE__ */ (0, import_react28.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ (0, import_react28.createElement)($f1701beae083dbae$export$602eac185826482c, {
    asChild: true,
    container
  }, children)));
};
var $cef8881cdc69808e$var$CONTENT_NAME = "HoverCardContent";
var $cef8881cdc69808e$export$aa4724a5938c586 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const portalContext = $cef8881cdc69808e$var$usePortalContext($cef8881cdc69808e$var$CONTENT_NAME, props.__scopeHoverCard);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $cef8881cdc69808e$var$useHoverCardContext($cef8881cdc69808e$var$CONTENT_NAME, props.__scopeHoverCard);
  return /* @__PURE__ */ (0, import_react28.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ (0, import_react28.createElement)($cef8881cdc69808e$var$HoverCardContentImpl, _extends({
    "data-state": context.open ? "open" : "closed"
  }, contentProps, {
    onPointerEnter: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerEnter, $cef8881cdc69808e$var$excludeTouch(context.onOpen)),
    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $cef8881cdc69808e$var$excludeTouch(context.onClose)),
    ref: forwardedRef
  })));
});
var $cef8881cdc69808e$var$HoverCardContentImpl = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const { __scopeHoverCard, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, ...contentProps } = props;
  const context = $cef8881cdc69808e$var$useHoverCardContext($cef8881cdc69808e$var$CONTENT_NAME, __scopeHoverCard);
  const popperScope = $cef8881cdc69808e$var$usePopperScope(__scopeHoverCard);
  const ref = (0, import_react28.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const [containSelection, setContainSelection] = (0, import_react28.useState)(false);
  (0, import_react28.useEffect)(() => {
    if (containSelection) {
      const body = document.body;
      $cef8881cdc69808e$var$originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
      body.style.userSelect = "none";
      body.style.webkitUserSelect = "none";
      return () => {
        body.style.userSelect = $cef8881cdc69808e$var$originalBodyUserSelect;
        body.style.webkitUserSelect = $cef8881cdc69808e$var$originalBodyUserSelect;
      };
    }
  }, [
    containSelection
  ]);
  (0, import_react28.useEffect)(() => {
    if (ref.current) {
      const handlePointerUp = () => {
        setContainSelection(false);
        context.isPointerDownOnContentRef.current = false;
        setTimeout(() => {
          var _document$getSelectio;
          const hasSelection = ((_document$getSelectio = document.getSelection()) === null || _document$getSelectio === void 0 ? void 0 : _document$getSelectio.toString()) !== "";
          if (hasSelection)
            context.hasSelectionRef.current = true;
        });
      };
      document.addEventListener("pointerup", handlePointerUp);
      return () => {
        document.removeEventListener("pointerup", handlePointerUp);
        context.hasSelectionRef.current = false;
        context.isPointerDownOnContentRef.current = false;
      };
    }
  }, [
    context.isPointerDownOnContentRef,
    context.hasSelectionRef
  ]);
  (0, import_react28.useEffect)(() => {
    if (ref.current) {
      const tabbables = $cef8881cdc69808e$var$getTabbableNodes(ref.current);
      tabbables.forEach(
        (tabbable) => tabbable.setAttribute("tabindex", "-1")
      );
    }
  });
  return /* @__PURE__ */ (0, import_react28.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents: false,
    onInteractOutside,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onFocusOutside, (event) => {
      event.preventDefault();
    }),
    onDismiss: context.onDismiss
  }, /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({}, popperScope, contentProps, {
    onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onPointerDown, (event) => {
      if (event.currentTarget.contains(event.target))
        setContainSelection(true);
      context.hasSelectionRef.current = false;
      context.isPointerDownOnContentRef.current = true;
    }),
    ref: composedRefs,
    style: {
      ...contentProps.style,
      userSelect: containSelection ? "text" : void 0,
      // Safari requires prefix
      WebkitUserSelect: containSelection ? "text" : void 0,
      "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)",
      "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)",
      "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)"
    }
  })));
});
var $cef8881cdc69808e$export$b9744d3e7456d806 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {
  const { __scopeHoverCard, ...arrowProps } = props;
  const popperScope = $cef8881cdc69808e$var$usePopperScope(__scopeHoverCard);
  return /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {
    ref: forwardedRef
  }));
});
function $cef8881cdc69808e$var$excludeTouch(eventHandler) {
  return (event) => event.pointerType === "touch" ? void 0 : eventHandler();
}
function $cef8881cdc69808e$var$getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
var $cef8881cdc69808e$export$be92b6f5f03c0fe9 = $cef8881cdc69808e$export$57a077cc9fbe653e;
var $cef8881cdc69808e$export$41fb9f06171c75f4 = $cef8881cdc69808e$export$ef9f7fd8e4ba882f;
var $cef8881cdc69808e$export$602eac185826482c = $cef8881cdc69808e$export$b384c6e0a789f88b;
var $cef8881cdc69808e$export$7c6e2c02157bb7d2 = $cef8881cdc69808e$export$aa4724a5938c586;
var $cef8881cdc69808e$export$21b07c8f274aebd5 = $cef8881cdc69808e$export$b9744d3e7456d806;

// ../../packages/myst-to-react/dist/components/HoverPopover.js
function HoverPopover({ children, openDelay = 400, card, side, arrowClass = "fill-white" }) {
  const [load2, setLoad] = (0, import_react29.useState)(false);
  return (0, import_jsx_runtime13.jsxs)($cef8881cdc69808e$export$be92b6f5f03c0fe9, { openDelay, children: [(0, import_jsx_runtime13.jsx)($cef8881cdc69808e$export$41fb9f06171c75f4, { asChild: true, onMouseEnter: () => setLoad(true), children }), (0, import_jsx_runtime13.jsx)($cef8881cdc69808e$export$602eac185826482c, { children: (0, import_jsx_runtime13.jsxs)($cef8881cdc69808e$export$7c6e2c02157bb7d2, { className: "exclude-from-outline hover-card-content", sideOffset: 5, side, children: [typeof card === "function" ? load2 && card({ load: load2 }) : card, (0, import_jsx_runtime13.jsx)($cef8881cdc69808e$export$21b07c8f274aebd5, { className: arrowClass })] }) })] });
}
function Tooltip({ title, children }) {
  return (0, import_jsx_runtime13.jsx)(HoverPopover, { side: "top", card: (0, import_jsx_runtime13.jsx)("div", { className: "p-1 text-xs text-white bg-blue-900 dark:bg-white dark:text-black", children: title }), arrowClass: "fill-blue-900 dark:fill-white", children });
}

// ../../packages/myst-to-react/dist/components/LinkCard.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_classnames3 = __toESM(require_classnames(), 1);
function LinkCard({ url, title, internal = false, loading = false, description, thumbnail, className = "w-[300px] sm:max-w-[500px] bg-white rounded shadow-md" }) {
  const Link2 = useLinkProvider();
  const baseurl = useBaseurl();
  const to = withBaseurl(url, baseurl);
  return (0, import_jsx_runtime14.jsxs)("div", { className: (0, import_classnames3.default)("hover-card-content rounded overflow-hidden", className, {
    "animate-pulse": loading
  }), children: [!loading && thumbnail && (0, import_jsx_runtime14.jsx)("img", { src: thumbnail, className: "w-full h-[150px] object-cover object-top object-left m-0" }), loading && (0, import_jsx_runtime14.jsx)("div", { className: "animate-pulse bg-slate-100 dark:bg-slate-800 w-full h-[150px]" }), internal && (0, import_jsx_runtime14.jsx)(Link2, { to, className: "block px-3 mt-3 text-sm font-semibold text-inherit hover:text-inherit", prefetch: "intent", children: title }), !internal && (0, import_jsx_runtime14.jsxs)("a", { href: to, className: "block px-3 mt-3 text-sm font-semibold text-inherit hover:text-inherit", target: "_blank", rel: "noreferrer", children: [(0, import_jsx_runtime14.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1rem", height: "1rem", className: "float-right" }), title] }), !loading && description && (0, import_jsx_runtime14.jsx)("div", { className: "p-3 prose text-sm max-h-[300px] overflow-hidden", children: description })] });
}

// ../../packages/myst-to-react/dist/basic.js
var BASIC_RENDERERS = {
  text({ node }) {
    var _a;
    if (!((_a = node.value) === null || _a === void 0 ? void 0 : _a.includes("\u200B"))) {
      return (0, import_jsx_runtime15.jsx)(import_jsx_runtime15.Fragment, { children: node.value });
    }
    const text = node.value.split("\u200B");
    return (0, import_jsx_runtime15.jsx)(import_jsx_runtime15.Fragment, { children: text.map((v2, i5) => (0, import_jsx_runtime15.jsxs)(import_react30.default.Fragment, { children: [v2, i5 < text.length - 1 && (0, import_jsx_runtime15.jsx)("wbr", {})] }, i5)) });
  },
  span({ node }) {
    return (0, import_jsx_runtime15.jsx)("span", { className: node.class, style: node.style, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  div({ node }) {
    return (0, import_jsx_runtime15.jsx)("div", { className: node.class, style: node.style, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  delete({ node }) {
    return (0, import_jsx_runtime15.jsx)("del", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  strong({ node }) {
    return (0, import_jsx_runtime15.jsx)("strong", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  emphasis({ node }) {
    return (0, import_jsx_runtime15.jsx)("em", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  underline({ node }) {
    return (0, import_jsx_runtime15.jsx)("span", { style: { textDecoration: "underline" }, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  smallcaps({ node }) {
    return (0, import_jsx_runtime15.jsx)("span", { style: { fontVariant: "small-caps" }, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  link({ node }) {
    return (0, import_jsx_runtime15.jsx)("a", { target: "_blank", href: node.url, rel: "noreferrer", children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  paragraph({ node }) {
    return (0, import_jsx_runtime15.jsx)("p", { id: node.html_id, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  algorithmLine({ node }) {
    var _a;
    const style = {
      paddingLeft: `${((_a = node.indent) !== null && _a !== void 0 ? _a : 0) + 2}rem`
    };
    return (0, import_jsx_runtime15.jsx)("p", { className: "line", style, "data-line-number": node.enumerator, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  break() {
    return (0, import_jsx_runtime15.jsx)("br", {});
  },
  inlineMath({ node }) {
    return (0, import_jsx_runtime15.jsx)("code", { children: node.value });
  },
  math({ node }) {
    return (0, import_jsx_runtime15.jsx)("code", { children: node.value });
  },
  list({ node }) {
    if (node.ordered) {
      return (0, import_jsx_runtime15.jsx)("ol", { start: node.start || void 0, id: node.html_id, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
    }
    return (0, import_jsx_runtime15.jsx)("ul", { id: node.html_id, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  listItem({ node }) {
    if (node.checked == null) {
      return (0, import_jsx_runtime15.jsx)("li", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
    }
    return (0, import_jsx_runtime15.jsxs)("li", { className: "task-list-item", children: [(0, import_jsx_runtime15.jsx)("input", { type: "checkbox", className: "task-list-item-checkbox", defaultChecked: node.checked }), (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children })] });
  },
  container({ node }) {
    const figureName = `fig-${node.kind}`;
    return (0, import_jsx_runtime15.jsx)("figure", { id: node.html_id || node.identifier || node.key, className: (0, import_classnames4.default)({ [figureName]: !!node.kind, subcontainer: node.subcontainer }, node.class), children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  caption({ node }) {
    return (0, import_jsx_runtime15.jsx)("figcaption", { className: "group", children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  legend({ node }) {
    return (0, import_jsx_runtime15.jsx)("figcaption", { className: "text-sm", children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  blockquote({ node }) {
    return (0, import_jsx_runtime15.jsx)("blockquote", { id: node.html_id, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  thematicBreak() {
    return (0, import_jsx_runtime15.jsx)("hr", { className: "py-2 my-5 translate-y-2" });
  },
  captionNumber({ node }) {
    const id = node.html_id || node.identifier || node.key;
    return (0, import_jsx_runtime15.jsx)(HashLink, { id, kind: node.kind, className: "mr-1 font-semibold text-inherit hover:text-inherit hover:font-semibold", children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  table({ node }) {
    return (0, import_jsx_runtime15.jsx)("table", { className: node.class, style: node.style, children: (0, import_jsx_runtime15.jsx)("tbody", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) }) });
  },
  tableRow({ node }) {
    return (0, import_jsx_runtime15.jsx)("tr", { className: node.class, style: node.style, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  tableCell({ node }) {
    const ifGreaterThanOne = (num) => num === 1 ? void 0 : num;
    const attrs = {
      rowSpan: ifGreaterThanOne(node.rowspan),
      colSpan: ifGreaterThanOne(node.colspan)
    };
    const align = {
      "text-left": node.align === "left",
      "text-right": node.align === "right",
      "text-center": node.align === "center"
    };
    if (node.header)
      return (0, import_jsx_runtime15.jsx)("th", Object.assign({ className: (0, import_classnames4.default)(node.class, align), style: node.style }, attrs, { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) }));
    return (0, import_jsx_runtime15.jsx)("td", Object.assign({ className: (0, import_classnames4.default)(node.class, align), style: node.style }, attrs, { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) }));
  },
  subscript({ node }) {
    return (0, import_jsx_runtime15.jsx)("sub", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  superscript({ node }) {
    return (0, import_jsx_runtime15.jsx)("sup", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  abbreviation({ node }) {
    return (0, import_jsx_runtime15.jsx)(Tooltip, { title: node.title, children: (0, import_jsx_runtime15.jsx)("abbr", { "aria-label": node.title, className: "border-b border-dotted cursor-help", children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) }) });
  },
  mystComment() {
    return null;
  },
  comment() {
    return null;
  },
  definitionList({ node }) {
    return (0, import_jsx_runtime15.jsx)("dl", { className: "my-5", id: node.html_id, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  definitionTerm({ node }) {
    var _a, _b;
    const allowedStrongTypes = /* @__PURE__ */ new Set(["text", "emphasis"]);
    const makeStrong = (_b = (_a = node.children) === null || _a === void 0 ? void 0 : _a.reduce((allowed, n4) => allowed && allowedStrongTypes.has(n4.type), true)) !== null && _b !== void 0 ? _b : false;
    return (0, import_jsx_runtime15.jsx)("dt", { id: node.html_id, children: makeStrong ? (0, import_jsx_runtime15.jsx)("strong", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) }) : (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  definitionDescription({ node }) {
    return (0, import_jsx_runtime15.jsx)("dd", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  aside({ node }) {
    return (0, import_jsx_runtime15.jsx)("aside", { className: "text-sm lg:h-0 col-margin-right", children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  keyboard({ node }) {
    return (0, import_jsx_runtime15.jsx)("kbd", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  }
};
var basic_default = BASIC_RENDERERS;

// ../../packages/myst-to-react/dist/admonitions.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@heroicons/react/24/solid/esm/Bars3Icon.js
var React33 = __toESM(require_react(), 1);
function Bars3Icon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React33.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React33.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React33.createElement("path", {
    fillRule: "evenodd",
    d: "M3 6.75A.75.75 0 013.75 6h16.5a.75.75 0 010 1.5H3.75A.75.75 0 013 6.75zM3 12a.75.75 0 01.75-.75h16.5a.75.75 0 010 1.5H3.75A.75.75 0 013 12zm0 5.25a.75.75 0 01.75-.75h16.5a.75.75 0 010 1.5H3.75a.75.75 0 01-.75-.75z",
    clipRule: "evenodd"
  }));
}
var ForwardRef25 = React33.forwardRef(Bars3Icon);
var Bars3Icon_default = ForwardRef25;

// ../../node_modules/@heroicons/react/24/solid/esm/BoltIcon.js
var React34 = __toESM(require_react(), 1);
function BoltIcon2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React34.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React34.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React34.createElement("path", {
    fillRule: "evenodd",
    d: "M14.615 1.595a.75.75 0 01.359.852L12.982 9.75h7.268a.75.75 0 01.548 1.262l-10.5 11.25a.75.75 0 01-1.272-.71l1.992-7.302H3.75a.75.75 0 01-.548-1.262l10.5-11.25a.75.75 0 01.913-.143z",
    clipRule: "evenodd"
  }));
}
var ForwardRef26 = React34.forwardRef(BoltIcon2);
var BoltIcon_default2 = ForwardRef26;

// ../../node_modules/@heroicons/react/24/solid/esm/ChevronDownIcon.js
var React35 = __toESM(require_react(), 1);
function ChevronDownIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React35.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React35.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React35.createElement("path", {
    fillRule: "evenodd",
    d: "M12.53 16.28a.75.75 0 01-1.06 0l-7.5-7.5a.75.75 0 011.06-1.06L12 14.69l6.97-6.97a.75.75 0 111.06 1.06l-7.5 7.5z",
    clipRule: "evenodd"
  }));
}
var ForwardRef27 = React35.forwardRef(ChevronDownIcon);
var ChevronDownIcon_default = ForwardRef27;

// ../../node_modules/@heroicons/react/24/solid/esm/ChevronRightIcon.js
var React36 = __toESM(require_react(), 1);
function ChevronRightIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React36.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React36.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React36.createElement("path", {
    fillRule: "evenodd",
    d: "M16.28 11.47a.75.75 0 010 1.06l-7.5 7.5a.75.75 0 01-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 011.06-1.06l7.5 7.5z",
    clipRule: "evenodd"
  }));
}
var ForwardRef28 = React36.forwardRef(ChevronRightIcon);
var ChevronRightIcon_default = ForwardRef28;

// ../../node_modules/@heroicons/react/24/solid/esm/EllipsisVerticalIcon.js
var React37 = __toESM(require_react(), 1);
function EllipsisVerticalIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React37.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React37.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React37.createElement("path", {
    fillRule: "evenodd",
    d: "M10.5 6a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0zm0 6a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0zm0 6a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0z",
    clipRule: "evenodd"
  }));
}
var ForwardRef29 = React37.forwardRef(EllipsisVerticalIcon);
var EllipsisVerticalIcon_default = ForwardRef29;

// ../../node_modules/@heroicons/react/24/solid/esm/ExclamationCircleIcon.js
var React38 = __toESM(require_react(), 1);
function ExclamationCircleIcon2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React38.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React38.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React38.createElement("path", {
    fillRule: "evenodd",
    d: "M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    clipRule: "evenodd"
  }));
}
var ForwardRef30 = React38.forwardRef(ExclamationCircleIcon2);
var ExclamationCircleIcon_default2 = ForwardRef30;

// ../../node_modules/@heroicons/react/24/solid/esm/ExclamationTriangleIcon.js
var React39 = __toESM(require_react(), 1);
function ExclamationTriangleIcon2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React39.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React39.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React39.createElement("path", {
    fillRule: "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    clipRule: "evenodd"
  }));
}
var ForwardRef31 = React39.forwardRef(ExclamationTriangleIcon2);
var ExclamationTriangleIcon_default2 = ForwardRef31;

// ../../node_modules/@heroicons/react/24/solid/esm/MoonIcon.js
var React40 = __toESM(require_react(), 1);
function MoonIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React40.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React40.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React40.createElement("path", {
    fillRule: "evenodd",
    d: "M9.528 1.718a.75.75 0 01.162.819A8.97 8.97 0 009 6a9 9 0 009 9 8.97 8.97 0 003.463-.69.75.75 0 01.981.98 10.503 10.503 0 01-9.694 6.46c-5.799 0-10.5-4.701-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 01.818.162z",
    clipRule: "evenodd"
  }));
}
var ForwardRef32 = React40.forwardRef(MoonIcon);
var MoonIcon_default = ForwardRef32;

// ../../node_modules/@heroicons/react/24/solid/esm/XCircleIcon.js
var React41 = __toESM(require_react(), 1);
function XCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React41.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React41.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React41.createElement("path", {
    fillRule: "evenodd",
    d: "M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zm-1.72 6.97a.75.75 0 10-1.06 1.06L10.94 12l-1.72 1.72a.75.75 0 101.06 1.06L12 13.06l1.72 1.72a.75.75 0 101.06-1.06L13.06 12l1.72-1.72a.75.75 0 10-1.06-1.06L12 10.94l-1.72-1.72z",
    clipRule: "evenodd"
  }));
}
var ForwardRef33 = React41.forwardRef(XCircleIcon);
var XCircleIcon_default = ForwardRef33;

// ../../packages/myst-to-react/dist/admonitions.js
var import_classnames5 = __toESM(require_classnames(), 1);
var AdmonitionKind;
(function(AdmonitionKind2) {
  AdmonitionKind2["admonition"] = "admonition";
  AdmonitionKind2["attention"] = "attention";
  AdmonitionKind2["caution"] = "caution";
  AdmonitionKind2["danger"] = "danger";
  AdmonitionKind2["error"] = "error";
  AdmonitionKind2["important"] = "important";
  AdmonitionKind2["hint"] = "hint";
  AdmonitionKind2["note"] = "note";
  AdmonitionKind2["seealso"] = "seealso";
  AdmonitionKind2["tip"] = "tip";
  AdmonitionKind2["warning"] = "warning";
})(AdmonitionKind || (AdmonitionKind = {}));
function getClasses(className) {
  var _a;
  const classes = (_a = className === null || className === void 0 ? void 0 : className.split(" ").map((s7) => s7.trim().toLowerCase()).filter((s7) => !!s7)) !== null && _a !== void 0 ? _a : [];
  return [...new Set(classes)];
}
function getFirstKind({ kind, classes = [] }) {
  if (kind === AdmonitionKind.note || classes.includes("note")) {
    return { kind: AdmonitionKind.note, color: "blue" };
  }
  if (kind === AdmonitionKind.important || classes.includes("important")) {
    return { kind: AdmonitionKind.important, color: "blue" };
  }
  if (kind === AdmonitionKind.hint || classes.includes("hint")) {
    return { kind: AdmonitionKind.hint, color: "green" };
  }
  if (kind === AdmonitionKind.seealso || classes.includes("seealso")) {
    return { kind: AdmonitionKind.seealso, color: "green" };
  }
  if (kind === AdmonitionKind.tip || classes.includes("tip")) {
    return { kind: AdmonitionKind.tip, color: "green" };
  }
  if (kind === AdmonitionKind.attention || classes.includes("attention")) {
    return { kind: AdmonitionKind.attention, color: "yellow" };
  }
  if (kind === AdmonitionKind.warning || classes.includes("warning")) {
    return { kind: AdmonitionKind.warning, color: "yellow" };
  }
  if (kind === AdmonitionKind.caution || classes.includes("caution")) {
    return { kind: AdmonitionKind.caution, color: "yellow" };
  }
  if (kind === AdmonitionKind.danger || classes.includes("danger")) {
    return { kind: AdmonitionKind.danger, color: "red" };
  }
  if (kind === AdmonitionKind.error || classes.includes("error")) {
    return { kind: AdmonitionKind.error, color: "red" };
  }
  return { kind: AdmonitionKind.note, color: "blue" };
}
var iconClass = "inline-block pl-2 mr-2 self-center flex-none";
function AdmonitionIcon({ kind, className }) {
  const cn = (0, import_classnames5.default)(iconClass, className);
  const opts = { width: "2rem", height: "2rem", className: cn };
  if (kind === AdmonitionKind.note)
    return (0, import_jsx_runtime16.jsx)(InformationCircleIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.caution)
    return (0, import_jsx_runtime16.jsx)(ExclamationCircleIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.warning)
    return (0, import_jsx_runtime16.jsx)(ExclamationTriangleIcon_default2, Object.assign({}, opts));
  if (kind === AdmonitionKind.danger)
    return (0, import_jsx_runtime16.jsx)(ExclamationCircleIcon_default2, Object.assign({}, opts));
  if (kind === AdmonitionKind.error)
    return (0, import_jsx_runtime16.jsx)(XCircleIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.attention)
    return (0, import_jsx_runtime16.jsx)(MegaphoneIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.tip)
    return (0, import_jsx_runtime16.jsx)(PencilSquareIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.hint)
    return (0, import_jsx_runtime16.jsx)(LightBulbIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.important)
    return (0, import_jsx_runtime16.jsx)(BoltIcon_default2, Object.assign({}, opts));
  if (kind === AdmonitionKind.seealso)
    return (0, import_jsx_runtime16.jsx)(ArrowRightCircleIcon_default, Object.assign({}, opts));
  return (0, import_jsx_runtime16.jsx)(InformationCircleIcon_default, Object.assign({}, opts));
}
var AdmonitionTitle = ({ node }) => {
  return (0, import_jsx_runtime16.jsx)(MyST, { ast: node.children });
};
var WrapperElement = ({ dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime16.jsx)("details", { className, children });
  return (0, import_jsx_runtime16.jsx)("aside", { className, children });
};
var HeaderElement = ({ dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime16.jsx)("summary", { className, children });
  return (0, import_jsx_runtime16.jsx)("div", { className, children });
};
function Admonition({ title, kind, color: color2, simple, dropdown, children, hideIcon, className }) {
  return (0, import_jsx_runtime16.jsxs)(WrapperElement, { dropdown, className: (0, import_classnames5.default)("my-5 shadow-md dark:shadow-2xl dark:shadow-neutral-900", "bg-gray-50/10 dark:bg-stone-800", "overflow-hidden", {
    "rounded border-l-4": !simple,
    "border-l-2": simple,
    "border-blue-500": !color2 || color2 === "blue",
    "border-green-600": color2 === "green",
    "border-amber-600": color2 === "yellow",
    "border-red-600": color2 === "red"
  }, className), children: [title && (0, import_jsx_runtime16.jsxs)(HeaderElement, { dropdown, className: (0, import_classnames5.default)("m-0 font-medium py-1 flex min-w-0", {
    "text-lg": !simple,
    "text-md": simple,
    "bg-gray-100 dark:bg-stone-700": simple,
    "text-blue-600 bg-blue-50 dark:bg-slate-900": !simple && (!color2 || color2 === "blue"),
    "text-green-600 bg-green-50 dark:bg-slate-900": !simple && color2 === "green",
    "text-amber-600 bg-amber-50 dark:bg-slate-900": !simple && color2 === "yellow",
    "text-red-600 bg-red-50 dark:bg-slate-900": !simple && color2 === "red",
    "cursor-pointer hover:shadow-[inset_0_0_0px_30px_#00000003] dark:hover:shadow-[inset_0_0_0px_30px_#FFFFFF03]": dropdown
  }), children: [!hideIcon && (0, import_jsx_runtime16.jsx)(AdmonitionIcon, { kind: kind !== null && kind !== void 0 ? kind : AdmonitionKind.note, className: (0, import_classnames5.default)({
    // Needed for simple!
    "text-blue-600": !color2 || color2 === "blue",
    "text-green-600": color2 === "green",
    "text-amber-600": color2 === "yellow",
    "text-red-600": color2 === "red"
  }) }), (0, import_jsx_runtime16.jsx)("div", { className: (0, import_classnames5.default)("text-neutral-900 dark:text-white grow self-center overflow-hidden break-words", { "ml-4": hideIcon }), children: title }), dropdown && (0, import_jsx_runtime16.jsx)("div", { className: "self-center flex-none text-sm font-thin text-neutral-700 dark:text-neutral-200", children: (0, import_jsx_runtime16.jsx)(ChevronRightIcon_default, { width: "2rem", height: "2rem", className: (0, import_classnames5.default)(iconClass, "transition-transform details-toggle") }) })] }), (0, import_jsx_runtime16.jsx)("div", { className: (0, import_classnames5.default)("px-4", { "py-1": !simple, "details-body": dropdown }), children })] });
}
var AdmonitionRenderer = ({ node }) => {
  const [title, ...rest2] = node.children;
  const classes = getClasses(node.class);
  const { kind, color: color2 } = getFirstKind({ kind: node.kind, classes });
  const isDropdown = classes.includes("dropdown");
  const isSimple = classes.includes("simple");
  const hideIcon = node.icon === false;
  const useTitle = (title === null || title === void 0 ? void 0 : title.type) === "admonitionTitle";
  return (0, import_jsx_runtime16.jsx)(Admonition, { title: useTitle ? (0, import_jsx_runtime16.jsx)(MyST, { ast: [title] }) : void 0, kind, color: color2, dropdown: isDropdown, simple: isSimple, hideIcon, className: (0, import_classnames5.default)(classes), children: useTitle ? (0, import_jsx_runtime16.jsx)(MyST, { ast: rest2 }) : (0, import_jsx_runtime16.jsx)(MyST, { ast: node.children }) });
};
var ADMONITION_RENDERERS = {
  admonition: AdmonitionRenderer,
  admonitionTitle: AdmonitionTitle
};
var admonitions_default = ADMONITION_RENDERERS;

// ../../packages/myst-to-react/dist/dropdown.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_classnames6 = __toESM(require_classnames(), 1);
var iconClass2 = "inline-block pl-2 mr-2 -translate-y-[1px]";
var SummaryTitle = ({ node }) => {
  return (0, import_jsx_runtime17.jsx)(MyST, { ast: node.children });
};
function Details({ title, children, open }) {
  return (0, import_jsx_runtime17.jsxs)("details", { className: (0, import_classnames6.default)("rounded-md my-5 shadow dark:shadow-2xl dark:shadow-neutral-900 overflow-hidden", "bg-gray-50 dark:bg-stone-800"), open, children: [(0, import_jsx_runtime17.jsx)("summary", { className: (0, import_classnames6.default)("m-0 text-lg font-medium py-1 min-h-[2em] pl-3", "cursor-pointer hover:shadow-[inset_0_0_0px_30px_#00000003] dark:hover:shadow-[inset_0_0_0px_30px_#FFFFFF03]", "bg-gray-100 dark:bg-slate-900"), children: (0, import_jsx_runtime17.jsxs)("span", { className: "text-neutral-900 dark:text-white", children: [(0, import_jsx_runtime17.jsx)("span", { className: "block float-right text-sm font-thin text-neutral-700 dark:text-neutral-200", children: (0, import_jsx_runtime17.jsx)(ChevronRightIcon_default, { width: "1.5rem", height: "1.5rem", className: (0, import_classnames6.default)(iconClass2, "details-toggle", "transition-transform") }) }), title] }) }), (0, import_jsx_runtime17.jsx)("div", { className: "px-4 py-1 details-body", children })] });
}
var DetailsRenderer = ({ node }) => {
  const [title, ...rest2] = node.children;
  return (0, import_jsx_runtime17.jsx)(Details, { title: (0, import_jsx_runtime17.jsx)(MyST, { ast: [title] }), open: node.open, children: (0, import_jsx_runtime17.jsx)(MyST, { ast: rest2 }) });
};
var DROPDOWN_RENDERERS = {
  details: DetailsRenderer,
  summary: SummaryTitle
};
var dropdown_default = DROPDOWN_RENDERERS;

// ../../packages/myst-to-react/dist/card.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_classnames7 = __toESM(require_classnames(), 1);
var Header = ({ node }) => {
  return (0, import_jsx_runtime18.jsx)("header", { className: "py-1 pl-3 m-0 border-b border-gray-100 bg-gray-50 dark:bg-slate-900 dark:border-gray-800", children: (0, import_jsx_runtime18.jsx)(MyST, { ast: node.children }) });
};
var Footer = ({ node }) => {
  return (0, import_jsx_runtime18.jsx)("footer", { className: "py-1 pl-3 m-0 border-t border-gray-100 bg-gray-50 dark:bg-slate-900 dark:border-gray-800", children: (0, import_jsx_runtime18.jsx)(MyST, { ast: node.children }) });
};
var CardTitle = ({ node }) => {
  return (0, import_jsx_runtime18.jsx)("div", { className: "pt-3 font-bold group-hover:underline", children: (0, import_jsx_runtime18.jsx)(MyST, { ast: node.children }) });
};
function getParts(children) {
  var _a, _b;
  const parts = {};
  if (!Array.isArray(children))
    return parts;
  const next = [...children];
  if (((_a = next[0]) === null || _a === void 0 ? void 0 : _a.type) === "header") {
    parts.header = next.splice(0, 1);
  }
  if (((_b = next[next.length - 1]) === null || _b === void 0 ? void 0 : _b.type) === "footer") {
    parts.footer = next.splice(-1, 1);
  }
  parts.body = next;
  return parts;
}
function ExternalOrInternalLink({ to, className, isStatic, prefetch = "intent", children }) {
  const Link2 = useLinkProvider();
  const baseurl = useBaseurl();
  if (to.startsWith("http") || isStatic) {
    return (0, import_jsx_runtime18.jsx)("a", { href: to, className, target: "_blank", rel: "noopener noreferrer", children });
  }
  return (0, import_jsx_runtime18.jsx)(Link2, { to: withBaseurl(to, baseurl), className, prefetch, children });
}
var CardRenderer = ({ node }) => {
  const parts = getParts(node.children);
  const url = node.url;
  const isStatic = node.static || false;
  const link2 = !!url;
  const sharedStyle = "my-5 rounded shadow dark:shadow-neutral-800 overflow-hidden border border-gray-100 dark:border-gray-800 flex flex-col";
  if (link2) {
    return (0, import_jsx_runtime18.jsxs)(ExternalOrInternalLink, { to: url, isStatic, className: (0, import_classnames7.default)(sharedStyle, "text-inherit hover:text-inherit", "block font-normal no-underline hover:no-underline cursor-pointer group", "hover:border-blue-500 dark:hover:border-blue-400"), children: [(0, import_jsx_runtime18.jsx)(MyST, { ast: parts.header }), (0, import_jsx_runtime18.jsx)("div", { className: "flex-grow px-4 py-2", children: (0, import_jsx_runtime18.jsx)(MyST, { ast: parts.body }) }), (0, import_jsx_runtime18.jsx)(MyST, { ast: parts.footer })] });
  }
  return (0, import_jsx_runtime18.jsxs)("div", { className: sharedStyle, children: [(0, import_jsx_runtime18.jsx)(MyST, { ast: parts.header }), (0, import_jsx_runtime18.jsx)("div", { className: "flex-grow px-4 py-2", children: (0, import_jsx_runtime18.jsx)(MyST, { ast: parts.body }) }), (0, import_jsx_runtime18.jsx)(MyST, { ast: parts.footer })] });
};
var CARD_RENDERERS = {
  card: CardRenderer,
  cardTitle: CardTitle,
  header: Header,
  footer: Footer
};
var card_default = CARD_RENDERERS;

// ../../packages/myst-to-react/dist/grid.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_classnames8 = __toESM(require_classnames(), 1);
var gridClassNames = {
  main: [
    "grid-cols-1",
    "grid-cols-2",
    "grid-cols-3",
    "grid-cols-4",
    "grid-cols-5",
    "grid-cols-6",
    "grid-cols-7",
    "grid-cols-8",
    "grid-cols-9",
    "grid-cols-10",
    "grid-cols-11",
    "grid-cols-12"
  ],
  sm: [
    "sm:grid-cols-1",
    "sm:grid-cols-2",
    "sm:grid-cols-3",
    "sm:grid-cols-4",
    "sm:grid-cols-5",
    "sm:grid-cols-6",
    "sm:grid-cols-7",
    "sm:grid-cols-8",
    "sm:grid-cols-9",
    "sm:grid-cols-10",
    "sm:grid-cols-11",
    "sm:grid-cols-12"
  ],
  md: [
    "md:grid-cols-1",
    "md:grid-cols-2",
    "md:grid-cols-3",
    "md:grid-cols-4",
    "md:grid-cols-5",
    "md:grid-cols-6",
    "md:grid-cols-7",
    "md:grid-cols-8",
    "md:grid-cols-9",
    "md:grid-cols-10",
    "md:grid-cols-11",
    "md:grid-cols-12"
  ],
  lg: [
    "lg:grid-cols-1",
    "lg:grid-cols-2",
    "lg:grid-cols-3",
    "lg:grid-cols-4",
    "lg:grid-cols-5",
    "lg:grid-cols-6",
    "lg:grid-cols-7",
    "lg:grid-cols-8",
    "lg:grid-cols-9",
    "lg:grid-cols-10",
    "lg:grid-cols-11",
    "lg:grid-cols-12"
  ],
  xl: [
    "xl:grid-cols-1",
    "xl:grid-cols-2",
    "xl:grid-cols-3",
    "xl:grid-cols-4",
    "xl:grid-cols-5",
    "xl:grid-cols-6",
    "xl:grid-cols-7",
    "xl:grid-cols-8",
    "xl:grid-cols-9",
    "xl:grid-cols-10",
    "xl:grid-cols-11",
    "xl:grid-cols-12"
  ]
};
var DEFAULT_NUM_COLUMNS = 3;
function getColumnClassName(classes, number) {
  var _a;
  const num = Number(number);
  if (!number || Number.isNaN(num)) {
    return getColumnClassName(classes, DEFAULT_NUM_COLUMNS);
  }
  return (_a = classes[num - 1]) !== null && _a !== void 0 ? _a : classes[DEFAULT_NUM_COLUMNS];
}
function gridColumnClasses(columns) {
  if (!columns || columns.length <= 1) {
    return getColumnClassName(gridClassNames.main, columns === null || columns === void 0 ? void 0 : columns[0]);
  }
  if (columns.length !== 4) {
    return getColumnClassName(gridClassNames.main, columns[0]);
  }
  return [
    // getColumnClassName(gridClassNames.main, columns[0]),
    getColumnClassName(gridClassNames.sm, columns[0]),
    getColumnClassName(gridClassNames.md, columns[1]),
    getColumnClassName(gridClassNames.lg, columns[2]),
    getColumnClassName(gridClassNames.xl, columns[3])
  ].join(" ");
}
function Grid({ columns, children }) {
  const gridClasses = gridColumnClasses(columns);
  const gutterClasses = "gap-4";
  return (0, import_jsx_runtime19.jsx)("div", { className: (0, import_classnames8.default)("myst-grid grid my-5", gridClasses, gutterClasses), children });
}
var GridRenderer = ({ node }) => {
  return (0, import_jsx_runtime19.jsx)(Grid, { columns: node.columns, children: (0, import_jsx_runtime19.jsx)(MyST, { ast: node.children }) });
};
var GRID_RENDERERS = {
  grid: GridRenderer
};
var grid_default = GRID_RENDERERS;

// ../../packages/myst-to-react/dist/cite.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_classnames9 = __toESM(require_classnames(), 1);

// ../../packages/myst-to-react/dist/inlineError.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
function InlineError({ value, message }) {
  return (0, import_jsx_runtime20.jsxs)("span", { className: "text-yellow-600", title: message || value, children: [(0, import_jsx_runtime20.jsx)(ExclamationCircleIcon_default, { width: "1rem", height: "1rem", className: "inline mr-1" }), value] });
}

// ../../packages/myst-to-react/dist/cite.js
function CiteChild({ html }) {
  return (0, import_jsx_runtime21.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] p-3", dangerouslySetInnerHTML: { __html: html || "" } });
}
var CiteGroup = ({ node }) => {
  return (0, import_jsx_runtime21.jsx)("span", { className: (0, import_classnames9.default)("cite-group", {
    narrative: node.kind === "narrative",
    parenthetical: node.kind === "parenthetical"
  }), children: (0, import_jsx_runtime21.jsx)(MyST, { ast: node.children }) });
};
var Cite = ({ label, error, children }) => {
  var _a, _b;
  const references = useReferences();
  if (!label) {
    return (0, import_jsx_runtime21.jsx)(InlineError, { value: "cite (no label)", message: "Citation Has No Label" });
  }
  const { html, doi: doiString } = (_b = (_a = references === null || references === void 0 ? void 0 : references.cite) === null || _a === void 0 ? void 0 : _a.data[label]) !== null && _b !== void 0 ? _b : {};
  if (error) {
    return (0, import_jsx_runtime21.jsx)(InlineError, { value: label, message: "Citation Not Found" });
  }
  const doiUrl = doiString ? doi.buildUrl(doiString) : null;
  return (0, import_jsx_runtime21.jsx)(HoverPopover, { openDelay: 300, card: (0, import_jsx_runtime21.jsx)(CiteChild, { html }), children: (0, import_jsx_runtime21.jsxs)("cite", { children: [doiUrl && (0, import_jsx_runtime21.jsx)("a", { href: doiUrl, target: "_blank", rel: "noreferrer", className: "hover-link", children }), !doiUrl && (0, import_jsx_runtime21.jsx)("span", { className: "hover-link", children })] }) });
};
var CiteRenderer = ({ node }) => {
  return (0, import_jsx_runtime21.jsx)(Cite, { label: node.label, error: node.error, children: (0, import_jsx_runtime21.jsx)(MyST, { ast: node.children }) });
};
var CITE_RENDERERS = {
  citeGroup: CiteGroup,
  cite: CiteRenderer
};
var cite_default = CITE_RENDERERS;

// ../../packages/myst-to-react/dist/footnotes.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
function FootnoteDefinition({ identifier }) {
  var _a, _b;
  const references = useReferences();
  const node = (_b = (_a = references === null || references === void 0 ? void 0 : references.footnotes) === null || _a === void 0 ? void 0 : _a[identifier]) !== null && _b !== void 0 ? _b : select(`footnoteDefinition[identifier=${identifier}]`, references === null || references === void 0 ? void 0 : references.article);
  return (0, import_jsx_runtime22.jsx)(XRefProvider, { children: (0, import_jsx_runtime22.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] px-3", children: (0, import_jsx_runtime22.jsx)(MyST, { ast: node.children }) }) });
}
var FootnoteReference = ({ node }) => {
  var _a;
  return (0, import_jsx_runtime22.jsx)(HoverPopover, { openDelay: 0, card: (0, import_jsx_runtime22.jsx)(FootnoteDefinition, { identifier: node.identifier }), children: (0, import_jsx_runtime22.jsx)("span", { children: (0, import_jsx_runtime22.jsxs)("sup", { className: "hover-link", children: ["[", (_a = node.number) !== null && _a !== void 0 ? _a : node.identifier, "]"] }) }) });
};
var FOOTNOTE_RENDERERS = {
  footnoteReference: FootnoteReference,
  // Do not render the definitions, they get pulled in by a handler
  footnoteDefinition: () => null
};
var footnotes_default = FOOTNOTE_RENDERERS;

// ../../packages/myst-to-react/dist/code.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i5;
  for (i5 = 0; i5 < sourceKeys.length; i5++) {
    key = sourceKeys[i5];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// ../../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i5;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i5 = 0; i5 < sourceSymbolKeys.length; i5++) {
      key = sourceSymbolKeys[i5];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}

// ../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
init_arrayLikeToArray();
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}

// ../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}

// ../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
init_unsupportedIterableToArray();

// ../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// ../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

// ../../node_modules/react-syntax-highlighter/dist/esm/highlight.js
init_defineProperty();
var import_react32 = __toESM(require_react());

// ../../node_modules/react-syntax-highlighter/dist/esm/create-element.js
init_extends();
init_defineProperty();
var import_react31 = __toESM(require_react());
function ownKeys(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i5 = 1; i5 < arguments.length; i5++) {
    var source = null != arguments[i5] ? arguments[i5] : {};
    i5 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function powerSetPermutations(arr) {
  var arrLength = arr.length;
  if (arrLength === 0 || arrLength === 1)
    return arr;
  if (arrLength === 2) {
    return [arr[0], arr[1], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength === 3) {
    return [arr[0], arr[1], arr[2], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength >= 4) {
    return [arr[0], arr[1], arr[2], arr[3], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3]), "".concat(arr[3], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
}
var classNameCombinations = {};
function getClassNameCombinations(classNames35) {
  if (classNames35.length === 0 || classNames35.length === 1)
    return classNames35;
  var key = classNames35.join(".");
  if (!classNameCombinations[key]) {
    classNameCombinations[key] = powerSetPermutations(classNames35);
  }
  return classNameCombinations[key];
}
function createStyleObject(classNames35) {
  var elementStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var stylesheet = arguments.length > 2 ? arguments[2] : void 0;
  var nonTokenClassNames = classNames35.filter(function(className) {
    return className !== "token";
  });
  var classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
  return classNamesCombinations.reduce(function(styleObject, className) {
    return _objectSpread(_objectSpread({}, styleObject), stylesheet[className]);
  }, elementStyle);
}
function createClassNameString(classNames35) {
  return classNames35.join(" ");
}
function createChildren(stylesheet, useInlineStyles) {
  var childrenCount = 0;
  return function(children) {
    childrenCount += 1;
    return children.map(function(child, i5) {
      return createElement34({
        node: child,
        stylesheet,
        useInlineStyles,
        key: "code-segment-".concat(childrenCount, "-").concat(i5)
      });
    });
  };
}
function createElement34(_ref) {
  var node = _ref.node, stylesheet = _ref.stylesheet, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref.useInlineStyles, key = _ref.key;
  var properties = node.properties, type2 = node.type, TagName = node.tagName, value = node.value;
  if (type2 === "text") {
    return value;
  } else if (TagName) {
    var childrenCreator = createChildren(stylesheet, useInlineStyles);
    var props;
    if (!useInlineStyles) {
      props = _objectSpread(_objectSpread({}, properties), {}, {
        className: createClassNameString(properties.className)
      });
    } else {
      var allStylesheetSelectors = Object.keys(stylesheet).reduce(function(classes, selector) {
        selector.split(".").forEach(function(className2) {
          if (!classes.includes(className2))
            classes.push(className2);
        });
        return classes;
      }, []);
      var startingClassName = properties.className && properties.className.includes("token") ? ["token"] : [];
      var className = properties.className && startingClassName.concat(properties.className.filter(function(className2) {
        return !allStylesheetSelectors.includes(className2);
      }));
      props = _objectSpread(_objectSpread({}, properties), {}, {
        className: createClassNameString(className) || void 0,
        style: createStyleObject(properties.className, Object.assign({}, properties.style, style), stylesheet)
      });
    }
    var children = childrenCreator(node.children);
    return /* @__PURE__ */ import_react31.default.createElement(TagName, _extends({
      key
    }, props), children);
  }
}

// ../../node_modules/react-syntax-highlighter/dist/esm/checkForListedLanguage.js
var checkForListedLanguage_default = function(astGenerator, language) {
  var langs = astGenerator.listLanguages();
  return langs.indexOf(language) !== -1;
};

// ../../node_modules/react-syntax-highlighter/dist/esm/highlight.js
var _excluded = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
function ownKeys2(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i5 = 1; i5 < arguments.length; i5++) {
    var source = null != arguments[i5] ? arguments[i5] : {};
    i5 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var newLineRegex = /\n/g;
function getNewLines(str2) {
  return str2.match(newLineRegex);
}
function getAllLineNumbers(_ref) {
  var lines = _ref.lines, startingLineNumber = _ref.startingLineNumber, style = _ref.style;
  return lines.map(function(_5, i5) {
    var number = i5 + startingLineNumber;
    return /* @__PURE__ */ import_react32.default.createElement("span", {
      key: "line-".concat(i5),
      className: "react-syntax-highlighter-line-number",
      style: typeof style === "function" ? style(number) : style
    }, "".concat(number, "\n"));
  });
}
function AllLineNumbers(_ref2) {
  var codeString = _ref2.codeString, codeStyle = _ref2.codeStyle, _ref2$containerStyle = _ref2.containerStyle, containerStyle = _ref2$containerStyle === void 0 ? {
    "float": "left",
    paddingRight: "10px"
  } : _ref2$containerStyle, _ref2$numberStyle = _ref2.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref2.startingLineNumber;
  return /* @__PURE__ */ import_react32.default.createElement("code", {
    style: Object.assign({}, codeStyle, containerStyle)
  }, getAllLineNumbers({
    lines: codeString.replace(/\n$/, "").split("\n"),
    style: numberStyle,
    startingLineNumber
  }));
}
function getEmWidthOfNumber(num) {
  return "".concat(num.toString().length, ".25em");
}
function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
  return {
    type: "element",
    tagName: "span",
    properties: {
      key: "line-number--".concat(lineNumber),
      className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
      style: inlineLineNumberStyle
    },
    children: [{
      type: "text",
      value: lineNumber
    }]
  };
}
function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
  var defaultLineNumberStyle = {
    display: "inline-block",
    minWidth: getEmWidthOfNumber(largestLineNumber),
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none"
  };
  var customLineNumberStyle = typeof lineNumberStyle === "function" ? lineNumberStyle(lineNumber) : lineNumberStyle;
  var assembledStyle = _objectSpread2(_objectSpread2({}, defaultLineNumberStyle), customLineNumberStyle);
  return assembledStyle;
}
function createLineElement(_ref3) {
  var children = _ref3.children, lineNumber = _ref3.lineNumber, lineNumberStyle = _ref3.lineNumberStyle, largestLineNumber = _ref3.largestLineNumber, showInlineLineNumbers = _ref3.showInlineLineNumbers, _ref3$lineProps = _ref3.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref3.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref3.showLineNumbers, wrapLongLines = _ref3.wrapLongLines;
  var properties = typeof lineProps === "function" ? lineProps(lineNumber) : lineProps;
  properties["className"] = className;
  if (lineNumber && showInlineLineNumbers) {
    var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
    children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
  }
  if (wrapLongLines & showLineNumbers) {
    properties.style = _objectSpread2(_objectSpread2({}, properties.style), {}, {
      display: "flex"
    });
  }
  return {
    type: "element",
    tagName: "span",
    properties,
    children
  };
}
function flattenCodeTree(tree) {
  var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var newTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  for (var i5 = 0; i5 < tree.length; i5++) {
    var node = tree[i5];
    if (node.type === "text") {
      newTree.push(createLineElement({
        children: [node],
        className: _toConsumableArray(new Set(className))
      }));
    } else if (node.children) {
      var classNames35 = className.concat(node.properties.className);
      flattenCodeTree(node.children, classNames35).forEach(function(i6) {
        return newTree.push(i6);
      });
    }
  }
  return newTree;
}
function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
  var _ref4;
  var tree = flattenCodeTree(codeTree.value);
  var newTree = [];
  var lastLineBreakIndex = -1;
  var index2 = 0;
  function createWrappedLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return createLineElement({
      children: children2,
      lineNumber: lineNumber2,
      lineNumberStyle,
      largestLineNumber,
      showInlineLineNumbers,
      lineProps,
      className,
      showLineNumbers,
      wrapLongLines
    });
  }
  function createUnwrappedLine(children2, lineNumber2) {
    if (showLineNumbers && lineNumber2 && showInlineLineNumbers) {
      var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber2, largestLineNumber);
      children2.unshift(getInlineLineNumber(lineNumber2, inlineLineNumberStyle));
    }
    return children2;
  }
  function createLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return wrapLines || className.length > 0 ? createWrappedLine(children2, lineNumber2, className) : createUnwrappedLine(children2, lineNumber2);
  }
  var _loop = function _loop2() {
    var node = tree[index2];
    var value = node.children[0].value;
    var newLines = getNewLines(value);
    if (newLines) {
      var splitValue = value.split("\n");
      splitValue.forEach(function(text, i5) {
        var lineNumber2 = showLineNumbers && newTree.length + startingLineNumber;
        var newChild = {
          type: "text",
          value: "".concat(text, "\n")
        };
        if (i5 === 0) {
          var _children = tree.slice(lastLineBreakIndex + 1, index2).concat(createLineElement({
            children: [newChild],
            className: node.properties.className
          }));
          var _line = createLine(_children, lineNumber2);
          newTree.push(_line);
        } else if (i5 === splitValue.length - 1) {
          var stringChild = tree[index2 + 1] && tree[index2 + 1].children && tree[index2 + 1].children[0];
          var lastLineInPreviousSpan = {
            type: "text",
            value: "".concat(text)
          };
          if (stringChild) {
            var newElem = createLineElement({
              children: [lastLineInPreviousSpan],
              className: node.properties.className
            });
            tree.splice(index2 + 1, 0, newElem);
          } else {
            var _children2 = [lastLineInPreviousSpan];
            var _line2 = createLine(_children2, lineNumber2, node.properties.className);
            newTree.push(_line2);
          }
        } else {
          var _children3 = [newChild];
          var _line3 = createLine(_children3, lineNumber2, node.properties.className);
          newTree.push(_line3);
        }
      });
      lastLineBreakIndex = index2;
    }
    index2++;
  };
  while (index2 < tree.length) {
    _loop();
  }
  if (lastLineBreakIndex !== tree.length - 1) {
    var children = tree.slice(lastLineBreakIndex + 1, tree.length);
    if (children && children.length) {
      var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
      var line = createLine(children, lineNumber);
      newTree.push(line);
    }
  }
  return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
}
function defaultRenderer(_ref5) {
  var rows = _ref5.rows, stylesheet = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
  return rows.map(function(node, i5) {
    return createElement34({
      node,
      stylesheet,
      useInlineStyles,
      key: "code-segement".concat(i5)
    });
  });
}
function isHighlightJs(astGenerator) {
  return astGenerator && typeof astGenerator.highlightAuto !== "undefined";
}
function getCodeTree(_ref6) {
  var astGenerator = _ref6.astGenerator, language = _ref6.language, code3 = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
  if (isHighlightJs(astGenerator)) {
    var hasLanguage = checkForListedLanguage_default(astGenerator, language);
    if (language === "text") {
      return {
        value: defaultCodeValue,
        language: "text"
      };
    } else if (hasLanguage) {
      return astGenerator.highlight(language, code3);
    } else {
      return astGenerator.highlightAuto(code3);
    }
  }
  try {
    return language && language !== "text" ? {
      value: astGenerator.highlight(code3, language)
    } : {
      value: defaultCodeValue
    };
  } catch (e4) {
    return {
      value: defaultCodeValue
    };
  }
}
function highlight_default(defaultAstGenerator, defaultStyle) {
  return function SyntaxHighlighter(_ref7) {
    var language = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style = _ref7$style === void 0 ? defaultStyle : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? {
      className: language ? "language-".concat(language) : void 0,
      style: _objectSpread2(_objectSpread2({}, style['code[class*="language-"]']), style['code[class*="language-'.concat(language, '"]')])
    } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? "pre" : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? "code" : _ref7$CodeTag, _ref7$code = _ref7.code, code3 = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || "" : _ref7$code, astGenerator = _ref7.astGenerator, rest2 = _objectWithoutProperties(_ref7, _excluded);
    astGenerator = astGenerator || defaultAstGenerator;
    var allLineNumbers = showLineNumbers ? /* @__PURE__ */ import_react32.default.createElement(AllLineNumbers, {
      containerStyle: lineNumberContainerStyle,
      codeStyle: codeTagProps.style || {},
      numberStyle: lineNumberStyle,
      startingLineNumber,
      codeString: code3
    }) : null;
    var defaultPreStyle = style.hljs || style['pre[class*="language-"]'] || {
      backgroundColor: "#fff"
    };
    var generatorClassName = isHighlightJs(astGenerator) ? "hljs" : "prismjs";
    var preProps = useInlineStyles ? Object.assign({}, rest2, {
      style: Object.assign({}, defaultPreStyle, customStyle)
    }) : Object.assign({}, rest2, {
      className: rest2.className ? "".concat(generatorClassName, " ").concat(rest2.className) : generatorClassName,
      style: Object.assign({}, customStyle)
    });
    if (wrapLongLines) {
      codeTagProps.style = _objectSpread2(_objectSpread2({}, codeTagProps.style), {}, {
        whiteSpace: "pre-wrap"
      });
    } else {
      codeTagProps.style = _objectSpread2(_objectSpread2({}, codeTagProps.style), {}, {
        whiteSpace: "pre"
      });
    }
    if (!astGenerator) {
      return /* @__PURE__ */ import_react32.default.createElement(PreTag, preProps, allLineNumbers, /* @__PURE__ */ import_react32.default.createElement(CodeTag, codeTagProps, code3));
    }
    if (wrapLines === void 0 && renderer || wrapLongLines)
      wrapLines = true;
    renderer = renderer || defaultRenderer;
    var defaultCodeValue = [{
      type: "text",
      value: code3
    }];
    var codeTree = getCodeTree({
      astGenerator,
      language,
      code: code3,
      defaultCodeValue
    });
    if (codeTree.language === null) {
      codeTree.value = defaultCodeValue;
    }
    var largestLineNumber = codeTree.value.length + startingLineNumber;
    var rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
    return /* @__PURE__ */ import_react32.default.createElement(PreTag, preProps, /* @__PURE__ */ import_react32.default.createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
      rows,
      stylesheet: style,
      useInlineStyles
    })));
  };
}

// ../../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject4, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject4(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject4) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject4, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject4, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}

// ../../node_modules/react-syntax-highlighter/dist/esm/async-syntax-highlighter.js
init_extends();

// ../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// ../../node_modules/@babel/runtime/helpers/esm/createClass.js
init_toPropertyKey();
function _defineProperties(target, props) {
  for (var i5 = 0; i5 < props.length; i5++) {
    var descriptor = props[i5];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

// ../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o10, p3) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p4) {
    o11.__proto__ = p4;
    return o11;
  };
  return _setPrototypeOf(o10, p3);
}

// ../../node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}

// ../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
init_typeof();

// ../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// ../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}

// ../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o10) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o11) {
    return o11.__proto__ || Object.getPrototypeOf(o11);
  };
  return _getPrototypeOf(o10);
}

// ../../node_modules/react-syntax-highlighter/dist/esm/async-syntax-highlighter.js
init_defineProperty();
var import_regenerator = __toESM(require_regenerator());
var import_react33 = __toESM(require_react());
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result2);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e4) {
    return false;
  }
}
var async_syntax_highlighter_default = function(options) {
  var loader3 = options.loader, isLanguageRegistered2 = options.isLanguageRegistered, registerLanguage2 = options.registerLanguage, languageLoaders = options.languageLoaders, noAsyncLoadingLanguages = options.noAsyncLoadingLanguages;
  var ReactAsyncHighlighter = /* @__PURE__ */ function(_React$PureComponent) {
    _inherits(ReactAsyncHighlighter2, _React$PureComponent);
    var _super = _createSuper(ReactAsyncHighlighter2);
    function ReactAsyncHighlighter2() {
      _classCallCheck(this, ReactAsyncHighlighter2);
      return _super.apply(this, arguments);
    }
    _createClass(ReactAsyncHighlighter2, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        if (!ReactAsyncHighlighter2.isRegistered(this.props.language) && languageLoaders) {
          this.loadLanguage();
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this = this;
        if (!ReactAsyncHighlighter2.astGeneratorPromise) {
          ReactAsyncHighlighter2.loadAstGenerator();
        }
        if (!ReactAsyncHighlighter2.astGenerator) {
          ReactAsyncHighlighter2.astGeneratorPromise.then(function() {
            _this.forceUpdate();
          });
        }
        if (!ReactAsyncHighlighter2.isRegistered(this.props.language) && languageLoaders) {
          this.loadLanguage();
        }
      }
    }, {
      key: "loadLanguage",
      value: function loadLanguage() {
        var _this2 = this;
        var language = this.props.language;
        if (language === "text") {
          return;
        }
        ReactAsyncHighlighter2.loadLanguage(language).then(function() {
          return _this2.forceUpdate();
        })["catch"](function() {
        });
      }
    }, {
      key: "normalizeLanguage",
      value: function normalizeLanguage2(language) {
        return ReactAsyncHighlighter2.isSupportedLanguage(language) ? language : "text";
      }
    }, {
      key: "render",
      value: function render() {
        return /* @__PURE__ */ import_react33.default.createElement(ReactAsyncHighlighter2.highlightInstance, _extends({}, this.props, {
          language: this.normalizeLanguage(this.props.language),
          astGenerator: ReactAsyncHighlighter2.astGenerator
        }));
      }
    }], [{
      key: "preload",
      value: function preload2() {
        return ReactAsyncHighlighter2.loadAstGenerator();
      }
    }, {
      key: "loadLanguage",
      value: function() {
        var _loadLanguage = _asyncToGenerator(/* @__PURE__ */ import_regenerator.default.mark(function _callee(language) {
          var languageLoader;
          return import_regenerator.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  languageLoader = languageLoaders[language];
                  if (!(typeof languageLoader === "function")) {
                    _context.next = 5;
                    break;
                  }
                  return _context.abrupt("return", languageLoader(ReactAsyncHighlighter2.registerLanguage));
                case 5:
                  throw new Error("Language ".concat(language, " not supported"));
                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        function loadLanguage(_x) {
          return _loadLanguage.apply(this, arguments);
        }
        return loadLanguage;
      }()
    }, {
      key: "isSupportedLanguage",
      value: function isSupportedLanguage(language) {
        return ReactAsyncHighlighter2.isRegistered(language) || typeof languageLoaders[language] === "function";
      }
    }, {
      key: "loadAstGenerator",
      value: function loadAstGenerator() {
        ReactAsyncHighlighter2.astGeneratorPromise = loader3().then(function(astGenerator) {
          ReactAsyncHighlighter2.astGenerator = astGenerator;
          if (registerLanguage2) {
            ReactAsyncHighlighter2.languages.forEach(function(language, name2) {
              return registerLanguage2(astGenerator, name2, language);
            });
          }
        });
        return ReactAsyncHighlighter2.astGeneratorPromise;
      }
    }]);
    return ReactAsyncHighlighter2;
  }(import_react33.default.PureComponent);
  _defineProperty(ReactAsyncHighlighter, "astGenerator", null);
  _defineProperty(ReactAsyncHighlighter, "highlightInstance", highlight_default(null, {}));
  _defineProperty(ReactAsyncHighlighter, "astGeneratorPromise", null);
  _defineProperty(ReactAsyncHighlighter, "languages", /* @__PURE__ */ new Map());
  _defineProperty(ReactAsyncHighlighter, "supportedLanguages", options.supportedLanguages || Object.keys(languageLoaders || {}));
  _defineProperty(ReactAsyncHighlighter, "isRegistered", function(language) {
    if (noAsyncLoadingLanguages) {
      return true;
    }
    if (!registerLanguage2) {
      throw new Error("Current syntax highlighter doesn't support registration of languages");
    }
    if (!ReactAsyncHighlighter.astGenerator) {
      return ReactAsyncHighlighter.languages.has(language);
    }
    return isLanguageRegistered2(ReactAsyncHighlighter.astGenerator, language);
  });
  _defineProperty(ReactAsyncHighlighter, "registerLanguage", function(name2, language) {
    if (!registerLanguage2) {
      throw new Error("Current syntax highlighter doesn't support registration of languages");
    }
    if (ReactAsyncHighlighter.astGenerator) {
      return registerLanguage2(ReactAsyncHighlighter.astGenerator, name2, language);
    } else {
      ReactAsyncHighlighter.languages.set(name2, language);
    }
  });
  return ReactAsyncHighlighter;
};

// ../../node_modules/react-syntax-highlighter/dist/esm/async-languages/create-language-async-loader.js
var import_regenerator2 = __toESM(require_regenerator());
var create_language_async_loader_default = function(name2, loader3) {
  return /* @__PURE__ */ function() {
    var _ref = _asyncToGenerator(/* @__PURE__ */ import_regenerator2.default.mark(function _callee(registerLanguage2) {
      var module2;
      return import_regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return loader3();
            case 2:
              module2 = _context.sent;
              registerLanguage2(name2, module2["default"] || module2);
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function(_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

// ../../node_modules/react-syntax-highlighter/dist/esm/async-languages/hljs.js
var hljs_default = {
  oneC: create_language_async_loader_default("oneC", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_oneC" */
      "/build/_shared/1c-MHGWKMBU.js"
    );
  }),
  abnf: create_language_async_loader_default("abnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_abnf" */
      "/build/_shared/abnf-H5EOJU5I.js"
    );
  }),
  accesslog: create_language_async_loader_default("accesslog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_accesslog" */
      "/build/_shared/accesslog-26TXF36J.js"
    );
  }),
  actionscript: create_language_async_loader_default("actionscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_actionscript" */
      "/build/_shared/actionscript-URKB2GAW.js"
    );
  }),
  ada: create_language_async_loader_default("ada", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ada" */
      "/build/_shared/ada-E76XDXKR.js"
    );
  }),
  angelscript: create_language_async_loader_default("angelscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_angelscript" */
      "/build/_shared/angelscript-WQKK53P2.js"
    );
  }),
  apache: create_language_async_loader_default("apache", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_apache" */
      "/build/_shared/apache-YMG342ZQ.js"
    );
  }),
  applescript: create_language_async_loader_default("applescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_applescript" */
      "/build/_shared/applescript-MOOLDF45.js"
    );
  }),
  arcade: create_language_async_loader_default("arcade", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_arcade" */
      "/build/_shared/arcade-DFFDL6I4.js"
    );
  }),
  arduino: create_language_async_loader_default("arduino", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_arduino" */
      "/build/_shared/arduino-HJBIFQTP.js"
    );
  }),
  armasm: create_language_async_loader_default("armasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_armasm" */
      "/build/_shared/armasm-2USUE5BZ.js"
    );
  }),
  asciidoc: create_language_async_loader_default("asciidoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_asciidoc" */
      "/build/_shared/asciidoc-PZYBP5RZ.js"
    );
  }),
  aspectj: create_language_async_loader_default("aspectj", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_aspectj" */
      "/build/_shared/aspectj-GHIZVSQR.js"
    );
  }),
  autohotkey: create_language_async_loader_default("autohotkey", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_autohotkey" */
      "/build/_shared/autohotkey-KR2SMGSD.js"
    );
  }),
  autoit: create_language_async_loader_default("autoit", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_autoit" */
      "/build/_shared/autoit-GVOUXSYQ.js"
    );
  }),
  avrasm: create_language_async_loader_default("avrasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_avrasm" */
      "/build/_shared/avrasm-4T6X3NWK.js"
    );
  }),
  awk: create_language_async_loader_default("awk", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_awk" */
      "/build/_shared/awk-UK4J2WVU.js"
    );
  }),
  axapta: create_language_async_loader_default("axapta", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_axapta" */
      "/build/_shared/axapta-AR6IZC3T.js"
    );
  }),
  bash: create_language_async_loader_default("bash", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_bash" */
      "/build/_shared/bash-FZTXAYMB.js"
    );
  }),
  basic: create_language_async_loader_default("basic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_basic" */
      "/build/_shared/basic-ZDA2M3HM.js"
    );
  }),
  bnf: create_language_async_loader_default("bnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_bnf" */
      "/build/_shared/bnf-4DXNWTVZ.js"
    );
  }),
  brainfuck: create_language_async_loader_default("brainfuck", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_brainfuck" */
      "/build/_shared/brainfuck-WBCGGNCT.js"
    );
  }),
  cLike: create_language_async_loader_default("cLike", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cLike" */
      "/build/_shared/c-like-ZISFRDMK.js"
    );
  }),
  c: create_language_async_loader_default("c", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_c" */
      "/build/_shared/c-DRLI5UX7.js"
    );
  }),
  cal: create_language_async_loader_default("cal", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cal" */
      "/build/_shared/cal-IFAXRS36.js"
    );
  }),
  capnproto: create_language_async_loader_default("capnproto", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_capnproto" */
      "/build/_shared/capnproto-FXZHDEBZ.js"
    );
  }),
  ceylon: create_language_async_loader_default("ceylon", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ceylon" */
      "/build/_shared/ceylon-4AE5V4IA.js"
    );
  }),
  clean: create_language_async_loader_default("clean", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clean" */
      "/build/_shared/clean-BFWXERNJ.js"
    );
  }),
  clojureRepl: create_language_async_loader_default("clojureRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clojureRepl" */
      "/build/_shared/clojure-repl-YPX2YXMS.js"
    );
  }),
  clojure: create_language_async_loader_default("clojure", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clojure" */
      "/build/_shared/clojure-LKLOJ57P.js"
    );
  }),
  cmake: create_language_async_loader_default("cmake", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cmake" */
      "/build/_shared/cmake-ZIVROEQD.js"
    );
  }),
  coffeescript: create_language_async_loader_default("coffeescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_coffeescript" */
      "/build/_shared/coffeescript-3OG4VSZD.js"
    );
  }),
  coq: create_language_async_loader_default("coq", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_coq" */
      "/build/_shared/coq-LOG5YZWQ.js"
    );
  }),
  cos: create_language_async_loader_default("cos", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cos" */
      "/build/_shared/cos-E22MF3DB.js"
    );
  }),
  cpp: create_language_async_loader_default("cpp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cpp" */
      "/build/_shared/cpp-H6YRHWOK.js"
    );
  }),
  crmsh: create_language_async_loader_default("crmsh", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_crmsh" */
      "/build/_shared/crmsh-WS7T5MVS.js"
    );
  }),
  crystal: create_language_async_loader_default("crystal", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_crystal" */
      "/build/_shared/crystal-OYIWXL5P.js"
    );
  }),
  csharp: create_language_async_loader_default("csharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_csharp" */
      "/build/_shared/csharp-HCSJ2ADA.js"
    );
  }),
  csp: create_language_async_loader_default("csp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_csp" */
      "/build/_shared/csp-XCQFOTZ4.js"
    );
  }),
  css: create_language_async_loader_default("css", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_css" */
      "/build/_shared/css-JPNILUVY.js"
    );
  }),
  d: create_language_async_loader_default("d", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_d" */
      "/build/_shared/d-UOA55URV.js"
    );
  }),
  dart: create_language_async_loader_default("dart", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dart" */
      "/build/_shared/dart-NTKQOJ2B.js"
    );
  }),
  delphi: create_language_async_loader_default("delphi", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_delphi" */
      "/build/_shared/delphi-HDKNI54B.js"
    );
  }),
  diff: create_language_async_loader_default("diff", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_diff" */
      "/build/_shared/diff-4AAW2IBS.js"
    );
  }),
  django: create_language_async_loader_default("django", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_django" */
      "/build/_shared/django-JLC6LLAG.js"
    );
  }),
  dns: create_language_async_loader_default("dns", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dns" */
      "/build/_shared/dns-GE4OEAIA.js"
    );
  }),
  dockerfile: create_language_async_loader_default("dockerfile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dockerfile" */
      "/build/_shared/dockerfile-IJZ2IBH3.js"
    );
  }),
  dos: create_language_async_loader_default("dos", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dos" */
      "/build/_shared/dos-G4DXODOP.js"
    );
  }),
  dsconfig: create_language_async_loader_default("dsconfig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dsconfig" */
      "/build/_shared/dsconfig-TV7GEKFV.js"
    );
  }),
  dts: create_language_async_loader_default("dts", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dts" */
      "/build/_shared/dts-KNEI4MQS.js"
    );
  }),
  dust: create_language_async_loader_default("dust", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dust" */
      "/build/_shared/dust-S24GE5NR.js"
    );
  }),
  ebnf: create_language_async_loader_default("ebnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ebnf" */
      "/build/_shared/ebnf-RW3SWHIK.js"
    );
  }),
  elixir: create_language_async_loader_default("elixir", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_elixir" */
      "/build/_shared/elixir-GNCLYP3H.js"
    );
  }),
  elm: create_language_async_loader_default("elm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_elm" */
      "/build/_shared/elm-35DVSYY4.js"
    );
  }),
  erb: create_language_async_loader_default("erb", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erb" */
      "/build/_shared/erb-2SS2OBHN.js"
    );
  }),
  erlangRepl: create_language_async_loader_default("erlangRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erlangRepl" */
      "/build/_shared/erlang-repl-KJDFF2FP.js"
    );
  }),
  erlang: create_language_async_loader_default("erlang", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erlang" */
      "/build/_shared/erlang-SDQVBHKA.js"
    );
  }),
  excel: create_language_async_loader_default("excel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_excel" */
      "/build/_shared/excel-G2SWGXTX.js"
    );
  }),
  fix: create_language_async_loader_default("fix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fix" */
      "/build/_shared/fix-2M4LSMD3.js"
    );
  }),
  flix: create_language_async_loader_default("flix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_flix" */
      "/build/_shared/flix-AOSLYJOZ.js"
    );
  }),
  fortran: create_language_async_loader_default("fortran", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fortran" */
      "/build/_shared/fortran-CYDMD2Q4.js"
    );
  }),
  fsharp: create_language_async_loader_default("fsharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fsharp" */
      "/build/_shared/fsharp-IB2HV44P.js"
    );
  }),
  gams: create_language_async_loader_default("gams", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gams" */
      "/build/_shared/gams-I6SYZBQQ.js"
    );
  }),
  gauss: create_language_async_loader_default("gauss", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gauss" */
      "/build/_shared/gauss-FEPW5DZR.js"
    );
  }),
  gcode: create_language_async_loader_default("gcode", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gcode" */
      "/build/_shared/gcode-67SW3DYT.js"
    );
  }),
  gherkin: create_language_async_loader_default("gherkin", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gherkin" */
      "/build/_shared/gherkin-AR37YGU5.js"
    );
  }),
  glsl: create_language_async_loader_default("glsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_glsl" */
      "/build/_shared/glsl-P3NAVFG3.js"
    );
  }),
  gml: create_language_async_loader_default("gml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gml" */
      "/build/_shared/gml-UP3NI2XI.js"
    );
  }),
  go: create_language_async_loader_default("go", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_go" */
      "/build/_shared/go-ACEDT3KZ.js"
    );
  }),
  golo: create_language_async_loader_default("golo", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_golo" */
      "/build/_shared/golo-UTSRFOLF.js"
    );
  }),
  gradle: create_language_async_loader_default("gradle", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gradle" */
      "/build/_shared/gradle-QI6HECFL.js"
    );
  }),
  groovy: create_language_async_loader_default("groovy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_groovy" */
      "/build/_shared/groovy-XOBHWGRB.js"
    );
  }),
  haml: create_language_async_loader_default("haml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haml" */
      "/build/_shared/haml-ER7WEXME.js"
    );
  }),
  handlebars: create_language_async_loader_default("handlebars", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_handlebars" */
      "/build/_shared/handlebars-HF5AGIMZ.js"
    );
  }),
  haskell: create_language_async_loader_default("haskell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haskell" */
      "/build/_shared/haskell-J5OD36TD.js"
    );
  }),
  haxe: create_language_async_loader_default("haxe", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haxe" */
      "/build/_shared/haxe-AL5NS6WV.js"
    );
  }),
  hsp: create_language_async_loader_default("hsp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_hsp" */
      "/build/_shared/hsp-AAHX6ZXX.js"
    );
  }),
  htmlbars: create_language_async_loader_default("htmlbars", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_htmlbars" */
      "/build/_shared/htmlbars-SP7I4KNP.js"
    );
  }),
  http: create_language_async_loader_default("http", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_http" */
      "/build/_shared/http-7VNYFBDG.js"
    );
  }),
  hy: create_language_async_loader_default("hy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_hy" */
      "/build/_shared/hy-WTESAGC2.js"
    );
  }),
  inform7: create_language_async_loader_default("inform7", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_inform7" */
      "/build/_shared/inform7-SIOMGB54.js"
    );
  }),
  ini: create_language_async_loader_default("ini", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ini" */
      "/build/_shared/ini-374QS4C3.js"
    );
  }),
  irpf90: create_language_async_loader_default("irpf90", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_irpf90" */
      "/build/_shared/irpf90-LJDNY6OC.js"
    );
  }),
  isbl: create_language_async_loader_default("isbl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_isbl" */
      "/build/_shared/isbl-WSA5V4A7.js"
    );
  }),
  java: create_language_async_loader_default("java", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_java" */
      "/build/_shared/java-6GLYUCNU.js"
    );
  }),
  javascript: create_language_async_loader_default("javascript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_javascript" */
      "/build/_shared/javascript-BF666MBQ.js"
    );
  }),
  jbossCli: create_language_async_loader_default("jbossCli", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_jbossCli" */
      "/build/_shared/jboss-cli-MKUQ7IXI.js"
    );
  }),
  json: create_language_async_loader_default("json", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_json" */
      "/build/_shared/json-KLQCI67V.js"
    );
  }),
  juliaRepl: create_language_async_loader_default("juliaRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_juliaRepl" */
      "/build/_shared/julia-repl-ADD3T65E.js"
    );
  }),
  julia: create_language_async_loader_default("julia", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_julia" */
      "/build/_shared/julia-55O2AJKT.js"
    );
  }),
  kotlin: create_language_async_loader_default("kotlin", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_kotlin" */
      "/build/_shared/kotlin-ZTYIY7PK.js"
    );
  }),
  lasso: create_language_async_loader_default("lasso", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lasso" */
      "/build/_shared/lasso-OMAZMCIV.js"
    );
  }),
  latex: create_language_async_loader_default("latex", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_latex" */
      "/build/_shared/latex-PDQILGQC.js"
    );
  }),
  ldif: create_language_async_loader_default("ldif", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ldif" */
      "/build/_shared/ldif-2Q5ZAGOR.js"
    );
  }),
  leaf: create_language_async_loader_default("leaf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_leaf" */
      "/build/_shared/leaf-6QLAPFHU.js"
    );
  }),
  less: create_language_async_loader_default("less", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_less" */
      "/build/_shared/less-7K3UGFMN.js"
    );
  }),
  lisp: create_language_async_loader_default("lisp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lisp" */
      "/build/_shared/lisp-J4UBE7QR.js"
    );
  }),
  livecodeserver: create_language_async_loader_default("livecodeserver", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_livecodeserver" */
      "/build/_shared/livecodeserver-QU2ZANUL.js"
    );
  }),
  livescript: create_language_async_loader_default("livescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_livescript" */
      "/build/_shared/livescript-L5DFJP24.js"
    );
  }),
  llvm: create_language_async_loader_default("llvm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_llvm" */
      "/build/_shared/llvm-5PD432JF.js"
    );
  }),
  lsl: create_language_async_loader_default("lsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lsl" */
      "/build/_shared/lsl-MBEE77AS.js"
    );
  }),
  lua: create_language_async_loader_default("lua", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lua" */
      "/build/_shared/lua-FLUELXU6.js"
    );
  }),
  makefile: create_language_async_loader_default("makefile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_makefile" */
      "/build/_shared/makefile-UBA35Z2R.js"
    );
  }),
  markdown: create_language_async_loader_default("markdown", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_markdown" */
      "/build/_shared/markdown-E6Q2HGEO.js"
    );
  }),
  mathematica: create_language_async_loader_default("mathematica", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mathematica" */
      "/build/_shared/mathematica-MK5EDHHX.js"
    );
  }),
  matlab: create_language_async_loader_default("matlab", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_matlab" */
      "/build/_shared/matlab-6WLBCELN.js"
    );
  }),
  maxima: create_language_async_loader_default("maxima", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_maxima" */
      "/build/_shared/maxima-VDWAGASY.js"
    );
  }),
  mel: create_language_async_loader_default("mel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mel" */
      "/build/_shared/mel-DCVR6EFC.js"
    );
  }),
  mercury: create_language_async_loader_default("mercury", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mercury" */
      "/build/_shared/mercury-2MVJ5LYS.js"
    );
  }),
  mipsasm: create_language_async_loader_default("mipsasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mipsasm" */
      "/build/_shared/mipsasm-RDO6HFVO.js"
    );
  }),
  mizar: create_language_async_loader_default("mizar", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mizar" */
      "/build/_shared/mizar-TYWOGBG5.js"
    );
  }),
  mojolicious: create_language_async_loader_default("mojolicious", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mojolicious" */
      "/build/_shared/mojolicious-EL4GHFQJ.js"
    );
  }),
  monkey: create_language_async_loader_default("monkey", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_monkey" */
      "/build/_shared/monkey-3ZLYCIJB.js"
    );
  }),
  moonscript: create_language_async_loader_default("moonscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_moonscript" */
      "/build/_shared/moonscript-A2RP65W4.js"
    );
  }),
  n1ql: create_language_async_loader_default("n1ql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_n1ql" */
      "/build/_shared/n1ql-NQKIGSIM.js"
    );
  }),
  nginx: create_language_async_loader_default("nginx", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nginx" */
      "/build/_shared/nginx-W565FNZ3.js"
    );
  }),
  nim: create_language_async_loader_default("nim", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nim" */
      "/build/_shared/nim-MH46TOOD.js"
    );
  }),
  nix: create_language_async_loader_default("nix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nix" */
      "/build/_shared/nix-5LP3WIEH.js"
    );
  }),
  nodeRepl: create_language_async_loader_default("nodeRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nodeRepl" */
      "/build/_shared/node-repl-VEP7FG72.js"
    );
  }),
  nsis: create_language_async_loader_default("nsis", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nsis" */
      "/build/_shared/nsis-MGN4YEZH.js"
    );
  }),
  objectivec: create_language_async_loader_default("objectivec", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_objectivec" */
      "/build/_shared/objectivec-GP5QMJX2.js"
    );
  }),
  ocaml: create_language_async_loader_default("ocaml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ocaml" */
      "/build/_shared/ocaml-VKKSC4VB.js"
    );
  }),
  openscad: create_language_async_loader_default("openscad", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_openscad" */
      "/build/_shared/openscad-EJTVYL5A.js"
    );
  }),
  oxygene: create_language_async_loader_default("oxygene", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_oxygene" */
      "/build/_shared/oxygene-ZFVMIADE.js"
    );
  }),
  parser3: create_language_async_loader_default("parser3", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_parser3" */
      "/build/_shared/parser3-4ROQMPSM.js"
    );
  }),
  perl: create_language_async_loader_default("perl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_perl" */
      "/build/_shared/perl-JX4WVWW3.js"
    );
  }),
  pf: create_language_async_loader_default("pf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pf" */
      "/build/_shared/pf-7FCDULWS.js"
    );
  }),
  pgsql: create_language_async_loader_default("pgsql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pgsql" */
      "/build/_shared/pgsql-XQMFM66V.js"
    );
  }),
  phpTemplate: create_language_async_loader_default("phpTemplate", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_phpTemplate" */
      "/build/_shared/php-template-UA2EPYFC.js"
    );
  }),
  php: create_language_async_loader_default("php", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_php" */
      "/build/_shared/php-Z36J4EVH.js"
    );
  }),
  plaintext: create_language_async_loader_default("plaintext", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_plaintext" */
      "/build/_shared/plaintext-N4DHMJTU.js"
    );
  }),
  pony: create_language_async_loader_default("pony", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pony" */
      "/build/_shared/pony-MMCU33FL.js"
    );
  }),
  powershell: create_language_async_loader_default("powershell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_powershell" */
      "/build/_shared/powershell-NHOQDQJK.js"
    );
  }),
  processing: create_language_async_loader_default("processing", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_processing" */
      "/build/_shared/processing-BNTUHALF.js"
    );
  }),
  profile: create_language_async_loader_default("profile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_profile" */
      "/build/_shared/profile-AUZ7M6AC.js"
    );
  }),
  prolog: create_language_async_loader_default("prolog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_prolog" */
      "/build/_shared/prolog-PCUS7NE4.js"
    );
  }),
  properties: create_language_async_loader_default("properties", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_properties" */
      "/build/_shared/properties-JADFWFSU.js"
    );
  }),
  protobuf: create_language_async_loader_default("protobuf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_protobuf" */
      "/build/_shared/protobuf-QVYQHUH2.js"
    );
  }),
  puppet: create_language_async_loader_default("puppet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_puppet" */
      "/build/_shared/puppet-7GU24XSN.js"
    );
  }),
  purebasic: create_language_async_loader_default("purebasic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_purebasic" */
      "/build/_shared/purebasic-2ED2BKHR.js"
    );
  }),
  pythonRepl: create_language_async_loader_default("pythonRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pythonRepl" */
      "/build/_shared/python-repl-QY5XDIQ5.js"
    );
  }),
  python: create_language_async_loader_default("python", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_python" */
      "/build/_shared/python-HEIED5XX.js"
    );
  }),
  q: create_language_async_loader_default("q", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_q" */
      "/build/_shared/q-QEBGLUX7.js"
    );
  }),
  qml: create_language_async_loader_default("qml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_qml" */
      "/build/_shared/qml-VKVYILLG.js"
    );
  }),
  r: create_language_async_loader_default("r", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_r" */
      "/build/_shared/r-6ETPU5SA.js"
    );
  }),
  reasonml: create_language_async_loader_default("reasonml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_reasonml" */
      "/build/_shared/reasonml-UA3FJLD2.js"
    );
  }),
  rib: create_language_async_loader_default("rib", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rib" */
      "/build/_shared/rib-FAOIL4QA.js"
    );
  }),
  roboconf: create_language_async_loader_default("roboconf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_roboconf" */
      "/build/_shared/roboconf-GTPXFHUD.js"
    );
  }),
  routeros: create_language_async_loader_default("routeros", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_routeros" */
      "/build/_shared/routeros-N7MBREZD.js"
    );
  }),
  rsl: create_language_async_loader_default("rsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rsl" */
      "/build/_shared/rsl-TXVN6DSZ.js"
    );
  }),
  ruby: create_language_async_loader_default("ruby", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ruby" */
      "/build/_shared/ruby-J6RG2H5T.js"
    );
  }),
  ruleslanguage: create_language_async_loader_default("ruleslanguage", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ruleslanguage" */
      "/build/_shared/ruleslanguage-AYRMGHWL.js"
    );
  }),
  rust: create_language_async_loader_default("rust", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rust" */
      "/build/_shared/rust-IFOIUIGA.js"
    );
  }),
  sas: create_language_async_loader_default("sas", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sas" */
      "/build/_shared/sas-JMOH6BUE.js"
    );
  }),
  scala: create_language_async_loader_default("scala", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scala" */
      "/build/_shared/scala-NLBOJPPF.js"
    );
  }),
  scheme: create_language_async_loader_default("scheme", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scheme" */
      "/build/_shared/scheme-ZEKOZCPE.js"
    );
  }),
  scilab: create_language_async_loader_default("scilab", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scilab" */
      "/build/_shared/scilab-XYGY3IVE.js"
    );
  }),
  scss: create_language_async_loader_default("scss", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scss" */
      "/build/_shared/scss-3H6M7FJA.js"
    );
  }),
  shell: create_language_async_loader_default("shell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_shell" */
      "/build/_shared/shell-RC2W7ULP.js"
    );
  }),
  smali: create_language_async_loader_default("smali", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_smali" */
      "/build/_shared/smali-G25PSYAR.js"
    );
  }),
  smalltalk: create_language_async_loader_default("smalltalk", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_smalltalk" */
      "/build/_shared/smalltalk-QV5ZCHJC.js"
    );
  }),
  sml: create_language_async_loader_default("sml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sml" */
      "/build/_shared/sml-DA2LKWQT.js"
    );
  }),
  sqf: create_language_async_loader_default("sqf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sqf" */
      "/build/_shared/sqf-TLPTGZZH.js"
    );
  }),
  sql: create_language_async_loader_default("sql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sql" */
      "/build/_shared/sql-OVPQZRSX.js"
    );
  }),
  sqlMore: create_language_async_loader_default("sqlMore", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sqlMore" */
      "/build/_shared/sql_more-ZOEYJCKZ.js"
    );
  }),
  stan: create_language_async_loader_default("stan", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stan" */
      "/build/_shared/stan-LICKPVL5.js"
    );
  }),
  stata: create_language_async_loader_default("stata", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stata" */
      "/build/_shared/stata-2GIMPXYU.js"
    );
  }),
  step21: create_language_async_loader_default("step21", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_step21" */
      "/build/_shared/step21-Y5TJV4KA.js"
    );
  }),
  stylus: create_language_async_loader_default("stylus", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stylus" */
      "/build/_shared/stylus-HYOK2JCK.js"
    );
  }),
  subunit: create_language_async_loader_default("subunit", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_subunit" */
      "/build/_shared/subunit-ZH4LHJ2S.js"
    );
  }),
  swift: create_language_async_loader_default("swift", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_swift" */
      "/build/_shared/swift-G55EACVL.js"
    );
  }),
  taggerscript: create_language_async_loader_default("taggerscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_taggerscript" */
      "/build/_shared/taggerscript-5UBHPCUO.js"
    );
  }),
  tap: create_language_async_loader_default("tap", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tap" */
      "/build/_shared/tap-NGPU6GRX.js"
    );
  }),
  tcl: create_language_async_loader_default("tcl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tcl" */
      "/build/_shared/tcl-N47MYKOO.js"
    );
  }),
  thrift: create_language_async_loader_default("thrift", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_thrift" */
      "/build/_shared/thrift-ZATOPCSG.js"
    );
  }),
  tp: create_language_async_loader_default("tp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tp" */
      "/build/_shared/tp-XG7QZC23.js"
    );
  }),
  twig: create_language_async_loader_default("twig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_twig" */
      "/build/_shared/twig-FNFVUMG4.js"
    );
  }),
  typescript: create_language_async_loader_default("typescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_typescript" */
      "/build/_shared/typescript-7EIWPJ6U.js"
    );
  }),
  vala: create_language_async_loader_default("vala", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vala" */
      "/build/_shared/vala-YP4EJJ5C.js"
    );
  }),
  vbnet: create_language_async_loader_default("vbnet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbnet" */
      "/build/_shared/vbnet-KPUVC7VK.js"
    );
  }),
  vbscriptHtml: create_language_async_loader_default("vbscriptHtml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbscriptHtml" */
      "/build/_shared/vbscript-html-MJ2DEVVI.js"
    );
  }),
  vbscript: create_language_async_loader_default("vbscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbscript" */
      "/build/_shared/vbscript-N3EPFU2E.js"
    );
  }),
  verilog: create_language_async_loader_default("verilog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_verilog" */
      "/build/_shared/verilog-M6UE4D47.js"
    );
  }),
  vhdl: create_language_async_loader_default("vhdl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vhdl" */
      "/build/_shared/vhdl-524NIHAM.js"
    );
  }),
  vim: create_language_async_loader_default("vim", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vim" */
      "/build/_shared/vim-YS3L7KO4.js"
    );
  }),
  x86asm: create_language_async_loader_default("x86asm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_x86asm" */
      "/build/_shared/x86asm-PDBHV5LO.js"
    );
  }),
  xl: create_language_async_loader_default("xl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xl" */
      "/build/_shared/xl-WA44LWTM.js"
    );
  }),
  xml: create_language_async_loader_default("xml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xml" */
      "/build/_shared/xml-DO3ZHFJZ.js"
    );
  }),
  xquery: create_language_async_loader_default("xquery", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xquery" */
      "/build/_shared/xquery-SSG3J2NB.js"
    );
  }),
  yaml: create_language_async_loader_default("yaml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_yaml" */
      "/build/_shared/yaml-PAVDEIIH.js"
    );
  }),
  zephir: create_language_async_loader_default("zephir", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_zephir" */
      "/build/_shared/zephir-BAYEEMF7.js"
    );
  })
};

// ../../node_modules/react-syntax-highlighter/dist/esm/light-async.js
var light_async_default = async_syntax_highlighter_default({
  loader: function loader() {
    return import(
      /* webpackChunkName:"react-syntax-highlighter/lowlight-import" */
      "/build/_shared/core-OR4OBBXG.js"
    ).then(function(module2) {
      return module2["default"] || module2;
    });
  },
  isLanguageRegistered: function isLanguageRegistered(instance, language) {
    return !!checkForListedLanguage_default(instance, language);
  },
  languageLoaders: hljs_default,
  registerLanguage: function registerLanguage(instance, name2, language) {
    return instance.registerLanguage(name2, language);
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/styles/hljs/xcode.js
var xcode_default = {
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "padding": "0.5em",
    "background": "#fff",
    "color": "black"
  },
  "xml .hljs-meta": {
    "color": "#c0c0c0"
  },
  "hljs-comment": {
    "color": "#007400"
  },
  "hljs-quote": {
    "color": "#007400"
  },
  "hljs-tag": {
    "color": "#aa0d91"
  },
  "hljs-attribute": {
    "color": "#aa0d91"
  },
  "hljs-keyword": {
    "color": "#aa0d91"
  },
  "hljs-selector-tag": {
    "color": "#aa0d91"
  },
  "hljs-literal": {
    "color": "#aa0d91"
  },
  "hljs-name": {
    "color": "#aa0d91"
  },
  "hljs-variable": {
    "color": "#3F6E74"
  },
  "hljs-template-variable": {
    "color": "#3F6E74"
  },
  "hljs-code": {
    "color": "#c41a16"
  },
  "hljs-string": {
    "color": "#c41a16"
  },
  "hljs-meta-string": {
    "color": "#c41a16"
  },
  "hljs-regexp": {
    "color": "#0E0EFF"
  },
  "hljs-link": {
    "color": "#0E0EFF"
  },
  "hljs-title": {
    "color": "#1c00cf"
  },
  "hljs-symbol": {
    "color": "#1c00cf"
  },
  "hljs-bullet": {
    "color": "#1c00cf"
  },
  "hljs-number": {
    "color": "#1c00cf"
  },
  "hljs-section": {
    "color": "#643820"
  },
  "hljs-meta": {
    "color": "#643820"
  },
  "hljs-class .hljs-title": {
    "color": "#5c2699"
  },
  "hljs-type": {
    "color": "#5c2699"
  },
  "hljs-built_in": {
    "color": "#5c2699"
  },
  "hljs-builtin-name": {
    "color": "#5c2699"
  },
  "hljs-params": {
    "color": "#5c2699"
  },
  "hljs-attr": {
    "color": "#836C28"
  },
  "hljs-subst": {
    "color": "#000"
  },
  "hljs-formula": {
    "backgroundColor": "#eee",
    "fontStyle": "italic"
  },
  "hljs-addition": {
    "backgroundColor": "#baeeba"
  },
  "hljs-deletion": {
    "backgroundColor": "#ffc8bd"
  },
  "hljs-selector-id": {
    "color": "#9b703f"
  },
  "hljs-selector-class": {
    "color": "#9b703f"
  },
  "hljs-doctag": {
    "fontWeight": "bold"
  },
  "hljs-strong": {
    "fontWeight": "bold"
  },
  "hljs-emphasis": {
    "fontStyle": "italic"
  }
};

// ../../node_modules/react-syntax-highlighter/dist/esm/styles/hljs/vs2015.js
var vs2015_default = {
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "padding": "0.5em",
    "background": "#1E1E1E",
    "color": "#DCDCDC"
  },
  "hljs-keyword": {
    "color": "#569CD6"
  },
  "hljs-literal": {
    "color": "#569CD6"
  },
  "hljs-symbol": {
    "color": "#569CD6"
  },
  "hljs-name": {
    "color": "#569CD6"
  },
  "hljs-link": {
    "color": "#569CD6",
    "textDecoration": "underline"
  },
  "hljs-built_in": {
    "color": "#4EC9B0"
  },
  "hljs-type": {
    "color": "#4EC9B0"
  },
  "hljs-number": {
    "color": "#B8D7A3"
  },
  "hljs-class": {
    "color": "#B8D7A3"
  },
  "hljs-string": {
    "color": "#D69D85"
  },
  "hljs-meta-string": {
    "color": "#D69D85"
  },
  "hljs-regexp": {
    "color": "#9A5334"
  },
  "hljs-template-tag": {
    "color": "#9A5334"
  },
  "hljs-subst": {
    "color": "#DCDCDC"
  },
  "hljs-function": {
    "color": "#DCDCDC"
  },
  "hljs-title": {
    "color": "#DCDCDC"
  },
  "hljs-params": {
    "color": "#DCDCDC"
  },
  "hljs-formula": {
    "color": "#DCDCDC"
  },
  "hljs-comment": {
    "color": "#57A64A",
    "fontStyle": "italic"
  },
  "hljs-quote": {
    "color": "#57A64A",
    "fontStyle": "italic"
  },
  "hljs-doctag": {
    "color": "#608B4E"
  },
  "hljs-meta": {
    "color": "#9B9B9B"
  },
  "hljs-meta-keyword": {
    "color": "#9B9B9B"
  },
  "hljs-tag": {
    "color": "#9B9B9B"
  },
  "hljs-variable": {
    "color": "#BD63C5"
  },
  "hljs-template-variable": {
    "color": "#BD63C5"
  },
  "hljs-attr": {
    "color": "#9CDCFE"
  },
  "hljs-attribute": {
    "color": "#9CDCFE"
  },
  "hljs-builtin-name": {
    "color": "#9CDCFE"
  },
  "hljs-section": {
    "color": "gold"
  },
  "hljs-emphasis": {
    "fontStyle": "italic"
  },
  "hljs-strong": {
    "fontWeight": "bold"
  },
  "hljs-bullet": {
    "color": "#D7BA7D"
  },
  "hljs-selector-tag": {
    "color": "#D7BA7D"
  },
  "hljs-selector-id": {
    "color": "#D7BA7D"
  },
  "hljs-selector-class": {
    "color": "#D7BA7D"
  },
  "hljs-selector-attr": {
    "color": "#D7BA7D"
  },
  "hljs-selector-pseudo": {
    "color": "#D7BA7D"
  },
  "hljs-addition": {
    "backgroundColor": "#144212",
    "display": "inline-block",
    "width": "100%"
  },
  "hljs-deletion": {
    "backgroundColor": "#600",
    "display": "inline-block",
    "width": "100%"
  }
};

// ../../packages/myst-to-react/dist/code.js
var import_classnames10 = __toESM(require_classnames(), 1);
function normalizeLanguage(lang) {
  switch (lang) {
    case "html":
      return "xml";
    default:
      return lang;
  }
}
function CodeBlock(props) {
  const { isLight } = useTheme();
  const { value, lang, identifier, emphasizeLines, showLineNumbers, className, showCopy = true, startingLineNumber = 1, filename, shadow, background, border } = props;
  const highlightLines = new Set(emphasizeLines);
  return (0, import_jsx_runtime23.jsxs)("div", { id: identifier, className: (0, import_classnames10.default)("relative group not-prose overflow-auto", className, {
    "shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 my-5 text-sm": shadow,
    "bg-stone-200/10": background,
    "border border-l-4 border-l-blue-400 border-gray-200 dark:border-l-blue-400 dark:border-gray-800": border
  }), children: [filename && (0, import_jsx_runtime23.jsxs)("div", { className: "flex flex-row pl-2 bg-white border-b dark:bg-slate-600 dark:border-slate-300", children: [(0, import_jsx_runtime23.jsx)(DocumentIcon_default, { width: "16px", height: "16px", className: "self-center flex-none inline-block text-gray-500 dark:text-gray-100" }), (0, import_jsx_runtime23.jsx)("div", { className: "self-center p-2 text-sm leading-3 prose text-slate-600 dark:text-white", children: filename })] }), (0, import_jsx_runtime23.jsx)(light_async_default, { language: normalizeLanguage(lang), startingLineNumber, showLineNumbers, style: isLight ? Object.assign(Object.assign({}, xcode_default), { hljs: Object.assign(Object.assign({}, xcode_default.hljs), { background: "transparent" }) }) : vs2015_default, wrapLines: true, lineNumberContainerStyle: {
    // This stops page content shifts
    display: "inline-block",
    float: "left",
    minWidth: "1.25em",
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none",
    borderLeft: "4px solid transparent"
  }, lineProps: (line) => {
    if (typeof line === "boolean")
      return {};
    return highlightLines.has(line) ? {
      "data-line-number": `${line}`,
      "data-highlight": "true"
    } : { "data-line-number": `${line}` };
  }, customStyle: { padding: "0.8rem" }, children: value }), showCopy && (0, import_jsx_runtime23.jsx)(CopyIcon, { text: value, className: (0, import_classnames10.default)("absolute right-1", { "top-[32px]": filename, "top-1": !filename }) })] });
}
var code2 = ({ node }) => {
  return (0, import_jsx_runtime23.jsx)(CodeBlock, { identifier: node.html_id, "data-mdast-node-type": node.type, "data-mdast-node-id": node.key, value: node.value || "", lang: node.lang, filename: node.filename, emphasizeLines: node.emphasizeLines, showLineNumbers: node.showLineNumbers, startingLineNumber: node.startingLineNumber, shadow: true, border: node.executable, background: !node.executable, className: (0, import_classnames10.default)({ hidden: node.visibility === "remove" }) });
};
function isColor(maybeColorHash) {
  if (!maybeColorHash || maybeColorHash.length > 9)
    return void 0;
  if (!(/* @__PURE__ */ new Set([4, 7, 9])).has(maybeColorHash.length))
    return void 0;
  const match = /^#([0-9A-Fa-f]{3,8})$/.exec(maybeColorHash);
  if (!match)
    return void 0;
  const color2 = match[1];
  return color2;
}
var inlineCode = ({ node }) => {
  if (isColor(node.value)) {
    return (0, import_jsx_runtime23.jsxs)("code", { className: "px-1 rounded bg-slate-100 text-slate-700 dark:bg-slate-800 dark:text-slate-100", children: [node.value, (0, import_jsx_runtime23.jsx)("span", { style: { backgroundColor: node.value }, className: "inline-block w-[10px] h-[10px] rounded-full ml-1" })] });
  }
  if (node.children && node.children.length > 0) {
    return (0, import_jsx_runtime23.jsx)("code", { children: (0, import_jsx_runtime23.jsx)(MyST, { ast: node.children }) });
  }
  return (0, import_jsx_runtime23.jsx)("code", { children: node.value });
};
var CODE_RENDERERS = {
  code: code2,
  inlineCode
};
var code_default = CODE_RENDERERS;

// ../../packages/myst-to-react/dist/math.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var mathRenderer = ({ node }) => {
  if (node.type === "math") {
    if (node.error || !node.html) {
      return (0, import_jsx_runtime24.jsxs)("pre", { title: node.message, children: [(0, import_jsx_runtime24.jsxs)("span", { className: "text-red-500", children: [(0, import_jsx_runtime24.jsx)(ExclamationCircleIcon_default, { width: "1rem", height: "1rem", className: "inline mr-1" }), node.message, "\n\n"] }), node.value] });
    }
    const id = node.html_id || node.identifier || node.key;
    return (0, import_jsx_runtime24.jsxs)("div", { id, className: "flex my-5 group", children: [(0, import_jsx_runtime24.jsx)("div", { dangerouslySetInnerHTML: { __html: node.html }, className: "flex-grow overflow-x-auto overflow-y-hidden" }), node.enumerator && (0, import_jsx_runtime24.jsx)("div", { className: "relative self-center flex-none pl-2 m-0 text-right select-none", children: (0, import_jsx_runtime24.jsxs)(HashLink, { id, kind: "Equation", className: "text-inherit hover:text-inherit", children: ["(", node.enumerator, ")"] }) })] });
  }
  if (node.error || !node.html) {
    return (0, import_jsx_runtime24.jsx)(InlineError, { value: node.value, message: node.message });
  }
  return (0, import_jsx_runtime24.jsx)("span", { dangerouslySetInnerHTML: { __html: node.html } });
};
var MATH_RENDERERS = {
  math: mathRenderer,
  inlineMath: mathRenderer
};
var math_default = MATH_RENDERERS;

// ../../packages/myst-to-react/dist/reactive.js
var import_react34 = __toESM(require_react(), 1);
var RVar = ({ node }) => {
  return (0, import_react34.createElement)("r-var", {
    name: node.name,
    value: node.value,
    ":value": node.valueFunction,
    format: node.format
  });
};
var RDisplay = ({ node }) => {
  return (0, import_react34.createElement)("r-display", {
    name: node.name,
    value: node.value,
    ":value": node.valueFunction,
    format: node.format
  });
};
var RDynamic = ({ node }) => {
  return (0, import_react34.createElement)("r-dynamic", {
    name: node.name,
    value: node.value,
    ":value": node.valueFunction,
    max: node.max,
    ":max": node.maxFunction,
    min: node.min,
    ":min": node.minFunction,
    step: node.step,
    ":step": node.stepFunction,
    ":change": node.changeFunction,
    format: node.format
  });
};
var RRange = ({ node }) => {
  return (0, import_react34.createElement)("r-range", {
    name: node.name,
    value: node.value,
    ":value": node.valueFunction,
    max: node.max,
    ":max": node.maxFunction,
    min: node.min,
    ":min": node.minFunction,
    step: node.step,
    ":step": node.stepFunction,
    ":change": node.changeFunction
  });
};
var REACTIVE_RENDERERS = {
  "r:var": RVar,
  "r:display": RDisplay,
  "r:dynamic": RDynamic,
  "r:range": RRange
};
var reactive_default = REACTIVE_RENDERERS;

// ../../packages/myst-to-react/dist/iframe.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
function getStyleValue(width) {
  if (typeof width === "number" && Number.isNaN(width)) {
    return void 0;
  }
  if (typeof width === "string") {
    if (width.endsWith("%")) {
      return getStyleValue(Number(width.replace("%", "")));
    } else if (width.endsWith("px")) {
      const px = getStyleValue(Number(width.replace("px", "")));
      return px ? px / 750 : 70;
    } else if (!Number.isNaN(Number(width))) {
      return Number(width);
    }
    console.log(`Unknown width ${width} in getImageWidth`);
    return void 0;
  }
  return width;
}
var IFrame = ({ node }) => {
  const width = getStyleValue(node.width) || 70;
  return (0, import_jsx_runtime25.jsx)("div", { id: node.label || void 0, style: { textAlign: node.align || "center" }, className: "leading-[0]", children: (0, import_jsx_runtime25.jsx)("div", { className: "relative inline-block", style: {
    paddingBottom: "60%",
    width: `min(max(${width}%, 500px), 100%)`
  }, children: (0, import_jsx_runtime25.jsx)("iframe", { width: "100%", height: "100%", src: node.src, allowFullScreen: true, allow: "autoplay", style: {
    width: "100%",
    height: "100%",
    position: "absolute",
    top: 0,
    left: 0,
    border: "none"
  } }) }) });
};
var IFRAME_RENDERERS = {
  iframe: IFrame
};
var iframe_default = IFRAME_RENDERERS;

// ../../packages/myst-to-react/dist/image.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
function getStyleValue2(width) {
  if (typeof width === "number" && Number.isNaN(width)) {
    return void 0;
  }
  if (typeof width === "string") {
    if (width.endsWith("%")) {
      return width;
    } else if (width.endsWith("px")) {
      return Number(width.replace("px", ""));
    } else if (!Number.isNaN(Number(width))) {
      return Number(width);
    }
    console.log(`Unknown width ${width} in getImageWidth`);
    return void 0;
  }
  return width;
}
function alignToMargin(align) {
  switch (align) {
    case "left":
      return { marginRight: "auto" };
    case "right":
      return { marginLeft: "auto" };
    case "center":
      return { margin: "0 auto" };
    default:
      return {};
  }
}
function Video({ src, urlSource, align = "center", width, height }) {
  return (0, import_jsx_runtime26.jsx)("video", {
    style: Object.assign({ width: getStyleValue2(width), height: getStyleValue2(height) }, alignToMargin(align)),
    src,
    "data-canonical-url": urlSource,
    autoPlay: true,
    // For autoplay, the element needs to be muted to actually start!
    muted: true,
    "webkit-playsinline": "true",
    playsInline: true,
    loop: true
  });
}
function Picture({ src, srcOptimized, urlSource, align = "center", alt, width, height }) {
  if (src.endsWith(".mp4") || (urlSource === null || urlSource === void 0 ? void 0 : urlSource.endsWith(".mp4"))) {
    return (0, import_jsx_runtime26.jsx)(Video, { width, height, align, src, urlSource });
  }
  const image = (0, import_jsx_runtime26.jsx)("img", { style: Object.assign({ width: getStyleValue2(width), height: getStyleValue2(height) }, alignToMargin(align)), src, alt, "data-canonical-url": urlSource });
  if (!srcOptimized)
    return image;
  return (0, import_jsx_runtime26.jsxs)("picture", { children: [(0, import_jsx_runtime26.jsx)("source", { srcSet: srcOptimized, type: "image/webp" }), image] });
}
var Image2 = ({ node }) => {
  return (0, import_jsx_runtime26.jsx)(Picture, {
    src: node.url,
    srcOptimized: node.urlOptimized,
    alt: node.alt || node.title,
    width: node.width || void 0,
    height: node.height || void 0,
    align: node.align,
    // Note that sourceUrl is for backwards compatibility
    urlSource: node.urlSource || node.sourceUrl
  });
};
var IMAGE_RENDERERS = {
  image: Image2
};
var image_default = IMAGE_RENDERERS;

// ../../packages/myst-to-react/dist/links/index.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);

// ../../packages/myst-to-react/dist/links/wiki.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/swr/core/dist/index.mjs
var import_react36 = __toESM(require_react(), 1);
var import_shim = __toESM(require_shim(), 1);

// ../../node_modules/swr/_internal/dist/index.mjs
var import_react35 = __toESM(require_react(), 1);
var noop = () => {
};
var UNDEFINED = (
  /*#__NOINLINE__*/
  noop()
);
var OBJECT = Object;
var isUndefined = (v2) => v2 === UNDEFINED;
var isFunction = (v2) => typeof v2 == "function";
var mergeObjects = (a4, b4) => ({
  ...a4,
  ...b4
});
var isPromiseLike = (x4) => isFunction(x4.then);
var table = /* @__PURE__ */ new WeakMap();
var counter = 0;
var stableHash = (arg) => {
  const type2 = typeof arg;
  const constructor = arg && arg.constructor;
  const isDate = constructor == Date;
  let result2;
  let index2;
  if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {
    result2 = table.get(arg);
    if (result2)
      return result2;
    result2 = ++counter + "~";
    table.set(arg, result2);
    if (constructor == Array) {
      result2 = "@";
      for (index2 = 0; index2 < arg.length; index2++) {
        result2 += stableHash(arg[index2]) + ",";
      }
      table.set(arg, result2);
    }
    if (constructor == OBJECT) {
      result2 = "#";
      const keys2 = OBJECT.keys(arg).sort();
      while (!isUndefined(index2 = keys2.pop())) {
        if (!isUndefined(arg[index2])) {
          result2 += index2 + ":" + stableHash(arg[index2]) + ",";
        }
      }
      table.set(arg, result2);
    }
  } else {
    result2 = isDate ? arg.toJSON() : type2 == "symbol" ? arg.toString() : type2 == "string" ? JSON.stringify(arg) : "" + arg;
  }
  return result2;
};
var SWRGlobalState = /* @__PURE__ */ new WeakMap();
var EMPTY_CACHE = {};
var INITIAL_CACHE = {};
var STR_UNDEFINED = "undefined";
var isWindowDefined = typeof window != STR_UNDEFINED;
var isDocumentDefined = typeof document != STR_UNDEFINED;
var hasRequestAnimationFrame = () => isWindowDefined && typeof window["requestAnimationFrame"] != STR_UNDEFINED;
var createCacheHelper = (cache2, key) => {
  const state = SWRGlobalState.get(cache2);
  return [
    // Getter
    () => !isUndefined(key) && cache2.get(key) || EMPTY_CACHE,
    // Setter
    (info) => {
      if (!isUndefined(key)) {
        const prev = cache2.get(key);
        if (!(key in INITIAL_CACHE)) {
          INITIAL_CACHE[key] = prev;
        }
        state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);
      }
    },
    // Subscriber
    state[6],
    // Get server cache snapshot
    () => {
      if (!isUndefined(key)) {
        if (key in INITIAL_CACHE)
          return INITIAL_CACHE[key];
      }
      return !isUndefined(key) && cache2.get(key) || EMPTY_CACHE;
    }
  ];
};
var online = true;
var isOnline = () => online;
var [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  noop,
  noop
];
var isVisible = () => {
  const visibilityState = isDocumentDefined && document.visibilityState;
  return isUndefined(visibilityState) || visibilityState !== "hidden";
};
var initFocus = (callback) => {
  if (isDocumentDefined) {
    document.addEventListener("visibilitychange", callback);
  }
  onWindowEvent("focus", callback);
  return () => {
    if (isDocumentDefined) {
      document.removeEventListener("visibilitychange", callback);
    }
    offWindowEvent("focus", callback);
  };
};
var initReconnect = (callback) => {
  const onOnline = () => {
    online = true;
    callback();
  };
  const onOffline = () => {
    online = false;
  };
  onWindowEvent("online", onOnline);
  onWindowEvent("offline", onOffline);
  return () => {
    offWindowEvent("online", onOnline);
    offWindowEvent("offline", onOffline);
  };
};
var preset = {
  isOnline,
  isVisible
};
var defaultConfigOptions = {
  initFocus,
  initReconnect
};
var IS_REACT_LEGACY = !import_react35.default.useId;
var IS_SERVER = !isWindowDefined || "Deno" in window;
var rAF = (f6) => hasRequestAnimationFrame() ? window["requestAnimationFrame"](f6) : setTimeout(f6, 1);
var useIsomorphicLayoutEffect = IS_SERVER ? import_react35.useEffect : import_react35.useLayoutEffect;
var navigatorConnection = typeof navigator !== "undefined" && navigator.connection;
var slowConnection = !IS_SERVER && navigatorConnection && ([
  "slow-2g",
  "2g"
].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);
var serialize = (key) => {
  if (isFunction(key)) {
    try {
      key = key();
    } catch (err) {
      key = "";
    }
  }
  const args = key;
  key = typeof key == "string" ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : "";
  return [
    key,
    args
  ];
};
var __timestamp = 0;
var getTimestamp = () => ++__timestamp;
var FOCUS_EVENT = 0;
var RECONNECT_EVENT = 1;
var MUTATE_EVENT = 2;
var ERROR_REVALIDATE_EVENT = 3;
var events = {
  __proto__: null,
  ERROR_REVALIDATE_EVENT,
  FOCUS_EVENT,
  MUTATE_EVENT,
  RECONNECT_EVENT
};
async function internalMutate(...args) {
  const [cache2, _key, _data, _opts] = args;
  const options = mergeObjects({
    populateCache: true,
    throwOnError: true
  }, typeof _opts === "boolean" ? {
    revalidate: _opts
  } : _opts || {});
  let populateCache = options.populateCache;
  const rollbackOnErrorOption = options.rollbackOnError;
  let optimisticData = options.optimisticData;
  const revalidate = options.revalidate !== false;
  const rollbackOnError = (error) => {
    return typeof rollbackOnErrorOption === "function" ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;
  };
  const throwOnError = options.throwOnError;
  if (isFunction(_key)) {
    const keyFilter = _key;
    const matchedKeys = [];
    const it2 = cache2.keys();
    for (const key of it2) {
      if (
        // Skip the special useSWRInfinite and useSWRSubscription keys.
        !/^\$(inf|sub)\$/.test(key) && keyFilter(cache2.get(key)._k)
      ) {
        matchedKeys.push(key);
      }
    }
    return Promise.all(matchedKeys.map(mutateByKey));
  }
  return mutateByKey(_key);
  async function mutateByKey(_k) {
    const [key] = serialize(_k);
    if (!key)
      return;
    const [get2, set3] = createCacheHelper(cache2, key);
    const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache2);
    const startRevalidate = () => {
      const revalidators = EVENT_REVALIDATORS[key];
      if (revalidate) {
        delete FETCH[key];
        delete PRELOAD[key];
        if (revalidators && revalidators[0]) {
          return revalidators[0](MUTATE_EVENT).then(() => get2().data);
        }
      }
      return get2().data;
    };
    if (args.length < 3) {
      return startRevalidate();
    }
    let data = _data;
    let error;
    const beforeMutationTs = getTimestamp();
    MUTATION[key] = [
      beforeMutationTs,
      0
    ];
    const hasOptimisticData = !isUndefined(optimisticData);
    const state = get2();
    const displayedData = state.data;
    const currentData = state._c;
    const committedData = isUndefined(currentData) ? displayedData : currentData;
    if (hasOptimisticData) {
      optimisticData = isFunction(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;
      set3({
        data: optimisticData,
        _c: committedData
      });
    }
    if (isFunction(data)) {
      try {
        data = data(committedData);
      } catch (err) {
        error = err;
      }
    }
    if (data && isPromiseLike(data)) {
      data = await data.catch((err) => {
        error = err;
      });
      if (beforeMutationTs !== MUTATION[key][0]) {
        if (error)
          throw error;
        return data;
      } else if (error && hasOptimisticData && rollbackOnError(error)) {
        populateCache = true;
        set3({
          data: committedData,
          _c: UNDEFINED
        });
      }
    }
    if (populateCache) {
      if (!error) {
        if (isFunction(populateCache)) {
          const populateCachedData = populateCache(data, committedData);
          set3({
            data: populateCachedData,
            error: UNDEFINED,
            _c: UNDEFINED
          });
        } else {
          set3({
            data,
            error: UNDEFINED,
            _c: UNDEFINED
          });
        }
      }
    }
    MUTATION[key][1] = getTimestamp();
    Promise.resolve(startRevalidate()).then(() => {
      set3({
        _c: UNDEFINED
      });
    });
    if (error) {
      if (throwOnError)
        throw error;
      return;
    }
    return data;
  }
}
var revalidateAllKeys = (revalidators, type2) => {
  for (const key in revalidators) {
    if (revalidators[key][0])
      revalidators[key][0](type2);
  }
};
var initCache = (provider, options) => {
  if (!SWRGlobalState.has(provider)) {
    const opts = mergeObjects(defaultConfigOptions, options);
    const EVENT_REVALIDATORS = {};
    const mutate2 = internalMutate.bind(UNDEFINED, provider);
    let unmount = noop;
    const subscriptions = {};
    const subscribe = (key, callback) => {
      const subs = subscriptions[key] || [];
      subscriptions[key] = subs;
      subs.push(callback);
      return () => subs.splice(subs.indexOf(callback), 1);
    };
    const setter = (key, value, prev) => {
      provider.set(key, value);
      const subs = subscriptions[key];
      if (subs) {
        for (const fn of subs) {
          fn(value, prev);
        }
      }
    };
    const initProvider = () => {
      if (!SWRGlobalState.has(provider)) {
        SWRGlobalState.set(provider, [
          EVENT_REVALIDATORS,
          {},
          {},
          {},
          mutate2,
          setter,
          subscribe
        ]);
        if (!IS_SERVER) {
          const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));
          const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));
          unmount = () => {
            releaseFocus && releaseFocus();
            releaseReconnect && releaseReconnect();
            SWRGlobalState.delete(provider);
          };
        }
      }
    };
    initProvider();
    return [
      provider,
      mutate2,
      initProvider,
      unmount
    ];
  }
  return [
    provider,
    SWRGlobalState.get(provider)[4]
  ];
};
var onErrorRetry = (_5, __, config, revalidate, opts) => {
  const maxRetryCount = config.errorRetryCount;
  const currentRetryCount = opts.retryCount;
  const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;
  if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {
    return;
  }
  setTimeout(revalidate, timeout, opts);
};
var compare = (currentData, newData) => stableHash(currentData) == stableHash(newData);
var [cache, mutate] = initCache(/* @__PURE__ */ new Map());
var defaultConfig = mergeObjects(
  {
    // events
    onLoadingSlow: noop,
    onSuccess: noop,
    onError: noop,
    onErrorRetry,
    onDiscarded: noop,
    // switches
    revalidateOnFocus: true,
    revalidateOnReconnect: true,
    revalidateIfStale: true,
    shouldRetryOnError: true,
    // timeouts
    errorRetryInterval: slowConnection ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: slowConnection ? 5e3 : 3e3,
    // providers
    compare,
    isPaused: () => false,
    cache,
    mutate,
    fallback: {}
  },
  // use web preset by default
  preset
);
var mergeConfigs = (a4, b4) => {
  const v2 = mergeObjects(a4, b4);
  if (b4) {
    const { use: u1, fallback: f1 } = a4;
    const { use: u22, fallback: f22 } = b4;
    if (u1 && u22) {
      v2.use = u1.concat(u22);
    }
    if (f1 && f22) {
      v2.fallback = mergeObjects(f1, f22);
    }
  }
  return v2;
};
var SWRConfigContext = (0, import_react35.createContext)({});
var SWRConfig = (props) => {
  const { value } = props;
  const parentConfig = (0, import_react35.useContext)(SWRConfigContext);
  const isFunctionalConfig = isFunction(value);
  const config = (0, import_react35.useMemo)(() => isFunctionalConfig ? value(parentConfig) : value, [
    isFunctionalConfig,
    parentConfig,
    value
  ]);
  const extendedConfig = (0, import_react35.useMemo)(() => isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [
    isFunctionalConfig,
    parentConfig,
    config
  ]);
  const provider = config && config.provider;
  const cacheContextRef = (0, import_react35.useRef)(UNDEFINED);
  if (provider && !cacheContextRef.current) {
    cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config);
  }
  const cacheContext = cacheContextRef.current;
  if (cacheContext) {
    extendedConfig.cache = cacheContext[0];
    extendedConfig.mutate = cacheContext[1];
  }
  useIsomorphicLayoutEffect(() => {
    if (cacheContext) {
      cacheContext[2] && cacheContext[2]();
      return cacheContext[3];
    }
  }, []);
  return (0, import_react35.createElement)(SWRConfigContext.Provider, mergeObjects(props, {
    value: extendedConfig
  }));
};
var INFINITE_PREFIX = "$inf$";
var enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;
var use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];
var setupDevTools = () => {
  if (enableDevtools) {
    window.__SWR_DEVTOOLS_REACT__ = import_react35.default;
  }
};
var normalize = (args) => {
  return isFunction(args[1]) ? [
    args[0],
    args[1],
    args[2] || {}
  ] : [
    args[0],
    null,
    (args[1] === null ? args[2] : args[1]) || {}
  ];
};
var useSWRConfig = () => {
  return mergeObjects(defaultConfig, (0, import_react35.useContext)(SWRConfigContext));
};
var middleware = (useSWRNext) => (key_, fetcher_, config) => {
  const fetcher6 = fetcher_ && ((...args) => {
    const [key] = serialize(key_);
    const [, , , PRELOAD] = SWRGlobalState.get(cache);
    if (key.startsWith(INFINITE_PREFIX)) {
      return fetcher_(...args);
    }
    const req = PRELOAD[key];
    if (isUndefined(req))
      return fetcher_(...args);
    delete PRELOAD[key];
    return req;
  });
  return useSWRNext(key_, fetcher6, config);
};
var BUILT_IN_MIDDLEWARE = use.concat(middleware);
var withArgs = (hook) => {
  return function useSWRArgs(...args) {
    const fallbackConfig = useSWRConfig();
    const [key, fn, _config] = normalize(args);
    const config = mergeConfigs(fallbackConfig, _config);
    let next = hook;
    const { use: use3 } = config;
    const middleware2 = (use3 || []).concat(BUILT_IN_MIDDLEWARE);
    for (let i5 = middleware2.length; i5--; ) {
      next = middleware2[i5](next);
    }
    return next(key, fn || config.fetcher || null, config);
  };
};
var subscribeCallback = (key, callbacks, callback) => {
  const keyedRevalidators = callbacks[key] || (callbacks[key] = []);
  keyedRevalidators.push(callback);
  return () => {
    const index2 = keyedRevalidators.indexOf(callback);
    if (index2 >= 0) {
      keyedRevalidators[index2] = keyedRevalidators[keyedRevalidators.length - 1];
      keyedRevalidators.pop();
    }
  };
};
var withMiddleware = (useSWR2, middleware2) => {
  return (...args) => {
    const [key, fn, config] = normalize(args);
    const uses = (config.use || []).concat(middleware2);
    return useSWR2(key, fn, {
      ...config,
      use: uses
    });
  };
};
setupDevTools();

// ../../node_modules/swr/core/dist/index.mjs
var use2 = import_react36.default.use || ((promise) => {
  if (promise.status === "pending") {
    throw promise;
  } else if (promise.status === "fulfilled") {
    return promise.value;
  } else if (promise.status === "rejected") {
    throw promise.reason;
  } else {
    promise.status = "pending";
    promise.then((v2) => {
      promise.status = "fulfilled";
      promise.value = v2;
    }, (e4) => {
      promise.status = "rejected";
      promise.reason = e4;
    });
    throw promise;
  }
});
var WITH_DEDUPE = {
  dedupe: true
};
var useSWRHandler = (_key, fetcher6, config) => {
  const { cache: cache2, compare: compare2, suspense, fallbackData, revalidateOnMount, revalidateIfStale, refreshInterval, refreshWhenHidden, refreshWhenOffline, keepPreviousData } = config;
  const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache2);
  const [key, fnArg] = serialize(_key);
  const initialMountedRef = (0, import_react36.useRef)(false);
  const unmountedRef = (0, import_react36.useRef)(false);
  const keyRef = (0, import_react36.useRef)(key);
  const fetcherRef = (0, import_react36.useRef)(fetcher6);
  const configRef = (0, import_react36.useRef)(config);
  const getConfig = () => configRef.current;
  const isActive = () => getConfig().isVisible() && getConfig().isOnline();
  const [getCache, setCache, subscribeCache, getInitialCache] = createCacheHelper(cache2, key);
  const stateDependencies = (0, import_react36.useRef)({}).current;
  const fallback = isUndefined(fallbackData) ? config.fallback[key] : fallbackData;
  const isEqual3 = (prev, current) => {
    for (const _5 in stateDependencies) {
      const t10 = _5;
      if (t10 === "data") {
        if (!compare2(prev[t10], current[t10])) {
          if (!isUndefined(prev[t10])) {
            return false;
          }
          if (!compare2(returnedData, current[t10])) {
            return false;
          }
        }
      } else {
        if (current[t10] !== prev[t10]) {
          return false;
        }
      }
    }
    return true;
  };
  const getSnapshot = (0, import_react36.useMemo)(() => {
    const shouldStartRequest = (() => {
      if (!key)
        return false;
      if (!fetcher6)
        return false;
      if (!isUndefined(revalidateOnMount))
        return revalidateOnMount;
      if (getConfig().isPaused())
        return false;
      if (suspense)
        return false;
      if (!isUndefined(revalidateIfStale))
        return revalidateIfStale;
      return true;
    })();
    const getSelectedCache = (state) => {
      const snapshot = mergeObjects(state);
      delete snapshot._k;
      if (!shouldStartRequest) {
        return snapshot;
      }
      return {
        isValidating: true,
        isLoading: true,
        ...snapshot
      };
    };
    const cachedData2 = getCache();
    const initialData = getInitialCache();
    const clientSnapshot = getSelectedCache(cachedData2);
    const serverSnapshot = cachedData2 === initialData ? clientSnapshot : getSelectedCache(initialData);
    let memorizedSnapshot = clientSnapshot;
    return [
      () => {
        const newSnapshot = getSelectedCache(getCache());
        const compareResult = isEqual3(newSnapshot, memorizedSnapshot);
        if (compareResult) {
          memorizedSnapshot.data = newSnapshot.data;
          memorizedSnapshot.isLoading = newSnapshot.isLoading;
          memorizedSnapshot.isValidating = newSnapshot.isValidating;
          memorizedSnapshot.error = newSnapshot.error;
          return memorizedSnapshot;
        } else {
          memorizedSnapshot = newSnapshot;
          return newSnapshot;
        }
      },
      () => serverSnapshot
    ];
  }, [
    cache2,
    key
  ]);
  const cached = (0, import_shim.useSyncExternalStore)((0, import_react36.useCallback)(
    (callback) => subscribeCache(key, (current, prev) => {
      if (!isEqual3(prev, current))
        callback();
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      cache2,
      key
    ]
  ), getSnapshot[0], getSnapshot[1]);
  const isInitialMount = !initialMountedRef.current;
  const hasRevalidator = EVENT_REVALIDATORS[key] && EVENT_REVALIDATORS[key].length > 0;
  const cachedData = cached.data;
  const data = isUndefined(cachedData) ? fallback : cachedData;
  const error = cached.error;
  const laggyDataRef = (0, import_react36.useRef)(data);
  const returnedData = keepPreviousData ? isUndefined(cachedData) ? laggyDataRef.current : cachedData : data;
  const shouldDoInitialRevalidation = (() => {
    if (hasRevalidator && !isUndefined(error))
      return false;
    if (isInitialMount && !isUndefined(revalidateOnMount))
      return revalidateOnMount;
    if (getConfig().isPaused())
      return false;
    if (suspense)
      return isUndefined(data) ? false : revalidateIfStale;
    return isUndefined(data) || revalidateIfStale;
  })();
  const defaultValidatingState = !!(key && fetcher6 && isInitialMount && shouldDoInitialRevalidation);
  const isValidating = isUndefined(cached.isValidating) ? defaultValidatingState : cached.isValidating;
  const isLoading = isUndefined(cached.isLoading) ? defaultValidatingState : cached.isLoading;
  const revalidate = (0, import_react36.useCallback)(
    async (revalidateOpts) => {
      const currentFetcher = fetcherRef.current;
      if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {
        return false;
      }
      let newData;
      let startAt;
      let loading = true;
      const opts = revalidateOpts || {};
      const shouldStartNewRequest = !FETCH[key] || !opts.dedupe;
      const callbackSafeguard = () => {
        if (IS_REACT_LEGACY) {
          return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;
        }
        return key === keyRef.current;
      };
      const finalState = {
        isValidating: false,
        isLoading: false
      };
      const finishRequestAndUpdateState = () => {
        setCache(finalState);
      };
      const cleanupState = () => {
        const requestInfo = FETCH[key];
        if (requestInfo && requestInfo[1] === startAt) {
          delete FETCH[key];
        }
      };
      const initialState = {
        isValidating: true
      };
      if (isUndefined(getCache().data)) {
        initialState.isLoading = true;
      }
      try {
        if (shouldStartNewRequest) {
          setCache(initialState);
          if (config.loadingTimeout && isUndefined(getCache().data)) {
            setTimeout(() => {
              if (loading && callbackSafeguard()) {
                getConfig().onLoadingSlow(key, config);
              }
            }, config.loadingTimeout);
          }
          FETCH[key] = [
            currentFetcher(fnArg),
            getTimestamp()
          ];
        }
        [newData, startAt] = FETCH[key];
        newData = await newData;
        if (shouldStartNewRequest) {
          setTimeout(cleanupState, config.dedupingInterval);
        }
        if (!FETCH[key] || FETCH[key][1] !== startAt) {
          if (shouldStartNewRequest) {
            if (callbackSafeguard()) {
              getConfig().onDiscarded(key);
            }
          }
          return false;
        }
        finalState.error = UNDEFINED;
        const mutationInfo = MUTATION[key];
        if (!isUndefined(mutationInfo) && // case 1
        (startAt <= mutationInfo[0] || // case 2
        startAt <= mutationInfo[1] || // case 3
        mutationInfo[1] === 0)) {
          finishRequestAndUpdateState();
          if (shouldStartNewRequest) {
            if (callbackSafeguard()) {
              getConfig().onDiscarded(key);
            }
          }
          return false;
        }
        const cacheData = getCache().data;
        finalState.data = compare2(cacheData, newData) ? cacheData : newData;
        if (shouldStartNewRequest) {
          if (callbackSafeguard()) {
            getConfig().onSuccess(newData, key, config);
          }
        }
      } catch (err) {
        cleanupState();
        const currentConfig = getConfig();
        const { shouldRetryOnError } = currentConfig;
        if (!currentConfig.isPaused()) {
          finalState.error = err;
          if (shouldStartNewRequest && callbackSafeguard()) {
            currentConfig.onError(err, key, currentConfig);
            if (shouldRetryOnError === true || isFunction(shouldRetryOnError) && shouldRetryOnError(err)) {
              if (isActive()) {
                currentConfig.onErrorRetry(err, key, currentConfig, (_opts) => {
                  const revalidators = EVENT_REVALIDATORS[key];
                  if (revalidators && revalidators[0]) {
                    revalidators[0](events.ERROR_REVALIDATE_EVENT, _opts);
                  }
                }, {
                  retryCount: (opts.retryCount || 0) + 1,
                  dedupe: true
                });
              }
            }
          }
        }
      }
      loading = false;
      finishRequestAndUpdateState();
      return true;
    },
    // `setState` is immutable, and `eventsCallback`, `fnArg`, and
    // `keyValidating` are depending on `key`, so we can exclude them from
    // the deps array.
    //
    // FIXME:
    // `fn` and `config` might be changed during the lifecycle,
    // but they might be changed every render like this.
    // `useSWR('key', () => fetch('/api/'), { suspense: true })`
    // So we omit the values from the deps array
    // even though it might cause unexpected behaviors.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      key,
      cache2
    ]
  );
  const boundMutate = (0, import_react36.useCallback)(
    // Use callback to make sure `keyRef.current` returns latest result every time
    (...args) => {
      return internalMutate(cache2, keyRef.current, ...args);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  useIsomorphicLayoutEffect(() => {
    fetcherRef.current = fetcher6;
    configRef.current = config;
    if (!isUndefined(cachedData)) {
      laggyDataRef.current = cachedData;
    }
  });
  useIsomorphicLayoutEffect(() => {
    if (!key)
      return;
    const softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);
    let nextFocusRevalidatedAt = 0;
    const onRevalidate = (type2, opts = {}) => {
      if (type2 == events.FOCUS_EVENT) {
        const now = Date.now();
        if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {
          nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;
          softRevalidate();
        }
      } else if (type2 == events.RECONNECT_EVENT) {
        if (getConfig().revalidateOnReconnect && isActive()) {
          softRevalidate();
        }
      } else if (type2 == events.MUTATE_EVENT) {
        return revalidate();
      } else if (type2 == events.ERROR_REVALIDATE_EVENT) {
        return revalidate(opts);
      }
      return;
    };
    const unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate);
    unmountedRef.current = false;
    keyRef.current = key;
    initialMountedRef.current = true;
    setCache({
      _k: fnArg
    });
    if (shouldDoInitialRevalidation) {
      if (isUndefined(data) || IS_SERVER) {
        softRevalidate();
      } else {
        rAF(softRevalidate);
      }
    }
    return () => {
      unmountedRef.current = true;
      unsubEvents();
    };
  }, [
    key
  ]);
  useIsomorphicLayoutEffect(() => {
    let timer;
    function next() {
      const interval = isFunction(refreshInterval) ? refreshInterval(getCache().data) : refreshInterval;
      if (interval && timer !== -1) {
        timer = setTimeout(execute, interval);
      }
    }
    function execute() {
      if (!getCache().error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {
        revalidate(WITH_DEDUPE).then(next);
      } else {
        next();
      }
    }
    next();
    return () => {
      if (timer) {
        clearTimeout(timer);
        timer = -1;
      }
    };
  }, [
    refreshInterval,
    refreshWhenHidden,
    refreshWhenOffline,
    key
  ]);
  (0, import_react36.useDebugValue)(returnedData);
  if (suspense && isUndefined(data) && key) {
    if (!IS_REACT_LEGACY && IS_SERVER) {
      throw new Error("Fallback data is required when using suspense in SSR.");
    }
    fetcherRef.current = fetcher6;
    configRef.current = config;
    unmountedRef.current = false;
    const req = PRELOAD[key];
    if (!isUndefined(req)) {
      const promise = boundMutate(req);
      use2(promise);
    }
    if (isUndefined(error)) {
      const promise = revalidate(WITH_DEDUPE);
      if (!isUndefined(returnedData)) {
        promise.status = "fulfilled";
        promise.value = true;
      }
      use2(promise);
    } else {
      throw error;
    }
  }
  return {
    mutate: boundMutate,
    get data() {
      stateDependencies.data = true;
      return returnedData;
    },
    get error() {
      stateDependencies.error = true;
      return error;
    },
    get isValidating() {
      stateDependencies.isValidating = true;
      return isValidating;
    },
    get isLoading() {
      stateDependencies.isLoading = true;
      return isLoading;
    }
  };
};
var SWRConfig2 = OBJECT.defineProperty(SWRConfig, "defaultValue", {
  value: defaultConfig
});
var useSWR = withArgs(useSWRHandler);

// ../../packages/myst-to-react/dist/links/wiki.js
var WikiTextMark = () => (0, import_jsx_runtime27.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", version: "1.1", id: "svg3400", viewBox: "0 0 500 85", className: "h-4", children: (0, import_jsx_runtime27.jsxs)("g", { transform: "translate(-357.71336,-784.65111)", children: [(0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 412.98736,806.72288 c 0,0 -1.468,-2.984 -1.968,-3.976 -3.336,-6.612 -3.264,-6.964 -6.636,-7.408 -0.944,-0.124 -1.432,-0.244 -1.432,-0.712 v -2.092 l 0.284,-0.204 c 6.092,-0.008 19.648,-0.008 19.648,-0.008 l 0.52,0.172 v 2.084 c 0,0.476 -0.34,0.72 -1.032,0.72 l -1.424,0.204 c -3.6,0.28 -3.012,1.752 -0.62,6.516 l 22.708,46.46 0.776,0.212 20.16,-47.844 c 0.7,-1.928 0.592,-3.296 -0.308,-4.1 -0.904,-0.784 -1.54,-1.248 -3.876,-1.344 l -1.892,-0.096 c -0.232,0 -0.452,-0.084 -0.664,-0.24 -0.208,-0.148 -0.316,-0.344 -0.316,-0.58 v -1.992 l 0.288,-0.204 c 5.68,0 22.776,0 22.776,0 l 0.232,0.204 v 1.992 c 0,0.54 -0.308,0.812 -0.916,0.812 -2.984,0.132 -5.196,0.78 -6.628,1.936 -1.436,1.164 -2.556,2.768 -3.36,4.852 0,0 -18.54,42.436 -24.884,56.54 -2.428,4.624 -4.816,4.2 -6.916,-0.132 -4.436,-9.136 -16.928,-36.852 -16.928,-36.852 l -7.592,-14.92 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 449.37136,792.29888 c 0,0 -12.812,-0.04 -18.516,0 l -0.284,0.204 v 1.984 c 0,0.244 0.104,0.436 0.312,0.584 0.212,0.156 0.428,0.236 0.66,0.236 l 0.916,0.1 c 2.332,0.096 3.404,0.708 3.724,1.092 0.556,0.68 0.832,1.416 -0.516,4.356 l -23.92,47.708 -0.628,-0.164 c 0,0 -17.132,-36.124 -22.092,-48.208 -0.516,-1.252 -0.748,-2.18 -0.748,-2.752 0,-1.228 1.108,-1.892 3.324,-1.984 l 2.584,-0.108 c 0.684,0 1.032,-0.264 1.032,-0.812 v -1.984 l -0.232,-0.204 c 0,0 -20.52,-0.024 -24.76,0 l -0.232,0.204 v 2.084 c 0,0.376 0.476,0.608 1.432,0.712 2.604,0.14 4.316,0.556 5.14,1.248 0.82,0.7 1.688,2.468 2.84,5.224 6.228,14.96 19.46,41.656 25.904,56.86 1.856,4.152 4.188,4.796 7.02,-0.128 4.904,-9.096 18.2,-36.872 18.2,-36.872 l 10.472,-19.584 c 1.22,-2.068 2.396,-3.912 2.992,-4.772 1.092,-1.572 1.704,-1.868 4.688,-2.008 0.608,0 0.916,-0.272 0.916,-0.82 v -1.984 l -0.228,-0.212 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 488.32736,854.23088 c 0,2.288 1.04,3.64 4.368,3.952 l 2.184,0.212 c 0.312,0 0.624,0.204 0.624,0.62 v 2.184 l -0.104,0.212 c 0,0 -7.904,-0.212 -11.128,-0.212 -2.912,0 -11.024,0.212 -11.024,0.212 l -0.208,-0.212 v -2.184 c 0,-0.416 0.312,-0.62 0.728,-0.62 l 2.08,-0.212 c 3.432,-0.312 4.472,-1.976 4.472,-3.952 v -34.632 c 0,-2.284 -1.252,-2.916 -4.472,-3.22 l -2.08,-0.216 c -0.416,0 -0.728,-0.096 -0.728,-0.416 v -2.396 l 0.104,-0.208 c 0,0 8.216,0.208 11.44,0.208 2.808,0 10.816,-0.208 10.816,-0.208 l 0.104,0.208 v 2.288 c 0,0.312 -0.208,0.52 -0.624,0.52 l -2.184,0.212 c -3.224,0.308 -4.368,1.144 -4.368,3.228 v 34.632 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 519.01936,854.23088 c 0,2.288 1.352,3.432 4.368,3.952 l 1.144,0.212 c 0.312,0.1 0.624,0.204 0.624,0.62 v 2.184 l -0.104,0.212 c 0,0 -6.552,-0.212 -9.672,-0.212 -2.912,0 -11.44,0.212 -11.44,0.212 l -0.208,-0.212 v -2.184 c 0,-0.416 0.312,-0.62 0.728,-0.62 l 2.08,-0.212 c 3.12,-0.312 4.472,-1.976 4.472,-3.952 v -34.632 c 0,-2.284 -1.144,-2.916 -4.472,-3.22 l -2.08,-0.216 c -0.416,0 -0.728,-0.096 -0.728,-0.416 v -2.396 l 0.104,-0.208 c 0,0 8.528,0.208 11.752,0.208 2.916,0 9.464,-0.208 9.464,-0.208 l 0.104,0.208 v 2.288 c 0,0.312 -0.208,0.416 -0.624,0.52 l -1.144,0.212 c -3.224,0.62 -4.368,1.144 -4.368,3.228 v 15.704 c 3.432,0 5.408,-1.764 9.984,-6.656 4.16,-4.58 7.384,-8.42 7.384,-10.4 0,-0.836 -0.936,-1.768 -3.016,-2.084 -0.416,-0.1 -0.624,-0.208 -0.624,-0.52 v -2.396 l 0.104,-0.1 c 0,0 8.424,0.208 11.44,0.208 2.704,0 7.28,-0.208 7.28,-0.208 l 0.312,0.1 v 2.396 c 0,0.312 -0.312,0.52 -0.832,0.52 -4.056,0.312 -6.864,0.52 -10.608,4.784 l -8.944,10.292 c -1.768,1.876 -2.392,3.016 -2.392,3.852 0,0.624 0.416,1.14 0.936,1.764 l 15.704,18.928 c 1.248,1.452 3.744,2.08 5.824,2.492 l 0.52,0.1 c 0.312,0.104 0.728,0.312 0.728,0.624 v 2.184 l -0.312,0.104 c 0,0 -5.512,-0.104 -8.424,-0.104 -2.6,0 -6.344,0.104 -6.344,0.104 l -0.104,-0.104 v -1.248 c 0,-1.356 -0.104,-2.492 -1.56,-4.156 l -11.544,-14.356 c -1.56,-2.084 -3.224,-2.596 -5.512,-2.596 v 15.404 l 0,0 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 575.08736,854.23088 c 0,2.288 1.04,3.64 4.368,3.952 l 2.184,0.212 c 0.312,0 0.624,0.204 0.624,0.62 v 2.184 l -0.104,0.212 c 0,0 -7.904,-0.212 -11.128,-0.212 -2.912,0 -11.024,0.212 -11.024,0.212 l -0.208,-0.212 v -2.184 c 0,-0.416 0.312,-0.62 0.728,-0.62 l 2.08,-0.212 c 3.432,-0.312 4.472,-1.976 4.472,-3.952 v -34.632 c 0,-2.284 -1.248,-2.916 -4.472,-3.22 l -2.08,-0.216 c -0.416,0 -0.728,-0.096 -0.728,-0.416 v -2.396 l 0.104,-0.208 c 0,0 8.216,0.208 11.44,0.208 2.808,0 10.816,-0.208 10.816,-0.208 l 0.104,0.208 v 2.288 c 0,0.312 -0.208,0.52 -0.624,0.52 l -2.184,0.212 c -3.224,0.308 -4.368,1.144 -4.368,3.228 v 34.632 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 597.55936,819.80288 c 0,-3.224 -1.352,-3.328 -6.24,-3.64 -0.624,0 -0.728,-0.308 -0.728,-0.52 v -2.392 l 0.208,-0.104 c 1.56,0 7.696,0.208 10.712,0.208 2.912,0 7.072,-0.208 10.92,-0.208 14.76,0 17.464,7.276 17.464,12.692 0,6.244 -3.016,16.016 -17.776,16.016 -2.6,0 -4.68,-0.212 -6.556,-1.04 v 13.928 c 0,2.288 1.248,2.812 4.58,3.328 l 2.084,0.312 c 0.416,0.104 0.728,0.212 0.728,0.624 v 2.184 l -0.1,0.208 c 0,0 -8.32,-0.208 -11.544,-0.208 -2.912,0 -10.712,0.208 -10.712,0.208 l -0.104,-0.208 v -2.184 c 0,-0.416 0.208,-0.52 0.624,-0.624 l 2.184,-0.312 c 3.224,-0.416 4.264,-1.352 4.264,-3.328 l -0.008,-34.94 0,0 z m 8.008,18.1 c 2.08,0.836 4.68,0.936 6.76,0.936 6.244,0 9.248,-3.752 9.248,-11.752 0,-8.944 -4.056,-10.92 -9.768,-10.92 -4.996,0 -6.244,0.936 -6.244,3.64 l 0.004,18.096 0,0 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 647.80736,861.19888 c -3.12,0 -10.292,0.212 -10.292,0.212 l -0.108,-0.212 v -2.288 c 0,-0.204 0.108,-0.516 0.624,-0.516 l 2.396,-0.212 c 3.228,-0.312 4.164,-2.392 4.164,-4.468 v -34.32 c 0,-2.4 -1.252,-2.812 -4.164,-3.016 l -2.396,-0.216 c -0.624,-0.096 -0.624,-0.308 -0.624,-0.416 v -2.396 l 0.108,-0.208 c 0,0 8.108,0.208 11.228,0.208 h 15.288 c 3.12,0 10.508,-0.208 10.508,-0.208 l 0.212,0.208 c 0.1,4.472 0.828,8.536 1.56,12.484 l -2.596,0.416 c -1.14,-3.852 -3.116,-9.36 -9.772,-9.36 h -8.32 c -1.976,0 -3.016,0.728 -3.016,2.492 v 15.084 h 7.796 c 2.916,0 3.64,-1.248 4.06,-3.328 l 0.62,-2.184 c 0,-0.312 0.212,-0.524 0.624,-0.524 h 1.764 c 0.212,0 0.212,0.108 0.212,0.312 -0.212,2.288 -0.624,5.204 -0.624,7.7 0,2.596 0.416,4.784 0.624,7.176 l -0.212,0.212 h -1.764 c -0.516,0 -0.732,-0.212 -0.732,-0.524 l -0.52,-2.284 c -0.416,-2.084 -1.352,-3.228 -4.064,-3.228 h -7.792 v 15.916 c 0,1.972 1.136,3.948 3.016,3.948 h 9.88 c 5.304,0 8.22,-3.328 9.464,-8.74 l 2.596,0.312 -2.084,11.956 -0.208,0.208 c 0,0 -6.136,-0.208 -9.256,-0.208 l -18.2,0.012 0,0 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 686.91936,858.39488 2.392,-0.212 c 3.124,-0.312 4.164,-1.248 4.164,-4.468 v -34.32 c 0,-2.712 -0.736,-2.712 -4.164,-3.016 l -2.28,-0.216 c -0.416,0 -0.736,-0.208 -0.736,-0.52 v -2.288 l 0.1,-0.208 c 0,0 9.156,0.208 11.032,0.208 1.968,0 11.024,-0.208 13.728,-0.208 17.368,0 25.9,10.816 25.9,24.648 0,18.204 -12.9,23.604 -24.44,23.604 -8.32,0 -11.956,-0.208 -15.18,-0.208 -3.124,0 -11.028,0.208 -11.028,0.208 l -0.104,-0.208 v -2.184 c -0.008,-0.3 0.204,-0.612 0.616,-0.612 z m 23.196,0 c 11.436,0 17.892,-4.26 17.892,-18.828 0,-10.812 -2.396,-23.404 -19.868,-23.404 -4.056,0 -6.656,0.624 -6.656,3.232 v 34.32 c 0,2.904 0.724,4.68 8.632,4.68 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 761.60736,854.23088 c 0,2.288 1.04,3.64 4.368,3.952 l 2.184,0.212 c 0.312,0 0.624,0.204 0.624,0.62 v 2.184 l -0.104,0.212 c 0,0 -7.904,-0.212 -11.124,-0.212 -2.916,0 -11.024,0.212 -11.024,0.212 l -0.212,-0.212 v -2.184 c 0,-0.416 0.312,-0.62 0.728,-0.62 l 2.084,-0.212 c 3.428,-0.312 4.472,-1.976 4.472,-3.952 v -34.632 c 0,-2.284 -1.252,-2.916 -4.472,-3.22 l -2.084,-0.216 c -0.416,0 -0.728,-0.096 -0.728,-0.416 v -2.396 l 0.104,-0.208 c 0,0 8.216,0.208 11.432,0.208 2.808,0 10.82,-0.208 10.82,-0.208 l 0.1,0.208 v 2.288 c 0,0.312 -0.212,0.52 -0.624,0.52 l -2.184,0.212 c -3.224,0.308 -4.368,1.144 -4.368,3.228 l 0.008,34.632 0,0 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 793.64736,858.18288 3.016,0.212 c 0.416,0 0.832,0.312 0.832,0.828 v 1.976 l -0.208,0.212 c 0,0 -11.336,-0.212 -13.832,-0.212 -2.708,0 -9.364,0.212 -9.364,0.212 l -0.212,-0.212 v -1.976 c 0,-0.516 0.312,-0.828 0.836,-0.828 4.58,-0.312 7.172,-1.148 10.084,-7.804 l 23.084,-54.084 c 1.14,-2.704 1.976,-3.748 3.54,-3.748 1.452,0 1.976,1.044 2.804,3.124 l 21.32,56.368 c 1.46,4.06 3.54,5.616 7.7,6.032 l 1.144,0.1 c 0.52,0 1.04,0.312 1.04,0.836 v 1.972 l -0.312,0.208 c 0,0 -8.008,-0.208 -12.064,-0.208 -3.64,0 -13.836,0.208 -13.836,0.208 l -0.1,-0.208 v -1.972 c 0,-0.524 0.208,-0.836 0.736,-0.836 l 2.912,-0.208 c 3.948,-0.308 5.412,-1.564 4.368,-4.472 l -6.344,-17.58 h -21.632 c -2.496,0 -3.12,0.416 -3.636,1.764 l -6.036,15.084 c -1.04,2.608 0.312,4.9 4.16,5.212 z m 25.48,-26.424 -10.088,-27.764 h -0.208 l -10.4,26.416 c -0.416,1.044 0.308,1.352 2.596,1.352 h 18.1 z" })] }) });
var fetcher = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.json();
  throw new Error(`Content returned with status ${res.status}.`);
});
var ENGLISH_WIKIPEDIA = "https://en.wikipedia.org/";
function createWikiUrl(name2, wiki) {
  return `${wiki || ENGLISH_WIKIPEDIA}wiki/${name2}`;
}
function createWikiApiUrl(name2, wiki) {
  return `${wiki || ENGLISH_WIKIPEDIA}api/rest_v1/page/summary/${name2}`;
}
function WikiChild({ page, wiki, load: load2 }) {
  var _a, _b;
  const { data, error } = useSWR(load2 ? createWikiApiUrl(page, wiki) : null, fetcher);
  const { thumbnail, extract, content_urls } = data !== null && data !== void 0 ? data : {};
  const url = (_b = (_a = content_urls === null || content_urls === void 0 ? void 0 : content_urls.desktop) === null || _a === void 0 ? void 0 : _a.page) !== null && _b !== void 0 ? _b : createWikiUrl(page);
  const image = thumbnail === null || thumbnail === void 0 ? void 0 : thumbnail.source;
  if (error) {
    return (0, import_jsx_runtime27.jsxs)("span", { children: [(0, import_jsx_runtime27.jsxs)("a", { href: url, className: "block text-inherit hover:text-inherit", target: "_blank", rel: "noreferrer", children: [(0, import_jsx_runtime27.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1rem", height: "1rem", className: "float-right" }), (0, import_jsx_runtime27.jsx)(WikiTextMark, {})] }), (0, import_jsx_runtime27.jsxs)("div", { className: "mt-2", children: ['Error loading "', page, '" from wikipedia.'] })] });
  }
  return (0, import_jsx_runtime27.jsx)(LinkCard, { loading: !data, url, title: (0, import_jsx_runtime27.jsx)(WikiTextMark, {}), thumbnail: image, description: extract });
}
function WikiLink({ children, page, url, wiki }) {
  return (0, import_jsx_runtime27.jsx)(HoverPopover, { card: ({ load: load2 }) => (0, import_jsx_runtime27.jsx)(WikiChild, { wiki, page, load: load2 }), children: (0, import_jsx_runtime27.jsx)("a", { href: url, className: "italic", target: "_blank", rel: "noreferrer", children }) });
}

// ../../packages/myst-to-react/dist/links/rrid.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var fetcher2 = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.json();
  throw new Error(`Content returned with status ${res.status}.`);
});
function RRIDChild({ rrid }) {
  var _a, _b, _c, _d, _e, _f, _g;
  const { data, error } = useSWR(`https://scicrunch.org/resolver/${rrid}.json`, fetcher2);
  if (!data && !error) {
    return (0, import_jsx_runtime28.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] animate-pulse", children: "Loading..." });
  }
  const hit = (_b = (_a = data === null || data === void 0 ? void 0 : data.hits) === null || _a === void 0 ? void 0 : _a.hits) === null || _b === void 0 ? void 0 : _b[0];
  if (error || !hit) {
    return (0, import_jsx_runtime28.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px]", children: ["Error loading ", rrid, "."] });
  }
  const { name: title, curie, description, supercategory, keywords, types: categories } = (_d = (_c = hit === null || hit === void 0 ? void 0 : hit._source) === null || _c === void 0 ? void 0 : _c.item) !== null && _d !== void 0 ? _d : {};
  const category = (_e = supercategory === null || supercategory === void 0 ? void 0 : supercategory[0]) === null || _e === void 0 ? void 0 : _e.name;
  const types2 = (_f = categories === null || categories === void 0 ? void 0 : categories.map(({ name: name2 }) => name2)) !== null && _f !== void 0 ? _f : [];
  const tags = (_g = keywords === null || keywords === void 0 ? void 0 : keywords.map(({ keyword }) => keyword)) !== null && _g !== void 0 ? _g : [];
  return (0, import_jsx_runtime28.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] p-3", children: [(0, import_jsx_runtime28.jsxs)("p", { className: "text-sm font-light", children: ["RRID: ", category] }), (0, import_jsx_runtime28.jsxs)("div", { className: "mb-4 text-xl font-bold", children: [title, " ", (0, import_jsx_runtime28.jsx)("code", { children: curie })] }), (0, import_jsx_runtime28.jsx)("p", { className: "text-md", children: description }), types2.length > 0 && (0, import_jsx_runtime28.jsxs)(import_jsx_runtime28.Fragment, { children: [(0, import_jsx_runtime28.jsx)("div", { className: "my-2 text-xs font-thin", children: "Categories" }), (0, import_jsx_runtime28.jsx)("div", { className: "flex flex-wrap ml-1", children: types2 === null || types2 === void 0 ? void 0 : types2.map((tag) => (0, import_jsx_runtime28.jsx)("span", { className: "inline-flex items-center px-3 py-1 ml-1 text-xs uppercase border rounded-full", children: tag })) })] }), tags.length > 0 && (0, import_jsx_runtime28.jsxs)(import_jsx_runtime28.Fragment, { children: [(0, import_jsx_runtime28.jsx)("div", { className: "my-2 text-xs font-thin", children: "Tags" }), (0, import_jsx_runtime28.jsx)("div", { className: "flex flex-wrap ml-1", children: tags === null || tags === void 0 ? void 0 : tags.map((tag) => (0, import_jsx_runtime28.jsx)("span", { className: "inline-flex items-center px-3 py-1 ml-1 text-xs uppercase border rounded-full", children: tag })) })] })] });
}
function RRIDLink({ rrid }) {
  return (0, import_jsx_runtime28.jsx)(HoverPopover, { card: (0, import_jsx_runtime28.jsx)(RRIDChild, { rrid }), children: (0, import_jsx_runtime28.jsxs)("a", { href: `https://scicrunch.org/resolver/${rrid}`, target: "_blank", rel: "noopener noreferrer", children: ["RRID: ", (0, import_jsx_runtime28.jsx)("cite", { className: "italic", children: rrid })] }) });
}

// ../../packages/myst-to-react/dist/links/github.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react37 = __toESM(require_react(), 1);
var import_classnames11 = __toESM(require_classnames(), 1);
var fetcher3 = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.text();
  throw new Error(`Content returned with status ${res.status}.`);
});
var jsonFetcher = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.json();
  throw new Error(`Content returned with status ${res.status}.`);
});
function extToLanguage(ext) {
  var _a;
  return (_a = {
    ts: "typescript",
    js: "javascript",
    py: "python",
    md: "markdown",
    yml: "yaml"
  }[ext !== null && ext !== void 0 ? ext : ""]) !== null && _a !== void 0 ? _a : ext;
}
function useLoadWhenOpen(open, url, loader3) {
  const [cached, setCached] = (0, import_react37.useState)();
  const { data, error } = useSWR(open ? url : null, loader3);
  (0, import_react37.useEffect)(() => {
    setCached(cached || data);
  }, [cached, url, data]);
  return { data: cached, error };
}
function GithubFilePreview({ url, raw, org, repo, file, from, to, open }) {
  const { data, error } = useLoadWhenOpen(open, raw, fetcher3);
  let code3 = data;
  if (error) {
    return (0, import_jsx_runtime29.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px]", children: [(0, import_jsx_runtime29.jsx)("a", { href: url, className: "block text-inherit hover:text-inherit", target: "_blank", rel: "noreferrer", children: (0, import_jsx_runtime29.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1rem", height: "1rem", className: "float-right" }) }), (0, import_jsx_runtime29.jsxs)("div", { className: "mt-2", children: ['Error loading "', file, '" from GitHub.'] })] });
  }
  const lang = extToLanguage(file === null || file === void 0 ? void 0 : file.split(".").pop());
  let startingLineNumber = 1;
  let emphasizeLines = [];
  const offset2 = 5;
  if (code3 && from && to) {
    startingLineNumber = from;
    code3 = code3 === null || code3 === void 0 ? void 0 : code3.split("\n").slice(from - 1, to).join("\n");
  } else if (code3 && from) {
    startingLineNumber = from + 1 - offset2;
    emphasizeLines = [from];
    code3 = code3 === null || code3 === void 0 ? void 0 : code3.split("\n").slice(Math.max(0, from - offset2), from + offset2).join("\n");
  } else {
    code3 = code3 === null || code3 === void 0 ? void 0 : code3.split("\n").slice(0, 10).join("\n");
  }
  const description = code3 ? (0, import_jsx_runtime29.jsx)(import_jsx_runtime29.Fragment, { children: (0, import_jsx_runtime29.jsx)(CodeBlock, { value: code3, lang, filename: file, showLineNumbers: true, startingLineNumber, emphasizeLines, showCopy: false }) }) : null;
  return (0, import_jsx_runtime29.jsx)(LinkCard, { loading: !code3, url, title: `GitHub - ${org}/${repo}`, description, className: "hover-document article max-w-[80vw]" });
}
function useWhiteTextColor(bgColor) {
  const color2 = bgColor.charAt(0) === "#" ? bgColor.substring(1, 7) : bgColor;
  const r4 = parseInt(color2.substring(0, 2), 16);
  const g4 = parseInt(color2.substring(2, 4), 16);
  const b4 = parseInt(color2.substring(4, 6), 16);
  return r4 * 0.299 + g4 * 0.587 + b4 * 0.114 <= 186;
}
function GithubIssuePreview({ url, org, repo, issue_number, open }) {
  var _a, _b;
  const { data, error } = useLoadWhenOpen(open, `https://api.github.com/repos/${org}/${repo}/issues/${issue_number}`, jsonFetcher);
  if (!data && !error) {
    return (0, import_jsx_runtime29.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] animate-pulse", children: "Loading..." });
  }
  const resp = data;
  if (error) {
    return (0, import_jsx_runtime29.jsxs)("div", { className: "hover-document article", children: [(0, import_jsx_runtime29.jsx)("a", { href: url, className: "block text-inherit hover:text-inherit", target: "_blank", rel: "noreferrer", children: (0, import_jsx_runtime29.jsx)(ArrowTopRightOnSquareIcon_default, { className: "float-right w-4 h-4" }) }), (0, import_jsx_runtime29.jsx)("div", { className: "mt-2", children: "Error loading from GitHub." })] });
  }
  const dateString = new Date(resp.created_at).toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric"
  });
  return (0, import_jsx_runtime29.jsxs)("div", { className: "hover-document article w-[400px] sm:max-w-[400px] p-3", children: [(0, import_jsx_runtime29.jsxs)("div", { className: "text-xs font-light", children: [org, "/", repo] }), (0, import_jsx_runtime29.jsxs)("div", { className: "my-2 text-lg font-bold dark:text-white", children: [resp.state === "open" && (0, import_jsx_runtime29.jsx)(PlusCircleIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block mr-2 text-green-700 -translate-y-px dark:text-green-500" }), resp.state === "closed" && (0, import_jsx_runtime29.jsx)(CheckCircleIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block mr-2 text-purple-700 -translate-y-px dark:text-purple-500" }), resp.title] }), (0, import_jsx_runtime29.jsxs)("div", { className: "text-xs font-light", children: ["#", issue_number, " opened on ", dateString, " by", " ", (0, import_jsx_runtime29.jsxs)("span", { className: "font-normal", children: ["@", resp.user.login] })] }), (0, import_jsx_runtime29.jsx)("p", { className: "text-md max-h-[4rem] overflow-hidden", children: resp.body }), ((_a = resp.labels) === null || _a === void 0 ? void 0 : _a.length) > 0 && (0, import_jsx_runtime29.jsx)("div", { className: "flex flex-wrap", children: (_b = resp.labels) === null || _b === void 0 ? void 0 : _b.map((label) => (0, import_jsx_runtime29.jsx)("span", { className: (0, import_classnames11.default)("mr-1 text-xs inline-flex items-center px-2 py-0.5 rounded-full", {
    "text-white": useWhiteTextColor(label.color)
  }), style: { backgroundColor: `#${label.color}` }, children: label.name }, label.id)) })] });
}
function GithubLink({ kind, children, url, org, repo, raw, file, from, to, issue_number }) {
  return (0, import_jsx_runtime29.jsx)(HoverPopover, { card: ({ load: load2 }) => {
    if (kind === "file") {
      return (0, import_jsx_runtime29.jsx)(GithubFilePreview, { url, raw, file, from, to, open: load2, org, repo });
    }
    if (kind === "issue") {
      return (0, import_jsx_runtime29.jsx)(GithubIssuePreview, { url, open: load2, org, issue_number, repo });
    }
  }, children: (0, import_jsx_runtime29.jsx)("a", { href: url, className: "italic", target: "_blank", rel: "noreferrer", children }) });
}

// ../../packages/myst-to-react/dist/links/index.js
function getPageInfo(site, path2) {
  var _a;
  if (!site)
    return void 0;
  const [projectSlug, pageSlug] = path2.replace(/^\//, "").split("/");
  const project = (_a = site.projects) === null || _a === void 0 ? void 0 : _a.find((p3) => p3.slug === projectSlug || !p3.slug && !pageSlug);
  if (!project)
    return void 0;
  return project.pages.find((p3) => p3.slug === (pageSlug || projectSlug));
}
function InternalLink({ url, children }) {
  const Link2 = useLinkProvider();
  const site = useSiteManifest();
  const page = getPageInfo(site, url);
  const baseurl = useBaseurl();
  const skipPreview = !page || !page.description && !page.thumbnail;
  if (!page || skipPreview) {
    return (0, import_jsx_runtime30.jsx)(Link2, { to: withBaseurl(url, baseurl), prefetch: "intent", children });
  }
  return (0, import_jsx_runtime30.jsx)(HoverPopover, { card: (0, import_jsx_runtime30.jsx)(LinkCard, { internal: true, url, title: page.title, description: page.description, thumbnail: page.thumbnailOptimized || page.thumbnail }), children: (0, import_jsx_runtime30.jsx)(Link2, { to: withBaseurl(url, baseurl), prefetch: "intent", children }) });
}
var link = ({ node }) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  const internal = (_a = node.internal) !== null && _a !== void 0 ? _a : false;
  const protocol = node.protocol;
  switch (protocol) {
    case "wiki":
      return (0, import_jsx_runtime30.jsx)(WikiLink, { url: node.url, page: (_b = node.data) === null || _b === void 0 ? void 0 : _b.page, wiki: (_c = node.data) === null || _c === void 0 ? void 0 : _c.wiki, children: (0, import_jsx_runtime30.jsx)(MyST, { ast: node.children }) });
    case "github":
      return (0, import_jsx_runtime30.jsx)(GithubLink, { kind: (_d = node.data) === null || _d === void 0 ? void 0 : _d.kind, url: node.url, org: (_e = node.data) === null || _e === void 0 ? void 0 : _e.org, repo: (_f = node.data) === null || _f === void 0 ? void 0 : _f.repo, raw: (_g = node.data) === null || _g === void 0 ? void 0 : _g.raw, file: (_h = node.data) === null || _h === void 0 ? void 0 : _h.file, from: (_j = node.data) === null || _j === void 0 ? void 0 : _j.from, to: (_k = node.data) === null || _k === void 0 ? void 0 : _k.to, issue_number: (_l = node.data) === null || _l === void 0 ? void 0 : _l.issue_number, children: (0, import_jsx_runtime30.jsx)(MyST, { ast: node.children }) });
    case "rrid":
      return (0, import_jsx_runtime30.jsx)(RRIDLink, { rrid: (_m = node.data) === null || _m === void 0 ? void 0 : _m.rrid });
    default:
      if (internal) {
        return (0, import_jsx_runtime30.jsx)(InternalLink, { url: node.url, children: (0, import_jsx_runtime30.jsx)(MyST, { ast: node.children }) });
      }
      return (0, import_jsx_runtime30.jsx)("a", { target: "_blank", href: node.url, rel: "noreferrer", children: (0, import_jsx_runtime30.jsx)(MyST, { ast: node.children }) });
  }
};
var linkBlock = ({ node }) => {
  var _a;
  const iconClass5 = "self-center transition-transform flex-none ml-3";
  const containerClass = "flex-1 p-4 my-5 block border font-normal hover:border-blue-500 dark:hover:border-blue-400 no-underline hover:text-blue-600 dark:hover:text-blue-400 text-gray-600 dark:text-gray-100 border-gray-200 dark:border-gray-500 rounded shadow-sm hover:shadow-lg dark:shadow-neutral-700";
  const internal = (_a = node.internal) !== null && _a !== void 0 ? _a : false;
  const nested = (0, import_jsx_runtime30.jsxs)("div", { className: "flex h-full align-middle", children: [(0, import_jsx_runtime30.jsxs)("div", { className: "flex-grow", children: [node.title, (0, import_jsx_runtime30.jsx)("div", { className: "text-xs text-gray-500 dark:text-gray-400", children: (0, import_jsx_runtime30.jsx)(MyST, { ast: node.children }) })] }), internal && (0, import_jsx_runtime30.jsx)(LinkIcon_default, { width: "1.5rem", height: "1.5rem", className: iconClass5 }), !internal && (0, import_jsx_runtime30.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1.5rem", height: "1.5rem", className: iconClass5 })] });
  if (internal) {
    return (0, import_jsx_runtime30.jsx)("a", { href: node.url, className: containerClass, children: nested });
  }
  return (0, import_jsx_runtime30.jsx)("a", { className: containerClass, target: "_blank", rel: "noopener noreferrer", href: node.url, children: nested });
};
var LINK_RENDERERS = {
  link,
  linkBlock
};
var links_default = LINK_RENDERERS;

// ../../packages/myst-to-react/dist/crossReference.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var hiddenNodes = /* @__PURE__ */ new Set(["comment", "mystComment"]);
function selectHeadingNodes(mdast, identifier, maxNodes = 3) {
  let begin = false;
  let htmlId = void 0;
  const nodes = [];
  visit(mdast, (node) => {
    if (begin && node.type === "heading" || nodes.length >= maxNodes) {
      return EXIT;
    }
    if (node.identifier === identifier && node.type === "heading") {
      begin = true;
      htmlId = node.html_id || node.identifier;
    }
    if (begin) {
      if (!hiddenNodes.has(node.type))
        nodes.push(node);
      return SKIP;
    }
  });
  return { htmlId, nodes };
}
function selectDefinitionTerm(mdast, identifier) {
  var _a, _b;
  let begin = false;
  const nodes = [];
  visit(mdast, (node) => {
    if (begin && node.type === "definitionTerm") {
      if (nodes.length > 1)
        return EXIT;
    } else if (begin && node.type !== "definitionDescription") {
      return EXIT;
    }
    if (node.identifier === identifier && node.type === "definitionTerm") {
      nodes.push(node);
      begin = true;
    }
    if (begin) {
      if (node.type === "definitionDescription")
        nodes.push(node);
      return SKIP;
    }
  });
  return {
    htmlId: ((_a = nodes === null || nodes === void 0 ? void 0 : nodes[0]) === null || _a === void 0 ? void 0 : _a.html_id) || ((_b = nodes === null || nodes === void 0 ? void 0 : nodes[0]) === null || _b === void 0 ? void 0 : _b.identifier),
    nodes: [{ type: "definitionList", key: "dl", children: nodes }]
  };
}
function selectMdastNodes(mdast, identifier) {
  const node = selectAll(`[identifier=${identifier}],[key=${identifier}]`, mdast).filter(({ type: type2 }) => type2 !== "crossReference" && type2 !== "cite")[0];
  if (!node)
    return { nodes: [] };
  switch (node.type) {
    case "heading":
      return selectHeadingNodes(mdast, identifier);
    case "definitionTerm":
      return selectDefinitionTerm(mdast, identifier);
    default:
      return { htmlId: node.html_id || node.identifier, nodes: [node] };
  }
}
var fetcher4 = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.json();
  throw new Error(`Content returned with status ${res.status}.`);
});
function XrefChildren({ load: load2, remote, url, dataUrl, identifier }) {
  const data = useSelectNodes({ load: load2, remote, url, dataUrl, identifier });
  if (!data)
    return null;
  if (data.loading) {
    return (0, import_jsx_runtime31.jsx)(import_jsx_runtime31.Fragment, { children: "Loading..." });
  }
  if (data.error) {
    return (0, import_jsx_runtime31.jsx)(import_jsx_runtime31.Fragment, { children: "Error loading remote page." });
  }
  if (!data.nodes || data.nodes.length === 0) {
    return (0, import_jsx_runtime31.jsx)(import_jsx_runtime31.Fragment, { children: (0, import_jsx_runtime31.jsx)(InlineError, { value: identifier || "No Label", message: "Cross Reference Not Found" }) });
  }
  return (0, import_jsx_runtime31.jsx)(MyST, { ast: data === null || data === void 0 ? void 0 : data.nodes });
}
function openDetails(el) {
  if (!el)
    return;
  if (el.nodeName === "DETAILS") {
    el.open = true;
  }
  openDetails(el.parentElement);
}
function useFetchMdast({ remote, url, dataUrl }) {
  var _a;
  const baseurl = useBaseurl();
  const external = (_a = url === null || url === void 0 ? void 0 : url.startsWith("http")) !== null && _a !== void 0 ? _a : false;
  const lookupUrl = external ? `/api/lookup?url=${url}.json` : dataUrl ? `${withBaseurl(dataUrl, baseurl)}` : `${withBaseurl(url, baseurl)}.json`;
  return useSWR(remote ? lookupUrl : null, fetcher4);
}
function useSelectNodes({ load: load2, remote, url, dataUrl, identifier }) {
  var _a;
  const references = useReferences();
  if (!load2)
    return;
  const { data, error } = useFetchMdast({ remote, url, dataUrl });
  const mdast = (_a = data === null || data === void 0 ? void 0 : data.mdast) !== null && _a !== void 0 ? _a : references === null || references === void 0 ? void 0 : references.article;
  const { nodes, htmlId } = selectMdastNodes(mdast, identifier);
  return { htmlId, nodes, loading: remote && !data, error: remote && error };
}
function CrossReferenceHover({ url: urlIn, dataUrl: dataUrlIn, remote: remoteIn, children, identifier, htmlId = "" }) {
  var _a;
  const Link2 = useLinkProvider();
  const baseurl = useBaseurl();
  const parent = useXRefState();
  const remote = parent.remote || remoteIn;
  const url = parent.remote ? urlIn !== null && urlIn !== void 0 ? urlIn : parent.url : urlIn;
  const dataUrl = parent.remote ? dataUrlIn !== null && dataUrlIn !== void 0 ? dataUrlIn : parent.dataUrl : dataUrlIn;
  const external = (_a = url === null || url === void 0 ? void 0 : url.startsWith("http")) !== null && _a !== void 0 ? _a : false;
  const scroll = (e4) => {
    e4.preventDefault();
    if (!htmlId)
      return;
    const el = document.getElementById(htmlId);
    openDetails(el);
    el === null || el === void 0 ? void 0 : el.scrollIntoView({ behavior: "smooth" });
    history.replaceState(void 0, "", `#${htmlId}`);
  };
  return (0, import_jsx_runtime31.jsx)(HoverPopover, { card: ({ load: load2 }) => (0, import_jsx_runtime31.jsx)(XRefProvider, { remote, url, dataUrl, children: (0, import_jsx_runtime31.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] px-3", children: (0, import_jsx_runtime31.jsx)(XrefChildren, { load: load2, remote, url, dataUrl, identifier }) }) }), children: (0, import_jsx_runtime31.jsxs)("span", { children: [remote && external && (0, import_jsx_runtime31.jsx)("a", { href: `${url}${htmlId ? `#${htmlId}` : ""}`, target: "_blank", className: "hover-link", children }), remote && !external && (0, import_jsx_runtime31.jsx)(Link2, { to: `${withBaseurl(url, baseurl)}${htmlId ? `#${htmlId}` : ""}`, prefetch: "intent", className: "hover-link", children }), !remote && (0, import_jsx_runtime31.jsx)("a", { href: `#${htmlId}`, onClick: scroll, className: "hover-link", children })] }) });
}
var CrossReferenceNode = ({ node }) => {
  if (!node.children) {
    return (0, import_jsx_runtime31.jsx)(InlineError, { value: node.label || node.identifier || "No Label", message: "Cross Reference Not Found" });
  }
  const { remote, url, dataUrl, identifier, html_id } = node;
  return (0, import_jsx_runtime31.jsxs)(CrossReferenceHover, { identifier, htmlId: html_id, remote, url, dataUrl, children: [node.prefix && (0, import_jsx_runtime31.jsxs)(import_jsx_runtime31.Fragment, { children: [node.prefix, " "] }), (0, import_jsx_runtime31.jsx)(MyST, { ast: node.children }), node.suffix || null] });
};
var CROSS_REFERENCE_RENDERERS = {
  crossReference: CrossReferenceNode
};
var crossReference_default = CROSS_REFERENCE_RENDERERS;

// ../../packages/myst-to-react/dist/tabs.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_classnames12 = __toESM(require_classnames(), 1);
var import_react38 = __toESM(require_react(), 1);
var TabSetContext = (0, import_react38.createContext)(void 0);
function TabSetStateProvider({ active, children }) {
  return (0, import_jsx_runtime32.jsx)(TabSetContext.Provider, { value: active, children });
}
function TabSet({ tabs, children }) {
  var _a, _b, _c, _d;
  const [lastClickedTab, onClickSyncedTab] = (_a = useTabSet()) !== null && _a !== void 0 ? _a : [];
  const [active, setActive] = (0, import_react38.useState)((_c = (_b = tabs.find((t10) => t10.selected)) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : (_d = tabs === null || tabs === void 0 ? void 0 : tabs[0]) === null || _d === void 0 ? void 0 : _d.id);
  const onClick = (tab) => {
    setActive(tab.id);
    if (tab.sync) {
      if (!onClickSyncedTab) {
        console.error("TabStateProvider is not defined, synced tabs will not work.");
      }
      onClickSyncedTab === null || onClickSyncedTab === void 0 ? void 0 : onClickSyncedTab(tab.sync);
    }
  };
  (0, import_react38.useEffect)(() => {
    if (!lastClickedTab)
      return;
    const tab = tabs.find((item) => item.sync === lastClickedTab);
    if (!tab)
      return;
    setActive(tab === null || tab === void 0 ? void 0 : tab.id);
  }, [tabs, lastClickedTab, setActive]);
  return (0, import_jsx_runtime32.jsx)(TabSetStateProvider, { active, children: (0, import_jsx_runtime32.jsxs)("div", { className: "my-5", children: [(0, import_jsx_runtime32.jsx)("div", { className: "flex flex-row overflow-x-auto border-b border-b-gray-100", children: tabs.map((tab) => {
    return (0, import_jsx_runtime32.jsx)("div", { className: (0, import_classnames12.default)("flex-none px-3 py-1 font-semibold cursor-pointer", {
      "text-blue-600 border-b-2 border-b-blue-600 dark:border-b-white dark:text-white": active === tab.id,
      "text-gray-500 dark:text-gray-300 hover:text-gray-700 dark:hover:text-gray-100": active !== tab.id
    }), onClick: () => onClick(tab), children: tab.title }, tab.id);
  }) }), (0, import_jsx_runtime32.jsx)("div", { className: "flex shadow", children: (0, import_jsx_runtime32.jsx)("div", { className: "w-full px-6", children }) })] }) });
}
function TabItem({ id, children }) {
  const active = (0, import_react38.useContext)(TabSetContext);
  const open = active === id;
  return (0, import_jsx_runtime32.jsx)("div", { className: (0, import_classnames12.default)({ hidden: !open }), children });
}
var TabSetRenderer = ({ node }) => {
  const tabs = selectAll("tabItem", node).map((tab) => ({
    title: tab.title,
    id: tab.key,
    sync: tab.sync
  }));
  return (0, import_jsx_runtime32.jsx)(TabSet, { tabs, children: (0, import_jsx_runtime32.jsx)(MyST, { ast: node.children }) });
};
var TabItemRenderer = ({ node }) => {
  return (0, import_jsx_runtime32.jsx)(TabItem, { id: node.key, children: (0, import_jsx_runtime32.jsx)(MyST, { ast: node.children }) });
};
var TAB_RENDERERS = {
  tabSet: TabSetRenderer,
  tabItem: TabItemRenderer
};
var tabs_default = TAB_RENDERERS;

// ../../packages/myst-to-react/dist/extensions/chemicalFormula.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
function parseFormula(formula) {
  return [...formula !== null && formula !== void 0 ? formula : ""].reduce((acc, current) => {
    const last2 = acc.pop();
    const letter = current === "+" ? "\u207A" : current === "-" ? "\u207B" : current;
    const isNumber = letter.match(/[0-9]/);
    const lastIsNumber = last2 === null || last2 === void 0 ? void 0 : last2.match(/[0-9]/);
    if (isNumber) {
      if (lastIsNumber) {
        return [...acc, `${last2 !== null && last2 !== void 0 ? last2 : ""}${letter}`];
      }
      return [...acc, last2, letter].filter((v2) => !!v2);
    }
    if (lastIsNumber) {
      return [...acc, last2, letter].filter((v2) => !!v2);
    }
    return [...acc, `${last2 !== null && last2 !== void 0 ? last2 : ""}${letter}`];
  }, []);
}
var ChemicalFormula = ({ node }) => {
  const parts = parseFormula(node.value);
  return (0, import_jsx_runtime33.jsx)("span", { className: "text-inherit", "aria-roledescription": "Chemical Formula", children: parts.map((letter, index2) => {
    if (letter.match(/[0-9]/))
      return (0, import_jsx_runtime33.jsx)("sub", { children: letter }, index2);
    return (0, import_jsx_runtime33.jsx)("span", { children: letter }, index2);
  }) });
};
var CHEM_RENDERERS = {
  chemicalFormula: ChemicalFormula
};
var chemicalFormula_default = CHEM_RENDERERS;

// ../../packages/myst-to-react/dist/extensions/siunits.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var SIUnits = ({ node }) => {
  var _a;
  const space = node.number == null ? "" : " ";
  const title = `${(_a = node.number) !== null && _a !== void 0 ? _a : ""}${space}${node.alt}`;
  return (0, import_jsx_runtime34.jsx)("span", { title, children: node.value });
};
var SI_RENDERERS = {
  si: SIUnits
};
var siunits_default = SI_RENDERERS;

// ../../packages/myst-to-react/dist/extensions/index.js
var EXT_RENDERERS = Object.assign(Object.assign({}, chemicalFormula_default), siunits_default);
var extensions_default = EXT_RENDERERS;

// ../../packages/myst-to-react/dist/inlineExpression.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var InlineExpression = ({ node }) => {
  var _a, _b, _c;
  if (!node.result) {
    return (0, import_jsx_runtime35.jsx)(InlineError, { value: `Unexecuted inline expression for: ${node.value}` });
  }
  if (((_a = node.result) === null || _a === void 0 ? void 0 : _a.status) !== "ok") {
    return (0, import_jsx_runtime35.jsx)(InlineError, { value: `${(_b = node.result) === null || _b === void 0 ? void 0 : _b.ename}: ${(_c = node.result) === null || _c === void 0 ? void 0 : _c.evalue}` });
  }
  return (0, import_jsx_runtime35.jsx)(Tooltip, { title: (0, import_jsx_runtime35.jsx)("code", { children: node.value }), children: (0, import_jsx_runtime35.jsx)("span", { className: "border-b border-dotted cursor-help", children: (0, import_jsx_runtime35.jsx)(MyST, { ast: node.children }) }) });
};
var INLINE_EXPRESSION_RENDERERS = {
  inlineExpression: InlineExpression
};
var inlineExpression_default = INLINE_EXPRESSION_RENDERERS;

// ../../packages/myst-to-react/dist/proof.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_classnames13 = __toESM(require_classnames(), 1);
var ProofKind;
(function(ProofKind2) {
  ProofKind2["proof"] = "proof";
  ProofKind2["axiom"] = "axiom";
  ProofKind2["lemma"] = "lemma";
  ProofKind2["definition"] = "definition";
  ProofKind2["criterion"] = "criterion";
  ProofKind2["remark"] = "remark";
  ProofKind2["conjecture"] = "conjecture";
  ProofKind2["corollary"] = "corollary";
  ProofKind2["algorithm"] = "algorithm";
  ProofKind2["example"] = "example";
  ProofKind2["property"] = "property";
  ProofKind2["observation"] = "observation";
  ProofKind2["proposition"] = "proposition";
  ProofKind2["assumption"] = "assumption";
  ProofKind2["theorem"] = "theorem";
})(ProofKind || (ProofKind = {}));
function getClasses2(className) {
  var _a;
  const classes = (_a = className === null || className === void 0 ? void 0 : className.split(" ").map((s7) => s7.trim().toLowerCase()).filter((s7) => !!s7)) !== null && _a !== void 0 ? _a : [];
  return [...new Set(classes)];
}
function capitalize(kind) {
  if (!kind)
    return "";
  return kind.slice(0, 1).toUpperCase() + kind.slice(1);
}
function getColor({ kind }) {
  switch (kind) {
    case ProofKind.proof:
    case ProofKind.algorithm:
      return { color: "gray" };
    case ProofKind.lemma:
    case ProofKind.conjecture:
    case ProofKind.theorem:
      return { color: "purple" };
    case ProofKind.observation:
    case ProofKind.assumption:
    case ProofKind.axiom:
      return { color: "yellow" };
    case ProofKind.criterion:
    case ProofKind.corollary:
    case ProofKind.property:
      return { color: "orange" };
    case ProofKind.example:
      return { color: "green" };
    case ProofKind.remark:
      return { color: "red" };
    case ProofKind.definition:
    case ProofKind.proposition:
    default:
      return { color: "blue" };
  }
}
var WrapperElement2 = ({ id, dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime36.jsx)("details", { id, className, children });
  return (0, import_jsx_runtime36.jsx)("aside", { id, className, children });
};
var HeaderElement2 = ({ dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime36.jsx)("summary", { className, children });
  return (0, import_jsx_runtime36.jsx)("div", { className, children });
};
var iconClass3 = "inline-block pl-2 mr-2 self-center flex-none";
function Proof({ title, kind, color: color2, dropdown, children, identifier, enumerator }) {
  return (0, import_jsx_runtime36.jsxs)(WrapperElement2, { id: identifier, dropdown, className: (0, import_classnames13.default)("my-5 shadow dark:bg-stone-800 overflow-hidden", "dark:border-l-4 border-slate-400", {
    "dark:border-gray-500/60": !color2 || color2 === "gray",
    "dark:border-blue-500/60": color2 === "blue",
    "dark:border-green-500/60": color2 === "green",
    "dark:border-amber-500/70": color2 === "yellow",
    "dark:border-orange-500/60": color2 === "orange",
    "dark:border-red-500/60": color2 === "red",
    "dark:border-purple-500/60": color2 === "purple"
  }), children: [(0, import_jsx_runtime36.jsxs)(HeaderElement2, { dropdown, className: (0, import_classnames13.default)("m-0 font-medium py-2 flex min-w-0", "text-md", "border-y dark:border-y-0", {
    "bg-gray-50/80 dark:bg-slate-900": !color2 || color2 === "gray",
    "bg-blue-50/80 dark:bg-slate-900": color2 === "blue",
    "bg-green-50/80 dark:bg-slate-900": color2 === "green",
    "bg-amber-50/80 dark:bg-slate-900": color2 === "yellow",
    "bg-orange-50/80 dark:bg-slate-900": color2 === "orange",
    "bg-red-50/80 dark:bg-slate-900": color2 === "red",
    "bg-purple-50/80 dark:bg-slate-900": color2 === "purple",
    "cursor-pointer hover:shadow-[inset_0_0_0px_30px_#00000003] dark:hover:shadow-[inset_0_0_0px_30px_#FFFFFF03]": dropdown
  }), children: [(0, import_jsx_runtime36.jsxs)("div", { className: (0, import_classnames13.default)("text-neutral-900 dark:text-white grow self-center overflow-hidden break-words", "ml-4"), children: [(0, import_jsx_runtime36.jsxs)(HashLink, { id: identifier, kind: capitalize(kind), children: [capitalize(kind), " ", enumerator] }), " ", title && (0, import_jsx_runtime36.jsxs)(import_jsx_runtime36.Fragment, { children: ["(", title, ")"] })] }), dropdown && (0, import_jsx_runtime36.jsx)("div", { className: "self-center flex-none text-sm font-thin text-neutral-700 dark:text-neutral-200", children: (0, import_jsx_runtime36.jsx)(ChevronRightIcon_default, { width: "1.5rem", height: "1.5rem", className: (0, import_classnames13.default)(iconClass3, "transition-transform details-toggle") }) })] }), (0, import_jsx_runtime36.jsx)("div", { className: (0, import_classnames13.default)("px-4", { "details-body": dropdown }), children })] });
}
var ProofRenderer = ({ node }) => {
  const [title, ...rest2] = node.children;
  const classes = getClasses2(node.class);
  const { color: color2 } = getColor({ kind: node.kind, classes });
  const isDropdown = classes.includes("dropdown");
  const useTitle = (title === null || title === void 0 ? void 0 : title.type) === "admonitionTitle";
  return (0, import_jsx_runtime36.jsx)(Proof, { identifier: node.html_id, title: useTitle ? (0, import_jsx_runtime36.jsx)(MyST, { ast: [title] }) : void 0, kind: node.kind, enumerator: node.enumerator, color: color2, dropdown: isDropdown, children: useTitle ? (0, import_jsx_runtime36.jsx)(MyST, { ast: rest2 }) : (0, import_jsx_runtime36.jsx)(MyST, { ast: node.children }) });
};
var PROOF_RENDERERS = {
  proof: ProofRenderer
};
var proof_default = PROOF_RENDERERS;

// ../../packages/myst-to-react/dist/exercise.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var import_classnames14 = __toESM(require_classnames(), 1);
function getClasses3(className) {
  var _a;
  const classes = (_a = className === null || className === void 0 ? void 0 : className.split(" ").map((s7) => s7.trim().toLowerCase()).filter((s7) => !!s7)) !== null && _a !== void 0 ? _a : [];
  return [...new Set(classes)];
}
function getColor2({ classes = [] }, defaultColor = "blue") {
  if (classes.includes("gray"))
    return { color: "gray" };
  if (classes.includes("purple"))
    return { color: "purple" };
  if (classes.includes("yellow"))
    return { color: "yellow" };
  if (classes.includes("orange"))
    return { color: "orange" };
  if (classes.includes("green"))
    return { color: "green" };
  if (classes.includes("red"))
    return { color: "red" };
  if (classes.includes("blue"))
    return { color: "blue" };
  return { color: defaultColor };
}
var WrapperElement3 = ({ id, dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime37.jsx)("details", { id, className, children });
  return (0, import_jsx_runtime37.jsx)("aside", { id, className, children });
};
var HeaderElement3 = ({ dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime37.jsx)("summary", { className, children });
  return (0, import_jsx_runtime37.jsx)("div", { className, children });
};
var iconClass4 = "inline-block pl-2 mr-2 self-center flex-none";
function Callout({ title, color: color2, dropdown, children, identifier, Icon }) {
  return (0, import_jsx_runtime37.jsxs)(WrapperElement3, { id: identifier, dropdown, className: (0, import_classnames14.default)("my-5 shadow dark:bg-stone-800 overflow-hidden", "dark:border-l-4 border-slate-400", {
    "dark:border-gray-500/60": !color2 || color2 === "gray",
    "dark:border-blue-500/60": color2 === "blue",
    "dark:border-green-500/60": color2 === "green",
    "dark:border-amber-500/70": color2 === "yellow",
    "dark:border-orange-500/60": color2 === "orange",
    "dark:border-red-500/60": color2 === "red",
    "dark:border-purple-500/60": color2 === "purple"
  }), children: [(0, import_jsx_runtime37.jsxs)(HeaderElement3, { dropdown, className: (0, import_classnames14.default)("m-0 font-medium py-2 flex min-w-0", "text-md", "border-y dark:border-y-0", {
    "bg-gray-50/80 dark:bg-slate-900": !color2 || color2 === "gray",
    "bg-blue-50/80 dark:bg-slate-900": color2 === "blue",
    "bg-green-50/80 dark:bg-slate-900": color2 === "green",
    "bg-amber-50/80 dark:bg-slate-900": color2 === "yellow",
    "bg-orange-50/80 dark:bg-slate-900": color2 === "orange",
    "bg-red-50/80 dark:bg-slate-900": color2 === "red",
    "bg-purple-50/80 dark:bg-slate-900": color2 === "purple",
    "cursor-pointer hover:shadow-[inset_0_0_0px_30px_#00000003] dark:hover:shadow-[inset_0_0_0px_30px_#FFFFFF03]": dropdown
  }), children: [Icon && (0, import_jsx_runtime37.jsx)(Icon, { width: "2rem", height: "2rem", className: (0, import_classnames14.default)("inline-block pl-2 mr-2 self-center flex-none", (0, import_classnames14.default)({
    "text-gray-600": !color2 || color2 === "gray",
    "text-blue-600": color2 === "blue",
    "text-green-600": color2 === "green",
    "text-amber-600": color2 === "yellow",
    "text-orange-600": color2 === "orange",
    "text-red-600": color2 === "red",
    "text-purple-600": color2 === "purple"
  })) }), (0, import_jsx_runtime37.jsx)("div", { className: (0, import_classnames14.default)(
    "text-neutral-900 dark:text-white grow self-center overflow-hidden break-words",
    { "ml-4": !Icon },
    // No icon!
    "group"
  ), children: title }), dropdown && (0, import_jsx_runtime37.jsx)("div", { className: "self-center flex-none text-sm font-thin text-neutral-700 dark:text-neutral-200", children: (0, import_jsx_runtime37.jsx)(ChevronRightIcon_default, { width: "1.5rem", height: "1.5rem", className: (0, import_classnames14.default)(iconClass4, "transition-transform details-toggle") }) })] }), (0, import_jsx_runtime37.jsx)("div", { className: (0, import_classnames14.default)("px-4", { "details-body": dropdown }), children })] });
}
var ExerciseRenderer = ({ node }) => {
  var _a, _b, _c;
  if (node.hidden)
    return null;
  const [title, ...rest2] = (_a = node.children) !== null && _a !== void 0 ? _a : [];
  const classes = getClasses3(node.class);
  const { color: color2 } = getColor2({ classes });
  const isDropdown = classes.includes("dropdown");
  const useTitle = ((_c = (_b = node.children) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) === "admonitionTitle";
  const identifier = node.html_id;
  const enumerator = node.enumerator;
  const titleNode = (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [(0, import_jsx_runtime37.jsxs)(HashLink, { id: identifier, kind: "Exercise", children: [node.gate === "start" && "Start of ", node.gate === "end" && "End of ", "Exercise", enumerator != null && (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [" ", enumerator] })] }), useTitle && (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [" ", "(", (0, import_jsx_runtime37.jsx)(MyST, { ast: [title] }), ")"] })] });
  return (0, import_jsx_runtime37.jsx)(Callout, { identifier, title: titleNode, color: color2, dropdown: isDropdown, children: useTitle ? (0, import_jsx_runtime37.jsx)(MyST, { ast: rest2 }) : (0, import_jsx_runtime37.jsx)(MyST, { ast: node.children }) });
};
var SolutionRenderer = ({ node }) => {
  var _a, _b, _c;
  if (node.hidden)
    return null;
  const [title, ...rest2] = (_a = node.children) !== null && _a !== void 0 ? _a : [];
  const classes = getClasses3(node.class);
  const { color: color2 } = getColor2({ classes }, "gray");
  const isDropdown = classes.includes("dropdown");
  const useTitle = ((_c = (_b = node.children) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) === "admonitionTitle";
  const identifier = node.html_id;
  const titleNode = (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [node.gate === "start" && "Start of ", node.gate === "end" && "End of ", (0, import_jsx_runtime37.jsx)(MyST, { ast: [title] }), (0, import_jsx_runtime37.jsx)(HashLink, { id: identifier, kind: "Solution", hover: true, hideInPopup: true, children: " #" })] });
  return (0, import_jsx_runtime37.jsx)(Callout, { identifier, title: useTitle ? titleNode : void 0, color: color2, dropdown: isDropdown, children: useTitle ? (0, import_jsx_runtime37.jsx)(MyST, { ast: rest2 }) : (0, import_jsx_runtime37.jsx)(MyST, { ast: node.children }) });
};
var EXERCISE_RENDERERS = {
  exercise: ExerciseRenderer,
  solution: SolutionRenderer
};
var exercise_default = EXERCISE_RENDERERS;

// ../../packages/myst-to-react/dist/unknown.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var UnknownDirective = ({ node }) => {
  const titleNode = (0, import_jsx_runtime38.jsxs)(import_jsx_runtime38.Fragment, { children: [(0, import_jsx_runtime38.jsx)("code", { children: node.name }), " - Unknown Directive"] });
  return (0, import_jsx_runtime38.jsx)(Callout, { title: titleNode, color: "red", dropdown: true, Icon: ExclamationTriangleIcon_default, children: (0, import_jsx_runtime38.jsx)("pre", { children: node.value }) });
};
var UNKNOWN_MYST_RENDERERS = {
  mystDirective: UnknownDirective
};
var unknown_default = UNKNOWN_MYST_RENDERERS;

// ../../packages/myst-to-react/dist/index.js
var DEFAULT_RENDERERS = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, basic_default), unknown_default), image_default), links_default), code_default), math_default), cite_default), tabs_default), iframe_default), footnotes_default), admonitions_default), reactive_default), heading_default), crossReference_default), dropdown_default), card_default), grid_default), inlineExpression_default), extensions_default), proof_default), exercise_default);

// ../../packages/site/src/components/ContentBlocks.tsx
var import_classnames20 = __toESM(require_classnames(), 1);

// ../../packages/jupyter/dist/embed.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);

// ../../packages/jupyter/dist/decoration.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var import_react46 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/execute/hooks.js
var import_react43 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/execute/provider.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react41 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/execute/actions.js
function isNavigatePayload(payload) {
  const maybePayload = payload;
  return typeof maybePayload.slug === "string" && typeof maybePayload.location === "string" && typeof maybePayload.mdast === "object" && Array.isArray(maybePayload.dependencies) && Array.isArray(maybePayload.computables);
}
function isSlugPayload(payload) {
  return typeof payload.slug === "string";
}
function isBuildStatusPayload(payload) {
  return typeof payload.status === "string" && isSlugPayload(payload);
}
function isAddMdastPayload(payload) {
  const maybePayload = payload;
  return typeof maybePayload.slug === "string" && typeof maybePayload.mdast === "object";
}
function isAddNotebookPayload(payload) {
  const maybePayload = payload;
  return typeof maybePayload.pageSlug === "string" && typeof maybePayload.notebookSlug === "string" && typeof maybePayload.notebook === "object" && typeof maybePayload.rendermime === "object";
}
function isAddSessionPayload(payload) {
  const maybePayload = payload;
  return typeof maybePayload.pageSlug === "string" && typeof maybePayload.notebookSlug === "string" && typeof maybePayload.session === "object";
}

// ../../packages/jupyter/dist/execute/reducer.js
var __rest4 = function(s7, e4) {
  var t10 = {};
  for (var p3 in s7)
    if (Object.prototype.hasOwnProperty.call(s7, p3) && e4.indexOf(p3) < 0)
      t10[p3] = s7[p3];
  if (s7 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i5 = 0, p3 = Object.getOwnPropertySymbols(s7); i5 < p3.length; i5++) {
      if (e4.indexOf(p3[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s7, p3[i5]))
        t10[p3[i5]] = s7[p3[i5]];
    }
  return t10;
};
function reducer(state, action) {
  var _a;
  switch (action.type) {
    case "NAVIGATE": {
      if (!isNavigatePayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid NAVIGATE payload");
      }
      const { kind, slug, location: location2, mdast, dependencies, computables } = action.payload;
      if (state.pages[slug])
        return state;
      return Object.assign(Object.assign({}, state), { mdast: Object.assign(Object.assign({}, state.mdast), { [slug]: { root: mdast } }), pages: Object.assign(Object.assign({}, state.pages), { [slug]: {
        kind,
        slug,
        location: location2,
        dependencies,
        computables,
        computable: computables.length > 0 || kind === SourceFileKind.Notebook,
        ready: false,
        scopes: {}
      } }) });
    }
    case "ADD_MDAST": {
      if (!isAddMdastPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid ADD_MDAST payload");
      }
      const { slug, mdast } = action.payload;
      if (state.mdast[slug])
        return state;
      return Object.assign(Object.assign({}, state), { mdast: Object.assign(Object.assign({}, state.mdast), { [slug]: { root: mdast } }) });
    }
    case "REQUEST_BUILD": {
      if (!isSlugPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid REQUEST_BUILD payload");
      }
      const { slug } = action.payload;
      if (!!state.builds[slug] && state.builds[slug].status === "pending")
        return state;
      return Object.assign(Object.assign({}, state), { builds: Object.assign(Object.assign({}, state.builds), { [slug]: {
        status: "pending"
      } }) });
    }
    case "BUILD_STATUS": {
      if (!isBuildStatusPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid BUILD_STATUS payload");
      }
      const { slug } = action.payload;
      if (!state.builds[slug]) {
        console.error(state, action.payload);
        throw new Error("Trying to set build status when there is no build state");
      }
      if (state.builds[slug].status === action.payload.status)
        return state;
      return Object.assign(Object.assign({}, state), { builds: Object.assign(Object.assign({}, state.builds), { [slug]: Object.assign(Object.assign({}, state.builds[slug]), { status: action.payload.status }) }) });
    }
    case "CLEAR_BUILD": {
      if (!isSlugPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid CLEAR_BUILD payload");
      }
      const { slug } = action.payload;
      if (!state.builds[slug])
        return state;
      const _b = state.builds, _c = slug, _5 = _b[_c], builds = __rest4(_b, [typeof _c === "symbol" ? _c : _c + ""]);
      return Object.assign(Object.assign({}, state), { builds });
    }
    case "SET_RENDERING_READY": {
      if (!isSlugPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid SET_READY payload");
      }
      const { slug } = action.payload;
      if (state.pages[slug].ready)
        return state;
      const _d = state.builds, _e = slug, _5 = _d[_e], builds = __rest4(_d, [typeof _e === "symbol" ? _e : _e + ""]);
      const newState = Object.assign(Object.assign({}, state), { builds, pages: Object.assign(Object.assign({}, state.pages), { [slug]: Object.assign(Object.assign({}, state.pages[slug]), { ready: true }) }) });
      return newState;
    }
    case "ADD_NOTEBOOK": {
      if (!isAddNotebookPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid ADD_NOTEBOOK payload");
      }
      const { pageSlug, notebookSlug, notebook, rendermime } = action.payload;
      if (!state.pages[pageSlug]) {
        console.error(state, action.payload);
        throw new Error("Trying to add notebook when there is no rendering state");
      }
      if (state.pages[pageSlug].scopes[notebookSlug]) {
        console.warn("Trying to add notebook scope when rendering already has one", action.payload);
        return state;
      }
      return Object.assign(Object.assign({}, state), { pages: Object.assign(Object.assign({}, state.pages), { [pageSlug]: Object.assign(Object.assign({}, state.pages[pageSlug]), { scopes: Object.assign(Object.assign({}, state.pages[pageSlug].scopes), { [notebookSlug]: {
        notebook,
        rendermime
      } }) }) }) });
    }
    case "ADD_SESSION": {
      if (!isAddSessionPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid ADD_SESSION payload");
      }
      const { pageSlug, notebookSlug, session } = action.payload;
      if (!state.pages[pageSlug]) {
        console.error(state, action.payload);
        throw new Error("Trying to add session when there is no rendering state");
      }
      if ((_a = state.pages[pageSlug].scopes[notebookSlug]) === null || _a === void 0 ? void 0 : _a.session) {
        console.warn("Trying to add session scope when rendering already has one", action.payload);
        return state;
      }
      return Object.assign(Object.assign({}, state), { pages: Object.assign(Object.assign({}, state.pages), { [pageSlug]: Object.assign(Object.assign({}, state.pages[pageSlug]), { scopes: Object.assign(Object.assign({}, state.pages[pageSlug].scopes), { [notebookSlug]: Object.assign(Object.assign({}, state.pages[pageSlug].scopes[notebookSlug]), { session }) }) }) }) });
    }
  }
  return state;
}

// ../../packages/jupyter/dist/execute/selectors.js
function selectNotebookForPage(state, pageSlug, notebookSlug) {
  var _a, _b;
  return (_b = (_a = state.pages[pageSlug]) === null || _a === void 0 ? void 0 : _a.scopes[notebookSlug]) === null || _b === void 0 ? void 0 : _b.notebook;
}
function selectIsComputable(state, slug) {
  var _a, _b;
  return (_b = (_a = state.pages[slug]) === null || _a === void 0 ? void 0 : _a.computable) !== null && _b !== void 0 ? _b : false;
}
function selectAreExecutionScopesBuilding(state, slug) {
  var _a;
  return !((_a = state.pages[slug]) === null || _a === void 0 ? void 0 : _a.ready) && !!state.builds[slug];
}
function selectExecutionScopeStatus(state, slug) {
  var _a, _b, _c;
  return ((_a = state.pages[slug]) === null || _a === void 0 ? void 0 : _a.ready) ? "ready" : (_c = (_b = state.builds[slug]) === null || _b === void 0 ? void 0 : _b.status) !== null && _c !== void 0 ? _c : "unknown";
}
function selectDependenciesToFetch(state) {
  return Object.entries(state.builds).filter(([, { status }]) => status === "fetching").reduce((targets, [slug]) => [
    ...targets,
    ...state.pages[slug].dependencies.filter((d6) => {
      var _a;
      return !state.mdast[(_a = d6.slug) !== null && _a !== void 0 ? _a : d6.url];
    }).map((d6) => {
      var _a;
      return {
        slug: (_a = d6.slug) !== null && _a !== void 0 ? _a : d6.url,
        url: d6.url
      };
    })
  ], []);
}
function makeSelectScopeEventStatus(statusName) {
  return (state) => {
    return Object.entries(state.builds).filter(([, { status }]) => status === statusName).reduce((all, [slug]) => {
      const targets = [];
      if (state.pages[slug].kind === SourceFileKind.Notebook)
        targets.push({
          pageSlug: slug,
          notebookSlug: slug,
          location: state.pages[slug].location
        });
      targets.push(...state.pages[slug].dependencies.map((d6) => {
        var _a;
        return {
          pageSlug: slug,
          notebookSlug: (_a = d6.slug) !== null && _a !== void 0 ? _a : d6.url,
          location: d6.location
        };
      }));
      return [...all, ...targets];
    }, []);
  };
}
var selectScopeNotebooksToBuild = makeSelectScopeEventStatus("build-notebooks");
var selectSessionsToStart = makeSelectScopeEventStatus("start-session");
function selectAreAllDependenciesReady(state, slug) {
  var _a;
  return (_a = state.pages[slug]) === null || _a === void 0 ? void 0 : _a.dependencies.every((dep) => {
    var _a2;
    return !!state.mdast[(_a2 = dep.slug) !== null && _a2 !== void 0 ? _a2 : dep.url];
  });
}
function selectAreAllNotebookScopesBuilt(state, slug) {
  const rendering = state.pages[slug];
  return rendering === null || rendering === void 0 ? void 0 : rendering.dependencies.every((dep) => {
    var _a;
    return !!rendering.scopes[(_a = dep.slug) !== null && _a !== void 0 ? _a : dep.url];
  });
}
function selectAreAllSessionsStarted(state, slug) {
  const rendering = state.pages[slug];
  return rendering === null || rendering === void 0 ? void 0 : rendering.dependencies.every((dep) => {
    var _a, _b;
    return !!((_b = rendering.scopes[(_a = dep.slug) !== null && _a !== void 0 ? _a : dep.url]) === null || _b === void 0 ? void 0 : _b.session);
  });
}

// ../../packages/jupyter/dist/execute/leaf.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react40 = __toESM(require_react(), 1);
var import_thebe_react = __toESM(require_dist3(), 1);

// ../../packages/jupyter/dist/execute/utils.js
function executableNodesFromBlock(block) {
  if (!block || block.type !== "block")
    return;
  let target = block;
  if (block.children && block.children.length === 1 && block.children[0].type === "container") {
    target = block.children[0];
  }
  if (target.children && target.children.length >= 2 && target.children[0].type === "code") {
    return { codeCell: target.children[0], output: target.children[1] };
  }
}
function notebookFromMdast(core2, config, pageSlug, notebookSlug, mdast, idkmap, rendermime) {
  const notebook = new core2.ThebeNotebook(notebookSlug, config, rendermime);
  notebook.cells = mdast.children.map((block) => {
    var _a, _b, _c;
    if (block.type !== "block")
      console.warn(`Unexpected block type ${block.type}`);
    const executableNodes = executableNodesFromBlock(block);
    if (executableNodes) {
      const { codeCell, output } = executableNodes;
      const target = {
        pageSlug,
        notebookSlug,
        cellId: block.key
      };
      idkmap[block.key] = target;
      idkmap[output.id] = target;
      if (block.identifier)
        idkmap[block.identifier] = target;
      if (codeCell.identifier)
        idkmap[codeCell.identifier] = target;
      if (output.identifier)
        idkmap[output.identifier] = target;
      return new core2.ThebeCodeCell(target.cellId, notebook.id, (_a = codeCell.value) !== null && _a !== void 0 ? _a : "", config, (_b = block.data) !== null && _b !== void 0 ? _b : {}, notebook.rendermime);
    } else {
      const cell = new core2.ThebeMarkdownCell(block.key, notebook.id, block.children.reduce((acc, child) => {
        var _a2;
        return acc + "\n" + ((_a2 = child.value) !== null && _a2 !== void 0 ? _a2 : "");
      }, ""), (_c = block.data) !== null && _c !== void 0 ? _c : {}, notebook.rendermime);
      return cell;
    }
  });
  return notebook;
}

// ../../packages/jupyter/dist/plotly.js
var import_react39 = __toESM(require_react(), 1);
function useLoadPlotly() {
  const [plotly, setPlotly] = (0, import_react39.useState)();
  (0, import_react39.useEffect)(() => {
    if (plotly)
      return;
    import("/build/_shared/plotly-renderer-VEGWEDS5.js").then((module2) => {
      console.debug("Jupyter: Adding plotly renderer factory to rendermime registry", {
        module: module2
      });
      setPlotly(module2);
    });
  }, [plotly]);
  return { plotly };
}
var PLOTLY_MIMETYPE = "application/vnd.plotly.v1+json";
function isPlotly(outputs) {
  return outputs.some((output) => {
    var _a;
    return Object.keys((_a = output.data) !== null && _a !== void 0 ? _a : []).includes(PLOTLY_MIMETYPE);
  });
}
function usePlotlyPassively(rendermime, outputs) {
  const isPlotlyOutput = isPlotly(outputs);
  const [loaded, setLoaded] = (0, import_react39.useState)(!isPlotlyOutput);
  (0, import_react39.useEffect)(() => {
    if (loaded || !isPlotlyOutput)
      return;
    import("/build/_shared/plotly-renderer-VEGWEDS5.js").then((module2) => {
      console.debug("Jupyter: Adding plotly renderer factory to rendermime registry", {
        module: module2
      });
      rendermime.addFactory(module2.rendererFactory, 41);
      setLoaded(true);
    });
  }, [loaded, isPlotlyOutput]);
  return { loaded };
}

// ../../packages/jupyter/dist/execute/leaf.js
function MdastFetcher({ slug, url, dispatch }) {
  const { data, error } = useFetchMdast({ remote: true, dataUrl: `${url}.json` });
  (0, import_react40.useEffect)(() => {
    if (!data)
      return;
    dispatch({ type: "ADD_MDAST", payload: { slug, mdast: data.mdast } });
  }, [data]);
  if (error) {
    return (0, import_jsx_runtime39.jsxs)("div", { children: ["error: ", slug, error.message] });
  }
  return null;
}
function NotebookBuilder({ pageSlug, notebookSlug, idkmap, state, dispatch }) {
  var _a;
  const { core: core2 } = (0, import_thebe_react.useThebeLoader)();
  const { config } = (0, import_thebe_react.useThebeConfig)();
  const lock = (0, import_react40.useRef)(false);
  const scopeHasNotebook = !!((_a = state.pages[pageSlug]) === null || _a === void 0 ? void 0 : _a.scopes[notebookSlug]);
  const { plotly } = useLoadPlotly();
  (0, import_react40.useEffect)(() => {
    var _a2;
    if (!core2 || !config || !plotly || scopeHasNotebook || lock.current)
      return;
    lock.current = true;
    console.debug(`Jupyter: NotebookBuilder - ${notebookSlug} being added to scope ${pageSlug}`);
    const rendermime = core2 === null || core2 === void 0 ? void 0 : core2.makeRenderMimeRegistry(config === null || config === void 0 ? void 0 : config.mathjax);
    if (plotly)
      rendermime.addFactory(plotly.rendererFactory, 41);
    const notebook = notebookFromMdast(core2, config, pageSlug, notebookSlug, state.mdast[notebookSlug].root, idkmap, rendermime);
    const computables = (_a2 = state.pages[pageSlug]) === null || _a2 === void 0 ? void 0 : _a2.computables;
    computables === null || computables === void 0 ? void 0 : computables.forEach((c6) => {
      if (idkmap[c6.label]) {
        idkmap[c6.outputKey] = idkmap[c6.label];
        idkmap[c6.embedKey] = idkmap[c6.label];
      }
    });
    dispatch({
      type: "ADD_NOTEBOOK",
      payload: { pageSlug, notebookSlug, rendermime, notebook }
    });
  }, [core2, config, pageSlug, notebookSlug, scopeHasNotebook, lock, plotly]);
  const allNotebooksAreBuilt = plotly && selectAreAllNotebookScopesBuilt(state, pageSlug);
  (0, import_react40.useEffect)(() => {
    if (!allNotebooksAreBuilt)
      return;
    dispatch({ type: "BUILD_STATUS", payload: { slug: pageSlug, status: "wait-for-server" } });
  }, [allNotebooksAreBuilt]);
  return null;
}
function SessionStarter({ pageSlug, notebookSlug, location: location2, state, dispatch }) {
  var _a;
  const { core: core2 } = (0, import_thebe_react.useThebeLoader)();
  const { config, server } = (0, import_thebe_react.useThebeServer)();
  const lock = (0, import_react40.useRef)(false);
  const scope = (_a = state.pages[pageSlug]) === null || _a === void 0 ? void 0 : _a.scopes[notebookSlug];
  (0, import_react40.useEffect)(() => {
    if (!core2 || !server || (scope === null || scope === void 0 ? void 0 : scope.session) || lock.current)
      return;
    lock.current = true;
    console.debug(`Jupyter: Starting session for ${pageSlug}-${notebookSlug} at ${location2}`);
    if (location2 === void 0) {
      console.warn("Article/Notebook json is missing the location field, this maybe break notebook execution when located outside of the root folder");
    }
    server.listRunningSessions().then((sessions) => {
      var _a2;
      console.debug("Jupyter: running sessions", sessions);
      let path2 = `/${pageSlug}-${notebookSlug}.ipynb`;
      console.debug("session starter path:", path2);
      const match = (_a2 = location2 === null || location2 === void 0 ? void 0 : location2.match(/(.*)\/.*.ipynb$/)) !== null && _a2 !== void 0 ? _a2 : null;
      if (match) {
        console.debug("session starter match:", match);
        path2 = `${match[1]}/${pageSlug}-${notebookSlug}.ipynb`;
        console.debug("session starter path (modified):", path2);
      }
      const existing = sessions.find((s7) => s7.path === path2);
      if (existing) {
        console.debug(`session already exists for ${path2}`, existing);
        server.connectToExistingSession(existing, scope.rendermime).then((sesh) => {
          var _a3;
          if (sesh == null) {
            console.error(`Could not connect to session for ${path2}`);
            return;
          }
          console.debug(`reconnected to session for ${path2}`, sesh);
          console.debug("restarting session", sesh);
          (_a3 = sesh.kernel) === null || _a3 === void 0 ? void 0 : _a3.restart().then(() => {
            const notebook = selectNotebookForPage(state, pageSlug, notebookSlug);
            notebook.attachSession(sesh);
            dispatch({ type: "ADD_SESSION", payload: { pageSlug, notebookSlug, session: sesh } });
          });
        });
      } else {
        server.startNewSession(scope.rendermime, Object.assign(Object.assign({}, config === null || config === void 0 ? void 0 : config.kernels), { path: path2 })).then((sesh) => {
          if (sesh == null) {
            server === null || server === void 0 ? void 0 : server.getKernelSpecs().then((specs) => {
              console.error(`Could not start session for ${path2}`);
              console.debug(`Available kernels: ${Object.keys(specs)}`);
            });
            return;
          }
          console.debug(`session started for ${path2}`, sesh);
          const notebook = selectNotebookForPage(state, pageSlug, notebookSlug);
          notebook.attachSession(sesh);
          dispatch({ type: "ADD_SESSION", payload: { pageSlug, notebookSlug, session: sesh } });
        });
      }
    });
  }, [core2, config, scope, pageSlug, notebookSlug, lock]);
  const allSessionsAreStarted = selectAreAllSessionsStarted(state, pageSlug);
  (0, import_react40.useEffect)(() => {
    if (!allSessionsAreStarted)
      return;
    dispatch({
      type: "SET_RENDERING_READY",
      payload: { slug: pageSlug }
    });
  }, [allSessionsAreStarted]);
  return null;
}
function ServerMonitor({ state, dispatch }) {
  const { core: core2, load: load2, loading } = (0, import_thebe_react.useThebeLoader)();
  const { ready, error } = (0, import_thebe_react.useThebeServer)();
  (0, import_react40.useEffect)(() => {
    if (core2 || loading)
      return;
    load2();
  }, [core2, load2, loading]);
  (0, import_react40.useEffect)(() => {
    if (ready) {
      Object.entries(state.builds).forEach(([slug, { status }]) => {
        if (status === "wait-for-server") {
          dispatch({ type: "BUILD_STATUS", payload: { slug, status: "start-session" } });
        }
      });
    }
  }, [ready, state]);
  (0, import_react40.useEffect)(() => {
    if (!error)
      return;
  }, [error]);
  return null;
}

// ../../packages/jupyter/dist/execute/provider.js
var ExecuteScopeContext = import_react41.default.createContext(void 0);
function useScopeNavigate({ contents: { slug, location: location2, kind, mdast, dependencies }, state, dispatch }) {
  (0, import_react41.useEffect)(() => {
    if (state.pages[slug]) {
      console.debug(`Jupyter: ExecuteScopeProvider - ${slug} is already in scope`);
      return;
    }
    const computables = listComputables(mdast);
    dispatch({
      type: "NAVIGATE",
      payload: {
        kind,
        slug,
        location: location2 !== null && location2 !== void 0 ? location2 : kind === SourceFileKind.Notebook ? "/fallback.ipynb" : "/",
        mdast,
        dependencies: dependencies !== null && dependencies !== void 0 ? dependencies : [],
        computables
      }
    });
  }, [slug]);
}
function useExecutionScopeFetcher({ slug, state, dispatch }) {
  (0, import_react41.useEffect)(() => {
    if (!state.builds[slug])
      return;
    if (state.builds[slug].status === "pending") {
      dispatch({ type: "BUILD_STATUS", payload: { slug, status: "fetching" } });
    }
    if (state.builds[slug].status === "fetching") {
      if (selectAreAllDependenciesReady(state, slug)) {
        dispatch({ type: "BUILD_STATUS", payload: { slug, status: "build-notebooks" } });
      }
    }
  }, [state.builds, state.mdast]);
}
function listComputables(mdast) {
  return selectAll("container[kind=figure]:has(output), embed:has(output)", mdast).map((node) => {
    const { key, label, source } = node;
    const output = selectAll("output", node);
    return { embedKey: key, outputKey: output[0].key, label, source };
  });
}
function ExecuteScopeProvider({ children, enable, contents }) {
  var _a, _b;
  const computables = listComputables(contents.mdast);
  const fallbackLocation = contents.kind === SourceFileKind.Notebook ? "/fallback.ipynb" : "/";
  const initialState = {
    mdast: {
      [contents.slug]: { root: contents.mdast }
    },
    pages: {
      [contents.slug]: {
        computable: computables.length > 0 || contents.kind === SourceFileKind.Notebook,
        kind: contents.kind,
        slug: contents.slug,
        location: (_a = contents.location) !== null && _a !== void 0 ? _a : fallbackLocation,
        dependencies: (_b = contents.dependencies) !== null && _b !== void 0 ? _b : [],
        computables,
        ready: false,
        scopes: {}
      }
    },
    builds: {}
  };
  const [state, dispatch] = (0, import_react41.useReducer)(reducer, initialState);
  const idkmap = (0, import_react41.useRef)({});
  useScopeNavigate({ contents, state, dispatch });
  useExecutionScopeFetcher({ slug: contents.slug, state, dispatch });
  const fetchTargets = selectDependenciesToFetch(state);
  const notebookBuildTargets = selectScopeNotebooksToBuild(state);
  const sessionStartTargets = selectSessionsToStart(state);
  const memo = import_react41.default.useMemo(() => ({
    canCompute: enable,
    slug: contents.slug,
    location: contents.location,
    state,
    dispatch,
    idkmap: idkmap.current
  }), [state, contents.slug, enable]);
  if (typeof window !== "undefined") {
    window.executeScope = memo;
  }
  return (0, import_jsx_runtime40.jsxs)(ExecuteScopeContext.Provider, { value: memo, children: [(0, import_jsx_runtime40.jsxs)("div", { className: "hidden", children: [fetchTargets.length > 0 && (0, import_jsx_runtime40.jsx)("div", { className: "p-1 pl-4", children: fetchTargets.map(({ slug, url }) => (0, import_jsx_runtime40.jsx)(MdastFetcher, { slug, url, dispatch }, `fetch-${slug}`)) }), notebookBuildTargets.length > 0 && (0, import_jsx_runtime40.jsx)("div", { className: "p-1 pl-4", children: notebookBuildTargets.map(({ pageSlug, notebookSlug }) => (0, import_jsx_runtime40.jsx)(NotebookBuilder, { pageSlug, notebookSlug, idkmap: idkmap.current, state, dispatch }, `build-${pageSlug}-${notebookSlug}`)) }), sessionStartTargets.length > 0 && (0, import_jsx_runtime40.jsx)("div", { className: "p-1 pl-4", children: sessionStartTargets.map(({ pageSlug, notebookSlug, location: location2 }) => (0, import_jsx_runtime40.jsx)(SessionStarter, { pageSlug, notebookSlug, location: location2, state, dispatch }, `session-${pageSlug}-${notebookSlug}`)) })] }), (0, import_jsx_runtime40.jsx)(ServerMonitor, { state, dispatch }), children] });
}

// ../../packages/jupyter/dist/execute/busy.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react42 = __toESM(require_react(), 1);
var __rest5 = function(s7, e4) {
  var t10 = {};
  for (var p3 in s7)
    if (Object.prototype.hasOwnProperty.call(s7, p3) && e4.indexOf(p3) < 0)
      t10[p3] = s7[p3];
  if (s7 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i5 = 0, p3 = Object.getOwnPropertySymbols(s7); i5 < p3.length; i5++) {
      if (e4.indexOf(p3[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s7, p3[i5]))
        t10[p3[i5]] = s7[p3[i5]];
    }
  return t10;
};
var BusyScopeContext = import_react42.default.createContext(void 0);
function isSlugPayload2(payload) {
  return typeof payload.pageSlug === "string" && typeof payload.notebookSlug === "string" && typeof payload.kind === "string";
}
function isCellPayload(payload) {
  return isSlugPayload2(payload) && typeof payload.cellId === "string" && typeof payload.kind === "string";
}
function isNotebookPayload(payload) {
  return isSlugPayload2(payload) && Array.isArray(payload.cellIds) && payload.cellIds.every((id) => typeof id === "string") && typeof payload.kind === "string";
}
function isErrorPayload(payload) {
  var _a, _b;
  return typeof payload.pageSlug === "string" && typeof payload.notebookSlug === "string" && payload.errors === void 0 || ((_b = Array.isArray(payload.errors) && ((_a = payload.errors) === null || _a === void 0 ? void 0 : _a.every((error) => typeof error === "object"))) !== null && _b !== void 0 ? _b : false);
}
function reducer2(state, action) {
  var _a, _b, _c, _d, _e, _f, _g;
  switch (action.type) {
    case "SET_CELL_BUSY": {
      if (!isCellPayload(action.payload)) {
        console.error("SET_CELL_BUSY payload must be a cell payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, cellId, kind } = action.payload;
      if ((_b = (_a = state[kind][pageSlug]) === null || _a === void 0 ? void 0 : _a[notebookSlug]) === null || _b === void 0 ? void 0 : _b[cellId])
        return state;
      return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [pageSlug]: Object.assign(Object.assign({}, state[kind][pageSlug]), { [notebookSlug]: Object.assign(Object.assign({}, (_c = state[kind][pageSlug]) === null || _c === void 0 ? void 0 : _c[notebookSlug]), { [cellId]: true }) }) }) });
    }
    case "CLEAR_CELL_BUSY": {
      if (!isCellPayload(action.payload)) {
        console.error("CLEAR_CELL_BUSY payload must be a cell payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, cellId, kind } = action.payload;
      const _h = state[kind], _j = pageSlug, renderBusy = _h[_j], otherRenders = __rest5(_h, [typeof _j === "symbol" ? _j : _j + ""]);
      if (!renderBusy)
        return state;
      const _k = renderBusy, _l = notebookSlug, notebookBusy = _k[_l], otherNotebooks = __rest5(_k, [typeof _l === "symbol" ? _l : _l + ""]);
      if (!notebookBusy)
        return state;
      if (!notebookBusy[cellId])
        return state;
      const _m = notebookBusy, _o = cellId, cellBusy = _m[_o], otherCells = __rest5(_m, [typeof _o === "symbol" ? _o : _o + ""]);
      if (Object.keys(otherCells).length === 0 && Object.keys(otherNotebooks).length === 0) {
        return Object.assign(Object.assign({}, state), { [kind]: otherRenders });
      }
      if (Object.keys(otherCells).length === 0) {
        return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [pageSlug]: Object.assign({}, otherNotebooks) }) });
      }
      return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [action.payload.pageSlug]: Object.assign(Object.assign({}, otherNotebooks), { [notebookSlug]: Object.assign({}, otherCells) }) }) });
    }
    case "SET_NOTEBOOK_BUSY": {
      if (!isNotebookPayload(action.payload)) {
        console.error("SET_NOTEBOOK_BUSY payload must be a notebook payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, cellIds, kind } = action.payload;
      return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [pageSlug]: Object.assign(Object.assign({}, state[kind][pageSlug]), { [notebookSlug]: Object.assign(Object.assign({}, (_d = state[kind][pageSlug]) === null || _d === void 0 ? void 0 : _d[notebookSlug]), cellIds.reduce((acc, cellId) => Object.assign(Object.assign({}, acc), { [cellId]: true }), {})) }) }) });
    }
    case "CLEAR_NOTEBOOK_BUSY": {
      if (!isSlugPayload2(action.payload)) {
        console.error("CLEAR_NOTEBOOK_BUSY payload must be a notebook payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, kind } = action.payload;
      if (!state[kind][pageSlug])
        return state;
      if (!((_e = state[kind][pageSlug]) === null || _e === void 0 ? void 0 : _e[notebookSlug]))
        return state;
      const _p = state[kind][pageSlug], _q = notebookSlug, notebookBusy = _p[_q], otherNotebooks = __rest5(_p, [typeof _q === "symbol" ? _q : _q + ""]);
      if (Object.keys(otherNotebooks).length === 0) {
        const _r = state[kind], _s = pageSlug, renderBusy = _r[_s], otherRenders = __rest5(_r, [typeof _s === "symbol" ? _s : _s + ""]);
        return Object.assign(Object.assign({}, state), { [kind]: otherRenders });
      }
      return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [pageSlug]: Object.assign({}, otherNotebooks) }) });
    }
    case "SET_ERROR": {
      if (!isErrorPayload(action.payload)) {
        console.error("SET_ERROR payload must be an error payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, errors } = action.payload;
      if (!errors) {
        console.error("SET_ERROR payload must have errors", action.payload);
        return state;
      }
      if (state.error[pageSlug])
        return state;
      if ((_f = state.error[pageSlug]) === null || _f === void 0 ? void 0 : _f[notebookSlug])
        return state;
      return Object.assign(Object.assign({}, state), { error: Object.assign(Object.assign({}, state.error), { [pageSlug]: Object.assign(Object.assign({}, state.error[pageSlug]), { [notebookSlug]: errors }) }) });
    }
    case "CLEAR_ERROR": {
      if (!isErrorPayload(action.payload)) {
        console.error("CLEAR_ERROR payload must be a error payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug } = action.payload;
      if (!state.error[pageSlug])
        return state;
      if (!((_g = state.error[pageSlug]) === null || _g === void 0 ? void 0 : _g[notebookSlug]))
        return state;
      const _t = state.error[pageSlug], _u = notebookSlug, notebookErrors = _t[_u], otherNotebooks = __rest5(_t, [typeof _u === "symbol" ? _u : _u + ""]);
      if (Object.keys(otherNotebooks).length > 0) {
        return Object.assign(Object.assign({}, state), { error: Object.assign(Object.assign({}, state.error), { [pageSlug]: Object.assign({}, otherNotebooks) }) });
      }
      const _v = state.error, _w = pageSlug, renderErrors = _v[_w], otherRenders = __rest5(_v, [typeof _w === "symbol" ? _w : _w + ""]);
      return Object.assign(Object.assign({}, state), { error: otherRenders });
    }
  }
  return state;
}
function BusyScopeProvider({ children }) {
  const [state, dispatch] = (0, import_react42.useReducer)(reducer2, { execute: {}, reset: {}, error: {} });
  const memo = import_react42.default.useMemo(() => ({ state, dispatch }), [state]);
  if (typeof window !== "undefined") {
    window.busyScopeState = memo.state;
  }
  return (0, import_jsx_runtime41.jsx)(BusyScopeContext.Provider, { value: memo, children });
}
function useBusyScope() {
  const context = import_react42.default.useContext(BusyScopeContext);
  if (context === void 0) {
    throw new Error("useBusyScope must be used within a BusyScopeProvider");
  }
  const { dispatch, state } = context;
  const cell = (0, import_react42.useCallback)((pageSlug, notebookSlug, cellId, kind) => selectCellIsBusy(state, pageSlug, notebookSlug, cellId, kind), [state]);
  const notebook = (0, import_react42.useCallback)((pageSlug, notebookSlug, kind) => selectNotebookIsBusy(state, pageSlug, notebookSlug, kind), [state]);
  const page = (0, import_react42.useCallback)((pageSlug, kind) => selectPageIsBusy(state, pageSlug, kind), [state]);
  const setCell = (0, import_react42.useCallback)((pageSlug, notebookSlug, cellId, kind) => {
    dispatch({ type: "SET_CELL_BUSY", payload: { pageSlug, notebookSlug, cellId, kind } });
  }, [dispatch]);
  const clearCell = (0, import_react42.useCallback)((pageSlug, notebookSlug, cellId, kind) => dispatch({ type: "CLEAR_CELL_BUSY", payload: { pageSlug, notebookSlug, cellId, kind } }), [dispatch]);
  const setNotebook = (0, import_react42.useCallback)((pageSlug, notebookSlug, cellIds, kind) => dispatch({ type: "SET_NOTEBOOK_BUSY", payload: { pageSlug, notebookSlug, cellIds, kind } }), [dispatch]);
  const clearNotebook = (0, import_react42.useCallback)((pageSlug, notebookSlug, kind) => dispatch({ type: "CLEAR_NOTEBOOK_BUSY", payload: { pageSlug, notebookSlug, kind } }), [dispatch]);
  const setError = (0, import_react42.useCallback)((pageSlug, notebookSlug, errors) => dispatch({ type: "SET_ERROR", payload: { pageSlug, notebookSlug, errors } }), [dispatch]);
  const clearError = (0, import_react42.useCallback)((pageSlug, notebookSlug) => dispatch({ type: "CLEAR_ERROR", payload: { pageSlug, notebookSlug } }), [dispatch]);
  return {
    cell,
    notebook,
    page,
    setCell,
    clearCell,
    setNotebook,
    clearNotebook,
    setError,
    clearError
  };
}
function useBusyErrors(pageSlug) {
  const context = import_react42.default.useContext(BusyScopeContext);
  if (context === void 0) {
    throw new Error("useBusyScope must be used within a BusyScopeProvider");
  }
  const { state, dispatch } = context;
  const clearErrors = () => {
    Object.keys(state.error[pageSlug]).forEach((notebookSlug) => {
      dispatch({ type: "CLEAR_ERROR", payload: { pageSlug, notebookSlug } });
    });
  };
  let items;
  if (Object.keys(state.error).length > 0 && state.error[pageSlug]) {
    items = Object.entries(state.error[pageSlug]).map(([notebookSlug, errors]) => ({
      pageSlug,
      notebookSlug,
      errors
    }));
  }
  return { items, clearErrors };
}
function selectCellIsBusy(state, pageSlug, notebookSlug, cellId, kind) {
  var _a, _b;
  return !!((_b = (_a = state[kind][pageSlug]) === null || _a === void 0 ? void 0 : _a[notebookSlug]) === null || _b === void 0 ? void 0 : _b[cellId]);
}
function selectNotebookIsBusy(state, pageSlug, notebookSlug, kind) {
  var _a;
  return !!((_a = state[kind][pageSlug]) === null || _a === void 0 ? void 0 : _a[notebookSlug]);
}
function selectPageIsBusy(state, pageSlug, kind) {
  return !!state[kind][pageSlug];
}

// ../../packages/jupyter/dist/execute/hooks.js
var import_thebe_react2 = __toESM(require_dist3(), 1);
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function useExecutionScope({ clearOutputsOnExecute = false } = {}) {
  var _a;
  const context = import_react43.default.useContext(ExecuteScopeContext);
  const { config } = (0, import_thebe_react2.useThebeConfig)();
  const busy = useBusyScope();
  if (context === void 0) {
    throw new Error("useExecuteScope must be used within a ExecuteScopeProvider");
  }
  const { state, dispatch } = context;
  const start = (0, import_react43.useCallback)((slug) => {
    console.debug(`Jupyter: Starting ${slug}`);
    dispatch({
      type: "REQUEST_BUILD",
      payload: {
        slug
      }
    });
  }, []);
  const execute = (slug) => {
    Object.entries(state.pages[slug].scopes).forEach(([notebookSlug, { notebook }]) => {
      busy.clearError(slug, notebookSlug);
      busy.setNotebook(slug, notebookSlug, notebook.code.map((c6) => c6.id), "execute");
    });
    if (clearOutputsOnExecute) {
      Object.values(state.pages[slug].scopes).forEach(({ notebook }) => {
        notebook.clear();
      });
    }
    setTimeout(() => __awaiter2(this, void 0, void 0, function* () {
      const handler = (_5, data) => {
        var _a2, _b;
        if (data.subject === "cell" && data.status === "idle") {
          const notebookSlug = (_a2 = data.object.notebookId) !== null && _a2 !== void 0 ? _a2 : "unknown";
          busy.clearCell(slug, notebookSlug, (_b = data.id) !== null && _b !== void 0 ? _b : "unknown", "execute");
        }
      };
      config === null || config === void 0 ? void 0 : config.events.on("status", handler);
      yield Promise.all(Object.entries(state.pages[slug].scopes).map(([, { notebook }]) => __awaiter2(this, void 0, void 0, function* () {
        const execReturns = yield notebook.executeAll(true);
        const errs = (0, import_thebe_react2.findErrors)(execReturns);
        if (errs != null) {
          console.error("errors", errs);
          busy.setError(slug, notebook.id, errs);
          busy.clearNotebook(slug, notebook.id, "execute");
        }
      })));
      config === null || config === void 0 ? void 0 : config.events.off("status", handler);
    }), 100);
  };
  const clearAll = (0, import_react43.useCallback)((pageSlug) => {
    var _a2;
    Object.entries((_a2 = state.pages[pageSlug]) === null || _a2 === void 0 ? void 0 : _a2.scopes).forEach(([, { notebook }]) => {
      notebook.clear();
    });
  }, [state]);
  const resetAll = (0, import_react43.useCallback)((pageSlug) => {
    var _a2;
    Object.entries((_a2 = state.pages[pageSlug]) === null || _a2 === void 0 ? void 0 : _a2.scopes).forEach(([notebookSlug, { notebook, session }]) => {
      busy.clearError(pageSlug, notebookSlug);
      busy.setNotebook(pageSlug, notebookSlug, notebook.code.map((c6) => c6.id), "reset");
      setTimeout(() => {
        var _a3;
        notebook.reset();
        (_a3 = session === null || session === void 0 ? void 0 : session.kernel) === null || _a3 === void 0 ? void 0 : _a3.restart().finally(() => {
          busy.clearNotebook(pageSlug, notebookSlug, "reset");
        });
      }, 300);
    });
  }, [state]);
  const ready = (_a = context.state.pages[context.slug]) === null || _a === void 0 ? void 0 : _a.ready;
  return Object.assign(Object.assign({}, context), { ready, start, clearAll, resetAll, execute });
}
function useNotebookExecution(id, clearOutputsOnExecute = false) {
  var _a, _b;
  const context = import_react43.default.useContext(ExecuteScopeContext);
  const { config } = (0, import_thebe_react2.useThebeConfig)();
  const busy = useBusyScope();
  if (context === void 0) {
    throw new Error("useNotebookExecution must be used within a ExecuteScopeProvider");
  }
  const { state, dispatch, idkmap } = context;
  const target = (_a = idkmap[id]) !== null && _a !== void 0 ? _a : {};
  const { pageSlug, notebookSlug, cellId } = target;
  const start = (0, import_react43.useCallback)(() => {
    dispatch({
      type: "REQUEST_BUILD",
      payload: {
        slug: context.slug
      }
    });
  }, [target]);
  let cell;
  let notebook;
  if (target && state.pages[pageSlug]) {
    notebook = selectNotebookForPage(state, pageSlug, notebookSlug);
    if (notebook)
      cell = notebook === null || notebook === void 0 ? void 0 : notebook.getCellById(cellId);
  }
  const execute = () => {
    const nb = selectNotebookForPage(state, pageSlug, notebookSlug);
    busy.clearError(pageSlug, notebookSlug);
    busy.setNotebook(pageSlug, notebookSlug, nb.code.map((c6) => c6.id), "execute");
    if (clearOutputsOnExecute)
      nb.clear();
    setTimeout(() => __awaiter2(this, void 0, void 0, function* () {
      const handler = (_5, data) => {
        var _a2;
        if (data.subject === "cell" && data.status === "idle") {
          busy.clearCell(pageSlug, notebookSlug, (_a2 = data.id) !== null && _a2 !== void 0 ? _a2 : "unknown", "execute");
        }
      };
      config === null || config === void 0 ? void 0 : config.events.on("status", handler);
      const execReturns = yield nb.executeAll(true);
      const errs = (0, import_thebe_react2.findErrors)(execReturns);
      if (errs != null) {
        console.error("an error occurred during notebook execution");
        busy.setError(pageSlug, notebookSlug, errs);
        busy.clearNotebook(pageSlug, notebookSlug, "execute");
      }
      config === null || config === void 0 ? void 0 : config.events.off("status", handler);
    }), 100);
  };
  const clear = (0, import_react43.useCallback)(() => {
    const nb = selectNotebookForPage(state, pageSlug, notebookSlug);
    nb.clear();
  }, [state]);
  const reset = (0, import_react43.useCallback)(() => {
    const nb = selectNotebookForPage(state, pageSlug, notebookSlug);
    busy.clearError(pageSlug, notebookSlug);
    busy.setNotebook(pageSlug, notebookSlug, nb.code.map((c6) => c6.id), "reset");
    setTimeout(() => {
      var _a2, _b2;
      nb.reset();
      (_b2 = (_a2 = nb.session) === null || _a2 === void 0 ? void 0 : _a2.kernel) === null || _b2 === void 0 ? void 0 : _b2.restart().finally(() => {
        busy.clearNotebook(pageSlug, notebookSlug, "reset");
      });
    }, 300);
  }, [state]);
  const ready = (_b = context.state.pages[context.slug]) === null || _b === void 0 ? void 0 : _b.ready;
  const notebookIsExecuting = busy.notebook(pageSlug, notebookSlug, "execute");
  const notebookIsResetting = busy.notebook(pageSlug, notebookSlug, "reset");
  const notebookIsBusy = notebookIsExecuting || notebookIsResetting;
  return Object.assign(Object.assign({}, context), {
    ready,
    start,
    clear,
    reset,
    execute,
    cellIsExecuting: cell ? busy.cell(pageSlug, notebookSlug, cell === null || cell === void 0 ? void 0 : cell.id, "execute") : false,
    notebookIsExecuting,
    notebookIsResetting,
    notebookIsBusy,
    executionCount: cell === null || cell === void 0 ? void 0 : cell.executionCount
  });
}
function useCellExecution(id, clearOutputsOnExecute = false) {
  var _a, _b, _c, _d;
  const busy = useBusyScope();
  const context = import_react43.default.useContext(ExecuteScopeContext);
  if (context === void 0) {
    throw new Error("useCellExecution must be used within a ExecuteScopeProvider");
  }
  const { state, idkmap } = context;
  const target = (_a = idkmap[id]) !== null && _a !== void 0 ? _a : {};
  const { pageSlug, notebookSlug, cellId } = target;
  let cell;
  let notebook;
  if (target && state.pages[pageSlug]) {
    notebook = selectNotebookForPage(state, pageSlug, notebookSlug);
    if (notebook)
      cell = notebook === null || notebook === void 0 ? void 0 : notebook.getCellById(cellId);
  }
  const ready = (_b = context.state.pages[context.slug]) === null || _b === void 0 ? void 0 : _b.ready;
  const kind = (_d = (_c = context.state.pages[context.slug]) === null || _c === void 0 ? void 0 : _c.kind) !== null && _d !== void 0 ? _d : SourceFileKind.Article;
  const execute = (0, import_react43.useCallback)(() => {
    if (!cell) {
      console.error("no cell found on execute", { pageSlug, notebookSlug, cellId });
      return;
    }
    busy.setCell(pageSlug, notebookSlug, cell.id, "execute");
    if (clearOutputsOnExecute)
      cell.clear();
    setTimeout(() => {
      if (!cell)
        throw new Error("no cell found on execute");
      cell.execute().then(() => {
        if (!cell)
          throw new Error("no cell found after execute");
        busy.clearCell(pageSlug, notebookSlug, cell === null || cell === void 0 ? void 0 : cell.id, "execute");
      });
    }, 100);
  }, [state, cell]);
  const clear = (0, import_react43.useCallback)(() => {
    if (!cell) {
      console.error("no cell found on clear", { pageSlug, notebookSlug, cellId });
      return;
    }
    cell.clear();
  }, [state, cell]);
  const notebookIsExecuting = busy.notebook(pageSlug, notebookSlug, "execute");
  const notebookIsResetting = busy.notebook(pageSlug, notebookSlug, "reset");
  const notebookIsBusy = notebookIsExecuting || notebookIsResetting;
  return {
    canCompute: context.canCompute,
    kind,
    ready,
    execute,
    clear,
    cellIsExecuting: cell ? busy.cell(pageSlug, notebookSlug, cell === null || cell === void 0 ? void 0 : cell.id, "execute") : false,
    notebookIsExecuting,
    notebookIsResetting,
    notebookIsBusy,
    cell
  };
}

// ../../packages/jupyter/dist/controls/ArticleCellControls.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_thebe_react3 = __toESM(require_dist3(), 1);

// ../../packages/jupyter/dist/controls/Buttons.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_classnames15 = __toESM(require_classnames(), 1);

// ../../packages/jupyter/dist/controls/Spinner.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
function Spinner({ size: size3 }) {
  return (0, import_jsx_runtime42.jsxs)("div", { role: "status", children: [(0, import_jsx_runtime42.jsxs)("svg", { "aria-hidden": "true", width: size3, height: size3, className: "mr-2 text-gray-200 animate-spin dark:text-gray-600 fill-green-600", viewBox: "0 0 100 101", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime42.jsx)("path", { d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z", fill: "currentColor" }), (0, import_jsx_runtime42.jsx)("path", { d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z", fill: "currentFill" })] }), (0, import_jsx_runtime42.jsx)("span", { className: "sr-only", children: "Loading..." })] });
}

// ../../node_modules/swr/immutable/dist/index.mjs
var immutable = (useSWRNext) => (key, fetcher6, config) => {
  config.revalidateOnFocus = false;
  config.revalidateIfStale = false;
  config.revalidateOnReconnect = false;
  return useSWRNext(key, fetcher6, config);
};
var useSWRImmutable = withMiddleware(useSWR, immutable);

// ../../packages/jupyter/dist/hooks.js
var import_react44 = __toESM(require_react(), 1);
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function fetcher5(url) {
  return __awaiter3(this, void 0, void 0, function* () {
    const resp = yield fetch(url);
    if (resp.status === 200) {
      const content = yield resp.text();
      if (url.endsWith(".json")) {
        try {
          const data = JSON.parse(content);
          const keys2 = Object.keys(data);
          if (keys2.length === 2 && keys2.includes("content") && keys2.includes("content_type")) {
            return data;
          }
        } catch (error) {
        }
      }
      return { content };
    }
    throw new Error(`Content returned with status ${resp.status}.`);
  });
}
function useLongContent(content, url) {
  if (typeof document === "undefined") {
    return url ? {} : { data: { content: content !== null && content !== void 0 ? content : "" } };
  }
  const { data, error } = useSWRImmutable(url || null, fetcher5);
  if (!url)
    return { data: { content: content !== null && content !== void 0 ? content : "" } };
  return { data, error };
}
var arrayFetcher = (...urls) => {
  return Promise.all(urls.map((url) => fetcher5(url[0])));
};
function shallowCloneOutputs(outputs) {
  return outputs.map((output) => {
    if ("data" in output && output.data) {
      const data = output.data;
      return Object.assign(Object.assign({}, output), { data: Object.entries(data).reduce((acc, [mimetype, payload]) => {
        return Object.assign(Object.assign({}, acc), { [mimetype]: Object.assign({}, payload) });
      }, {}) });
    }
    return Object.assign({}, output);
  });
}
function useFetchAnyTruncatedContent(outputs) {
  const itemsWithPaths = [];
  const updated = shallowCloneOutputs(outputs);
  walkOutputs(updated, (obj) => {
    if ("content_type" in obj && obj.content_type.startsWith("image/"))
      return;
    if (obj.path) {
      itemsWithPaths.push(obj);
    }
  });
  const { data, error } = useSWRImmutable(itemsWithPaths.map(({ path: path2 }) => path2), arrayFetcher);
  data === null || data === void 0 ? void 0 : data.forEach(({ content }, idx) => {
    const obj = itemsWithPaths[idx];
    if ("text" in obj) {
      obj.text = content;
    } else if ("traceback" in obj) {
      obj.traceback = content;
    } else {
      obj.content = content;
    }
    obj.path = void 0;
  });
  return {
    data: itemsWithPaths.length === 0 || data ? updated : void 0,
    error
  };
}

// ../../packages/jupyter/dist/controls/Buttons.js
function SpinnerStatusButton({ ready, busy, modified, onClick }) {
  let title = "Enable compute to make this figure interactive";
  if (ready) {
    title = modified ? "The figure has been modified" : "The figure is in its original state";
  }
  let icon = (0, import_jsx_runtime43.jsx)(PowerIcon_default, { width: "1.5rem", height: "1.5rem" });
  if (ready) {
    if (modified) {
      icon = (0, import_jsx_runtime43.jsx)(BoltIcon_default, { width: "1.5rem", height: "1.5rem", className: "text-green-600" });
    } else {
      icon = (0, import_jsx_runtime43.jsx)(BoltIcon_default2, { width: "1.5rem", height: "1.5rem", className: "text-green-600" });
    }
  }
  return (0, import_jsx_runtime43.jsxs)("div", { className: "relative flex text-sm", children: [(0, import_jsx_runtime43.jsx)("button", { className: (0, import_classnames15.default)("cursor-pointer text-gray-700 dark:text-white active:text-green-700 hover:opacity-100", {
    "opacity-10": busy,
    "opacity-70": !busy
  }), disabled: ready, title, "aria-label": `status`, onClick: onClick !== null && onClick !== void 0 ? onClick : () => ({}), children: icon }), busy && (0, import_jsx_runtime43.jsx)("span", { className: "absolute top-0 left-0 z-10 opacity-100", children: (0, import_jsx_runtime43.jsx)(Spinner, { size: 24 }) })] });
}
function SpinnerButton({ ready, icon, busy, disabled, title, onClick }) {
  return (0, import_jsx_runtime43.jsxs)("div", { className: "relative flex text-sm", children: [(0, import_jsx_runtime43.jsx)("button", { className: (0, import_classnames15.default)(" text-gray-700 dark:text-white active:text-green-700 ", {
    "opacity-10 hover:opacity-10": busy,
    "opacity-70": !busy && !disabled,
    "cursor-pointer hover:opacity-100": !disabled,
    "cursor-not-allowed opacity-10 hover:opacity-10": disabled
  }), disabled: disabled || !ready || busy, onClick: () => onClick(), title: title !== null && title !== void 0 ? title : "run all cells", "aria-label": title !== null && title !== void 0 ? title : "run all cells", children: icon }), busy && (0, import_jsx_runtime43.jsx)("span", { className: "absolute top-0 left-0 z-10 opacity-100", children: (0, import_jsx_runtime43.jsx)(Spinner, { size: 24 }) })] });
}
function Run({ ready, executing, disabled, title, onClick }) {
  return (0, import_jsx_runtime43.jsx)(SpinnerButton, { ready, busy: executing, disabled, title: title !== null && title !== void 0 ? title : "run all cells", onClick, icon: (0, import_jsx_runtime43.jsx)(PlayCircleIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block align-top" }) });
}
function Restart({ ready, resetting, disabled, title, onClick }) {
  return (0, import_jsx_runtime43.jsx)(SpinnerButton, { ready, busy: resetting, disabled, title: title !== null && title !== void 0 ? title : "reset notebook", onClick, icon: (0, import_jsx_runtime43.jsx)(ArrowUturnLeftIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block align-top" }) });
}
function Clear({ ready, disabled, title, onClick }) {
  return (0, import_jsx_runtime43.jsx)("button", { className: (0, import_classnames15.default)("flex text-gray-700 dark:text-white", {
    "cursor-not-allowed opacity-10": disabled || !ready,
    "active:text-green-700 opacity-70 hover:opacity-100 cursor-pointer": !disabled
  }), disabled: disabled || !ready, onClick: () => onClick(), title: title !== null && title !== void 0 ? title : "clear", "aria-label": title !== null && title !== void 0 ? title : "clear", children: (0, import_jsx_runtime43.jsx)(MinusCircleIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block align-top" }) });
}
function Launch({ ready, disabled, title, onClick }) {
  return (0, import_jsx_runtime43.jsx)("button", { className: "flex items-center text-gray-700 cursor-pointer dark:text-white active:text-green-700 opacity-70 hover:opacity-100", disabled: disabled || !ready, onClick: () => onClick(), title: title !== null && title !== void 0 ? title : "launch in jupyter", "aria-label": title !== null && title !== void 0 ? title : "launch in jupyter", children: (0, import_jsx_runtime43.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block align-top" }) });
}

// ../../packages/jupyter/dist/controls/ArticleCellControls.js
function ArticleStatusBadge({ id }) {
  const { connect, connecting } = (0, import_thebe_react3.useThebeServer)();
  const { slug, state, start, ready, executionCount } = useNotebookExecution(id);
  const building = selectAreExecutionScopesBuilding(state, slug);
  const handleStart = () => {
    if (!connect) {
      console.debug("ArticleStatusBadge: Trying to start a connection but connect() isn't defined");
      return;
    }
    connect();
    start();
  };
  return (0, import_jsx_runtime44.jsx)(SpinnerStatusButton, { ready, busy: building || connecting, modified: executionCount != null, onClick: handleStart });
}
function ArticleRunNotebook({ id }) {
  const { ready, cellIsExecuting, notebookIsBusy, execute } = useNotebookExecution(id);
  if (!ready)
    return null;
  return (0, import_jsx_runtime44.jsx)(Run, { ready, executing: cellIsExecuting, disabled: notebookIsBusy, onClick: execute, title: "Run the notebook that creates this figure" });
}
function ArticleResetNotebook({ id }) {
  const { ready, notebookIsResetting, notebookIsBusy, reset } = useNotebookExecution(id);
  if (!ready)
    return null;
  return (0, import_jsx_runtime44.jsx)(Restart, { ready, resetting: notebookIsResetting, disabled: notebookIsBusy, onClick: reset, title: "Reset the figure to its original state and restart the kernel" });
}

// ../../node_modules/@scienceicons/react/24/solid/esm/CcByIcon.js
var React50 = __toESM(require_react(), 1);
function CcByIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React50.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React50.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React50.createElement("path", {
    d: "M12 2.2c2.7 0 5 .9 6.9 2.8 1.9 1.9 2.8 4.2 2.8 6.9s-.9 5-2.8 6.8c-2 1.9-4.3 2.9-7 2.9-2.6 0-4.9-1-6.9-2.9-1.8-1.7-2.8-4-2.8-6.7s1-5 2.9-6.9C7 3.2 9.3 2.2 12 2.2zM12 4c-2.2 0-4.1.8-5.6 2.3C4.8 8 4 9.9 4 12c0 2.2.8 4 2.4 5.6C8 19.2 9.8 20 12 20c2.2 0 4.1-.8 5.7-2.4 1.5-1.5 2.3-3.3 2.3-5.6 0-2.2-.8-4.1-2.3-5.7C16.1 4.8 14.2 4 12 4zm2.6 5.6v4h-1.1v4.7h-3v-4.7H9.4v-4c0-.2.1-.3.2-.4.1-.2.2-.2.4-.2h4c.2 0 .3.1.4.2.2.1.2.2.2.4zm-4-2.5c0-.9.5-1.4 1.4-1.4s1.4.5 1.4 1.4c0 .9-.5 1.4-1.4 1.4s-1.4-.5-1.4-1.4z"
  }));
}
var ForwardRef34 = React50.forwardRef(CcByIcon);
var CcByIcon_default = ForwardRef34;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcNcIcon.js
var React51 = __toESM(require_react(), 1);
function CcNcIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React51.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React51.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React51.createElement("path", {
    d: "M12 2.2c2.7 0 5 .9 6.9 2.8 1.9 1.9 2.8 4.2 2.8 6.9s-.9 5-2.8 6.8c-2 1.9-4.3 2.9-7 2.9-2.6 0-4.9-1-6.9-2.9-1.9-1.9-2.9-4.2-2.9-6.9s1-5 2.9-6.9c2-1.7 4.3-2.7 7-2.7zM4.4 9.4C4.2 10.2 4 11 4 12c0 2.2.8 4 2.4 5.6C8 19.2 9.8 20 12 20c2.2 0 4.1-.8 5.7-2.4.6-.5 1-1.1 1.3-1.7l-3.7-1.6c-.1.6-.4 1.1-.9 1.5-.5.4-1.1.6-1.8.7V18h-1.1v-1.5c-1.1 0-2.1-.4-3-1.2l1.3-1.4c.6.6 1.4.9 2.2.9.3 0 .6-.1.9-.2.2-.2.4-.4.4-.7 0-.2-.1-.4-.3-.6l-.9-.4-1.1-.6-1.5-.7-5.1-2.2zM12 4c-2.2 0-4.1.8-5.6 2.3-.4.4-.7.9-1.1 1.3L9 9.3c.2-.5.5-.9 1-1.2.5-.3 1-.5 1.6-.5V6.1h1.1v1.5c.9 0 1.7.3 2.4.9l-1.3 1.3c-.5-.4-1.1-.6-1.7-.6-.3 0-.6.1-.8.2-.2.1-.3.3-.3.6 0 .1 0 .2.1.2l1.2.6.9.4 1.6.7 5 2.2c.2-.7.2-1.4.2-2.1 0-2.2-.8-4.1-2.3-5.7C16.1 4.8 14.2 4 12 4z"
  }));
}
var ForwardRef35 = React51.forwardRef(CcNcIcon);
var CcNcIcon_default = ForwardRef35;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcNdIcon.js
var React52 = __toESM(require_react(), 1);
function CcNdIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React52.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React52.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React52.createElement("path", {
    d: "M12 2.2c2.7 0 5 .9 6.9 2.8 1.9 1.9 2.8 4.2 2.8 6.9s-.9 5-2.8 6.9c-2 1.9-4.3 2.9-7 2.9-2.6 0-4.9-1-6.9-2.9C3.2 17 2.2 14.7 2.2 12s1-5 2.9-6.9C7 3.2 9.3 2.2 12 2.2zM12 4c-2.2 0-4.1.8-5.6 2.4C4.8 8 4 9.9 4 12c0 2.2.8 4 2.4 5.6C8 19.2 9.8 20 12 20c2.2 0 4.1-.8 5.7-2.4 1.5-1.5 2.3-3.3 2.3-5.6 0-2.2-.8-4.1-2.3-5.6C16.1 4.8 14.2 4 12 4zm3.7 5.7v1.7H8.6V9.7h7.1zm0 3.1v1.7H8.6v-1.7h7.1z"
  }));
}
var ForwardRef36 = React52.forwardRef(CcNdIcon);
var CcNdIcon_default = ForwardRef36;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcSaIcon.js
var React53 = __toESM(require_react(), 1);
function CcSaIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React53.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React53.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React53.createElement("path", {
    d: "M12 2.2c2.7 0 5 .9 6.9 2.8 1.9 1.9 2.8 4.2 2.8 6.9s-.9 5-2.8 6.9c-2 1.9-4.3 2.9-7 2.9-2.6 0-4.9-1-6.9-2.9C3.2 17 2.2 14.7 2.2 12s1-5 2.9-6.9C7 3.2 9.3 2.2 12 2.2zM12 4c-2.2 0-4.1.8-5.6 2.4C4.8 8 4 9.9 4 12c0 2.2.8 4 2.4 5.6C8 19.2 9.8 20 12 20c2.2 0 4.1-.8 5.7-2.4 1.5-1.5 2.3-3.3 2.3-5.6 0-2.2-.8-4.1-2.3-5.6C16.1 4.8 14.2 4 12 4zm-4.3 6.6c.2-1.2.7-2.1 1.4-2.8.8-.7 1.7-1 2.8-1 1.5 0 2.8.5 3.7 1.5.9 1 1.4 2.3 1.4 3.8s-.5 2.7-1.4 3.7c-.9 1-2.2 1.5-3.7 1.5-1.1 0-2.1-.3-2.9-1-.8-.7-1.3-1.6-1.4-2.8h2.5c.1 1.2.8 1.8 2.1 1.8.7 0 1.2-.3 1.7-.9.4-.6.6-1.4.6-2.4s-.2-1.8-.6-2.4c-.4-.5-.9-.8-1.7-.8-1.3 0-2 .6-2.2 1.7h.7l-1.9 1.9-1.9-1.9.8.1z"
  }));
}
var ForwardRef37 = React53.forwardRef(CcSaIcon);
var CcSaIcon_default = ForwardRef37;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcZeroIcon.js
var React54 = __toESM(require_react(), 1);
function CcZeroIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React54.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React54.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React54.createElement("path", {
    d: "M12 6.4c-3.2 0-4 3-4 5.6 0 2.6.8 5.6 4 5.6s4-3 4-5.6c0-2.6-.8-5.6-4-5.6zm0 2.1h.4c.2.2.3.5.1.9l-2.1 3.9c-.1-.5-.1-1-.1-1.4 0-1 0-3.4 1.7-3.4zm1.6 1.8c.1.6.1 1.2.1 1.7 0 1.1-.1 3.5-1.7 3.5h-.4-.1-.1c-.4-.2-.6-.4-.3-.9l2.5-4.3z"
  }), /* @__PURE__ */ React54.createElement("path", {
    d: "M12 2.2c-2.7 0-5 .9-6.8 2.8-1 1-1.7 2.1-2.2 3.3-.5 1.2-.8 2.4-.8 3.7 0 1.3.2 2.5.7 3.7.5 1.2 1.2 2.2 2.1 3.2.9.9 2 1.6 3.2 2.1 1.2.5 2.4.7 3.7.7 1.3 0 2.5-.3 3.7-.8 1.2-.5 2.3-1.2 3.2-2.2.9-.9 1.6-1.9 2.1-3.1.5-1.2.7-2.4.7-3.8 0-1.3-.2-2.6-.7-3.7-.3-1-1-2.1-1.9-3-2-1.9-4.3-2.9-7-2.9zM12 4c2.2 0 4.1.8 5.7 2.3.7.8 1.3 1.7 1.7 2.6.4 1 .6 2 .6 3.1 0 2.2-.8 4.1-2.3 5.6-.8.8-1.7 1.4-2.7 1.8-1 .4-2 .6-3 .6-1.1 0-2.1-.2-3-.6-1-.4-1.8-1-2.6-1.7C5.6 16.9 5 16 4.6 15c-.4-1-.6-2-.6-3 0-1.1.2-2.1.6-3 .4-1 1-1.9 1.8-2.6C7.9 4.8 9.8 4 12 4z"
  }));
}
var ForwardRef38 = React54.forwardRef(CcZeroIcon);
var CcZeroIcon_default = ForwardRef38;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcIcon.js
var React55 = __toESM(require_react(), 1);
function CcIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React55.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React55.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React55.createElement("path", {
    d: "M12 2.2c2.7 0 5 1 7 2.9.9.9 1.6 2 2.1 3.1.5 1.2.7 2.4.7 3.8 0 1.3-.2 2.6-.7 3.8-.5 1.2-1.2 2.2-2.1 3.1-1 .9-2 1.7-3.2 2.2-1.2.5-2.5.7-3.7.7s-2.6-.3-3.8-.8c-1.2-.5-2.2-1.2-3.2-2.1s-1.6-2-2.1-3.2-.8-2.4-.8-3.7c0-1.3.2-2.5.7-3.7S4.2 6 5.1 5.1C7 3.2 9.3 2.2 12 2.2zM12 4c-2.2 0-4.1.8-5.6 2.3C5.6 7.1 5 8 4.6 9c-.4 1-.6 2-.6 3s.2 2.1.6 3c.4 1 1 1.8 1.8 2.6S8 19 9 19.4c1 .4 2 .6 3 .6s2.1-.2 3-.6c1-.4 1.9-1 2.7-1.8 1.5-1.5 2.3-3.3 2.3-5.6 0-1.1-.2-2.1-.6-3.1-.4-1-1-1.8-1.7-2.6C16.1 4.8 14.2 4 12 4zm-.1 6.4l-1.3.7c-.1-.3-.3-.5-.5-.6-.2-.1-.4-.2-.6-.2-.9 0-1.3.6-1.3 1.7 0 .5.1.9.3 1.3.2.3.5.5 1 .5.6 0 1-.3 1.2-.8l1.2.6c-.3.5-.6.9-1.1 1.1-.5.3-1 .4-1.5.4-.9 0-1.6-.3-2.1-.8-.5-.6-.8-1.3-.8-2.3 0-.9.3-1.7.8-2.2.6-.6 1.3-.8 2.1-.8 1.2 0 2.1.4 2.6 1.4zm5.6 0l-1.3.7c-.1-.3-.3-.5-.5-.6-.2-.1-.4-.2-.6-.2-.9 0-1.3.6-1.3 1.7 0 .5.1.9.3 1.3.2.3.5.5 1 .5.6 0 1-.3 1.2-.8l1.2.6c-.3.5-.6.9-1.1 1.1-.4.2-.9.3-1.4.3-.9 0-1.6-.3-2.1-.8s-.8-1.3-.8-2.2c0-.9.3-1.7.8-2.2.5-.5 1.2-.8 2-.8 1.2 0 2.1.4 2.6 1.4z"
  }));
}
var ForwardRef39 = React55.forwardRef(CcIcon);
var CcIcon_default = ForwardRef39;

// ../../node_modules/@scienceicons/react/24/solid/esm/EmailIcon.js
var React56 = __toESM(require_react(), 1);
function EmailIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React56.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React56.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React56.createElement("path", {
    d: "M21.8 18c0 1.1-.9 2-1.9 2H4.2c-1.1 0-1.9-.9-1.9-2V9.9c0-.5.3-.7.8-.4l7.8 4.7c.7.4 1.7.4 2.4 0L21 9.5c.4-.2.8-.1.8.4V18z"
  }), /* @__PURE__ */ React56.createElement("path", {
    d: "M21.8 6c0-1.1-.9-2-1.9-2H4.2c-1.1 0-2 .9-2 2v.4c0 .5.3 1.1.8 1.3l8.5 5.1c.2.1.7.1.9 0l8.6-5c.4-.3.8-.9.8-1.3-.1-.1-.1-.5 0-.5z"
  }));
}
var ForwardRef40 = React56.forwardRef(EmailIcon);
var EmailIcon_default = ForwardRef40;

// ../../node_modules/@scienceicons/react/24/solid/esm/GithubIcon.js
var React57 = __toESM(require_react(), 1);
function GithubIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React57.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React57.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React57.createElement("path", {
    d: "M12 2.5c-5.4 0-9.8 4.4-9.8 9.7 0 4.3 2.8 8 6.7 9.2.5.1.7-.2.7-.5v-1.8c-2.4.5-3.1-.6-3.3-1.1-.1-.3-.6-1.1-1-1.4-.3-.2-.8-.6 0-.6s1.3.7 1.5 1c.9 1.5 2.3 1.1 2.8.8.1-.6.3-1.1.6-1.3-2.2-.2-4.4-1.1-4.4-4.8 0-1.1.4-1.9 1-2.6-.1-.2-.4-1.2.1-2.6 0 0 .8-.3 2.7 1 .8-.2 1.6-.3 2.4-.3.8 0 1.7.1 2.4.3 1.9-1.3 2.7-1 2.7-1 .5 1.3.2 2.3.1 2.6.6.7 1 1.5 1 2.6 0 3.7-2.3 4.6-4.4 4.8.4.3.7.9.7 1.8V21c0 .3.2.6.7.5 3.9-1.3 6.6-4.9 6.6-9.2 0-5.4-4.4-9.8-9.8-9.8z"
  }));
}
var ForwardRef41 = React57.forwardRef(GithubIcon);
var GithubIcon_default = ForwardRef41;

// ../../node_modules/@scienceicons/react/24/solid/esm/JupyterIcon.js
var React58 = __toESM(require_react(), 1);
function JupyterIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React58.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React58.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React58.createElement("path", {
    d: "M20.2 1.7c0 .8-.5 1.4-1.3 1.5-.8 0-1.4-.5-1.5-1.3 0-.8.5-1.4 1.3-1.5.8-.1 1.5.5 1.5 1.3zM12 17.9c-3.7 0-7-1.3-8.7-3.3 1.8 4.8 7.1 7.3 11.9 5.5 2.5-.9 4.5-2.9 5.5-5.5-1.7 2-4.9 3.3-8.7 3.3zM12 5.1c3.7 0 7 1.3 8.7 3.3-1.8-4.8-7.1-7.3-11.9-5.5-2.5.9-4.5 2.9-5.5 5.5 1.7-2 5-3.3 8.7-3.3zM6.9 21.8c.1 1-.7 1.8-1.7 1.9-1 .1-1.8-.7-1.9-1.7 0-1 .7-1.8 1.7-1.9 1-.1 1.8.7 1.9 1.7zM3.7 4.6c-.6 0-1-.4-1-1s.4-1 1-1 1 .4 1 1c0 .5-.4 1-1 1z"
  }));
}
var ForwardRef42 = React58.forwardRef(JupyterIcon);
var JupyterIcon_default = ForwardRef42;

// ../../node_modules/@scienceicons/react/24/solid/esm/OpenAccessIcon.js
var React59 = __toESM(require_react(), 1);
function OpenAccessIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React59.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React59.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React59.createElement("path", {
    d: "M17.1 12.6h-2V7.5c0-1.7-1.4-3.1-3-3.1-.8 0-1.6.3-2.2.9-.6.5-.9 1.3-.9 2.2v.7H7v-.7c0-1.4.5-2.7 1.5-3.7s2.2-1.5 3.6-1.5 2.6.5 3.6 1.5 1.5 2.3 1.5 3.7v5.1z"
  }), /* @__PURE__ */ React59.createElement("path", {
    d: "M12 21.8c-.8 0-1.6-.2-2.3-.5-.7-.3-1.4-.8-1.9-1.3-.6-.6-1-1.2-1.3-2-.3-.8-.5-1.6-.5-2.4s.2-1.6.5-2.4c.3-.7.7-1.4 1.3-2s1.2-1 1.9-1.3c.7-.3 1.5-.5 2.3-.5.8 0 1.6.2 2.3.5.7.3 1.4.8 1.9 1.3.6.6 1 1.2 1.3 2 .3.8.5 1.6.5 2.4s-.2 1.6-.5 2.4c-.3.7-.7 1.4-1.3 2-.6.6-1.2 1-1.9 1.3-.7.3-1.5.5-2.3.5zm0-10.3c-2.2 0-4 1.8-4 4.1s1.8 4.1 4 4.1 4-1.8 4-4.1-1.8-4.1-4-4.1z"
  }), /* @__PURE__ */ React59.createElement("circle", {
    cx: 12,
    cy: 15.6,
    r: 1.7
  }));
}
var ForwardRef43 = React59.forwardRef(OpenAccessIcon);
var OpenAccessIcon_default = ForwardRef43;

// ../../node_modules/@scienceicons/react/24/solid/esm/OrcidIcon.js
var React60 = __toESM(require_react(), 1);
function OrcidIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React60.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React60.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React60.createElement("path", {
    d: "M21.8 12c0 5.4-4.4 9.8-9.8 9.8S2.2 17.4 2.2 12 6.6 2.2 12 2.2s9.8 4.4 9.8 9.8zM8.2 5.8c-.4 0-.8.3-.8.8s.3.8.8.8.8-.4.8-.8-.3-.8-.8-.8zm2.3 9.6h1.2v-6h1.8c2.3 0 3.3 1.4 3.3 3s-1.5 3-3.3 3h-3v1.1H9V8.3H7.7v8.2h5.9c3.3 0 4.5-2.2 4.5-4.1s-1.2-4.1-4.3-4.1h-3.2l-.1 7.1z"
  }));
}
var ForwardRef44 = React60.forwardRef(OrcidIcon);
var OrcidIcon_default = ForwardRef44;

// ../../node_modules/@scienceicons/react/24/solid/esm/OsiIcon.js
var React61 = __toESM(require_react(), 1);
function OsiIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React61.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React61.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React61.createElement("path", {
    d: "M13.2 15.6c1.4-.5 2.1-1.6 2.1-3.3S13.8 8.9 12 8.9c-1.9 0-3.3 1.6-3.3 3.3 0 1.8.8 3 2.2 3.4l-2.3 5.9c-3.1-.8-6.3-4.6-6.3-9.3 0-5.5 4.3-10 9.7-10s9.8 4.5 9.8 10c0 4.7-3.1 8.5-6.3 9.3l-2.3-5.9z"
  }));
}
var ForwardRef45 = React61.forwardRef(OsiIcon);
var OsiIcon_default = ForwardRef45;

// ../../node_modules/@scienceicons/react/24/solid/esm/RorIcon.js
var React62 = __toESM(require_react(), 1);
function RorIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React62.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React62.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React62.createElement("path", {
    d: "M10 4.2L8.3 6.8 6.6 4.2H10zM17.1 4.2l-1.7 2.6-1.7-2.6h3.4zM6.6 19.8l1.7-2.6 1.7 2.6H6.6zM13.7 19.8l1.7-2.6 1.7 2.6h-3.4zM20.8 12.5c.6-.1 1.1-.4 1.4-.8.3-.4.5-.9.5-1.5 0-.5-.1-.9-.3-1.2-.2-.3-.4-.6-.7-.8-.3-.2-.6-.3-1-.4-.4-.1-.8-.1-1.2-.1h-3.3v2.6c0-.1-.1-.2-.1-.2-.2-.6-.6-1-1-1.4-.4-.4-.9-.7-1.5-.9-.6-.2-1.2-.3-1.9-.3s-1.3.1-1.9.3c-.5.1-1 .4-1.4.8-.3.4-.6.8-.9 1.3 0-.3-.1-.6-.2-.9-.2-.4-.4-.6-.7-.8-.3-.2-.6-.3-1-.4s-.8-.2-1.3-.2H1v8.5h1.9v-3.4h.9l1.8 3.4h2.3l-2.2-3.6c.6-.1 1.1-.4 1.4-.8v-.1.2c0 .7.1 1.3.3 1.8.2.6.6 1 1 1.4.4.4.9.7 1.5.9.6.2 1.2.3 1.9.3s1.3-.1 1.9-.3c.6-.2 1.1-.5 1.5-.9.4-.4.7-.9 1-1.4 0-.1.1-.2.1-.2V16H18v-3.4h.9l1.8 3.4H23l-2.2-3.5zM5.4 10.7c-.1.2-.2.3-.3.3-.2.1-.3.1-.5.1H2.9V9.2h1.7c.2 0 .3.1.5.1.1.1.3.2.3.3.1.1.1.3.1.5.1.3 0 .5-.1.6zm8.8 2.3c-.1.3-.3.6-.5.9-.2.2-.5.4-.8.6-.3.1-.7.2-1.1.2-.4 0-.8-.1-1.1-.2-.3-.1-.6-.3-.8-.6-.2-.2-.4-.5-.5-.9-.1-.3-.2-.7-.2-1.1 0-.4.1-.8.2-1.1s.3-.6.5-.9c.2-.2.5-.4.8-.6.3-.1.7-.2 1.1-.2.4 0 .8.1 1.1.2.3.1.6.3.8.6.2.2.4.5.5.9.1.3.2.7.2 1.1 0 .4 0 .7-.2 1.1zm6.4-2.3c-.1.1-.2.2-.4.3-.2.1-.3.1-.5.1H18V9.2h1.7c.2 0 .3.1.5.1.1.1.3.2.3.3.1.1.1.3.1.5.1.3.1.5 0 .6z"
  }));
}
var ForwardRef46 = React62.forwardRef(RorIcon);
var RorIcon_default = ForwardRef46;

// ../../node_modules/@scienceicons/react/24/solid/esm/TwitterIcon.js
var React63 = __toESM(require_react(), 1);
function TwitterIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React63.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React63.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React63.createElement("path", {
    d: "M22.7 5.4c-.8.3-1.7.6-2.5.7.9-.5 1.6-1.4 1.9-2.4-.9.5-1.8.9-2.8 1.1-1.7-1.8-4.4-1.9-6.2-.2-1.1 1.1-1.6 2.7-1.3 4.2-3.5-.3-6.8-1.9-9-4.7-.4.7-.6 1.5-.6 2.2 0 1.5.7 2.8 1.9 3.6-.7 0-1.4-.2-2-.5v.1c0 2.1 1.5 3.9 3.5 4.3-.6.2-1.3.2-2 .1.6 1.8 2.2 3 4.1 3-1.6 1.2-3.5 1.9-5.4 1.9-.3 0-.7 0-1-.1 2 1.3 4.3 2 6.7 2 8.1 0 12.5-6.7 12.5-12.5v-.6c.8-.6 1.6-1.3 2.2-2.2"
  }));
}
var ForwardRef47 = React63.forwardRef(TwitterIcon);
var TwitterIcon_default = ForwardRef47;

// ../../packages/jupyter/dist/providers.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var import_react45 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/utils.js
function isObject3(maybeObject) {
  return typeof maybeObject === "object" && maybeObject !== null;
}
function thebeFrontmatterToOptions(fm) {
  if (fm === void 0)
    return void 0;
  const { binder, server, lite, kernelName, disableSessionSaving, mathjaxConfig, mathjaxUrl } = fm !== null && fm !== void 0 ? fm : {};
  const thebeOptions = { mathjaxConfig, mathjaxUrl };
  if (disableSessionSaving) {
    thebeOptions.savedSessionOptions = { enabled: false };
  }
  if (kernelName) {
    thebeOptions.kernelOptions = {
      kernelName
    };
  }
  if (binder) {
    thebeOptions.useBinder = true;
    const { repo, ref, url, provider } = binder;
    thebeOptions.binderOptions = { repo, ref, binderUrl: url, repoProvider: provider };
  }
  if (lite === true) {
    thebeOptions.useJupyterLite = true;
  }
  if (isObject3(server)) {
    const { url, token } = server;
    thebeOptions.serverSettings = {};
    if (url)
      thebeOptions.serverSettings.baseUrl = url;
    if (token)
      thebeOptions.serverSettings.token = token;
  }
  return thebeOptions;
}

// ../../packages/jupyter/dist/providers.js
var import_thebe_react4 = __toESM(require_dist3(), 1);
var ComputeOptionsContext = import_react45.default.createContext(void 0);
function ComputeOptionsProvider({ features, optionOverrideFn, customRepoProviders, children }) {
  const project = useProjectManifest();
  const options = import_react45.default.useMemo(() => {
    if (!project)
      return;
    const thebeFrontmatter = project === null || project === void 0 ? void 0 : project.thebe;
    const githubBadgeUrl = project === null || project === void 0 ? void 0 : project.github;
    const binderBadgeUrl = project === null || project === void 0 ? void 0 : project.binder;
    const optionsFromFrontmatter = thebeFrontmatterToOptions(thebeFrontmatter);
    const optionsWithOverrides = optionOverrideFn ? optionOverrideFn(optionsFromFrontmatter) : optionsFromFrontmatter;
    return {
      enabled: !!optionsWithOverrides,
      thebe: optionsWithOverrides,
      githubBadgeUrl,
      binderBadgeUrl,
      features,
      customRepoProviders
    };
  }, [project, optionOverrideFn]);
  return (0, import_jsx_runtime45.jsx)(ComputeOptionsContext.Provider, { value: options, children });
}
function useComputeOptions() {
  return (0, import_react45.useContext)(ComputeOptionsContext);
}
function ThebeLoaderAndServer({ baseurl, connect, children }) {
  var _a, _b, _c, _d, _e, _f, _g;
  const compute = useComputeOptions();
  return (0, import_jsx_runtime45.jsx)(import_thebe_react4.ThebeBundleLoaderProvider, { loadThebeLite: (_b = (_a = compute === null || compute === void 0 ? void 0 : compute.thebe) === null || _a === void 0 ? void 0 : _a.useJupyterLite) !== null && _b !== void 0 ? _b : false, publicPath: baseurl, children: (0, import_jsx_runtime45.jsx)(import_thebe_react4.ThebeServerProvider, { connect: connect !== null && connect !== void 0 ? connect : false, options: compute === null || compute === void 0 ? void 0 : compute.thebe, useBinder: (_d = (_c = compute === null || compute === void 0 ? void 0 : compute.thebe) === null || _c === void 0 ? void 0 : _c.useBinder) !== null && _d !== void 0 ? _d : false, useJupyterLite: (_f = (_e = compute === null || compute === void 0 ? void 0 : compute.thebe) === null || _e === void 0 ? void 0 : _e.useJupyterLite) !== null && _f !== void 0 ? _f : false, customRepoProviders: (_g = compute === null || compute === void 0 ? void 0 : compute.customRepoProviders) !== null && _g !== void 0 ? _g : [], children }) });
}

// ../../packages/jupyter/dist/decoration.js
var PlaceholderContext = import_react46.default.createContext({});
function PlaceholderProvider({ placeholder: placeholder2, children }) {
  const value = import_react46.default.useMemo(() => ({ placeholder: placeholder2 }), [placeholder2]);
  return (0, import_jsx_runtime46.jsx)(PlaceholderContext.Provider, { value, children });
}
function usePlaceholder() {
  const context = import_react46.default.useContext(PlaceholderContext);
  return context.placeholder;
}
function OutputDecoration({ outputId, placeholder: placeholder2, children, title = "Jupyter Notebook", url }) {
  const { kind } = useCellExecution(outputId);
  const compute = useComputeOptions();
  const Link2 = useLinkProvider();
  const top = useThemeTop();
  const baseurl = useBaseurl();
  const showComputeControls = (compute === null || compute === void 0 ? void 0 : compute.enabled) && (compute === null || compute === void 0 ? void 0 : compute.features.figureCompute) && kind === SourceFileKind.Article;
  if (showComputeControls) {
    return (0, import_jsx_runtime46.jsxs)("div", { className: "mb-4 shadow", children: [(0, import_jsx_runtime46.jsx)("div", { className: "sticky z-[2] w-full bg-gray-100/80 backdrop-blur dark:bg-neutral-800/80 py-1 px-2", style: { top }, children: (0, import_jsx_runtime46.jsxs)("div", { className: "flex items-center", children: [(0, import_jsx_runtime46.jsxs)("div", { className: "flex items-center", children: [(0, import_jsx_runtime46.jsx)(JupyterIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block" }), (0, import_jsx_runtime46.jsx)("span", { className: "ml-2", children: "Source:" }), url && (0, import_jsx_runtime46.jsx)(Link2, { to: withBaseurl(url, baseurl), className: "ml-2 no-underline text-normal hover:underline", children: title })] }), (0, import_jsx_runtime46.jsx)("div", { className: "flex-grow" }), (0, import_jsx_runtime46.jsx)(ArticleStatusBadge, { id: outputId }), (0, import_jsx_runtime46.jsx)(ArticleRunNotebook, { id: outputId }), (0, import_jsx_runtime46.jsx)(ArticleResetNotebook, { id: outputId })] }) }), (0, import_jsx_runtime46.jsx)(PlaceholderProvider, { placeholder: placeholder2, children })] });
  }
  if (kind === SourceFileKind.Article) {
    return (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, { children: [(0, import_jsx_runtime46.jsxs)("div", { className: "flex items-center justify-end text-xs", children: [(0, import_jsx_runtime46.jsx)(JupyterIcon_default, { width: "0.75rem", height: "0.75rem", className: "inline-block" }), (0, import_jsx_runtime46.jsx)("div", { className: "ml-1", children: "Source:" }), url && (0, import_jsx_runtime46.jsx)(Link2, { to: withBaseurl(url, baseurl), className: "ml-1 no-underline text-normal hover:underline", children: title })] }), (0, import_jsx_runtime46.jsx)(PlaceholderProvider, { placeholder: placeholder2, children })] });
  }
  return (0, import_jsx_runtime46.jsx)(import_jsx_runtime46.Fragment, { children });
}

// ../../packages/jupyter/dist/embed.js
function Embed({ node }) {
  var _a, _b, _c;
  const output = (_a = node.children) === null || _a === void 0 ? void 0 : _a.find((child) => child.type === "output");
  if (!output)
    return (0, import_jsx_runtime47.jsx)(MyST, { ast: node.children });
  return (0, import_jsx_runtime47.jsx)(OutputDecoration, { outputId: output.id, title: (_b = node.source) === null || _b === void 0 ? void 0 : _b.title, url: (_c = node.source) === null || _c === void 0 ? void 0 : _c.url, children: (0, import_jsx_runtime47.jsx)(MyST, { ast: node.children }) }, node.key);
}

// ../../packages/jupyter/dist/output.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var import_classnames17 = __toESM(require_classnames(), 1);

// ../../packages/jupyter/dist/safe.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);

// ../../packages/jupyter/dist/stream.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@curvenote/ansi-to-react/dist/index.js
var import_anser = __toESM(require_lib14(), 1);
var import_escape_carriage = __toESM(require_escape_carriage(), 1);
var React66 = __toESM(require_react(), 1);
function ansiToJSON(input, use_classes = false) {
  input = (0, import_escape_carriage.escapeCarriageReturn)(fixBackspace(input));
  return import_anser.default.ansiToJson(input, {
    json: true,
    remove_empty: true,
    use_classes
  });
}
function createClass(bundle) {
  let classNames35 = "";
  if (bundle.bg) {
    classNames35 += `${bundle.bg}-bg `;
  }
  if (bundle.fg) {
    classNames35 += `${bundle.fg}-fg `;
  }
  if (bundle.decoration) {
    classNames35 += `ansi-${bundle.decoration} `;
  }
  if (classNames35 === "") {
    return null;
  }
  classNames35 = classNames35.substring(0, classNames35.length - 1);
  return classNames35;
}
function createStyle(bundle) {
  const style = {};
  if (bundle.bg) {
    style.backgroundColor = `rgb(${bundle.bg})`;
  }
  if (bundle.fg) {
    style.color = `rgb(${bundle.fg})`;
  }
  switch (bundle.decoration) {
    case "bold":
      style.fontWeight = "bold";
      break;
    case "dim":
      style.opacity = "0.5";
      break;
    case "italic":
      style.fontStyle = "italic";
      break;
    case "hidden":
      style.visibility = "hidden";
      break;
    case "strikethrough":
      style.textDecoration = "line-through";
      break;
    case "underline":
      style.textDecoration = "underline";
      break;
    case "blink":
      style.textDecoration = "blink";
      break;
    default:
      break;
  }
  return style;
}
function convertBundleIntoReact(linkify, useClasses, bundle, key) {
  const style = useClasses ? null : createStyle(bundle);
  const className = useClasses ? createClass(bundle) : null;
  if (!linkify) {
    return React66.createElement("span", { style, key, className }, bundle.content);
  }
  const content = [];
  const linkRegex = /(\s|^)(https?:\/\/(?:www\.|(?!www))[^\s.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/g;
  let index2 = 0;
  let match;
  while ((match = linkRegex.exec(bundle.content)) !== null) {
    const [, pre, url] = match;
    const startIndex = match.index + pre.length;
    if (startIndex > index2) {
      content.push(bundle.content.substring(index2, startIndex));
    }
    const href = url.startsWith("www.") ? `http://${url}` : url;
    content.push(React66.createElement("a", {
      key: index2,
      href,
      target: "_blank"
    }, `${url}`));
    index2 = linkRegex.lastIndex;
  }
  if (index2 < bundle.content.length) {
    content.push(bundle.content.substring(index2));
  }
  return React66.createElement("span", { style, key, className }, content);
}
function Ansi(props) {
  const { className, useClasses, children, linkify } = props;
  return React66.createElement("code", { className }, ansiToJSON(children !== null && children !== void 0 ? children : "", useClasses !== null && useClasses !== void 0 ? useClasses : false).map(convertBundleIntoReact.bind(null, linkify !== null && linkify !== void 0 ? linkify : false, useClasses !== null && useClasses !== void 0 ? useClasses : false)));
}
function fixBackspace(txt) {
  let tmp = txt;
  do {
    txt = tmp;
    tmp = txt.replace(/[^\n]\x08/gm, "");
  } while (tmp.length < txt.length);
  return txt;
}

// ../../packages/jupyter/dist/components.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_react47 = __toESM(require_react(), 1);
var MaybeLongContent = ({ content, path: path2, render }) => {
  const { error, data } = useLongContent(content, path2);
  if (error) {
    return (0, import_jsx_runtime48.jsxs)("div", { className: "text-red-500", children: ["Error loading content: ", error.message] });
  }
  if (!data) {
    return (0, import_jsx_runtime48.jsx)("div", { children: "Fetching long content...." });
  }
  return (0, import_jsx_runtime48.jsx)("div", { children: render(data.content) });
};

// ../../packages/jupyter/dist/stream.js
function Stream({ output }) {
  return (0, import_jsx_runtime49.jsx)(MaybeLongContent, { content: ensureString(output.text), path: output.path, render: (content) => (0, import_jsx_runtime49.jsx)("pre", { className: "text-sm font-thin font-system", children: (0, import_jsx_runtime49.jsx)(Ansi, { children: content !== null && content !== void 0 ? content : "" }) }) });
}

// ../../packages/jupyter/dist/error.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
function Error2({ output }) {
  return (0, import_jsx_runtime50.jsx)(MaybeLongContent, { content: ensureString(output.traceback), path: output.path, render: (content) => {
    return (0, import_jsx_runtime50.jsx)("pre", { className: "text-sm font-thin font-system jupyter-error", children: (0, import_jsx_runtime50.jsx)(Ansi, { children: content !== null && content !== void 0 ? content : "" }) });
  } });
}

// ../../packages/jupyter/dist/safe.js
var RENDER_PRIORITY = [
  KnownCellOutputMimeTypes.ImagePng,
  KnownCellOutputMimeTypes.ImageJpeg,
  KnownCellOutputMimeTypes.ImageGif,
  KnownCellOutputMimeTypes.ImageBmp
];
function findSafeMimeOutputs(output) {
  const data = output.data;
  const image = RENDER_PRIORITY.reduce((acc, mimetype) => {
    if (acc)
      return acc;
    if (data && data[mimetype])
      return data[mimetype];
    return void 0;
  }, void 0);
  const text = data && data["text/plain"];
  return { image, text };
}
function OutputImage({ image, text }) {
  var _a;
  return (0, import_jsx_runtime51.jsx)("img", { src: image === null || image === void 0 ? void 0 : image.path, alt: (_a = text === null || text === void 0 ? void 0 : text.content) !== null && _a !== void 0 ? _a : "Image produced in Jupyter" });
}
function SafeOutput({ output }) {
  switch (output.output_type) {
    case "stream":
      return (0, import_jsx_runtime51.jsx)(Stream, { output });
    case "error":
      return (0, import_jsx_runtime51.jsx)(Error2, { output });
    case "display_data":
    case "execute_result":
    case "update_display_data": {
      const { image, text } = findSafeMimeOutputs(output);
      if (!image && !text)
        return null;
      if (image)
        return (0, import_jsx_runtime51.jsx)(OutputImage, { image, text });
      if (text)
        return (0, import_jsx_runtime51.jsx)("div", { className: "font-mono text-sm whitespace-pre-wrap", children: (0, import_jsx_runtime51.jsx)(Ansi, { children: text.content }) });
      return null;
    }
    default:
      console.warn(`Unknown output_type ${output["output_type"]}`);
      return null;
  }
}
function SafeOutputs({ keyStub, outputs }) {
  if (!outputs)
    return null;
  const components = outputs.map((output, idx) => (0, import_jsx_runtime51.jsx)(SafeOutput, { output }, `${keyStub}-${idx}`));
  return (0, import_jsx_runtime51.jsx)(import_jsx_runtime51.Fragment, { children: components });
}

// ../../packages/jupyter/dist/jupyter.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var import_react48 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/convertImages.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function requestImageAsBase64String(src) {
  return __awaiter4(this, void 0, void 0, function* () {
    const img = new Image();
    img.crossOrigin = "Anonymous";
    const base64String = new Promise((resolve, reject4) => {
      img.onload = function ol() {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          console.error("Could not get canvas context");
          return reject4();
        }
        canvas.height = img.naturalHeight;
        canvas.width = img.naturalWidth;
        ctx.drawImage(img, 0, 0);
        const dataURL = canvas.toDataURL("image/png");
        const [, base64] = dataURL.split(";base64,");
        resolve(base64);
      };
      img.src = src;
    });
    return base64String;
  });
}
function fetchAndEncodeOutputImages(outputs) {
  return __awaiter4(this, void 0, void 0, function* () {
    return Promise.all(outputs.map((output) => __awaiter4(this, void 0, void 0, function* () {
      if (!("data" in output))
        return output;
      const imageMimetypes = Object.keys(output.data).filter((mimetype) => mimetype !== "image/svg" && mimetype !== "image/svg+xml" && mimetype.startsWith("image/"));
      if (imageMimetypes.length === 0)
        return output;
      const images = yield Promise.all(imageMimetypes.map((mimetype) => __awaiter4(this, void 0, void 0, function* () {
        const data = output.data[mimetype];
        if (data.path) {
          const base64 = yield requestImageAsBase64String(data.path);
          return Object.assign(Object.assign({}, data), { content: base64 });
        }
        return data;
      })));
      imageMimetypes.forEach((mimetype, i5) => {
        output.data[mimetype] = images[i5];
      });
      return output;
    })));
  });
}

// ../../packages/jupyter/dist/jupyter.js
var import_thebe_react5 = __toESM(require_dist3(), 1);
var import_classnames16 = __toESM(require_classnames(), 1);
function ActiveOutputRenderer({ id, initialData, core: core2 }) {
  var _a;
  const exec = useCellExecution(id);
  const placeholder2 = usePlaceholder();
  const ref = (0, import_react48.useRef)(null);
  (0, import_react48.useEffect)(() => {
    var _a2, _b, _c;
    if (!ref.current || !(exec === null || exec === void 0 ? void 0 : exec.cell)) {
      console.debug(`Jupyter: No cell ref available for cell ${id}:${(_a2 = exec === null || exec === void 0 ? void 0 : exec.cell) === null || _a2 === void 0 ? void 0 : _a2.id}`);
      return;
    }
    const verb = exec.cell.isAttachedToDOM ? "reattaching" : "attaching";
    console.debug(`${verb} cell ${exec.cell.id} to DOM at:`, {
      el: ref.current,
      connected: ref.current.isConnected,
      data: (_b = core2 === null || core2 === void 0 ? void 0 : core2.stripWidgets(initialData)) !== null && _b !== void 0 ? _b : initialData
    });
    exec.cell.attachToDOM(ref.current);
    if (exec.cell.executionCount == null) {
      exec.cell.initOutputs((_c = core2 === null || core2 === void 0 ? void 0 : core2.stripWidgets(initialData, true, placeholder2 ? () => "" : void 0)) !== null && _c !== void 0 ? _c : initialData);
    }
  }, [ref === null || ref === void 0 ? void 0 : ref.current, exec === null || exec === void 0 ? void 0 : exec.cell]);
  const executed = ((_a = exec === null || exec === void 0 ? void 0 : exec.cell) === null || _a === void 0 ? void 0 : _a.executionCount) != null;
  console.debug(`Jupyter: Cell ${id} executed: ${executed}; Show output: ${executed || !placeholder2}`);
  return (0, import_jsx_runtime52.jsxs)("div", { children: [(0, import_jsx_runtime52.jsx)("div", { ref, "data-thebe-active-ref": "true", className: (0, import_classnames16.default)("relative", { "invisible h-0": !executed && placeholder2 }) }), placeholder2 && !executed && (0, import_jsx_runtime52.jsx)(MyST, { ast: placeholder2 })] });
}
function PassiveOutputRenderer({ id, data, core: core2 }) {
  const rendermime = core2.makeRenderMimeRegistry();
  const cell = (0, import_react48.useRef)(new core2.PassiveCellRenderer(id, rendermime, void 0));
  const ref = (0, import_react48.useRef)(null);
  const { loaded } = usePlotlyPassively(rendermime, data);
  (0, import_react48.useEffect)(() => {
    var _a, _b;
    if (!ref.current || !loaded)
      return;
    cell.current.attachToDOM((_a = ref.current) !== null && _a !== void 0 ? _a : void 0, true);
    cell.current.render((_b = core2 === null || core2 === void 0 ? void 0 : core2.stripWidgets(data)) !== null && _b !== void 0 ? _b : data);
  }, [ref, loaded]);
  return (0, import_jsx_runtime52.jsx)("div", { ref, "data-thebe-passive-ref": "true" });
}
var JupyterOutputs = import_react48.default.memo(({ id, outputs }) => {
  const { core: core2, load: load2 } = (0, import_thebe_react5.useThebeLoader)();
  const { inCrossRef } = useXRefState();
  const { data, error } = useFetchAnyTruncatedContent(outputs);
  const [fullOutputs, setFullOutputs] = (0, import_react48.useState)(null);
  const exec = useCellExecution(id);
  const placeholder2 = usePlaceholder();
  (0, import_react48.useEffect)(() => {
    if (core2)
      return;
    load2();
  }, [core2, load2]);
  (0, import_react48.useEffect)(() => {
    if (!data || fullOutputs != null)
      return;
    fetchAndEncodeOutputImages(data).then((out) => {
      const compactOutputs = convertToIOutputs(out, {});
      setFullOutputs(compactOutputs);
    });
  }, [id, data, fullOutputs]);
  if (error) {
    console.error(error);
    return (0, import_jsx_runtime52.jsxs)("div", { className: "text-red-500", children: ["Error rendering output: ", error.message] });
  }
  if (!inCrossRef && (exec === null || exec === void 0 ? void 0 : exec.ready)) {
    return (0, import_jsx_runtime52.jsxs)("div", { children: [!fullOutputs && (0, import_jsx_runtime52.jsx)("div", { className: "p-2.5", children: "Fetching full output data..." }), core2 && fullOutputs && (0, import_jsx_runtime52.jsx)(ActiveOutputRenderer, { id, initialData: fullOutputs, core: core2 }, id)] });
  }
  if (placeholder2) {
    return (0, import_jsx_runtime52.jsx)(MyST, { ast: placeholder2 });
  }
  return (0, import_jsx_runtime52.jsxs)("div", { children: [!fullOutputs && (0, import_jsx_runtime52.jsx)("div", { className: "p-2.5", children: "Loading..." }), fullOutputs && core2 && (0, import_jsx_runtime52.jsx)(PassiveOutputRenderer, { id, data: fullOutputs, core: core2, kind: SourceFileKind.Notebook })] });
});

// ../../packages/jupyter/dist/output.js
var import_react49 = __toESM(require_react(), 1);
var DIRECT_OUTPUT_TYPES = /* @__PURE__ */ new Set(["stream", "error"]);
var DIRECT_MIME_TYPES = /* @__PURE__ */ new Set([
  KnownCellOutputMimeTypes.TextPlain,
  KnownCellOutputMimeTypes.ImagePng,
  KnownCellOutputMimeTypes.ImageGif,
  KnownCellOutputMimeTypes.ImageJpeg,
  KnownCellOutputMimeTypes.ImageBmp
]);
function allOutputsAreSafe(outputs, directOutputTypes, directMimeTypes) {
  if (!outputs || outputs.length === 0)
    return true;
  return outputs.reduce((flag, output) => {
    if (directOutputTypes.has(output.output_type))
      return flag && true;
    const data = output.data;
    const mimetypes = data ? Object.keys(data) : [];
    const safe = "data" in output && Boolean(output.data) && mimetypes.every((mimetype) => directMimeTypes.has(mimetype));
    return flag && safe;
  }, true);
}
function JupyterOutput({ outputId, identifier, data, align, className }) {
  const { ready } = useCellExecution(outputId);
  const outputs = data;
  const allSafe = (0, import_react49.useMemo)(() => allOutputsAreSafe(outputs, DIRECT_OUTPUT_TYPES, DIRECT_MIME_TYPES), [outputs]);
  const placeholder2 = usePlaceholder();
  let component;
  if (allSafe && !ready) {
    if (placeholder2 && (!outputs || outputs.length === 0)) {
      if (placeholder2) {
        return (0, import_jsx_runtime53.jsx)(MyST, { ast: placeholder2 });
      }
    }
    component = (0, import_jsx_runtime53.jsx)(SafeOutputs, { keyStub: outputId, outputs });
  } else {
    component = (0, import_jsx_runtime53.jsx)(JupyterOutputs, { id: outputId, outputs });
  }
  return (0, import_jsx_runtime53.jsx)("div", { id: identifier || void 0, "data-mdast-node-id": outputId, className: (0, import_classnames17.default)("max-w-full overflow-y-visible overflow-x-auto m-0 group not-prose relative", {
    "text-left": !align || align === "left",
    "text-center": align === "center",
    "text-right": align === "right",
    "mb-5": outputs && outputs.length > 0
  }, className), children: component });
}
function Output({ node }) {
  return (0, import_jsx_runtime53.jsx)(JupyterOutput, { className: (0, import_classnames17.default)({ hidden: node.visibility === "remove" }), outputId: node.id, identifier: node.identifier, align: node.align, data: node.data });
}

// ../../packages/jupyter/dist/figure.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var import_classnames18 = __toESM(require_classnames(), 1);
function Figure({ node }) {
  var _a, _b, _c, _d, _e, _f;
  const { container: Container } = DEFAULT_RENDERERS;
  const isFromJupyer = ((_a = node.source) === null || _a === void 0 ? void 0 : _a.kind) === SourceFileKind.Notebook;
  const output = (_b = node.children) === null || _b === void 0 ? void 0 : _b.find((child) => child.type === "output");
  if (isFromJupyer && !!output) {
    const placeholder2 = (_c = node.children) === null || _c === void 0 ? void 0 : _c.find((child) => child.type === "image" && child.placeholder);
    const others = (_d = node.children) === null || _d === void 0 ? void 0 : _d.filter((child) => !(child.type === "image" && child.placeholder));
    return (0, import_jsx_runtime54.jsx)("figure", { id: node.html_id || node.identifier || node.key, className: (0, import_classnames18.default)({ subcontainer: node.subcontainer }, node.class), children: (0, import_jsx_runtime54.jsx)(OutputDecoration, { outputId: output.id, placeholder: placeholder2, title: (_e = node.source) === null || _e === void 0 ? void 0 : _e.title, url: (_f = node.source) === null || _f === void 0 ? void 0 : _f.url, children: (0, import_jsx_runtime54.jsx)(MyST, { ast: others }) }, node.key) });
  }
  return (0, import_jsx_runtime54.jsx)(Container, { node });
}

// ../../packages/jupyter/dist/BinderBadge.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);

// ../../packages/jupyter/dist/ErrorTray.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var import_react50 = __toESM(require_react(), 1);
var import_thebe_react6 = __toESM(require_dist3(), 1);
function ErrorDecoration({ children, idx }) {
  return (0, import_jsx_runtime56.jsxs)("div", { className: "relative py-3 mx-2 my-8 border rounded", children: [(0, import_jsx_runtime56.jsx)("div", { className: "absolute z-10 flex items-center bg-white -top-3 -left-2", children: idx && (0, import_jsx_runtime56.jsxs)("div", { className: "ml-1 text-sm text-gray-500", children: ["cell #: ", idx + 1] }) }), (0, import_jsx_runtime56.jsx)("div", { className: "mx-3", children })] });
}
function ErrorTrayMessage({ errors }) {
  const { core: core2 } = (0, import_thebe_react6.useThebeLoader)();
  const [cells, setCells] = (0, import_react50.useState)([]);
  const [refs, setRefs] = (0, import_react50.useState)([]);
  (0, import_react50.useEffect)(() => {
    if (!core2)
      return;
    const cs = errors.map(() => new core2.PassiveCellRenderer("any"));
    setRefs(errors.map((_5, idx) => (node) => {
      var _a;
      if (node) {
        cs[idx].attachToDOM(node);
        cs[idx].render((_a = errors[idx].error) !== null && _a !== void 0 ? _a : []);
      }
    }));
    setCells(cells);
  }, [core2, errors]);
  if (!core2)
    return null;
  return (0, import_jsx_runtime56.jsx)("div", { children: errors.map((error, idx) => (0, import_jsx_runtime56.jsx)("div", { className: "not-prose min-w-[400px]", children: (0, import_jsx_runtime56.jsx)(ErrorDecoration, { idx: error.index, children: (0, import_jsx_runtime56.jsx)("div", { className: "z-100", ref: refs[idx] }, error.id) }) }, `error-${error.id}`)) });
}
function ErrorTray({ pageSlug, index: index2 }) {
  const { items } = useBusyErrors(pageSlug);
  if (!items || items.length === 0)
    return null;
  if (index2 && index2)
    return null;
  return (0, import_jsx_runtime56.jsx)("div", { className: "relative px-4 pt-3 my-8 text-sm text-red-600 border border-red-400 rounded border-1", children: items.map(({ notebookSlug, errors }, i5) => {
    return (0, import_jsx_runtime56.jsxs)("div", { children: [(0, import_jsx_runtime56.jsxs)("div", { children: [(0, import_jsx_runtime56.jsx)("span", { className: "font-bold", children: "Error" }), " in notebook ", (0, import_jsx_runtime56.jsxs)("span", { children: ['"', notebookSlug, '"'] })] }), (0, import_jsx_runtime56.jsx)(ErrorTrayMessage, { errors })] }, `${notebookSlug}-${i5}`);
  }) });
}

// ../../packages/jupyter/dist/ConnectionStatusTray.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var import_react51 = __toESM(require_react(), 1);
var import_thebe_react7 = __toESM(require_dist3(), 1);
function ConnectionStatusTray({ waitForSessions }) {
  var _a, _b, _c;
  const options = useComputeOptions();
  const { connecting, ready: serverReady, error: serverError, events: events2 } = (0, import_thebe_react7.useThebeServer)();
  const { slug, ready: scopeReady, state } = useExecutionScope();
  const [show, setShow] = (0, import_react51.useState)(false);
  const [unsub, setUnsub] = (0, import_react51.useState)();
  const [status, setStatus] = (0, import_react51.useState)("[client] Connecting...");
  const error = serverError;
  const ready = serverReady && (!waitForSessions || scopeReady);
  const busy = connecting || selectAreExecutionScopesBuilding(state, slug);
  const handleStatus = (event, data) => {
    setStatus(`[${data.subject}]: ${data.message}`);
  };
  (0, import_react51.useEffect)(() => {
    if (!events2)
      return;
    events2.on("status", handleStatus);
  }, [events2]);
  (0, import_react51.useEffect)(() => {
    if (!(options === null || options === void 0 ? void 0 : options.thebe))
      return;
    if (busy || error) {
      setShow(true);
    } else if (ready) {
      setTimeout(() => {
        setShow(false);
        unsub === null || unsub === void 0 ? void 0 : unsub();
        setUnsub(void 0);
      }, 1e3);
    }
  }, [options, busy, ready, error]);
  const host = ((_a = options === null || options === void 0 ? void 0 : options.thebe) === null || _a === void 0 ? void 0 : _a.useBinder) ? "Jupyter" : ((_b = options === null || options === void 0 ? void 0 : options.thebe) === null || _b === void 0 ? void 0 : _b.useJupyterLite) ? "JupyterLite" : "Local Server";
  if (show && error) {
    return (0, import_jsx_runtime57.jsxs)("div", { className: "fixed p-3 z-[11] text-sm text-gray-700 bg-white border rounded shadow-lg bottom-2 sm:right-2 max-w-[90%] md:max-w-[300px] min-w-0", children: [(0, import_jsx_runtime57.jsxs)("div", { className: "mb-2 font-semibold text-center", children: ["\u26D4\uFE0F Error connecting to ", host, " \u26D4\uFE0F"] }), (0, import_jsx_runtime57.jsx)("div", { className: "my-1 max-h-[15rem] mono overflow-hidden text-ellipsis", children: error }), (0, import_jsx_runtime57.jsx)("div", { className: "flex justify-end", children: (0, import_jsx_runtime57.jsx)("div", { className: "text-xs cursor-pointer hover:underline", role: "button", onClick: () => setShow(false), children: "dismiss" }) })] });
  }
  if (show && ((_c = options === null || options === void 0 ? void 0 : options.thebe) === null || _c === void 0 ? void 0 : _c.useJupyterLite)) {
    return (0, import_jsx_runtime57.jsxs)("div", { className: "fixed p-3 z-[11] text-sm text-gray-700 bg-white border rounded shadow-lg bottom-2 sm:right-2 max-w-[90%] md:max-w-[300px] min-w-0", children: [(0, import_jsx_runtime57.jsxs)("div", { className: "mb-1 font-semibold text-center", children: ["\u26A1\uFE0F Connecting to ", host, " \u26A1\uFE0F"] }), !ready && (0, import_jsx_runtime57.jsx)("div", { className: "max-h-[5rem] mono overflow-hidden text-ellipsis", children: status }), ready && (0, import_jsx_runtime57.jsx)("div", { className: "max-h-[15rem] mono overflow-hidden text-ellipsis", children: "The in-browser JupyterLite server is ready, press run anytime." })] });
  }
  if (show) {
    return (0, import_jsx_runtime57.jsxs)("div", { className: "fixed p-3 z-[11] text-sm text-gray-700 bg-white border rounded shadow-lg bottom-2 sm:right-2 max-w-[90%] md:max-w-[300px] min-w-0", children: [(0, import_jsx_runtime57.jsxs)("div", { className: "mb-1 font-semibold text-center", children: ["\u26A1\uFE0F Connecting to ", host, " \u26A1\uFE0F"] }), (0, import_jsx_runtime57.jsx)("div", { className: "max-h-[15rem] mono overflow-hidden text-ellipsis", children: status })] });
  }
  return null;
}

// ../../packages/jupyter/dist/controls/NotebookCellControls.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
function NotebookRunCell({ id }) {
  const { ready, cellIsExecuting, notebookIsBusy, execute } = useCellExecution(id);
  if (!ready)
    return null;
  return (0, import_jsx_runtime58.jsx)(Run, { ready, executing: cellIsExecuting, disabled: notebookIsBusy, onClick: execute });
}
function NotebookRunCellSpinnerOnly({ id }) {
  const { ready, cellIsExecuting } = useCellExecution(id);
  if (!ready || !cellIsExecuting)
    return null;
  return (0, import_jsx_runtime58.jsx)(Run, { ready, executing: cellIsExecuting, disabled: true, onClick: () => ({}), title: "executing cell..." });
}
function NotebookClearCell({ id }) {
  const { ready, notebookIsBusy, clear } = useCellExecution(id);
  if (!ready)
    return null;
  return (0, import_jsx_runtime58.jsx)(Clear, { ready, disabled: notebookIsBusy, onClick: clear, title: "Clear cell outputs" });
}

// ../../packages/jupyter/dist/controls/NotebookToolbar.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var import_thebe_react8 = __toESM(require_dist3(), 1);
var import_classnames19 = __toESM(require_classnames(), 1);
function NotebookToolbar({ showLaunch = false }) {
  const { slug, ready, state, start, resetAll, clearAll, execute } = useExecutionScope();
  const busy = useBusyScope();
  const { connecting, connect, ready: serverReady, server, error: serverError } = (0, import_thebe_react8.useThebeServer)();
  const computable = selectIsComputable(state, slug);
  const handleStart = () => {
    if (!connect) {
      console.debug("NotebookToolbar: Trying to start a connection but connect() isn't defined");
      return;
    }
    connect();
    start(slug);
  };
  const handleReset = () => resetAll(slug);
  const handleClear = () => clearAll(slug);
  const handleRun = () => execute(slug);
  const handleLaunch = () => {
    if (!serverReady || !(server === null || server === void 0 ? void 0 : server.settings))
      return;
    window.open(`${server.settings.baseUrl}?token=${server.settings.token}`, "_blank");
  };
  const building = selectAreExecutionScopesBuilding(state, slug);
  const status = selectExecutionScopeStatus(state, slug);
  const error = !!serverError;
  let title = "Connect to a compute server";
  if (error) {
    title = "Error connecting to compute server";
  } else if (building) {
    title = status;
  }
  if (computable)
    return (0, import_jsx_runtime59.jsx)("div", { className: "sticky top-[60px] flex justify-end w-full z-20 pointer-events-none", children: (0, import_jsx_runtime59.jsxs)("div", { className: "flex p-1 m-1 space-x-1 border rounded-full shadow pointer-events-auto border-stone-300 bg-white/80 dark:bg-stone-900/80 backdrop-blur", children: [!ready && (0, import_jsx_runtime59.jsxs)("div", { className: "rounded", children: [(0, import_jsx_runtime59.jsx)("button", { className: (0, import_classnames19.default)("flex text-center rounded-full cursor-pointer text-stone-800 dark:text-white hover:opacity-100 opacity-60", {
      "opacity-10 text-stone-100 dark:text-stone-700": connecting || building
    }), onClick: handleStart, disabled: building, "aria-label": "start compute environment", children: (0, import_jsx_runtime59.jsx)(PowerIcon_default, { className: "inline-block w-6 h-6 align-top", title: "enable compute" }) }), (connecting || building) && !error && (0, import_jsx_runtime59.jsx)("span", { className: "absolute top-1 left-1 z-10 w-[22px] h-[22px] opacity-100", title, children: (0, import_jsx_runtime59.jsx)(Spinner, { size: 24 }) })] }), ready && (0, import_jsx_runtime59.jsx)(Run, { ready, executing: busy.page(slug, "execute"), onClick: handleRun, title: "Run all cells" }), ready && (0, import_jsx_runtime59.jsx)(Restart, { ready, resetting: busy.page(slug, "reset"), onClick: handleReset, disabled: busy.page(slug, "execute"), title: "Reset notebook and restart kernel" }), ready && (0, import_jsx_runtime59.jsx)(Clear, { ready, disabled: busy.page(slug, "execute") || busy.page(slug, "reset"), onClick: handleClear, title: "Clear all cells" }), showLaunch && ready && (0, import_jsx_runtime59.jsx)(Launch, { ready, disabled: false, onClick: handleLaunch, title: "Launch notebook in Jupyter" })] }) });
  return null;
}

// ../../packages/jupyter/dist/index.js
var OUTPUT_RENDERERS = {
  output: Output,
  embed: Embed,
  container: Figure
};
var dist_default = OUTPUT_RENDERERS;

// ../../packages/site/src/components/ContentBlocks.tsx
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime(), 1);
function isACodeCell(node) {
  return !!executableNodesFromBlock(node);
}
function Block({
  id,
  pageKind,
  node,
  className
}) {
  var _a, _b;
  const grid = useGridSystemProvider();
  const subGrid = `${grid} subgrid-gap col-screen`;
  const dataClassName = typeof ((_a = node.data) == null ? void 0 : _a.class) === "string" ? (_b = node.data) == null ? void 0 : _b.class : void 0;
  const noSubGrid = dataClassName && dataClassName.includes("col-") || className && className.includes("col-");
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
    "div",
    {
      id,
      className: (0, import_classnames20.default)("relative group/block", className, dataClassName, {
        [subGrid]: !noSubGrid
      }),
      children: [
        pageKind === SourceFileKind.Notebook && isACodeCell(node) && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_jsx_dev_runtime.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { className: "flex sticky top-[80px] z-10 opacity-70 group-hover/block:opacity-100 group-hover/block:hidden", children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { className: "absolute top-0 -right-[28px] flex md:flex-col", children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(NotebookRunCellSpinnerOnly, { id }, void 0, false, {
            fileName: "../../packages/site/src/components/ContentBlocks.tsx",
            lineNumber: 46,
            columnNumber: 15
          }, this) }, void 0, false, {
            fileName: "../../packages/site/src/components/ContentBlocks.tsx",
            lineNumber: 45,
            columnNumber: 13
          }, this) }, void 0, false, {
            fileName: "../../packages/site/src/components/ContentBlocks.tsx",
            lineNumber: 44,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { className: "hidden sticky top-[80px] z-10 opacity-70 group-hover/block:opacity-100 group-hover/block:flex", children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { className: "absolute top-0 -right-[28px] flex md:flex-col", children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(NotebookRunCell, { id }, void 0, false, {
              fileName: "../../packages/site/src/components/ContentBlocks.tsx",
              lineNumber: 51,
              columnNumber: 15
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(NotebookClearCell, { id }, void 0, false, {
              fileName: "../../packages/site/src/components/ContentBlocks.tsx",
              lineNumber: 52,
              columnNumber: 15
            }, this)
          ] }, void 0, true, {
            fileName: "../../packages/site/src/components/ContentBlocks.tsx",
            lineNumber: 50,
            columnNumber: 13
          }, this) }, void 0, false, {
            fileName: "../../packages/site/src/components/ContentBlocks.tsx",
            lineNumber: 49,
            columnNumber: 11
          }, this)
        ] }, void 0, true, {
          fileName: "../../packages/site/src/components/ContentBlocks.tsx",
          lineNumber: 43,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(MyST, { ast: node.children }, void 0, false, {
          fileName: "../../packages/site/src/components/ContentBlocks.tsx",
          lineNumber: 57,
          columnNumber: 7
        }, this)
      ]
    },
    `block-${id}`,
    true,
    {
      fileName: "../../packages/site/src/components/ContentBlocks.tsx",
      lineNumber: 35,
      columnNumber: 5
    },
    this
  );
}
function ContentBlocks({
  mdast,
  pageKind = SourceFileKind.Article,
  className
}) {
  if (!mdast)
    return null;
  const blocks = mdast.children;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_jsx_dev_runtime.Fragment, { children: blocks.filter((node) => node.visibility !== "remove").map((node) => /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
    Block,
    {
      id: node.key,
      pageKind,
      node,
      className
    },
    node.key,
    false,
    {
      fileName: "../../packages/site/src/components/ContentBlocks.tsx",
      lineNumber: 78,
      columnNumber: 11
    },
    this
  )) }, void 0, false, {
    fileName: "../../packages/site/src/components/ContentBlocks.tsx",
    lineNumber: 74,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/DocumentOutline.tsx
var import_classnames21 = __toESM(require_classnames(), 1);
var import_lodash2 = __toESM(require_lodash2(), 1);
var import_react53 = __toESM(require_react(), 1);
var import_jsx_dev_runtime2 = __toESM(require_jsx_dev_runtime(), 1);
var SELECTOR = [1, 2, 3, 4].map((n4) => `main h${n4}`).join(", ");
var HIGHLIGHT_CLASS = "highlight";
var onClient = typeof document !== "undefined";
var Headings = ({ headings, activeId, highlight, selector }) => /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("ul", { className: "text-sm leading-6 text-slate-400", children: headings.map((heading) => /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(
  "li",
  {
    className: (0, import_classnames21.default)("border-l-2 hover:border-l-blue-500", {
      "text-blue-600": heading.id === activeId,
      "border-l-gray-300 dark:border-l-gray-50": heading.id !== activeId,
      "border-l-blue-500": heading.id === activeId,
      "bg-blue-50 dark:bg-slate-800": heading.id === activeId
    }),
    children: /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(
      "a",
      {
        className: (0, import_classnames21.default)("block p-1", {
          "text-slate-900 dark:text-slate-50": heading.level < 2 && heading.id !== activeId,
          "text-slate-500 dark:text-slate-300": heading.level >= 2 && heading.id !== activeId,
          "text-blue-600 dark:text-white font-bold": heading.id === activeId,
          "pr-2": heading.id !== activeId,
          // Allows for bold to change length
          "pl-2": heading.level === 1,
          "pl-4": heading.level === 2,
          "pl-8 text-xs": heading.level === 3,
          "pl-10 text-xs font-light": heading.level === 4,
          "pl-12 text-xs font-extralight": heading.level === 5
        }),
        href: `#${heading.id}`,
        onClick: (e4) => {
          e4.preventDefault();
          const el = document.querySelector(`#${heading.id}`);
          if (!el)
            return;
          getHeaders(selector).forEach((h4) => {
            h4.classList.remove(HIGHLIGHT_CLASS);
          });
          el.classList.add(HIGHLIGHT_CLASS);
          highlight == null ? void 0 : highlight();
          el.scrollIntoView({ behavior: "smooth" });
          history.replaceState(void 0, "", `#${heading.id}`);
        },
        dangerouslySetInnerHTML: { __html: heading.titleHTML }
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/DocumentOutline.tsx",
        lineNumber: 48,
        columnNumber: 9
      },
      this
    )
  },
  heading.id,
  false,
  {
    fileName: "../../packages/site/src/components/DocumentOutline.tsx",
    lineNumber: 39,
    columnNumber: 7
  },
  this
)) }, void 0, false, {
  fileName: "../../packages/site/src/components/DocumentOutline.tsx",
  lineNumber: 37,
  columnNumber: 3
}, this);
function cloneHeadingElement(originalElement) {
  const clonedElement = originalElement.cloneNode(true);
  const abbrElements = clonedElement.getElementsByTagName("abbr");
  for (let i5 = 0; i5 < abbrElements.length; i5++) {
    const abbr = abbrElements[i5];
    const parent = abbr.parentNode;
    while (abbr.firstChild) {
      parent.insertBefore(abbr.firstChild, abbr);
    }
    parent.removeChild(abbr);
  }
  return clonedElement;
}
function getHeaders(selector) {
  const headers = Array.from(document.querySelectorAll(selector)).filter((e4) => {
    const parent = e4.closest(".exclude-from-outline");
    return !(e4.classList.contains("title") || parent);
  });
  return headers;
}
function useHeaders(selector, maxdepth) {
  if (!onClient)
    return { activeId: "", headings: [] };
  const onScreen = (0, import_react53.useRef)(/* @__PURE__ */ new Set());
  const [activeId, setActiveId] = (0, import_react53.useState)();
  const headingsSet = (0, import_react53.useRef)(/* @__PURE__ */ new Set());
  const highlight = (0, import_react53.useCallback)(() => {
    const current = [...onScreen.current];
    const highlighted = current.reduce(
      (a4, b4) => {
        if (a4)
          return a4;
        if (b4.classList.contains("highlight"))
          return b4.id;
        return null;
      },
      null
    );
    const active = [...onScreen.current].sort((a4, b4) => a4.offsetTop - b4.offsetTop)[0];
    if (highlighted || active)
      setActiveId(highlighted || active.id);
  }, []);
  const { observer } = useIntersectionObserver(highlight, onScreen.current);
  const [elements, setElements] = (0, import_react53.useState)([]);
  const render = (0, import_lodash2.default)(() => setElements(getHeaders(selector)), 500);
  (0, import_react53.useEffect)(() => {
    const main = document.querySelector("main");
    const mutations = new MutationObserver(render);
    render();
    if (main) {
      mutations.observe(main, { attributes: true, childList: true, subtree: true });
    }
    return () => mutations.disconnect();
  }, []);
  (0, import_react53.useEffect)(() => {
    Array.from(elements).map((e4) => {
      var _a;
      return (_a = observer.current) == null ? void 0 : _a.observe(e4);
    });
  }, [observer]);
  let minLevel = 10;
  const headings = elements.map((element2) => {
    return {
      element: element2,
      level: Number(element2.tagName.slice(1)),
      id: element2.id,
      text: element2.querySelector(".heading-text")
    };
  }).filter((h4) => !!h4.text).map(({ element: element2, level, text, id }) => {
    const { innerText: title, innerHTML: titleHTML } = cloneHeadingElement(
      text
    );
    minLevel = Math.min(minLevel, level);
    return { element: element2, title, titleHTML, id, level };
  }).filter((heading) => {
    heading.level = heading.level - minLevel + 1;
    return heading.level < maxdepth + 1;
  });
  headings.forEach(({ element: e4 }) => {
    var _a;
    if (headingsSet.current.has(e4))
      return;
    (_a = observer.current) == null ? void 0 : _a.observe(e4);
    headingsSet.current.add(e4);
  });
  return { activeId, highlight, headings };
}
var useIntersectionObserver = (highlight, onScreen) => {
  const observer = (0, import_react53.useRef)(null);
  if (!onClient)
    return { observer };
  (0, import_react53.useEffect)(() => {
    const callback = (entries) => {
      entries.forEach((entry) => {
        onScreen[entry.isIntersecting ? "add" : "delete"](entry.target);
      });
      highlight();
    };
    const o10 = new IntersectionObserver(callback);
    observer.current = o10;
    return () => o10.disconnect();
  }, [highlight, onScreen]);
  return { observer };
};
function useOutlineHeight(existingContainer) {
  const container = (0, import_react53.useRef)(null);
  const outline = (0, import_react53.useRef)(null);
  const transitionState = useNavigation().state;
  const setHeight = () => {
    if (!container.current || !outline.current)
      return;
    const height = container.current.offsetHeight - window.scrollY + container.current.offsetTop;
    outline.current.style.display = height < 50 ? "none" : "";
    outline.current.style.height = height > window.innerHeight ? "" : `${height}px`;
    outline.current.style.opacity = height && height > 300 ? "" : "0";
    outline.current.style.pointerEvents = height && height > 300 ? "" : "none";
  };
  (0, import_react53.useEffect)(() => {
    setHeight();
    setTimeout(setHeight, 100);
    const handleScroll2 = () => setHeight();
    window.addEventListener("scroll", handleScroll2);
    return () => {
      window.removeEventListener("scroll", handleScroll2);
    };
  }, [container.current, outline.current, transitionState]);
  (0, import_react53.useEffect)(() => {
    if (!existingContainer || !existingContainer.current)
      return;
    container.current = existingContainer.current;
  }, [existingContainer == null ? void 0 : existingContainer.current]);
  return { container, outline };
}
var DocumentOutline = ({
  outlineRef,
  top = 0,
  className,
  selector = SELECTOR,
  children,
  maxdepth = 4
}) => {
  const { activeId, headings, highlight } = useHeaders(selector, maxdepth);
  if (headings.length <= 1 || !onClient) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("nav", { suppressHydrationWarning: true, children }, void 0, false, {
      fileName: "../../packages/site/src/components/DocumentOutline.tsx",
      lineNumber: 247,
      columnNumber: 12
    }, this);
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(
    "nav",
    {
      ref: outlineRef,
      "aria-label": "Document Outline",
      className: (0, import_classnames21.default)(
        "not-prose overflow-y-auto",
        "transition-opacity duration-700",
        // Animation on load
        className
      ),
      style: {
        top,
        maxHeight: `calc(100vh - ${top + 20}px)`
      },
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("div", { className: "mb-4 text-sm leading-6 uppercase text-slate-900 dark:text-slate-100", children: "In this article" }, void 0, false, {
          fileName: "../../packages/site/src/components/DocumentOutline.tsx",
          lineNumber: 263,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(Headings, { headings, activeId, highlight, selector }, void 0, false, {
          fileName: "../../packages/site/src/components/DocumentOutline.tsx",
          lineNumber: 266,
          columnNumber: 7
        }, this),
        children
      ]
    },
    void 0,
    true,
    {
      fileName: "../../packages/site/src/components/DocumentOutline.tsx",
      lineNumber: 250,
      columnNumber: 5
    },
    this
  );
};

// ../../packages/site/src/components/FooterLinksBlock.tsx
var import_classnames22 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime3 = __toESM(require_jsx_dev_runtime(), 1);
var FooterLink = ({
  title,
  short_title,
  url,
  group: group2,
  right
}) => {
  const baseurl = useBaseurl();
  const Link2 = useLinkProvider();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
    Link2,
    {
      prefetch: "intent",
      className: "flex-1 block p-4 font-normal text-gray-600 no-underline border border-gray-200 rounded shadow-sm group hover:border-blue-600 dark:hover:border-blue-400 hover:text-blue-600 dark:hover:text-blue-400 dark:text-gray-100 dark:border-gray-500 hover:shadow-lg dark:shadow-neutral-700",
      to: withBaseurl(url, baseurl),
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("div", { className: "flex h-full align-middle", children: [
        right && /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
          ArrowLeftIcon_default,
          {
            width: "1.5rem",
            height: "1.5rem",
            className: "self-center transition-transform group-hover:-translate-x-1 shrink-0"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
            lineNumber: 23,
            columnNumber: 11
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("div", { className: (0, import_classnames22.default)("flex-grow", { "text-right": right }), children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("div", { className: "text-xs text-gray-500 dark:text-gray-400", children: group2 || " " }, void 0, false, {
            fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
            lineNumber: 30,
            columnNumber: 11
          }, this),
          short_title || title
        ] }, void 0, true, {
          fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
          lineNumber: 29,
          columnNumber: 9
        }, this),
        !right && /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
          ArrowRightIcon_default,
          {
            width: "1.5rem",
            height: "1.5rem",
            className: "self-center transition-transform group-hover:translate-x-1 shrink-0"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
            lineNumber: 34,
            columnNumber: 11
          },
          this
        )
      ] }, void 0, true, {
        fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
        lineNumber: 21,
        columnNumber: 7
      }, this)
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
      lineNumber: 16,
      columnNumber: 5
    },
    this
  );
};
function FooterLinksBlock({ links }) {
  var _a, _b, _c, _d, _e, _f;
  if (!links || !((_a = links.navigation) == null ? void 0 : _a.prev) && !((_b = links.navigation) == null ? void 0 : _b.next))
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("div", { className: "flex pt-10 mb-10 space-x-4", children: [
    ((_c = links.navigation) == null ? void 0 : _c.prev) && /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(FooterLink, { ...(_d = links.navigation) == null ? void 0 : _d.prev, right: true }, void 0, false, {
      fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
      lineNumber: 49,
      columnNumber: 34
    }, this),
    ((_e = links.navigation) == null ? void 0 : _e.next) && /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(FooterLink, { ...(_f = links.navigation) == null ? void 0 : _f.next }, void 0, false, {
      fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
      lineNumber: 50,
      columnNumber: 34
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
    lineNumber: 48,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/ContentReload.tsx
var import_react54 = __toESM(require_react(), 1);
var STORAGE_KEY = "myst";
async function mystLiveReloadConnect(config) {
  if (!config.port || window.mystLiveReloadConnected)
    return;
  window.mystLiveReloadConnected = true;
  setTimeout(() => {
    const myst = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || "{}");
    if (myst.scroll) {
      window.scrollTo(0, myst.scroll);
      sessionStorage.removeItem(STORAGE_KEY);
    }
  }, 30);
  console.log(`\u{1F50A} Listening to live content changes on port ${config.port}`);
  const protocol = location.protocol === "https:" ? "wss:" : "ws:";
  const host = location.hostname;
  const socketPath = `${protocol}//${host}:${config.port}/socket`;
  const ws = new WebSocket(socketPath);
  ws.onmessage = (message) => {
    const event = JSON.parse(message.data);
    if (event.type === "LOG") {
      console.log(event.message);
    }
    if (event.type === "RELOAD") {
      console.log("\u{1F680} Reloading window ...");
      console.log(`\u{1F4CC} Keeping scroll for page at ${window.scrollY}`);
      const myst = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || "{}");
      myst.scroll = window.scrollY;
      sessionStorage.setItem(STORAGE_KEY, JSON.stringify(myst));
      window.location.reload();
    }
  };
  ws.onopen = () => {
    if (config && typeof config.onOpen === "function") {
      config.onOpen();
    }
  };
  ws.onclose = () => {
    console.log("MyST content server web socket closed. Reconnecting...");
    setTimeout(
      () => mystLiveReloadConnect({
        ...config,
        onOpen: () => window.location.reload()
      }),
      1e3
    );
  };
  ws.onerror = (error) => {
    console.log("MyST content server web socket error:");
    console.error(error);
  };
}
function ContentReload({ port }) {
  (0, import_react54.useEffect)(() => {
    mystLiveReloadConnect({ port });
  }, []);
  return null;
}

// ../../packages/site/src/components/Bibliography.tsx
var import_classnames23 = __toESM(require_classnames(), 1);
var import_react55 = __toESM(require_react(), 1);
var import_jsx_dev_runtime4 = __toESM(require_jsx_dev_runtime(), 1);
var HIDE_OVER_N_REFERENCES = 5;
function Bibliography() {
  var _a;
  const references = useReferences();
  const grid = useGridSystemProvider();
  const { order, data } = (_a = references == null ? void 0 : references.cite) != null ? _a : {};
  const filtered = order == null ? void 0 : order.filter((l7) => l7);
  const [hidden, setHidden] = (0, import_react55.useState)(true);
  if (!filtered || !data || filtered.length === 0)
    return null;
  const refs = hidden ? filtered.slice(0, HIDE_OVER_N_REFERENCES) : filtered;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("section", { id: "references", className: (0, import_classnames23.default)(grid, "subgrid-gap col-screen"), children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("div", { children: [
      filtered.length > HIDE_OVER_N_REFERENCES && /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
        "button",
        {
          onClick: () => setHidden(!hidden),
          className: "float-right p-1 px-2 text-xs border rounded hover:border-blue-500 dark:hover:border-blue-400",
          children: hidden ? "Show All" : "Collapse"
        },
        void 0,
        false,
        {
          fileName: "../../packages/site/src/components/Bibliography.tsx",
          lineNumber: 20,
          columnNumber: 11
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("header", { className: "text-lg font-semibold text-stone-900 dark:text-white group", children: [
        "References",
        /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(HashLink, { id: "references", title: "Link to References", hover: true, className: "ml-2" }, void 0, false, {
          fileName: "../../packages/site/src/components/Bibliography.tsx",
          lineNumber: 29,
          columnNumber: 11
        }, this)
      ] }, void 0, true, {
        fileName: "../../packages/site/src/components/Bibliography.tsx",
        lineNumber: 27,
        columnNumber: 9
      }, this)
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Bibliography.tsx",
      lineNumber: 18,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("div", { className: "pl-3 mb-8 text-xs text-stone-500 dark:text-stone-300", children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("ol", { children: [
      refs.map((label) => {
        const { html } = data[label];
        return /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
          "li",
          {
            className: "break-words",
            id: `cite-${label}`,
            dangerouslySetInnerHTML: { __html: html || "" }
          },
          label,
          false,
          {
            fileName: "../../packages/site/src/components/Bibliography.tsx",
            lineNumber: 37,
            columnNumber: 15
          },
          this
        );
      }),
      filtered.length > HIDE_OVER_N_REFERENCES && /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("li", { className: "text-center list-none", children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
        "button",
        {
          onClick: () => setHidden(!hidden),
          className: "p-2 border rounded hover:border-blue-500 dark:hover:border-blue-400",
          children: hidden ? `Show all ${filtered.length} references` : "Collapse references"
        },
        void 0,
        false,
        {
          fileName: "../../packages/site/src/components/Bibliography.tsx",
          lineNumber: 47,
          columnNumber: 15
        },
        this
      ) }, void 0, false, {
        fileName: "../../packages/site/src/components/Bibliography.tsx",
        lineNumber: 46,
        columnNumber: 13
      }, this)
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Bibliography.tsx",
      lineNumber: 33,
      columnNumber: 9
    }, this) }, void 0, false, {
      fileName: "../../packages/site/src/components/Bibliography.tsx",
      lineNumber: 32,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Bibliography.tsx",
    lineNumber: 17,
    columnNumber: 5
  }, this);
}

// ../../packages/frontmatter/dist/FrontmatterBlock.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var import_classnames27 = __toESM(require_classnames(), 1);

// ../../packages/frontmatter/dist/licenses.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var import_classnames24 = __toESM(require_classnames(), 1);
function CreativeCommonsBadge({ license, preamble = "", className }) {
  var _a;
  const match = /^([CBYSAND0-]+)(?:(?:-)([0-9].[0-9]))?$/.exec(license.id);
  if (!license.CC || !match)
    return null;
  const title = `${preamble}${(_a = license.name) !== null && _a !== void 0 ? _a : license.title} (${license.id})`;
  const kind = match[1].toUpperCase();
  return (0, import_jsx_runtime60.jsxs)("a", { href: license.url, target: "_blank", rel: "noopener noreferrer", className: (0, import_classnames24.default)("opacity-50 hover:opacity-100 text-inherit hover:text-inherit", className), "aria-label": title, children: [(0, import_jsx_runtime60.jsx)(CcIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block mx-1", title }), (kind.startsWith("CC0") || kind.startsWith("CC-0") || kind.includes("ZERO")) && (0, import_jsx_runtime60.jsx)(CcZeroIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block mr-1", title: "CC0: Work is in the worldwide public domain" }), kind.includes("BY") && (0, import_jsx_runtime60.jsx)(CcByIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block mr-1", title: "Credit must be given to the creator" }), kind.includes("NC") && (0, import_jsx_runtime60.jsx)(CcNcIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block mr-1", title: "Only noncommercial uses of the work are permitted" }), kind.includes("SA") && (0, import_jsx_runtime60.jsx)(CcSaIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block mr-1", title: "Adaptations must be shared under the same terms" }), kind.includes("ND") && (0, import_jsx_runtime60.jsx)(CcNdIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block mr-1", title: "No derivatives or adaptations of the work are permitted" })] });
}
function SingleLicenseBadge({ license: possibleLicense, preamble = "", className }) {
  var _a;
  if (!possibleLicense)
    return null;
  const license = typeof possibleLicense === "string" ? { name: "", url: "", id: possibleLicense } : possibleLicense;
  if (!license || Object.keys(license).length === 0)
    return null;
  if (license.CC) {
    return (0, import_jsx_runtime60.jsx)(CreativeCommonsBadge, { license, preamble, className });
  }
  return (0, import_jsx_runtime60.jsxs)("a", { href: license.url || void 0, target: "_blank", rel: "noopener noreferrer", title: `${preamble}${(_a = license.name) !== null && _a !== void 0 ? _a : license.title} (${license.id})`, className: "text-inherit hover:text-inherit", children: [!license.osi && (0, import_jsx_runtime60.jsx)(ScaleIcon_default, { width: "1.25rem", height: "1.25rem", className: (0, import_classnames24.default)("mx-1 inline-block opacity-60 hover:opacity-100", className) }), license.osi && (0, import_jsx_runtime60.jsx)(OsiIcon_default, { width: "1.25rem", height: "1.25rem", className: (0, import_classnames24.default)("mx-1 inline-block opacity-60 hover:opacity-100 hover:text-[#599F46]", className) })] });
}
function LicenseBadges({ license, className }) {
  if (!license)
    return null;
  if (typeof license !== "string" && ("code" in license || "content" in license)) {
    return (0, import_jsx_runtime60.jsxs)(import_jsx_runtime60.Fragment, { children: [(0, import_jsx_runtime60.jsx)(SingleLicenseBadge, { license: license.content, preamble: "Content License: ", className }), (0, import_jsx_runtime60.jsx)(SingleLicenseBadge, { license: license.code, preamble: "Code License: ", className })] });
  }
  return (0, import_jsx_runtime60.jsx)(SingleLicenseBadge, { license, className });
}

// ../../packages/frontmatter/dist/downloads.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var import_react56 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/env.js
var i = Object.defineProperty;
var d = (t10, e4, n4) => e4 in t10 ? i(t10, e4, { enumerable: true, configurable: true, writable: true, value: n4 }) : t10[e4] = n4;
var r = (t10, e4, n4) => (d(t10, typeof e4 != "symbol" ? e4 + "" : e4, n4), n4);
var o = class {
  constructor() {
    r(this, "current", this.detect());
    r(this, "handoffState", "pending");
    r(this, "currentId", 0);
  }
  set(e4) {
    this.current !== e4 && (this.handoffState = "pending", this.currentId = 0, this.current = e4);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
};
var s = new o();

// ../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var l = (e4, f6) => {
  s.isServer ? (0, import_react56.useEffect)(e4, f6) : (0, import_react56.useLayoutEffect)(e4, f6);
};

// ../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js
var import_react57 = __toESM(require_react(), 1);
function s2(e4) {
  let r4 = (0, import_react57.useRef)(e4);
  return l(() => {
    r4.current = e4;
  }, [e4]), r4;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-disposables.js
var import_react58 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/micro-task.js
function t3(e4) {
  typeof queueMicrotask == "function" ? queueMicrotask(e4) : Promise.resolve().then(e4).catch((o10) => setTimeout(() => {
    throw o10;
  }));
}

// ../../node_modules/@headlessui/react/dist/utils/disposables.js
function o2() {
  let n4 = [], r4 = { addEventListener(e4, t10, s7, a4) {
    return e4.addEventListener(t10, s7, a4), r4.add(() => e4.removeEventListener(t10, s7, a4));
  }, requestAnimationFrame(...e4) {
    let t10 = requestAnimationFrame(...e4);
    return r4.add(() => cancelAnimationFrame(t10));
  }, nextFrame(...e4) {
    return r4.requestAnimationFrame(() => r4.requestAnimationFrame(...e4));
  }, setTimeout(...e4) {
    let t10 = setTimeout(...e4);
    return r4.add(() => clearTimeout(t10));
  }, microTask(...e4) {
    let t10 = { current: true };
    return t3(() => {
      t10.current && e4[0]();
    }), r4.add(() => {
      t10.current = false;
    });
  }, style(e4, t10, s7) {
    let a4 = e4.style.getPropertyValue(t10);
    return Object.assign(e4.style, { [t10]: s7 }), this.add(() => {
      Object.assign(e4.style, { [t10]: a4 });
    });
  }, group(e4) {
    let t10 = o2();
    return e4(t10), this.add(() => t10.dispose());
  }, add(e4) {
    return n4.push(e4), () => {
      let t10 = n4.indexOf(e4);
      if (t10 >= 0)
        for (let s7 of n4.splice(t10, 1))
          s7();
    };
  }, dispose() {
    for (let e4 of n4.splice(0))
      e4();
  } };
  return r4;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-disposables.js
function p() {
  let [e4] = (0, import_react58.useState)(o2);
  return (0, import_react58.useEffect)(() => () => e4.dispose(), [e4]), e4;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-event.js
var import_react59 = __toESM(require_react(), 1);
var o4 = function(t10) {
  let e4 = s2(t10);
  return import_react59.default.useCallback((...r4) => e4.current(...r4), [e4]);
};

// ../../node_modules/@headlessui/react/dist/hooks/use-id.js
var import_react60 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-server-handoff-complete.js
var t4 = __toESM(require_react(), 1);
function s4() {
  let r4 = typeof document == "undefined";
  return "useSyncExternalStore" in t4 ? ((o10) => o10.useSyncExternalStore)(t4)(() => () => {
  }, () => false, () => !r4) : false;
}
function l2() {
  let r4 = s4(), [e4, n4] = t4.useState(s.isHandoffComplete);
  return e4 && s.isHandoffComplete === false && n4(false), t4.useEffect(() => {
    e4 !== true && n4(true);
  }, [e4]), t4.useEffect(() => s.handoff(), []), r4 ? false : e4;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-id.js
var o5;
var I = (o5 = import_react60.default.useId) != null ? o5 : function() {
  let n4 = l2(), [e4, u4] = import_react60.default.useState(n4 ? () => s.nextId() : null);
  return l(() => {
    e4 === null && u4(s.nextId());
  }, [e4]), e4 != null ? "" + e4 : void 0;
};

// ../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js
var import_react63 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/match.js
function u(r4, n4, ...a4) {
  if (r4 in n4) {
    let e4 = n4[r4];
    return typeof e4 == "function" ? e4(...a4) : e4;
  }
  let t10 = new Error(`Tried to handle "${r4}" but there is no handler defined. Only defined handlers are: ${Object.keys(n4).map((e4) => `"${e4}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t10, u), t10;
}

// ../../node_modules/@headlessui/react/dist/utils/owner.js
function e3(r4) {
  return s.isServer ? null : r4 instanceof Node ? r4.ownerDocument : r4 != null && r4.hasOwnProperty("current") && r4.current instanceof Node ? r4.current.ownerDocument : document;
}

// ../../node_modules/@headlessui/react/dist/utils/focus-management.js
var c2 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e4) => `${e4}:not([tabindex='-1'])`).join(",");
var M = ((n4) => (n4[n4.First = 1] = "First", n4[n4.Previous = 2] = "Previous", n4[n4.Next = 4] = "Next", n4[n4.Last = 8] = "Last", n4[n4.WrapAround = 16] = "WrapAround", n4[n4.NoScroll = 32] = "NoScroll", n4))(M || {});
var N = ((o10) => (o10[o10.Error = 0] = "Error", o10[o10.Overflow = 1] = "Overflow", o10[o10.Success = 2] = "Success", o10[o10.Underflow = 3] = "Underflow", o10))(N || {});
var F = ((t10) => (t10[t10.Previous = -1] = "Previous", t10[t10.Next = 1] = "Next", t10))(F || {});
function f(e4 = document.body) {
  return e4 == null ? [] : Array.from(e4.querySelectorAll(c2)).sort((r4, t10) => Math.sign((r4.tabIndex || Number.MAX_SAFE_INTEGER) - (t10.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T = ((t10) => (t10[t10.Strict = 0] = "Strict", t10[t10.Loose = 1] = "Loose", t10))(T || {});
function h(e4, r4 = 0) {
  var t10;
  return e4 === ((t10 = e3(e4)) == null ? void 0 : t10.body) ? false : u(r4, { [0]() {
    return e4.matches(c2);
  }, [1]() {
    let l7 = e4;
    for (; l7 !== null; ) {
      if (l7.matches(c2))
        return true;
      l7 = l7.parentElement;
    }
    return false;
  } });
}
function D(e4) {
  let r4 = e3(e4);
  o2().nextFrame(() => {
    r4 && !h(r4.activeElement, 0) && y(e4);
  });
}
var w = ((t10) => (t10[t10.Keyboard = 0] = "Keyboard", t10[t10.Mouse = 1] = "Mouse", t10))(w || {});
typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e4) => {
  e4.metaKey || e4.altKey || e4.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true), document.addEventListener("click", (e4) => {
  e4.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e4.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true));
function y(e4) {
  e4 == null || e4.focus({ preventScroll: true });
}
var S = ["textarea", "input"].join(",");
function H(e4) {
  var r4, t10;
  return (t10 = (r4 = e4 == null ? void 0 : e4.matches) == null ? void 0 : r4.call(e4, S)) != null ? t10 : false;
}
function I2(e4, r4 = (t10) => t10) {
  return e4.slice().sort((t10, l7) => {
    let o10 = r4(t10), i5 = r4(l7);
    if (o10 === null || i5 === null)
      return 0;
    let n4 = o10.compareDocumentPosition(i5);
    return n4 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : n4 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function _3(e4, r4) {
  return O(f(), r4, { relativeTo: e4 });
}
function O(e4, r4, { sorted: t10 = true, relativeTo: l7 = null, skipElements: o10 = [] } = {}) {
  let i5 = Array.isArray(e4) ? e4.length > 0 ? e4[0].ownerDocument : document : e4.ownerDocument, n4 = Array.isArray(e4) ? t10 ? I2(e4) : e4 : f(e4);
  o10.length > 0 && n4.length > 1 && (n4 = n4.filter((s7) => !o10.includes(s7))), l7 = l7 != null ? l7 : i5.activeElement;
  let E4 = (() => {
    if (r4 & 5)
      return 1;
    if (r4 & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), x4 = (() => {
    if (r4 & 1)
      return 0;
    if (r4 & 2)
      return Math.max(0, n4.indexOf(l7)) - 1;
    if (r4 & 4)
      return Math.max(0, n4.indexOf(l7)) + 1;
    if (r4 & 8)
      return n4.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), p3 = r4 & 32 ? { preventScroll: true } : {}, d6 = 0, a4 = n4.length, u4;
  do {
    if (d6 >= a4 || d6 + a4 <= 0)
      return 0;
    let s7 = x4 + d6;
    if (r4 & 16)
      s7 = (s7 + a4) % a4;
    else {
      if (s7 < 0)
        return 3;
      if (s7 >= a4)
        return 1;
    }
    u4 = n4[s7], u4 == null || u4.focus(p3), d6 += E4;
  } while (u4 !== i5.activeElement);
  return r4 & 6 && H(u4) && u4.select(), 2;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-document-event.js
var import_react61 = __toESM(require_react(), 1);
function d2(e4, r4, n4) {
  let o10 = s2(r4);
  (0, import_react61.useEffect)(() => {
    function t10(u4) {
      o10.current(u4);
    }
    return document.addEventListener(e4, t10, n4), () => document.removeEventListener(e4, t10, n4);
  }, [e4, n4]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-window-event.js
var import_react62 = __toESM(require_react(), 1);
function s5(e4, r4, n4) {
  let o10 = s2(r4);
  (0, import_react62.useEffect)(() => {
    function t10(i5) {
      o10.current(i5);
    }
    return window.addEventListener(e4, t10, n4), () => window.removeEventListener(e4, t10, n4);
  }, [e4, n4]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js
function h2(s7, m4, a4 = true) {
  let i5 = (0, import_react63.useRef)(false);
  (0, import_react63.useEffect)(() => {
    requestAnimationFrame(() => {
      i5.current = a4;
    });
  }, [a4]);
  function c6(e4, r4) {
    if (!i5.current || e4.defaultPrevented)
      return;
    let t10 = r4(e4);
    if (t10 === null || !t10.getRootNode().contains(t10) || !t10.isConnected)
      return;
    let E4 = function u4(n4) {
      return typeof n4 == "function" ? u4(n4()) : Array.isArray(n4) || n4 instanceof Set ? n4 : [n4];
    }(s7);
    for (let u4 of E4) {
      if (u4 === null)
        continue;
      let n4 = u4 instanceof HTMLElement ? u4 : u4.current;
      if (n4 != null && n4.contains(t10) || e4.composed && e4.composedPath().includes(n4))
        return;
    }
    return !h(t10, T.Loose) && t10.tabIndex !== -1 && e4.preventDefault(), m4(e4, t10);
  }
  let o10 = (0, import_react63.useRef)(null);
  d2("pointerdown", (e4) => {
    var r4, t10;
    i5.current && (o10.current = ((t10 = (r4 = e4.composedPath) == null ? void 0 : r4.call(e4)) == null ? void 0 : t10[0]) || e4.target);
  }, true), d2("mousedown", (e4) => {
    var r4, t10;
    i5.current && (o10.current = ((t10 = (r4 = e4.composedPath) == null ? void 0 : r4.call(e4)) == null ? void 0 : t10[0]) || e4.target);
  }, true), d2("click", (e4) => {
    o10.current && (c6(e4, () => o10.current), o10.current = null);
  }, true), d2("touchend", (e4) => c6(e4, () => e4.target instanceof HTMLElement ? e4.target : null), true), s5("blur", (e4) => c6(e4, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js
var import_react64 = __toESM(require_react(), 1);
function i2(t10) {
  var n4;
  if (t10.type)
    return t10.type;
  let e4 = (n4 = t10.as) != null ? n4 : "button";
  if (typeof e4 == "string" && e4.toLowerCase() === "button")
    return "button";
}
function s6(t10, e4) {
  let [n4, u4] = (0, import_react64.useState)(() => i2(t10));
  return l(() => {
    u4(i2(t10));
  }, [t10.type, t10.as]), l(() => {
    n4 || e4.current && e4.current instanceof HTMLButtonElement && !e4.current.hasAttribute("type") && u4("button");
  }, [n4, e4]), n4;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js
var import_react65 = __toESM(require_react(), 1);
var u2 = Symbol();
function y2(...t10) {
  let n4 = (0, import_react65.useRef)(t10);
  (0, import_react65.useEffect)(() => {
    n4.current = t10;
  }, [t10]);
  let c6 = o4((e4) => {
    for (let o10 of n4.current)
      o10 != null && (typeof o10 == "function" ? o10(e4) : o10.current = e4);
  });
  return t10.every((e4) => e4 == null || (e4 == null ? void 0 : e4[u2])) ? void 0 : c6;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-tree-walker.js
var import_react66 = __toESM(require_react(), 1);
function F2({ container: e4, accept: t10, walk: r4, enabled: c6 = true }) {
  let o10 = (0, import_react66.useRef)(t10), l7 = (0, import_react66.useRef)(r4);
  (0, import_react66.useEffect)(() => {
    o10.current = t10, l7.current = r4;
  }, [t10, r4]), l(() => {
    if (!e4 || !c6)
      return;
    let n4 = e3(e4);
    if (!n4)
      return;
    let f6 = o10.current, p3 = l7.current, d6 = Object.assign((i5) => f6(i5), { acceptNode: f6 }), u4 = n4.createTreeWalker(e4, NodeFilter.SHOW_ELEMENT, d6, false);
    for (; u4.nextNode(); )
      p3(u4.currentNode);
  }, [e4, c6, o10, l7]);
}

// ../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js
function f3(r4) {
  throw new Error("Unexpected object: " + r4);
}
var a2 = ((e4) => (e4[e4.First = 0] = "First", e4[e4.Previous = 1] = "Previous", e4[e4.Next = 2] = "Next", e4[e4.Last = 3] = "Last", e4[e4.Specific = 4] = "Specific", e4[e4.Nothing = 5] = "Nothing", e4))(a2 || {});
function x(r4, n4) {
  let t10 = n4.resolveItems();
  if (t10.length <= 0)
    return null;
  let l7 = n4.resolveActiveIndex(), s7 = l7 != null ? l7 : -1, d6 = (() => {
    switch (r4.focus) {
      case 0:
        return t10.findIndex((e4) => !n4.resolveDisabled(e4));
      case 1: {
        let e4 = t10.slice().reverse().findIndex((i5, c6, u4) => s7 !== -1 && u4.length - c6 - 1 >= s7 ? false : !n4.resolveDisabled(i5));
        return e4 === -1 ? e4 : t10.length - 1 - e4;
      }
      case 2:
        return t10.findIndex((e4, i5) => i5 <= s7 ? false : !n4.resolveDisabled(e4));
      case 3: {
        let e4 = t10.slice().reverse().findIndex((i5) => !n4.resolveDisabled(i5));
        return e4 === -1 ? e4 : t10.length - 1 - e4;
      }
      case 4:
        return t10.findIndex((e4) => n4.resolveId(e4) === r4.id);
      case 5:
        return null;
      default:
        f3(r4);
    }
  })();
  return d6 === -1 ? l7 : d6;
}

// ../../node_modules/@headlessui/react/dist/utils/render.js
var import_react67 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/class-names.js
function t6(...r4) {
  return Array.from(new Set(r4.flatMap((n4) => typeof n4 == "string" ? n4.split(" ") : []))).filter(Boolean).join(" ");
}

// ../../node_modules/@headlessui/react/dist/utils/render.js
var S2 = ((a4) => (a4[a4.None = 0] = "None", a4[a4.RenderStrategy = 1] = "RenderStrategy", a4[a4.Static = 2] = "Static", a4))(S2 || {});
var j = ((e4) => (e4[e4.Unmount = 0] = "Unmount", e4[e4.Hidden = 1] = "Hidden", e4))(j || {});
function X({ ourProps: r4, theirProps: t10, slot: e4, defaultTag: a4, features: s7, visible: n4 = true, name: f6 }) {
  let o10 = N2(t10, r4);
  if (n4)
    return c3(o10, e4, a4, f6);
  let u4 = s7 != null ? s7 : 0;
  if (u4 & 2) {
    let { static: l7 = false, ...p3 } = o10;
    if (l7)
      return c3(p3, e4, a4, f6);
  }
  if (u4 & 1) {
    let { unmount: l7 = true, ...p3 } = o10;
    return u(l7 ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return c3({ ...p3, hidden: true, style: { display: "none" } }, e4, a4, f6);
    } });
  }
  return c3(o10, e4, a4, f6);
}
function c3(r4, t10 = {}, e4, a4) {
  let { as: s7 = e4, children: n4, refName: f6 = "ref", ...o10 } = g(r4, ["unmount", "static"]), u4 = r4.ref !== void 0 ? { [f6]: r4.ref } : {}, l7 = typeof n4 == "function" ? n4(t10) : n4;
  "className" in o10 && o10.className && typeof o10.className == "function" && (o10.className = o10.className(t10));
  let p3 = {};
  if (t10) {
    let i5 = false, m4 = [];
    for (let [y3, d6] of Object.entries(t10))
      typeof d6 == "boolean" && (i5 = true), d6 === true && m4.push(y3);
    i5 && (p3["data-headlessui-state"] = m4.join(" "));
  }
  if (s7 === import_react67.Fragment && Object.keys(R(o10)).length > 0) {
    if (!(0, import_react67.isValidElement)(l7) || Array.isArray(l7) && l7.length > 1)
      throw new Error(['Passing props on "Fragment"!', "", `The current component <${a4} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(o10).map((d6) => `  - ${d6}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((d6) => `  - ${d6}`).join(`
`)].join(`
`));
    let i5 = l7.props, m4 = typeof (i5 == null ? void 0 : i5.className) == "function" ? (...d6) => t6(i5 == null ? void 0 : i5.className(...d6), o10.className) : t6(i5 == null ? void 0 : i5.className, o10.className), y3 = m4 ? { className: m4 } : {};
    return (0, import_react67.cloneElement)(l7, Object.assign({}, N2(l7.props, R(g(o10, ["ref"]))), p3, u4, w2(l7.ref, u4.ref), y3));
  }
  return (0, import_react67.createElement)(s7, Object.assign({}, g(o10, ["ref"]), s7 !== import_react67.Fragment && u4, s7 !== import_react67.Fragment && p3), l7);
}
function w2(...r4) {
  return { ref: r4.every((t10) => t10 == null) ? void 0 : (t10) => {
    for (let e4 of r4)
      e4 != null && (typeof e4 == "function" ? e4(t10) : e4.current = t10);
  } };
}
function N2(...r4) {
  var a4;
  if (r4.length === 0)
    return {};
  if (r4.length === 1)
    return r4[0];
  let t10 = {}, e4 = {};
  for (let s7 of r4)
    for (let n4 in s7)
      n4.startsWith("on") && typeof s7[n4] == "function" ? ((a4 = e4[n4]) != null || (e4[n4] = []), e4[n4].push(s7[n4])) : t10[n4] = s7[n4];
  if (t10.disabled || t10["aria-disabled"])
    return Object.assign(t10, Object.fromEntries(Object.keys(e4).map((s7) => [s7, void 0])));
  for (let s7 in e4)
    Object.assign(t10, { [s7](n4, ...f6) {
      let o10 = e4[s7];
      for (let u4 of o10) {
        if ((n4 instanceof Event || (n4 == null ? void 0 : n4.nativeEvent) instanceof Event) && n4.defaultPrevented)
          return;
        u4(n4, ...f6);
      }
    } });
  return t10;
}
function D2(r4) {
  var t10;
  return Object.assign((0, import_react67.forwardRef)(r4), { displayName: (t10 = r4.displayName) != null ? t10 : r4.name });
}
function R(r4) {
  let t10 = Object.assign({}, r4);
  for (let e4 in t10)
    t10[e4] === void 0 && delete t10[e4];
  return t10;
}
function g(r4, t10 = []) {
  let e4 = Object.assign({}, r4);
  for (let a4 of t10)
    a4 in e4 && delete e4[a4];
  return e4;
}

// ../../node_modules/@headlessui/react/dist/utils/bugs.js
function r2(n4) {
  let e4 = n4.parentElement, l7 = null;
  for (; e4 && !(e4 instanceof HTMLFieldSetElement); )
    e4 instanceof HTMLLegendElement && (l7 = e4), e4 = e4.parentElement;
  let t10 = (e4 == null ? void 0 : e4.getAttribute("disabled")) === "";
  return t10 && i4(l7) ? false : t10;
}
function i4(n4) {
  if (!n4)
    return false;
  let e4 = n4.previousElementSibling;
  for (; e4 !== null; ) {
    if (e4 instanceof HTMLLegendElement)
      return false;
    e4 = e4.previousElementSibling;
  }
  return true;
}

// ../../node_modules/@headlessui/react/dist/internal/open-closed.js
var import_react68 = __toESM(require_react(), 1);
var n = (0, import_react68.createContext)(null);
n.displayName = "OpenClosedContext";
var d5 = ((e4) => (e4[e4.Open = 1] = "Open", e4[e4.Closed = 2] = "Closed", e4[e4.Closing = 4] = "Closing", e4[e4.Opening = 8] = "Opening", e4))(d5 || {});
function C() {
  return (0, import_react68.useContext)(n);
}
function c4({ value: o10, children: r4 }) {
  return import_react68.default.createElement(n.Provider, { value: o10 }, r4);
}

// ../../node_modules/@headlessui/react/dist/components/keyboard.js
var o7 = ((r4) => (r4.Space = " ", r4.Enter = "Enter", r4.Escape = "Escape", r4.Backspace = "Backspace", r4.Delete = "Delete", r4.ArrowLeft = "ArrowLeft", r4.ArrowUp = "ArrowUp", r4.ArrowRight = "ArrowRight", r4.ArrowDown = "ArrowDown", r4.Home = "Home", r4.End = "End", r4.PageUp = "PageUp", r4.PageDown = "PageDown", r4.Tab = "Tab", r4))(o7 || {});

// ../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js
var import_react69 = __toESM(require_react(), 1);
function t8(e4) {
  return [e4.screenX, e4.screenY];
}
function u3() {
  let e4 = (0, import_react69.useRef)([-1, -1]);
  return { wasMoved(r4) {
    let n4 = t8(r4);
    return e4.current[0] === n4[0] && e4.current[1] === n4[1] ? false : (e4.current = n4, true);
  }, update(r4) {
    e4.current = t8(r4);
  } };
}

// ../../node_modules/@headlessui/react/dist/hooks/use-owner.js
var import_react70 = __toESM(require_react(), 1);
function n2(...e4) {
  return (0, import_react70.useMemo)(() => e3(...e4), [...e4]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-is-mounted.js
var import_react71 = __toESM(require_react(), 1);
function f4() {
  let e4 = (0, import_react71.useRef)(false);
  return l(() => (e4.current = true, () => {
    e4.current = false;
  }), []), e4;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-text-value.js
var import_react72 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/get-text-value.js
var a3 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o9(e4) {
  var r4, i5;
  let n4 = (r4 = e4.innerText) != null ? r4 : "", t10 = e4.cloneNode(true);
  if (!(t10 instanceof HTMLElement))
    return n4;
  let u4 = false;
  for (let f6 of t10.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))
    f6.remove(), u4 = true;
  let l7 = u4 ? (i5 = t10.innerText) != null ? i5 : "" : n4;
  return a3.test(l7) && (l7 = l7.replace(a3, "")), l7;
}
function g2(e4) {
  let n4 = e4.getAttribute("aria-label");
  if (typeof n4 == "string")
    return n4.trim();
  let t10 = e4.getAttribute("aria-labelledby");
  if (t10) {
    let u4 = t10.split(" ").map((l7) => {
      let r4 = document.getElementById(l7);
      if (r4) {
        let i5 = r4.getAttribute("aria-label");
        return typeof i5 == "string" ? i5.trim() : o9(r4).trim();
      }
      return null;
    }).filter(Boolean);
    if (u4.length > 0)
      return u4.join(", ");
  }
  return o9(e4).trim();
}

// ../../node_modules/@headlessui/react/dist/hooks/use-text-value.js
function b2(c6) {
  let t10 = (0, import_react72.useRef)(""), r4 = (0, import_react72.useRef)("");
  return o4(() => {
    let e4 = c6.current;
    if (!e4)
      return "";
    let u4 = e4.innerText;
    if (t10.current === u4)
      return r4.current;
    let n4 = g2(e4).trim().toLowerCase();
    return t10.current = u4, r4.current = n4, n4;
  });
}

// ../../node_modules/@headlessui/react/dist/components/menu/menu.js
var import_react73 = __toESM(require_react(), 1);
var me = ((r4) => (r4[r4.Open = 0] = "Open", r4[r4.Closed = 1] = "Closed", r4))(me || {});
var de = ((r4) => (r4[r4.Pointer = 0] = "Pointer", r4[r4.Other = 1] = "Other", r4))(de || {});
var fe = ((a4) => (a4[a4.OpenMenu = 0] = "OpenMenu", a4[a4.CloseMenu = 1] = "CloseMenu", a4[a4.GoToItem = 2] = "GoToItem", a4[a4.Search = 3] = "Search", a4[a4.ClearSearch = 4] = "ClearSearch", a4[a4.RegisterItem = 5] = "RegisterItem", a4[a4.UnregisterItem = 6] = "UnregisterItem", a4))(fe || {});
function w3(e4, u4 = (r4) => r4) {
  let r4 = e4.activeItemIndex !== null ? e4.items[e4.activeItemIndex] : null, i5 = I2(u4(e4.items.slice()), (t10) => t10.dataRef.current.domRef.current), s7 = r4 ? i5.indexOf(r4) : null;
  return s7 === -1 && (s7 = null), { items: i5, activeItemIndex: s7 };
}
var Te = { [1](e4) {
  return e4.menuState === 1 ? e4 : { ...e4, activeItemIndex: null, menuState: 1 };
}, [0](e4) {
  return e4.menuState === 0 ? e4 : { ...e4, __demoMode: false, menuState: 0 };
}, [2]: (e4, u4) => {
  var s7;
  let r4 = w3(e4), i5 = x(u4, { resolveItems: () => r4.items, resolveActiveIndex: () => r4.activeItemIndex, resolveId: (t10) => t10.id, resolveDisabled: (t10) => t10.dataRef.current.disabled });
  return { ...e4, ...r4, searchQuery: "", activeItemIndex: i5, activationTrigger: (s7 = u4.trigger) != null ? s7 : 1 };
}, [3]: (e4, u4) => {
  let i5 = e4.searchQuery !== "" ? 0 : 1, s7 = e4.searchQuery + u4.value.toLowerCase(), o10 = (e4.activeItemIndex !== null ? e4.items.slice(e4.activeItemIndex + i5).concat(e4.items.slice(0, e4.activeItemIndex + i5)) : e4.items).find((l7) => {
    var m4;
    return ((m4 = l7.dataRef.current.textValue) == null ? void 0 : m4.startsWith(s7)) && !l7.dataRef.current.disabled;
  }), a4 = o10 ? e4.items.indexOf(o10) : -1;
  return a4 === -1 || a4 === e4.activeItemIndex ? { ...e4, searchQuery: s7 } : { ...e4, searchQuery: s7, activeItemIndex: a4, activationTrigger: 1 };
}, [4](e4) {
  return e4.searchQuery === "" ? e4 : { ...e4, searchQuery: "", searchActiveItemIndex: null };
}, [5]: (e4, u4) => {
  let r4 = w3(e4, (i5) => [...i5, { id: u4.id, dataRef: u4.dataRef }]);
  return { ...e4, ...r4 };
}, [6]: (e4, u4) => {
  let r4 = w3(e4, (i5) => {
    let s7 = i5.findIndex((t10) => t10.id === u4.id);
    return s7 !== -1 && i5.splice(s7, 1), i5;
  });
  return { ...e4, ...r4, activationTrigger: 1 };
} };
var U = (0, import_react73.createContext)(null);
U.displayName = "MenuContext";
function O2(e4) {
  let u4 = (0, import_react73.useContext)(U);
  if (u4 === null) {
    let r4 = new Error(`<${e4} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r4, O2), r4;
  }
  return u4;
}
function ye(e4, u4) {
  return u(u4.type, Te, e4, u4);
}
var Ie = import_react73.Fragment;
function Me(e4, u4) {
  let { __demoMode: r4 = false, ...i5 } = e4, s7 = (0, import_react73.useReducer)(ye, { __demoMode: r4, menuState: r4 ? 0 : 1, buttonRef: (0, import_react73.createRef)(), itemsRef: (0, import_react73.createRef)(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: t10, itemsRef: o10, buttonRef: a4 }, l7] = s7, m4 = y2(u4);
  h2([a4, o10], (g4, R2) => {
    var p3;
    l7({ type: 1 }), h(R2, T.Loose) || (g4.preventDefault(), (p3 = a4.current) == null || p3.focus());
  }, t10 === 0);
  let I3 = o4(() => {
    l7({ type: 1 });
  }), A = (0, import_react73.useMemo)(() => ({ open: t10 === 0, close: I3 }), [t10, I3]), f6 = { ref: m4 };
  return import_react73.default.createElement(U.Provider, { value: s7 }, import_react73.default.createElement(c4, { value: u(t10, { [0]: d5.Open, [1]: d5.Closed }) }, X({ ourProps: f6, theirProps: i5, slot: A, defaultTag: Ie, name: "Menu" })));
}
var ge = "button";
function Re(e4, u4) {
  var R2;
  let r4 = I(), { id: i5 = `headlessui-menu-button-${r4}`, ...s7 } = e4, [t10, o10] = O2("Menu.Button"), a4 = y2(t10.buttonRef, u4), l7 = p(), m4 = o4((p3) => {
    switch (p3.key) {
      case o7.Space:
      case o7.Enter:
      case o7.ArrowDown:
        p3.preventDefault(), p3.stopPropagation(), o10({ type: 0 }), l7.nextFrame(() => o10({ type: 2, focus: a2.First }));
        break;
      case o7.ArrowUp:
        p3.preventDefault(), p3.stopPropagation(), o10({ type: 0 }), l7.nextFrame(() => o10({ type: 2, focus: a2.Last }));
        break;
    }
  }), I3 = o4((p3) => {
    switch (p3.key) {
      case o7.Space:
        p3.preventDefault();
        break;
    }
  }), A = o4((p3) => {
    if (r2(p3.currentTarget))
      return p3.preventDefault();
    e4.disabled || (t10.menuState === 0 ? (o10({ type: 1 }), l7.nextFrame(() => {
      var M4;
      return (M4 = t10.buttonRef.current) == null ? void 0 : M4.focus({ preventScroll: true });
    })) : (p3.preventDefault(), o10({ type: 0 })));
  }), f6 = (0, import_react73.useMemo)(() => ({ open: t10.menuState === 0 }), [t10]), g4 = { ref: a4, id: i5, type: s6(e4, t10.buttonRef), "aria-haspopup": "menu", "aria-controls": (R2 = t10.itemsRef.current) == null ? void 0 : R2.id, "aria-expanded": t10.menuState === 0, onKeyDown: m4, onKeyUp: I3, onClick: A };
  return X({ ourProps: g4, theirProps: s7, slot: f6, defaultTag: ge, name: "Menu.Button" });
}
var Ae = "div";
var be = S2.RenderStrategy | S2.Static;
function Ee(e4, u4) {
  var M4, b4;
  let r4 = I(), { id: i5 = `headlessui-menu-items-${r4}`, ...s7 } = e4, [t10, o10] = O2("Menu.Items"), a4 = y2(t10.itemsRef, u4), l7 = n2(t10.itemsRef), m4 = p(), I3 = C(), A = (() => I3 !== null ? (I3 & d5.Open) === d5.Open : t10.menuState === 0)();
  (0, import_react73.useEffect)(() => {
    let n4 = t10.itemsRef.current;
    n4 && t10.menuState === 0 && n4 !== (l7 == null ? void 0 : l7.activeElement) && n4.focus({ preventScroll: true });
  }, [t10.menuState, t10.itemsRef, l7]), F2({ container: t10.itemsRef.current, enabled: t10.menuState === 0, accept(n4) {
    return n4.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : n4.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(n4) {
    n4.setAttribute("role", "none");
  } });
  let f6 = o4((n4) => {
    var E4, P;
    switch (m4.dispose(), n4.key) {
      case o7.Space:
        if (t10.searchQuery !== "")
          return n4.preventDefault(), n4.stopPropagation(), o10({ type: 3, value: n4.key });
      case o7.Enter:
        if (n4.preventDefault(), n4.stopPropagation(), o10({ type: 1 }), t10.activeItemIndex !== null) {
          let { dataRef: S4 } = t10.items[t10.activeItemIndex];
          (P = (E4 = S4.current) == null ? void 0 : E4.domRef.current) == null || P.click();
        }
        D(t10.buttonRef.current);
        break;
      case o7.ArrowDown:
        return n4.preventDefault(), n4.stopPropagation(), o10({ type: 2, focus: a2.Next });
      case o7.ArrowUp:
        return n4.preventDefault(), n4.stopPropagation(), o10({ type: 2, focus: a2.Previous });
      case o7.Home:
      case o7.PageUp:
        return n4.preventDefault(), n4.stopPropagation(), o10({ type: 2, focus: a2.First });
      case o7.End:
      case o7.PageDown:
        return n4.preventDefault(), n4.stopPropagation(), o10({ type: 2, focus: a2.Last });
      case o7.Escape:
        n4.preventDefault(), n4.stopPropagation(), o10({ type: 1 }), o2().nextFrame(() => {
          var S4;
          return (S4 = t10.buttonRef.current) == null ? void 0 : S4.focus({ preventScroll: true });
        });
        break;
      case o7.Tab:
        n4.preventDefault(), n4.stopPropagation(), o10({ type: 1 }), o2().nextFrame(() => {
          _3(t10.buttonRef.current, n4.shiftKey ? M.Previous : M.Next);
        });
        break;
      default:
        n4.key.length === 1 && (o10({ type: 3, value: n4.key }), m4.setTimeout(() => o10({ type: 4 }), 350));
        break;
    }
  }), g4 = o4((n4) => {
    switch (n4.key) {
      case o7.Space:
        n4.preventDefault();
        break;
    }
  }), R2 = (0, import_react73.useMemo)(() => ({ open: t10.menuState === 0 }), [t10]), p3 = { "aria-activedescendant": t10.activeItemIndex === null || (M4 = t10.items[t10.activeItemIndex]) == null ? void 0 : M4.id, "aria-labelledby": (b4 = t10.buttonRef.current) == null ? void 0 : b4.id, id: i5, onKeyDown: f6, onKeyUp: g4, role: "menu", tabIndex: 0, ref: a4 };
  return X({ ourProps: p3, theirProps: s7, slot: R2, defaultTag: Ae, features: be, visible: A, name: "Menu.Items" });
}
var Se = import_react73.Fragment;
function Pe(e4, u4) {
  let r4 = I(), { id: i5 = `headlessui-menu-item-${r4}`, disabled: s7 = false, ...t10 } = e4, [o10, a4] = O2("Menu.Item"), l7 = o10.activeItemIndex !== null ? o10.items[o10.activeItemIndex].id === i5 : false, m4 = (0, import_react73.useRef)(null), I3 = y2(u4, m4);
  l(() => {
    if (o10.__demoMode || o10.menuState !== 0 || !l7 || o10.activationTrigger === 0)
      return;
    let T3 = o2();
    return T3.requestAnimationFrame(() => {
      var v2, B2;
      (B2 = (v2 = m4.current) == null ? void 0 : v2.scrollIntoView) == null || B2.call(v2, { block: "nearest" });
    }), T3.dispose;
  }, [o10.__demoMode, m4, l7, o10.menuState, o10.activationTrigger, o10.activeItemIndex]);
  let A = b2(m4), f6 = (0, import_react73.useRef)({ disabled: s7, domRef: m4, get textValue() {
    return A();
  } });
  l(() => {
    f6.current.disabled = s7;
  }, [f6, s7]), l(() => (a4({ type: 5, id: i5, dataRef: f6 }), () => a4({ type: 6, id: i5 })), [f6, i5]);
  let g4 = o4(() => {
    a4({ type: 1 });
  }), R2 = o4((T3) => {
    if (s7)
      return T3.preventDefault();
    a4({ type: 1 }), D(o10.buttonRef.current);
  }), p3 = o4(() => {
    if (s7)
      return a4({ type: 2, focus: a2.Nothing });
    a4({ type: 2, focus: a2.Specific, id: i5 });
  }), M4 = u3(), b4 = o4((T3) => M4.update(T3)), n4 = o4((T3) => {
    M4.wasMoved(T3) && (s7 || l7 || a4({ type: 2, focus: a2.Specific, id: i5, trigger: 0 }));
  }), E4 = o4((T3) => {
    M4.wasMoved(T3) && (s7 || l7 && a4({ type: 2, focus: a2.Nothing }));
  }), P = (0, import_react73.useMemo)(() => ({ active: l7, disabled: s7, close: g4 }), [l7, s7, g4]);
  return X({ ourProps: { id: i5, ref: I3, role: "menuitem", tabIndex: s7 === true ? void 0 : -1, "aria-disabled": s7 === true ? true : void 0, disabled: void 0, onClick: R2, onFocus: p3, onPointerEnter: b4, onMouseEnter: b4, onPointerMove: n4, onMouseMove: n4, onPointerLeave: E4, onMouseLeave: E4 }, theirProps: t10, slot: P, defaultTag: Se, name: "Menu.Item" });
}
var ve = D2(Me);
var xe = D2(Re);
var he = D2(Ee);
var De = D2(Pe);
var it = Object.assign(ve, { Button: xe, Items: he, Item: De });

// ../../node_modules/@headlessui/react/dist/hooks/use-flags.js
var import_react74 = __toESM(require_react(), 1);
function c5(a4 = 0) {
  let [l7, r4] = (0, import_react74.useState)(a4), t10 = f4(), o10 = (0, import_react74.useCallback)((e4) => {
    t10.current && r4((u4) => u4 | e4);
  }, [l7, t10]), m4 = (0, import_react74.useCallback)((e4) => Boolean(l7 & e4), [l7]), s7 = (0, import_react74.useCallback)((e4) => {
    t10.current && r4((u4) => u4 & ~e4);
  }, [r4, t10]), g4 = (0, import_react74.useCallback)((e4) => {
    t10.current && r4((u4) => u4 ^ e4);
  }, [r4]);
  return { flags: l7, addFlag: o10, hasFlag: m4, removeFlag: s7, toggleFlag: g4 };
}

// ../../node_modules/@headlessui/react/dist/components/transitions/transition.js
var import_react75 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/once.js
function l6(r4) {
  let e4 = { called: false };
  return (...t10) => {
    if (!e4.called)
      return e4.called = true, r4(...t10);
  };
}

// ../../node_modules/@headlessui/react/dist/components/transitions/utils/transition.js
function g3(t10, ...e4) {
  t10 && e4.length > 0 && t10.classList.add(...e4);
}
function v(t10, ...e4) {
  t10 && e4.length > 0 && t10.classList.remove(...e4);
}
function b3(t10, e4) {
  let n4 = o2();
  if (!t10)
    return n4.dispose;
  let { transitionDuration: m4, transitionDelay: a4 } = getComputedStyle(t10), [u4, p3] = [m4, a4].map((l7) => {
    let [r4 = 0] = l7.split(",").filter(Boolean).map((i5) => i5.includes("ms") ? parseFloat(i5) : parseFloat(i5) * 1e3).sort((i5, T3) => T3 - i5);
    return r4;
  }), o10 = u4 + p3;
  if (o10 !== 0) {
    n4.group((r4) => {
      r4.setTimeout(() => {
        e4(), r4.dispose();
      }, o10), r4.addEventListener(t10, "transitionrun", (i5) => {
        i5.target === i5.currentTarget && r4.dispose();
      });
    });
    let l7 = n4.addEventListener(t10, "transitionend", (r4) => {
      r4.target === r4.currentTarget && (e4(), l7());
    });
  } else
    e4();
  return n4.add(() => e4()), n4.dispose;
}
function M2(t10, e4, n4, m4) {
  let a4 = n4 ? "enter" : "leave", u4 = o2(), p3 = m4 !== void 0 ? l6(m4) : () => {
  };
  a4 === "enter" && (t10.removeAttribute("hidden"), t10.style.display = "");
  let o10 = u(a4, { enter: () => e4.enter, leave: () => e4.leave }), l7 = u(a4, { enter: () => e4.enterTo, leave: () => e4.leaveTo }), r4 = u(a4, { enter: () => e4.enterFrom, leave: () => e4.leaveFrom });
  return v(t10, ...e4.base, ...e4.enter, ...e4.enterTo, ...e4.enterFrom, ...e4.leave, ...e4.leaveFrom, ...e4.leaveTo, ...e4.entered), g3(t10, ...e4.base, ...o10, ...r4), u4.nextFrame(() => {
    v(t10, ...e4.base, ...o10, ...r4), g3(t10, ...e4.base, ...o10, ...l7), b3(t10, () => (v(t10, ...e4.base, ...o10), g3(t10, ...e4.base, ...e4.entered), p3()));
  }), u4.dispose;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-transition.js
function E3({ immediate: t10, container: s7, direction: n4, classes: u4, onStart: a4, onStop: c6 }) {
  let l7 = f4(), d6 = p(), e4 = s2(n4);
  l(() => {
    t10 && (e4.current = "enter");
  }, [t10]), l(() => {
    let r4 = o2();
    d6.add(r4.dispose);
    let i5 = s7.current;
    if (i5 && e4.current !== "idle" && l7.current)
      return r4.dispose(), a4.current(e4.current), r4.add(M2(i5, u4.current, e4.current === "enter", () => {
        r4.dispose(), c6.current(e4.current);
      })), r4.dispose;
  }, [n4]);
}

// ../../node_modules/@headlessui/react/dist/components/transitions/transition.js
function S3(t10 = "") {
  return t10.split(" ").filter((n4) => n4.trim().length > 1);
}
var _4 = (0, import_react75.createContext)(null);
_4.displayName = "TransitionContext";
var be2 = ((r4) => (r4.Visible = "visible", r4.Hidden = "hidden", r4))(be2 || {});
function Se2() {
  let t10 = (0, import_react75.useContext)(_4);
  if (t10 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return t10;
}
function Ne() {
  let t10 = (0, import_react75.useContext)(M3);
  if (t10 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return t10;
}
var M3 = (0, import_react75.createContext)(null);
M3.displayName = "NestingContext";
function U2(t10) {
  return "children" in t10 ? U2(t10.children) : t10.current.filter(({ el: n4 }) => n4.current !== null).filter(({ state: n4 }) => n4 === "visible").length > 0;
}
function oe(t10, n4) {
  let r4 = s2(t10), s7 = (0, import_react75.useRef)([]), y3 = f4(), D3 = p(), c6 = o4((i5, e4 = j.Hidden) => {
    let a4 = s7.current.findIndex(({ el: o10 }) => o10 === i5);
    a4 !== -1 && (u(e4, { [j.Unmount]() {
      s7.current.splice(a4, 1);
    }, [j.Hidden]() {
      s7.current[a4].state = "hidden";
    } }), D3.microTask(() => {
      var o10;
      !U2(s7) && y3.current && ((o10 = r4.current) == null || o10.call(r4));
    }));
  }), x4 = o4((i5) => {
    let e4 = s7.current.find(({ el: a4 }) => a4 === i5);
    return e4 ? e4.state !== "visible" && (e4.state = "visible") : s7.current.push({ el: i5, state: "visible" }), () => c6(i5, j.Unmount);
  }), p3 = (0, import_react75.useRef)([]), h4 = (0, import_react75.useRef)(Promise.resolve()), u4 = (0, import_react75.useRef)({ enter: [], leave: [], idle: [] }), v2 = o4((i5, e4, a4) => {
    p3.current.splice(0), n4 && (n4.chains.current[e4] = n4.chains.current[e4].filter(([o10]) => o10 !== i5)), n4 == null || n4.chains.current[e4].push([i5, new Promise((o10) => {
      p3.current.push(o10);
    })]), n4 == null || n4.chains.current[e4].push([i5, new Promise((o10) => {
      Promise.all(u4.current[e4].map(([f6, P]) => P)).then(() => o10());
    })]), e4 === "enter" ? h4.current = h4.current.then(() => n4 == null ? void 0 : n4.wait.current).then(() => a4(e4)) : a4(e4);
  }), d6 = o4((i5, e4, a4) => {
    Promise.all(u4.current[e4].splice(0).map(([o10, f6]) => f6)).then(() => {
      var o10;
      (o10 = p3.current.shift()) == null || o10();
    }).then(() => a4(e4));
  });
  return (0, import_react75.useMemo)(() => ({ children: s7, register: x4, unregister: c6, onStart: v2, onStop: d6, wait: h4, chains: u4 }), [x4, c6, s7, v2, d6, u4, h4]);
}
function xe2() {
}
var Pe2 = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function se(t10) {
  var r4;
  let n4 = {};
  for (let s7 of Pe2)
    n4[s7] = (r4 = t10[s7]) != null ? r4 : xe2;
  return n4;
}
function Re2(t10) {
  let n4 = (0, import_react75.useRef)(se(t10));
  return (0, import_react75.useEffect)(() => {
    n4.current = se(t10);
  }, [t10]), n4;
}
var ye2 = "div";
var ae = S2.RenderStrategy;
function De2(t10, n4) {
  var K2, Q;
  let { beforeEnter: r4, afterEnter: s7, beforeLeave: y3, afterLeave: D3, enter: c6, enterFrom: x4, enterTo: p3, entered: h4, leave: u4, leaveFrom: v2, leaveTo: d6, ...i5 } = t10, e4 = (0, import_react75.useRef)(null), a4 = y2(e4, n4), o10 = (K2 = i5.unmount) == null || K2 ? j.Unmount : j.Hidden, { show: f6, appear: P, initial: T3 } = Se2(), [l7, j2] = (0, import_react75.useState)(f6 ? "visible" : "hidden"), q2 = Ne(), { register: O3, unregister: V } = q2;
  (0, import_react75.useEffect)(() => O3(e4), [O3, e4]), (0, import_react75.useEffect)(() => {
    if (o10 === j.Hidden && e4.current) {
      if (f6 && l7 !== "visible") {
        j2("visible");
        return;
      }
      return u(l7, { ["hidden"]: () => V(e4), ["visible"]: () => O3(e4) });
    }
  }, [l7, e4, O3, V, f6, o10]);
  let k = s2({ base: S3(i5.className), enter: S3(c6), enterFrom: S3(x4), enterTo: S3(p3), entered: S3(h4), leave: S3(u4), leaveFrom: S3(v2), leaveTo: S3(d6) }), w4 = Re2({ beforeEnter: r4, afterEnter: s7, beforeLeave: y3, afterLeave: D3 }), G2 = l2();
  (0, import_react75.useEffect)(() => {
    if (G2 && l7 === "visible" && e4.current === null)
      throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [e4, l7, G2]);
  let ue = T3 && !P, z2 = P && f6 && T3, Te2 = (() => !G2 || ue ? "idle" : f6 ? "enter" : "leave")(), H3 = c5(0), de2 = o4((g4) => u(g4, { enter: () => {
    H3.addFlag(d5.Opening), w4.current.beforeEnter();
  }, leave: () => {
    H3.addFlag(d5.Closing), w4.current.beforeLeave();
  }, idle: () => {
  } })), fe2 = o4((g4) => u(g4, { enter: () => {
    H3.removeFlag(d5.Opening), w4.current.afterEnter();
  }, leave: () => {
    H3.removeFlag(d5.Closing), w4.current.afterLeave();
  }, idle: () => {
  } })), A = oe(() => {
    j2("hidden"), V(e4);
  }, q2);
  E3({ immediate: z2, container: e4, classes: k, direction: Te2, onStart: s2((g4) => {
    A.onStart(e4, g4, de2);
  }), onStop: s2((g4) => {
    A.onStop(e4, g4, fe2), g4 === "leave" && !U2(A) && (j2("hidden"), V(e4));
  }) });
  let R2 = i5, me2 = { ref: a4 };
  return z2 ? R2 = { ...R2, className: t6(i5.className, ...k.current.enter, ...k.current.enterFrom) } : (R2.className = t6(i5.className, (Q = e4.current) == null ? void 0 : Q.className), R2.className === "" && delete R2.className), import_react75.default.createElement(M3.Provider, { value: A }, import_react75.default.createElement(c4, { value: u(l7, { ["visible"]: d5.Open, ["hidden"]: d5.Closed }) | H3.flags }, X({ ourProps: me2, theirProps: R2, defaultTag: ye2, features: ae, visible: l7 === "visible", name: "Transition.Child" })));
}
function He(t10, n4) {
  let { show: r4, appear: s7 = false, unmount: y3 = true, ...D3 } = t10, c6 = (0, import_react75.useRef)(null), x4 = y2(c6, n4);
  l2();
  let p3 = C();
  if (r4 === void 0 && p3 !== null && (r4 = (p3 & d5.Open) === d5.Open), ![true, false].includes(r4))
    throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [h4, u4] = (0, import_react75.useState)(r4 ? "visible" : "hidden"), v2 = oe(() => {
    u4("hidden");
  }), [d6, i5] = (0, import_react75.useState)(true), e4 = (0, import_react75.useRef)([r4]);
  l(() => {
    d6 !== false && e4.current[e4.current.length - 1] !== r4 && (e4.current.push(r4), i5(false));
  }, [e4, r4]);
  let a4 = (0, import_react75.useMemo)(() => ({ show: r4, appear: s7, initial: d6 }), [r4, s7, d6]);
  (0, import_react75.useEffect)(() => {
    if (r4)
      u4("visible");
    else if (!U2(v2))
      u4("hidden");
    else {
      let T3 = c6.current;
      if (!T3)
        return;
      let l7 = T3.getBoundingClientRect();
      l7.x === 0 && l7.y === 0 && l7.width === 0 && l7.height === 0 && u4("hidden");
    }
  }, [r4, v2]);
  let o10 = { unmount: y3 }, f6 = o4(() => {
    var T3;
    d6 && i5(false), (T3 = t10.beforeEnter) == null || T3.call(t10);
  }), P = o4(() => {
    var T3;
    d6 && i5(false), (T3 = t10.beforeLeave) == null || T3.call(t10);
  });
  return import_react75.default.createElement(M3.Provider, { value: v2 }, import_react75.default.createElement(_4.Provider, { value: a4 }, X({ ourProps: { ...o10, as: import_react75.Fragment, children: import_react75.default.createElement(le, { ref: x4, ...o10, ...D3, beforeEnter: f6, beforeLeave: P }) }, theirProps: {}, defaultTag: import_react75.Fragment, features: ae, visible: h4 === "visible", name: "Transition" })));
}
function Fe(t10, n4) {
  let r4 = (0, import_react75.useContext)(_4) !== null, s7 = C() !== null;
  return import_react75.default.createElement(import_react75.default.Fragment, null, !r4 && s7 ? import_react75.default.createElement(W, { ref: n4, ...t10 }) : import_react75.default.createElement(le, { ref: n4, ...t10 }));
}
var W = D2(He);
var le = D2(De2);
var Le = D2(Fe);
var tt = Object.assign(W, { Child: Le, Root: W });

// ../../packages/frontmatter/dist/downloads.js
var import_classnames25 = __toESM(require_classnames(), 1);
var import_react77 = __toESM(require_react(), 1);
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function triggerDirectDownload(url, filename) {
  return __awaiter5(this, void 0, void 0, function* () {
    const resp = yield fetch(url);
    const blob = yield resp.blob();
    return triggerBlobDownload(blob, filename);
  });
}
function triggerBlobDownload(blob, filename) {
  return __awaiter5(this, void 0, void 0, function* () {
    if (window.navigator && window.navigator.msSaveOrOpenBlob)
      return window.navigator.msSaveOrOpenBlob(blob);
    const objectUrl = URL.createObjectURL(blob);
    const a4 = document.createElement("a");
    a4.href = objectUrl;
    a4.download = filename;
    a4.style.display = "none";
    a4.dispatchEvent(new MouseEvent("click", {
      bubbles: true,
      cancelable: true,
      view: window
    }));
    setTimeout(() => {
      URL.revokeObjectURL(objectUrl);
      a4.remove();
    }, 100);
    return true;
  });
}
function Download({ url, filename, format: format2, className }) {
  const clickDownload = (0, import_react77.useCallback)((e4) => {
    e4.preventDefault();
    triggerDirectDownload(url, filename);
  }, [url, filename]);
  return (0, import_jsx_runtime61.jsxs)("a", { className: (0, import_classnames25.default)(className, "flex"), href: url, onClick: clickDownload, children: [(0, import_jsx_runtime61.jsxs)("span", { className: "sr-only", children: ["Download as ", format2] }), (0, import_jsx_runtime61.jsx)(DocumentIcon_default, { width: "1.25rem", height: "1.25rem", className: "items-center inline-block mr-2", "aria-hidden": "true" }), filename] });
}
function DownloadsDropdown({ exports: exports2 }) {
  if (!exports2 || exports2.length === 0)
    return null;
  return (0, import_jsx_runtime61.jsxs)(it, { as: "div", className: "relative flex inline-block mx-1 grow-0", children: [(0, import_jsx_runtime61.jsxs)(it.Button, { className: "relative", children: [(0, import_jsx_runtime61.jsx)("span", { className: "sr-only", children: "Downloads" }), (0, import_jsx_runtime61.jsx)(ArrowDownTrayIcon_default, { width: "1.25rem", height: "1.25rem", className: "ml-2 -mr-1", "aria-hidden": "true" })] }), (0, import_jsx_runtime61.jsx)(it.Items, { className: "absolute overflow-hidden bg-white rounded-sm shadow-lg -right-1 dark:bg-slate-800 ring-1 ring-black ring-opacity-5 focus:outline-none", children: exports2.map(({ format: format2, filename, url }, index2) => (0, import_jsx_runtime61.jsx)(it.Item, { children: (0, import_jsx_runtime61.jsx)(Download, { className: "block p-3 no-underline hover:bg-stone-700 dark:hover:bg-stone-200 hover:text-white dark:hover:text-black", url, filename, format: format2 }) }, index2)) })] });
}

// ../../packages/frontmatter/dist/Authors.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var import_react82 = __toESM(require_react(), 1);
var import_classnames26 = __toESM(require_classnames(), 1);

// ../../packages/frontmatter/dist/AuthorPopover.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@radix-ui/react-popover/dist/index.mjs
init_extends();
var import_react81 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var import_react78 = __toESM(require_react(), 1);
var $3db38b7d1fb3fe6a$var$count = 0;
function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
  (0, import_react78.useEffect)(() => {
    var _edgeGuards$, _edgeGuards$2;
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());
    document.body.insertAdjacentElement("beforeend", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());
    $3db38b7d1fb3fe6a$var$count++;
    return () => {
      if ($3db38b7d1fb3fe6a$var$count === 1)
        document.querySelectorAll("[data-radix-focus-guard]").forEach(
          (node) => node.remove()
        );
      $3db38b7d1fb3fe6a$var$count--;
    };
  }, []);
}
function $3db38b7d1fb3fe6a$var$createFocusGuard() {
  const element2 = document.createElement("span");
  element2.setAttribute("data-radix-focus-guard", "");
  element2.tabIndex = 0;
  element2.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element2;
}

// ../../node_modules/@radix-ui/react-focus-scope/dist/index.mjs
init_extends();
var import_react79 = __toESM(require_react(), 1);
var $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var $d3863c46a17e8a28$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
var $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ (0, import_react79.forwardRef)((props, forwardedRef) => {
  const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;
  const [container1, setContainer] = (0, import_react79.useState)(null);
  const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);
  const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);
  const lastFocusedElementRef = (0, import_react79.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setContainer(node)
  );
  const focusScope = (0, import_react79.useRef)({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  (0, import_react79.useEffect)(() => {
    if (trapped) {
      let handleFocusIn = function(event) {
        if (focusScope.paused || !container1)
          return;
        const target = event.target;
        if (container1.contains(target))
          lastFocusedElementRef.current = target;
        else
          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
            select: true
          });
      }, handleFocusOut = function(event) {
        if (focusScope.paused || !container1)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container1.contains(relatedTarget))
          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
            select: true
          });
      }, handleMutations = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body)
          return;
        for (const mutation of mutations)
          if (mutation.removedNodes.length > 0)
            $d3863c46a17e8a28$var$focus(container1);
      };
      document.addEventListener("focusin", handleFocusIn);
      document.addEventListener("focusout", handleFocusOut);
      const mutationObserver = new MutationObserver(handleMutations);
      if (container1)
        mutationObserver.observe(container1, {
          childList: true,
          subtree: true
        });
      return () => {
        document.removeEventListener("focusin", handleFocusIn);
        document.removeEventListener("focusout", handleFocusOut);
        mutationObserver.disconnect();
      };
    }
  }, [
    trapped,
    container1,
    focusScope.paused
  ]);
  (0, import_react79.useEffect)(() => {
    if (container1) {
      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container1.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {
            select: true
          });
          if (document.activeElement === previouslyFocusedElement)
            $d3863c46a17e8a28$var$focus(container1);
        }
      }
      return () => {
        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container1.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented)
            $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
              select: true
            });
          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [
    container1,
    onMountAutoFocus,
    onUnmountAutoFocus,
    focusScope
  ]);
  const handleKeyDown = (0, import_react79.useCallback)((event) => {
    if (!loop && !trapped)
      return;
    if (focusScope.paused)
      return;
    const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
    const focusedElement = document.activeElement;
    if (isTabKey && focusedElement) {
      const container = event.currentTarget;
      const [first2, last2] = $d3863c46a17e8a28$var$getTabbableEdges(container);
      const hasTabbableElementsInside = first2 && last2;
      if (!hasTabbableElementsInside) {
        if (focusedElement === container)
          event.preventDefault();
      } else {
        if (!event.shiftKey && focusedElement === last2) {
          event.preventDefault();
          if (loop)
            $d3863c46a17e8a28$var$focus(first2, {
              select: true
            });
        } else if (event.shiftKey && focusedElement === first2) {
          event.preventDefault();
          if (loop)
            $d3863c46a17e8a28$var$focus(last2, {
              select: true
            });
        }
      }
    }
  }, [
    loop,
    trapped,
    focusScope.paused
  ]);
  return /* @__PURE__ */ (0, import_react79.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    tabIndex: -1
  }, scopeProps, {
    ref: composedRefs,
    onKeyDown: handleKeyDown
  }));
});
function $d3863c46a17e8a28$var$focusFirst(candidates, { select: select2 = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    $d3863c46a17e8a28$var$focus(candidate, {
      select: select2
    });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function $d3863c46a17e8a28$var$getTabbableEdges(container) {
  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);
  const first2 = $d3863c46a17e8a28$var$findVisible(candidates, container);
  const last2 = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);
  return [
    first2,
    last2
  ];
}
function $d3863c46a17e8a28$var$getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function $d3863c46a17e8a28$var$findVisible(elements, container) {
  for (const element2 of elements) {
    if (!$d3863c46a17e8a28$var$isHidden(element2, {
      upTo: container
    }))
      return element2;
  }
}
function $d3863c46a17e8a28$var$isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function $d3863c46a17e8a28$var$isSelectableInput(element2) {
  return element2 instanceof HTMLInputElement && "select" in element2;
}
function $d3863c46a17e8a28$var$focus(element2, { select: select2 = false } = {}) {
  if (element2 && element2.focus) {
    const previouslyFocusedElement = document.activeElement;
    element2.focus({
      preventScroll: true
    });
    if (element2 !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element2) && select2)
      element2.select();
  }
}
var $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();
function $d3863c46a17e8a28$var$createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope)
        activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _stack$;
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();
    }
  };
}
function $d3863c46a17e8a28$var$arrayRemove(array, item) {
  const updatedArray = [
    ...array
  ];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1)
    updatedArray.splice(index2, 1);
  return updatedArray;
}
function $d3863c46a17e8a28$var$removeLinks(items) {
  return items.filter(
    (item) => item.tagName !== "A"
  );
}

// ../../node_modules/@radix-ui/react-id/dist/index.mjs
var $2AODx$react = __toESM(require_react(), 1);
var $1746a345f3d73bb7$var$useReactId = $2AODx$react["useId".toString()] || (() => void 0);
var $1746a345f3d73bb7$var$count = 0;
function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
  const [id, setId] = $2AODx$react.useState($1746a345f3d73bb7$var$useReactId());
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (!deterministicId)
      setId(
        (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
      );
  }, [
    deterministicId
  ]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// ../../node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x4) {
    return Boolean(x4);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes2 = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        var attr = node.getAttribute(controlAttribute);
        var alreadyHidden = attr !== null && attr !== "false";
        var counterValue = (counterMap.get(node) || 0) + 1;
        var markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenNodes2.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node, true);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node.setAttribute(controlAttribute, "true");
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes2.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
init_tslib_es6();
var React74 = __toESM(require_react());

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
init_tslib_es6();
var React70 = __toESM(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// ../../node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// ../../node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react80 = __toESM(require_react());
function useCallbackRef(initialValue, callback) {
  var ref = (0, import_react80.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last2 = ref.value;
          if (last2 !== value) {
            ref.value = value;
            ref.callback(value, last2);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// ../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js
function useMergeRefs(refs, defaultValue) {
  return useCallbackRef(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}

// ../../node_modules/use-sidecar/dist/es2015/medium.js
init_tslib_es6();
function ItoI(a4) {
  return a4;
}
function innerCreateMedium(defaults, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware2(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x4) {
          return x4 !== item;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
      }
      buffer = {
        push: function(x4) {
          return cb2(x4);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x4) {
          pendingQueue.push(x4);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// ../../node_modules/use-sidecar/dist/es2015/exports.js
init_tslib_es6();
var React69 = __toESM(require_react());
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest2 = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React69.createElement(Target, __assign({}, rest2));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// ../../node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React70.forwardRef(function(props, parentRef) {
  var ref = React70.useRef(null);
  var _a = React70.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, rest2 = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest2), callbacks);
  return React70.createElement(
    React70.Fragment,
    null,
    enabled && React70.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
    forwardProps ? React70.cloneElement(React70.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React70.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
init_tslib_es6();
var React73 = __toESM(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React72 = __toESM(require_react());

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var React71 = __toESM(require_react());

// ../../node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// ../../node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter2 = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter2 == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter2++;
    },
    remove: function() {
      counter2--;
      if (!counter2 && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React71.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x4) {
  return parseInt(x4 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var RemoveScrollBar = function(props) {
  var noRelative = props.noRelative, noImportant = props.noImportant, _a = props.gapMode, gapMode = _a === void 0 ? "margin" : _a;
  var gap = React72.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React72.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// ../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// ../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), s7 = _a[1], d6 = _a[2];
      if (s7 > d6) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x4, y3) {
  return x4[0] === y3[0] && x4[1] === y3[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter2 = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React73.useRef([]);
  var touchStartRef = React73.useRef([0, 0]);
  var activeAxis = React73.useRef();
  var id = React73.useState(idCounter2++)[0];
  var Style2 = React73.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = React73.useRef(props);
  React73.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React73.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React73.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React73.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e4) {
      return e4.name === event.type && e4.target === event.target && deltaCompare(e4.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React73.useCallback(function(name2, delta, target, should) {
    var event = { name: name2, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e4) {
        return e4 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React73.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React73.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React73.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React73.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React73.createElement(
    React73.Fragment,
    null,
    inert ? React73.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React73.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}

// ../../node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React74.forwardRef(function(props, ref) {
  return React74.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// ../../node_modules/@radix-ui/react-popover/dist/index.mjs
var $cb5cc270b50c6fcd$var$POPOVER_NAME = "Popover";
var [$cb5cc270b50c6fcd$var$createPopoverContext, $cb5cc270b50c6fcd$export$c8393c9e73286932] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cb5cc270b50c6fcd$var$POPOVER_NAME, [
  $cf1ac5d9fe0e8206$export$722aac194ae923
]);
var $cb5cc270b50c6fcd$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
var [$cb5cc270b50c6fcd$var$PopoverProvider, $cb5cc270b50c6fcd$var$usePopoverContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$POPOVER_NAME);
var $cb5cc270b50c6fcd$export$5b6b19405a83ff9d = (props) => {
  const { __scopePopover, children, open: openProp, defaultOpen, onOpenChange, modal = false } = props;
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  const triggerRef = (0, import_react81.useRef)(null);
  const [hasCustomAnchor, setHasCustomAnchor] = (0, import_react81.useState)(false);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_react81.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react81.createElement)($cb5cc270b50c6fcd$var$PopoverProvider, {
    scope: __scopePopover,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    triggerRef,
    open,
    onOpenChange: setOpen,
    onOpenToggle: (0, import_react81.useCallback)(
      () => setOpen(
        (prevOpen) => !prevOpen
      ),
      [
        setOpen
      ]
    ),
    hasCustomAnchor,
    onCustomAnchorAdd: (0, import_react81.useCallback)(
      () => setHasCustomAnchor(true),
      []
    ),
    onCustomAnchorRemove: (0, import_react81.useCallback)(
      () => setHasCustomAnchor(false),
      []
    ),
    modal
  }, children));
};
var $cb5cc270b50c6fcd$var$TRIGGER_NAME = "PopoverTrigger";
var $cb5cc270b50c6fcd$export$7dacb05d26466c3 = /* @__PURE__ */ (0, import_react81.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, ...triggerProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$TRIGGER_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.triggerRef);
  const trigger = /* @__PURE__ */ (0, import_react81.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": context.open,
    "aria-controls": context.contentId,
    "data-state": $cb5cc270b50c6fcd$var$getState(context.open)
  }, triggerProps, {
    ref: composedTriggerRef,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)
  }));
  return context.hasCustomAnchor ? trigger : /* @__PURE__ */ (0, import_react81.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({
    asChild: true
  }, popperScope), trigger);
});
var $cb5cc270b50c6fcd$var$PORTAL_NAME = "PopoverPortal";
var [$cb5cc270b50c6fcd$var$PortalProvider, $cb5cc270b50c6fcd$var$usePortalContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, {
  forceMount: void 0
});
var $cb5cc270b50c6fcd$export$dd679ffb4362d2d4 = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, __scopePopover);
  return /* @__PURE__ */ (0, import_react81.createElement)($cb5cc270b50c6fcd$var$PortalProvider, {
    scope: __scopePopover,
    forceMount
  }, /* @__PURE__ */ (0, import_react81.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ (0, import_react81.createElement)($f1701beae083dbae$export$602eac185826482c, {
    asChild: true,
    container
  }, children)));
};
var $cb5cc270b50c6fcd$var$CONTENT_NAME = "PopoverContent";
var $cb5cc270b50c6fcd$export$d7e1f420b25549ff = /* @__PURE__ */ (0, import_react81.forwardRef)((props, forwardedRef) => {
  const portalContext = $cb5cc270b50c6fcd$var$usePortalContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  return /* @__PURE__ */ (0, import_react81.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, context.modal ? /* @__PURE__ */ (0, import_react81.createElement)($cb5cc270b50c6fcd$var$PopoverContentModal, _extends({}, contentProps, {
    ref: forwardedRef
  })) : /* @__PURE__ */ (0, import_react81.createElement)($cb5cc270b50c6fcd$var$PopoverContentNonModal, _extends({}, contentProps, {
    ref: forwardedRef
  })));
});
var $cb5cc270b50c6fcd$var$PopoverContentModal = /* @__PURE__ */ (0, import_react81.forwardRef)((props, forwardedRef) => {
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const contentRef = (0, import_react81.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
  const isRightClickOutsideRef = (0, import_react81.useRef)(false);
  (0, import_react81.useEffect)(() => {
    const content = contentRef.current;
    if (content)
      return hideOthers(content);
  }, []);
  return /* @__PURE__ */ (0, import_react81.createElement)(Combination_default, {
    as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
    allowPinchZoom: true
  }, /* @__PURE__ */ (0, import_react81.createElement)($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
      var _context$triggerRef$c;
      event.preventDefault();
      if (!isRightClickOutsideRef.current)
        (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
    }),
    onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      isRightClickOutsideRef.current = isRightClick;
    }, {
      checkForDefaultPrevented: false
    }),
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocusOutside,
      (event) => event.preventDefault(),
      {
        checkForDefaultPrevented: false
      }
    )
  })));
});
var $cb5cc270b50c6fcd$var$PopoverContentNonModal = /* @__PURE__ */ (0, import_react81.forwardRef)((props, forwardedRef) => {
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const hasInteractedOutsideRef = (0, import_react81.useRef)(false);
  const hasPointerDownOutsideRef = (0, import_react81.useRef)(false);
  return /* @__PURE__ */ (0, import_react81.createElement)($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      var _props$onCloseAutoFoc;
      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
      if (!event.defaultPrevented) {
        var _context$triggerRef$c2;
        if (!hasInteractedOutsideRef.current)
          (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
      hasPointerDownOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      var _props$onInteractOuts, _context$triggerRef$c3;
      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef.current = true;
        if (event.detail.originalEvent.type === "pointerdown")
          hasPointerDownOutsideRef.current = true;
      }
      const target = event.target;
      const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current)
        event.preventDefault();
    }
  }));
});
var $cb5cc270b50c6fcd$var$PopoverContentImpl = /* @__PURE__ */ (0, import_react81.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, ...contentProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
  return /* @__PURE__ */ (0, import_react81.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: true,
    loop: true,
    trapped: trapFocus,
    onMountAutoFocus: onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, /* @__PURE__ */ (0, import_react81.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents,
    onInteractOutside,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onDismiss: () => context.onOpenChange(false)
  }, /* @__PURE__ */ (0, import_react81.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
    "data-state": $cb5cc270b50c6fcd$var$getState(context.open),
    role: "dialog",
    id: context.contentId
  }, popperScope, contentProps, {
    ref: forwardedRef,
    style: {
      ...contentProps.style,
      "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
      "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
      "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }))));
});
var $cb5cc270b50c6fcd$export$3152841115e061b2 = /* @__PURE__ */ (0, import_react81.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, ...arrowProps } = props;
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  return /* @__PURE__ */ (0, import_react81.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {
    ref: forwardedRef
  }));
});
function $cb5cc270b50c6fcd$var$getState(open) {
  return open ? "open" : "closed";
}
var $cb5cc270b50c6fcd$export$be92b6f5f03c0fe9 = $cb5cc270b50c6fcd$export$5b6b19405a83ff9d;
var $cb5cc270b50c6fcd$export$41fb9f06171c75f4 = $cb5cc270b50c6fcd$export$7dacb05d26466c3;
var $cb5cc270b50c6fcd$export$602eac185826482c = $cb5cc270b50c6fcd$export$dd679ffb4362d2d4;
var $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2 = $cb5cc270b50c6fcd$export$d7e1f420b25549ff;
var $cb5cc270b50c6fcd$export$21b07c8f274aebd5 = $cb5cc270b50c6fcd$export$3152841115e061b2;

// ../../packages/frontmatter/dist/Affiliations.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var __rest6 = function(s7, e4) {
  var t10 = {};
  for (var p3 in s7)
    if (Object.prototype.hasOwnProperty.call(s7, p3) && e4.indexOf(p3) < 0)
      t10[p3] = s7[p3];
  if (s7 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i5 = 0, p3 = Object.getOwnPropertySymbols(s7); i5 < p3.length; i5++) {
      if (e4.indexOf(p3[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s7, p3[i5]))
        t10[p3[i5]] = s7[p3[i5]];
    }
  return t10;
};
function Affiliation({ affiliations, affiliationId }) {
  var _a, _b;
  if (!affiliations || affiliations.length === 0)
    return null;
  const affiliationsLookup = Object.fromEntries((_a = affiliations === null || affiliations === void 0 ? void 0 : affiliations.map((_a2) => {
    var { id } = _a2, rest2 = __rest6(_a2, ["id"]);
    return [id, rest2];
  })) !== null && _a !== void 0 ? _a : []);
  const affiliation = (_b = affiliationsLookup[affiliationId]) !== null && _b !== void 0 ? _b : { name: affiliationId };
  return (0, import_jsx_runtime62.jsxs)(import_jsx_runtime62.Fragment, { children: [affiliation.name || affiliation.institution, " ", affiliation.ror && (0, import_jsx_runtime62.jsx)("a", { className: "ml-1", href: `https://ror.org/${affiliation.ror.replace(/(https?:\/\/)?ror\.org\//, "")}`, target: "_blank", rel: "noopener noreferrer", title: "Research Organization Registry", children: (0, import_jsx_runtime62.jsx)(RorIcon_default, { width: "1rem", height: "1rem", className: "inline-block" }) })] });
}

// ../../packages/frontmatter/dist/AuthorPopover.js
function Definition({ title, children }) {
  return (0, import_jsx_runtime63.jsxs)("div", { className: "px-4 py-2 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-0", children: [(0, import_jsx_runtime63.jsx)("dt", { className: "text-sm font-medium leading-6 text-gray-900", children: title }), (0, import_jsx_runtime63.jsx)("dd", { className: "mt-1 text-sm leading-6 text-gray-700 sm:col-span-2 sm:mt-0", children })] });
}
var AuthorPopover = ({ author, affiliations, children }) => {
  var _a;
  if (!author)
    return (0, import_jsx_runtime63.jsx)(import_jsx_runtime63.Fragment, { children });
  return (0, import_jsx_runtime63.jsxs)($cb5cc270b50c6fcd$export$be92b6f5f03c0fe9, { children: [(0, import_jsx_runtime63.jsx)($cb5cc270b50c6fcd$export$41fb9f06171c75f4, { asChild: true, children: (0, import_jsx_runtime63.jsx)("button", { className: "focus:shadow-[0_0_0_2px] focus:shadow-black outline-none hover:underline", "aria-label": "Author Details", children }) }), (0, import_jsx_runtime63.jsx)($cb5cc270b50c6fcd$export$602eac185826482c, { children: (0, import_jsx_runtime63.jsxs)($cb5cc270b50c6fcd$export$7c6e2c02157bb7d2, { className: "rounded p-5 w-[400px] bg-white shadow", sideOffset: 5, children: [(0, import_jsx_runtime63.jsxs)("div", { className: "flex flex-col gap-2.5", children: [(0, import_jsx_runtime63.jsx)("p", { className: "text-mauve12 text-[15px] leading-[19px] font-medium mb-2.5", children: author.name }), (0, import_jsx_runtime63.jsx)("p", { className: "text-mauve12 text-[15px] leading-[19px] font-medium mb-2.5", children: (_a = author.affiliations) === null || _a === void 0 ? void 0 : _a.map((affiliationId) => (0, import_jsx_runtime63.jsx)(Affiliation, { affiliations, affiliationId }, affiliationId)) }), (0, import_jsx_runtime63.jsxs)("dl", { className: "divide-y divide-gray-100", children: [author.email && (0, import_jsx_runtime63.jsx)(Definition, { title: "Email", children: (0, import_jsx_runtime63.jsx)("a", { className: "ml-1", href: `mailto:${author.email}`, title: `${author.name} <${author.email}>`, target: "_blank", rel: "noopener noreferrer", children: author.email }) }), author.orcid && (0, import_jsx_runtime63.jsx)(Definition, { title: "ORCID", children: (0, import_jsx_runtime63.jsx)("a", { className: "ml-1", href: `https://orcid.org/${author.orcid}`, target: "_blank", rel: "noopener noreferrer", title: "ORCID (Open Researcher and Contributor ID)", children: author.orcid }) }), author.github && (0, import_jsx_runtime63.jsx)(Definition, { title: "GitHub", children: (0, import_jsx_runtime63.jsxs)("a", { className: "ml-1", href: `https://github.com/${author.github}`, target: "_blank", rel: "noopener noreferrer", title: `GitHub: ${author.github}`, children: ["@", author.github] }) }), author.twitter && (0, import_jsx_runtime63.jsx)(Definition, { title: "Twitter", children: (0, import_jsx_runtime63.jsxs)("a", { className: "ml-1", href: `https://twitter.com/${author.twitter}`, target: "_blank", rel: "noopener noreferrer", title: `Twitter: ${author.twitter}`, children: ["@", author.twitter] }) }), author.url && (0, import_jsx_runtime63.jsx)(Definition, { title: "Website", children: (0, import_jsx_runtime63.jsx)("a", { className: "ml-1", href: author.url, target: "_blank", rel: "noopener noreferrer", title: `Author Website`, children: author.url }) }), author.roles && (0, import_jsx_runtime63.jsx)(Definition, { title: "Roles", children: author.roles.join(", ") })] })] }), (0, import_jsx_runtime63.jsx)($cb5cc270b50c6fcd$export$21b07c8f274aebd5, { className: "fill-white" })] }) })] });
};

// ../../packages/frontmatter/dist/Authors.js
function Author({ author, affiliations, className }) {
  return (0, import_jsx_runtime64.jsxs)("span", { className: (0, import_classnames26.default)("font-semibold text-sm", className), children: [(0, import_jsx_runtime64.jsx)(AuthorPopover, { author, affiliations, children: author.name }), author.email && author.corresponding && (0, import_jsx_runtime64.jsx)("a", { className: "ml-1", href: `mailto:${author.email}`, title: `${author.name} <${author.email}>`, target: "_blank", rel: "noopener noreferrer", children: (0, import_jsx_runtime64.jsx)(EmailIcon_default, { width: "1rem", height: "1rem", className: "inline-block text-gray-400 hover:text-blue-400 -translate-y-[0.1em]" }) }), author.orcid && (0, import_jsx_runtime64.jsx)("a", { className: "ml-1", href: `https://orcid.org/${author.orcid}`, target: "_blank", rel: "noopener noreferrer", title: "ORCID (Open Researcher and Contributor ID)", children: (0, import_jsx_runtime64.jsx)(OrcidIcon_default, { width: "1rem", height: "1rem", className: "inline-block text-gray-400 hover:text-[#A9C751] -translate-y-[0.1em]" }) }), author.twitter && (0, import_jsx_runtime64.jsx)("a", { className: "ml-1", href: `https://twitter.com/${author.twitter}`, target: "_blank", rel: "noopener noreferrer", title: `Twitter: ${author.twitter}`, children: (0, import_jsx_runtime64.jsx)(TwitterIcon_default, { width: "1rem", height: "1rem", className: "inline-block text-gray-400 hover:text-[#1DA1F2] -translate-y-[0.1em]" }) })] });
}
function AuthorsList({ authors, affiliations }) {
  if (!authors || authors.length === 0)
    return null;
  return (0, import_jsx_runtime64.jsx)("div", { children: authors.map((a4, i5) => (0, import_jsx_runtime64.jsx)(Author, { author: a4, affiliations, className: (0, import_classnames26.default)("inline-block", {
    "text-comma": i5 < authors.length - 1
  }) }, a4.name)) });
}
function AuthorAndAffiliations({ authors, affiliations }) {
  if (!authors || authors.length === 0)
    return null;
  const hasAffliations = authors.reduce((r4, { affiliations: a4 }) => r4 || !!a4 && (a4 === null || a4 === void 0 ? void 0 : a4.length) > 0, false);
  if (!hasAffliations) {
    return (0, import_jsx_runtime64.jsx)("header", { className: "mt-4 not-prose", children: (0, import_jsx_runtime64.jsx)(AuthorsList, { authors, affiliations }) });
  }
  return (0, import_jsx_runtime64.jsx)("header", { className: "mt-4 not-prose", children: (0, import_jsx_runtime64.jsxs)("div", { className: "grid grid-cols-1 sm:grid-cols-2 gap-y-1", children: [authors.length > 1 && (0, import_jsx_runtime64.jsxs)(import_jsx_runtime64.Fragment, { children: [(0, import_jsx_runtime64.jsx)("div", { className: "pb-2 text-xs font-thin uppercase", children: "Authors" }), (0, import_jsx_runtime64.jsx)("div", { className: "pb-2 text-xs font-thin uppercase", children: "Affiliations" })] }), authors.map((author) => {
    var _a;
    return (0, import_jsx_runtime64.jsxs)(import_react82.default.Fragment, { children: [(0, import_jsx_runtime64.jsx)("div", { children: (0, import_jsx_runtime64.jsx)(Author, { author, affiliations }) }), (0, import_jsx_runtime64.jsx)("div", { className: "text-sm", children: (_a = author.affiliations) === null || _a === void 0 ? void 0 : _a.map((affiliationId) => {
      return (0, import_jsx_runtime64.jsx)("div", { children: (0, import_jsx_runtime64.jsx)(Affiliation, { affiliations, affiliationId }) }, affiliationId);
    }) })] }, author.name);
  })] }) });
}

// ../../packages/frontmatter/dist/FrontmatterBlock.js
function ExternalOrInternalLink2({ to, className, title, children }) {
  return (0, import_jsx_runtime65.jsx)("a", { href: to, className, title, children });
}
function DoiBadge({ doi: possibleLink, className }) {
  if (!possibleLink)
    return null;
  const doi2 = possibleLink.replace(/^(https?:\/\/)?(dx\.)?doi\.org\//, "");
  const url = `https://doi.org/${doi2}`;
  return (0, import_jsx_runtime65.jsx)("div", { className: (0, import_classnames27.default)("flex-none", className), title: "DOI (Digital Object Identifier)", children: (0, import_jsx_runtime65.jsx)("a", { className: "font-light no-underline hover:font-light hover:underline text-inherit hover:text-inherit", target: "_blank", rel: "noopener noreferrer", href: url, children: url }) });
}
function DateString({ date, format: format2 = {
  year: "numeric",
  month: "long",
  day: "numeric"
}, spacer }) {
  if (!date)
    return null;
  const d6 = new Date(date);
  const utcDate = new Date(d6.getUTCFullYear(), d6.getUTCMonth(), d6.getUTCDate());
  const dateString = utcDate.toLocaleDateString("en-US", format2);
  return (0, import_jsx_runtime65.jsx)("time", { dateTime: date, className: (0, import_classnames27.default)({ "text-spacer": spacer }), children: dateString });
}
function GitHubLink({ github: possibleLink }) {
  if (!possibleLink)
    return null;
  const github = possibleLink.replace(/^(https?:\/\/)?github\.com\//, "");
  return (0, import_jsx_runtime65.jsx)("a", { href: `https://github.com/${github}`, title: `GitHub Repository: ${github}`, target: "_blank", rel: "noopener noreferrer", className: "text-inherit hover:text-inherit", children: (0, import_jsx_runtime65.jsx)(GithubIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block mr-1 opacity-60 hover:opacity-100" }) });
}
function OpenAccessBadge({ open_access }) {
  if (!open_access)
    return null;
  return (0, import_jsx_runtime65.jsx)("a", { href: "https://en.wikipedia.org/wiki/Open_access", target: "_blank", rel: "noopener noreferrer", title: "Open Access", className: "text-inherit hover:text-inherit", children: (0, import_jsx_runtime65.jsx)(OpenAccessIcon_default, { width: "1.25rem", height: "1.25rem", className: "mr-1 inline-block opacity-60 hover:opacity-100 hover:text-[#E18435]" }) });
}
function Journal({ venue, biblio, className }) {
  if (!venue)
    return null;
  const { title, url } = typeof venue === "string" ? { title: venue, url: null } : venue;
  if (!title)
    return null;
  const { volume, issue } = biblio !== null && biblio !== void 0 ? biblio : {};
  return (0, import_jsx_runtime65.jsxs)("div", { className: (0, import_classnames27.default)("flex-none mr-2", className), children: [url ? (0, import_jsx_runtime65.jsx)(ExternalOrInternalLink2, { className: "font-semibold no-underline smallcaps", to: url, title, children: title }) : (0, import_jsx_runtime65.jsx)("span", { className: "font-semibold smallcaps", children: title }), volume != null && (0, import_jsx_runtime65.jsxs)("span", { className: "pl-2 ml-2 border-l", children: ["Volume ", volume, issue != null && (0, import_jsx_runtime65.jsxs)(import_jsx_runtime65.Fragment, { children: [", Issue ", issue] })] })] });
}
function FrontmatterBlock({ frontmatter, kind = SourceFileKind.Article, authorStyle = "block", hideBadges, hideExports, className }) {
  if (!frontmatter)
    return null;
  const { title, subtitle, subject, doi: doi2, open_access, license, github, venue, biblio, exports: exports2, date, authors } = frontmatter;
  const isJupyter = kind === SourceFileKind.Notebook;
  const hasExports = exports2 && exports2.length > 0;
  const hasAuthors = authors && authors.length > 0;
  const hasBadges = !!open_access || !!license || !!hasExports || !!isJupyter || !!github;
  const hasHeaders = !!subject || !!venue || !!biblio;
  const hasDateOrDoi = !!doi2 || !!date;
  const showHeaderBlock = hasHeaders || hasBadges && !hideBadges || hasExports && !hideExports;
  if (!title && !subtitle && !showHeaderBlock && !hasAuthors && !hasDateOrDoi) {
    return null;
  }
  return (0, import_jsx_runtime65.jsxs)("div", { id: "skip-to-frontmatter", "aria-label": "article frontmatter", className: (0, import_classnames27.default)(className), children: [showHeaderBlock && (0, import_jsx_runtime65.jsxs)("div", { className: "flex items-center h-6 mt-3 mb-5 text-sm font-light", children: [subject && (0, import_jsx_runtime65.jsx)("div", { className: (0, import_classnames27.default)("flex-none pr-2 smallcaps", {
    "border-r mr-2": venue
  }), children: subject }), (0, import_jsx_runtime65.jsx)(Journal, { venue, biblio }), (0, import_jsx_runtime65.jsx)("div", { className: "flex-grow" }), !hideBadges && (0, import_jsx_runtime65.jsxs)(import_jsx_runtime65.Fragment, { children: [(0, import_jsx_runtime65.jsx)(LicenseBadges, { license }), (0, import_jsx_runtime65.jsx)(OpenAccessBadge, { open_access }), (0, import_jsx_runtime65.jsx)(GitHubLink, { github }), isJupyter && (0, import_jsx_runtime65.jsx)("div", { className: "inline-block mr-1", children: (0, import_jsx_runtime65.jsx)(JupyterIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block" }) })] }), !hideExports && (0, import_jsx_runtime65.jsx)(DownloadsDropdown, { exports: exports2 })] }), title && (0, import_jsx_runtime65.jsx)("h1", { className: "mb-0", children: title }), subtitle && (0, import_jsx_runtime65.jsx)("p", { className: "mt-2 mb-0 lead text-zinc-600 dark:text-zinc-400", children: subtitle }), hasAuthors && authorStyle === "list" && (0, import_jsx_runtime65.jsx)(AuthorsList, { authors: frontmatter.authors, affiliations: frontmatter.affiliations }), hasAuthors && authorStyle === "block" && (0, import_jsx_runtime65.jsx)(AuthorAndAffiliations, { authors: frontmatter.authors, affiliations: frontmatter.affiliations }), hasDateOrDoi && (0, import_jsx_runtime65.jsxs)("div", { className: "flex mt-2 text-sm font-light", children: [(0, import_jsx_runtime65.jsx)(DateString, { date, spacer: !!doi2 }), (0, import_jsx_runtime65.jsx)(DoiBadge, { doi: doi2 })] })] });
}

// ../../packages/site/src/components/Navigation/ThemeButton.tsx
var import_classnames28 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime5 = __toESM(require_jsx_dev_runtime(), 1);
function ThemeButton({ className = "w-8 h-8 mx-3" }) {
  const { isDark, nextTheme } = useTheme();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(
    "button",
    {
      className: (0, import_classnames28.default)(
        "theme rounded-full border border-stone-700 dark:border-white hover:bg-neutral-100 border-solid overflow-hidden text-stone-700 dark:text-white hover:text-stone-500 dark:hover:text-neutral-800",
        className
      ),
      title: `Change theme to ${isDark ? "light" : "dark"} mode.`,
      "aria-label": `Change theme to ${isDark ? "light" : "dark"} mode.`,
      onClick: nextTheme,
      children: isDark ? /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(MoonIcon_default, { className: "h-full w-full p-0.5" }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/ThemeButton.tsx",
        lineNumber: 19,
        columnNumber: 9
      }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(SunIcon_default, { className: "h-full w-full p-0.5" }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/ThemeButton.tsx",
        lineNumber: 21,
        columnNumber: 9
      }, this)
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/ThemeButton.tsx",
      lineNumber: 9,
      columnNumber: 5
    },
    this
  );
}

// ../../packages/site/src/components/Navigation/TopNav.tsx
var import_react86 = __toESM(require_react(), 1);
var import_classnames30 = __toESM(require_classnames(), 1);

// ../../packages/site/src/components/Navigation/Loading.tsx
var import_react84 = __toESM(require_react(), 1);
var import_classnames29 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime6 = __toESM(require_jsx_dev_runtime(), 1);
function useLoading() {
  const transitionState = useNavigation().state;
  const ref = (0, import_react84.useMemo)(() => ({}), []);
  const [showLoading, setShowLoading] = (0, import_react84.useState)(false);
  (0, import_react84.useEffect)(() => {
    if (transitionState === "loading") {
      ref.start = setTimeout(() => {
        setShowLoading(true);
      }, 150);
    } else {
      if (ref.start) {
        clearTimeout(ref.start);
        delete ref.start;
        setShowLoading(false);
        return;
      }
      ref.finish = setTimeout(() => {
        setShowLoading(false);
      }, 150);
    }
    return () => {
      if (ref.start) {
        clearTimeout(ref.start);
        delete ref.start;
      }
      if (ref.finish) {
        clearTimeout(ref.finish);
        delete ref.finish;
      }
    };
  }, [transitionState]);
  return { showLoading, isLoading: transitionState === "loading" };
}
function LoadingBar() {
  const { isLoading, showLoading } = useLoading();
  if (!showLoading)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
    "div",
    {
      className: (0, import_classnames29.default)(
        "w-screen h-[2px] bg-blue-500 absolute left-0 bottom-0 transition-transform",
        {
          "animate-load scale-x-40": isLoading,
          "scale-x-100": !isLoading
        }
      )
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/Loading.tsx",
      lineNumber: 49,
      columnNumber: 5
    },
    this
  );
}

// ../../packages/site/src/components/Navigation/TopNav.tsx
var import_jsx_dev_runtime7 = __toESM(require_jsx_dev_runtime(), 1);
var DEFAULT_NAV_HEIGHT = 60;
function ExternalOrInternalLink3({
  to,
  className,
  children,
  nav,
  prefetch = "intent"
}) {
  const Link2 = useLinkProvider();
  const staticClass = typeof className === "function" ? className({ isActive: false }) : className;
  if (to.startsWith("http") || to.startsWith("mailto:")) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("a", { href: to, target: "_blank", rel: "noopener noreferrer", className: staticClass, children }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 40,
      columnNumber: 7
    }, this);
  }
  if (nav) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(NavLink, { prefetch, to, className, children }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 47,
      columnNumber: 7
    }, this);
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(Link2, { prefetch, to, className: staticClass, children }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
    lineNumber: 53,
    columnNumber: 5
  }, this);
}
function NavItem({ item }) {
  var _a, _b;
  if (!("children" in item)) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "relative inline-block mx-2 grow-0", children: /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
      ExternalOrInternalLink3,
      {
        nav: true,
        to: (_a = item.url) != null ? _a : "",
        className: ({ isActive }) => (0, import_classnames30.default)(
          "inline-flex items-center justify-center w-full mx-2 py-1 text-md font-medium dark:text-white focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75",
          {
            "border-b border-stone-200": isActive
          }
        ),
        children: item.title
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 63,
        columnNumber: 9
      },
      this
    ) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 62,
      columnNumber: 7
    }, this);
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(it, { as: "div", className: "relative inline-block mx-2 grow-0", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "inline-block", children: /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(it.Button, { className: "inline-flex items-center justify-center w-full py-1 mx-2 font-medium rounded-md text-md text-stone-900 dark:text-white focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("span", { children: item.title }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 84,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
        ChevronDownIcon_default,
        {
          width: "1.25rem",
          height: "1.25rem",
          className: "ml-2 -mr-1 text-violet-200 hover:text-violet-100"
        },
        void 0,
        false,
        {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 85,
          columnNumber: 11
        },
        this
      )
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 83,
      columnNumber: 9
    }, this) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 82,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
      tt,
      {
        as: import_react86.Fragment,
        enter: "transition ease-out duration-100",
        enterFrom: "transform opacity-0 scale-95",
        enterTo: "transform opacity-100 scale-100",
        leave: "transition ease-in duration-75",
        leaveFrom: "transform opacity-100 scale-100",
        leaveTo: "transform opacity-0 scale-95",
        children: /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(it.Items, { className: "absolute w-48 py-1 mt-2 origin-top-left bg-white rounded-sm shadow-lg left-4 ring-1 ring-black ring-opacity-5 focus:outline-none", children: (_b = item.children) == null ? void 0 : _b.map((action) => {
          var _a2;
          return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(it.Item, { children: ((_a2 = action.url) == null ? void 0 : _a2.startsWith("http")) ? /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
            "a",
            {
              href: action.url || "",
              className: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-black",
              target: "_blank",
              rel: "noopener noreferrer",
              children: action.title
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
              lineNumber: 106,
              columnNumber: 17
            },
            this
          ) : /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
            NavLink,
            {
              to: action.url || "",
              className: ({ isActive }) => (0, import_classnames30.default)(
                " block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-black ",
                {
                  "text-black font-bold": isActive
                }
              ),
              children: action.title
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
              lineNumber: 115,
              columnNumber: 17
            },
            this
          ) }, action.url, false, {
            fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
            lineNumber: 103,
            columnNumber: 13
          }, this);
        }) }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 101,
          columnNumber: 9
        }, this)
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 92,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
    lineNumber: 81,
    columnNumber: 5
  }, this);
}
function NavItems({ nav }) {
  if (!nav)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "flex-grow hidden text-md lg:block", children: nav.map((item) => {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(NavItem, { item }, "url" in item ? item.url : item.title, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 142,
      columnNumber: 16
    }, this);
  }) }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
    lineNumber: 140,
    columnNumber: 5
  }, this);
}
function ActionMenu({ actions }) {
  if (!actions || actions.length === 0)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(it, { as: "div", className: "relative", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { children: /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(it.Button, { className: "flex text-sm bg-transparent rounded-full focus:outline-none", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("span", { className: "sr-only", children: "Open Menu" }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 154,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "flex items-center text-stone-200 hover:text-white", children: /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(EllipsisVerticalIcon_default, { width: "2rem", height: "2rem", className: "p-1" }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 156,
        columnNumber: 13
      }, this) }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 155,
        columnNumber: 11
      }, this)
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 153,
      columnNumber: 9
    }, this) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 152,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
      tt,
      {
        as: import_react86.Fragment,
        enter: "transition ease-out duration-100",
        enterFrom: "transform opacity-0 scale-95",
        enterTo: "transform opacity-100 scale-100",
        leave: "transition ease-in duration-75",
        leaveFrom: "transform opacity-100 scale-100",
        leaveTo: "transform opacity-0 scale-95",
        children: /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(it.Items, { className: "absolute right-0 w-48 py-1 mt-2 origin-top-right bg-white rounded-sm shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none", children: actions == null ? void 0 : actions.map((action) => /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(it.Item, { children: ({ active }) => /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
          "a",
          {
            href: action.url,
            className: (0, import_classnames30.default)(
              active ? "bg-gray-100" : "",
              "block px-4 py-2 text-sm text-gray-700"
            ),
            children: action.title
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
            lineNumber: 173,
            columnNumber: 17
          },
          this
        ) }, action.url, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 171,
          columnNumber: 13
        }, this)) }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 169,
          columnNumber: 9
        }, this)
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 160,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
    lineNumber: 151,
    columnNumber: 5
  }, this);
}
function HomeLink({
  logo,
  logoDark,
  logoText,
  name: name2
}) {
  const Link2 = useLinkProvider();
  const baseurl = useBaseurl();
  const nothingSet = !logo && !logoText;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
    Link2,
    {
      className: "flex items-center ml-3 dark:text-white w-fit md:ml-5 xl:ml-7",
      to: withBaseurl("/", baseurl),
      prefetch: "intent",
      children: [
        logo && /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
          "div",
          {
            className: (0, import_classnames30.default)("p-1 mr-3", {
              "dark:bg-white dark:rounded": !logoDark
            }),
            children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
                "img",
                {
                  src: logo,
                  className: (0, import_classnames30.default)("h-9", { "dark:hidden": !!logoDark }),
                  alt: logoText || name2,
                  height: "2.25rem"
                },
                void 0,
                false,
                {
                  fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
                  lineNumber: 217,
                  columnNumber: 11
                },
                this
              ),
              logoDark && /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
                "img",
                {
                  src: logoDark,
                  className: "hidden h-9 dark:block",
                  alt: logoText || name2,
                  height: "2.25rem"
                },
                void 0,
                false,
                {
                  fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
                  lineNumber: 224,
                  columnNumber: 13
                },
                this
              )
            ]
          },
          void 0,
          true,
          {
            fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
            lineNumber: 212,
            columnNumber: 9
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
          "span",
          {
            className: (0, import_classnames30.default)("text-md sm:text-xl tracking-tight sm:mr-5", {
              "sr-only": !(logoText || nothingSet)
            }),
            children: logoText || "Made with MyST"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
            lineNumber: 233,
            columnNumber: 7
          },
          this
        )
      ]
    },
    void 0,
    true,
    {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 206,
      columnNumber: 5
    },
    this
  );
}
function TopNav() {
  var _a;
  const [open, setOpen] = useNavOpen();
  const config = useSiteManifest();
  const { title, nav, actions } = config != null ? config : {};
  const { logo, logo_dark, logo_text } = (_a = config == null ? void 0 : config.options) != null ? _a : {};
  return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "bg-white/80 backdrop-blur dark:bg-stone-900/80 shadow dark:shadow-stone-700 p-3 md:px-8 fixed w-screen top-0 z-30 h-[60px]", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("nav", { className: "flex items-center justify-between flex-wrap max-w-[1440px] mx-auto", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "flex flex-row xl:min-w-[19.5rem] mr-2 sm:mr-7 justify-start items-center", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "block xl:hidden", children: /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
          "button",
          {
            className: "flex items-center border-stone-400 text-stone-800 hover:text-stone-900 dark:text-stone-200 hover:dark:text-stone-100",
            onClick: () => {
              setOpen(!open);
            },
            children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(Bars3Icon_default, { width: "2rem", height: "2rem", className: "m-1" }, void 0, false, {
                fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
                lineNumber: 260,
                columnNumber: 15
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("span", { className: "sr-only", children: "Open Menu" }, void 0, false, {
                fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
                lineNumber: 261,
                columnNumber: 15
              }, this)
            ]
          },
          void 0,
          true,
          {
            fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
            lineNumber: 254,
            columnNumber: 13
          },
          this
        ) }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 253,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(HomeLink, { name: title, logo, logoDark: logo_dark, logoText: logo_text }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 264,
          columnNumber: 11
        }, this)
      ] }, void 0, true, {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 252,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "flex items-center flex-grow w-auto", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(NavItems, { nav }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 267,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "flex-grow block" }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 268,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(ThemeButton, {}, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 269,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "block sm:hidden", children: /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(ActionMenu, { actions }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 271,
          columnNumber: 13
        }, this) }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 270,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "hidden sm:block", children: actions == null ? void 0 : actions.map((action, index2) => /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
          ExternalOrInternalLink3,
          {
            className: "inline-block px-4 py-2 mx-1 mt-0 leading-none border rounded text-md border-stone-700 dark:border-white text-stone-700 dark:text-white hover:text-stone-500 dark:hover:text-neutral-800 hover:bg-neutral-100",
            to: action.url,
            children: action.title
          },
          action.url || index2,
          false,
          {
            fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
            lineNumber: 275,
            columnNumber: 15
          },
          this
        )) }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 273,
          columnNumber: 11
        }, this)
      ] }, void 0, true, {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 266,
        columnNumber: 9
      }, this)
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 251,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(LoadingBar, {}, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 286,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
    lineNumber: 250,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/Navigation/TableOfContents.tsx
var import_react91 = __toESM(require_react(), 1);
var import_classnames32 = __toESM(require_classnames(), 1);

// ../../packages/site/src/components/Navigation/TableOfContentsItems.tsx
var import_react89 = __toESM(require_react(), 1);
var import_classnames31 = __toESM(require_classnames(), 1);

// ../../node_modules/@radix-ui/react-collapsible/dist/index.mjs
init_extends();
var import_react88 = __toESM(require_react(), 1);
var $409067139f391064$var$COLLAPSIBLE_NAME = "Collapsible";
var [$409067139f391064$var$createCollapsibleContext, $409067139f391064$export$952b32dcbe73087a] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($409067139f391064$var$COLLAPSIBLE_NAME);
var [$409067139f391064$var$CollapsibleProvider, $409067139f391064$var$useCollapsibleContext] = $409067139f391064$var$createCollapsibleContext($409067139f391064$var$COLLAPSIBLE_NAME);
var $409067139f391064$export$6eb0f7ddcda6131f = /* @__PURE__ */ (0, import_react88.forwardRef)((props, forwardedRef) => {
  const { __scopeCollapsible, open: openProp, defaultOpen, disabled, onOpenChange, ...collapsibleProps } = props;
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_react88.createElement)($409067139f391064$var$CollapsibleProvider, {
    scope: __scopeCollapsible,
    disabled,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    open,
    onOpenToggle: (0, import_react88.useCallback)(
      () => setOpen(
        (prevOpen) => !prevOpen
      ),
      [
        setOpen
      ]
    )
  }, /* @__PURE__ */ (0, import_react88.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    "data-state": $409067139f391064$var$getState(open),
    "data-disabled": disabled ? "" : void 0
  }, collapsibleProps, {
    ref: forwardedRef
  })));
});
var $409067139f391064$var$TRIGGER_NAME = "CollapsibleTrigger";
var $409067139f391064$export$c135dce7b15bbbdc = /* @__PURE__ */ (0, import_react88.forwardRef)((props, forwardedRef) => {
  const { __scopeCollapsible, ...triggerProps } = props;
  const context = $409067139f391064$var$useCollapsibleContext($409067139f391064$var$TRIGGER_NAME, __scopeCollapsible);
  return /* @__PURE__ */ (0, import_react88.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    "aria-controls": context.contentId,
    "aria-expanded": context.open || false,
    "data-state": $409067139f391064$var$getState(context.open),
    "data-disabled": context.disabled ? "" : void 0,
    disabled: context.disabled
  }, triggerProps, {
    ref: forwardedRef,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)
  }));
});
var $409067139f391064$var$CONTENT_NAME = "CollapsibleContent";
var $409067139f391064$export$aadde00976f34151 = /* @__PURE__ */ (0, import_react88.forwardRef)((props, forwardedRef) => {
  const { forceMount, ...contentProps } = props;
  const context = $409067139f391064$var$useCollapsibleContext($409067139f391064$var$CONTENT_NAME, props.__scopeCollapsible);
  return /* @__PURE__ */ (0, import_react88.createElement)(
    $921a889cee6df7e8$export$99c2b779aa4e8b8b,
    {
      present: forceMount || context.open
    },
    ({ present }) => /* @__PURE__ */ (0, import_react88.createElement)($409067139f391064$var$CollapsibleContentImpl, _extends({}, contentProps, {
      ref: forwardedRef,
      present
    }))
  );
});
var $409067139f391064$var$CollapsibleContentImpl = /* @__PURE__ */ (0, import_react88.forwardRef)((props, forwardedRef) => {
  const { __scopeCollapsible, present, children, ...contentProps } = props;
  const context = $409067139f391064$var$useCollapsibleContext($409067139f391064$var$CONTENT_NAME, __scopeCollapsible);
  const [isPresent, setIsPresent] = (0, import_react88.useState)(present);
  const ref = (0, import_react88.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const heightRef = (0, import_react88.useRef)(0);
  const height = heightRef.current;
  const widthRef = (0, import_react88.useRef)(0);
  const width = widthRef.current;
  const isOpen = context.open || isPresent;
  const isMountAnimationPreventedRef = (0, import_react88.useRef)(isOpen);
  const originalStylesRef = (0, import_react88.useRef)();
  (0, import_react88.useEffect)(() => {
    const rAF2 = requestAnimationFrame(
      () => isMountAnimationPreventedRef.current = false
    );
    return () => cancelAnimationFrame(rAF2);
  }, []);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    const node = ref.current;
    if (node) {
      originalStylesRef.current = originalStylesRef.current || {
        transitionDuration: node.style.transitionDuration,
        animationName: node.style.animationName
      };
      node.style.transitionDuration = "0s";
      node.style.animationName = "none";
      const rect = node.getBoundingClientRect();
      heightRef.current = rect.height;
      widthRef.current = rect.width;
      if (!isMountAnimationPreventedRef.current) {
        node.style.transitionDuration = originalStylesRef.current.transitionDuration;
        node.style.animationName = originalStylesRef.current.animationName;
      }
      setIsPresent(present);
    }
  }, [
    context.open,
    present
  ]);
  return /* @__PURE__ */ (0, import_react88.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    "data-state": $409067139f391064$var$getState(context.open),
    "data-disabled": context.disabled ? "" : void 0,
    id: context.contentId,
    hidden: !isOpen
  }, contentProps, {
    ref: composedRefs,
    style: {
      [`--radix-collapsible-content-height`]: height ? `${height}px` : void 0,
      [`--radix-collapsible-content-width`]: width ? `${width}px` : void 0,
      ...props.style
    }
  }), isOpen && children);
});
function $409067139f391064$var$getState(open) {
  return open ? "open" : "closed";
}
var $409067139f391064$export$be92b6f5f03c0fe9 = $409067139f391064$export$6eb0f7ddcda6131f;
var $409067139f391064$export$41fb9f06171c75f4 = $409067139f391064$export$c135dce7b15bbbdc;
var $409067139f391064$export$7c6e2c02157bb7d2 = $409067139f391064$export$aadde00976f34151;

// ../../packages/site/src/components/Navigation/TableOfContentsItems.tsx
var import_jsx_dev_runtime8 = __toESM(require_jsx_dev_runtime(), 1);
function nestToc(toc) {
  const items = [];
  const stack = [];
  toc.forEach((tocItem, id) => {
    const item = tocItem;
    item.children = [];
    item.id = String(id);
    if (item.level === "index") {
      while (stack.length)
        stack.pop();
      items.push(item);
      return;
    }
    while (stack.length && stack[stack.length - 1].level >= item.level) {
      stack.pop();
    }
    const top = stack[stack.length - 1];
    if (top) {
      top.children.push(item);
    } else {
      items.push(item);
    }
    stack.push(item);
  });
  return items;
}
function childrenOpen(headings, pathname, baseurl) {
  return headings.map((heading) => {
    if (withBaseurl(heading.path, baseurl) === pathname)
      return [heading.id];
    const open = childrenOpen(heading.children, pathname, baseurl);
    if (open.length === 0)
      return [];
    return [heading.id, ...open];
  }).flat();
}
var Toc = ({ headings }) => {
  const nested = nestToc(headings);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "w-full px-1 dark:text-white", children: nested.map((item) => /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(NestedToc, { heading: item }, item.id, false, {
    fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
    lineNumber: 54,
    columnNumber: 9
  }, this)) }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
    lineNumber: 52,
    columnNumber: 5
  }, this);
};
function LinkItem({
  className,
  heading,
  onClick
}) {
  const NavLink2 = useNavLinkProvider();
  const baseurl = useBaseurl();
  const [, setOpen] = useNavOpen();
  if (!heading.path) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
      "div",
      {
        title: heading.title,
        className: (0, import_classnames31.default)("block break-words rounded", className),
        onClick: () => {
          onClick == null ? void 0 : onClick();
        },
        children: heading.short_title || heading.title
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
        lineNumber: 74,
        columnNumber: 7
      },
      this
    );
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
    NavLink2,
    {
      prefetch: "intent",
      title: heading.title,
      className: (0, import_classnames31.default)(
        "block break-words focus:outline outline-blue-200 outline-2 rounded",
        className
      ),
      to: withBaseurl(heading.path, baseurl),
      onClick: () => {
        onClick == null ? void 0 : onClick();
        setOpen(false);
      },
      children: heading.short_title || heading.title
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
      lineNumber: 86,
      columnNumber: 5
    },
    this
  );
}
var NestedToc = ({ heading }) => {
  const { pathname } = useLocation();
  const baseurl = useBaseurl();
  const startOpen = childrenOpen([heading], pathname, baseurl).includes(heading.id);
  const nav = useNavigation();
  const [open, setOpen] = import_react89.default.useState(startOpen);
  (0, import_react89.useEffect)(() => {
    if (nav.state === "idle")
      setOpen(startOpen);
  }, [nav.state]);
  const exact = pathname === withBaseurl(heading.path, baseurl);
  if (!heading.children || heading.children.length === 0) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
      LinkItem,
      {
        className: (0, import_classnames31.default)("p-2 my-1 rounded-lg", {
          "bg-blue-300/30": exact,
          "hover:bg-slate-300/30": !exact,
          "font-bold": heading.level === "index"
        }),
        heading
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
        lineNumber: 116,
        columnNumber: 7
      },
      this
    );
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)($409067139f391064$export$be92b6f5f03c0fe9, { className: "w-full", open, onOpenChange: setOpen, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
      "div",
      {
        className: (0, import_classnames31.default)(
          "flex flex-row w-full gap-2 px-2 my-1 text-left rounded-lg outline-none",
          {
            "bg-blue-300/30": exact,
            "hover:bg-slate-300/30": !exact
          }
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
            LinkItem,
            {
              className: (0, import_classnames31.default)("py-2 grow", {
                "font-semibold text-blue-800 dark:text-blue-200": startOpen,
                "cursor-pointer": !heading.path
              }),
              heading,
              onClick: () => setOpen(heading.path ? true : !open)
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
              lineNumber: 137,
              columnNumber: 9
            },
            this
          ),
          /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)($409067139f391064$export$41fb9f06171c75f4, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("button", { className: "self-center flex-none rounded-md group hover:bg-slate-300/30 focus:outline outline-blue-200 outline-2", children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
            ChevronRightIcon_default,
            {
              className: "transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100",
              height: "1.5rem",
              width: "1.5rem"
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
              lineNumber: 147,
              columnNumber: 13
            },
            this
          ) }, void 0, false, {
            fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
            lineNumber: 146,
            columnNumber: 11
          }, this) }, void 0, false, {
            fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
            lineNumber: 145,
            columnNumber: 9
          }, this)
        ]
      },
      void 0,
      true,
      {
        fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
        lineNumber: 128,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)($409067139f391064$export$7c6e2c02157bb7d2, { className: "pl-3 pr-[2px] collapsible-content", children: heading.children.map((item) => /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(NestedToc, { heading: item }, item.id, false, {
      fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
      lineNumber: 157,
      columnNumber: 11
    }, this)) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
      lineNumber: 155,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
    lineNumber: 127,
    columnNumber: 5
  }, this);
};

// ../../packages/site/src/components/Navigation/TableOfContents.tsx
var import_jsx_dev_runtime9 = __toESM(require_jsx_dev_runtime(), 1);
function useTocHeight(top = 0, inset = 0) {
  const container = (0, import_react91.useRef)(null);
  const toc = (0, import_react91.useRef)(null);
  const transitionState = useNavigation().state;
  const setHeight = () => {
    if (!container.current || !toc.current)
      return;
    const height = container.current.offsetHeight - window.scrollY;
    const div = toc.current.firstChild;
    if (div)
      div.style.height = `min(calc(100vh - ${top}px), ${height + inset}px)`;
    const nav = toc.current.querySelector("nav");
    if (nav)
      nav.style.opacity = height > 150 ? "1" : "0";
  };
  (0, import_react91.useEffect)(() => {
    setHeight();
    setTimeout(setHeight, 100);
    const handleScroll2 = () => setHeight();
    window.addEventListener("scroll", handleScroll2);
    return () => {
      window.removeEventListener("scroll", handleScroll2);
    };
  }, [container, toc, transitionState]);
  return { container, toc };
}
var TableOfContents = ({
  projectSlug,
  tocRef,
  footer
}) => {
  const top = useThemeTop();
  const grid = useGridSystemProvider();
  const footerRef = (0, import_react91.useRef)(null);
  const [open] = useNavOpen();
  const config = useSiteManifest();
  (0, import_react91.useEffect)(() => {
    setTimeout(() => {
      if (!footerRef.current)
        return;
      footerRef.current.style.opacity = "1";
      footerRef.current.style.transform = "none";
    }, 500);
  }, [footerRef]);
  if (!config)
    return null;
  const headings = getProjectHeadings(config, projectSlug, {
    addGroups: false
  });
  if (!headings)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(
    "div",
    {
      ref: tocRef,
      className: (0, import_classnames32.default)(
        "fixed",
        `xl:${grid}`,
        // for example, xl:article-grid
        "grid-gap xl:w-screen xl:pointer-events-none overflow-auto max-xl:min-w-[300px]",
        { hidden: !open, "z-30": open, "z-10": !open }
      ),
      style: { top },
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(
        "div",
        {
          className: (0, import_classnames32.default)(
            "pointer-events-auto",
            "xl:col-margin-left flex-col",
            "overflow-hidden",
            // 'border-r border-stone-200 dark:border-stone-700',
            {
              flex: open,
              "bg-white dark:bg-stone-900": open,
              // just apply when open, so that theme can transition
              "hidden xl:flex": !open
            }
          ),
          children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(
              "nav",
              {
                "aria-label": "Table of Contents",
                className: "flex-grow overflow-y-auto transition-opacity mt-6 pb-3 ml-3 xl:ml-0 mr-3 max-w-[350px]",
                children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(Toc, { headings }, void 0, false, {
                  fileName: "../../packages/site/src/components/Navigation/TableOfContents.tsx",
                  lineNumber: 91,
                  columnNumber: 11
                }, this)
              },
              void 0,
              false,
              {
                fileName: "../../packages/site/src/components/Navigation/TableOfContents.tsx",
                lineNumber: 87,
                columnNumber: 9
              },
              this
            ),
            footer && /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(
              "div",
              {
                className: "flex-none py-4 transition-all duration-700 translate-y-6 opacity-0",
                ref: footerRef,
                children: footer
              },
              void 0,
              false,
              {
                fileName: "../../packages/site/src/components/Navigation/TableOfContents.tsx",
                lineNumber: 94,
                columnNumber: 11
              },
              this
            )
          ]
        },
        void 0,
        true,
        {
          fileName: "../../packages/site/src/components/Navigation/TableOfContents.tsx",
          lineNumber: 74,
          columnNumber: 7
        },
        this
      )
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/TableOfContents.tsx",
      lineNumber: 64,
      columnNumber: 5
    },
    this
  );
};

// ../../packages/site/src/components/Navigation/Navigation.tsx
var import_jsx_dev_runtime10 = __toESM(require_jsx_dev_runtime(), 1);
function Navigation({
  children,
  projectSlug,
  tocRef,
  hide_toc,
  footer
}) {
  const [open, setOpen] = useNavOpen();
  const top = useThemeTop();
  if (children)
    console.warn(
      `Including children in Navigation can break keyboard accessbility and is deprecated. Please move children to the page component.`
    );
  if (hide_toc)
    return children ? null : /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(import_jsx_dev_runtime10.Fragment, { children }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/Navigation.tsx",
      lineNumber: 23,
      columnNumber: 42
    }, this);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(import_jsx_dev_runtime10.Fragment, { children: [
    open && /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
      "div",
      {
        className: "fixed inset-0 z-30 bg-black opacity-50",
        style: { marginTop: top },
        onClick: () => setOpen(false)
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/Navigation.tsx",
        lineNumber: 27,
        columnNumber: 9
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(TableOfContents, { tocRef, projectSlug, footer }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/Navigation.tsx",
      lineNumber: 33,
      columnNumber: 7
    }, this),
    children
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/Navigation.tsx",
    lineNumber: 25,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/Abstract.tsx
var import_classnames33 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime11 = __toESM(require_jsx_dev_runtime(), 1);
function FrontmatterParts({
  parts,
  keywords,
  hideKeywords
}) {
  if (!parts.abstract && !parts.keypoints && !parts.summary)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(import_jsx_dev_runtime11.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(Abstract, { content: parts.abstract }, void 0, false, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 19,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(Abstract, { content: parts.keypoints, title: "Key Points", id: "keypoints" }, void 0, false, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 20,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(Abstract, { content: parts.summary, title: "Plain Language Summary", id: "summary" }, void 0, false, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 21,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(Keywords, { keywords, hideKeywords }, void 0, false, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 22,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Abstract.tsx",
    lineNumber: 18,
    columnNumber: 5
  }, this);
}
function Abstract({
  content,
  title = "Abstract",
  id = "abstract"
}) {
  if (!content)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(import_jsx_dev_runtime11.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("h2", { id, className: "mb-3 text-base font-semibold group", children: [
      title,
      /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(HashLink, { id, title: `Link to ${title}`, hover: true, className: "ml-2" }, void 0, false, {
        fileName: "../../packages/site/src/components/Abstract.tsx",
        lineNumber: 41,
        columnNumber: 9
      }, this)
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 39,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("div", { className: "px-6 py-1 mb-3 rounded-sm bg-slate-50 dark:bg-slate-800", children: /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(ContentBlocks, { mdast: content, className: "col-body" }, void 0, false, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 44,
      columnNumber: 9
    }, this) }, void 0, false, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 43,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Abstract.tsx",
    lineNumber: 38,
    columnNumber: 5
  }, this);
}
function Keywords({
  keywords,
  hideKeywords
}) {
  if (hideKeywords || !keywords || keywords.length === 0)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("div", { className: "mb-10 group", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("span", { className: "mr-2 font-semibold", children: "Keywords:" }, void 0, false, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 60,
      columnNumber: 7
    }, this),
    keywords.map((k, i5) => /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(
      "span",
      {
        className: (0, import_classnames33.default)({
          "after:content-[','] after:mr-1": i5 < keywords.length - 1
        }),
        children: k
      },
      k,
      false,
      {
        fileName: "../../packages/site/src/components/Abstract.tsx",
        lineNumber: 62,
        columnNumber: 9
      },
      this
    )),
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(HashLink, { id: "keywords", title: "Link to Keywords", hover: true, className: "ml-2" }, void 0, false, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 71,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Abstract.tsx",
    lineNumber: 59,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/Backmatter.tsx
var import_jsx_dev_runtime12 = __toESM(require_jsx_dev_runtime(), 1);
function BackmatterParts({ parts }) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(import_jsx_dev_runtime12.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(Backmatter, { title: "Acknowledgments", id: "acknowledgments", content: parts.acknowledgments }, void 0, false, {
      fileName: "../../packages/site/src/components/Backmatter.tsx",
      lineNumber: 9,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
      Backmatter,
      {
        title: "Data Availability",
        id: "data-availability",
        content: parts.data_availability
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Backmatter.tsx",
        lineNumber: 10,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Backmatter.tsx",
    lineNumber: 8,
    columnNumber: 5
  }, this);
}
function Backmatter({
  title,
  id,
  content
}) {
  if (!content)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)("div", { className: "flex flex-col w-full md:flex-row group/backmatter", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
      "h2",
      {
        id,
        className: "mt-5 text-base font-semibold group md:w-[200px] self-start md:flex-none opacity-90 group-hover/backmatter:opacity-100",
        children: [
          title,
          /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(HashLink, { id, title: `Link to ${title}`, hover: true, className: "ml-2" }, void 0, false, {
            fileName: "../../packages/site/src/components/Backmatter.tsx",
            lineNumber: 36,
            columnNumber: 9
          }, this)
        ]
      },
      void 0,
      true,
      {
        fileName: "../../packages/site/src/components/Backmatter.tsx",
        lineNumber: 31,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)("div", { className: "grow", children: /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
      ContentBlocks,
      {
        mdast: content,
        className: "opacity-90 group-hover/backmatter:opacity-100 col-screen"
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Backmatter.tsx",
        lineNumber: 39,
        columnNumber: 9
      },
      this
    ) }, void 0, false, {
      fileName: "../../packages/site/src/components/Backmatter.tsx",
      lineNumber: 38,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Backmatter.tsx",
    lineNumber: 30,
    columnNumber: 5
  }, this);
}

// ../../packages/myst-demo/dist/index.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);

// ../../packages/myst-demo/node_modules/unist-util-is/lib/index.js
var convert = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all);
  function all(node) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node
    );
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type2);
  function type2(node) {
    return node && node.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}

// ../../packages/myst-demo/node_modules/unist-util-remove/lib/index.js
function remove(tree, options, test) {
  const is2 = convert(test || options);
  let cascade = true;
  if (options && typeof options === "object" && "cascade" in options && typeof options.cascade === "boolean") {
    cascade = options.cascade;
  }
  preorder(tree);
  function preorder(node, index2, parent) {
    if (node !== tree && is2(node, index2, parent)) {
      return false;
    }
    if ("children" in node && Array.isArray(node.children)) {
      const nodeAsParent = (
        /** @type {Parent} */
        node
      );
      const children = nodeAsParent.children;
      let oldChildIndex = -1;
      let newChildIndex = 0;
      if (children.length > 0) {
        while (++oldChildIndex < children.length) {
          if (preorder(children[oldChildIndex], oldChildIndex, nodeAsParent)) {
            children[newChildIndex++] = children[oldChildIndex];
          }
        }
        if (node !== tree && cascade && !newChildIndex) {
          return false;
        }
        children.length = newChildIndex;
      }
    }
    return true;
  }
}

// ../../packages/myst-demo/node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject4(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray2(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index2, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
      key = sourceKeys[index2];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result2 = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result2 += string;
  }
  return result2;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject4;
var toArray_1 = toArray2;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact2) {
  var where2 = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where2 += 'in "' + exception2.mark.name + '" ';
  }
  where2 += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact2 && exception2.mark.snippet) {
    where2 += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where2;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString2(compact2) {
  return this.name + ": " + formatError(this, compact2);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max3) {
  return common.repeat(" ", max3 - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result2 = "", i5, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i5 = 1; i5 <= options.linesBefore; i5++) {
    if (foundLineNo - i5 < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i5],
      lineEnds[foundLineNo - i5],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i5]),
      maxLineLength
    );
    result2 = common.repeat(" ", options.indent) + padStart((mark.line - i5 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result2;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result2 += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result2 += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i5 = 1; i5 <= options.linesAfter; i5++) {
    if (foundLineNo + i5 >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i5],
      lineEnds[foundLineNo + i5],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i5]),
      maxLineLength
    );
    result2 += common.repeat(" ", options.indent) + padStart((mark.line + i5 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result2.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map4) {
  var result2 = {};
  if (map4 !== null) {
    Object.keys(map4).forEach(function(style) {
      map4[style].forEach(function(alias) {
        result2[String(alias)] = style;
      });
    });
  }
  return result2;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name2) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
      throw new exception('Unknown option "' + name2 + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name2) {
  var result2 = [];
  schema2[name2].forEach(function(currentType) {
    var newIndex = result2.length;
    result2.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result2[newIndex] = currentType;
  });
  return result2;
}
function compileMap() {
  var result2 = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index2, length;
  function collectType(type2) {
    if (type2.multi) {
      result2.multi[type2.kind].push(type2);
      result2.multi["fallback"].push(type2);
    } else {
      result2[type2.kind][type2.tag] = result2["fallback"][type2.tag] = type2;
    }
  }
  for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
    arguments[index2].forEach(collectType);
  }
  return result2;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result2 = Object.create(Schema$1.prototype);
  result2.implicit = (this.implicit || []).concat(implicit);
  result2.explicit = (this.explicit || []).concat(explicit);
  result2.compiledImplicit = compileList(result2, "implicit");
  result2.compiledExplicit = compileList(result2, "explicit");
  result2.compiledTypeMap = compileMap(result2.compiledImplicit, result2.compiledExplicit);
  return result2;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map3 = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map3
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max3 = data.length;
  return max3 === 1 && data === "~" || max3 === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull2(object2) {
  return object2 === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull2,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max3 = data.length;
  return max3 === 4 && (data === "true" || data === "True" || data === "TRUE") || max3 === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean2(object2) {
  return Object.prototype.toString.call(object2) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean2,
  represent: {
    lowercase: function(object2) {
      return object2 ? "true" : "false";
    },
    uppercase: function(object2) {
      return object2 ? "TRUE" : "FALSE";
    },
    camelcase: function(object2) {
      return object2 ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c6) {
  return 48 <= c6 && c6 <= 57 || 65 <= c6 && c6 <= 70 || 97 <= c6 && c6 <= 102;
}
function isOctCode(c6) {
  return 48 <= c6 && c6 <= 55;
}
function isDecCode(c6) {
  return 48 <= c6 && c6 <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max3 = data.length, index2 = 0, hasDigits = false, ch;
  if (!max3)
    return false;
  ch = data[index2];
  if (ch === "-" || ch === "+") {
    ch = data[++index2];
  }
  if (ch === "0") {
    if (index2 + 1 === max3)
      return true;
    ch = data[++index2];
    if (ch === "b") {
      index2++;
      for (; index2 < max3; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index2++;
      for (; index2 < max3; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index2++;
      for (; index2 < max3; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index2 < max3; index2++) {
    ch = data[index2];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index2))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object2) {
  return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 === 0 && !common.isNegativeZero(object2));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object2, style) {
  var res;
  if (isNaN(object2)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object2) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object2) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object2)) {
    return "-0.0";
  }
  res = object2.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object2) {
  return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 !== 0 || common.isNegativeZero(object2));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object2) {
  return object2.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code3, idx, bitlen = 0, max3 = data.length, map4 = BASE64_MAP;
  for (idx = 0; idx < max3; idx++) {
    code3 = map4.indexOf(data.charAt(idx));
    if (code3 > 64)
      continue;
    if (code3 < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max3 = input.length, map4 = BASE64_MAP, bits = 0, result2 = [];
  for (idx = 0; idx < max3; idx++) {
    if (idx % 4 === 0 && idx) {
      result2.push(bits >> 16 & 255);
      result2.push(bits >> 8 & 255);
      result2.push(bits & 255);
    }
    bits = bits << 6 | map4.indexOf(input.charAt(idx));
  }
  tailbits = max3 % 4 * 6;
  if (tailbits === 0) {
    result2.push(bits >> 16 & 255);
    result2.push(bits >> 8 & 255);
    result2.push(bits & 255);
  } else if (tailbits === 18) {
    result2.push(bits >> 10 & 255);
    result2.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result2.push(bits >> 4 & 255);
  }
  return new Uint8Array(result2);
}
function representYamlBinary(object2) {
  var result2 = "", bits = 0, idx, tail, max3 = object2.length, map4 = BASE64_MAP;
  for (idx = 0; idx < max3; idx++) {
    if (idx % 3 === 0 && idx) {
      result2 += map4[bits >> 18 & 63];
      result2 += map4[bits >> 12 & 63];
      result2 += map4[bits >> 6 & 63];
      result2 += map4[bits & 63];
    }
    bits = (bits << 8) + object2[idx];
  }
  tail = max3 % 3;
  if (tail === 0) {
    result2 += map4[bits >> 18 & 63];
    result2 += map4[bits >> 12 & 63];
    result2 += map4[bits >> 6 & 63];
    result2 += map4[bits & 63];
  } else if (tail === 2) {
    result2 += map4[bits >> 10 & 63];
    result2 += map4[bits >> 4 & 63];
    result2 += map4[bits << 2 & 63];
    result2 += map4[64];
  } else if (tail === 1) {
    result2 += map4[bits >> 2 & 63];
    result2 += map4[bits << 4 & 63];
    result2 += map4[64];
    result2 += map4[64];
  }
  return result2;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object2 = data;
  for (index2 = 0, length = object2.length; index2 < length; index2 += 1) {
    pair = object2[index2];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index2, length, pair, keys2, result2, object2 = data;
  result2 = new Array(object2.length);
  for (index2 = 0, length = object2.length; index2 < length; index2 += 1) {
    pair = object2[index2];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys2 = Object.keys(pair);
    if (keys2.length !== 1)
      return false;
    result2[index2] = [keys2[0], pair[keys2[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index2, length, pair, keys2, result2, object2 = data;
  result2 = new Array(object2.length);
  for (index2 = 0, length = object2.length; index2 < length; index2 += 1) {
    pair = object2[index2];
    keys2 = Object.keys(pair);
    result2[index2] = [keys2[0], pair[keys2[0]]];
  }
  return result2;
}
var pairs2 = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object2 = data;
  for (key in object2) {
    if (_hasOwnProperty$2.call(object2, key)) {
      if (object2[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set2 = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs2,
    set2
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c6) {
  return c6 === 10 || c6 === 13;
}
function is_WHITE_SPACE(c6) {
  return c6 === 9 || c6 === 32;
}
function is_WS_OR_EOL(c6) {
  return c6 === 9 || c6 === 32 || c6 === 10 || c6 === 13;
}
function is_FLOW_INDICATOR(c6) {
  return c6 === 44 || c6 === 91 || c6 === 93 || c6 === 123 || c6 === 125;
}
function fromHexCode(c6) {
  var lc;
  if (48 <= c6 && c6 <= 57) {
    return c6 - 48;
  }
  lc = c6 | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c6) {
  if (c6 === 120) {
    return 2;
  }
  if (c6 === 117) {
    return 4;
  }
  if (c6 === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c6) {
  if (48 <= c6 && c6 <= 57) {
    return c6 - 48;
  }
  return -1;
}
function simpleEscapeSequence(c6) {
  return c6 === 48 ? "\0" : c6 === 97 ? "\x07" : c6 === 98 ? "\b" : c6 === 116 ? "	" : c6 === 9 ? "	" : c6 === 110 ? "\n" : c6 === 118 ? "\v" : c6 === 102 ? "\f" : c6 === 114 ? "\r" : c6 === 101 ? "\x1B" : c6 === 32 ? " " : c6 === 34 ? '"' : c6 === 47 ? "/" : c6 === 92 ? "\\" : c6 === 78 ? "\x85" : c6 === 95 ? "\xA0" : c6 === 76 ? "\u2028" : c6 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c6) {
  if (c6 <= 65535) {
    return String.fromCharCode(c6);
  }
  return String.fromCharCode(
    (c6 - 65536 >> 10) + 55296,
    (c6 - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i5 = 0; i5 < 256; i5++) {
  simpleEscapeCheck[i5] = simpleEscapeSequence(i5) ? 1 : 0;
  simpleEscapeMap[i5] = simpleEscapeSequence(i5);
}
var i5;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name2, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name2, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index2, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
    key = sourceKeys[index2];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index2, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
      if (Array.isArray(keyNode[index2])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
        keyNode[index2] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
        mergeMappings(state, _result, valueNode[index2], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
    iterator(documents[index2]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader2 = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map4) {
  var result2, keys2, index2, length, tag, style, type2;
  if (map4 === null)
    return {};
  result2 = {};
  keys2 = Object.keys(map4);
  for (index2 = 0, length = keys2.length; index2 < length; index2 += 1) {
    tag = keys2[index2];
    style = String(map4[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result2[tag] = style;
  }
  return result2;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result2 = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result2 += ind;
    result2 += line;
  }
  return result2;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index2, length, type2;
  for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
    type2 = state.implicitTypes[index2];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c6) {
  return c6 === CHAR_SPACE || c6 === CHAR_TAB;
}
function isPrintable(c6) {
  return 32 <= c6 && c6 <= 126 || 161 <= c6 && c6 <= 55295 && c6 !== 8232 && c6 !== 8233 || 57344 <= c6 && c6 <= 65533 && c6 !== CHAR_BOM || 65536 <= c6 && c6 <= 1114111;
}
function isNsCharOrWhitespace(c6) {
  return isPrintable(c6) && c6 !== CHAR_BOM && c6 !== CHAR_CARRIAGE_RETURN && c6 !== CHAR_LINE_FEED;
}
function isPlainSafe(c6, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c6);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c6);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c6 !== CHAR_COMMA && c6 !== CHAR_LEFT_SQUARE_BRACKET && c6 !== CHAR_RIGHT_SQUARE_BRACKET && c6 !== CHAR_LEFT_CURLY_BRACKET && c6 !== CHAR_RIGHT_CURLY_BRACKET) && c6 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c6 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c6) {
  return isPrintable(c6) && c6 !== CHAR_BOM && !isWhitespace(c6) && c6 !== CHAR_MINUS && c6 !== CHAR_QUESTION && c6 !== CHAR_COLON && c6 !== CHAR_COMMA && c6 !== CHAR_LEFT_SQUARE_BRACKET && c6 !== CHAR_RIGHT_SQUARE_BRACKET && c6 !== CHAR_LEFT_CURLY_BRACKET && c6 !== CHAR_RIGHT_CURLY_BRACKET && c6 !== CHAR_SHARP && c6 !== CHAR_AMPERSAND && c6 !== CHAR_ASTERISK && c6 !== CHAR_EXCLAMATION && c6 !== CHAR_VERTICAL_LINE && c6 !== CHAR_EQUALS && c6 !== CHAR_GREATER_THAN && c6 !== CHAR_SINGLE_QUOTE && c6 !== CHAR_DOUBLE_QUOTE && c6 !== CHAR_PERCENT && c6 !== CHAR_COMMERCIAL_AT && c6 !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c6) {
  return !isWhitespace(c6) && c6 !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first2 = string.charCodeAt(pos), second;
  if (first2 >= 55296 && first2 <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first2 - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first2;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i5;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i5 = 0; i5 < string.length; char >= 65536 ? i5 += 2 : i5++) {
      char = codePointAt(string, i5);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i5 = 0; i5 < string.length; char >= 65536 ? i5 += 2 : i5++) {
      char = codePointAt(string, i5);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i5 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i5;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i5 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result2 = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result2 += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result2;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result2 = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result2 += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result2 += "\n";
  if (line.length - start > width && curr > start) {
    result2 += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result2 += line.slice(start);
  }
  return result2.slice(1);
}
function escapeString(string) {
  var result2 = "";
  var char = 0;
  var escapeSeq;
  for (var i5 = 0; i5 < string.length; char >= 65536 ? i5 += 2 : i5++) {
    char = codePointAt(string, i5);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result2 += string[i5];
      if (char >= 65536)
        result2 += string[i5 + 1];
    } else {
      result2 += escapeSeq || encodeHex(char);
    }
  }
  return result2;
}
function writeFlowSequence(state, level, object2) {
  var _result = "", _tag = state.tag, index2, length, value;
  for (index2 = 0, length = object2.length; index2 < length; index2 += 1) {
    value = object2[index2];
    if (state.replacer) {
      value = state.replacer.call(object2, String(index2), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object2, compact2) {
  var _result = "", _tag = state.tag, index2, length, value;
  for (index2 = 0, length = object2.length; index2 < length; index2 += 1) {
    value = object2[index2];
    if (state.replacer) {
      value = state.replacer.call(object2, String(index2), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact2 || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object2) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object2), index2, length, objectKey, objectValue, pairBuffer;
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index2];
    objectValue = object2[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object2, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object2, compact2) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object2), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (!compact2 || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index2];
    objectValue = object2[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object2, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object2, explicit) {
  var _result, typeList, index2, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
    type2 = typeList[index2];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object2 === "object" && object2 instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object2))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object2);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object2, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object2, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object2, block, compact2, iskey, isblockseq) {
  state.tag = null;
  state.dump = object2;
  if (!detectType(state, object2, false)) {
    detectType(state, object2, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object2);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact2 = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact2);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact2);
        } else {
          writeBlockSequence(state, level, state.dump, compact2);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object2, state) {
  var objects = [], duplicatesIndexes = [], index2, length;
  inspectNode(object2, objects, duplicatesIndexes);
  for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index2]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object2, objects, duplicatesIndexes) {
  var objectKeyList, index2, length;
  if (object2 !== null && typeof object2 === "object") {
    index2 = objects.indexOf(object2);
    if (index2 !== -1) {
      if (duplicatesIndexes.indexOf(index2) === -1) {
        duplicatesIndexes.push(index2);
      }
    } else {
      objects.push(object2);
      if (Array.isArray(object2)) {
        for (index2 = 0, length = object2.length; index2 < length; index2 += 1) {
          inspectNode(object2[index2], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object2);
        for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
          inspectNode(object2[objectKeyList[index2]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SCHEMA = _default;
var load = loader2.load;
var loadAll = loader2.loadAll;
var dump = dumper.dump;
var YAMLException = exception;
var types = {
  binary,
  float,
  map: map3,
  null: _null,
  pairs: pairs2,
  set: set2,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");
var jsYaml = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SCHEMA,
  load,
  loadAll,
  dump,
  YAMLException,
  types,
  safeLoad,
  safeLoadAll,
  safeDump
};
var js_yaml_default = jsYaml;

// ../../node_modules/myst-frontmatter/dist/utils/normalizeString.js
function normalizeJsonToString(value) {
  return JSON.stringify(Object.entries(value).filter(([, val]) => val !== void 0).sort());
}

// ../../node_modules/myst-frontmatter/dist/utils/referenceStash.js
function pseudoUniqueId(kind, index2, file) {
  let suffix = "";
  if (file) {
    const fileParts = file.replace("\\", "/").split("/");
    const nameParts = fileParts[fileParts.length - 1].split(".");
    if (nameParts.length === 1) {
      suffix = `-${nameParts[0]}`;
    } else {
      suffix = `-${nameParts.slice(0, nameParts.length - 1).join("-")}`;
    }
  }
  return `${kind}${suffix}-generated-uid-${index2}`;
}
function stashPlaceholder(value) {
  return { id: value, name: value };
}
function isStashPlaceholder(object2) {
  var _a;
  if (!object2.name || !object2.id || object2.name !== object2.id)
    return false;
  const nKeys = Object.keys(object2).length;
  if (nKeys === 2)
    return true;
  return nKeys === 3 && ((_a = object2.nameParsed) === null || _a === void 0 ? void 0 : _a.literal) === object2.id;
}
function validateAndStashObject(input, stash, kind, validateFn, opts) {
  var _a, _b, _c;
  const lookup = {};
  const lookupNorm2Id = {};
  (_a = stash[kind]) === null || _a === void 0 ? void 0 : _a.forEach((item) => {
    if (item.id) {
      lookup[item.id] = item;
      lookupNorm2Id[normalizeJsonToString({ ...item, id: void 0 })] = item.id;
    }
  });
  if (typeof input === "string" && Object.keys(lookup).includes(input)) {
    return input;
  }
  const value = validateFn(input, opts);
  if (!value)
    return;
  let warnOnDuplicate = !isStashPlaceholder(value);
  if (!value.id) {
    if (lookupNorm2Id[normalizeJsonToString(value)]) {
      value.id = lookupNorm2Id[normalizeJsonToString(value)];
      warnOnDuplicate = false;
    } else {
      value.id = pseudoUniqueId(kind, (_c = (_b = stash[kind]) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0, opts.file);
    }
  }
  if (!Object.keys(lookup).includes(value.id)) {
    lookup[value.id] = value;
  } else if (isStashPlaceholder(lookup[value.id])) {
    lookup[value.id] = value;
  } else if (warnOnDuplicate) {
    validationWarning(`duplicate id for ${kind} found in frontmatter: ${value.id}`, opts);
  }
  stash[kind] = Object.values(lookup);
  return value.id;
}

// ../../node_modules/myst-frontmatter/dist/utils/validators.js
var GITHUB_USERNAME_REPO_REGEX = "^[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+$";
function validateDoi(value, opts) {
  const doiString = validateString(value, opts);
  if (doiString !== void 0) {
    if (doi.validate(doiString, { strict: true })) {
      return doiString;
    } else {
      validationError("must be valid DOI", opts);
    }
  }
  return void 0;
}
function validateGithubUrl(value, opts) {
  let github = value;
  if (typeof github === "string") {
    const repo = github.match(GITHUB_USERNAME_REPO_REGEX);
    if (repo) {
      github = `https://github.com/${repo}`;
    }
  }
  return validateUrl(github, {
    ...incrementOptions("github", opts),
    includes: "github"
  });
}
function validateStringOrNumber(input, opts) {
  if (typeof input === "string")
    return validateString(input, opts);
  if (typeof input === "number")
    return input;
  return validationError("must be string or number", opts);
}

// ../../node_modules/myst-frontmatter/dist/affiliations/validators.js
var AFFILIATION_KEYS = [
  "id",
  "address",
  "city",
  "state",
  "postal_code",
  "country",
  "name",
  "department",
  "collaboration",
  "isni",
  "ringgold",
  "ror",
  "doi",
  "url",
  "email",
  "phone",
  "fax"
];
var AFFILIATION_ALIASES = {
  ref: "id",
  region: "state",
  province: "state",
  zipcode: "postal_code",
  zip_code: "postal_code",
  website: "url",
  institution: "name"
};
function validateAffiliation(input, opts) {
  if (typeof input === "string") {
    input = stashPlaceholder(input);
  }
  const value = validateObjectKeys(input, { optional: AFFILIATION_KEYS, alias: AFFILIATION_ALIASES }, opts);
  if (value === void 0)
    return void 0;
  if (Object.keys(value).length === 1 && value.id) {
    value.name = value.id;
  }
  const output = {};
  if (defined(value.id)) {
    output.id = validateString(value.id, incrementOptions("id", opts));
  }
  if (defined(value.name)) {
    output.name = validateString(value.name, incrementOptions("name", opts));
  } else {
    validationWarning("affiliation should include name/institution", opts);
  }
  if (defined(value.department)) {
    output.department = validateString(value.department, incrementOptions("department", opts));
  }
  if (defined(value.address)) {
    output.address = validateString(value.address, incrementOptions("address", opts));
  }
  if (defined(value.city)) {
    output.city = validateString(value.city, incrementOptions("city", opts));
  }
  if (defined(value.state)) {
    output.state = validateString(value.state, incrementOptions("state", opts));
  }
  if (defined(value.postal_code)) {
    output.postal_code = validateString(value.postal_code, {
      coerceNumber: true,
      ...incrementOptions("postal_code", opts)
    });
  }
  if (defined(value.country)) {
    output.country = validateString(value.country, incrementOptions("country", opts));
  }
  if (defined(value.isni)) {
    output.isni = validateString(value.isni, incrementOptions("isni", opts));
  }
  if (defined(value.ror)) {
    output.ror = validateString(value.ror, incrementOptions("ror", opts));
  }
  if (defined(value.ringgold)) {
    output.ringgold = validateNumber(value.ringgold, {
      min: 1e3,
      max: 999999,
      ...incrementOptions("ringgold", opts)
    });
  }
  if (defined(value.doi)) {
    output.doi = validateDoi(value.doi, incrementOptions("doi", opts));
  }
  if (defined(value.collaboration)) {
    output.collaboration = validateBoolean(value.collaboration, incrementOptions("collaboration", opts));
  }
  if (defined(value.email)) {
    output.email = validateEmail(value.email, incrementOptions("email", opts));
  }
  if (defined(value.url)) {
    output.url = validateUrl(value.url, incrementOptions("url", opts));
  }
  if (defined(value.phone)) {
    output.phone = validateString(value.phone, incrementOptions("phone", opts));
  }
  if (defined(value.fax)) {
    output.fax = validateString(value.fax, incrementOptions("fax", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/biblio/validators.js
var BIBLIO_KEYS = ["volume", "issue", "first_page", "last_page"];
function validateBiblio(input, opts) {
  const value = validateObjectKeys(input, { optional: BIBLIO_KEYS }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.volume)) {
    output.volume = validateStringOrNumber(value.volume, incrementOptions("volume", opts));
  }
  if (defined(value.issue)) {
    output.issue = validateStringOrNumber(value.issue, incrementOptions("issue", opts));
  }
  if (defined(value.first_page)) {
    output.first_page = validateStringOrNumber(value.first_page, incrementOptions("first_page", opts));
  }
  if (defined(value.last_page)) {
    output.last_page = validateStringOrNumber(value.last_page, incrementOptions("last_page", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/utils/parseName.js
function startsWithUpperCase(word) {
  for (const letter of word) {
    if (letter.toLowerCase() === letter.toUpperCase())
      continue;
    return letter === letter.toUpperCase();
  }
  return true;
}
function parseName(literal) {
  var _a, _b;
  const displayParts = literal.split(",");
  if (displayParts.length === 1) {
    return { literal, ...parseGivenParticleFamily(literal) };
  }
  const lastPart = (_a = displayParts.pop()) === null || _a === void 0 ? void 0 : _a.trim();
  const givenAndParticle = parseGivenParticle(lastPart);
  if (displayParts.length === 1) {
    return { literal, ...givenAndParticle, ...parseParticleFamily(displayParts[0]) };
  }
  const suffix = (_b = displayParts.pop()) === null || _b === void 0 ? void 0 : _b.trim();
  const particleAndFamily = parseParticleFamily(displayParts.join(","));
  if (!suffix)
    return { literal, ...givenAndParticle, ...particleAndFamily };
  return { literal, ...givenAndParticle, ...particleAndFamily, suffix };
}
function parseGivenParticle(name2) {
  const nameParts = name2 === null || name2 === void 0 ? void 0 : name2.trim().split(/\s+/);
  if (!(nameParts === null || nameParts === void 0 ? void 0 : nameParts.length))
    return {};
  let given = nameParts.shift();
  if (!given)
    return {};
  while (nameParts.length && startsWithUpperCase(nameParts[0])) {
    given = `${given} ${nameParts.shift()}`;
  }
  if (!nameParts.length)
    return { given };
  return { given, dropping_particle: nameParts.join(" ") };
}
function parseParticleFamily(name2) {
  const nameParts = name2.trim().split(/\s+/);
  if (!nameParts.length)
    return {};
  let family = nameParts.pop();
  if (!family)
    return {};
  if (nameParts.length && startsWithUpperCase(nameParts[0])) {
    return { family: [...nameParts, family].join(" ") };
  }
  while (nameParts.length && startsWithUpperCase(nameParts[nameParts.length - 1])) {
    family = `${nameParts.pop()} ${family}`;
  }
  if (!nameParts.length)
    return { family };
  return { non_dropping_particle: nameParts.join(" "), family };
}
function parseGivenParticleFamily(name2) {
  const nameParts = name2.trim().split(/\s+/);
  if (!nameParts.length)
    return {};
  let family = nameParts.pop();
  if (!family)
    return {};
  if (!nameParts.length)
    return { family };
  let given = nameParts.shift();
  while (nameParts.length && startsWithUpperCase(nameParts[0])) {
    given = `${given} ${nameParts.shift()}`;
  }
  while (nameParts.length && startsWithUpperCase(nameParts[nameParts.length - 1])) {
    family = `${nameParts.pop()} ${family}`;
  }
  if (!nameParts.length)
    return { given, family };
  return { given, non_dropping_particle: nameParts.join(" "), family };
}
function formatName(name2, alwaysReversed = false) {
  const { literal, given, dropping_particle, non_dropping_particle, family, suffix } = name2;
  if (literal)
    return literal;
  const hasCommas = [given, dropping_particle, non_dropping_particle, family, suffix].join("").includes(",");
  if (!alwaysReversed && !hasCommas && !dropping_particle && !suffix) {
    const formattedName = [given, non_dropping_particle, family].filter(Boolean).join(" ");
    const reParsedName = parseName(formattedName);
    delete reParsedName.literal;
    const serializedParsedName = JSON.stringify(Object.entries(reParsedName).sort());
    const serializedSourceName = JSON.stringify(Object.entries(name2).sort());
    if (serializedParsedName === serializedSourceName) {
      return formattedName;
    }
  }
  let output = ",";
  if (suffix || hasCommas)
    output = `${output}${suffix ? " " : ""}${suffix !== null && suffix !== void 0 ? suffix : ""},`;
  if (given)
    output = `${output} ${given}`;
  if (family)
    output = `${family}${output}`;
  if (dropping_particle)
    output = `${output} ${dropping_particle}`;
  if (non_dropping_particle)
    output = `${non_dropping_particle} ${output}`;
  if (output === ",")
    return "";
  return output;
}

// ../../node_modules/myst-frontmatter/dist/contributors/validators.js
var PERSON_KEYS = [
  "id",
  "userId",
  "name",
  "nameParsed",
  "orcid",
  "corresponding",
  "equal_contributor",
  "deceased",
  "email",
  "roles",
  "affiliations",
  "collaborations",
  "twitter",
  "github",
  "url",
  "note",
  "phone",
  "fax"
];
var PERSON_ALIASES = {
  ref: "id",
  role: "roles",
  "equal-contributor": "equal_contributor",
  affiliation: "affiliations",
  website: "url"
};
var NAME_KEYS = [
  "literal",
  "given",
  "family",
  "suffix",
  "non_dropping_particle",
  "dropping_particle"
];
var NAME_ALIASES = {
  surname: "family",
  last: "family",
  forename: "given",
  first: "given",
  particle: "non_dropping_particle",
  "non-dropping-particle": "non_dropping_particle",
  "dropping-particle": "dropping_particle"
};
function validateName(input, opts) {
  let output;
  let raiseCommaWarnings = false;
  if (typeof input === "string") {
    output = parseName(input);
    raiseCommaWarnings = true;
  } else {
    const value = validateObjectKeys(input, { optional: NAME_KEYS, alias: NAME_ALIASES }, opts);
    if (value === void 0)
      return void 0;
    output = {};
    if (defined(value.literal)) {
      output.literal = validateString(value.literal, incrementOptions("literal", opts));
    }
    if (defined(value.given)) {
      output.given = validateString(value.given, incrementOptions("given", opts));
    }
    if (defined(value.non_dropping_particle)) {
      output.non_dropping_particle = validateString(value.non_dropping_particle, incrementOptions("non_dropping_particle", opts));
    }
    if (defined(value.dropping_particle)) {
      output.dropping_particle = validateString(value.dropping_particle, incrementOptions("dropping_particle", opts));
    }
    if (defined(value.family)) {
      output.family = validateString(value.family, incrementOptions("family", opts));
    }
    if (defined(value.suffix)) {
      output.suffix = validateString(value.suffix, incrementOptions("suffix", opts));
    }
    if (Object.keys(output).length === 1 && output.literal) {
      output = { ...output, ...parseName(output.literal) };
      raiseCommaWarnings = true;
    } else if (!output.literal) {
      output.literal = formatName(output);
      if (output.literal.startsWith(",")) {
        validationWarning(`unexpected comma at beginning of name: ${output.literal} - you may need to define 'name.literal' explicitly`, opts);
      }
    }
  }
  if (raiseCommaWarnings) {
    const warnOnComma = (part, o10) => {
      if (part && part.includes(",")) {
        validationWarning(`unexpected comma in name part: ${part} - you may need to define 'name' explicitly as an object`, o10);
      }
    };
    warnOnComma(output.given, incrementOptions("given", opts));
    warnOnComma(output.family, incrementOptions("family", opts));
    warnOnComma(output.non_dropping_particle, incrementOptions("non_dropping_particle", opts));
    warnOnComma(output.dropping_particle, incrementOptions("dropping_particle", opts));
    warnOnComma(output.suffix, incrementOptions("suffix", opts));
  }
  return output;
}
function validateContributor(input, stash, opts) {
  var _a, _b, _c;
  const inputAff = validateObjectKeys(input, { optional: AFFILIATION_KEYS, alias: AFFILIATION_ALIASES }, {
    ...opts,
    suppressErrors: true,
    suppressWarnings: true
  });
  if ((inputAff === null || inputAff === void 0 ? void 0 : inputAff.collaboration) === true) {
    return validateAffiliation(input, opts);
  }
  if (typeof input === "string") {
    input = stashPlaceholder(input);
  }
  const value = validateObjectKeys(input, { optional: PERSON_KEYS, alias: PERSON_ALIASES }, opts);
  if (value === void 0)
    return void 0;
  if (inputAff && Object.keys(inputAff).length > Object.keys(value).length) {
    validationWarning('contributor may be a collaboration, not a person - if so, add "collaboration: true"', opts);
  }
  if (Object.keys(value).length === 1 && value.id) {
    value.name = value.id;
  }
  const output = {};
  if (defined(value.id)) {
    output.id = validateString(value.id, incrementOptions("id", opts));
  }
  if (defined(value.userId)) {
    output.userId = validateString(value.userId, incrementOptions("userId", opts));
  }
  if (defined(value.nameParsed)) {
    output.nameParsed = validateName(value.nameParsed, incrementOptions("nameParsed", opts));
    output.name = value.name ? validateString(value.name, incrementOptions("name", opts)) : (_a = output.nameParsed) === null || _a === void 0 ? void 0 : _a.literal;
    if (output.name !== ((_b = output.nameParsed) === null || _b === void 0 ? void 0 : _b.literal)) {
      validationWarning(`"name" and "parsedName.literal" should match`, opts);
    }
  } else if (defined(value.name)) {
    output.nameParsed = validateName(value.name, incrementOptions("name", opts));
    output.name = (_c = output.nameParsed) === null || _c === void 0 ? void 0 : _c.literal;
  } else {
    validationWarning("contributor should include name", opts);
  }
  if (defined(value.orcid)) {
    const orcidOpts = incrementOptions("orcid", opts);
    const id = orcid.normalize(value.orcid);
    if (id) {
      output.orcid = id;
    } else {
      validationError(`ORCID "${value.orcid}" is not valid, try an ID of the form "0000-0000-0000-0000"`, orcidOpts);
    }
  }
  if (defined(value.corresponding)) {
    const correspondingOpts = incrementOptions("corresponding", opts);
    output.corresponding = validateBoolean(value.corresponding, correspondingOpts);
    if (value.corresponding && !defined(value.email)) {
      validationError(`must include email for corresponding author`, correspondingOpts);
      output.corresponding = false;
    }
  }
  if (defined(value.equal_contributor)) {
    output.equal_contributor = validateBoolean(value.equal_contributor, incrementOptions("equal_contributor", opts));
  }
  if (defined(value.deceased)) {
    output.deceased = validateBoolean(value.deceased, incrementOptions("deceased", opts));
  }
  if (defined(value.email)) {
    output.email = validateEmail(value.email, incrementOptions("email", opts));
  }
  if (defined(value.roles)) {
    const rolesOpts = incrementOptions("roles", opts);
    let roles = value.roles;
    if (typeof roles === "string") {
      roles = roles.split(/[,;]/);
    }
    output.roles = validateList(roles, rolesOpts, (r4) => {
      const roleString = validateString(r4, rolesOpts);
      if (roleString === void 0)
        return void 0;
      const role = credit.normalize(roleString);
      if (!role) {
        validationWarning(`unknown value "${roleString}" - should be a CRediT role - see https://credit.niso.org/`, rolesOpts);
        return roleString.trim();
      }
      return role;
    });
  }
  if (defined(value.collaborations)) {
    validationError('collaborations must be defined in frontmatter as affiliations with "collaboration: true"', incrementOptions("collaborations", opts));
  }
  if (defined(value.affiliations)) {
    const affiliationsOpts = incrementOptions("affiliations", opts);
    let affiliations = value.affiliations;
    if (typeof affiliations === "string") {
      affiliations = affiliations.split(";").map((aff) => aff.trim());
    }
    if (!Array.isArray(affiliations)) {
      affiliations = [affiliations];
    }
    output.affiliations = validateList(affiliations, affiliationsOpts, (aff) => {
      return validateAndStashObject(aff, stash, "affiliations", validateAffiliation, affiliationsOpts);
    });
  }
  if (defined(value.twitter)) {
    output.twitter = validateString(value.twitter, incrementOptions("twitter", opts));
  }
  if (defined(value.github)) {
    output.github = validateString(value.github, incrementOptions("github", opts));
  }
  if (defined(value.url)) {
    output.url = validateUrl(value.url, incrementOptions("url", opts));
  }
  if (defined(value.phone)) {
    output.phone = validateString(value.phone, incrementOptions("phone", opts));
  }
  if (defined(value.fax)) {
    output.fax = validateString(value.fax, incrementOptions("fax", opts));
  }
  if (defined(value.note)) {
    output.note = validateString(value.note, incrementOptions("note", opts));
  }
  if (isStashPlaceholder(output) || !output.nameParsed)
    return output;
  if (value.nameParsed || value.name && typeof value.name !== "string")
    return output;
  const suffix = " - if this is intended, you may define 'name' explicitly as an object";
  if (!output.nameParsed.given) {
    validationWarning(`No given name for name '${output.nameParsed.literal}'${suffix}`, opts);
  }
  if (!output.nameParsed.family) {
    validationWarning(`No family name for name '${output.nameParsed.literal}'${suffix}`, opts);
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/exports/types.js
var ExportFormats;
(function(ExportFormats2) {
  ExportFormats2["pdf"] = "pdf";
  ExportFormats2["tex"] = "tex";
  ExportFormats2["pdftex"] = "pdf+tex";
  ExportFormats2["typst"] = "typst";
  ExportFormats2["docx"] = "docx";
  ExportFormats2["xml"] = "xml";
  ExportFormats2["md"] = "md";
  ExportFormats2["meca"] = "meca";
})(ExportFormats || (ExportFormats = {}));

// ../../node_modules/myst-frontmatter/dist/funding/validators.js
var AWARD_KEYS = ["id", "name", "description", "sources", "recipients", "investigators"];
var AWARD_ALIASES = { source: "sources", recipient: "recipients", investigator: "investigators" };
var FUNDING_KEYS = ["statement", "open_access", "awards"];
var FUNDING_ALIASES = { award: "awards" };
function validateAward(input, stash, opts) {
  const value = validateObjectKeys(input, { optional: AWARD_KEYS, alias: AWARD_ALIASES }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.id)) {
    output.id = validateString(value.id, { ...incrementOptions("id", opts), coerceNumber: true });
  }
  if (defined(value.name)) {
    output.name = validateString(value.name, incrementOptions("name", opts));
  }
  if (defined(value.description)) {
    output.description = validateString(value.description, incrementOptions("description", opts));
  }
  if (defined(value.sources)) {
    output.sources = validateList(value.sources, { coerce: true, ...incrementOptions("sources", opts) }, (source, index2) => {
      return validateAndStashObject(source, stash, "affiliations", validateAffiliation, incrementOptions(`sources.${index2}`, opts));
    });
  }
  if (defined(value.recipients)) {
    output.recipients = validateList(value.recipients, { coerce: true, ...incrementOptions("recipients", opts) }, (recipient, index2) => {
      return validateAndStashObject(recipient, stash, "contributors", (v2, o10) => validateContributor(v2, stash, o10), incrementOptions(`recipients.${index2}`, opts));
    });
  }
  if (defined(value.investigators)) {
    output.investigators = validateList(value.investigators, { coerce: true, ...incrementOptions("investigators", opts) }, (investigator, index2) => {
      return validateAndStashObject(investigator, stash, "contributors", (v2, o10) => validateContributor(v2, stash, o10), incrementOptions(`investigators.${index2}`, opts));
    });
  }
  return output;
}
function validateFunding(input, stash, opts) {
  if (typeof input === "string") {
    input = { statement: input };
  }
  const valueAsObj = validateObject(input, opts);
  if (valueAsObj === void 0)
    return void 0;
  const value = validateKeys(valueAsObj, { optional: FUNDING_KEYS, alias: FUNDING_ALIASES }, { ...opts, suppressErrors: true, suppressWarnings: true });
  if (value === void 0)
    return void 0;
  if (!value.awards) {
    validateKeys(valueAsObj, {
      optional: [...FUNDING_KEYS, ...AWARD_KEYS],
      alias: { ...FUNDING_ALIASES, ...AWARD_ALIASES }
    }, opts);
    const valueAsAward = validateObjectKeys(input, { optional: AWARD_KEYS, alias: AWARD_ALIASES }, { ...opts, suppressErrors: true, suppressWarnings: true });
    if (valueAsAward && Object.keys(valueAsAward).length > 0) {
      value.awards = [
        validateObjectKeys(input, { optional: AWARD_KEYS, alias: AWARD_ALIASES }, { ...opts, suppressErrors: true, suppressWarnings: true })
      ];
    }
  } else {
    validateKeys(valueAsObj, { optional: FUNDING_KEYS, alias: FUNDING_ALIASES }, opts);
  }
  const output = {};
  if (defined(value.statement)) {
    output.statement = validateString(value.statement, incrementOptions("statement", opts));
  }
  if (defined(value.open_access)) {
    output.open_access = validateString(value.open_access, incrementOptions("open_access", opts));
  }
  if (defined(value.awards)) {
    output.awards = validateList(value.awards, { coerce: true, ...incrementOptions("awards", opts) }, (award, index2) => {
      return validateAward(award, stash, incrementOptions(`awards.${index2}`, opts));
    });
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/venues/validators.js
function validateVenue(input, opts) {
  let titleOpts;
  if (typeof input === "string") {
    input = { title: input };
    titleOpts = opts;
  } else {
    titleOpts = incrementOptions("title", opts);
  }
  const value = validateObjectKeys(input, { optional: ["title", "url"] }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.title)) {
    output.title = validateString(value.title, titleOpts);
  }
  if (defined(value.url)) {
    output.url = validateUrl(value.url, incrementOptions("url", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/site/validators.js
var SITE_FRONTMATTER_KEYS = [
  "title",
  "subtitle",
  "short_title",
  "description",
  "thumbnail",
  "thumbnailOptimized",
  "banner",
  "bannerOptimized",
  "authors",
  "reviewers",
  "editors",
  "contributors",
  "venue",
  "github",
  "keywords",
  "affiliations",
  "funding",
  "copyright",
  "options"
];
var FRONTMATTER_ALIASES = {
  author: "authors",
  reviewer: "reviewers",
  editor: "editors",
  contributor: "contributors",
  affiliation: "affiliations",
  export: "exports",
  jupyter: "thebe",
  part: "parts",
  ack: "acknowledgments",
  acknowledgements: "acknowledgments",
  availability: "data_availability",
  dataAvailability: "data_availability",
  "data-availability": "data_availability",
  quote: "epigraph",
  plain_language_summary: "summary",
  "plain-language-summary": "summary",
  plainLanguageSummary: "summary",
  lay_summary: "summary",
  "lay-summary": "summary",
  keyPoints: "keypoints",
  key_points: "keypoints",
  "key-points": "keypoints",
  image: "thumbnail"
};
function validateSiteFrontmatterKeys(value, opts) {
  var _a, _b, _c, _d, _e;
  const output = {};
  if (defined(value.title)) {
    output.title = validateString(value.title, incrementOptions("title", opts));
  }
  if (defined(value.description)) {
    output.description = validateString(value.description, incrementOptions("description", opts));
  }
  if (defined(value.short_title)) {
    output.short_title = validateString(value.short_title, incrementOptions("short_title", opts));
  }
  if (defined(value.subtitle)) {
    output.subtitle = validateString(value.subtitle, incrementOptions("subtitle", opts));
  }
  if (value.banner === null) {
    output.banner = null;
  } else if (defined(value.banner)) {
    output.banner = validateString(value.banner, incrementOptions("banner", opts));
  }
  if (defined(value.bannerOptimized)) {
    output.bannerOptimized = value.bannerOptimized;
  }
  const stash = {};
  if (defined(value.affiliations)) {
    const affiliationsOpts = incrementOptions("affiliations", opts);
    let affiliations = value.affiliations;
    if (typeof affiliations === "string") {
      affiliations = affiliations.split(";").map((aff) => aff.trim());
    }
    validateList(affiliations, affiliationsOpts, (aff) => {
      return validateAndStashObject(aff, stash, "affiliations", validateAffiliation, affiliationsOpts);
    });
  }
  if (defined(value.authors)) {
    stash.authorIds = validateList(value.authors, { coerce: true, ...incrementOptions("authors", opts) }, (author, index2) => {
      return validateAndStashObject(author, stash, "contributors", (v2, o10) => validateContributor(v2, stash, o10), incrementOptions(`authors.${index2}`, opts));
    });
  }
  if (defined(value.contributors)) {
    validateList(value.contributors, { coerce: true, ...incrementOptions("contributors", opts) }, (contributor, index2) => {
      return validateAndStashObject(contributor, stash, "contributors", (v2, o10) => validateContributor(v2, stash, o10), incrementOptions(`contributors.${index2}`, opts));
    });
  }
  if (defined(value.reviewers)) {
    output.reviewers = validateList(value.reviewers, { coerce: true, ...incrementOptions("reviewers", opts) }, (reviewer, ind) => {
      return validateAndStashObject(reviewer, stash, "contributors", (v2, o10) => validateContributor(v2, stash, o10), incrementOptions(`reviewers.${ind}`, opts));
    });
  }
  if (defined(value.editors)) {
    output.editors = validateList(value.editors, { coerce: true, ...incrementOptions("editors", opts) }, (editor, ind) => {
      return validateAndStashObject(editor, stash, "contributors", (v2, o10) => validateContributor(v2, stash, o10), incrementOptions(`editors.${ind}`, opts));
    });
  }
  if (defined(value.venue)) {
    output.venue = validateVenue(value.venue, incrementOptions("venue", opts));
  }
  if (defined(value.github)) {
    output.github = validateGithubUrl(value.github, incrementOptions("github", opts));
  }
  if (defined(value.keywords)) {
    let keywords = value.keywords;
    if (typeof keywords === "string") {
      keywords = keywords.split(/[,;]/).map((k) => k.trim());
    }
    output.keywords = validateList(keywords, incrementOptions("keywords", opts), (word, ind) => {
      return validateString(word, incrementOptions(`keywords.${ind}`, opts));
    });
  }
  if (defined(value.funding)) {
    output.funding = validateList(value.funding, { coerce: true, ...incrementOptions("funding", opts) }, (fund, index2) => {
      return validateFunding(fund, stash, incrementOptions(`funding.${index2}`, opts));
    });
  }
  if (defined(value.copyright)) {
    output.copyright = validateString(value.copyright, incrementOptions("copyright", opts));
  }
  if (defined(value.options)) {
    const optionsOptions = incrementOptions("options", opts);
    const options = validateObject(value.options, optionsOptions);
    if (options) {
      Object.entries(options).forEach(([key, val]) => {
        var _a2;
        if (RESERVED_EXPORT_KEYS.includes(key)) {
          validationError(`options cannot include reserved key ${key}`, optionsOptions);
        } else {
          ((_a2 = output.options) !== null && _a2 !== void 0 ? _a2 : output.options = {})[key] = val;
        }
      });
    }
  }
  const stashContribAuthors = (_a = stash.contributors) === null || _a === void 0 ? void 0 : _a.filter((contrib) => {
    var _a2;
    return (_a2 = stash.authorIds) === null || _a2 === void 0 ? void 0 : _a2.includes(contrib.id);
  });
  const stashContribNonAuthors = (_b = stash.contributors) === null || _b === void 0 ? void 0 : _b.filter((contrib) => {
    var _a2;
    return !((_a2 = stash.authorIds) === null || _a2 === void 0 ? void 0 : _a2.includes(contrib.id));
  });
  if (stashContribAuthors === null || stashContribAuthors === void 0 ? void 0 : stashContribAuthors.length) {
    output.authors = stashContribAuthors;
    const correspondingAuthor = (_c = output.authors) === null || _c === void 0 ? void 0 : _c.find((a4) => a4.corresponding);
    const personWithEmail = (_d = output.authors) === null || _d === void 0 ? void 0 : _d.find((a4) => a4.email && !a4.collaboration && a4.corresponding === void 0);
    if (!correspondingAuthor && personWithEmail) {
      personWithEmail.corresponding = true;
    }
  }
  if (stashContribNonAuthors === null || stashContribNonAuthors === void 0 ? void 0 : stashContribNonAuthors.length) {
    output.contributors = stashContribNonAuthors;
  }
  if ((_e = stash.affiliations) === null || _e === void 0 ? void 0 : _e.length) {
    output.affiliations = stash.affiliations;
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/project/types.js
var PROJECT_AND_PAGE_FRONTMATTER_KEYS = [
  "date",
  "name",
  "doi",
  "arxiv",
  "open_access",
  "license",
  "binder",
  "source",
  "subject",
  "biblio",
  "oxa",
  "numbering",
  "bibliography",
  "math",
  "abbreviations",
  "exports",
  "settings",
  // Do not add any project specific keys here!
  ...SITE_FRONTMATTER_KEYS
];
var PROJECT_FRONTMATTER_KEYS = [
  ...PROJECT_AND_PAGE_FRONTMATTER_KEYS,
  // These keys only exist on the project
  "id",
  "references",
  "requirements",
  "resources",
  "thebe"
];

// ../../node_modules/myst-frontmatter/dist/page/types.js
var PAGE_KNOWN_PARTS = [
  "abstract",
  "summary",
  "keypoints",
  "dedication",
  "epigraph",
  "data_availability",
  "acknowledgments"
];
var PAGE_FRONTMATTER_KEYS = [
  ...PROJECT_AND_PAGE_FRONTMATTER_KEYS,
  // These keys only exist on the page
  "kernelspec",
  "jupytext",
  "tags",
  "parts",
  "content_includes_title",
  ...PAGE_KNOWN_PARTS
];

// ../../node_modules/myst-frontmatter/dist/exports/validators.js
var EXPORT_KEY_OBJECT = {
  required: [],
  optional: [
    "format",
    "template",
    "output",
    "zip",
    "id",
    "name",
    "renderer",
    "articles",
    "sub_articles"
  ],
  alias: {
    article: "articles",
    sub_article: "sub_articles"
  }
};
var EXPORT_ARTICLE_KEY_OBJECT = {
  optional: [
    "file",
    "title",
    "level",
    ...PAGE_FRONTMATTER_KEYS,
    ...Object.keys(FRONTMATTER_ALIASES)
  ]
};
var EXT_TO_FORMAT = {
  ".pdf": ExportFormats.pdf,
  ".tex": ExportFormats.tex,
  ".doc": ExportFormats.docx,
  ".docx": ExportFormats.docx,
  ".md": ExportFormats.md,
  ".zip": ExportFormats.meca,
  ".meca": ExportFormats.meca,
  ".xml": ExportFormats.xml,
  ".jats": ExportFormats.xml,
  ".typ": ExportFormats.typst,
  ".typst": ExportFormats.typst
};
var RESERVED_EXPORT_KEYS = [
  ...EXPORT_KEY_OBJECT.required,
  ...EXPORT_KEY_OBJECT.optional,
  ...Object.keys(EXPORT_KEY_OBJECT.alias),
  ...PROJECT_FRONTMATTER_KEYS,
  ...Object.keys(FRONTMATTER_ALIASES)
];
var MULTI_ARTICLE_EXPORT_FORMATS = [
  ExportFormats.typst,
  ExportFormats.pdf,
  ExportFormats.tex,
  ExportFormats.pdftex
];
function validateExportsList(input, opts) {
  if (input === void 0)
    return void 0;
  const output = validateList(input, { coerce: true, ...incrementOptions("exports", opts) }, (exp, ind) => {
    return validateExport(exp, incrementOptions(`exports.${ind}`, opts));
  });
  if (!output || output.length === 0)
    return void 0;
  return output;
}
function validateExportFormat(input, opts) {
  if (input === void 0)
    return void 0;
  if (input === "tex+pdf")
    input = "pdf+tex";
  if (input === "jats")
    input = "xml";
  const format2 = validateEnum(input, { ...opts, enum: ExportFormats });
  return format2;
}
function validateExportArticle(input, opts) {
  if (typeof input === "string") {
    input = { file: input };
  }
  const value = validateObjectKeys(input, EXPORT_ARTICLE_KEY_OBJECT, opts);
  if (!value)
    return void 0;
  const output = { ...value };
  if (defined(value.file)) {
    output.file = validateString(value.file, opts);
  }
  if (defined(value.title)) {
    output.title = validateString(value.title, incrementOptions("title", opts));
  }
  if (defined(value.level)) {
    output.level = validateNumber(value.level, {
      min: -1,
      max: 6,
      integer: true,
      ...incrementOptions("level", opts)
    });
  }
  if (!output.title && !output.file) {
    return validationError("export articles must specify file or part/chapter title", opts);
  }
  return output;
}
function articlesWithFile(articles) {
  var _a;
  return (_a = articles === null || articles === void 0 ? void 0 : articles.filter((article) => {
    return !!article.file;
  })) !== null && _a !== void 0 ? _a : [];
}
function singleArticleWithFile(articles) {
  return articlesWithFile(articles)[0];
}
function validateExport(input, opts) {
  if (typeof input === "string") {
    let format3;
    let output2;
    if (input.startsWith(".")) {
      Object.entries(EXT_TO_FORMAT).forEach(([ext, fmt]) => {
        if (input === ext)
          format3 = fmt;
      });
    } else if (input.includes(".")) {
      output2 = input;
    }
    if (!format3 && !output2) {
      format3 = validateExportFormat(input, opts);
      if (!format3)
        return void 0;
    }
    input = { format: format3, output: output2 };
  }
  const value = validateObjectKeys(input, EXPORT_KEY_OBJECT, {
    ...opts,
    suppressWarnings: true,
    keepExtraKeys: true
  });
  if (value === void 0)
    return void 0;
  let format2;
  let output;
  let template2;
  if (value.template === null) {
    template2 = null;
  } else if (defined(value.template)) {
    template2 = validateString(value.template, incrementOptions("template", opts));
  }
  if (defined(value.output)) {
    const outputOpts = incrementOptions("output", opts);
    const outputString = validateString(value.output, outputOpts);
    if (outputString) {
      Object.keys(EXT_TO_FORMAT).forEach((ext) => {
        if (outputString.endsWith(ext))
          output = outputString;
      });
      if (!outputString.slice(1).includes(".")) {
        output = outputString;
      }
      if (!output) {
        return validationError(`unknown export output extension: ${outputString}`, outputOpts);
      }
    }
  }
  if (defined(value.format)) {
    format2 = validateExportFormat(value.format, incrementOptions("format", opts));
    if (!format2)
      return void 0;
  }
  if (!format2 && !template2 && !output) {
    return validationError("export must specify one of: format, template, or output", opts);
  }
  const validExport = { ...value, format: format2, output, template: template2 };
  if (defined(value.zip)) {
    validExport.zip = validateBoolean(value.zip, incrementOptions("zip", opts));
  }
  if (defined(value.articles)) {
    const articles = validateList(value.articles, { coerce: true, ...incrementOptions("articles", opts) }, (item, ind) => validateExportArticle(item, incrementOptions(`articles.${ind}`, opts)));
    const singleArticle = singleArticleWithFile(articles);
    if (articles === null || articles === void 0 ? void 0 : articles.length) {
      if (!singleArticle) {
        validationError("no files found in export article list", opts);
        validExport.articles = void 0;
      } else if (articles.length > 1 && validExport.format && !MULTI_ARTICLE_EXPORT_FORMATS.includes(validExport.format)) {
        if (validExport.format === ExportFormats.xml && !defined(value.sub_articles)) {
          validationError("multiple articles are not supported for 'jats' export - instead specify one article with additional sub_articles", opts);
        } else {
          validationError("multiple articles are only supported for 'tex', 'typst', and 'pdf' exports", opts);
        }
        validExport.articles = [singleArticle];
      } else {
        validExport.articles = articles;
      }
    } else {
      validExport.articles = void 0;
    }
  }
  if (defined(value.sub_articles)) {
    if (validExport.format !== ExportFormats.xml) {
      validationError("sub_articles are only supported for 'jats' export", opts);
      validExport.sub_articles = void 0;
    } else {
      validExport.sub_articles = validateList(value.sub_articles, { coerce: true, ...incrementOptions("sub_articles", opts) }, (file, ind) => {
        return validateString(file, incrementOptions(`sub_articles.${ind}`, opts));
      });
    }
  }
  if (defined(value.toc)) {
    const tocOpts = incrementOptions("toc", opts);
    if (validExport.articles || validExport.sub_articles) {
      validationError("export cannot define both toc file and articles/sub_articles; ignoring toc", tocOpts);
      validExport.toc = void 0;
    } else {
      validExport.toc = validateString(value.toc, tocOpts);
    }
  }
  return validExport;
}

// ../../node_modules/myst-frontmatter/dist/jupytext/validators.js
var TEXT_REPRESENTATION_KEYS = ["extension", "format_name", "format_version", "jupytext_version"];
var JUPYTEXT_KEYS = ["formats", "text_representation"];
function validateTextRepresentation(input, opts) {
  const value = validateObjectKeys(input, { optional: TEXT_REPRESENTATION_KEYS }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.extension)) {
    output.extension = validateString(value.extension, incrementOptions("extension", opts));
  }
  if (defined(value.format_name)) {
    output.format_name = validateString(value.format_name, incrementOptions("format_name", opts));
  }
  if (defined(value.format_version)) {
    const format_version = typeof value.format_version === "number" ? String(value.format_version) : value.format_version;
    output.format_version = validateString(format_version, incrementOptions("format_version", opts));
  }
  if (defined(value.jupytext_version)) {
    output.jupytext_version = validateString(value.jupytext_version, incrementOptions("jupytext_version", opts));
  }
  return output;
}
function validateJupytext(input, opts) {
  const value = validateObjectKeys(input, { optional: JUPYTEXT_KEYS }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.formats)) {
    output.formats = validateString(value.formats, incrementOptions("formats", opts));
  }
  if (defined(value.text_representation)) {
    output.text_representation = validateTextRepresentation(value.text_representation, incrementOptions("text_representation", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/kernelspec/validators.js
var KERNELSPEC_KEYS = ["name", "language", "display_name", "argv", "env"];
function validateKernelSpec(input, opts) {
  const value = validateObjectKeys(input, { optional: KERNELSPEC_KEYS }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.name)) {
    output.name = validateString(value.name, incrementOptions("name", opts));
  }
  if (defined(value.language)) {
    output.language = validateString(value.language, incrementOptions("language", opts));
  }
  if (defined(value.display_name)) {
    output.display_name = validateString(value.display_name, incrementOptions("display_name", opts));
  }
  if (defined(value.env)) {
    output.env = validateObject(value.env, incrementOptions("env", opts));
  }
  if (defined(value.argv)) {
    output.argv = validateList(value.argv, incrementOptions("argv", opts), (arg, index2) => {
      return validateString(arg, incrementOptions(`argv.${index2}`, opts));
    });
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/licenses/licenses.js
var licenses = {
  "0BSD": {
    name: "BSD Zero Clause License",
    osi: true
  },
  AAL: {
    name: "Attribution Assurance License",
    osi: true
  },
  Abstyles: {
    name: "Abstyles License"
  },
  "AdaCore-doc": {
    name: "AdaCore Doc License"
  },
  "Adobe-2006": {
    name: "Adobe Systems Incorporated Source Code License Agreement"
  },
  "Adobe-Display-PostScript": {
    name: "Adobe Display PostScript License"
  },
  "Adobe-Glyph": {
    name: "Adobe Glyph List License"
  },
  "Adobe-Utopia": {
    name: "Adobe Utopia Font License"
  },
  ADSL: {
    name: "Amazon Digital Services License"
  },
  "AFL-1.1": {
    name: "Academic Free License v1.1",
    osi: true,
    free: true
  },
  "AFL-1.2": {
    name: "Academic Free License v1.2",
    osi: true,
    free: true
  },
  "AFL-2.0": {
    name: "Academic Free License v2.0",
    osi: true,
    free: true
  },
  "AFL-2.1": {
    name: "Academic Free License v2.1",
    osi: true,
    free: true
  },
  "AFL-3.0": {
    name: "Academic Free License v3.0",
    osi: true,
    free: true
  },
  Afmparse: {
    name: "Afmparse License"
  },
  "AGPL-1.0-only": {
    name: "Affero General Public License v1.0 only"
  },
  "AGPL-1.0-or-later": {
    name: "Affero General Public License v1.0 or later"
  },
  "AGPL-3.0-only": {
    name: "GNU Affero General Public License v3.0 only",
    osi: true,
    free: true
  },
  "AGPL-3.0-or-later": {
    name: "GNU Affero General Public License v3.0 or later",
    osi: true,
    free: true
  },
  Aladdin: {
    name: "Aladdin Free Public License"
  },
  AMDPLPA: {
    name: "AMD's plpa_map.c License"
  },
  AML: {
    name: "Apple MIT License"
  },
  "AML-glslang": {
    name: "AML glslang variant License"
  },
  AMPAS: {
    name: "Academy of Motion Picture Arts and Sciences BSD"
  },
  "ANTLR-PD": {
    name: "ANTLR Software Rights Notice"
  },
  "ANTLR-PD-fallback": {
    name: "ANTLR Software Rights Notice with license fallback"
  },
  "Apache-1.0": {
    name: "Apache License 1.0",
    free: true
  },
  "Apache-1.1": {
    name: "Apache License 1.1",
    osi: true,
    free: true
  },
  "Apache-2.0": {
    name: "Apache License 2.0",
    osi: true,
    free: true
  },
  APAFML: {
    name: "Adobe Postscript AFM License"
  },
  "APL-1.0": {
    name: "Adaptive Public License 1.0",
    osi: true
  },
  "App-s2p": {
    name: "App::s2p License"
  },
  "APSL-1.0": {
    name: "Apple Public Source License 1.0",
    osi: true
  },
  "APSL-1.1": {
    name: "Apple Public Source License 1.1",
    osi: true
  },
  "APSL-1.2": {
    name: "Apple Public Source License 1.2",
    osi: true
  },
  "APSL-2.0": {
    name: "Apple Public Source License 2.0",
    osi: true,
    free: true
  },
  "Arphic-1999": {
    name: "Arphic Public License"
  },
  "Artistic-1.0": {
    name: "Artistic License 1.0",
    osi: true
  },
  "Artistic-1.0-cl8": {
    name: "Artistic License 1.0 w/clause 8",
    osi: true
  },
  "Artistic-1.0-Perl": {
    name: "Artistic License 1.0 (Perl)",
    osi: true
  },
  "Artistic-2.0": {
    name: "Artistic License 2.0",
    osi: true,
    free: true
  },
  "ASWF-Digital-Assets-1.0": {
    name: "ASWF Digital Assets License version 1.0"
  },
  "ASWF-Digital-Assets-1.1": {
    name: "ASWF Digital Assets License 1.1"
  },
  Baekmuk: {
    name: "Baekmuk License"
  },
  Bahyph: {
    name: "Bahyph License"
  },
  Barr: {
    name: "Barr License"
  },
  "bcrypt-Solar-Designer": {
    name: "bcrypt Solar Designer License"
  },
  Beerware: {
    name: "Beerware License"
  },
  "Bitstream-Charter": {
    name: "Bitstream Charter Font License"
  },
  "Bitstream-Vera": {
    name: "Bitstream Vera Font License"
  },
  "BitTorrent-1.0": {
    name: "BitTorrent Open Source License v1.0"
  },
  "BitTorrent-1.1": {
    name: "BitTorrent Open Source License v1.1",
    free: true
  },
  blessing: {
    name: "SQLite Blessing"
  },
  "BlueOak-1.0.0": {
    name: "Blue Oak Model License 1.0.0",
    osi: true
  },
  "Boehm-GC": {
    name: "Boehm-Demers-Weiser GC License"
  },
  Borceux: {
    name: "Borceux license"
  },
  "Brian-Gladman-2-Clause": {
    name: "Brian Gladman 2-Clause License"
  },
  "Brian-Gladman-3-Clause": {
    name: "Brian Gladman 3-Clause License"
  },
  "BSD-1-Clause": {
    name: "BSD 1-Clause License",
    osi: true
  },
  "BSD-2-Clause": {
    name: 'BSD 2-Clause "Simplified" License',
    osi: true,
    free: true
  },
  "BSD-2-Clause-Darwin": {
    name: "BSD 2-Clause - Ian Darwin variant"
  },
  "BSD-2-Clause-Patent": {
    name: "BSD-2-Clause Plus Patent License",
    osi: true
  },
  "BSD-2-Clause-Views": {
    name: "BSD 2-Clause with views sentence"
  },
  "BSD-3-Clause": {
    name: 'BSD 3-Clause "New" or "Revised" License',
    osi: true,
    free: true
  },
  "BSD-3-Clause-acpica": {
    name: "BSD 3-Clause acpica variant"
  },
  "BSD-3-Clause-Attribution": {
    name: "BSD with attribution"
  },
  "BSD-3-Clause-Clear": {
    name: "BSD 3-Clause Clear License",
    free: true
  },
  "BSD-3-Clause-flex": {
    name: "BSD 3-Clause Flex variant"
  },
  "BSD-3-Clause-HP": {
    name: "Hewlett-Packard BSD variant license"
  },
  "BSD-3-Clause-LBNL": {
    name: "Lawrence Berkeley National Labs BSD variant license",
    osi: true
  },
  "BSD-3-Clause-Modification": {
    name: "BSD 3-Clause Modification"
  },
  "BSD-3-Clause-No-Military-License": {
    name: "BSD 3-Clause No Military License"
  },
  "BSD-3-Clause-No-Nuclear-License": {
    name: "BSD 3-Clause No Nuclear License"
  },
  "BSD-3-Clause-No-Nuclear-License-2014": {
    name: "BSD 3-Clause No Nuclear License 2014"
  },
  "BSD-3-Clause-No-Nuclear-Warranty": {
    name: "BSD 3-Clause No Nuclear Warranty"
  },
  "BSD-3-Clause-Open-MPI": {
    name: "BSD 3-Clause Open MPI variant"
  },
  "BSD-3-Clause-Sun": {
    name: "BSD 3-Clause Sun Microsystems"
  },
  "BSD-4-Clause": {
    name: 'BSD 4-Clause "Original" or "Old" License',
    free: true
  },
  "BSD-4-Clause-Shortened": {
    name: "BSD 4 Clause Shortened"
  },
  "BSD-4-Clause-UC": {
    name: "BSD-4-Clause (University of California-Specific)"
  },
  "BSD-4.3RENO": {
    name: "BSD 4.3 RENO License"
  },
  "BSD-4.3TAHOE": {
    name: "BSD 4.3 TAHOE License"
  },
  "BSD-Advertising-Acknowledgement": {
    name: "BSD Advertising Acknowledgement License"
  },
  "BSD-Attribution-HPND-disclaimer": {
    name: "BSD with Attribution and HPND disclaimer"
  },
  "BSD-Inferno-Nettverk": {
    name: "BSD-Inferno-Nettverk"
  },
  "BSD-Protection": {
    name: "BSD Protection License"
  },
  "BSD-Source-beginning-file": {
    name: "BSD Source Code Attribution - beginning of file variant"
  },
  "BSD-Source-Code": {
    name: "BSD Source Code Attribution"
  },
  "BSD-Systemics": {
    name: "Systemics BSD variant license"
  },
  "BSD-Systemics-W3Works": {
    name: "Systemics W3Works BSD variant license"
  },
  "BSL-1.0": {
    name: "Boost Software License 1.0",
    osi: true,
    free: true
  },
  "BUSL-1.1": {
    name: "Business Source License 1.1"
  },
  "bzip2-1.0.6": {
    name: "bzip2 and libbzip2 License v1.0.6"
  },
  "C-UDA-1.0": {
    name: "Computational Use of Data Agreement v1.0"
  },
  "CAL-1.0": {
    name: "Cryptographic Autonomy License 1.0",
    osi: true
  },
  "CAL-1.0-Combined-Work-Exception": {
    name: "Cryptographic Autonomy License 1.0 (Combined Work Exception)",
    osi: true
  },
  Caldera: {
    name: "Caldera License"
  },
  "Caldera-no-preamble": {
    name: "Caldera License (without preamble)"
  },
  "CATOSL-1.1": {
    name: "Computer Associates Trusted Open Source License 1.1",
    osi: true
  },
  "CC-BY-1.0": {
    name: "Creative Commons Attribution 1.0 Generic",
    CC: true
  },
  "CC-BY-2.0": {
    name: "Creative Commons Attribution 2.0 Generic",
    CC: true
  },
  "CC-BY-2.5": {
    name: "Creative Commons Attribution 2.5 Generic",
    CC: true
  },
  "CC-BY-2.5-AU": {
    name: "Creative Commons Attribution 2.5 Australia",
    CC: true
  },
  "CC-BY-3.0": {
    name: "Creative Commons Attribution 3.0 Unported",
    CC: true
  },
  "CC-BY-3.0-AT": {
    name: "Creative Commons Attribution 3.0 Austria",
    CC: true
  },
  "CC-BY-3.0-AU": {
    name: "Creative Commons Attribution 3.0 Australia",
    CC: true
  },
  "CC-BY-3.0-DE": {
    name: "Creative Commons Attribution 3.0 Germany",
    CC: true
  },
  "CC-BY-3.0-IGO": {
    name: "Creative Commons Attribution 3.0 IGO",
    CC: true
  },
  "CC-BY-3.0-NL": {
    name: "Creative Commons Attribution 3.0 Netherlands",
    CC: true
  },
  "CC-BY-3.0-US": {
    name: "Creative Commons Attribution 3.0 United States",
    CC: true
  },
  "CC-BY-4.0": {
    name: "Creative Commons Attribution 4.0 International",
    free: true,
    CC: true
  },
  "CC-BY-NC-1.0": {
    name: "Creative Commons Attribution Non Commercial 1.0 Generic",
    CC: true
  },
  "CC-BY-NC-2.0": {
    name: "Creative Commons Attribution Non Commercial 2.0 Generic",
    CC: true
  },
  "CC-BY-NC-2.5": {
    name: "Creative Commons Attribution Non Commercial 2.5 Generic",
    CC: true
  },
  "CC-BY-NC-3.0": {
    name: "Creative Commons Attribution Non Commercial 3.0 Unported",
    CC: true
  },
  "CC-BY-NC-3.0-DE": {
    name: "Creative Commons Attribution Non Commercial 3.0 Germany",
    CC: true
  },
  "CC-BY-NC-4.0": {
    name: "Creative Commons Attribution Non Commercial 4.0 International",
    CC: true
  },
  "CC-BY-NC-ND-1.0": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 1.0 Generic",
    CC: true
  },
  "CC-BY-NC-ND-2.0": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 2.0 Generic",
    CC: true
  },
  "CC-BY-NC-ND-2.5": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 2.5 Generic",
    CC: true
  },
  "CC-BY-NC-ND-3.0": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 3.0 Unported",
    CC: true
  },
  "CC-BY-NC-ND-3.0-DE": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 3.0 Germany",
    CC: true
  },
  "CC-BY-NC-ND-3.0-IGO": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 3.0 IGO",
    CC: true
  },
  "CC-BY-NC-ND-4.0": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 4.0 International",
    CC: true
  },
  "CC-BY-NC-SA-1.0": {
    name: "Creative Commons Attribution Non Commercial Share Alike 1.0 Generic",
    CC: true
  },
  "CC-BY-NC-SA-2.0": {
    name: "Creative Commons Attribution Non Commercial Share Alike 2.0 Generic",
    CC: true
  },
  "CC-BY-NC-SA-2.0-DE": {
    name: "Creative Commons Attribution Non Commercial Share Alike 2.0 Germany",
    CC: true
  },
  "CC-BY-NC-SA-2.0-FR": {
    name: "Creative Commons Attribution-NonCommercial-ShareAlike 2.0 France",
    CC: true
  },
  "CC-BY-NC-SA-2.0-UK": {
    name: "Creative Commons Attribution Non Commercial Share Alike 2.0 England and Wales",
    CC: true
  },
  "CC-BY-NC-SA-2.5": {
    name: "Creative Commons Attribution Non Commercial Share Alike 2.5 Generic",
    CC: true
  },
  "CC-BY-NC-SA-3.0": {
    name: "Creative Commons Attribution Non Commercial Share Alike 3.0 Unported",
    CC: true
  },
  "CC-BY-NC-SA-3.0-DE": {
    name: "Creative Commons Attribution Non Commercial Share Alike 3.0 Germany",
    CC: true
  },
  "CC-BY-NC-SA-3.0-IGO": {
    name: "Creative Commons Attribution Non Commercial Share Alike 3.0 IGO",
    CC: true
  },
  "CC-BY-NC-SA-4.0": {
    name: "Creative Commons Attribution Non Commercial Share Alike 4.0 International",
    CC: true
  },
  "CC-BY-ND-1.0": {
    name: "Creative Commons Attribution No Derivatives 1.0 Generic",
    CC: true
  },
  "CC-BY-ND-2.0": {
    name: "Creative Commons Attribution No Derivatives 2.0 Generic",
    CC: true
  },
  "CC-BY-ND-2.5": {
    name: "Creative Commons Attribution No Derivatives 2.5 Generic",
    CC: true
  },
  "CC-BY-ND-3.0": {
    name: "Creative Commons Attribution No Derivatives 3.0 Unported",
    CC: true
  },
  "CC-BY-ND-3.0-DE": {
    name: "Creative Commons Attribution No Derivatives 3.0 Germany",
    CC: true
  },
  "CC-BY-ND-4.0": {
    name: "Creative Commons Attribution No Derivatives 4.0 International",
    CC: true
  },
  "CC-BY-SA-1.0": {
    name: "Creative Commons Attribution Share Alike 1.0 Generic",
    CC: true
  },
  "CC-BY-SA-2.0": {
    name: "Creative Commons Attribution Share Alike 2.0 Generic",
    CC: true
  },
  "CC-BY-SA-2.0-UK": {
    name: "Creative Commons Attribution Share Alike 2.0 England and Wales",
    CC: true
  },
  "CC-BY-SA-2.1-JP": {
    name: "Creative Commons Attribution Share Alike 2.1 Japan",
    CC: true
  },
  "CC-BY-SA-2.5": {
    name: "Creative Commons Attribution Share Alike 2.5 Generic",
    CC: true
  },
  "CC-BY-SA-3.0": {
    name: "Creative Commons Attribution Share Alike 3.0 Unported",
    CC: true
  },
  "CC-BY-SA-3.0-AT": {
    name: "Creative Commons Attribution Share Alike 3.0 Austria",
    CC: true
  },
  "CC-BY-SA-3.0-DE": {
    name: "Creative Commons Attribution Share Alike 3.0 Germany",
    CC: true
  },
  "CC-BY-SA-3.0-IGO": {
    name: "Creative Commons Attribution-ShareAlike 3.0 IGO",
    CC: true
  },
  "CC-BY-SA-4.0": {
    name: "Creative Commons Attribution Share Alike 4.0 International",
    free: true,
    CC: true
  },
  "CC-PDDC": {
    name: "Creative Commons Public Domain Dedication and Certification",
    CC: true
  },
  "CC0-1.0": {
    name: "Creative Commons Zero v1.0 Universal",
    free: true,
    CC: true
  },
  "CDDL-1.0": {
    name: "Common Development and Distribution License 1.0",
    osi: true,
    free: true
  },
  "CDDL-1.1": {
    name: "Common Development and Distribution License 1.1"
  },
  "CDL-1.0": {
    name: "Common Documentation License 1.0"
  },
  "CDLA-Permissive-1.0": {
    name: "Community Data License Agreement Permissive 1.0"
  },
  "CDLA-Permissive-2.0": {
    name: "Community Data License Agreement Permissive 2.0"
  },
  "CDLA-Sharing-1.0": {
    name: "Community Data License Agreement Sharing 1.0"
  },
  "CECILL-1.0": {
    name: "CeCILL Free Software License Agreement v1.0"
  },
  "CECILL-1.1": {
    name: "CeCILL Free Software License Agreement v1.1"
  },
  "CECILL-2.0": {
    name: "CeCILL Free Software License Agreement v2.0",
    free: true
  },
  "CECILL-2.1": {
    name: "CeCILL Free Software License Agreement v2.1",
    osi: true
  },
  "CECILL-B": {
    name: "CeCILL-B Free Software License Agreement",
    free: true
  },
  "CECILL-C": {
    name: "CeCILL-C Free Software License Agreement",
    free: true
  },
  "CERN-OHL-1.1": {
    name: "CERN Open Hardware Licence v1.1"
  },
  "CERN-OHL-1.2": {
    name: "CERN Open Hardware Licence v1.2"
  },
  "CERN-OHL-P-2.0": {
    name: "CERN Open Hardware Licence Version 2 - Permissive",
    osi: true
  },
  "CERN-OHL-S-2.0": {
    name: "CERN Open Hardware Licence Version 2 - Strongly Reciprocal",
    osi: true
  },
  "CERN-OHL-W-2.0": {
    name: "CERN Open Hardware Licence Version 2 - Weakly Reciprocal",
    osi: true
  },
  CFITSIO: {
    name: "CFITSIO License"
  },
  "check-cvs": {
    name: "check-cvs License"
  },
  checkmk: {
    name: "Checkmk License"
  },
  ClArtistic: {
    name: "Clarified Artistic License",
    free: true
  },
  Clips: {
    name: "Clips License"
  },
  "CMU-Mach": {
    name: "CMU Mach License"
  },
  "CMU-Mach-nodoc": {
    name: "CMU    Mach - no notices-in-documentation variant"
  },
  "CNRI-Jython": {
    name: "CNRI Jython License"
  },
  "CNRI-Python": {
    name: "CNRI Python License",
    osi: true
  },
  "CNRI-Python-GPL-Compatible": {
    name: "CNRI Python Open Source GPL Compatible License Agreement"
  },
  "COIL-1.0": {
    name: "Copyfree Open Innovation License"
  },
  "Community-Spec-1.0": {
    name: "Community Specification License 1.0"
  },
  "Condor-1.1": {
    name: "Condor Public License v1.1",
    free: true
  },
  "copyleft-next-0.3.0": {
    name: "copyleft-next 0.3.0"
  },
  "copyleft-next-0.3.1": {
    name: "copyleft-next 0.3.1"
  },
  "Cornell-Lossless-JPEG": {
    name: "Cornell Lossless JPEG License"
  },
  "CPAL-1.0": {
    name: "Common Public Attribution License 1.0",
    osi: true,
    free: true
  },
  "CPL-1.0": {
    name: "Common Public License 1.0",
    osi: true,
    free: true
  },
  "CPOL-1.02": {
    name: "Code Project Open License 1.02"
  },
  Cronyx: {
    name: "Cronyx License"
  },
  Crossword: {
    name: "Crossword License"
  },
  CrystalStacker: {
    name: "CrystalStacker License"
  },
  "CUA-OPL-1.0": {
    name: "CUA Office Public License v1.0",
    osi: true
  },
  Cube: {
    name: "Cube License"
  },
  curl: {
    name: "curl License"
  },
  "D-FSL-1.0": {
    name: "Deutsche Freie Software Lizenz"
  },
  "DEC-3-Clause": {
    name: "DEC 3-Clause License"
  },
  diffmark: {
    name: "diffmark license"
  },
  "DL-DE-BY-2.0": {
    name: "Data licence Germany \u2013 attribution \u2013 version 2.0"
  },
  "DL-DE-ZERO-2.0": {
    name: "Data licence Germany \u2013 zero \u2013 version 2.0"
  },
  DOC: {
    name: "DOC License"
  },
  Dotseqn: {
    name: "Dotseqn License"
  },
  "DRL-1.0": {
    name: "Detection Rule License 1.0"
  },
  "DRL-1.1": {
    name: "Detection Rule License 1.1"
  },
  DSDP: {
    name: "DSDP License"
  },
  dtoa: {
    name: "David M. Gay dtoa License"
  },
  dvipdfm: {
    name: "dvipdfm License"
  },
  "ECL-1.0": {
    name: "Educational Community License v1.0",
    osi: true
  },
  "ECL-2.0": {
    name: "Educational Community License v2.0",
    osi: true,
    free: true
  },
  "EFL-1.0": {
    name: "Eiffel Forum License v1.0",
    osi: true
  },
  "EFL-2.0": {
    name: "Eiffel Forum License v2.0",
    osi: true,
    free: true
  },
  eGenix: {
    name: "eGenix.com Public License 1.1.0"
  },
  "Elastic-2.0": {
    name: "Elastic License 2.0"
  },
  Entessa: {
    name: "Entessa Public License v1.0",
    osi: true
  },
  EPICS: {
    name: "EPICS Open License"
  },
  "EPL-1.0": {
    name: "Eclipse Public License 1.0",
    osi: true,
    free: true
  },
  "EPL-2.0": {
    name: "Eclipse Public License 2.0",
    osi: true,
    free: true
  },
  "ErlPL-1.1": {
    name: "Erlang Public License v1.1"
  },
  "etalab-2.0": {
    name: "Etalab Open License 2.0"
  },
  EUDatagrid: {
    name: "EU DataGrid Software License",
    osi: true,
    free: true
  },
  "EUPL-1.0": {
    name: "European Union Public License 1.0"
  },
  "EUPL-1.1": {
    name: "European Union Public License 1.1",
    osi: true,
    free: true
  },
  "EUPL-1.2": {
    name: "European Union Public License 1.2",
    osi: true,
    free: true
  },
  Eurosym: {
    name: "Eurosym License"
  },
  Fair: {
    name: "Fair License",
    osi: true
  },
  FBM: {
    name: "Fuzzy Bitmap License"
  },
  "FDK-AAC": {
    name: "Fraunhofer FDK AAC Codec Library"
  },
  "Ferguson-Twofish": {
    name: "Ferguson Twofish License"
  },
  "Frameworx-1.0": {
    name: "Frameworx Open License 1.0",
    osi: true
  },
  "FreeBSD-DOC": {
    name: "FreeBSD Documentation License"
  },
  FreeImage: {
    name: "FreeImage Public License v1.0"
  },
  FSFAP: {
    name: "FSF All Permissive License",
    free: true
  },
  "FSFAP-no-warranty-disclaimer": {
    name: "FSF All Permissive License (without Warranty)"
  },
  FSFUL: {
    name: "FSF Unlimited License"
  },
  FSFULLR: {
    name: "FSF Unlimited License (with License Retention)"
  },
  FSFULLRWD: {
    name: "FSF Unlimited License (With License Retention and Warranty Disclaimer)"
  },
  FTL: {
    name: "Freetype Project License",
    free: true
  },
  Furuseth: {
    name: "Furuseth License"
  },
  fwlw: {
    name: "fwlw License"
  },
  "GCR-docs": {
    name: "Gnome GCR Documentation License"
  },
  GD: {
    name: "GD License"
  },
  "GFDL-1.1-invariants-only": {
    name: "GNU Free Documentation License v1.1 only - invariants"
  },
  "GFDL-1.1-invariants-or-later": {
    name: "GNU Free Documentation License v1.1 or later - invariants"
  },
  "GFDL-1.1-no-invariants-only": {
    name: "GNU Free Documentation License v1.1 only - no invariants"
  },
  "GFDL-1.1-no-invariants-or-later": {
    name: "GNU Free Documentation License v1.1 or later - no invariants"
  },
  "GFDL-1.1-only": {
    name: "GNU Free Documentation License v1.1 only",
    free: true
  },
  "GFDL-1.1-or-later": {
    name: "GNU Free Documentation License v1.1 or later",
    free: true
  },
  "GFDL-1.2-invariants-only": {
    name: "GNU Free Documentation License v1.2 only - invariants"
  },
  "GFDL-1.2-invariants-or-later": {
    name: "GNU Free Documentation License v1.2 or later - invariants"
  },
  "GFDL-1.2-no-invariants-only": {
    name: "GNU Free Documentation License v1.2 only - no invariants"
  },
  "GFDL-1.2-no-invariants-or-later": {
    name: "GNU Free Documentation License v1.2 or later - no invariants"
  },
  "GFDL-1.2-only": {
    name: "GNU Free Documentation License v1.2 only",
    free: true
  },
  "GFDL-1.2-or-later": {
    name: "GNU Free Documentation License v1.2 or later",
    free: true
  },
  "GFDL-1.3-invariants-only": {
    name: "GNU Free Documentation License v1.3 only - invariants"
  },
  "GFDL-1.3-invariants-or-later": {
    name: "GNU Free Documentation License v1.3 or later - invariants"
  },
  "GFDL-1.3-no-invariants-only": {
    name: "GNU Free Documentation License v1.3 only - no invariants"
  },
  "GFDL-1.3-no-invariants-or-later": {
    name: "GNU Free Documentation License v1.3 or later - no invariants"
  },
  "GFDL-1.3-only": {
    name: "GNU Free Documentation License v1.3 only",
    free: true
  },
  "GFDL-1.3-or-later": {
    name: "GNU Free Documentation License v1.3 or later",
    free: true
  },
  Giftware: {
    name: "Giftware License"
  },
  GL2PS: {
    name: "GL2PS License"
  },
  Glide: {
    name: "3dfx Glide License"
  },
  Glulxe: {
    name: "Glulxe License"
  },
  GLWTPL: {
    name: "Good Luck With That Public License"
  },
  gnuplot: {
    name: "gnuplot License",
    free: true
  },
  "GPL-1.0-only": {
    name: "GNU General Public License v1.0 only"
  },
  "GPL-1.0-or-later": {
    name: "GNU General Public License v1.0 or later"
  },
  "GPL-2.0-only": {
    name: "GNU General Public License v2.0 only",
    osi: true,
    free: true
  },
  "GPL-2.0-or-later": {
    name: "GNU General Public License v2.0 or later",
    osi: true,
    free: true
  },
  "GPL-3.0-only": {
    name: "GNU General Public License v3.0 only",
    osi: true,
    free: true
  },
  "GPL-3.0-or-later": {
    name: "GNU General Public License v3.0 or later",
    osi: true,
    free: true
  },
  "Graphics-Gems": {
    name: "Graphics Gems License"
  },
  "gSOAP-1.3b": {
    name: "gSOAP Public License v1.3b"
  },
  gtkbook: {
    name: "gtkbook License"
  },
  HaskellReport: {
    name: "Haskell Language Report License"
  },
  hdparm: {
    name: "hdparm License"
  },
  "Hippocratic-2.1": {
    name: "Hippocratic License 2.1"
  },
  "HP-1986": {
    name: "Hewlett-Packard 1986 License"
  },
  "HP-1989": {
    name: "Hewlett-Packard 1989 License"
  },
  HPND: {
    name: "Historical Permission Notice and Disclaimer",
    osi: true,
    free: true
  },
  "HPND-DEC": {
    name: "Historical Permission Notice and Disclaimer - DEC variant"
  },
  "HPND-doc": {
    name: "Historical Permission Notice and Disclaimer - documentation variant"
  },
  "HPND-doc-sell": {
    name: "Historical Permission Notice and Disclaimer - documentation sell variant"
  },
  "HPND-export-US": {
    name: "HPND with US Government export control warning"
  },
  "HPND-export-US-modify": {
    name: "HPND with US Government export control warning and modification rqmt"
  },
  "HPND-Fenneberg-Livingston": {
    name: "Historical Permission Notice and Disclaimer - Fenneberg-Livingston variant"
  },
  "HPND-INRIA-IMAG": {
    name: "Historical Permission Notice and Disclaimer    - INRIA-IMAG variant"
  },
  "HPND-Kevlin-Henney": {
    name: "Historical Permission Notice and Disclaimer - Kevlin Henney variant"
  },
  "HPND-Markus-Kuhn": {
    name: "Historical Permission Notice and Disclaimer - Markus Kuhn variant"
  },
  "HPND-MIT-disclaimer": {
    name: "Historical Permission Notice and Disclaimer with MIT disclaimer"
  },
  "HPND-Pbmplus": {
    name: "Historical Permission Notice and Disclaimer - Pbmplus variant"
  },
  "HPND-sell-MIT-disclaimer-xserver": {
    name: "Historical Permission Notice and Disclaimer - sell xserver variant with MIT disclaimer"
  },
  "HPND-sell-regexpr": {
    name: "Historical Permission Notice and Disclaimer - sell regexpr variant"
  },
  "HPND-sell-variant": {
    name: "Historical Permission Notice and Disclaimer - sell variant"
  },
  "HPND-sell-variant-MIT-disclaimer": {
    name: "HPND sell variant with MIT disclaimer"
  },
  "HPND-UC": {
    name: "Historical Permission Notice and Disclaimer - University of California variant"
  },
  HTMLTIDY: {
    name: "HTML Tidy License"
  },
  "IBM-pibs": {
    name: "IBM PowerPC Initialization and Boot Software"
  },
  ICU: {
    name: "ICU License",
    osi: true
  },
  "IEC-Code-Components-EULA": {
    name: "IEC    Code Components End-user licence agreement"
  },
  IJG: {
    name: "Independent JPEG Group License",
    free: true
  },
  "IJG-short": {
    name: "Independent JPEG Group License - short"
  },
  ImageMagick: {
    name: "ImageMagick License"
  },
  iMatix: {
    name: "iMatix Standard Function Library Agreement",
    free: true
  },
  Imlib2: {
    name: "Imlib2 License",
    free: true
  },
  "Info-ZIP": {
    name: "Info-ZIP License"
  },
  "Inner-Net-2.0": {
    name: "Inner Net License v2.0"
  },
  Intel: {
    name: "Intel Open Source License",
    osi: true,
    free: true
  },
  "Intel-ACPI": {
    name: "Intel ACPI Software License Agreement"
  },
  "Interbase-1.0": {
    name: "Interbase Public License v1.0"
  },
  IPA: {
    name: "IPA Font License",
    osi: true,
    free: true
  },
  "IPL-1.0": {
    name: "IBM Public License v1.0",
    osi: true,
    free: true
  },
  ISC: {
    name: "ISC License",
    osi: true,
    free: true
  },
  "ISC-Veillard": {
    name: "ISC Veillard variant"
  },
  Jam: {
    name: "Jam License",
    osi: true
  },
  "JasPer-2.0": {
    name: "JasPer License"
  },
  "JPL-image": {
    name: "JPL Image Use Policy"
  },
  JPNIC: {
    name: "Japan Network Information Center License"
  },
  JSON: {
    name: "JSON License"
  },
  Kastrup: {
    name: "Kastrup License"
  },
  Kazlib: {
    name: "Kazlib License"
  },
  "Knuth-CTAN": {
    name: "Knuth CTAN License"
  },
  "LAL-1.2": {
    name: "Licence Art Libre 1.2"
  },
  "LAL-1.3": {
    name: "Licence Art Libre 1.3"
  },
  Latex2e: {
    name: "Latex2e License"
  },
  "Latex2e-translated-notice": {
    name: "Latex2e with translated notice permission"
  },
  Leptonica: {
    name: "Leptonica License"
  },
  "LGPL-2.0-only": {
    name: "GNU Library General Public License v2 only",
    osi: true
  },
  "LGPL-2.0-or-later": {
    name: "GNU Library General Public License v2 or later",
    osi: true
  },
  "LGPL-2.1-only": {
    name: "GNU Lesser General Public License v2.1 only",
    osi: true,
    free: true
  },
  "LGPL-2.1-or-later": {
    name: "GNU Lesser General Public License v2.1 or later",
    osi: true,
    free: true
  },
  "LGPL-3.0-only": {
    name: "GNU Lesser General Public License v3.0 only",
    osi: true,
    free: true
  },
  "LGPL-3.0-or-later": {
    name: "GNU Lesser General Public License v3.0 or later",
    osi: true,
    free: true
  },
  LGPLLR: {
    name: "Lesser General Public License For Linguistic Resources"
  },
  Libpng: {
    name: "libpng License"
  },
  "libpng-2.0": {
    name: "PNG Reference Library version 2"
  },
  "libselinux-1.0": {
    name: "libselinux public domain notice"
  },
  libtiff: {
    name: "libtiff License"
  },
  "libutil-David-Nugent": {
    name: "libutil David Nugent License"
  },
  "LiLiQ-P-1.1": {
    name: "Licence Libre du Qu\xE9bec \u2013 Permissive version 1.1",
    osi: true
  },
  "LiLiQ-R-1.1": {
    name: "Licence Libre du Qu\xE9bec \u2013 R\xE9ciprocit\xE9 version 1.1",
    osi: true
  },
  "LiLiQ-Rplus-1.1": {
    name: "Licence Libre du Qu\xE9bec \u2013 R\xE9ciprocit\xE9 forte version 1.1",
    osi: true
  },
  "Linux-man-pages-1-para": {
    name: "Linux man-pages - 1 paragraph"
  },
  "Linux-man-pages-copyleft": {
    name: "Linux man-pages Copyleft"
  },
  "Linux-man-pages-copyleft-2-para": {
    name: "Linux man-pages Copyleft - 2 paragraphs"
  },
  "Linux-man-pages-copyleft-var": {
    name: "Linux man-pages Copyleft Variant"
  },
  "Linux-OpenIB": {
    name: "Linux Kernel Variant of OpenIB.org license"
  },
  LOOP: {
    name: "Common Lisp LOOP License"
  },
  "LPD-document": {
    name: "LPD Documentation License"
  },
  "LPL-1.0": {
    name: "Lucent Public License Version 1.0",
    osi: true
  },
  "LPL-1.02": {
    name: "Lucent Public License v1.02",
    osi: true,
    free: true
  },
  "LPPL-1.0": {
    name: "LaTeX Project Public License v1.0"
  },
  "LPPL-1.1": {
    name: "LaTeX Project Public License v1.1"
  },
  "LPPL-1.2": {
    name: "LaTeX Project Public License v1.2",
    free: true
  },
  "LPPL-1.3a": {
    name: "LaTeX Project Public License v1.3a",
    free: true
  },
  "LPPL-1.3c": {
    name: "LaTeX Project Public License v1.3c",
    osi: true
  },
  lsof: {
    name: "lsof License"
  },
  "Lucida-Bitmap-Fonts": {
    name: "Lucida Bitmap Fonts License"
  },
  "LZMA-SDK-9.11-to-9.20": {
    name: "LZMA SDK License (versions 9.11 to 9.20)"
  },
  "LZMA-SDK-9.22": {
    name: "LZMA SDK License (versions 9.22 and beyond)"
  },
  "Mackerras-3-Clause": {
    name: "Mackerras 3-Clause License"
  },
  "Mackerras-3-Clause-acknowledgment": {
    name: "Mackerras 3-Clause - acknowledgment variant"
  },
  magaz: {
    name: "magaz License"
  },
  mailprio: {
    name: "mailprio License"
  },
  MakeIndex: {
    name: "MakeIndex License"
  },
  "Martin-Birgmeier": {
    name: "Martin Birgmeier License"
  },
  "McPhee-slideshow": {
    name: "McPhee Slideshow License"
  },
  metamail: {
    name: "metamail License"
  },
  Minpack: {
    name: "Minpack License"
  },
  MirOS: {
    name: "The MirOS Licence",
    osi: true
  },
  MIT: {
    name: "MIT License",
    osi: true,
    free: true
  },
  "MIT-0": {
    name: "MIT No Attribution",
    osi: true
  },
  "MIT-advertising": {
    name: "Enlightenment License (e16)"
  },
  "MIT-CMU": {
    name: "CMU License"
  },
  "MIT-enna": {
    name: "enna License"
  },
  "MIT-feh": {
    name: "feh License"
  },
  "MIT-Festival": {
    name: "MIT Festival Variant"
  },
  "MIT-Modern-Variant": {
    name: "MIT License Modern Variant",
    osi: true
  },
  "MIT-open-group": {
    name: "MIT Open Group variant"
  },
  "MIT-testregex": {
    name: "MIT testregex Variant"
  },
  "MIT-Wu": {
    name: "MIT Tom Wu Variant"
  },
  MITNFA: {
    name: "MIT +no-false-attribs license"
  },
  MMIXware: {
    name: "MMIXware License"
  },
  Motosoto: {
    name: "Motosoto License",
    osi: true
  },
  "MPEG-SSG": {
    name: "MPEG Software Simulation"
  },
  "mpi-permissive": {
    name: "mpi Permissive License"
  },
  mpich2: {
    name: "mpich2 License"
  },
  "MPL-1.0": {
    name: "Mozilla Public License 1.0",
    osi: true
  },
  "MPL-1.1": {
    name: "Mozilla Public License 1.1",
    osi: true,
    free: true
  },
  "MPL-2.0": {
    name: "Mozilla Public License 2.0",
    osi: true,
    free: true
  },
  "MPL-2.0-no-copyleft-exception": {
    name: "Mozilla Public License 2.0 (no copyleft exception)",
    osi: true
  },
  mplus: {
    name: "mplus Font License"
  },
  "MS-LPL": {
    name: "Microsoft Limited Public License"
  },
  "MS-PL": {
    name: "Microsoft Public License",
    osi: true,
    free: true
  },
  "MS-RL": {
    name: "Microsoft Reciprocal License",
    osi: true,
    free: true
  },
  MTLL: {
    name: "Matrix Template Library License"
  },
  "MulanPSL-1.0": {
    name: "Mulan Permissive Software License, Version 1"
  },
  "MulanPSL-2.0": {
    name: "Mulan Permissive Software License, Version 2",
    osi: true
  },
  Multics: {
    name: "Multics License",
    osi: true
  },
  Mup: {
    name: "Mup License"
  },
  "NAIST-2003": {
    name: "Nara Institute of Science and Technology License (2003)"
  },
  "NASA-1.3": {
    name: "NASA Open Source Agreement 1.3",
    osi: true
  },
  Naumen: {
    name: "Naumen Public License",
    osi: true
  },
  "NBPL-1.0": {
    name: "Net Boolean Public License v1"
  },
  "NCGL-UK-2.0": {
    name: "Non-Commercial Government Licence"
  },
  NCSA: {
    name: "University of Illinois/NCSA Open Source License",
    osi: true,
    free: true
  },
  "Net-SNMP": {
    name: "Net-SNMP License"
  },
  NetCDF: {
    name: "NetCDF license"
  },
  Newsletr: {
    name: "Newsletr License"
  },
  NGPL: {
    name: "Nethack General Public License",
    osi: true
  },
  "NICTA-1.0": {
    name: "NICTA Public Software License, Version 1.0"
  },
  "NIST-PD": {
    name: "NIST Public Domain Notice"
  },
  "NIST-PD-fallback": {
    name: "NIST Public Domain Notice with license fallback"
  },
  "NIST-Software": {
    name: "NIST Software License"
  },
  "NLOD-1.0": {
    name: "Norwegian Licence for Open Government Data (NLOD) 1.0"
  },
  "NLOD-2.0": {
    name: "Norwegian Licence for Open Government Data (NLOD) 2.0"
  },
  NLPL: {
    name: "No Limit Public License"
  },
  Nokia: {
    name: "Nokia Open Source License",
    osi: true,
    free: true
  },
  NOSL: {
    name: "Netizen Open Source License",
    free: true
  },
  Noweb: {
    name: "Noweb License"
  },
  "NPL-1.0": {
    name: "Netscape Public License v1.0",
    free: true
  },
  "NPL-1.1": {
    name: "Netscape Public License v1.1",
    free: true
  },
  "NPOSL-3.0": {
    name: "Non-Profit Open Software License 3.0",
    osi: true
  },
  NRL: {
    name: "NRL License"
  },
  NTP: {
    name: "NTP License",
    osi: true
  },
  "NTP-0": {
    name: "NTP No Attribution"
  },
  "O-UDA-1.0": {
    name: "Open Use of Data Agreement v1.0"
  },
  "OCCT-PL": {
    name: "Open CASCADE Technology Public License"
  },
  "OCLC-2.0": {
    name: "OCLC Research Public License 2.0",
    osi: true
  },
  "ODbL-1.0": {
    name: "Open Data Commons Open Database License v1.0",
    free: true
  },
  "ODC-By-1.0": {
    name: "Open Data Commons Attribution License v1.0"
  },
  OFFIS: {
    name: "OFFIS License"
  },
  "OFL-1.0": {
    name: "SIL Open Font License 1.0",
    free: true
  },
  "OFL-1.0-no-RFN": {
    name: "SIL Open Font License 1.0 with no Reserved Font Name"
  },
  "OFL-1.0-RFN": {
    name: "SIL Open Font License 1.0 with Reserved Font Name"
  },
  "OFL-1.1": {
    name: "SIL Open Font License 1.1",
    osi: true,
    free: true
  },
  "OFL-1.1-no-RFN": {
    name: "SIL Open Font License 1.1 with no Reserved Font Name",
    osi: true
  },
  "OFL-1.1-RFN": {
    name: "SIL Open Font License 1.1 with Reserved Font Name",
    osi: true
  },
  "OGC-1.0": {
    name: "OGC Software License, Version 1.0"
  },
  "OGDL-Taiwan-1.0": {
    name: "Taiwan Open Government Data License, version 1.0"
  },
  "OGL-Canada-2.0": {
    name: "Open Government Licence - Canada"
  },
  "OGL-UK-1.0": {
    name: "Open Government Licence v1.0"
  },
  "OGL-UK-2.0": {
    name: "Open Government Licence v2.0"
  },
  "OGL-UK-3.0": {
    name: "Open Government Licence v3.0"
  },
  OGTSL: {
    name: "Open Group Test Suite License",
    osi: true
  },
  "OLDAP-1.1": {
    name: "Open LDAP Public License v1.1"
  },
  "OLDAP-1.2": {
    name: "Open LDAP Public License v1.2"
  },
  "OLDAP-1.3": {
    name: "Open LDAP Public License v1.3"
  },
  "OLDAP-1.4": {
    name: "Open LDAP Public License v1.4"
  },
  "OLDAP-2.0": {
    name: "Open LDAP Public License v2.0 (or possibly 2.0A and 2.0B)"
  },
  "OLDAP-2.0.1": {
    name: "Open LDAP Public License v2.0.1"
  },
  "OLDAP-2.1": {
    name: "Open LDAP Public License v2.1"
  },
  "OLDAP-2.2": {
    name: "Open LDAP Public License v2.2"
  },
  "OLDAP-2.2.1": {
    name: "Open LDAP Public License v2.2.1"
  },
  "OLDAP-2.2.2": {
    name: "Open LDAP Public License 2.2.2"
  },
  "OLDAP-2.3": {
    name: "Open LDAP Public License v2.3",
    free: true
  },
  "OLDAP-2.4": {
    name: "Open LDAP Public License v2.4"
  },
  "OLDAP-2.5": {
    name: "Open LDAP Public License v2.5"
  },
  "OLDAP-2.6": {
    name: "Open LDAP Public License v2.6"
  },
  "OLDAP-2.7": {
    name: "Open LDAP Public License v2.7",
    free: true
  },
  "OLDAP-2.8": {
    name: "Open LDAP Public License v2.8",
    osi: true
  },
  "OLFL-1.3": {
    name: "Open Logistics Foundation License Version 1.3",
    osi: true
  },
  OML: {
    name: "Open Market License"
  },
  "OpenPBS-2.3": {
    name: "OpenPBS v2.3 Software License"
  },
  OpenSSL: {
    name: "OpenSSL License",
    free: true
  },
  "OpenSSL-standalone": {
    name: "OpenSSL License - standalone"
  },
  OpenVision: {
    name: "OpenVision License"
  },
  "OPL-1.0": {
    name: "Open Public License v1.0"
  },
  "OPL-UK-3.0": {
    name: "United    Kingdom Open Parliament Licence v3.0"
  },
  "OPUBL-1.0": {
    name: "Open Publication License v1.0"
  },
  "OSET-PL-2.1": {
    name: "OSET Public License version 2.1",
    osi: true
  },
  "OSL-1.0": {
    name: "Open Software License 1.0",
    osi: true,
    free: true
  },
  "OSL-1.1": {
    name: "Open Software License 1.1",
    free: true
  },
  "OSL-2.0": {
    name: "Open Software License 2.0",
    osi: true,
    free: true
  },
  "OSL-2.1": {
    name: "Open Software License 2.1",
    osi: true,
    free: true
  },
  "OSL-3.0": {
    name: "Open Software License 3.0",
    osi: true,
    free: true
  },
  PADL: {
    name: "PADL License"
  },
  "Parity-6.0.0": {
    name: "The Parity Public License 6.0.0"
  },
  "Parity-7.0.0": {
    name: "The Parity Public License 7.0.0"
  },
  "PDDL-1.0": {
    name: "Open Data Commons Public Domain Dedication & License 1.0"
  },
  "PHP-3.0": {
    name: "PHP License v3.0",
    osi: true
  },
  "PHP-3.01": {
    name: "PHP License v3.01",
    osi: true,
    free: true
  },
  Pixar: {
    name: "Pixar License"
  },
  Plexus: {
    name: "Plexus Classworlds License"
  },
  pnmstitch: {
    name: "pnmstitch License"
  },
  "PolyForm-Noncommercial-1.0.0": {
    name: "PolyForm Noncommercial License 1.0.0"
  },
  "PolyForm-Small-Business-1.0.0": {
    name: "PolyForm Small Business License 1.0.0"
  },
  PostgreSQL: {
    name: "PostgreSQL License",
    osi: true
  },
  "PSF-2.0": {
    name: "Python Software Foundation License 2.0"
  },
  psfrag: {
    name: "psfrag License"
  },
  psutils: {
    name: "psutils License"
  },
  "Python-2.0": {
    name: "Python License 2.0",
    osi: true,
    free: true
  },
  "Python-2.0.1": {
    name: "Python License 2.0.1"
  },
  "python-ldap": {
    name: "Python ldap License"
  },
  Qhull: {
    name: "Qhull License"
  },
  "QPL-1.0": {
    name: "Q Public License 1.0",
    osi: true,
    free: true
  },
  "QPL-1.0-INRIA-2004": {
    name: "Q Public License 1.0 - INRIA 2004 variant"
  },
  radvd: {
    name: "radvd License"
  },
  Rdisc: {
    name: "Rdisc License"
  },
  "RHeCos-1.1": {
    name: "Red Hat eCos Public License v1.1"
  },
  "RPL-1.1": {
    name: "Reciprocal Public License 1.1",
    osi: true
  },
  "RPL-1.5": {
    name: "Reciprocal Public License 1.5",
    osi: true
  },
  "RPSL-1.0": {
    name: "RealNetworks Public Source License v1.0",
    osi: true,
    free: true
  },
  "RSA-MD": {
    name: "RSA Message-Digest License"
  },
  RSCPL: {
    name: "Ricoh Source Code Public License",
    osi: true
  },
  Ruby: {
    name: "Ruby License",
    free: true
  },
  "SAX-PD": {
    name: "Sax Public Domain Notice"
  },
  "SAX-PD-2.0": {
    name: "Sax Public Domain Notice 2.0"
  },
  Saxpath: {
    name: "Saxpath License"
  },
  SCEA: {
    name: "SCEA Shared Source License"
  },
  SchemeReport: {
    name: "Scheme Language Report License"
  },
  Sendmail: {
    name: "Sendmail License"
  },
  "Sendmail-8.23": {
    name: "Sendmail License 8.23"
  },
  "SGI-B-1.0": {
    name: "SGI Free Software License B v1.0"
  },
  "SGI-B-1.1": {
    name: "SGI Free Software License B v1.1"
  },
  "SGI-B-2.0": {
    name: "SGI Free Software License B v2.0",
    free: true
  },
  "SGI-OpenGL": {
    name: "SGI OpenGL License"
  },
  SGP4: {
    name: "SGP4 Permission Notice"
  },
  "SHL-0.5": {
    name: "Solderpad Hardware License v0.5"
  },
  "SHL-0.51": {
    name: "Solderpad Hardware License, Version 0.51"
  },
  "SimPL-2.0": {
    name: "Simple Public License 2.0",
    osi: true
  },
  SISSL: {
    name: "Sun Industry Standards Source License v1.1",
    osi: true,
    free: true
  },
  "SISSL-1.2": {
    name: "Sun Industry Standards Source License v1.2"
  },
  SL: {
    name: "SL License"
  },
  Sleepycat: {
    name: "Sleepycat License",
    osi: true,
    free: true
  },
  SMLNJ: {
    name: "Standard ML of New Jersey License",
    free: true
  },
  SMPPL: {
    name: "Secure Messaging Protocol Public License"
  },
  SNIA: {
    name: "SNIA Public License 1.1"
  },
  snprintf: {
    name: "snprintf License"
  },
  softSurfer: {
    name: "softSurfer License"
  },
  Soundex: {
    name: "Soundex License"
  },
  "Spencer-86": {
    name: "Spencer License 86"
  },
  "Spencer-94": {
    name: "Spencer License 94"
  },
  "Spencer-99": {
    name: "Spencer License 99"
  },
  "SPL-1.0": {
    name: "Sun Public License v1.0",
    osi: true,
    free: true
  },
  "ssh-keyscan": {
    name: "ssh-keyscan License"
  },
  "SSH-OpenSSH": {
    name: "SSH OpenSSH license"
  },
  "SSH-short": {
    name: "SSH short notice"
  },
  "SSLeay-standalone": {
    name: "SSLeay License - standalone"
  },
  "SSPL-1.0": {
    name: "Server Side Public License, v 1"
  },
  "SugarCRM-1.1.3": {
    name: "SugarCRM Public License v1.1.3"
  },
  "Sun-PPP": {
    name: "Sun PPP License"
  },
  SunPro: {
    name: "SunPro License"
  },
  SWL: {
    name: "Scheme Widget Library (SWL) Software License Agreement"
  },
  swrule: {
    name: "swrule License"
  },
  Symlinks: {
    name: "Symlinks License"
  },
  "TAPR-OHL-1.0": {
    name: "TAPR Open Hardware License v1.0"
  },
  TCL: {
    name: "TCL/TK License"
  },
  "TCP-wrappers": {
    name: "TCP Wrappers License"
  },
  TermReadKey: {
    name: "TermReadKey License"
  },
  "TGPPL-1.0": {
    name: "Transitive Grace Period Public Licence 1.0"
  },
  TMate: {
    name: "TMate Open Source License"
  },
  "TORQUE-1.1": {
    name: "TORQUE v2.5+ Software License v1.1"
  },
  TOSL: {
    name: "Trusster Open Source License"
  },
  TPDL: {
    name: "Time::ParseDate License"
  },
  "TPL-1.0": {
    name: "THOR Public License 1.0"
  },
  TTWL: {
    name: "Text-Tabs+Wrap License"
  },
  TTYP0: {
    name: "TTYP0 License"
  },
  "TU-Berlin-1.0": {
    name: "Technische Universitaet Berlin License 1.0"
  },
  "TU-Berlin-2.0": {
    name: "Technische Universitaet Berlin License 2.0"
  },
  UCAR: {
    name: "UCAR License"
  },
  "UCL-1.0": {
    name: "Upstream Compatibility License v1.0",
    osi: true
  },
  ulem: {
    name: "ulem License"
  },
  "UMich-Merit": {
    name: "Michigan/Merit Networks License"
  },
  "Unicode-3.0": {
    name: "Unicode License v3",
    osi: true
  },
  "Unicode-DFS-2015": {
    name: "Unicode License Agreement - Data Files and Software (2015)"
  },
  "Unicode-DFS-2016": {
    name: "Unicode License Agreement - Data Files and Software (2016)",
    osi: true
  },
  "Unicode-TOU": {
    name: "Unicode Terms of Use"
  },
  UnixCrypt: {
    name: "UnixCrypt License"
  },
  Unlicense: {
    name: "The Unlicense",
    osi: true,
    free: true
  },
  "UPL-1.0": {
    name: "Universal Permissive License v1.0",
    osi: true,
    free: true
  },
  "URT-RLE": {
    name: "Utah Raster Toolkit Run Length Encoded License"
  },
  Vim: {
    name: "Vim License",
    free: true
  },
  VOSTROM: {
    name: "VOSTROM Public License for Open Source"
  },
  "VSL-1.0": {
    name: "Vovida Software License v1.0",
    osi: true
  },
  W3C: {
    name: "W3C Software Notice and License (2002-12-31)",
    osi: true,
    free: true
  },
  "W3C-19980720": {
    name: "W3C Software Notice and License (1998-07-20)"
  },
  "W3C-20150513": {
    name: "W3C Software Notice and Document License (2015-05-13)"
  },
  w3m: {
    name: "w3m License"
  },
  "Watcom-1.0": {
    name: "Sybase Open Watcom Public License 1.0",
    osi: true
  },
  "Widget-Workshop": {
    name: "Widget Workshop License"
  },
  Wsuipa: {
    name: "Wsuipa License"
  },
  WTFPL: {
    name: "Do What The F*ck You Want To Public License",
    free: true
  },
  X11: {
    name: "X11 License",
    free: true
  },
  "X11-distribute-modifications-variant": {
    name: "X11 License Distribution Modification Variant"
  },
  "Xdebug-1.03": {
    name: "Xdebug License v 1.03"
  },
  Xerox: {
    name: "Xerox License"
  },
  Xfig: {
    name: "Xfig License"
  },
  "XFree86-1.1": {
    name: "XFree86 License 1.1",
    free: true
  },
  xinetd: {
    name: "xinetd License",
    free: true
  },
  "xkeyboard-config-Zinoviev": {
    name: "xkeyboard-config Zinoviev License"
  },
  xlock: {
    name: "xlock License"
  },
  Xnet: {
    name: "X.Net License",
    osi: true
  },
  xpp: {
    name: "XPP License"
  },
  XSkat: {
    name: "XSkat License"
  },
  "YPL-1.0": {
    name: "Yahoo! Public License v1.0"
  },
  "YPL-1.1": {
    name: "Yahoo! Public License v1.1",
    free: true
  },
  Zed: {
    name: "Zed License"
  },
  Zeeff: {
    name: "Zeeff License"
  },
  "Zend-2.0": {
    name: "Zend License v2.0",
    free: true
  },
  "Zimbra-1.3": {
    name: "Zimbra Public License v1.3",
    free: true
  },
  "Zimbra-1.4": {
    name: "Zimbra Public License v1.4"
  },
  Zlib: {
    name: "zlib License",
    osi: true,
    free: true
  },
  "zlib-acknowledgement": {
    name: "zlib/libpng License with Acknowledgement"
  },
  "ZPL-1.1": {
    name: "Zope Public License 1.1"
  },
  "ZPL-2.0": {
    name: "Zope Public License 2.0",
    osi: true,
    free: true
  },
  "ZPL-2.1": {
    name: "Zope Public License 2.1",
    osi: true,
    free: true
  }
};
var licenses_default = licenses;

// ../../node_modules/myst-frontmatter/dist/licenses/validators.js
var import_spdx_correct = __toESM(require_spdx_correct(), 1);
function correctLicense(license) {
  if (!license)
    return void 0;
  const value = (0, import_spdx_correct.default)(license);
  if (value)
    return value;
  if (license.toUpperCase() === "CC-BY")
    return "CC-BY-4.0";
  return void 0;
}
function createURL(license) {
  var _a, _b;
  if (license.CC) {
    const match = /^([CBYSAND0-]+)(?:(?:-)([0-9].[0-9]))?(?:(?:-)([A-Z]{2}))?$/.exec(license.id);
    if (!match) {
      throw new Error("Creative Commons license not found");
    }
    const kind = match[1].toUpperCase();
    const version2 = (_a = match[2]) !== null && _a !== void 0 ? _a : "4.0";
    const extra = (_b = match[3]) !== null && _b !== void 0 ? _b : "";
    let link2 = "";
    switch (kind) {
      case "CC-BY":
        link2 = `/by/${version2}/`;
        break;
      case "CC-BY-SA":
        link2 = `/by-sa/${version2}/`;
        break;
      case "CC-BY-NC":
        link2 = `/by-nc/${version2}/`;
        break;
      case "CC-BY-NC-SA":
        link2 = `/by-nc-sa/${version2}/`;
        break;
      case "CC-BY-ND":
        link2 = `/by-nd/${version2}/`;
        break;
      case "CC-BY-NC-ND":
        link2 = `/by-nc-nd/${version2}/`;
        break;
      case "CC-ZERO":
      case "CC-0":
      case "CC0":
        link2 = "/zero/1.0/";
        break;
      case "CC-PDDC":
        link2 = "/publicdomain/";
        break;
      default:
        break;
    }
    if (extra)
      link2 += `${extra}/`;
    return `https://creativecommons.org/licenses${link2}`;
  }
  if (license.osi) {
    return `https://opensource.org/licenses/${license.id}`;
  }
  return `https://spdx.org/licenses/${license.id}`;
}
function validateLicense(input, opts) {
  if (typeof input === "object") {
    const revalidated = validateLicense(input.id, {
      ...opts,
      suppressErrors: true,
      suppressWarnings: true
    });
    let equal = Boolean(revalidated);
    if (revalidated) {
      Object.entries(revalidated).forEach(([key, val]) => {
        if (val !== input[key])
          equal = false;
      });
    }
    if (!equal) {
      return validationError(`invalid license object - use a valid license ID string instead, see https://spdx.org/licenses/`, opts);
    }
    return revalidated;
  }
  const valueUnvalidated = validateString(input, opts);
  if (valueUnvalidated === void 0)
    return void 0;
  const value = correctLicense(valueUnvalidated);
  if (!value) {
    return validationError(`invalid value "${valueUnvalidated}" - must be a valid license ID, see https://spdx.org/licenses/`, opts);
  }
  if (value !== valueUnvalidated) {
    validationWarning(`The SPDX ID for the license is "${value}". Corrected from "${valueUnvalidated}".`, opts);
  }
  const spdx = { id: value, ...licenses_default[value] };
  const url = createURL(spdx);
  return { ...spdx, url };
}
function validateLicenses(input, opts) {
  let contentOpts;
  if (typeof input === "string") {
    input = { content: input };
    contentOpts = opts;
  } else {
    contentOpts = incrementOptions("content", opts);
  }
  const value = validateObjectKeys(input, { optional: ["content", "code"] }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.content)) {
    output.content = validateLicense(value.content, contentOpts);
  }
  if (defined(value.code) && value.code !== value.content) {
    output.code = validateLicense(value.code, incrementOptions("code", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/settings/validatorsMystToTex.js
var MYST_TO_TEX_SETTINGS = ["codeStyle", "beamer"];
var MYST_TO_TEX_SETTINGS_ALIAS = {
  code_style: "codeStyle"
};
function validateMystToTexSettings(value, opts) {
  const output = {};
  const settings = validateObjectKeys(value, { optional: MYST_TO_TEX_SETTINGS, alias: MYST_TO_TEX_SETTINGS_ALIAS }, opts);
  if (!settings)
    return void 0;
  if (defined(settings.codeStyle)) {
    const codeStyle = validateChoice(settings.codeStyle, {
      ...incrementOptions("codeStyle", opts),
      choices: ["verbatim", "minted", "listings"]
    });
    if (codeStyle)
      output.codeStyle = codeStyle;
  }
  if (defined(settings.beamer)) {
    const beamer = validateBoolean(settings.beamer, incrementOptions("beamer", opts));
    if (beamer != null)
      output.beamer = beamer;
  }
  if (Object.keys(output).length === 0)
    return void 0;
  return output;
}

// ../../node_modules/myst-frontmatter/dist/settings/validators.js
var OUTPUT_REMOVAL_OPTIONS = [
  "show",
  "remove",
  "remove-warn",
  "remove-error",
  "warn",
  "error"
];
var PROJECT_SETTINGS = [
  "output_stderr",
  "output_stdout",
  "output_matplotlib_strings",
  "myst_to_tex"
];
var PROJECT_SETTINGS_ALIAS = {
  stderr_output: "output_stderr",
  stdout_output: "output_stdout",
  mystToTex: "myst_to_tex",
  tex: "myst_to_tex"
  // The default is the renderer, not the parser
};
function validateProjectAndPageSettings(value, opts) {
  const output = {};
  const settings = validateObjectKeys(value, { optional: PROJECT_SETTINGS, alias: PROJECT_SETTINGS_ALIAS }, opts);
  if (!settings)
    return void 0;
  if (defined(settings.output_stderr)) {
    const output_stderr = validateChoice(settings.output_stderr, {
      ...incrementOptions("output_stderr", opts),
      choices: OUTPUT_REMOVAL_OPTIONS
    });
    if (output_stderr)
      output.output_stderr = output_stderr;
  }
  if (defined(settings.output_stdout)) {
    const output_stdout = validateChoice(settings.output_stdout, {
      ...incrementOptions("output_stdout", opts),
      choices: OUTPUT_REMOVAL_OPTIONS
    });
    if (output_stdout)
      output.output_stdout = output_stdout;
  }
  if (defined(settings.output_matplotlib_strings)) {
    const output_matplotlib_strings = validateChoice(settings.output_matplotlib_strings, {
      ...incrementOptions("output_matplotlib_strings", opts),
      choices: OUTPUT_REMOVAL_OPTIONS
    });
    if (output_matplotlib_strings)
      output.output_matplotlib_strings = output_matplotlib_strings;
  }
  if (defined(settings.myst_to_tex)) {
    const myst_to_tex = validateMystToTexSettings(settings.myst_to_tex, incrementOptions("myst_to_tex", opts));
    if (myst_to_tex)
      output.myst_to_tex = myst_to_tex;
  }
  if (Object.keys(output).length === 0)
    return void 0;
  return output;
}

// ../../node_modules/myst-frontmatter/dist/project/validators.js
function validateProjectAndPageFrontmatterKeys(value, opts) {
  const output = validateSiteFrontmatterKeys(value, opts);
  if (defined(value.date)) {
    output.date = validateDate(value.date, incrementOptions("date", opts));
  }
  if (defined(value.name)) {
    output.name = validateString(value.name, incrementOptions("name", opts));
  }
  if (defined(value.doi)) {
    output.doi = validateDoi(value.doi, incrementOptions("doi", opts));
  }
  if (defined(value.arxiv)) {
    output.arxiv = validateUrl(value.arxiv, {
      ...incrementOptions("arxiv", opts),
      includes: "arxiv.org"
    });
  }
  if (defined(value.open_access)) {
    output.open_access = validateBoolean(value.open_access, incrementOptions("open_access", opts));
  }
  if (defined(value.license)) {
    output.license = validateLicenses(value.license, incrementOptions("license", opts));
  }
  if (defined(value.binder)) {
    output.binder = validateUrl(value.binder, incrementOptions("binder", opts));
  }
  if (defined(value.source)) {
    output.source = validateUrl(value.source, incrementOptions("source", opts));
  }
  if (defined(value.subject)) {
    output.subject = validateString(value.subject, {
      ...incrementOptions("subject", opts),
      maxLength: 40
    });
  }
  if (defined(value.bibliography)) {
    output.bibliography = validateList(value.bibliography, { coerce: true, ...incrementOptions("bibliography", opts) }, (req, index2) => {
      return validateString(req, incrementOptions(`bibliography.${index2}`, opts));
    });
  }
  if (defined(value.biblio)) {
    output.biblio = validateBiblio(value.biblio, incrementOptions("biblio", opts));
  }
  if (defined(value.oxa)) {
    output.oxa = validateString(value.oxa, incrementOptions("oxa", opts));
  }
  if (defined(value.numbering)) {
    output.numbering = validateNumbering(value.numbering, incrementOptions("numbering", opts));
  }
  if (defined(value.math)) {
    const mathOpts = incrementOptions("math", opts);
    const math = validateObject(value.math, mathOpts);
    if (math) {
      const stringKeys = Object.keys(math).filter((key) => {
        return validateString(math[key], incrementOptions(key, mathOpts));
      });
      output.math = filterKeys(math, stringKeys);
    }
  }
  if (defined(value.abbreviations)) {
    const abbreviationsOpts = incrementOptions("abbreviations", opts);
    const abbreviations = validateObject(value.abbreviations, abbreviationsOpts);
    if (abbreviations) {
      const stringKeys = Object.keys(abbreviations).filter((key) => {
        return validateString(abbreviations[key], incrementOptions(key, abbreviationsOpts));
      });
      output.abbreviations = filterKeys(abbreviations, stringKeys);
    }
  }
  if (defined(value.exports)) {
    const exports2 = validateExportsList(value.exports, opts);
    if (exports2)
      output.exports = exports2;
  }
  if (value.thumbnail === null) {
    output.thumbnail = null;
  } else if (defined(value.thumbnail)) {
    output.thumbnail = validateString(value.thumbnail, incrementOptions("thumbnail", opts));
  }
  if (defined(value.thumbnailOptimized)) {
    output.thumbnailOptimized = value.thumbnailOptimized;
  }
  if (value.banner === null) {
    output.banner = null;
  } else if (defined(value.banner)) {
    output.banner = validateString(value.banner, incrementOptions("banner", opts));
  }
  if (defined(value.bannerOptimized)) {
    output.bannerOptimized = value.bannerOptimized;
  }
  if (defined(value.settings)) {
    const settings = validateProjectAndPageSettings(value.settings, incrementOptions("settings", opts));
    if (settings)
      output.settings = settings;
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/page/validators.js
function validatePageFrontmatterKeys(value, opts) {
  const output = validateProjectAndPageFrontmatterKeys(value, opts);
  if (defined(value.kernelspec)) {
    output.kernelspec = validateKernelSpec(value.kernelspec, incrementOptions("kernelspec", opts));
  }
  if (defined(value.jupytext)) {
    output.jupytext = validateJupytext(value.jupytext, incrementOptions("jupytext", opts));
  }
  if (defined(value.tags)) {
    output.tags = validateList(value.tags, incrementOptions("tags", opts), (file, index2) => {
      return validateString(file, incrementOptions(`tags.${index2}`, opts));
    });
  }
  const partsOptions = incrementOptions("parts", opts);
  let parts;
  if (defined(value.parts)) {
    parts = validateObject(value.parts, partsOptions);
  }
  PAGE_KNOWN_PARTS.forEach((partKey) => {
    if (defined(value[partKey])) {
      parts !== null && parts !== void 0 ? parts : parts = {};
      if (parts[partKey]) {
        validationError(`duplicate value for part ${partKey}`, partsOptions);
      } else {
        parts[partKey] = value[partKey];
      }
    }
  });
  if (parts) {
    const partsEntries = Object.entries(parts).map(([k, v2]) => {
      return [
        k,
        validateList(v2, { coerce: true, ...incrementOptions(k, partsOptions) }, (item, index2) => {
          return validateString(item, incrementOptions(`${k}.${index2}`, partsOptions));
        })
      ];
    }).filter((entry) => {
      var _a;
      return !!((_a = entry[1]) === null || _a === void 0 ? void 0 : _a.length);
    });
    if (partsEntries.length > 0) {
      output.parts = Object.fromEntries(partsEntries);
    }
  }
  if (defined(value.content_includes_title)) {
    output.content_includes_title = validateBoolean(value.content_includes_title, incrementOptions("content_includes_title", opts));
  }
  return output;
}
function validatePageFrontmatter(input, opts) {
  const value = validateObjectKeys(input, { optional: PAGE_FRONTMATTER_KEYS, alias: FRONTMATTER_ALIASES }, opts) || {};
  return validatePageFrontmatterKeys(value, opts);
}

// ../../packages/myst-demo/dist/index.js
var import_react93 = __toESM(require_react(), 1);
var import_classnames34 = __toESM(require_classnames(), 1);
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function downloadBlob(filename, blob) {
  const a4 = document.createElement("a");
  const url = URL.createObjectURL(blob);
  a4.href = url;
  a4.download = filename;
  a4.click();
}
function saveDocxFile(filename, mdast) {
  return __awaiter6(this, void 0, void 0, function* () {
    const { unified } = yield import("/build/_shared/unified-YRUTPRKB.js");
    const { mystToDocx, fetchImagesAsBuffers } = yield import("/build/_shared/dist-UDYURLUX.js");
    const tree = JSON.parse(JSON.stringify(mdast));
    const opts = yield fetchImagesAsBuffers(tree);
    const docxBlob = yield unified().use(mystToDocx, opts).stringify(tree).result;
    downloadBlob(filename, docxBlob);
  });
}
function getFrontmatter(vfile, tree) {
  var _a, _b;
  const firstParent = ((_a = tree.children[0]) === null || _a === void 0 ? void 0 : _a.type) === "block" ? tree.children[0] : tree;
  const firstNode = (_b = firstParent.children) === null || _b === void 0 ? void 0 : _b[0];
  let frontmatter = {};
  const firstIsYaml = (firstNode === null || firstNode === void 0 ? void 0 : firstNode.type) === "code" && (firstNode === null || firstNode === void 0 ? void 0 : firstNode.lang) === "yaml";
  if (firstIsYaml) {
    try {
      frontmatter = js_yaml_default.load(firstNode.value) || {};
      firstNode.type = "__delete__";
    } catch (err) {
      fileError(vfile, "Invalid YAML frontmatter", {
        note: err.message,
        ruleId: RuleId.frontmatterIsYaml
      });
    }
  }
  const possibleNull = remove(tree, "__delete__");
  if (possibleNull === null) {
    remove(tree, { cascade: false }, "__delete__");
  }
  return frontmatter;
}
function parse2(text, defaultFrontmatter, options) {
  var _a, _b, _c;
  return __awaiter6(this, void 0, void 0, function* () {
    const { visit: visit2 } = yield import("/build/_shared/unist-util-visit-CSB3JZZ3.js");
    const { unified } = yield import("/build/_shared/unified-YRUTPRKB.js");
    const { mystParse } = yield import("/build/_shared/dist-IN77FIOK.js");
    const { mathPlugin, footnotesPlugin, keysPlugin, basicTransformationsPlugin, enumerateTargetsPlugin, resolveReferencesPlugin, WikiTransformer, GithubTransformer, DOITransformer, RRIDTransformer, linksPlugin, ReferenceState, abbreviationPlugin, glossaryPlugin, joinGatesPlugin } = yield import("/build/_shared/dist-6ITSLG7U.js");
    const { default: mystToTex } = yield import("/build/_shared/dist-TWFBQNOA.js");
    const { default: mystToTypst } = yield import("/build/_shared/dist-YC46GH6N.js");
    const { default: mystToJats } = yield import("/build/_shared/dist-2LDVQ7XA.js").catch(() => ({ default: null }));
    const { mystToHtml } = yield import("/build/_shared/dist-U33EQ4KS.js");
    const { cardDirective } = yield import("/build/_shared/dist-7MJX6IHI.js");
    const { gridDirective } = yield import("/build/_shared/dist-B5YLR3VR.js");
    const { tabDirectives } = yield import("/build/_shared/dist-ZF7GJYCI.js");
    const { proofDirective } = yield import("/build/_shared/dist-WSCNIHPJ.js");
    const { exerciseDirectives } = yield import("/build/_shared/dist-XRKTME44.js");
    const vfile = new VFile();
    const parseMyst = (content) => mystParse(content, {
      markdownit: { linkify: true },
      directives: [
        cardDirective,
        gridDirective,
        ...tabDirectives,
        proofDirective,
        ...exerciseDirectives
      ],
      // roles: [reactiveRole],
      vfile
    });
    const mdast = parseMyst(text);
    const linkTransforms = [
      new WikiTransformer(),
      new GithubTransformer(),
      new DOITransformer(),
      new RRIDTransformer()
    ];
    const mdastPre = JSON.parse(JSON.stringify(mdast));
    visit2(mdastPre, (n4) => delete n4.position);
    const htmlString = mystToHtml(JSON.parse(JSON.stringify(mdast)));
    const references = {
      cite: { order: [], data: {} },
      footnotes: {}
    };
    const frontmatterRaw = getFrontmatter(vfile, mdast);
    const frontmatter = validatePageFrontmatter(frontmatterRaw, {
      property: "frontmatter",
      messages: {}
    });
    const state = new ReferenceState("", {
      numbering: (_a = frontmatter.numbering) !== null && _a !== void 0 ? _a : defaultFrontmatter === null || defaultFrontmatter === void 0 ? void 0 : defaultFrontmatter.numbering,
      vfile
    });
    visit2(mdast, (n4) => {
      if (n4.type === "cite") {
        n4.error = true;
      }
    });
    unified().use(basicTransformationsPlugin, { parser: parseMyst }).use(mathPlugin, { macros: (_b = frontmatter === null || frontmatter === void 0 ? void 0 : frontmatter.math) !== null && _b !== void 0 ? _b : {} }).use(glossaryPlugin).use(abbreviationPlugin, { abbreviations: frontmatter.abbreviations }).use(enumerateTargetsPlugin, { state }).use(linksPlugin, { transformers: linkTransforms }).use(footnotesPlugin).use(joinGatesPlugin).use(resolveReferencesPlugin, { state }).use(keysPlugin).runSync(mdast, vfile);
    const mdastPost = JSON.parse(JSON.stringify(mdast));
    visit2(mdastPost, (n4) => {
      delete n4.position;
      delete n4.key;
    });
    const texFile = new VFile();
    const tex = unified().use(mystToTex, { references }).stringify(mdast, texFile).result;
    const typstFile = new VFile();
    let typst;
    try {
      typst = unified().use(mystToTypst).stringify(mdast, typstFile).result;
    } catch (error) {
      console.error(error);
      typst = {
        value: `Problem with typst conversion: ${error.message || "Unknown Error"}`,
        macros: [],
        commands: {}
      };
    }
    const jatsFile = new VFile();
    const jats = mystToJats ? unified().use(mystToJats, SourceFileKind.Article, frontmatter, void 0, "", {
      format: 2,
      writeFullArticle: (_c = options === null || options === void 0 ? void 0 : options.jats) === null || _c === void 0 ? void 0 : _c.fullArticle
    }).stringify(mdast, jatsFile).result : "Problem loading myst-to-jats";
    return {
      frontmatter,
      mdastPre,
      mdastPost,
      references: Object.assign(Object.assign({}, references), { article: mdast }),
      html: htmlString,
      tex: tex.value,
      texWarnings: texFile.messages,
      typst: typst.value,
      typstWarnings: typstFile.messages,
      jats,
      jatsWarnings: jatsFile.messages,
      warnings: vfile.messages
    };
  });
}
function MySTRenderer({ value, column, fullscreen, numbering, TitleBlock, captureTab, className }) {
  var _a;
  const area = (0, import_react93.useRef)(null);
  const [text, setText] = (0, import_react93.useState)(value.trim());
  const [references, setReferences] = (0, import_react93.useState)({});
  const [frontmatter, setFrontmatter] = (0, import_react93.useState)({});
  const [mdastPre, setMdastPre] = (0, import_react93.useState)("Loading...");
  const [mdastPost, setMdastPost] = (0, import_react93.useState)("Loading...");
  const [html, setHtml] = (0, import_react93.useState)("Loading...");
  const [tex, setTex] = (0, import_react93.useState)("Loading...");
  const [texWarnings, setTexWarnings] = (0, import_react93.useState)([]);
  const [typst, setTypst] = (0, import_react93.useState)("Loading...");
  const [typstWarnings, setTypstWarnings] = (0, import_react93.useState)([]);
  const [jats, setJats] = (0, import_react93.useState)("Loading...");
  const [jatsWarnings, setJatsWarnings] = (0, import_react93.useState)([]);
  const [warnings, setWarnings] = (0, import_react93.useState)([]);
  const [previewType, setPreviewType] = (0, import_react93.useState)("DEMO");
  const [astLang, setAstLang] = (0, import_react93.useState)("yaml");
  const [astStage, setAstStage] = (0, import_react93.useState)("pre");
  (0, import_react93.useEffect)(() => {
    const ref = { current: true };
    parse2(text, { numbering }, { removeHeading: !!TitleBlock, jats: { fullArticle: !!TitleBlock } }).then((result2) => {
      if (!ref.current)
        return;
      setFrontmatter(result2.frontmatter);
      setMdastPre(result2.mdastPre);
      setMdastPost(result2.mdastPost);
      setReferences(result2.references);
      setHtml(result2.html);
      setTex(result2.tex);
      setTexWarnings(result2.texWarnings);
      setTypst(result2.typst);
      setTypstWarnings(result2.typstWarnings);
      setJats(result2.jats);
      setJatsWarnings(result2.jatsWarnings);
      setWarnings(result2.warnings);
    });
    return () => {
      ref.current = false;
    };
  }, [text]);
  (0, import_react93.useEffect)(() => {
    if (!area.current)
      return;
    if (column) {
      area.current.style.height = "";
      return;
    }
    area.current.style.height = "auto";
    area.current.style.height = `${area.current.scrollHeight}px`;
  }, [text, column]);
  (0, import_react93.useEffect)(() => {
    if (!area.current || !captureTab)
      return;
    area.current.addEventListener("keydown", (ev) => {
      if (ev.key !== "Tab")
        return;
      ev.preventDefault();
      ev.stopPropagation();
    });
  }, [area, captureTab]);
  let currentWarnings = [];
  switch (previewType) {
    case "DEMO":
      currentWarnings = warnings;
      break;
    case "LaTeX":
      currentWarnings = texWarnings;
      break;
    case "Typst":
      currentWarnings = typstWarnings;
      break;
    case "JATS":
      currentWarnings = jatsWarnings;
      break;
    default:
      break;
  }
  const demoMenu = (0, import_jsx_runtime66.jsxs)(import_jsx_runtime66.Fragment, { children: [(0, import_jsx_runtime66.jsx)("div", { className: "self-center text-sm border cursor-pointer dark:border-slate-600", children: ["DEMO", "AST", "HTML", "LaTeX", "Typst", "JATS", "DOCX"].map((show) => (0, import_jsx_runtime66.jsx)("button", { className: (0, import_classnames34.default)("px-2 py-1", {
    "bg-white hover:bg-slate-200 dark:bg-slate-500 dark:hover:bg-slate-700": previewType !== show,
    "bg-blue-800 text-white": previewType === show
  }), title: `Show the ${show}`, "aria-label": `Show the ${show}`, "aria-pressed": previewType === show ? "true" : "false", onClick: () => setPreviewType(show), children: show }, show)) }), previewType === "AST" && (0, import_jsx_runtime66.jsxs)("div", { className: "self-center text-sm border cursor-pointer w-fit dark:border-slate-600", children: [["yaml", "json"].map((show) => (0, import_jsx_runtime66.jsx)("button", { className: (0, import_classnames34.default)("px-2 py-1", {
    "bg-white hover:bg-slate-200 dark:bg-slate-500 dark:hover:bg-slate-700": astLang !== show,
    "bg-blue-800 text-white": astLang === show
  }), title: `Show the AST as ${show.toUpperCase()}`, "aria-pressed": astLang === show ? "true" : "false", onClick: () => setAstLang(show), children: show.toUpperCase() }, show)), ["pre", "post"].map((show) => (0, import_jsx_runtime66.jsx)("button", { className: (0, import_classnames34.default)("px-2 py-1", {
    "bg-white hover:bg-slate-200 dark:bg-slate-500 dark:hover:bg-slate-700": astStage !== show,
    "bg-blue-800 text-white": astStage === show
  }), title: `Show the AST Stage ${show.toUpperCase()}`, "aria-pressed": astStage === show ? "true" : "false", onClick: () => setAstStage(show), children: show.toUpperCase() }, show))] })] });
  const mdastStage = astStage === "pre" ? mdastPre : mdastPost;
  return (0, import_jsx_runtime66.jsxs)("figure", { className: (0, import_classnames34.default)("relative", {
    "grid grid-cols-2 gap-0 grid-rows-[3rem_1fr]": column,
    "shadow-lg rounded": !fullscreen,
    "m-0": fullscreen
  }, className), children: [column && (0, import_jsx_runtime66.jsxs)("div", { className: "flex flex-row items-stretch h-full col-span-2 px-2 border dark:border-slate-600", children: [(0, import_jsx_runtime66.jsx)("div", { className: "flex-grow" }), demoMenu] }), (0, import_jsx_runtime66.jsxs)("div", { className: (0, import_classnames34.default)("myst relative", { "overflow-auto": column }), children: [(0, import_jsx_runtime66.jsx)(CopyIcon, { text, className: "absolute right-0 p-1" }), (0, import_jsx_runtime66.jsxs)("label", { children: [(0, import_jsx_runtime66.jsx)("span", { className: "sr-only", children: "Edit the MyST Markdown text" }), (0, import_jsx_runtime66.jsx)("textarea", { ref: area, value: text, className: (0, import_classnames34.default)("block p-6 shadow-inner resize-none w-full font-mono bg-slate-50/50 dark:bg-slate-800/50 outline-none", { "text-sm": !column }, { "h-full": column }), onChange: (e4) => setText(e4.target.value) })] })] }), (0, import_jsx_runtime66.jsxs)("div", { className: (0, import_classnames34.default)("exclude-from-outline relative min-h-1 dark:bg-slate-900", {
    "overflow-auto": column
  }), children: [!column && (0, import_jsx_runtime66.jsx)("div", { className: "absolute top-0 left-0", children: demoMenu }), (0, import_jsx_runtime66.jsxs)("div", { className: (0, import_classnames34.default)("px-6 pb-6", {
    "pt-[40px]": !column && previewType !== "AST",
    "pt-[80px]": !column && previewType === "AST",
    "pt-4": column
  }), children: [previewType === "DEMO" && (0, import_jsx_runtime66.jsx)(import_jsx_runtime66.Fragment, { children: (0, import_jsx_runtime66.jsxs)(ReferencesProvider, { references, frontmatter, children: [TitleBlock && (0, import_jsx_runtime66.jsx)(TitleBlock, { frontmatter }), (0, import_jsx_runtime66.jsx)(MyST, { ast: (_a = references.article) === null || _a === void 0 ? void 0 : _a.children })] }) }), previewType === "AST" && (0, import_jsx_runtime66.jsx)(import_jsx_runtime66.Fragment, { children: (0, import_jsx_runtime66.jsx)(CodeBlock, { lang: astLang, value: astLang === "yaml" ? js_yaml_default.dump(mdastStage) : JSON.stringify(mdastStage, null, 2) }) }), previewType === "HTML" && (0, import_jsx_runtime66.jsx)(CodeBlock, { lang: "xml", value: html, showCopy: false }), previewType === "LaTeX" && (0, import_jsx_runtime66.jsx)(CodeBlock, { lang: "latex", value: tex, showCopy: false }), previewType === "Typst" && (0, import_jsx_runtime66.jsx)(CodeBlock, { lang: "typst", value: typst, showCopy: false }), previewType === "JATS" && (0, import_jsx_runtime66.jsx)(CodeBlock, { lang: "xml", value: jats, showCopy: false }), previewType === "DOCX" && (0, import_jsx_runtime66.jsx)("div", { children: (0, import_jsx_runtime66.jsxs)("button", { className: "p-3 border rounded", onClick: () => saveDocxFile("demo.docx", references.article), title: `Download Micorsoft Word`, "aria-label": `Download Micorsoft Word`, children: [(0, import_jsx_runtime66.jsx)(ArrowDownTrayIcon_default, { width: "1.3rem", height: "1.3rem", className: "inline mr-1" }), " ", "Download as Microsoft Word"] }) })] }), currentWarnings.length > 0 && (0, import_jsx_runtime66.jsx)("div", { className: (0, import_classnames34.default)("w-full", { "absolute bottom-0": column }), children: currentWarnings.map((m4, i5) => (0, import_jsx_runtime66.jsxs)("div", { className: (0, import_classnames34.default)("p-1 shadow-inner text-white not-prose", {
    "bg-red-500 dark:bg-red-800": m4.fatal === true,
    "bg-orange-500 dark:bg-orange-700": m4.fatal === false,
    "bg-slate-500 dark:bg-slate-800": m4.fatal === null
  }), children: [m4.fatal === true && (0, import_jsx_runtime66.jsx)(ExclamationCircleIcon_default, { width: "1.3rem", height: "1.3rem", className: "inline mr-1" }), m4.fatal === false && (0, import_jsx_runtime66.jsx)(ExclamationTriangleIcon_default, { width: "1.3rem", height: "1.3rem", className: "inline mr-1" }), m4.fatal === null && (0, import_jsx_runtime66.jsx)(InformationCircleIcon_default, { width: "1.3rem", height: "1.3rem", className: "inline mr-1" }), (0, import_jsx_runtime66.jsx)("code", { children: m4.ruleId || m4.source }), ": ", m4.message] }, i5)) })] })] });
}
var MystDemoRenderer = ({ node }) => {
  return (0, import_jsx_runtime66.jsx)(MySTRenderer, { value: node.value, numbering: node.numbering });
};

// ../../packages/diagrams/dist/index.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var import_react94 = __toESM(require_react(), 1);
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function parse3(id, text) {
  return __awaiter7(this, void 0, void 0, function* () {
    const { default: mermaid } = yield import("/build/_shared/mermaid.core-FD6MNEXB.js");
    return yield new Promise((resolve) => {
      mermaid.render(id, text, (code3) => {
        resolve(code3);
      });
    });
  });
}
function MermaidRenderer({ id, value }) {
  const [graph, setGraph] = (0, import_react94.useState)();
  const [error, setError] = (0, import_react94.useState)();
  (0, import_react94.useEffect)(() => {
    parse3(id, value).then((svg) => {
      setGraph(svg);
      setError(void 0);
    }).catch((err) => {
      setGraph(void 0);
      setError(err);
    });
  }, []);
  return (0, import_jsx_runtime67.jsxs)("figure", { className: "", children: [graph && (0, import_jsx_runtime67.jsx)("div", { dangerouslySetInnerHTML: { __html: graph } }), error && (0, import_jsx_runtime67.jsxs)("pre", { children: ["Error parsing mermaid graph.", "\n\n", value] })] });
}
var MermaidNodeRenderer = ({ node }) => {
  return (0, import_jsx_runtime67.jsx)(MermaidRenderer, { id: node.key, value: node.value });
};

// ../../packages/site/src/components/renderers.ts
var renderers = {
  ...DEFAULT_RENDERERS,
  myst: MystDemoRenderer,
  mermaid: MermaidNodeRenderer,
  ...dist_default
};

// ../../packages/site/src/components/SkipToArticle.tsx
var import_react95 = __toESM(require_react(), 1);
var import_jsx_dev_runtime13 = __toESM(require_jsx_dev_runtime(), 1);
function makeSkipClickHandler(hash) {
  return (e4) => {
    e4.preventDefault();
    const el = document.querySelector(`#${hash}`);
    if (!el)
      return;
    el.nextSibling.focus();
    history.replaceState(void 0, "", `#${hash}`);
  };
}
function SkipToArticle({
  frontmatter = true,
  article = true
}) {
  const fm = "skip-to-frontmatter";
  const art = "skip-to-article";
  const frontmatterHandler = (0, import_react95.useCallback)(() => makeSkipClickHandler(fm), [frontmatter]);
  const articleHandler = (0, import_react95.useCallback)(() => makeSkipClickHandler(art), [article]);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
    "div",
    {
      className: "fixed top-1 left-1 h-[0px] w-[0px] focus-within:z-40 focus-within:h-auto focus-within:w-auto bg-white overflow-hidden focus-within:p-2 focus-within:ring-1",
      "aria-label": "skip to content options",
      children: [
        frontmatter && /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
          "a",
          {
            href: `#${fm}`,
            className: "block px-2 py-1 text-black underline",
            onClick: frontmatterHandler,
            children: "Skip to article frontmatter"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/SkipToArticle.tsx",
            lineNumber: 31,
            columnNumber: 9
          },
          this
        ),
        article && /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
          "a",
          {
            href: `#${art}`,
            className: "block px-2 py-1 text-black underline",
            onClick: articleHandler,
            children: "Skip to article content"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/SkipToArticle.tsx",
            lineNumber: 40,
            columnNumber: 9
          },
          this
        )
      ]
    },
    void 0,
    true,
    {
      fileName: "../../packages/site/src/components/SkipToArticle.tsx",
      lineNumber: 26,
      columnNumber: 5
    },
    this
  );
}

// ../../packages/site/src/seo/analytics.tsx
var import_jsx_dev_runtime14 = __toESM(require_jsx_dev_runtime(), 1);
var getGoogleAnalyticsScript = (tag) => `window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', '${tag}');`;
function Analytics({ analytics_google, analytics_plausible }) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(import_jsx_dev_runtime14.Fragment, { children: [
    analytics_plausible && /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(
      "script",
      {
        defer: true,
        "data-domain": analytics_plausible,
        src: "https://plausible.io/js/plausible.js"
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/seo/analytics.tsx",
        lineNumber: 13,
        columnNumber: 9
      },
      this
    ),
    analytics_google && /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(import_jsx_dev_runtime14.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(
        "script",
        {
          async: true,
          src: `https://www.googletagmanager.com/gtag/js?id=${analytics_google}`
        },
        void 0,
        false,
        {
          fileName: "../../packages/site/src/seo/analytics.tsx",
          lineNumber: 21,
          columnNumber: 11
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(
        "script",
        {
          dangerouslySetInnerHTML: {
            __html: getGoogleAnalyticsScript(analytics_google)
          }
        },
        void 0,
        false,
        {
          fileName: "../../packages/site/src/seo/analytics.tsx",
          lineNumber: 25,
          columnNumber: 11
        },
        this
      )
    ] }, void 0, true, {
      fileName: "../../packages/site/src/seo/analytics.tsx",
      lineNumber: 20,
      columnNumber: 9
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/seo/analytics.tsx",
    lineNumber: 11,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/seo/meta.ts
function allDefined(meta) {
  return Object.fromEntries(Object.entries(meta).filter(([, v2]) => v2));
}
function getMetaTagsForSite({ title, twitter }) {
  const meta = {
    title,
    "twitter:site": twitter ? `@${twitter.replace("@", "")}` : void 0
  };
  return allDefined(meta);
}
function getMetaTagsForArticle({
  origin,
  url,
  title,
  description,
  image,
  twitter,
  keywords
}) {
  const meta = {
    title,
    description,
    keywords: keywords == null ? void 0 : keywords.join(", "),
    image,
    "og:url": origin && url ? `${origin}${url}` : void 0,
    "og:title": title,
    "og:description": description,
    "og:image": image,
    "twitter:card": image ? "summary_large_image" : "summary",
    "twitter:creator": twitter ? `@${twitter.replace("@", "")}` : void 0,
    "twitter:title": title,
    "twitter:description": description,
    "twitter:image": image,
    "twitter:alt": title
  };
  return allDefined(meta);
}

// ../../packages/site/src/pages/Error404.tsx
var import_jsx_dev_runtime15 = __toESM(require_jsx_dev_runtime(), 1);
function Error404() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)(import_jsx_dev_runtime15.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)("h1", { children: "No Site Found - 404" }, void 0, false, {
      fileName: "../../packages/site/src/pages/Error404.tsx",
      lineNumber: 4,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)("p", { children: "No website is available at this url, or an error occurred. Please double check the url." }, void 0, false, {
      fileName: "../../packages/site/src/pages/Error404.tsx",
      lineNumber: 5,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/pages/Error404.tsx",
    lineNumber: 3,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/pages/Root.tsx
var import_classnames35 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime16 = __toESM(require_jsx_dev_runtime(), 1);
function Document({
  children,
  scripts,
  theme,
  config,
  title,
  staticBuild,
  baseurl,
  top = DEFAULT_NAV_HEIGHT
}) {
  var _a, _b;
  const links = staticBuild ? {
    Link: (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(Link, { ...{ ...props, reloadDocument: true } }, void 0, false, {
      fileName: "../../packages/site/src/pages/Root.tsx",
      lineNumber: 41,
      columnNumber: 31
    }, this),
    NavLink: (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(NavLink, { ...{ ...props, reloadDocument: true } }, void 0, false, {
      fileName: "../../packages/site/src/pages/Root.tsx",
      lineNumber: 42,
      columnNumber: 34
    }, this)
  } : {
    Link,
    NavLink
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("html", { lang: "en", className: (0, import_classnames35.default)(theme), style: { scrollPadding: top }, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("head", { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("meta", { charSet: "utf-8" }, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 52,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("meta", { name: "viewport", content: "width=device-width,initial-scale=1" }, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 53,
        columnNumber: 9
      }, this),
      title && /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("title", { children: title }, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 54,
        columnNumber: 19
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(Meta, {}, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 55,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(Links, {}, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 56,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(
        Analytics,
        {
          analytics_google: (_a = config == null ? void 0 : config.options) == null ? void 0 : _a.analytics_google,
          analytics_plausible: (_b = config == null ? void 0 : config.options) == null ? void 0 : _b.analytics_plausible
        },
        void 0,
        false,
        {
          fileName: "../../packages/site/src/pages/Root.tsx",
          lineNumber: 57,
          columnNumber: 9
        },
        this
      )
    ] }, void 0, true, {
      fileName: "../../packages/site/src/pages/Root.tsx",
      lineNumber: 51,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("body", { className: "m-0 transition-colors duration-500 bg-white dark:bg-stone-900", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(ThemeProvider, { theme, renderers, ...links, top, children: /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(BaseUrlProvider, { baseurl, children: /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(SiteProvider, { config, children }, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 65,
        columnNumber: 13
      }, this) }, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 64,
        columnNumber: 11
      }, this) }, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 63,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(ScrollRestoration, {}, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 68,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(Scripts, {}, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 69,
        columnNumber: 9
      }, this),
      !staticBuild && /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(LiveReload, {}, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 70,
        columnNumber: 26
      }, this),
      scripts
    ] }, void 0, true, {
      fileName: "../../packages/site/src/pages/Root.tsx",
      lineNumber: 62,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 50,
    columnNumber: 5
  }, this);
}
function AppCatchBoundary() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(Document, { theme: Theme.light, children: /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("article", { className: "article", children: /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("main", { className: "article-grid subgrid-gap col-screen", children: /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(Error404, {}, void 0, false, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 91,
    columnNumber: 11
  }, this) }, void 0, false, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 90,
    columnNumber: 9
  }, this) }, void 0, false, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 89,
    columnNumber: 7
  }, this) }, void 0, false, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 88,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/pages/ErrorDocumentNotFound.tsx
var import_jsx_dev_runtime17 = __toESM(require_jsx_dev_runtime(), 1);
function ErrorDocumentNotFound() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(import_jsx_dev_runtime17.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)("h1", { children: "Document Not Found" }, void 0, false, {
      fileName: "../../packages/site/src/pages/ErrorDocumentNotFound.tsx",
      lineNumber: 4,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)("p", { children: [
      "Take me ",
      /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)("a", { href: "/", children: "home" }, void 0, false, {
        fileName: "../../packages/site/src/pages/ErrorDocumentNotFound.tsx",
        lineNumber: 6,
        columnNumber: 17
      }, this),
      "."
    ] }, void 0, true, {
      fileName: "../../packages/site/src/pages/ErrorDocumentNotFound.tsx",
      lineNumber: 5,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/pages/ErrorDocumentNotFound.tsx",
    lineNumber: 3,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/pages/Article.tsx
var import_react97 = __toESM(require_react(), 1);

// ../../packages/site/src/utils.ts
function extractKnownParts(tree) {
  const abstract = extractPart(tree, "abstract");
  const summary = extractPart(tree, "summary");
  const keypoints = extractPart(tree, "keypoints");
  const data_availability = extractPart(tree, "data_availability");
  const acknowledgments = extractPart(tree, "acknowledgments");
  return { abstract, summary, keypoints, data_availability, acknowledgments };
}

// ../../packages/site/src/pages/Article.tsx
var import_jsx_dev_runtime18 = __toESM(require_jsx_dev_runtime(), 1);
var ArticlePage = import_react97.default.memo(function({
  article,
  hide_all_footer_links,
  hideKeywords
}) {
  var _a, _b, _c, _d, _e;
  const compute = useComputeOptions();
  const { hide_title_block, hide_footer_links } = (_b = (_a = article.frontmatter) == null ? void 0 : _a.options) != null ? _b : {};
  const tree = copyNode(article.mdast);
  const keywords = (_d = (_c = article.frontmatter) == null ? void 0 : _c.keywords) != null ? _d : [];
  const parts = extractKnownParts(tree);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(
    ReferencesProvider,
    {
      references: { ...article.references, article: article.mdast },
      frontmatter: article.frontmatter,
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(BusyScopeProvider, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(ExecuteScopeProvider, { enable: (_e = compute == null ? void 0 : compute.enabled) != null ? _e : false, contents: article, children: [
        !hide_title_block && /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(
          FrontmatterBlock,
          {
            kind: article.kind,
            frontmatter: article.frontmatter,
            className: "pt-5 mb-8"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/pages/Article.tsx",
            lineNumber: 51,
            columnNumber: 13
          },
          this
        ),
        (compute == null ? void 0 : compute.enabled) && compute.features.notebookCompute && article.kind === SourceFileKind.Notebook && /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(NotebookToolbar, { showLaunch: true }, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 59,
          columnNumber: 57
        }, this),
        (compute == null ? void 0 : compute.enabled) && article.kind === SourceFileKind.Article && /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(ErrorTray, { pageSlug: article.slug }, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 61,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)("div", { id: "skip-to-article" }, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 63,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(FrontmatterParts, { parts, keywords, hideKeywords }, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 64,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(ContentBlocks, { pageKind: article.kind, mdast: tree }, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 65,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(BackmatterParts, { parts }, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 66,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(Bibliography, {}, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 67,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(ConnectionStatusTray, {}, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 68,
          columnNumber: 11
        }, this),
        !hide_footer_links && !hide_all_footer_links && /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(FooterLinksBlock, { links: article.footer }, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 70,
          columnNumber: 13
        }, this)
      ] }, void 0, true, {
        fileName: "../../packages/site/src/pages/Article.tsx",
        lineNumber: 49,
        columnNumber: 9
      }, this) }, void 0, false, {
        fileName: "../../packages/site/src/pages/Article.tsx",
        lineNumber: 48,
        columnNumber: 7
      }, this)
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/pages/Article.tsx",
      lineNumber: 44,
      columnNumber: 5
    },
    this
  );
});
function ArticlePageCatchBoundary() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(ErrorDocumentNotFound, {}, void 0, false, {
    fileName: "../../packages/site/src/pages/Article.tsx",
    lineNumber: 83,
    columnNumber: 10
  }, this);
}

export {
  require_loaders,
  useThemeTop,
  useBaseurl,
  UiStateProvider,
  useSiteManifest,
  TabStateProvider,
  ProjectProvider,
  ComputeOptionsProvider,
  ThebeLoaderAndServer,
  useOutlineHeight,
  DocumentOutline,
  ContentReload,
  TopNav,
  useTocHeight,
  Navigation,
  SkipToArticle,
  ArticlePage,
  ArticlePageCatchBoundary,
  getMetaTagsForSite,
  getMetaTagsForArticle,
  Document,
  AppCatchBoundary
};
/*! Bundled license information:

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
//# sourceMappingURL=/build/_shared/chunk-7ASKZRGB.js.map
