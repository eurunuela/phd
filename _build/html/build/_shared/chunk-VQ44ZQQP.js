import {
  require_entities
} from "/build/_shared/chunk-6S3SPRRW.js";
import {
  require_client
} from "/build/_shared/chunk-EO2YHY6V.js";
import {
  require_react
} from "/build/_shared/chunk-IFNAVDNZ.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "/build/_shared/chunk-D5NAPBYJ.js";

// ../../node_modules/@lumino/coreutils/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/@lumino/coreutils/dist/index.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.lumino_coreutils = {}));
    })(exports2, function(exports3) {
      "use strict";
      exports3.JSONExt = void 0;
      (function(JSONExt10) {
        JSONExt10.emptyObject = Object.freeze({});
        JSONExt10.emptyArray = Object.freeze([]);
        function isPrimitive(value) {
          return value === null || typeof value === "boolean" || typeof value === "number" || typeof value === "string";
        }
        JSONExt10.isPrimitive = isPrimitive;
        function isArray(value) {
          return Array.isArray(value);
        }
        JSONExt10.isArray = isArray;
        function isObject9(value) {
          return !isPrimitive(value) && !isArray(value);
        }
        JSONExt10.isObject = isObject9;
        function deepEqual(first, second) {
          if (first === second) {
            return true;
          }
          if (isPrimitive(first) || isPrimitive(second)) {
            return false;
          }
          let a1 = isArray(first);
          let a2 = isArray(second);
          if (a1 !== a2) {
            return false;
          }
          if (a1 && a2) {
            return deepArrayEqual(first, second);
          }
          return deepObjectEqual(first, second);
        }
        JSONExt10.deepEqual = deepEqual;
        function deepCopy(value) {
          if (isPrimitive(value)) {
            return value;
          }
          if (isArray(value)) {
            return deepArrayCopy(value);
          }
          return deepObjectCopy(value);
        }
        JSONExt10.deepCopy = deepCopy;
        function deepArrayEqual(first, second) {
          if (first === second) {
            return true;
          }
          if (first.length !== second.length) {
            return false;
          }
          for (let i = 0, n = first.length; i < n; ++i) {
            if (!deepEqual(first[i], second[i])) {
              return false;
            }
          }
          return true;
        }
        function deepObjectEqual(first, second) {
          if (first === second) {
            return true;
          }
          for (let key2 in first) {
            if (first[key2] !== void 0 && !(key2 in second)) {
              return false;
            }
          }
          for (let key2 in second) {
            if (second[key2] !== void 0 && !(key2 in first)) {
              return false;
            }
          }
          for (let key2 in first) {
            let firstValue = first[key2];
            let secondValue = second[key2];
            if (firstValue === void 0 && secondValue === void 0) {
              continue;
            }
            if (firstValue === void 0 || secondValue === void 0) {
              return false;
            }
            if (!deepEqual(firstValue, secondValue)) {
              return false;
            }
          }
          return true;
        }
        function deepArrayCopy(value) {
          let result = new Array(value.length);
          for (let i = 0, n = value.length; i < n; ++i) {
            result[i] = deepCopy(value[i]);
          }
          return result;
        }
        function deepObjectCopy(value) {
          let result = {};
          for (let key2 in value) {
            let subvalue = value[key2];
            if (subvalue === void 0) {
              continue;
            }
            result[key2] = deepCopy(subvalue);
          }
          return result;
        }
      })(exports3.JSONExt || (exports3.JSONExt = {}));
      class MimeData3 {
        constructor() {
          this._types = [];
          this._values = [];
        }
        /**
         * Get an array of the MIME types contained within the dataset.
         *
         * @returns A new array of the MIME types, in order of insertion.
         */
        types() {
          return this._types.slice();
        }
        /**
         * Test whether the dataset has an entry for the given type.
         *
         * @param mime - The MIME type of interest.
         *
         * @returns `true` if the dataset contains a value for the given
         *   MIME type, `false` otherwise.
         */
        hasData(mime) {
          return this._types.indexOf(mime) !== -1;
        }
        /**
         * Get the data value for the given MIME type.
         *
         * @param mime - The MIME type of interest.
         *
         * @returns The value for the given MIME type, or `undefined` if
         *   the dataset does not contain a value for the type.
         */
        getData(mime) {
          let i = this._types.indexOf(mime);
          return i !== -1 ? this._values[i] : void 0;
        }
        /**
         * Set the data value for the given MIME type.
         *
         * @param mime - The MIME type of interest.
         *
         * @param data - The data value for the given MIME type.
         *
         * #### Notes
         * This will overwrite any previous entry for the MIME type.
         */
        setData(mime, data) {
          this.clearData(mime);
          this._types.push(mime);
          this._values.push(data);
        }
        /**
         * Remove the data entry for the given MIME type.
         *
         * @param mime - The MIME type of interest.
         *
         * #### Notes
         * This is a no-op if there is no entry for the given MIME type.
         */
        clearData(mime) {
          let i = this._types.indexOf(mime);
          if (i !== -1) {
            this._types.splice(i, 1);
            this._values.splice(i, 1);
          }
        }
        /**
         * Remove all data entries from the dataset.
         */
        clear() {
          this._types.length = 0;
          this._values.length = 0;
        }
      }
      class PromiseDelegate7 {
        /**
         * Construct a new promise delegate.
         */
        constructor() {
          this.promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
          });
        }
        /**
         * Resolve the wrapped promise with the given value.
         *
         * @param value - The value to use for resolving the promise.
         */
        resolve(value) {
          let resolve = this._resolve;
          resolve(value);
        }
        /**
         * Reject the wrapped promise with the given value.
         *
         * @reason - The reason for rejecting the promise.
         */
        reject(reason) {
          let reject = this._reject;
          reject(reason);
        }
      }
      class Token5 {
        /**
         * Construct a new token.
         *
         * @param name - A human readable name for the token.
         * @param description - Token purpose description for documentation.
         */
        constructor(name2, description) {
          this.name = name2;
          this.description = description !== null && description !== void 0 ? description : "";
          this._tokenStructuralPropertyT = null;
        }
      }
      function fallbackRandomValues(buffer) {
        let value = 0;
        for (let i = 0, n = buffer.length; i < n; ++i) {
          if (i % 4 === 0) {
            value = Math.random() * 4294967295 >>> 0;
          }
          buffer[i] = value & 255;
          value >>>= 8;
        }
      }
      exports3.Random = void 0;
      (function(Random) {
        Random.getRandomValues = (() => {
          const crypto = typeof window !== "undefined" && (window.crypto || window.msCrypto) || null;
          if (crypto && typeof crypto.getRandomValues === "function") {
            return function getRandomValues(buffer) {
              return crypto.getRandomValues(buffer);
            };
          }
          return fallbackRandomValues;
        })();
      })(exports3.Random || (exports3.Random = {}));
      function uuid4Factory(getRandomValues) {
        const bytes = new Uint8Array(16);
        const lut = new Array(256);
        for (let i = 0; i < 16; ++i) {
          lut[i] = "0" + i.toString(16);
        }
        for (let i = 16; i < 256; ++i) {
          lut[i] = i.toString(16);
        }
        return function uuid4() {
          getRandomValues(bytes);
          bytes[6] = 64 | bytes[6] & 15;
          bytes[8] = 128 | bytes[8] & 63;
          return lut[bytes[0]] + lut[bytes[1]] + lut[bytes[2]] + lut[bytes[3]] + "-" + lut[bytes[4]] + lut[bytes[5]] + "-" + lut[bytes[6]] + lut[bytes[7]] + "-" + lut[bytes[8]] + lut[bytes[9]] + "-" + lut[bytes[10]] + lut[bytes[11]] + lut[bytes[12]] + lut[bytes[13]] + lut[bytes[14]] + lut[bytes[15]];
        };
      }
      exports3.UUID = void 0;
      (function(UUID6) {
        UUID6.uuid4 = uuid4Factory(exports3.Random.getRandomValues);
      })(exports3.UUID || (exports3.UUID = {}));
      exports3.MimeData = MimeData3;
      exports3.PromiseDelegate = PromiseDelegate7;
      exports3.Token = Token5;
    });
  }
});

// ../../node_modules/@jupyterlab/translation/lib/utils.js
function normalizeDomain(domain) {
  return domain.replace("-", "_");
}
var init_utils = __esm({
  "../../node_modules/@jupyterlab/translation/lib/utils.js"() {
  }
});

// ../../node_modules/@jupyterlab/translation/lib/gettext.js
var Gettext;
var init_gettext = __esm({
  "../../node_modules/@jupyterlab/translation/lib/gettext.js"() {
    init_utils();
    Gettext = class {
      constructor(options) {
        options = options || {};
        this._defaults = {
          domain: "messages",
          locale: document.documentElement.getAttribute("lang") || "en",
          pluralFunc: function(n) {
            return { nplurals: 2, plural: n != 1 ? 1 : 0 };
          },
          contextDelimiter: String.fromCharCode(4),
          stringsPrefix: ""
        };
        this._locale = (options.locale || this._defaults.locale).replace("_", "-");
        this._domain = normalizeDomain(options.domain || this._defaults.domain);
        this._contextDelimiter = options.contextDelimiter || this._defaults.contextDelimiter;
        this._stringsPrefix = options.stringsPrefix || this._defaults.stringsPrefix;
        this._pluralFuncs = {};
        this._dictionary = {};
        this._pluralForms = {};
        if (options.messages) {
          this._dictionary[this._domain] = {};
          this._dictionary[this._domain][this._locale] = options.messages;
        }
        if (options.pluralForms) {
          this._pluralForms[this._locale] = options.pluralForms;
        }
      }
      /**
       * Set current context delimiter.
       *
       * @param delimiter - The delimiter to set.
       */
      setContextDelimiter(delimiter) {
        this._contextDelimiter = delimiter;
      }
      /**
       * Get current context delimiter.
       *
       * @returns The current delimiter.
       */
      getContextDelimiter() {
        return this._contextDelimiter;
      }
      /**
       * Set current locale.
       *
       * @param locale - The locale to set.
       */
      setLocale(locale) {
        this._locale = locale.replace("_", "-");
      }
      /**
       * Get current locale.
       *
       * @returns The current locale.
       */
      getLocale() {
        return this._locale;
      }
      /**
       * Set current domain.
       *
       * @param domain - The domain to set.
       */
      setDomain(domain) {
        this._domain = normalizeDomain(domain);
      }
      /**
       * Get current domain.
       *
       * @returns The current domain string.
       */
      getDomain() {
        return this._domain;
      }
      /**
       * Set current strings prefix.
       *
       * @param prefix - The string prefix to set.
       */
      setStringsPrefix(prefix) {
        this._stringsPrefix = prefix;
      }
      /**
       * Get current strings prefix.
       *
       * @returns The strings prefix.
       */
      getStringsPrefix() {
        return this._stringsPrefix;
      }
      /**
       * `sprintf` equivalent, takes a string and some arguments to make a
       * computed string.
       *
       * @param fmt - The string to interpolate.
       * @param args - The variables to use in interpolation.
       *
       * ### Examples
       * strfmt("%1 dogs are in %2", 7, "the kitchen"); => "7 dogs are in the kitchen"
       * strfmt("I like %1, bananas and %1", "apples"); => "I like apples, bananas and apples"
       */
      static strfmt(fmt, ...args) {
        return fmt.replace(/%%/g, "%% ").replace(/%(\d+)/g, function(str, p1) {
          return args[p1 - 1];
        }).replace(/%% /g, "%");
      }
      /**
       * Load json translations strings (In Jed 2.x format).
       *
       * @param jsonData - The translation strings plus metadata.
       * @param domain - The translation domain, e.g. "jupyterlab".
       */
      loadJSON(jsonData, domain) {
        if (!jsonData[""] || !jsonData[""]["language"] || !jsonData[""]["pluralForms"]) {
          throw new Error(`Wrong jsonData, it must have an empty key ("") with "language" and "pluralForms" information: ${jsonData}`);
        }
        domain = normalizeDomain(domain);
        let headers = jsonData[""];
        let jsonDataCopy = JSON.parse(JSON.stringify(jsonData));
        delete jsonDataCopy[""];
        this.setMessages(domain || this._defaults.domain, headers["language"], jsonDataCopy, headers["pluralForms"]);
      }
      /**
       * Shorthand for gettext.
       *
       * @param msgid - The singular string to translate.
       * @param args - Any additional values to use with interpolation.
       *
       * @returns A translated string if found, or the original string.
       *
       * ### Notes
       * This is not a private method (starts with an underscore) it is just
       * a shorter and standard way to call these methods.
       */
      __(msgid, ...args) {
        return this.gettext(msgid, ...args);
      }
      /**
       * Shorthand for ngettext.
       *
       * @param msgid - The singular string to translate.
       * @param msgid_plural - The plural string to translate.
       * @param n - The number for pluralization.
       * @param args - Any additional values to use with interpolation.
       *
       * @returns A translated string if found, or the original string.
       *
       * ### Notes
       * This is not a private method (starts with an underscore) it is just
       * a shorter and standard way to call these methods.
       */
      _n(msgid, msgid_plural, n, ...args) {
        return this.ngettext(msgid, msgid_plural, n, ...args);
      }
      /**
       * Shorthand for pgettext.
       *
       * @param msgctxt - The message context.
       * @param msgid - The singular string to translate.
       * @param args - Any additional values to use with interpolation.
       *
       * @returns A translated string if found, or the original string.
       *
       * ### Notes
       * This is not a private method (starts with an underscore) it is just
       * a shorter and standard way to call these methods.
       */
      _p(msgctxt, msgid, ...args) {
        return this.pgettext(msgctxt, msgid, ...args);
      }
      /**
       * Shorthand for npgettext.
       *
       * @param msgctxt - The message context.
       * @param msgid - The singular string to translate.
       * @param msgid_plural - The plural string to translate.
       * @param n - The number for pluralization.
       * @param args - Any additional values to use with interpolation.
       *
       * @returns A translated string if found, or the original string.
       *
       * ### Notes
       * This is not a private method (starts with an underscore) it is just
       * a shorter and standard way to call these methods.
       */
      _np(msgctxt, msgid, msgid_plural, n, ...args) {
        return this.npgettext(msgctxt, msgid, msgid_plural, n, ...args);
      }
      /**
       * Translate a singular string with extra interpolation values.
       *
       * @param msgid - The singular string to translate.
       * @param args - Any additional values to use with interpolation.
       *
       * @returns A translated string if found, or the original string.
       */
      gettext(msgid, ...args) {
        return this.dcnpgettext("", "", msgid, "", 0, ...args);
      }
      /**
       * Translate a plural string with extra interpolation values.
       *
       * @param msgid - The singular string to translate.
       * @param args - Any additional values to use with interpolation.
       *
       * @returns A translated string if found, or the original string.
       */
      ngettext(msgid, msgid_plural, n, ...args) {
        return this.dcnpgettext("", "", msgid, msgid_plural, n, ...args);
      }
      /**
       * Translate a contextualized singular string with extra interpolation values.
       *
       * @param msgctxt - The message context.
       * @param msgid - The singular string to translate.
       * @param args - Any additional values to use with interpolation.
       *
       * @returns A translated string if found, or the original string.
       *
       * ### Notes
       * This is not a private method (starts with an underscore) it is just
       * a shorter and standard way to call these methods.
       */
      pgettext(msgctxt, msgid, ...args) {
        return this.dcnpgettext("", msgctxt, msgid, "", 0, ...args);
      }
      /**
       * Translate a contextualized plural string with extra interpolation values.
       *
       * @param msgctxt - The message context.
       * @param msgid - The singular string to translate.
       * @param msgid_plural - The plural string to translate.
       * @param n - The number for pluralization.
       * @param args - Any additional values to use with interpolation
       *
       * @returns A translated string if found, or the original string.
       */
      npgettext(msgctxt, msgid, msgid_plural, n, ...args) {
        return this.dcnpgettext("", msgctxt, msgid, msgid_plural, n, ...args);
      }
      /**
       * Translate a singular string with extra interpolation values.
       *
       * @param domain - The translations domain.
       * @param msgctxt - The message context.
       * @param msgid - The singular string to translate.
       * @param msgid_plural - The plural string to translate.
       * @param n - The number for pluralization.
       * @param args - Any additional values to use with interpolation
       *
       * @returns A translated string if found, or the original string.
       */
      dcnpgettext(domain, msgctxt, msgid, msgid_plural, n, ...args) {
        domain = normalizeDomain(domain) || this._domain;
        let translation;
        let key2 = msgctxt ? msgctxt + this._contextDelimiter + msgid : msgid;
        let options = { pluralForm: false };
        let exist = false;
        let locale = this._locale;
        let locales = this.expandLocale(this._locale);
        for (let i in locales) {
          locale = locales[i];
          exist = this._dictionary[domain] && this._dictionary[domain][locale] && this._dictionary[domain][locale][key2];
          if (msgid_plural) {
            exist = exist && this._dictionary[domain][locale][key2].length > 1;
          } else {
            exist = exist && this._dictionary[domain][locale][key2].length == 1;
          }
          if (exist) {
            options.locale = locale;
            break;
          }
        }
        if (!exist) {
          translation = [msgid];
          options.pluralFunc = this._defaults.pluralFunc;
        } else {
          translation = this._dictionary[domain][locale][key2];
        }
        if (!msgid_plural) {
          return this.t(translation, n, options, ...args);
        }
        options.pluralForm = true;
        let value = exist ? translation : [msgid, msgid_plural];
        return this.t(value, n, options, ...args);
      }
      /**
       * Split a locale into parent locales. "es-CO" -> ["es-CO", "es"]
       *
       * @param locale - The locale string.
       *
       * @returns An array of locales.
       */
      expandLocale(locale) {
        let locales = [locale];
        let i = locale.lastIndexOf("-");
        while (i > 0) {
          locale = locale.slice(0, i);
          locales.push(locale);
          i = locale.lastIndexOf("-");
        }
        return locales;
      }
      /**
       * Split a locale into parent locales. "es-CO" -> ["es-CO", "es"]
       *
       * @param pluralForm - Plural form string..
       * @returns An function to compute plural forms.
       */
      // eslint-disable-next-line @typescript-eslint/ban-types
      getPluralFunc(pluralForm) {
        let pf_re = new RegExp("^\\s*nplurals\\s*=\\s*[0-9]+\\s*;\\s*plural\\s*=\\s*(?:\\s|[-\\?\\|&=!<>+*/%:;n0-9_()])+");
        if (!pf_re.test(pluralForm))
          throw new Error(Gettext.strfmt('The plural form "%1" is not valid', pluralForm));
        return new Function("n", "let plural, nplurals; " + pluralForm + " return { nplurals: nplurals, plural: (plural === true ? 1 : (plural ? plural : 0)) };");
      }
      /**
       * Remove the context delimiter from string.
       *
       * @param str - Translation string.
       * @returns A translation string without context.
       */
      removeContext(str) {
        if (str.indexOf(this._contextDelimiter) !== -1) {
          let parts = str.split(this._contextDelimiter);
          return parts[1];
        }
        return str;
      }
      /**
       * Proper translation function that handle plurals and directives.
       *
       * @param messages - List of translation strings.
       * @param n - The number for pluralization.
       * @param options - Translation options.
       * @param args - Any variables to interpolate.
       *
       * @returns A translation string without context.
       *
       * ### Notes
       * Contains juicy parts of https://github.com/Orange-OpenSource/gettext.js/blob/master/lib.gettext.js
       */
      t(messages, n, options, ...args) {
        if (!options.pluralForm)
          return this._stringsPrefix + Gettext.strfmt(this.removeContext(messages[0]), ...args);
        let plural;
        if (options.pluralFunc) {
          plural = options.pluralFunc(n);
        } else if (!this._pluralFuncs[options.locale || ""]) {
          this._pluralFuncs[options.locale || ""] = this.getPluralFunc(this._pluralForms[options.locale || ""]);
          plural = this._pluralFuncs[options.locale || ""](n);
        } else {
          plural = this._pluralFuncs[options.locale || ""](n);
        }
        if ("undefined" === typeof !plural.plural || plural.plural > plural.nplurals || messages.length <= plural.plural)
          plural.plural = 0;
        return this._stringsPrefix + Gettext.strfmt(this.removeContext(messages[plural.plural]), ...[n].concat(args));
      }
      /**
       * Set messages after loading them.
       *
       * @param domain - The translation domain.
       * @param locale - The translation locale.
       * @param messages - List of translation strings.
       * @param pluralForms - Plural form string.
       *
       * ### Notes
       * Contains juicy parts of https://github.com/Orange-OpenSource/gettext.js/blob/master/lib.gettext.js
       */
      setMessages(domain, locale, messages, pluralForms) {
        domain = normalizeDomain(domain);
        if (pluralForms)
          this._pluralForms[locale] = pluralForms;
        if (!this._dictionary[domain])
          this._dictionary[domain] = {};
        this._dictionary[domain][locale] = messages;
      }
    };
  }
});

// ../../node_modules/@jupyterlab/translation/lib/base.js
var NullTranslator, NullLanguageBundle, nullTranslator;
var init_base = __esm({
  "../../node_modules/@jupyterlab/translation/lib/base.js"() {
    init_gettext();
    NullTranslator = class {
      constructor(bundle) {
        this.languageCode = "en";
        this._languageBundle = bundle;
      }
      load(domain) {
        return this._languageBundle;
      }
    };
    NullLanguageBundle = class {
      __(msgid, ...args) {
        return this.gettext(msgid, ...args);
      }
      _n(msgid, msgid_plural, n, ...args) {
        return this.ngettext(msgid, msgid_plural, n, ...args);
      }
      _p(msgctxt, msgid, ...args) {
        return this.pgettext(msgctxt, msgid, ...args);
      }
      _np(msgctxt, msgid, msgid_plural, n, ...args) {
        return this.npgettext(msgctxt, msgid, msgid_plural, n, ...args);
      }
      gettext(msgid, ...args) {
        return Gettext.strfmt(msgid, ...args);
      }
      ngettext(msgid, msgid_plural, n, ...args) {
        return Gettext.strfmt(n == 1 ? msgid : msgid_plural, ...[n].concat(args));
      }
      pgettext(msgctxt, msgid, ...args) {
        return Gettext.strfmt(msgid, ...args);
      }
      npgettext(msgctxt, msgid, msgid_plural, n, ...args) {
        return this.ngettext(msgid, msgid_plural, n, ...args);
      }
      dcnpgettext(domain, msgctxt, msgid, msgid_plural, n, ...args) {
        return this.ngettext(msgid, msgid_plural, n, ...args);
      }
    };
    nullTranslator = new NullTranslator(new NullLanguageBundle());
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/statedb/lib/dataconnector.js
var require_dataconnector = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/statedb/lib/dataconnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DataConnector = void 0;
    var DataConnector = class {
      /**
       * Retrieve the list of items available from the data connector.
       *
       * @param query - The optional query filter to apply to the connector request.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can list.
       */
      async list(query) {
        throw new Error("DataConnector#list method has not been implemented.");
      }
      /**
       * Remove a value using the data connector.
       *
       * @param id - The identifier for the data being removed.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can remove.
       */
      async remove(id) {
        throw new Error("DataConnector#remove method has not been implemented.");
      }
      /**
       * Save a value using the data connector.
       *
       * @param id - The identifier for the data being saved.
       *
       * @param value - The data being saved.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can save.
       */
      async save(id, value) {
        throw new Error("DataConnector#save method has not been implemented.");
      }
    };
    exports2.DataConnector = DataConnector;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/statedb/lib/interfaces.js
var require_interfaces = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/statedb/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@lumino/properties/dist/index.es6.js
var index_es6_exports = {};
__export(index_es6_exports, {
  AttachedProperty: () => AttachedProperty
});
var AttachedProperty, Private;
var init_index_es6 = __esm({
  "../../node_modules/@jupyterlab/translation/node_modules/@lumino/properties/dist/index.es6.js"() {
    AttachedProperty = class {
      /**
       * Construct a new attached property.
       *
       * @param options - The options for initializing the property.
       */
      constructor(options) {
        this._pid = Private.nextPID();
        this.name = options.name;
        this._create = options.create;
        this._coerce = options.coerce || null;
        this._compare = options.compare || null;
        this._changed = options.changed || null;
      }
      /**
       * Get the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @returns The current value of the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and assigned as the current value of the property.
       */
      get(owner) {
        let value;
        let map2 = Private.ensureMap(owner);
        if (this._pid in map2) {
          value = map2[this._pid];
        } else {
          value = map2[this._pid] = this._createValue(owner);
        }
        return value;
      }
      /**
       * Set the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @param value - The value for the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      set(owner, value) {
        let oldValue;
        let map2 = Private.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, value);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Explicitly coerce the current property value for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      coerce(owner) {
        let oldValue;
        let map2 = Private.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, oldValue);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Get or create the default value for the given owner.
       */
      _createValue(owner) {
        let create5 = this._create;
        return create5(owner);
      }
      /**
       * Coerce the value for the given owner.
       */
      _coerceValue(owner, value) {
        let coerce = this._coerce;
        return coerce ? coerce(owner, value) : value;
      }
      /**
       * Compare the old value and new value for equality.
       */
      _compareValue(oldValue, newValue) {
        let compare = this._compare;
        return compare ? compare(oldValue, newValue) : oldValue === newValue;
      }
      /**
       * Run the change notification if the given values are different.
       */
      _maybeNotify(owner, oldValue, newValue) {
        let changed = this._changed;
        if (changed && !this._compareValue(oldValue, newValue)) {
          changed(owner, oldValue, newValue);
        }
      }
    };
    (function(AttachedProperty5) {
      function clearData(owner) {
        Private.ownerData.delete(owner);
      }
      AttachedProperty5.clearData = clearData;
    })(AttachedProperty || (AttachedProperty = {}));
    (function(Private36) {
      Private36.ownerData = /* @__PURE__ */ new WeakMap();
      Private36.nextPID = (() => {
        let id = 0;
        return () => {
          let rand = Math.random();
          let stem = `${rand}`.slice(2);
          return `pid-${stem}-${id++}`;
        };
      })();
      function ensureMap(owner) {
        let map2 = Private36.ownerData.get(owner);
        if (map2) {
          return map2;
        }
        map2 = /* @__PURE__ */ Object.create(null);
        Private36.ownerData.set(owner, map2);
        return map2;
      }
      Private36.ensureMap = ensureMap;
    })(Private || (Private = {}));
  }
});

// ../../node_modules/@lumino/signaling/node_modules/@lumino/algorithm/dist/index.es6.js
function find(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return value;
    }
  }
  return void 0;
}
var ArrayExt, Private2, StringExt;
var init_index_es62 = __esm({
  "../../node_modules/@lumino/signaling/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt8) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start + i) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start - i + n) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start + i) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findFirstIndex = findFirstIndex;
      function findLastIndex2(array, fn, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let d;
        if (start < stop) {
          d = start + 1 + (n - stop);
        } else {
          d = start - stop + 1;
        }
        for (let i = 0; i < d; ++i) {
          let j = (start - i + n) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findLastIndex = findLastIndex2;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index = findFirstIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index = findLastIndex2(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt8.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt8.upperBound = upperBound;
      function shallowEqual(a, b, fn) {
        if (a === b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0, n = a.length; i < n; ++i) {
          if (fn ? !fn(a[i], b[i]) : a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt8.shallowEqual = shallowEqual;
      function slice(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n = array.length;
        if (start === void 0) {
          start = step < 0 ? n - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n, step < 0 ? -1 : 0);
        } else if (start >= n) {
          start = step < 0 ? n - 1 : n;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n;
        } else if (stop < 0) {
          stop = Math.max(stop + n, step < 0 ? -1 : 0);
        } else if (stop >= n) {
          stop = step < 0 ? n - 1 : n;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result = [];
        for (let i = 0; i < length; ++i) {
          result[i] = array[start + i * step];
        }
        return result;
      }
      ArrayExt8.slice = slice;
      function move(array, fromIndex, toIndex) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n);
        } else {
          fromIndex = Math.min(fromIndex, n - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n);
        } else {
          toIndex = Math.min(toIndex, n - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d = fromIndex < toIndex ? 1 : -1;
        for (let i = fromIndex; i !== toIndex; i += d) {
          array[i] = array[i + d];
        }
        array[toIndex] = value;
      }
      ArrayExt8.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        while (start < stop) {
          let a = array[start];
          let b = array[stop];
          array[start++] = b;
          array[stop--] = a;
        }
      }
      ArrayExt8.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt8.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          array[(start + i) % n] = value;
        }
      }
      ArrayExt8.fill = fill;
      function insert(array, index, value) {
        let n = array.length;
        if (index < 0) {
          index = Math.max(0, index + n);
        } else {
          index = Math.min(index, n);
        }
        for (let i = n; i > index; --i) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      ArrayExt8.insert = insert;
      function removeAt(array, index) {
        let n = array.length;
        if (index < 0) {
          index += n;
        }
        if (index < 0 || index >= n) {
          return void 0;
        }
        let value = array[index];
        for (let i = index + 1; i < n; ++i) {
          array[i - 1] = array[i];
        }
        array.length = n - 1;
        return value;
      }
      ArrayExt8.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index = firstIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index = lastIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i = 0; i < n; ++i) {
          if (start <= stop && i >= start && i <= stop && array[i] === value) {
            count++;
          } else if (stop < start && (i <= stop || i >= start) && array[i] === value) {
            count++;
          } else if (count > 0) {
            array[i - count] = array[i];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index = findFirstIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index = findLastIndex2(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i = 0; i < n; ++i) {
          if (start <= stop && i >= start && i <= stop && fn(array[i], i)) {
            count++;
          } else if (stop < start && (i <= stop || i >= start) && fn(array[i], i)) {
            count++;
          } else if (count > 0) {
            array[i - count] = array[i];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllWhere = removeAllWhere;
    })(ArrayExt || (ArrayExt = {}));
    (function(Private36) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private36.rangeLength = rangeLength;
    })(Private2 || (Private2 = {}));
    (function(StringExt8) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i = 0, j = start, n = query.length; i < n; ++i, ++j) {
          j = source.indexOf(query[i], j);
          if (j === -1) {
            return null;
          }
          indices[i] = j;
        }
        return indices;
      }
      StringExt8.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i = 0, n = indices.length; i < n; ++i) {
          let j = indices[i] - start;
          score += j * j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last = start - 1;
        for (let i = 0, n = indices.length; i < n; ++i) {
          let j = indices[i];
          score += j - last - 1;
          last = j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result = [];
        let k = 0;
        let last = 0;
        let n = indices.length;
        while (k < n) {
          let i = indices[k];
          let j = indices[k];
          while (++k < n && indices[k] === j + 1) {
            j++;
          }
          if (last < i) {
            result.push(source.slice(last, i));
          }
          if (i < j + 1) {
            result.push(fn(source.slice(i, j + 1)));
          }
          last = j + 1;
        }
        if (last < source.length) {
          result.push(source.slice(last));
        }
        return result;
      }
      StringExt8.highlight = highlight;
      function cmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      StringExt8.cmp = cmp;
    })(StringExt || (StringExt = {}));
  }
});

// ../../node_modules/@lumino/signaling/dist/index.es6.js
var index_es6_exports2 = {};
__export(index_es6_exports2, {
  Signal: () => Signal,
  Stream: () => Stream
});
var import_coreutils, Signal, Stream, Private3;
var init_index_es63 = __esm({
  "../../node_modules/@lumino/signaling/dist/index.es6.js"() {
    init_index_es62();
    import_coreutils = __toESM(require_dist());
    Signal = class {
      /**
       * Construct a new signal.
       *
       * @param sender - The sender which owns the signal.
       */
      constructor(sender) {
        this.sender = sender;
      }
      /**
       * Connect a slot to the signal.
       *
       * @param slot - The slot to invoke when the signal is emitted.
       *
       * @param thisArg - The `this` context for the slot. If provided,
       *   this must be a non-primitive object.
       *
       * @returns `true` if the connection succeeds, `false` otherwise.
       */
      connect(slot, thisArg) {
        return Private3.connect(this, slot, thisArg);
      }
      /**
       * Disconnect a slot from the signal.
       *
       * @param slot - The slot to disconnect from the signal.
       *
       * @param thisArg - The `this` context for the slot. If provided,
       *   this must be a non-primitive object.
       *
       * @returns `true` if the connection is removed, `false` otherwise.
       */
      disconnect(slot, thisArg) {
        return Private3.disconnect(this, slot, thisArg);
      }
      /**
       * Emit the signal and invoke the connected slots.
       *
       * @param args - The args to pass to the connected slots.
       *
       * #### Notes
       * Slots are invoked synchronously in connection order.
       *
       * Exceptions thrown by connected slots will be caught and logged.
       */
      emit(args) {
        Private3.emit(this, args);
      }
    };
    (function(Signal2) {
      function disconnectBetween(sender, receiver) {
        Private3.disconnectBetween(sender, receiver);
      }
      Signal2.disconnectBetween = disconnectBetween;
      function disconnectSender(sender) {
        Private3.disconnectSender(sender);
      }
      Signal2.disconnectSender = disconnectSender;
      function disconnectReceiver(receiver) {
        Private3.disconnectReceiver(receiver);
      }
      Signal2.disconnectReceiver = disconnectReceiver;
      function disconnectAll(object) {
        Private3.disconnectAll(object);
      }
      Signal2.disconnectAll = disconnectAll;
      function clearData(object) {
        Private3.disconnectAll(object);
      }
      Signal2.clearData = clearData;
      function getExceptionHandler() {
        return Private3.exceptionHandler;
      }
      Signal2.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = Private3.exceptionHandler;
        Private3.exceptionHandler = handler;
        return old;
      }
      Signal2.setExceptionHandler = setExceptionHandler;
    })(Signal || (Signal = {}));
    Stream = class extends Signal {
      constructor() {
        super(...arguments);
        this._pending = new import_coreutils.PromiseDelegate();
      }
      /**
       * Return an async iterator that yields every emission.
       */
      async *[Symbol.asyncIterator]() {
        let pending = this._pending;
        while (true) {
          try {
            const { args, next } = await pending.promise;
            pending = next;
            yield args;
          } catch (_) {
            return;
          }
        }
      }
      /**
       * Emit the signal, invoke the connected slots, and yield the emission.
       *
       * @param args - The args to pass to the connected slots.
       */
      emit(args) {
        const pending = this._pending;
        const next = this._pending = new import_coreutils.PromiseDelegate();
        pending.resolve({ args, next });
        super.emit(args);
      }
      /**
       * Stop the stream's async iteration.
       */
      stop() {
        this._pending.promise.catch(() => void 0);
        this._pending.reject("stop");
        this._pending = new import_coreutils.PromiseDelegate();
      }
    };
    (function(Private36) {
      Private36.exceptionHandler = (err) => {
        console.error(err);
      };
      function connect(signal, slot, thisArg) {
        thisArg = thisArg || void 0;
        let receivers = receiversForSender.get(signal.sender);
        if (!receivers) {
          receivers = [];
          receiversForSender.set(signal.sender, receivers);
        }
        if (findConnection(receivers, signal, slot, thisArg)) {
          return false;
        }
        let receiver = thisArg || slot;
        let senders = sendersForReceiver.get(receiver);
        if (!senders) {
          senders = [];
          sendersForReceiver.set(receiver, senders);
        }
        let connection = { signal, slot, thisArg };
        receivers.push(connection);
        senders.push(connection);
        return true;
      }
      Private36.connect = connect;
      function disconnect(signal, slot, thisArg) {
        thisArg = thisArg || void 0;
        let receivers = receiversForSender.get(signal.sender);
        if (!receivers || receivers.length === 0) {
          return false;
        }
        let connection = findConnection(receivers, signal, slot, thisArg);
        if (!connection) {
          return false;
        }
        let receiver = thisArg || slot;
        let senders = sendersForReceiver.get(receiver);
        connection.signal = null;
        scheduleCleanup(receivers);
        scheduleCleanup(senders);
        return true;
      }
      Private36.disconnect = disconnect;
      function disconnectBetween(sender, receiver) {
        let receivers = receiversForSender.get(sender);
        if (!receivers || receivers.length === 0) {
          return;
        }
        let senders = sendersForReceiver.get(receiver);
        if (!senders || senders.length === 0) {
          return;
        }
        for (const connection of senders) {
          if (!connection.signal) {
            continue;
          }
          if (connection.signal.sender === sender) {
            connection.signal = null;
          }
        }
        scheduleCleanup(receivers);
        scheduleCleanup(senders);
      }
      Private36.disconnectBetween = disconnectBetween;
      function disconnectSender(sender) {
        let receivers = receiversForSender.get(sender);
        if (!receivers || receivers.length === 0) {
          return;
        }
        for (const connection of receivers) {
          if (!connection.signal) {
            continue;
          }
          let receiver = connection.thisArg || connection.slot;
          connection.signal = null;
          scheduleCleanup(sendersForReceiver.get(receiver));
        }
        scheduleCleanup(receivers);
      }
      Private36.disconnectSender = disconnectSender;
      function disconnectReceiver(receiver) {
        let senders = sendersForReceiver.get(receiver);
        if (!senders || senders.length === 0) {
          return;
        }
        for (const connection of senders) {
          if (!connection.signal) {
            continue;
          }
          let sender = connection.signal.sender;
          connection.signal = null;
          scheduleCleanup(receiversForSender.get(sender));
        }
        scheduleCleanup(senders);
      }
      Private36.disconnectReceiver = disconnectReceiver;
      function disconnectAll(object) {
        disconnectSender(object);
        disconnectReceiver(object);
      }
      Private36.disconnectAll = disconnectAll;
      function emit(signal, args) {
        let receivers = receiversForSender.get(signal.sender);
        if (!receivers || receivers.length === 0) {
          return;
        }
        for (let i = 0, n = receivers.length; i < n; ++i) {
          let connection = receivers[i];
          if (connection.signal === signal) {
            invokeSlot(connection, args);
          }
        }
      }
      Private36.emit = emit;
      const receiversForSender = /* @__PURE__ */ new WeakMap();
      const sendersForReceiver = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      const schedule = (() => {
        let ok = typeof requestAnimationFrame === "function";
        return ok ? requestAnimationFrame : setImmediate;
      })();
      function findConnection(connections, signal, slot, thisArg) {
        return find(connections, (connection) => connection.signal === signal && connection.slot === slot && connection.thisArg === thisArg);
      }
      function invokeSlot(connection, args) {
        let { signal, slot, thisArg } = connection;
        try {
          slot.call(thisArg, signal.sender, args);
        } catch (err) {
          Private36.exceptionHandler(err);
        }
      }
      function scheduleCleanup(array) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(array);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupConnections);
        dirtySet.clear();
      }
      function cleanupConnections(connections) {
        ArrayExt.removeAllWhere(connections, isDeadConnection);
      }
      function isDeadConnection(connection) {
        return connection.signal === null;
      }
    })(Private3 || (Private3 = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/statedb/lib/restorablepool.js
var require_restorablepool = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/statedb/lib/restorablepool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestorablePool = void 0;
    var coreutils_12 = require_dist();
    var properties_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var RestorablePool2 = class {
      /**
       * Create a new restorable pool.
       *
       * @param options - The instantiation options for a restorable pool.
       */
      constructor(options) {
        this._added = new signaling_1.Signal(this);
        this._current = null;
        this._currentChanged = new signaling_1.Signal(this);
        this._hasRestored = false;
        this._isDisposed = false;
        this._objects = /* @__PURE__ */ new Set();
        this._restore = null;
        this._restored = new coreutils_12.PromiseDelegate();
        this._updated = new signaling_1.Signal(this);
        this.namespace = options.namespace;
      }
      /**
       * A signal emitted when an object object is added.
       *
       * #### Notes
       * This signal will only fire when an object is added to the pool.
       * It will not fire if an object injected into the pool.
       */
      get added() {
        return this._added;
      }
      /**
       * The current object.
       *
       * #### Notes
       * The restorable pool does not set `current`. It is intended for client use.
       *
       * If `current` is set to an object that does not exist in the pool, it is a
       * no-op.
       */
      get current() {
        return this._current;
      }
      set current(obj) {
        if (this._current === obj) {
          return;
        }
        if (obj !== null && this._objects.has(obj)) {
          this._current = obj;
          this._currentChanged.emit(this._current);
        }
      }
      /**
       * A signal emitted when the current widget changes.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * Test whether the pool is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * A promise resolved when the restorable pool has been restored.
       */
      get restored() {
        return this._restored.promise;
      }
      /**
       * The number of objects held by the pool.
       */
      get size() {
        return this._objects.size;
      }
      /**
       * A signal emitted when an object is updated.
       */
      get updated() {
        return this._updated;
      }
      /**
       * Add a new object to the pool.
       *
       * @param obj - The object object being added.
       *
       * #### Notes
       * The object passed into the pool is added synchronously; its existence in
       * the pool can be checked with the `has()` method. The promise this method
       * returns resolves after the object has been added and saved to an underlying
       * restoration connector, if one is available.
       */
      async add(obj) {
        var _a, _b;
        if (obj.isDisposed) {
          const warning = "A disposed object cannot be added.";
          console.warn(warning, obj);
          throw new Error(warning);
        }
        if (this._objects.has(obj)) {
          const warning = "This object already exists in the pool.";
          console.warn(warning, obj);
          throw new Error(warning);
        }
        this._objects.add(obj);
        obj.disposed.connect(this._onInstanceDisposed, this);
        if (Private36.injectedProperty.get(obj)) {
          return;
        }
        if (this._restore) {
          const { connector } = this._restore;
          const objName = this._restore.name(obj);
          if (objName) {
            const name2 = `${this.namespace}:${objName}`;
            const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
            Private36.nameProperty.set(obj, name2);
            await connector.save(name2, { data });
          }
        }
        this._added.emit(obj);
      }
      /**
       * Dispose of the resources held by the pool.
       *
       * #### Notes
       * Disposing a pool does not affect the underlying data in the data connector,
       * it simply disposes the client-side pool without making any connector calls.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._current = null;
        this._isDisposed = true;
        this._objects.clear();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Find the first object in the pool that satisfies a filter function.
       *
       * @param - fn The filter function to call on each object.
       */
      find(fn) {
        const values = this._objects.values();
        for (const value of values) {
          if (fn(value)) {
            return value;
          }
        }
        return void 0;
      }
      /**
       * Iterate through each object in the pool.
       *
       * @param fn - The function to call on each object.
       */
      forEach(fn) {
        this._objects.forEach(fn);
      }
      /**
       * Filter the objects in the pool based on a predicate.
       *
       * @param fn - The function by which to filter.
       */
      filter(fn) {
        const filtered = [];
        this.forEach((obj) => {
          if (fn(obj)) {
            filtered.push(obj);
          }
        });
        return filtered;
      }
      /**
       * Inject an object into the restorable pool without the pool handling its
       * restoration lifecycle.
       *
       * @param obj - The object to inject into the pool.
       */
      inject(obj) {
        Private36.injectedProperty.set(obj, true);
        return this.add(obj);
      }
      /**
       * Check if this pool has the specified object.
       *
       * @param obj - The object whose existence is being checked.
       */
      has(obj) {
        return this._objects.has(obj);
      }
      /**
       * Restore the objects in this pool's namespace.
       *
       * @param options - The configuration options that describe restoration.
       *
       * @returns A promise that resolves when restoration has completed.
       *
       * #### Notes
       * This function should almost never be invoked by client code. Its primary
       * use case is to be invoked by a layout restorer plugin that handles
       * multiple restorable pools and, when ready, asks them each to restore their
       * respective objects.
       */
      async restore(options) {
        if (this._hasRestored) {
          throw new Error("This pool has already been restored.");
        }
        this._hasRestored = true;
        const { command, connector, registry, when: when2 } = options;
        const namespace = this.namespace;
        const promises = when2 ? [connector.list(namespace)].concat(when2) : [connector.list(namespace)];
        this._restore = options;
        const [saved] = await Promise.all(promises);
        const values = await Promise.all(saved.ids.map(async (id, index) => {
          const value = saved.values[index];
          const args = value && value.data;
          if (args === void 0) {
            return connector.remove(id);
          }
          return registry.execute(command, args).catch(() => connector.remove(id));
        }));
        this._restored.resolve();
        return values;
      }
      /**
       * Save the restore data for a given object.
       *
       * @param obj - The object being saved.
       */
      async save(obj) {
        var _a, _b;
        const injected = Private36.injectedProperty.get(obj);
        if (!this._restore || !this.has(obj) || injected) {
          return;
        }
        const { connector } = this._restore;
        const objName = this._restore.name(obj);
        const oldName = Private36.nameProperty.get(obj);
        const newName = objName ? `${this.namespace}:${objName}` : "";
        if (oldName && oldName !== newName) {
          await connector.remove(oldName);
        }
        Private36.nameProperty.set(obj, newName);
        if (newName) {
          const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
          await connector.save(newName, { data });
        }
        if (oldName !== newName) {
          this._updated.emit(obj);
        }
      }
      /**
       * Clean up after disposed objects.
       */
      _onInstanceDisposed(obj) {
        this._objects.delete(obj);
        if (obj === this._current) {
          this._current = null;
          this._currentChanged.emit(this._current);
        }
        if (Private36.injectedProperty.get(obj)) {
          return;
        }
        if (!this._restore) {
          return;
        }
        const { connector } = this._restore;
        const name2 = Private36.nameProperty.get(obj);
        if (name2) {
          void connector.remove(name2);
        }
      }
    };
    exports2.RestorablePool = RestorablePool2;
    var Private36;
    (function(Private37) {
      Private37.injectedProperty = new properties_1.AttachedProperty({
        name: "injected",
        create: () => false
      });
      Private37.nameProperty = new properties_1.AttachedProperty({
        name: "name",
        create: () => ""
      });
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/statedb/lib/statedb.js
var require_statedb = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/statedb/lib/statedb.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StateDB = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var StateDB = class {
      /**
       * Create a new state database.
       *
       * @param options - The instantiation options for a state database.
       */
      constructor(options = {}) {
        this._changed = new signaling_1.Signal(this);
        const { connector, transform: transform2 } = options;
        this._connector = connector || new StateDB.Connector();
        if (!transform2) {
          this._ready = Promise.resolve(void 0);
        } else {
          this._ready = transform2.then((transformation) => {
            const { contents, type } = transformation;
            switch (type) {
              case "cancel":
                return;
              case "clear":
                return this._clear();
              case "merge":
                return this._merge(contents || {});
              case "overwrite":
                return this._overwrite(contents || {});
              default:
                return;
            }
          });
        }
      }
      /**
       * A signal that emits the change type any time a value changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Clear the entire database.
       */
      async clear() {
        await this._ready;
        await this._clear();
      }
      /**
       * Retrieve a saved bundle from the database.
       *
       * @param id - The identifier used to retrieve a data bundle.
       *
       * @returns A promise that bears a data payload if available.
       *
       * #### Notes
       * The `id` values of stored items in the state database are formatted:
       * `'namespace:identifier'`, which is the same convention that command
       * identifiers in JupyterLab use as well. While this is not a technical
       * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
       * using the `list(namespace: string)` method.
       *
       * The promise returned by this method may be rejected if an error occurs in
       * retrieving the data. Non-existence of an `id` will succeed with the `value`
       * `undefined`.
       */
      async fetch(id) {
        await this._ready;
        return this._fetch(id);
      }
      /**
       * Retrieve all the saved bundles for a namespace.
       *
       * @param filter - The namespace prefix to retrieve.
       *
       * @returns A promise that bears a collection of payloads for a namespace.
       *
       * #### Notes
       * Namespaces are entirely conventional entities. The `id` values of stored
       * items in the state database are formatted: `'namespace:identifier'`, which
       * is the same convention that command identifiers in JupyterLab use as well.
       *
       * If there are any errors in retrieving the data, they will be logged to the
       * console in order to optimistically return any extant data without failing.
       * This promise will always succeed.
       */
      async list(namespace) {
        await this._ready;
        return this._list(namespace);
      }
      /**
       * Remove a value from the database.
       *
       * @param id - The identifier for the data being removed.
       *
       * @returns A promise that is rejected if remove fails and succeeds otherwise.
       */
      async remove(id) {
        await this._ready;
        await this._remove(id);
        this._changed.emit({ id, type: "remove" });
      }
      /**
       * Save a value in the database.
       *
       * @param id - The identifier for the data being saved.
       *
       * @param value - The data being saved.
       *
       * @returns A promise that is rejected if saving fails and succeeds otherwise.
       *
       * #### Notes
       * The `id` values of stored items in the state database are formatted:
       * `'namespace:identifier'`, which is the same convention that command
       * identifiers in JupyterLab use as well. While this is not a technical
       * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
       * using the `list(namespace: string)` method.
       */
      async save(id, value) {
        await this._ready;
        await this._save(id, value);
        this._changed.emit({ id, type: "save" });
      }
      /**
       * Return a serialized copy of the state database's entire contents.
       *
       * @returns A promise that resolves with the database contents as JSON.
       */
      async toJSON() {
        await this._ready;
        const { ids, values } = await this._list();
        return values.reduce((acc, val, idx) => {
          acc[ids[idx]] = val;
          return acc;
        }, {});
      }
      /**
       * Clear the entire database.
       */
      async _clear() {
        await Promise.all((await this._list()).ids.map((id) => this._remove(id)));
      }
      /**
       * Fetch a value from the database.
       */
      async _fetch(id) {
        const value = await this._connector.fetch(id);
        if (value) {
          return JSON.parse(value).v;
        }
      }
      /**
       * Fetch a list from the database.
       */
      async _list(namespace = "") {
        const { ids, values } = await this._connector.list(namespace);
        return {
          ids,
          values: values.map((val) => JSON.parse(val).v)
        };
      }
      /**
       * Merge data into the state database.
       */
      async _merge(contents) {
        await Promise.all(Object.keys(contents).map((key2) => contents[key2] && this._save(key2, contents[key2])));
      }
      /**
       * Overwrite the entire database with new contents.
       */
      async _overwrite(contents) {
        await this._clear();
        await this._merge(contents);
      }
      /**
       * Remove a key in the database.
       */
      async _remove(id) {
        return this._connector.remove(id);
      }
      /**
       * Save a key and its value in the database.
       */
      async _save(id, value) {
        return this._connector.save(id, JSON.stringify({ v: value }));
      }
    };
    exports2.StateDB = StateDB;
    (function(StateDB2) {
      class Connector {
        constructor() {
          this._storage = {};
        }
        /**
         * Retrieve an item from the data connector.
         */
        async fetch(id) {
          return this._storage[id];
        }
        /**
         * Retrieve the list of items available from the data connector.
         *
         * @param namespace - If not empty, only keys whose first token before `:`
         * exactly match `namespace` will be returned, e.g. `foo` in `foo:bar`.
         */
        async list(namespace = "") {
          return Object.keys(this._storage).reduce((acc, val) => {
            if (namespace === "" ? true : namespace === val.split(":")[0]) {
              acc.ids.push(val);
              acc.values.push(this._storage[val]);
            }
            return acc;
          }, { ids: [], values: [] });
        }
        /**
         * Remove a value using the data connector.
         */
        async remove(id) {
          delete this._storage[id];
        }
        /**
         * Save a value using the data connector.
         */
        async save(id, value) {
          this._storage[id] = value;
        }
      }
      StateDB2.Connector = Connector;
    })(StateDB || (exports2.StateDB = StateDB = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/statedb/lib/tokens.js
var require_tokens = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/statedb/lib/tokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IStateDB = void 0;
    var coreutils_12 = require_dist();
    exports2.IStateDB = new coreutils_12.Token("@jupyterlab/coreutils:IStateDB", `A service for the JupyterLab state database.
  Use this if you want to store data that will persist across page loads.
  See "state database" for more information.`);
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/statedb/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/statedb/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_dataconnector(), exports2);
    __exportStar2(require_interfaces(), exports2);
    __exportStar2(require_restorablepool(), exports2);
    __exportStar2(require_statedb(), exports2);
    __exportStar2(require_tokens(), exports2);
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/activitymonitor.js
var require_activitymonitor = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/activitymonitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActivityMonitor = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var ActivityMonitor = class {
      /**
       * Construct a new activity monitor.
       */
      constructor(options) {
        this._timer = -1;
        this._timeout = -1;
        this._isDisposed = false;
        this._activityStopped = new signaling_1.Signal(this);
        options.signal.connect(this._onSignalFired, this);
        this._timeout = options.timeout || 1e3;
      }
      /**
       * A signal emitted when activity has ceased.
       */
      get activityStopped() {
        return this._activityStopped;
      }
      /**
       * The timeout associated with the monitor, in milliseconds.
       */
      get timeout() {
        return this._timeout;
      }
      set timeout(value) {
        this._timeout = value;
      }
      /**
       * Test whether the monitor has been disposed.
       *
       * #### Notes
       * This is a read-only property.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the activity monitor.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * A signal handler for the monitored signal.
       */
      _onSignalFired(sender, args) {
        clearTimeout(this._timer);
        this._sender = sender;
        this._args = args;
        this._timer = setTimeout(() => {
          this._activityStopped.emit({
            sender: this._sender,
            args: this._args
          });
        }, this._timeout);
      }
    };
    exports2.ActivityMonitor = ActivityMonitor;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/interfaces.js
var require_interfaces2 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/lru.js
var require_lru = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/lru.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LruCache = void 0;
    var DEFAULT_MAX_SIZE = 128;
    var LruCache = class {
      constructor(options = {}) {
        this._map = /* @__PURE__ */ new Map();
        this._maxSize = (options === null || options === void 0 ? void 0 : options.maxSize) || DEFAULT_MAX_SIZE;
      }
      /**
       * Return the current size of the cache.
       */
      get size() {
        return this._map.size;
      }
      /**
       * Clear the values in the cache.
       */
      clear() {
        this._map.clear();
      }
      /**
       * Get a value (or null) from the cache, pushing the item to the front of the cache.
       */
      get(key2) {
        const item = this._map.get(key2) || null;
        if (item != null) {
          this._map.delete(key2);
          this._map.set(key2, item);
        }
        return item;
      }
      /**
       * Set a value in the cache, potentially evicting an old item.
       */
      set(key2, value) {
        if (this._map.size >= this._maxSize) {
          this._map.delete(this._map.keys().next().value);
        }
        this._map.set(key2, value);
      }
    };
    exports2.LruCache = LruCache;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js
var require_markdowncodeblocks = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MarkdownCodeBlocks = void 0;
    var MarkdownCodeBlocks;
    (function(MarkdownCodeBlocks2) {
      MarkdownCodeBlocks2.CODE_BLOCK_MARKER = "```";
      const markdownExtensions = [
        ".markdown",
        ".mdown",
        ".mkdn",
        ".md",
        ".mkd",
        ".mdwn",
        ".mdtxt",
        ".mdtext",
        ".text",
        ".txt",
        ".Rmd"
      ];
      class MarkdownCodeBlock {
        constructor(startLine) {
          this.startLine = startLine;
          this.code = "";
          this.endLine = -1;
        }
      }
      MarkdownCodeBlocks2.MarkdownCodeBlock = MarkdownCodeBlock;
      function isMarkdown(extension) {
        return markdownExtensions.indexOf(extension) > -1;
      }
      MarkdownCodeBlocks2.isMarkdown = isMarkdown;
      function findMarkdownCodeBlocks(text) {
        if (!text || text === "") {
          return [];
        }
        const lines = text.split("\n");
        const codeBlocks = [];
        let currentBlock = null;
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
          const line = lines[lineIndex];
          const lineContainsMarker = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER) === 0;
          const constructingBlock = currentBlock != null;
          if (!lineContainsMarker && !constructingBlock) {
            continue;
          }
          if (!constructingBlock) {
            currentBlock = new MarkdownCodeBlock(lineIndex);
            const firstIndex = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const lastIndex = line.lastIndexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const isSingleLine = firstIndex !== lastIndex;
            if (isSingleLine) {
              currentBlock.code = line.substring(firstIndex + MarkdownCodeBlocks2.CODE_BLOCK_MARKER.length, lastIndex);
              currentBlock.endLine = lineIndex;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            }
          } else if (currentBlock) {
            if (lineContainsMarker) {
              currentBlock.endLine = lineIndex - 1;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            } else {
              currentBlock.code += line + "\n";
            }
          }
        }
        return codeBlocks;
      }
      MarkdownCodeBlocks2.findMarkdownCodeBlocks = findMarkdownCodeBlocks;
    })(MarkdownCodeBlocks || (exports2.MarkdownCodeBlocks = MarkdownCodeBlocks = {}));
  }
});

// ../../node_modules/minimist/index.js
var require_minimist = __commonJS({
  "../../node_modules/minimist/index.js"(exports2, module2) {
    "use strict";
    function hasKey(obj, keys) {
      var o = obj;
      keys.slice(0, -1).forEach(function(key3) {
        o = o[key3] || {};
      });
      var key2 = keys[keys.length - 1];
      return key2 in o;
    }
    function isNumber3(x) {
      if (typeof x === "number") {
        return true;
      }
      if (/^0x[0-9a-f]+$/i.test(x)) {
        return true;
      }
      return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function isConstructorOrProto(obj, key2) {
      return key2 === "constructor" && typeof obj[key2] === "function" || key2 === "__proto__";
    }
    module2.exports = function(args, opts) {
      if (!opts) {
        opts = {};
      }
      var flags = {
        bools: {},
        strings: {},
        unknownFn: null
      };
      if (typeof opts.unknown === "function") {
        flags.unknownFn = opts.unknown;
      }
      if (typeof opts.boolean === "boolean" && opts.boolean) {
        flags.allBools = true;
      } else {
        [].concat(opts.boolean).filter(Boolean).forEach(function(key3) {
          flags.bools[key3] = true;
        });
      }
      var aliases = {};
      function aliasIsBoolean(key3) {
        return aliases[key3].some(function(x) {
          return flags.bools[x];
        });
      }
      Object.keys(opts.alias || {}).forEach(function(key3) {
        aliases[key3] = [].concat(opts.alias[key3]);
        aliases[key3].forEach(function(x) {
          aliases[x] = [key3].concat(aliases[key3].filter(function(y) {
            return x !== y;
          }));
        });
      });
      [].concat(opts.string).filter(Boolean).forEach(function(key3) {
        flags.strings[key3] = true;
        if (aliases[key3]) {
          [].concat(aliases[key3]).forEach(function(k) {
            flags.strings[k] = true;
          });
        }
      });
      var defaults = opts.default || {};
      var argv = { _: [] };
      function argDefined(key3, arg2) {
        return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key3] || flags.bools[key3] || aliases[key3];
      }
      function setKey(obj, keys, value2) {
        var o = obj;
        for (var i2 = 0; i2 < keys.length - 1; i2++) {
          var key3 = keys[i2];
          if (isConstructorOrProto(o, key3)) {
            return;
          }
          if (o[key3] === void 0) {
            o[key3] = {};
          }
          if (o[key3] === Object.prototype || o[key3] === Number.prototype || o[key3] === String.prototype) {
            o[key3] = {};
          }
          if (o[key3] === Array.prototype) {
            o[key3] = [];
          }
          o = o[key3];
        }
        var lastKey = keys[keys.length - 1];
        if (isConstructorOrProto(o, lastKey)) {
          return;
        }
        if (o === Object.prototype || o === Number.prototype || o === String.prototype) {
          o = {};
        }
        if (o === Array.prototype) {
          o = [];
        }
        if (o[lastKey] === void 0 || flags.bools[lastKey] || typeof o[lastKey] === "boolean") {
          o[lastKey] = value2;
        } else if (Array.isArray(o[lastKey])) {
          o[lastKey].push(value2);
        } else {
          o[lastKey] = [o[lastKey], value2];
        }
      }
      function setArg(key3, val, arg2) {
        if (arg2 && flags.unknownFn && !argDefined(key3, arg2)) {
          if (flags.unknownFn(arg2) === false) {
            return;
          }
        }
        var value2 = !flags.strings[key3] && isNumber3(val) ? Number(val) : val;
        setKey(argv, key3.split("."), value2);
        (aliases[key3] || []).forEach(function(x) {
          setKey(argv, x.split("."), value2);
        });
      }
      Object.keys(flags.bools).forEach(function(key3) {
        setArg(key3, defaults[key3] === void 0 ? false : defaults[key3]);
      });
      var notFlags = [];
      if (args.indexOf("--") !== -1) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
      }
      for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        var key2;
        var next;
        if (/^--.+=/.test(arg)) {
          var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
          key2 = m[1];
          var value = m[2];
          if (flags.bools[key2]) {
            value = value !== "false";
          }
          setArg(key2, value, arg);
        } else if (/^--no-.+/.test(arg)) {
          key2 = arg.match(/^--no-(.+)/)[1];
          setArg(key2, false, arg);
        } else if (/^--.+/.test(arg)) {
          key2 = arg.match(/^--(.+)/)[1];
          next = args[i + 1];
          if (next !== void 0 && !/^(-|--)[^-]/.test(next) && !flags.bools[key2] && !flags.allBools && (aliases[key2] ? !aliasIsBoolean(key2) : true)) {
            setArg(key2, next, arg);
            i += 1;
          } else if (/^(true|false)$/.test(next)) {
            setArg(key2, next === "true", arg);
            i += 1;
          } else {
            setArg(key2, flags.strings[key2] ? "" : true, arg);
          }
        } else if (/^-[^-]+/.test(arg)) {
          var letters = arg.slice(1, -1).split("");
          var broken = false;
          for (var j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);
            if (next === "-") {
              setArg(letters[j], next, arg);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && next[0] === "=") {
              setArg(letters[j], next.slice(1), arg);
              broken = true;
              break;
            }
            if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next, arg);
              broken = true;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2), arg);
              broken = true;
              break;
            } else {
              setArg(letters[j], flags.strings[letters[j]] ? "" : true, arg);
            }
          }
          key2 = arg.slice(-1)[0];
          if (!broken && key2 !== "-") {
            if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key2] && (aliases[key2] ? !aliasIsBoolean(key2) : true)) {
              setArg(key2, args[i + 1], arg);
              i += 1;
            } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
              setArg(key2, args[i + 1] === "true", arg);
              i += 1;
            } else {
              setArg(key2, flags.strings[key2] ? "" : true, arg);
            }
          }
        } else {
          if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
            argv._.push(flags.strings._ || !isNumber3(arg) ? arg : Number(arg));
          }
          if (opts.stopEarly) {
            argv._.push.apply(argv._, args.slice(i + 1));
            break;
          }
        }
      }
      Object.keys(defaults).forEach(function(k) {
        if (!hasKey(argv, k.split("."))) {
          setKey(argv, k.split("."), defaults[k]);
          (aliases[k] || []).forEach(function(x) {
            setKey(argv, x.split("."), defaults[k]);
          });
        }
      });
      if (opts["--"]) {
        argv["--"] = notFlags.slice();
      } else {
        notFlags.forEach(function(k) {
          argv._.push(k);
        });
      }
      return argv;
    };
  }
});

// ../../node_modules/requires-port/index.js
var require_requires_port = __commonJS({
  "../../node_modules/requires-port/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port)
        return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
  }
});

// ../../node_modules/querystringify/index.js
var require_querystringify = __commonJS({
  "../../node_modules/querystringify/index.js"(exports2) {
    "use strict";
    var has5 = Object.prototype.hasOwnProperty;
    var undef;
    function decode(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, " "));
      } catch (e) {
        return null;
      }
    }
    function encode(input) {
      try {
        return encodeURIComponent(input);
      } catch (e) {
        return null;
      }
    }
    function querystring(query) {
      var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
      while (part = parser.exec(query)) {
        var key2 = decode(part[1]), value = decode(part[2]);
        if (key2 === null || value === null || key2 in result)
          continue;
        result[key2] = value;
      }
      return result;
    }
    function querystringify(obj, prefix) {
      prefix = prefix || "";
      var pairs = [], value, key2;
      if ("string" !== typeof prefix)
        prefix = "?";
      for (key2 in obj) {
        if (has5.call(obj, key2)) {
          value = obj[key2];
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = "";
          }
          key2 = encode(key2);
          value = encode(value);
          if (key2 === null || value === null)
            continue;
          pairs.push(key2 + "=" + value);
        }
      }
      return pairs.length ? prefix + pairs.join("&") : "";
    }
    exports2.stringify = querystringify;
    exports2.parse = querystring;
  }
});

// ../../node_modules/url-parse/index.js
var require_url_parse = __commonJS({
  "../../node_modules/url-parse/index.js"(exports2, module2) {
    "use strict";
    var required = require_requires_port();
    var qs = require_querystringify();
    var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
    var CRHTLF = /[\n\r\t]/g;
    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
    var port = /:\d+$/;
    var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
    var windowsDriveLetter = /^[a-zA-Z]:/;
    function trimLeft(str) {
      return (str ? str : "").toString().replace(controlOrWhitespace, "");
    }
    var rules = [
      ["#", "hash"],
      // Extract from the back.
      ["?", "query"],
      // Extract from the back.
      function sanitize2(address, url) {
        return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
      },
      ["/", "pathname"],
      // Extract from the back.
      ["@", "auth", 1],
      // Extract from the front.
      [NaN, "host", void 0, 1, 1],
      // Set left over value.
      [/:(\d*)$/, "port", void 0, 1],
      // RegExp the back.
      [NaN, "hostname", void 0, 1, 1]
      // Set left over.
    ];
    var ignore2 = { hash: 1, query: 1 };
    function lolcation(loc) {
      var globalVar;
      if (typeof window !== "undefined")
        globalVar = window;
      else if (typeof globalThis !== "undefined")
        globalVar = globalThis;
      else if (typeof self !== "undefined")
        globalVar = self;
      else
        globalVar = {};
      var location2 = globalVar.location || {};
      loc = loc || location2;
      var finaldestination = {}, type = typeof loc, key2;
      if ("blob:" === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ("string" === type) {
        finaldestination = new Url(loc, {});
        for (key2 in ignore2)
          delete finaldestination[key2];
      } else if ("object" === type) {
        for (key2 in loc) {
          if (key2 in ignore2)
            continue;
          finaldestination[key2] = loc[key2];
        }
        if (finaldestination.slashes === void 0) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }
      return finaldestination;
    }
    function isSpecial(scheme) {
      return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
    }
    function extractProtocol(address, location2) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      location2 = location2 || {};
      var match = protocolre.exec(address);
      var protocol = match[1] ? match[1].toLowerCase() : "";
      var forwardSlashes = !!match[2];
      var otherSlashes = !!match[3];
      var slashesCount = 0;
      var rest;
      if (forwardSlashes) {
        if (otherSlashes) {
          rest = match[2] + match[3] + match[4];
          slashesCount = match[2].length + match[3].length;
        } else {
          rest = match[2] + match[4];
          slashesCount = match[2].length;
        }
      } else {
        if (otherSlashes) {
          rest = match[3] + match[4];
          slashesCount = match[3].length;
        } else {
          rest = match[4];
        }
      }
      if (protocol === "file:") {
        if (slashesCount >= 2) {
          rest = rest.slice(2);
        }
      } else if (isSpecial(protocol)) {
        rest = match[4];
      } else if (protocol) {
        if (forwardSlashes) {
          rest = rest.slice(2);
        }
      } else if (slashesCount >= 2 && isSpecial(location2.protocol)) {
        rest = match[4];
      }
      return {
        protocol,
        slashes: forwardSlashes || isSpecial(protocol),
        slashesCount,
        rest
      };
    }
    function resolve(relative, base) {
      if (relative === "")
        return base;
      var path2 = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path2.length, last = path2[i - 1], unshift = false, up = 0;
      while (i--) {
        if (path2[i] === ".") {
          path2.splice(i, 1);
        } else if (path2[i] === "..") {
          path2.splice(i, 1);
          up++;
        } else if (up) {
          if (i === 0)
            unshift = true;
          path2.splice(i, 1);
          up--;
        }
      }
      if (unshift)
        path2.unshift("");
      if (last === "." || last === "..")
        path2.push("");
      return path2.join("/");
    }
    function Url(address, location2, parser) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      if (!(this instanceof Url)) {
        return new Url(address, location2, parser);
      }
      var relative, extracted, parse, instruction, index, key2, instructions = rules.slice(), type = typeof location2, url = this, i = 0;
      if ("object" !== type && "string" !== type) {
        parser = location2;
        location2 = null;
      }
      if (parser && "function" !== typeof parser)
        parser = qs.parse;
      location2 = lolcation(location2);
      extracted = extractProtocol(address || "", location2);
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location2.slashes;
      url.protocol = extracted.protocol || location2.protocol || "";
      address = extracted.rest;
      if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
        instructions[3] = [/(.*)/, "pathname"];
      }
      for (; i < instructions.length; i++) {
        instruction = instructions[i];
        if (typeof instruction === "function") {
          address = instruction(address, url);
          continue;
        }
        parse = instruction[0];
        key2 = instruction[1];
        if (parse !== parse) {
          url[key2] = address;
        } else if ("string" === typeof parse) {
          index = parse === "@" ? address.lastIndexOf(parse) : address.indexOf(parse);
          if (~index) {
            if ("number" === typeof instruction[2]) {
              url[key2] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key2] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if (index = parse.exec(address)) {
          url[key2] = index[1];
          address = address.slice(0, index.index);
        }
        url[key2] = url[key2] || (relative && instruction[3] ? location2[key2] || "" : "");
        if (instruction[4])
          url[key2] = url[key2].toLowerCase();
      }
      if (parser)
        url.query = parser(url.query);
      if (relative && location2.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location2.pathname !== "")) {
        url.pathname = resolve(url.pathname, location2.pathname);
      }
      if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
        url.pathname = "/" + url.pathname;
      }
      if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = "";
      }
      url.username = url.password = "";
      if (url.auth) {
        index = url.auth.indexOf(":");
        if (~index) {
          url.username = url.auth.slice(0, index);
          url.username = encodeURIComponent(decodeURIComponent(url.username));
          url.password = url.auth.slice(index + 1);
          url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
          url.username = encodeURIComponent(decodeURIComponent(url.auth));
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
      }
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
    }
    function set7(part, value, fn) {
      var url = this;
      switch (part) {
        case "query":
          if ("string" === typeof value && value.length) {
            value = (fn || qs.parse)(value);
          }
          url[part] = value;
          break;
        case "port":
          url[part] = value;
          if (!required(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = "";
          } else if (value) {
            url.host = url.hostname + ":" + value;
          }
          break;
        case "hostname":
          url[part] = value;
          if (url.port)
            value += ":" + url.port;
          url.host = value;
          break;
        case "host":
          url[part] = value;
          if (port.test(value)) {
            value = value.split(":");
            url.port = value.pop();
            url.hostname = value.join(":");
          } else {
            url.hostname = value;
            url.port = "";
          }
          break;
        case "protocol":
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;
        case "pathname":
        case "hash":
          if (value) {
            var char = part === "pathname" ? "/" : "#";
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;
        case "username":
        case "password":
          url[part] = encodeURIComponent(value);
          break;
        case "auth":
          var index = value.indexOf(":");
          if (~index) {
            url.username = value.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = value.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(value));
          }
      }
      for (var i = 0; i < rules.length; i++) {
        var ins = rules[i];
        if (ins[4])
          url[ins[1]] = url[ins[1]].toLowerCase();
      }
      url.auth = url.password ? url.username + ":" + url.password : url.username;
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
      return url;
    }
    function toString(stringify) {
      if (!stringify || "function" !== typeof stringify)
        stringify = qs.stringify;
      var query, url = this, host = url.host, protocol = url.protocol;
      if (protocol && protocol.charAt(protocol.length - 1) !== ":")
        protocol += ":";
      var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
      if (url.username) {
        result += url.username;
        if (url.password)
          result += ":" + url.password;
        result += "@";
      } else if (url.password) {
        result += ":" + url.password;
        result += "@";
      } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
        result += "@";
      }
      if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
        host += ":";
      }
      result += host + url.pathname;
      query = "object" === typeof url.query ? stringify(url.query) : url.query;
      if (query)
        result += "?" !== query.charAt(0) ? "?" + query : query;
      if (url.hash)
        result += url.hash;
      return result;
    }
    Url.prototype = { set: set7, toString };
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = qs;
    module2.exports = Url;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/url.js
var require_url = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/url.js"(exports2) {
    "use strict";
    var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLExt = void 0;
    var path_1 = __require("path");
    var url_parse_1 = __importDefault3(require_url_parse());
    var URLExt;
    (function(URLExt2) {
      function parse(url) {
        if (typeof document !== "undefined" && document) {
          const a = document.createElement("a");
          a.href = url;
          return a;
        }
        return (0, url_parse_1.default)(url);
      }
      URLExt2.parse = parse;
      function getHostName(url) {
        return (0, url_parse_1.default)(url).hostname;
      }
      URLExt2.getHostName = getHostName;
      function normalize2(url) {
        return url && parse(url).toString();
      }
      URLExt2.normalize = normalize2;
      function join2(...parts) {
        let u = (0, url_parse_1.default)(parts[0], {});
        const isSchemaLess = u.protocol === "" && u.slashes;
        if (isSchemaLess) {
          u = (0, url_parse_1.default)(parts[0], "https:" + parts[0]);
        }
        const prefix = `${isSchemaLess ? "" : u.protocol}${u.slashes ? "//" : ""}${u.auth}${u.auth ? "@" : ""}${u.host}`;
        const path2 = path_1.posix.join(`${!!prefix && u.pathname[0] !== "/" ? "/" : ""}${u.pathname}`, ...parts.slice(1));
        return `${prefix}${path2 === "." ? "" : path2}`;
      }
      URLExt2.join = join2;
      function encodeParts(url) {
        return join2(...url.split("/").map(encodeURIComponent));
      }
      URLExt2.encodeParts = encodeParts;
      function objectToQueryString(value) {
        const keys = Object.keys(value).filter((key2) => key2.length > 0);
        if (!keys.length) {
          return "";
        }
        return "?" + keys.map((key2) => {
          const content = encodeURIComponent(String(value[key2]));
          return key2 + (content ? "=" + content : "");
        }).join("&");
      }
      URLExt2.objectToQueryString = objectToQueryString;
      function queryStringToObject(value) {
        return value.replace(/^\?/, "").split("&").reduce((acc, val) => {
          const [key2, value2] = val.split("=");
          if (key2.length > 0) {
            acc[key2] = decodeURIComponent(value2 || "");
          }
          return acc;
        }, {});
      }
      URLExt2.queryStringToObject = queryStringToObject;
      function isLocal(url, allowRoot = false) {
        const { protocol } = parse(url);
        return (!protocol || url.toLowerCase().indexOf(protocol) !== 0) && (allowRoot ? url.indexOf("//") !== 0 : url.indexOf("/") !== 0);
      }
      URLExt2.isLocal = isLocal;
    })(URLExt || (exports2.URLExt = URLExt = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/pageconfig.js
var require_pageconfig = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/pageconfig.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageConfig = void 0;
    var coreutils_1 = require_dist();
    var minimist_1 = __importDefault(require_minimist());
    var url_1 = require_url();
    var PageConfig;
    (function(PageConfig) {
      function getOption(name) {
        if (configData) {
          return configData[name] || getBodyData(name);
        }
        configData = /* @__PURE__ */ Object.create(null);
        let found = false;
        if (typeof document !== "undefined" && document) {
          const el = document.getElementById("jupyter-config-data");
          if (el) {
            configData = JSON.parse(el.textContent || "");
            found = true;
          }
        }
        if (!found && typeof process !== "undefined" && process.argv) {
          try {
            const cli = (0, minimist_1.default)(process.argv.slice(2));
            const path = __require("path");
            let fullPath = "";
            if ("jupyter-config-data" in cli) {
              fullPath = path.resolve(cli["jupyter-config-data"]);
            } else if ("JUPYTER_CONFIG_DATA" in process.env) {
              fullPath = path.resolve(process.env["JUPYTER_CONFIG_DATA"]);
            }
            if (fullPath) {
              configData = eval("require")(fullPath);
            }
          } catch (e) {
            console.error(e);
          }
        }
        if (!coreutils_1.JSONExt.isObject(configData)) {
          configData = /* @__PURE__ */ Object.create(null);
        } else {
          for (const key2 in configData) {
            if (typeof configData[key2] !== "string") {
              configData[key2] = JSON.stringify(configData[key2]);
            }
          }
        }
        return configData[name] || getBodyData(name);
      }
      PageConfig.getOption = getOption;
      function setOption(name2, value) {
        const last = getOption(name2);
        configData[name2] = value;
        return last;
      }
      PageConfig.setOption = setOption;
      function getBaseUrl() {
        return url_1.URLExt.normalize(getOption("baseUrl") || "/");
      }
      PageConfig.getBaseUrl = getBaseUrl;
      function getTreeUrl() {
        return url_1.URLExt.join(getBaseUrl(), getOption("treeUrl"));
      }
      PageConfig.getTreeUrl = getTreeUrl;
      function getShareUrl() {
        return url_1.URLExt.normalize(getOption("shareUrl") || getBaseUrl());
      }
      PageConfig.getShareUrl = getShareUrl;
      function getTreeShareUrl() {
        return url_1.URLExt.normalize(url_1.URLExt.join(getShareUrl(), getOption("treeUrl")));
      }
      PageConfig.getTreeShareUrl = getTreeShareUrl;
      function getUrl(options) {
        var _a, _b, _c, _d;
        let path2 = options.toShare ? getShareUrl() : getBaseUrl();
        const mode = (_a = options.mode) !== null && _a !== void 0 ? _a : getOption("mode");
        const workspace = (_b = options.workspace) !== null && _b !== void 0 ? _b : getOption("workspace");
        const labOrDoc = mode === "single-document" ? "doc" : "lab";
        path2 = url_1.URLExt.join(path2, labOrDoc);
        if (workspace !== PageConfig.defaultWorkspace) {
          path2 = url_1.URLExt.join(path2, "workspaces", encodeURIComponent((_c = getOption("workspace")) !== null && _c !== void 0 ? _c : PageConfig.defaultWorkspace));
        }
        const treePath = (_d = options.treePath) !== null && _d !== void 0 ? _d : getOption("treePath");
        if (treePath) {
          path2 = url_1.URLExt.join(path2, "tree", url_1.URLExt.encodeParts(treePath));
        }
        return path2;
      }
      PageConfig.getUrl = getUrl;
      PageConfig.defaultWorkspace = "default";
      function getWsUrl(baseUrl) {
        let wsUrl = getOption("wsUrl");
        if (!wsUrl) {
          baseUrl = baseUrl ? url_1.URLExt.normalize(baseUrl) : getBaseUrl();
          if (baseUrl.indexOf("http") !== 0) {
            return "";
          }
          wsUrl = "ws" + baseUrl.slice(4);
        }
        return url_1.URLExt.normalize(wsUrl);
      }
      PageConfig.getWsUrl = getWsUrl;
      function getNBConvertURL({ path: path2, format, download }) {
        const notebookPath = url_1.URLExt.encodeParts(path2);
        const url = url_1.URLExt.join(getBaseUrl(), "nbconvert", format, notebookPath);
        if (download) {
          return url + "?download=true";
        }
        return url;
      }
      PageConfig.getNBConvertURL = getNBConvertURL;
      function getToken() {
        return getOption("token") || getBodyData("jupyterApiToken");
      }
      PageConfig.getToken = getToken;
      function getNotebookVersion() {
        const notebookVersion = getOption("notebookVersion");
        if (notebookVersion === "") {
          return [0, 0, 0];
        }
        return JSON.parse(notebookVersion);
      }
      PageConfig.getNotebookVersion = getNotebookVersion;
      let configData = null;
      function getBodyData(key2) {
        if (typeof document === "undefined" || !document.body) {
          return "";
        }
        const val = document.body.dataset[key2];
        if (typeof val === "undefined") {
          return "";
        }
        return decodeURIComponent(val);
      }
      let Extension;
      (function(Extension2) {
        function populate(key2) {
          try {
            const raw = getOption(key2);
            if (raw) {
              return JSON.parse(raw);
            }
          } catch (error) {
            console.warn(`Unable to parse ${key2}.`, error);
          }
          return [];
        }
        Extension2.deferred = populate("deferredExtensions");
        Extension2.disabled = populate("disabledExtensions");
        function isDeferred(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.deferred.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDeferred = isDeferred;
        function isDisabled(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.disabled.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDisabled = isDisabled;
      })(Extension = PageConfig.Extension || (PageConfig.Extension = {}));
    })(PageConfig || (exports.PageConfig = PageConfig = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/path.js
var require_path = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathExt = void 0;
    var path_1 = __require("path");
    var PathExt2;
    (function(PathExt3) {
      function join2(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : removeSlash(path2);
      }
      PathExt3.join = join2;
      function joinWithLeadingSlash(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : path2;
      }
      PathExt3.joinWithLeadingSlash = joinWithLeadingSlash;
      function basename(path2, ext) {
        return path_1.posix.basename(path2, ext);
      }
      PathExt3.basename = basename;
      function dirname(path2) {
        const dir = removeSlash(path_1.posix.dirname(path2));
        return dir === "." ? "" : dir;
      }
      PathExt3.dirname = dirname;
      function extname(path2) {
        return path_1.posix.extname(path2);
      }
      PathExt3.extname = extname;
      function normalize2(path2) {
        if (path2 === "") {
          return "";
        }
        return removeSlash(path_1.posix.normalize(path2));
      }
      PathExt3.normalize = normalize2;
      function resolve(...parts) {
        return removeSlash(path_1.posix.resolve(...parts));
      }
      PathExt3.resolve = resolve;
      function relative(from2, to) {
        return removeSlash(path_1.posix.relative(from2, to));
      }
      PathExt3.relative = relative;
      function normalizeExtension(extension) {
        if (extension.length > 0 && extension.indexOf(".") !== 0) {
          extension = `.${extension}`;
        }
        return extension;
      }
      PathExt3.normalizeExtension = normalizeExtension;
      function removeSlash(path2) {
        if (path2.indexOf("/") === 0) {
          path2 = path2.slice(1);
        }
        return path2;
      }
      PathExt3.removeSlash = removeSlash;
    })(PathExt2 || (exports2.PathExt = PathExt2 = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/signal.js
var require_signal = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/signal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signalToPromise = void 0;
    var coreutils_12 = require_dist();
    function signalToPromise(signal, timeout) {
      const waitForSignal = new coreutils_12.PromiseDelegate();
      function cleanup() {
        signal.disconnect(slot);
      }
      function slot(sender, args) {
        cleanup();
        waitForSignal.resolve([sender, args]);
      }
      signal.connect(slot);
      if ((timeout !== null && timeout !== void 0 ? timeout : 0) > 0) {
        setTimeout(() => {
          cleanup();
          waitForSignal.reject(`Signal not emitted within ${timeout} ms.`);
        }, timeout);
      }
      return waitForSignal.promise;
    }
    exports2.signalToPromise = signalToPromise;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/text.js
var require_text = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/text.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Text = void 0;
    var Text3;
    (function(Text4) {
      const HAS_SURROGATES = "\u{1D41A}".length > 1;
      function jsIndexToCharIndex(jsIdx, text) {
        if (HAS_SURROGATES) {
          return jsIdx;
        }
        let charIdx = jsIdx;
        for (let i = 0; i + 1 < text.length && i < jsIdx; i++) {
          const charCode = text.charCodeAt(i);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              charIdx--;
              i++;
            }
          }
        }
        return charIdx;
      }
      Text4.jsIndexToCharIndex = jsIndexToCharIndex;
      function charIndexToJsIndex(charIdx, text) {
        if (HAS_SURROGATES) {
          return charIdx;
        }
        let jsIdx = charIdx;
        for (let i = 0; i + 1 < text.length && i < jsIdx; i++) {
          const charCode = text.charCodeAt(i);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              jsIdx++;
              i++;
            }
          }
        }
        return jsIdx;
      }
      Text4.charIndexToJsIndex = charIndexToJsIndex;
      function camelCase(str, upper = false) {
        return str.replace(/^(\w)|[\s-_:]+(\w)/g, function(match, p1, p2) {
          if (p2) {
            return p2.toUpperCase();
          } else {
            return upper ? p1.toUpperCase() : p1.toLowerCase();
          }
        });
      }
      Text4.camelCase = camelCase;
      function titleCase(str) {
        return (str || "").toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
      }
      Text4.titleCase = titleCase;
    })(Text3 || (exports2.Text = Text3 = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/time.js
var require_time = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Time = void 0;
    var UNITS = [
      { name: "years", milliseconds: 365 * 24 * 60 * 60 * 1e3 },
      { name: "months", milliseconds: 30 * 24 * 60 * 60 * 1e3 },
      { name: "days", milliseconds: 24 * 60 * 60 * 1e3 },
      { name: "hours", milliseconds: 60 * 60 * 1e3 },
      { name: "minutes", milliseconds: 60 * 1e3 },
      { name: "seconds", milliseconds: 1e3 }
    ];
    var Time;
    (function(Time2) {
      function formatHuman(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.RelativeTimeFormat(lang, { numeric: "auto" });
        const delta = new Date(value).getTime() - Date.now();
        for (let unit of UNITS) {
          const amount = Math.ceil(delta / unit.milliseconds);
          if (amount === 0) {
            continue;
          }
          return formatter.format(amount, unit.name);
        }
        return formatter.format(0, "seconds");
      }
      Time2.formatHuman = formatHuman;
      function format(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.DateTimeFormat(lang, {
          dateStyle: "short",
          timeStyle: "short"
        });
        return formatter.format(new Date(value));
      }
      Time2.format = format;
    })(Time || (exports2.Time = Time = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/coreutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_activitymonitor(), exports2);
    __exportStar2(require_interfaces2(), exports2);
    __exportStar2(require_lru(), exports2);
    __exportStar2(require_markdowncodeblocks(), exports2);
    __exportStar2(require_pageconfig(), exports2);
    __exportStar2(require_path(), exports2);
    __exportStar2(require_signal(), exports2);
    __exportStar2(require_text(), exports2);
    __exportStar2(require_time(), exports2);
    __exportStar2(require_url(), exports2);
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/messages.js
var require_messages = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.supportedKernelWebSocketProtocols = exports2.isInputReplyMsg = exports2.isInputRequestMsg = exports2.isDebugReplyMsg = exports2.isDebugRequestMsg = exports2.isExecuteReplyMsg = exports2.isInfoRequestMsg = exports2.isCommMsgMsg = exports2.isCommCloseMsg = exports2.isCommOpenMsg = exports2.isDebugEventMsg = exports2.isClearOutputMsg = exports2.isStatusMsg = exports2.isErrorMsg = exports2.isExecuteResultMsg = exports2.isExecuteInputMsg = exports2.isUpdateDisplayDataMsg = exports2.isDisplayDataMsg = exports2.isStreamMsg = exports2.createMessage = void 0;
    var coreutils_12 = require_dist();
    function createMessage(options) {
      var _a, _b, _c, _d, _e;
      return {
        buffers: (_a = options.buffers) !== null && _a !== void 0 ? _a : [],
        channel: options.channel,
        content: options.content,
        header: {
          date: (/* @__PURE__ */ new Date()).toISOString(),
          msg_id: (_b = options.msgId) !== null && _b !== void 0 ? _b : coreutils_12.UUID.uuid4(),
          msg_type: options.msgType,
          session: options.session,
          username: (_c = options.username) !== null && _c !== void 0 ? _c : "",
          version: "5.2"
        },
        metadata: (_d = options.metadata) !== null && _d !== void 0 ? _d : {},
        parent_header: (_e = options.parentHeader) !== null && _e !== void 0 ? _e : {}
      };
    }
    exports2.createMessage = createMessage;
    function isStreamMsg(msg) {
      return msg.header.msg_type === "stream";
    }
    exports2.isStreamMsg = isStreamMsg;
    function isDisplayDataMsg(msg) {
      return msg.header.msg_type === "display_data";
    }
    exports2.isDisplayDataMsg = isDisplayDataMsg;
    function isUpdateDisplayDataMsg(msg) {
      return msg.header.msg_type === "update_display_data";
    }
    exports2.isUpdateDisplayDataMsg = isUpdateDisplayDataMsg;
    function isExecuteInputMsg(msg) {
      return msg.header.msg_type === "execute_input";
    }
    exports2.isExecuteInputMsg = isExecuteInputMsg;
    function isExecuteResultMsg(msg) {
      return msg.header.msg_type === "execute_result";
    }
    exports2.isExecuteResultMsg = isExecuteResultMsg;
    function isErrorMsg(msg) {
      return msg.header.msg_type === "error";
    }
    exports2.isErrorMsg = isErrorMsg;
    function isStatusMsg(msg) {
      return msg.header.msg_type === "status";
    }
    exports2.isStatusMsg = isStatusMsg;
    function isClearOutputMsg(msg) {
      return msg.header.msg_type === "clear_output";
    }
    exports2.isClearOutputMsg = isClearOutputMsg;
    function isDebugEventMsg(msg) {
      return msg.header.msg_type === "debug_event";
    }
    exports2.isDebugEventMsg = isDebugEventMsg;
    function isCommOpenMsg(msg) {
      return msg.header.msg_type === "comm_open";
    }
    exports2.isCommOpenMsg = isCommOpenMsg;
    function isCommCloseMsg(msg) {
      return msg.header.msg_type === "comm_close";
    }
    exports2.isCommCloseMsg = isCommCloseMsg;
    function isCommMsgMsg(msg) {
      return msg.header.msg_type === "comm_msg";
    }
    exports2.isCommMsgMsg = isCommMsgMsg;
    function isInfoRequestMsg(msg) {
      return msg.header.msg_type === "kernel_info_request";
    }
    exports2.isInfoRequestMsg = isInfoRequestMsg;
    function isExecuteReplyMsg(msg) {
      return msg.header.msg_type === "execute_reply";
    }
    exports2.isExecuteReplyMsg = isExecuteReplyMsg;
    function isDebugRequestMsg(msg) {
      return msg.header.msg_type === "debug_request";
    }
    exports2.isDebugRequestMsg = isDebugRequestMsg;
    function isDebugReplyMsg(msg) {
      return msg.header.msg_type === "debug_reply";
    }
    exports2.isDebugReplyMsg = isDebugReplyMsg;
    function isInputRequestMsg(msg) {
      return msg.header.msg_type === "input_request";
    }
    exports2.isInputRequestMsg = isInputRequestMsg;
    function isInputReplyMsg(msg) {
      return msg.header.msg_type === "input_reply";
    }
    exports2.isInputReplyMsg = isInputReplyMsg;
    var supportedKernelWebSocketProtocols;
    (function(supportedKernelWebSocketProtocols2) {
      supportedKernelWebSocketProtocols2["v1KernelWebsocketJupyterOrg"] = "v1.kernel.websocket.jupyter.org";
    })(supportedKernelWebSocketProtocols || (exports2.supportedKernelWebSocketProtocols = supportedKernelWebSocketProtocols = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/serialize.js
var require_serialize = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/serialize.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deserialize = exports2.serialize = void 0;
    var KernelMessage = __importStar2(require_messages());
    function serialize(msg, protocol = "") {
      switch (protocol) {
        case KernelMessage.supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg:
          return Private36.serializeV1KernelWebsocketJupyterOrg(msg);
        default:
          return Private36.serializeDefault(msg);
      }
    }
    exports2.serialize = serialize;
    function deserialize(data, protocol = "") {
      switch (protocol) {
        case KernelMessage.supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg:
          return Private36.deserializeV1KernelWebsocketJupyterOrg(data);
        default:
          return Private36.deserializeDefault(data);
      }
    }
    exports2.deserialize = deserialize;
    var Private36;
    (function(Private37) {
      function deserializeV1KernelWebsocketJupyterOrg(binMsg) {
        let msg;
        const data = new DataView(binMsg);
        const offsetNumber = Number(data.getBigUint64(
          0,
          true
          /* littleEndian */
        ));
        let offsets = [];
        for (let i = 0; i < offsetNumber; i++) {
          offsets.push(Number(data.getBigUint64(
            8 * (i + 1),
            true
            /* littleEndian */
          )));
        }
        const decoder = new TextDecoder("utf8");
        const channel = decoder.decode(binMsg.slice(offsets[0], offsets[1]));
        const header = JSON.parse(decoder.decode(binMsg.slice(offsets[1], offsets[2])));
        const parent_header = JSON.parse(decoder.decode(binMsg.slice(offsets[2], offsets[3])));
        const metadata = JSON.parse(decoder.decode(binMsg.slice(offsets[3], offsets[4])));
        const content = JSON.parse(decoder.decode(binMsg.slice(offsets[4], offsets[5])));
        let buffers = [];
        for (let i = 5; i < offsets.length - 1; i++) {
          buffers.push(new DataView(binMsg.slice(offsets[i], offsets[i + 1])));
        }
        msg = {
          channel,
          header,
          parent_header,
          metadata,
          content,
          buffers
        };
        return msg;
      }
      Private37.deserializeV1KernelWebsocketJupyterOrg = deserializeV1KernelWebsocketJupyterOrg;
      function serializeV1KernelWebsocketJupyterOrg(msg) {
        const header = JSON.stringify(msg.header);
        const parentHeader = msg.parent_header == null ? "{}" : JSON.stringify(msg.parent_header);
        const metadata = JSON.stringify(msg.metadata);
        const content = JSON.stringify(msg.content);
        const buffers = msg.buffers !== void 0 ? msg.buffers : [];
        const offsetNumber = 1 + 4 + buffers.length + 1;
        let offsets = [];
        offsets.push(8 * (1 + offsetNumber));
        offsets.push(msg.channel.length + offsets[offsets.length - 1]);
        const encoder = new TextEncoder();
        const channelEncoded = encoder.encode(msg.channel);
        const headerEncoded = encoder.encode(header);
        const parentHeaderEncoded = encoder.encode(parentHeader);
        const metadataEncoded = encoder.encode(metadata);
        const contentEncoded = encoder.encode(content);
        const binMsgNoBuff = new Uint8Array(channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length + metadataEncoded.length + contentEncoded.length);
        binMsgNoBuff.set(channelEncoded);
        binMsgNoBuff.set(headerEncoded, channelEncoded.length);
        binMsgNoBuff.set(parentHeaderEncoded, channelEncoded.length + headerEncoded.length);
        binMsgNoBuff.set(metadataEncoded, channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length);
        binMsgNoBuff.set(contentEncoded, channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length + metadataEncoded.length);
        for (let length of [
          headerEncoded.length,
          parentHeaderEncoded.length,
          metadataEncoded.length,
          contentEncoded.length
        ]) {
          offsets.push(length + offsets[offsets.length - 1]);
        }
        let buffersByteLength = 0;
        for (let buffer of buffers) {
          let length = buffer.byteLength;
          offsets.push(length + offsets[offsets.length - 1]);
          buffersByteLength += length;
        }
        const binMsg = new Uint8Array(8 * (1 + offsetNumber) + binMsgNoBuff.byteLength + buffersByteLength);
        const word = new ArrayBuffer(8);
        const data = new DataView(word);
        data.setBigUint64(
          0,
          BigInt(offsetNumber),
          true
          /* littleEndian */
        );
        binMsg.set(new Uint8Array(word), 0);
        for (let i = 0; i < offsets.length; i++) {
          data.setBigUint64(
            0,
            BigInt(offsets[i]),
            true
            /* littleEndian */
          );
          binMsg.set(new Uint8Array(word), 8 * (i + 1));
        }
        binMsg.set(binMsgNoBuff, offsets[0]);
        for (let i = 0; i < buffers.length; i++) {
          const buffer = buffers[i];
          binMsg.set(new Uint8Array(ArrayBuffer.isView(buffer) ? buffer.buffer : buffer), offsets[5 + i]);
        }
        return binMsg.buffer;
      }
      Private37.serializeV1KernelWebsocketJupyterOrg = serializeV1KernelWebsocketJupyterOrg;
      function deserializeDefault(data) {
        let value;
        if (typeof data === "string") {
          value = JSON.parse(data);
        } else {
          value = deserializeBinary(data);
        }
        return value;
      }
      Private37.deserializeDefault = deserializeDefault;
      function serializeDefault(msg) {
        var _a;
        let value;
        if ((_a = msg.buffers) === null || _a === void 0 ? void 0 : _a.length) {
          value = serializeBinary(msg);
        } else {
          value = JSON.stringify(msg);
        }
        return value;
      }
      Private37.serializeDefault = serializeDefault;
      function deserializeBinary(buf) {
        const data = new DataView(buf);
        const nbufs = data.getUint32(0);
        const offsets = [];
        if (nbufs < 2) {
          throw new Error("Invalid incoming Kernel Message");
        }
        for (let i = 1; i <= nbufs; i++) {
          offsets.push(data.getUint32(i * 4));
        }
        const jsonBytes = new Uint8Array(buf.slice(offsets[0], offsets[1]));
        const msg = JSON.parse(new TextDecoder("utf8").decode(jsonBytes));
        msg.buffers = [];
        for (let i = 1; i < nbufs; i++) {
          const start = offsets[i];
          const stop = offsets[i + 1] || buf.byteLength;
          msg.buffers.push(new DataView(buf.slice(start, stop)));
        }
        return msg;
      }
      function serializeBinary(msg) {
        const offsets = [];
        const buffers = [];
        const encoder = new TextEncoder();
        let origBuffers = [];
        if (msg.buffers !== void 0) {
          origBuffers = msg.buffers;
          delete msg["buffers"];
        }
        const jsonUtf8 = encoder.encode(JSON.stringify(msg));
        buffers.push(jsonUtf8.buffer);
        for (let i = 0; i < origBuffers.length; i++) {
          const b = origBuffers[i];
          buffers.push(ArrayBuffer.isView(b) ? b.buffer : b);
        }
        const nbufs = buffers.length;
        offsets.push(4 * (nbufs + 1));
        for (let i = 0; i + 1 < buffers.length; i++) {
          offsets.push(offsets[offsets.length - 1] + buffers[i].byteLength);
        }
        const msgBuf = new Uint8Array(offsets[offsets.length - 1] + buffers[buffers.length - 1].byteLength);
        const view = new DataView(msgBuf.buffer);
        view.setUint32(0, nbufs);
        for (let i = 0; i < offsets.length; i++) {
          view.setUint32(4 * (i + 1), offsets[i]);
        }
        for (let i = 0; i < buffers.length; i++) {
          msgBuf.set(new Uint8Array(buffers[i]), offsets[i]);
        }
        return msgBuf.buffer;
      }
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/shim/ws.js
var require_ws = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/shim/ws.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = WebSocket;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/serverconnection.js
var require_serverconnection = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/serverconnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerConnection = void 0;
    var coreutils_12 = require_lib2();
    var serialize_1 = require_serialize();
    var WEBSOCKET;
    if (typeof window === "undefined") {
      WEBSOCKET = require_ws();
    } else {
      WEBSOCKET = WebSocket;
    }
    var ServerConnection3;
    (function(ServerConnection4) {
      function makeSettings(options) {
        return Private36.makeSettings(options);
      }
      ServerConnection4.makeSettings = makeSettings;
      function makeRequest(url, init, settings) {
        return Private36.handleRequest(url, init, settings);
      }
      ServerConnection4.makeRequest = makeRequest;
      class ResponseError extends Error {
        /**
         * Create a ResponseError from a response, handling the traceback and message
         * as appropriate.
         *
         * @param response The response object.
         *
         * @returns A promise that resolves with a `ResponseError` object.
         */
        static async create(response) {
          try {
            const data = await response.json();
            const { message, traceback } = data;
            if (traceback) {
              console.error(traceback);
            }
            return new ResponseError(response, message !== null && message !== void 0 ? message : ResponseError._defaultMessage(response), traceback !== null && traceback !== void 0 ? traceback : "");
          } catch (e) {
            console.debug(e);
            return new ResponseError(response);
          }
        }
        /**
         * Create a new response error.
         */
        constructor(response, message = ResponseError._defaultMessage(response), traceback = "") {
          super(message);
          this.response = response;
          this.traceback = traceback;
        }
        static _defaultMessage(response) {
          return `Invalid response: ${response.status} ${response.statusText}`;
        }
      }
      ServerConnection4.ResponseError = ResponseError;
      class NetworkError extends TypeError {
        /**
         * Create a new network error.
         */
        constructor(original) {
          super(original.message);
          this.stack = original.stack;
        }
      }
      ServerConnection4.NetworkError = NetworkError;
    })(ServerConnection3 || (exports2.ServerConnection = ServerConnection3 = {}));
    var Private36;
    (function(Private37) {
      function makeSettings(options = {}) {
        var _a;
        const pageBaseUrl = coreutils_12.PageConfig.getBaseUrl();
        const pageWsUrl = coreutils_12.PageConfig.getWsUrl();
        const baseUrl = coreutils_12.URLExt.normalize(options.baseUrl) || pageBaseUrl;
        let wsUrl = options.wsUrl;
        if (!wsUrl && baseUrl === pageBaseUrl) {
          wsUrl = pageWsUrl;
        }
        if (!wsUrl && baseUrl.indexOf("http") === 0) {
          wsUrl = "ws" + baseUrl.slice(4);
        }
        wsUrl = wsUrl !== null && wsUrl !== void 0 ? wsUrl : pageWsUrl;
        return {
          init: { cache: "no-store", credentials: "same-origin" },
          fetch,
          Headers,
          Request,
          WebSocket: WEBSOCKET,
          token: coreutils_12.PageConfig.getToken(),
          appUrl: coreutils_12.PageConfig.getOption("appUrl"),
          appendToken: typeof window === "undefined" || typeof process !== "undefined" && ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.JEST_WORKER_ID) !== void 0 || coreutils_12.URLExt.getHostName(pageBaseUrl) !== coreutils_12.URLExt.getHostName(wsUrl),
          serializer: { serialize: serialize_1.serialize, deserialize: serialize_1.deserialize },
          ...options,
          baseUrl,
          wsUrl
        };
      }
      Private37.makeSettings = makeSettings;
      function handleRequest(url, init, settings) {
        var _a;
        if (url.indexOf(settings.baseUrl) !== 0) {
          throw new Error("Can only be used for notebook server requests");
        }
        const cache2 = (_a = init.cache) !== null && _a !== void 0 ? _a : settings.init.cache;
        if (cache2 === "no-store") {
          url += (/\?/.test(url) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
        }
        const request = new settings.Request(url, { ...settings.init, ...init });
        let authenticated = false;
        if (settings.token) {
          authenticated = true;
          request.headers.append("Authorization", `token ${settings.token}`);
        }
        if (typeof document !== "undefined") {
          const xsrfToken = getCookie("_xsrf");
          if (xsrfToken !== void 0) {
            authenticated = true;
            request.headers.append("X-XSRFToken", xsrfToken);
          }
        }
        if (!request.headers.has("Content-Type") && authenticated) {
          request.headers.set("Content-Type", "application/json");
        }
        return settings.fetch.call(null, request).catch((e) => {
          throw new ServerConnection3.NetworkError(e);
        });
      }
      Private37.handleRequest = handleRequest;
      function getCookie(name2) {
        let cookie = "";
        try {
          cookie = document.cookie;
        } catch (e) {
          return;
        }
        const matches2 = cookie.match("\\b" + name2 + "=([^;]*)\\b");
        return matches2 === null || matches2 === void 0 ? void 0 : matches2[1];
      }
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/basemanager.js
var require_basemanager = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/basemanager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseManager = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var serverconnection_1 = require_serverconnection();
    var BaseManager = class {
      constructor(options) {
        var _a;
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * A signal emitted when the delegate is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Test whether the delegate has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Whether the manager is active.
       */
      get isActive() {
        return true;
      }
      /**
       * Dispose of the delegate and invoke the callback function.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._disposed.emit(void 0);
        signaling_1.Signal.clearData(this);
      }
    };
    exports2.BaseManager = BaseManager;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/config/index.js
var require_config = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigWithDefaults = exports2.ConfigSection = void 0;
    var coreutils_12 = require_lib2();
    var __1 = require_lib3();
    var SERVICE_CONFIG_URL = "api/config";
    var ConfigSection;
    (function(ConfigSection2) {
      function create5(options) {
        const section = new DefaultConfigSection(options);
        return section.load().then(() => {
          return section;
        });
      }
      ConfigSection2.create = create5;
    })(ConfigSection || (exports2.ConfigSection = ConfigSection = {}));
    var DefaultConfigSection = class {
      /**
       * Construct a new config section.
       */
      constructor(options) {
        var _a;
        this._url = "unknown";
        const settings = this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._url = coreutils_12.URLExt.join(settings.baseUrl, SERVICE_CONFIG_URL, encodeURIComponent(options.name));
      }
      /**
       * Get the data for this section.
       */
      get data() {
        return this._data;
      }
      /**
       * Load the initial data for this section.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       */
      async load() {
        const response = await __1.ServerConnection.makeRequest(this._url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._data = await response.json();
      }
      /**
       * Modify the stored config values.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * Updates the local data immediately, sends the change to the server,
       * and updates the local data with the response, and fulfils the promise
       * with that data.
       */
      async update(newdata) {
        this._data = { ...this._data, ...newdata };
        const init = {
          method: "PATCH",
          body: JSON.stringify(newdata)
        };
        const response = await __1.ServerConnection.makeRequest(this._url, init, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._data = await response.json();
        return this._data;
      }
    };
    var ConfigWithDefaults = class {
      /**
       * Create a new config with defaults.
       */
      constructor(options) {
        var _a, _b;
        this._className = "";
        this._section = options.section;
        this._defaults = (_a = options.defaults) !== null && _a !== void 0 ? _a : {};
        this._className = (_b = options.className) !== null && _b !== void 0 ? _b : "";
      }
      /**
       * Get data from the config section or fall back to defaults.
       */
      get(key2) {
        const data = this._classData();
        return key2 in data ? data[key2] : this._defaults[key2];
      }
      /**
       * Set a config value.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * Sends the update to the server, and changes our local copy of the data
       * immediately.
       */
      set(key2, value) {
        const d = {};
        d[key2] = value;
        if (this._className) {
          const d2 = {};
          d2[this._className] = d;
          return this._section.update(d2);
        } else {
          return this._section.update(d);
        }
      }
      /**
       * Get data from the Section with our classname, if available.
       *
       * #### Notes
       * If we have no classname, get all of the data in the Section
       */
      _classData() {
        const data = this._section.data;
        if (this._className && this._className in data) {
          return data[this._className];
        }
        return data;
      }
    };
    exports2.ConfigWithDefaults = ConfigWithDefaults;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/validate.js
var require_validate = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateProperty = void 0;
    function validateProperty(object, name2, typeName, values = []) {
      if (!object.hasOwnProperty(name2)) {
        throw Error(`Missing property '${name2}'`);
      }
      const value = object[name2];
      if (typeName !== void 0) {
        let valid = true;
        switch (typeName) {
          case "array":
            valid = Array.isArray(value);
            break;
          case "object":
            valid = typeof value !== "undefined";
            break;
          default:
            valid = typeof value === typeName;
        }
        if (!valid) {
          throw new Error(`Property '${name2}' is not of type '${typeName}'`);
        }
        if (values.length > 0) {
          let valid2 = true;
          switch (typeName) {
            case "string":
            case "number":
            case "boolean":
              valid2 = values.includes(value);
              break;
            default:
              valid2 = values.findIndex((v) => v === value) >= 0;
              break;
          }
          if (!valid2) {
            throw new Error(`Property '${name2}' is not one of the valid values ${JSON.stringify(values)}`);
          }
        }
      }
    }
    exports2.validateProperty = validateProperty;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/contents/validate.js
var require_validate2 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/contents/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateCheckpointModel = exports2.validateContentsModel = void 0;
    var validate_1 = require_validate();
    function validateContentsModel(model) {
      (0, validate_1.validateProperty)(model, "name", "string");
      (0, validate_1.validateProperty)(model, "path", "string");
      (0, validate_1.validateProperty)(model, "type", "string");
      (0, validate_1.validateProperty)(model, "created", "string");
      (0, validate_1.validateProperty)(model, "last_modified", "string");
      (0, validate_1.validateProperty)(model, "mimetype", "object");
      (0, validate_1.validateProperty)(model, "content", "object");
      (0, validate_1.validateProperty)(model, "format", "object");
    }
    exports2.validateContentsModel = validateContentsModel;
    function validateCheckpointModel(model) {
      (0, validate_1.validateProperty)(model, "id", "string");
      (0, validate_1.validateProperty)(model, "last_modified", "string");
    }
    exports2.validateCheckpointModel = validateCheckpointModel;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/contents/index.js
var require_contents = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/contents/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Drive = exports2.ContentsManager = exports2.Contents = void 0;
    var coreutils_12 = require_lib2();
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib3();
    var validate = __importStar2(require_validate2());
    var SERVICE_DRIVE_URL = "api/contents";
    var FILES_URL = "files";
    var Contents;
    (function(Contents2) {
      function validateContentsModel(contents) {
        validate.validateContentsModel(contents);
      }
      Contents2.validateContentsModel = validateContentsModel;
      function validateCheckpointModel(checkpoint) {
        validate.validateCheckpointModel(checkpoint);
      }
      Contents2.validateCheckpointModel = validateCheckpointModel;
    })(Contents || (exports2.Contents = Contents = {}));
    var ContentsManager = class {
      /**
       * Construct a new contents manager object.
       *
       * @param options - The options used to initialize the object.
       */
      constructor(options = {}) {
        var _a, _b;
        this._isDisposed = false;
        this._additionalDrives = /* @__PURE__ */ new Map();
        this._fileChanged = new signaling_1.Signal(this);
        const serverSettings = this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._defaultDrive = (_b = options.defaultDrive) !== null && _b !== void 0 ? _b : new Drive({ serverSettings });
        this._defaultDrive.fileChanged.connect(this._onFileChanged, this);
      }
      /**
       * A signal emitted when a file operation takes place.
       */
      get fileChanged() {
        return this._fileChanged;
      }
      /**
       * Test whether the manager has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * Add an `IDrive` to the manager.
       */
      addDrive(drive) {
        this._additionalDrives.set(drive.name, drive);
        drive.fileChanged.connect(this._onFileChanged, this);
      }
      /**
       * Given a path, get a shared model factory from the
       * relevant backend. Returns `null` if the backend
       * does not provide one.
       */
      getSharedModelFactory(path2) {
        var _a;
        const [drive] = this._driveForPath(path2);
        return (_a = drive === null || drive === void 0 ? void 0 : drive.sharedModelFactory) !== null && _a !== void 0 ? _a : null;
      }
      /**
       * Given a path of the form `drive:local/portion/of/it.txt`
       * get the local part of it.
       *
       * @param path: the path.
       *
       * @returns The local part of the path.
       */
      localPath(path2) {
        const parts = path2.split("/");
        const firstParts = parts[0].split(":");
        if (firstParts.length === 1 || !this._additionalDrives.has(firstParts[0])) {
          return coreutils_12.PathExt.removeSlash(path2);
        }
        return coreutils_12.PathExt.join(firstParts.slice(1).join(":"), ...parts.slice(1));
      }
      /**
       * Normalize a global path. Reduces '..' and '.' parts, and removes
       * leading slashes from the local part of the path, while retaining
       * the drive name if it exists.
       *
       * @param path: the path.
       *
       * @returns The normalized path.
       */
      normalize(path2) {
        const parts = path2.split(":");
        if (parts.length === 1) {
          return coreutils_12.PathExt.normalize(path2);
        }
        return `${parts[0]}:${coreutils_12.PathExt.normalize(parts.slice(1).join(":"))}`;
      }
      /**
       * Resolve a global path, starting from the root path. Behaves like
       * posix-path.resolve, with 3 differences:
       *  - will never prepend cwd
       *  - if root has a drive name, the result is prefixed with "<drive>:"
       *  - before adding drive name, leading slashes are removed
       *
       * @param path: the path.
       *
       * @returns The normalized path.
       */
      resolvePath(root, path2) {
        const driveName = this.driveName(root);
        const localPath = this.localPath(root);
        const resolved = coreutils_12.PathExt.resolve("/", localPath, path2);
        return driveName ? `${driveName}:${resolved}` : resolved;
      }
      /**
       * Given a path of the form `drive:local/portion/of/it.txt`
       * get the name of the drive. If the path is missing
       * a drive portion, returns an empty string.
       *
       * @param path: the path.
       *
       * @returns The drive name for the path, or the empty string.
       */
      driveName(path2) {
        const parts = path2.split("/");
        const firstParts = parts[0].split(":");
        if (firstParts.length === 1) {
          return "";
        }
        if (this._additionalDrives.has(firstParts[0])) {
          return firstParts[0];
        }
        return "";
      }
      /**
       * Get a file or directory.
       *
       * @param path: The path to the file.
       *
       * @param options: The options used to fetch the file.
       *
       * @returns A promise which resolves with the file content.
       */
      get(path2, options) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.get(localPath, options).then((contentsModel) => {
          const listing = [];
          if (contentsModel.type === "directory" && contentsModel.content) {
            for (const item of contentsModel.content) {
              listing.push({ ...item, path: this._toGlobalPath(drive, item.path) });
            }
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive, localPath),
              content: listing,
              serverPath: contentsModel.path
            };
          } else {
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive, localPath),
              serverPath: contentsModel.path
            };
          }
        });
      }
      /**
       * Get an encoded download url given a file path.
       *
       * @param path - An absolute POSIX file path on the server.
       *
       * #### Notes
       * It is expected that the path contains no relative paths.
       *
       * The returned URL may include a query parameter.
       */
      getDownloadUrl(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.getDownloadUrl(localPath);
      }
      /**
       * Create a new untitled file or directory in the specified directory path.
       *
       * @param options: The options used to create the file.
       *
       * @returns A promise which resolves with the created file content when the
       *    file is created.
       */
      newUntitled(options = {}) {
        if (options.path) {
          const globalPath = this.normalize(options.path);
          const [drive, localPath] = this._driveForPath(globalPath);
          return drive.newUntitled({ ...options, path: localPath }).then((contentsModel) => {
            return {
              ...contentsModel,
              path: coreutils_12.PathExt.join(globalPath, contentsModel.name),
              serverPath: contentsModel.path
            };
          });
        } else {
          return this._defaultDrive.newUntitled(options);
        }
      }
      /**
       * Delete a file.
       *
       * @param path - The path to the file.
       *
       * @returns A promise which resolves when the file is deleted.
       */
      delete(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.delete(localPath);
      }
      /**
       * Rename a file or directory.
       *
       * @param path - The original file path.
       *
       * @param newPath - The new file path.
       *
       * @returns A promise which resolves with the new file contents model when
       *   the file is renamed.
       */
      rename(path2, newPath) {
        const [drive1, path1] = this._driveForPath(path2);
        const [drive2, path22] = this._driveForPath(newPath);
        if (drive1 !== drive2) {
          throw Error("ContentsManager: renaming files must occur within a Drive");
        }
        return drive1.rename(path1, path22).then((contentsModel) => {
          return {
            ...contentsModel,
            path: this._toGlobalPath(drive1, path22),
            serverPath: contentsModel.path
          };
        });
      }
      /**
       * Save a file.
       *
       * @param path - The desired file path.
       *
       * @param options - Optional overrides to the model.
       *
       * @returns A promise which resolves with the file content model when the
       *   file is saved.
       *
       * #### Notes
       * Ensure that `model.content` is populated for the file.
       */
      save(path2, options = {}) {
        const globalPath = this.normalize(path2);
        const [drive, localPath] = this._driveForPath(path2);
        return drive.save(localPath, { ...options, path: localPath }).then((contentsModel) => {
          return {
            ...contentsModel,
            path: globalPath,
            serverPath: contentsModel.path
          };
        });
      }
      /**
       * Copy a file into a given directory.
       *
       * @param path - The original file path.
       *
       * @param toDir - The destination directory path.
       *
       * @returns A promise which resolves with the new contents model when the
       *  file is copied.
       *
       * #### Notes
       * The server will select the name of the copied file.
       */
      copy(fromFile, toDir) {
        const [drive1, path1] = this._driveForPath(fromFile);
        const [drive2, path2] = this._driveForPath(toDir);
        if (drive1 === drive2) {
          return drive1.copy(path1, path2).then((contentsModel) => {
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive1, contentsModel.path),
              serverPath: contentsModel.path
            };
          });
        } else {
          throw Error("Copying files between drives is not currently implemented");
        }
      }
      /**
       * Create a checkpoint for a file.
       *
       * @param path - The path of the file.
       *
       * @returns A promise which resolves with the new checkpoint model when the
       *   checkpoint is created.
       */
      createCheckpoint(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.createCheckpoint(localPath);
      }
      /**
       * List available checkpoints for a file.
       *
       * @param path - The path of the file.
       *
       * @returns A promise which resolves with a list of checkpoint models for
       *    the file.
       */
      listCheckpoints(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.listCheckpoints(localPath);
      }
      /**
       * Restore a file to a known checkpoint state.
       *
       * @param path - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to restore.
       *
       * @returns A promise which resolves when the checkpoint is restored.
       */
      restoreCheckpoint(path2, checkpointID) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.restoreCheckpoint(localPath, checkpointID);
      }
      /**
       * Delete a checkpoint for a file.
       *
       * @param path - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to delete.
       *
       * @returns A promise which resolves when the checkpoint is deleted.
       */
      deleteCheckpoint(path2, checkpointID) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.deleteCheckpoint(localPath, checkpointID);
      }
      /**
       * Given a drive and a local path, construct a fully qualified
       * path. The inverse of `_driveForPath`.
       *
       * @param drive: an `IDrive`.
       *
       * @param localPath: the local path on the drive.
       *
       * @returns the fully qualified path.
       */
      _toGlobalPath(drive, localPath) {
        if (drive === this._defaultDrive) {
          return coreutils_12.PathExt.removeSlash(localPath);
        } else {
          return `${drive.name}:${coreutils_12.PathExt.removeSlash(localPath)}`;
        }
      }
      /**
       * Given a path, get the `IDrive to which it refers,
       * where the path satisfies the pattern
       * `'driveName:path/to/file'`. If there is no `driveName`
       * prepended to the path, it returns the default drive.
       *
       * @param path: a path to a file.
       *
       * @returns A tuple containing an `IDrive` object for the path,
       * and a local path for that drive.
       */
      _driveForPath(path2) {
        const driveName = this.driveName(path2);
        const localPath = this.localPath(path2);
        if (driveName) {
          return [this._additionalDrives.get(driveName), localPath];
        } else {
          return [this._defaultDrive, localPath];
        }
      }
      /**
       * Respond to fileChanged signals from the drives attached to
       * the manager. This prepends the drive name to the path if necessary,
       * and then forwards the signal.
       */
      _onFileChanged(sender, args) {
        var _a, _b;
        if (sender === this._defaultDrive) {
          this._fileChanged.emit(args);
        } else {
          let newValue = null;
          let oldValue = null;
          if ((_a = args.newValue) === null || _a === void 0 ? void 0 : _a.path) {
            newValue = {
              ...args.newValue,
              path: this._toGlobalPath(sender, args.newValue.path)
            };
          }
          if ((_b = args.oldValue) === null || _b === void 0 ? void 0 : _b.path) {
            oldValue = {
              ...args.oldValue,
              path: this._toGlobalPath(sender, args.oldValue.path)
            };
          }
          this._fileChanged.emit({
            type: args.type,
            newValue,
            oldValue
          });
        }
      }
    };
    exports2.ContentsManager = ContentsManager;
    var Drive = class {
      /**
       * Construct a new contents manager object.
       *
       * @param options - The options used to initialize the object.
       */
      constructor(options = {}) {
        var _a, _b, _c;
        this._isDisposed = false;
        this._fileChanged = new signaling_1.Signal(this);
        this.name = (_a = options.name) !== null && _a !== void 0 ? _a : "Default";
        this._apiEndpoint = (_b = options.apiEndpoint) !== null && _b !== void 0 ? _b : SERVICE_DRIVE_URL;
        this.serverSettings = (_c = options.serverSettings) !== null && _c !== void 0 ? _c : __1.ServerConnection.makeSettings();
      }
      /**
       * A signal emitted when a file operation takes place.
       */
      get fileChanged() {
        return this._fileChanged;
      }
      /**
       * Test whether the manager has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * Get a file or directory.
       *
       * @param localPath: The path to the file.
       *
       * @param options: The options used to fetch the file.
       *
       * @returns A promise which resolves with the file content.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async get(localPath, options) {
        let url = this._getUrl(localPath);
        if (options) {
          if (options.type === "notebook") {
            delete options["format"];
          }
          const content = options.content ? "1" : "0";
          const hash = options.hash ? "1" : "0";
          const params = { ...options, content, hash };
          url += coreutils_12.URLExt.objectToQueryString(params);
        }
        const settings = this.serverSettings;
        const response = await __1.ServerConnection.makeRequest(url, {}, settings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        return data;
      }
      /**
       * Get an encoded download url given a file path.
       *
       * @param localPath - An absolute POSIX file path on the server.
       *
       * #### Notes
       * It is expected that the path contains no relative paths.
       *
       * The returned URL may include a query parameter.
       */
      getDownloadUrl(localPath) {
        const baseUrl = this.serverSettings.baseUrl;
        let url = coreutils_12.URLExt.join(baseUrl, FILES_URL, coreutils_12.URLExt.encodeParts(localPath));
        let cookie = "";
        try {
          cookie = document.cookie;
        } catch (e) {
        }
        const xsrfTokenMatch = cookie.match("\\b_xsrf=([^;]*)\\b");
        if (xsrfTokenMatch) {
          const fullUrl = new URL(url);
          fullUrl.searchParams.append("_xsrf", xsrfTokenMatch[1]);
          url = fullUrl.toString();
        }
        return Promise.resolve(url);
      }
      /**
       * Create a new untitled file or directory in the specified directory path.
       *
       * @param options: The options used to create the file.
       *
       * @returns A promise which resolves with the created file content when the
       *    file is created.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async newUntitled(options = {}) {
        var _a;
        let body = "{}";
        if (options) {
          if (options.ext) {
            options.ext = Private36.normalizeExtension(options.ext);
          }
          body = JSON.stringify(options);
        }
        const settings = this.serverSettings;
        const url = this._getUrl((_a = options.path) !== null && _a !== void 0 ? _a : "");
        const init = {
          method: "POST",
          body
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "new",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Delete a file.
       *
       * @param localPath - The path to the file.
       *
       * @returns A promise which resolves when the file is deleted.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async delete(localPath) {
        const url = this._getUrl(localPath);
        const settings = this.serverSettings;
        const init = { method: "DELETE" };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._fileChanged.emit({
          type: "delete",
          oldValue: { path: localPath },
          newValue: null
        });
      }
      /**
       * Rename a file or directory.
       *
       * @param oldLocalPath - The original file path.
       *
       * @param newLocalPath - The new file path.
       *
       * @returns A promise which resolves with the new file contents model when
       *   the file is renamed.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async rename(oldLocalPath, newLocalPath) {
        const settings = this.serverSettings;
        const url = this._getUrl(oldLocalPath);
        const init = {
          method: "PATCH",
          body: JSON.stringify({ path: newLocalPath })
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "rename",
          oldValue: { path: oldLocalPath },
          newValue: data
        });
        return data;
      }
      /**
       * Save a file.
       *
       * @param localPath - The desired file path.
       *
       * @param options - Optional overrides to the model.
       *
       * @returns A promise which resolves with the file content model when the
       *   file is saved.
       *
       * #### Notes
       * Ensure that `model.content` is populated for the file.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async save(localPath, options = {}) {
        const settings = this.serverSettings;
        const url = this._getUrl(localPath);
        const init = {
          method: "PUT",
          body: JSON.stringify(options)
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 200 && response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "save",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Copy a file into a given directory.
       *
       * @param localPath - The original file path.
       *
       * @param toDir - The destination directory path.
       *
       * @returns A promise which resolves with the new contents model when the
       *  file is copied.
       *
       * #### Notes
       * The server will select the name of the copied file.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async copy(fromFile, toDir) {
        const settings = this.serverSettings;
        const url = this._getUrl(toDir);
        const init = {
          method: "POST",
          body: JSON.stringify({ copy_from: fromFile })
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "new",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Create a checkpoint for a file.
       *
       * @param localPath - The path of the file.
       *
       * @returns A promise which resolves with the new checkpoint model when the
       *   checkpoint is created.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async createCheckpoint(localPath) {
        const url = this._getUrl(localPath, "checkpoints");
        const init = { method: "POST" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateCheckpointModel(data);
        return data;
      }
      /**
       * List available checkpoints for a file.
       *
       * @param localPath - The path of the file.
       *
       * @returns A promise which resolves with a list of checkpoint models for
       *    the file.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async listCheckpoints(localPath) {
        const url = this._getUrl(localPath, "checkpoints");
        const response = await __1.ServerConnection.makeRequest(url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        if (!Array.isArray(data)) {
          throw new Error("Invalid Checkpoint list");
        }
        for (let i = 0; i < data.length; i++) {
          validate.validateCheckpointModel(data[i]);
        }
        return data;
      }
      /**
       * Restore a file to a known checkpoint state.
       *
       * @param localPath - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to restore.
       *
       * @returns A promise which resolves when the checkpoint is restored.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async restoreCheckpoint(localPath, checkpointID) {
        const url = this._getUrl(localPath, "checkpoints", checkpointID);
        const init = { method: "POST" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Delete a checkpoint for a file.
       *
       * @param localPath - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to delete.
       *
       * @returns A promise which resolves when the checkpoint is deleted.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async deleteCheckpoint(localPath, checkpointID) {
        const url = this._getUrl(localPath, "checkpoints", checkpointID);
        const init = { method: "DELETE" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Get a REST url for a file given a path.
       */
      _getUrl(...args) {
        const parts = args.map((path2) => coreutils_12.URLExt.encodeParts(path2));
        const baseUrl = this.serverSettings.baseUrl;
        return coreutils_12.URLExt.join(baseUrl, this._apiEndpoint, ...parts);
      }
    };
    exports2.Drive = Drive;
    var Private36;
    (function(Private37) {
      function normalizeExtension(extension) {
        if (extension.length > 0 && extension.indexOf(".") !== 0) {
          extension = `.${extension}`;
        }
        return extension;
      }
      Private37.normalizeExtension = normalizeExtension;
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@lumino/polling/dist/index.es6.js
var index_es6_exports3 = {};
__export(index_es6_exports3, {
  Debouncer: () => Debouncer,
  Poll: () => Poll,
  RateLimiter: () => RateLimiter,
  Throttler: () => Throttler
});
var import_coreutils2, Poll, Private4, RateLimiter, Debouncer, Throttler;
var init_index_es64 = __esm({
  "../../node_modules/@lumino/polling/dist/index.es6.js"() {
    import_coreutils2 = __toESM(require_dist());
    init_index_es63();
    Poll = class {
      /**
       * Instantiate a new poll with exponential backoff in case of failure.
       *
       * @param options - The poll instantiation options.
       */
      constructor(options) {
        var _a;
        this._disposed = new Signal(this);
        this._lingered = 0;
        this._tick = new import_coreutils2.PromiseDelegate();
        this._ticked = new Signal(this);
        this._factory = options.factory;
        this._linger = (_a = options.linger) !== null && _a !== void 0 ? _a : Private4.DEFAULT_LINGER;
        this._standby = options.standby || Private4.DEFAULT_STANDBY;
        this._state = { ...Private4.DEFAULT_STATE, timestamp: (/* @__PURE__ */ new Date()).getTime() };
        const frequency = options.frequency || {};
        const max2 = Math.max(frequency.interval || 0, frequency.max || 0, Private4.DEFAULT_FREQUENCY.max);
        this.frequency = { ...Private4.DEFAULT_FREQUENCY, ...frequency, ...{ max: max2 } };
        this.name = options.name || Private4.DEFAULT_NAME;
        if ("auto" in options ? options.auto : true) {
          setTimeout(() => this.start());
        }
      }
      /**
       * A signal emitted when the poll is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * The polling frequency parameters.
       */
      get frequency() {
        return this._frequency;
      }
      set frequency(frequency) {
        if (this.isDisposed || import_coreutils2.JSONExt.deepEqual(frequency, this.frequency || {})) {
          return;
        }
        let { backoff, interval, max: max2 } = frequency;
        interval = Math.round(interval);
        max2 = Math.round(max2);
        if (typeof backoff === "number" && backoff < 1) {
          throw new Error("Poll backoff growth factor must be at least 1");
        }
        if ((interval < 0 || interval > max2) && interval !== Poll.NEVER) {
          throw new Error("Poll interval must be between 0 and max");
        }
        if (max2 > Poll.MAX_INTERVAL && max2 !== Poll.NEVER) {
          throw new Error(`Max interval must be less than ${Poll.MAX_INTERVAL}`);
        }
        this._frequency = { backoff, interval, max: max2 };
      }
      /**
       * Whether the poll is disposed.
       */
      get isDisposed() {
        return this.state.phase === "disposed";
      }
      /**
       * Indicates when the poll switches to standby.
       */
      get standby() {
        return this._standby;
      }
      set standby(standby) {
        if (this.isDisposed || this.standby === standby) {
          return;
        }
        this._standby = standby;
      }
      /**
       * The poll state, which is the content of the current poll tick.
       */
      get state() {
        return this._state;
      }
      /**
       * A promise that resolves when the poll next ticks.
       */
      get tick() {
        return this._tick.promise;
      }
      /**
       * A signal emitted when the poll ticks and fires off a new request.
       */
      get ticked() {
        return this._ticked;
      }
      /**
       * Return an async iterator that yields every tick.
       */
      async *[Symbol.asyncIterator]() {
        while (!this.isDisposed) {
          yield this.state;
          await this.tick.catch(() => void 0);
        }
      }
      /**
       * Dispose the poll.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._state = {
          ...Private4.DISPOSED_STATE,
          timestamp: (/* @__PURE__ */ new Date()).getTime()
        };
        this._tick.promise.catch((_) => void 0);
        this._tick.reject(new Error(`Poll (${this.name}) is disposed.`));
        this._disposed.emit(void 0);
        Signal.clearData(this);
      }
      /**
       * Refreshes the poll. Schedules `refreshed` tick if necessary.
       *
       * @returns A promise that resolves after tick is scheduled and never rejects.
       *
       * #### Notes
       * The returned promise resolves after the tick is scheduled, but before
       * the polling action is run. To wait until after the poll action executes,
       * await the `poll.tick` promise: `await poll.refresh(); await poll.tick;`
       */
      refresh() {
        return this.schedule({
          cancel: ({ phase }) => phase === "refreshed",
          interval: Poll.IMMEDIATE,
          phase: "refreshed"
        });
      }
      /**
       * Schedule the next poll tick.
       *
       * @param next - The next poll state data to schedule. Defaults to standby.
       *
       * @param next.cancel - Cancels state transition if function returns `true`.
       *
       * @returns A promise that resolves when the next poll state is active.
       *
       * #### Notes
       * This method is not meant to be invoked by user code typically. It is public
       * to allow poll instances to be composed into classes that schedule ticks.
       */
      async schedule(next = {}) {
        if (this.isDisposed) {
          return;
        }
        if (next.cancel && next.cancel(this.state)) {
          return;
        }
        const pending = this._tick;
        const scheduled = new import_coreutils2.PromiseDelegate();
        const state = {
          interval: this.frequency.interval,
          payload: null,
          phase: "standby",
          timestamp: (/* @__PURE__ */ new Date()).getTime(),
          ...next
        };
        this._state = state;
        this._tick = scheduled;
        clearTimeout(this._timeout);
        this._ticked.emit(this.state);
        pending.resolve(this);
        await pending.promise;
        if (state.interval === Poll.NEVER) {
          this._timeout = void 0;
          return;
        }
        const execute = () => {
          if (this.isDisposed || this.tick !== scheduled.promise) {
            return;
          }
          this._execute();
        };
        this._timeout = setTimeout(execute, state.interval);
      }
      /**
       * Starts the poll. Schedules `started` tick if necessary.
       *
       * @returns A promise that resolves after tick is scheduled and never rejects.
       */
      start() {
        return this.schedule({
          cancel: ({ phase }) => phase !== "constructed" && phase !== "standby" && phase !== "stopped",
          interval: Poll.IMMEDIATE,
          phase: "started"
        });
      }
      /**
       * Stops the poll. Schedules `stopped` tick if necessary.
       *
       * @returns A promise that resolves after tick is scheduled and never rejects.
       */
      stop() {
        return this.schedule({
          cancel: ({ phase }) => phase === "stopped",
          interval: Poll.NEVER,
          phase: "stopped"
        });
      }
      /**
       * Whether the poll is hidden.
       *
       * #### Notes
       * This property is only relevant in a browser context.
       */
      get hidden() {
        return Private4.hidden;
      }
      /**
       * Execute a new poll factory promise or stand by if necessary.
       */
      _execute() {
        let standby = typeof this.standby === "function" ? this.standby() : this.standby;
        if (standby === "never") {
          standby = false;
        } else if (standby === "when-hidden") {
          if (this.hidden) {
            standby = ++this._lingered > this._linger;
          } else {
            this._lingered = 0;
            standby = false;
          }
        }
        if (standby) {
          void this.schedule();
          return;
        }
        const pending = this.tick;
        this._factory(this.state).then((resolved) => {
          if (this.isDisposed || this.tick !== pending) {
            return;
          }
          void this.schedule({
            payload: resolved,
            phase: this.state.phase === "rejected" ? "reconnected" : "resolved"
          });
        }).catch((rejected) => {
          if (this.isDisposed || this.tick !== pending) {
            return;
          }
          void this.schedule({
            interval: Private4.sleep(this.frequency, this.state),
            payload: rejected,
            phase: "rejected"
          });
        });
      }
    };
    (function(Poll2) {
      Poll2.IMMEDIATE = 0;
      Poll2.MAX_INTERVAL = 2147483647;
      Poll2.NEVER = Infinity;
    })(Poll || (Poll = {}));
    (function(Private36) {
      Private36.DEFAULT_BACKOFF = 3;
      Private36.DEFAULT_FREQUENCY = {
        backoff: true,
        interval: 1e3,
        max: 30 * 1e3
      };
      Private36.DEFAULT_LINGER = 1;
      Private36.DEFAULT_NAME = "unknown";
      Private36.DEFAULT_STANDBY = "when-hidden";
      Private36.DEFAULT_STATE = {
        interval: Poll.NEVER,
        payload: null,
        phase: "constructed",
        timestamp: (/* @__PURE__ */ new Date(0)).getTime()
      };
      Private36.DISPOSED_STATE = {
        interval: Poll.NEVER,
        payload: null,
        phase: "disposed",
        timestamp: (/* @__PURE__ */ new Date(0)).getTime()
      };
      function sleep(frequency, last) {
        const { backoff, interval, max: max2 } = frequency;
        if (interval === Poll.NEVER) {
          return interval;
        }
        const growth = backoff === true ? Private36.DEFAULT_BACKOFF : backoff === false ? 1 : backoff;
        const random = getRandomIntInclusive(interval, last.interval * growth);
        return Math.min(max2, random);
      }
      Private36.sleep = sleep;
      Private36.hidden = (() => {
        if (typeof document === "undefined") {
          return false;
        }
        document.addEventListener("visibilitychange", () => {
          Private36.hidden = document.visibilityState === "hidden";
        });
        document.addEventListener("pagehide", () => {
          Private36.hidden = document.visibilityState === "hidden";
        });
        return document.visibilityState === "hidden";
      })();
      function getRandomIntInclusive(min, max2) {
        min = Math.ceil(min);
        max2 = Math.floor(max2);
        return Math.floor(Math.random() * (max2 - min + 1)) + min;
      }
    })(Private4 || (Private4 = {}));
    RateLimiter = class {
      /**
       * Instantiate a rate limiter.
       *
       * @param fn - The function to rate limit.
       *
       * @param limit - The rate limit; defaults to 500ms.
       */
      constructor(fn, limit2 = 500) {
        this.args = void 0;
        this.payload = null;
        this.limit = limit2;
        this.poll = new Poll({
          auto: false,
          factory: async () => {
            const { args } = this;
            this.args = void 0;
            return fn(...args);
          },
          frequency: { backoff: false, interval: Poll.NEVER, max: Poll.NEVER },
          standby: "never"
        });
        this.payload = new import_coreutils2.PromiseDelegate();
        this.poll.ticked.connect((_, state) => {
          const { payload } = this;
          if (state.phase === "resolved") {
            this.payload = new import_coreutils2.PromiseDelegate();
            payload.resolve(state.payload);
            return;
          }
          if (state.phase === "rejected" || state.phase === "stopped") {
            this.payload = new import_coreutils2.PromiseDelegate();
            payload.promise.catch((_2) => void 0);
            payload.reject(state.payload);
            return;
          }
        }, this);
      }
      /**
       * Whether the rate limiter is disposed.
       */
      get isDisposed() {
        return this.payload === null;
      }
      /**
       * Disposes the rate limiter.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this.args = void 0;
        this.payload = null;
        this.poll.dispose();
      }
      /**
       * Stop the function if it is mid-flight.
       */
      async stop() {
        return this.poll.stop();
      }
    };
    Debouncer = class extends RateLimiter {
      /**
       * Invokes the function and only executes after rate limit has elapsed.
       * Each invocation resets the timer.
       */
      invoke(...args) {
        this.args = args;
        void this.poll.schedule({ interval: this.limit, phase: "invoked" });
        return this.payload.promise;
      }
    };
    Throttler = class extends RateLimiter {
      /**
       * Instantiate a throttler.
       *
       * @param fn - The function being throttled.
       *
       * @param options - Throttling configuration or throttling limit in ms.
       *
       * #### Notes
       * The `edge` defaults to `leading`; the `limit` defaults to `500`.
       */
      constructor(fn, options) {
        super(fn, typeof options === "number" ? options : options && options.limit);
        this._trailing = false;
        if (typeof options !== "number" && options && options.edge === "trailing") {
          this._trailing = true;
        }
        this._interval = this._trailing ? this.limit : Poll.IMMEDIATE;
      }
      /**
       * Throttles function invocations if one is currently in flight.
       */
      invoke(...args) {
        const idle = this.poll.state.phase !== "invoked";
        if (idle || this._trailing) {
          this.args = args;
        }
        if (idle) {
          void this.poll.schedule({ interval: this._interval, phase: "invoked" });
        }
        return this.payload.promise;
      }
    };
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/event/index.js
var require_event = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/event/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventManager = void 0;
    var coreutils_12 = require_lib2();
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var serverconnection_1 = require_serverconnection();
    var SERVICE_EVENTS_URL = "api/events";
    var EventManager = class {
      /**
       * Create a new event manager.
       */
      constructor(options = {}) {
        var _a;
        this._socket = null;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        this._poll = new polling_1.Poll({ factory: () => this._subscribe() });
        this._stream = new signaling_1.Stream(this);
        void this._poll.start();
      }
      /**
       * Whether the event manager is disposed.
       */
      get isDisposed() {
        return this._poll.isDisposed;
      }
      /**
       * An event stream that emits and yields each new event.
       */
      get stream() {
        return this._stream;
      }
      /**
       * Dispose the event manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._poll.dispose();
        const socket = this._socket;
        if (socket) {
          this._socket = null;
          socket.onopen = () => void 0;
          socket.onerror = () => void 0;
          socket.onmessage = () => void 0;
          socket.onclose = () => void 0;
          socket.close();
        }
        signaling_1.Signal.clearData(this);
        this._stream.stop();
      }
      /**
       * Post an event request to be emitted by the event bus.
       */
      async emit(event) {
        const { serverSettings } = this;
        const { baseUrl, token } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const url = coreutils_12.URLExt.join(baseUrl, SERVICE_EVENTS_URL) + (token ? `?token=${token}` : "");
        const init = { body: JSON.stringify(event), method: "POST" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          throw new ResponseError(response);
        }
      }
      /**
       * Subscribe to event bus emissions.
       */
      _subscribe() {
        return new Promise((_, reject) => {
          if (this.isDisposed) {
            return;
          }
          const { token, WebSocket: WebSocket2, wsUrl } = this.serverSettings;
          const url = coreutils_12.URLExt.join(wsUrl, SERVICE_EVENTS_URL, "subscribe") + (token ? `?token=${encodeURIComponent(token)}` : "");
          const socket = this._socket = new WebSocket2(url);
          const stream = this._stream;
          socket.onclose = () => reject(new Error("EventManager socket closed"));
          socket.onmessage = (msg) => msg.data && stream.emit(JSON.parse(msg.data));
        });
      }
    };
    exports2.EventManager = EventManager;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/kernel.js
var require_kernel = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/kernel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/validate.js
var require_validate3 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateModels = exports2.validateModel = exports2.validateMessage = void 0;
    var validate_1 = require_validate();
    var HEADER_FIELDS = ["username", "version", "session", "msg_id", "msg_type"];
    var IOPUB_CONTENT_FIELDS = {
      stream: { name: "string", text: "string" },
      display_data: { data: "object", metadata: "object" },
      execute_input: { code: "string", execution_count: "number" },
      execute_result: {
        execution_count: "number",
        data: "object",
        metadata: "object"
      },
      error: { ename: "string", evalue: "string", traceback: "object" },
      status: {
        execution_state: [
          "string",
          ["starting", "idle", "busy", "restarting", "dead"]
        ]
      },
      clear_output: { wait: "boolean" },
      comm_open: { comm_id: "string", target_name: "string", data: "object" },
      comm_msg: { comm_id: "string", data: "object" },
      comm_close: { comm_id: "string" },
      shutdown_reply: { restart: "boolean" }
      // Emitted by the IPython kernel.
    };
    function validateHeader(header) {
      for (let i = 0; i < HEADER_FIELDS.length; i++) {
        (0, validate_1.validateProperty)(header, HEADER_FIELDS[i], "string");
      }
    }
    function validateMessage(msg) {
      (0, validate_1.validateProperty)(msg, "metadata", "object");
      (0, validate_1.validateProperty)(msg, "content", "object");
      (0, validate_1.validateProperty)(msg, "channel", "string");
      validateHeader(msg.header);
      if (msg.channel === "iopub") {
        validateIOPubContent(msg);
      }
    }
    exports2.validateMessage = validateMessage;
    function validateIOPubContent(msg) {
      if (msg.channel === "iopub") {
        const fields = IOPUB_CONTENT_FIELDS[msg.header.msg_type];
        if (fields === void 0) {
          return;
        }
        const names = Object.keys(fields);
        const content = msg.content;
        for (let i = 0; i < names.length; i++) {
          let args = fields[names[i]];
          if (!Array.isArray(args)) {
            args = [args];
          }
          (0, validate_1.validateProperty)(content, names[i], ...args);
        }
      }
    }
    function validateModel(model) {
      (0, validate_1.validateProperty)(model, "name", "string");
      (0, validate_1.validateProperty)(model, "id", "string");
    }
    exports2.validateModel = validateModel;
    function validateModels(models) {
      if (!Array.isArray(models)) {
        throw new Error("Invalid kernel list");
      }
      models.forEach((d) => validateModel(d));
    }
    exports2.validateModels = validateModels;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/restapi.js
var require_restapi = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKernelModel = exports2.shutdownKernel = exports2.interruptKernel = exports2.restartKernel = exports2.startNew = exports2.listRunning = exports2.KERNEL_SERVICE_URL = void 0;
    var serverconnection_1 = require_serverconnection();
    var coreutils_12 = require_lib2();
    var validate_1 = require_validate3();
    exports2.KERNEL_SERVICE_URL = "api/kernels";
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModels)(data);
      return data;
    }
    exports2.listRunning = listRunning;
    async function startNew(options = {}, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify(options)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 201) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.startNew = startNew;
    async function restartKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id), "restart");
      const init = { method: "POST" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
    }
    exports2.restartKernel = restartKernel;
    async function interruptKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id), "interrupt");
      const init = { method: "POST" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.interruptKernel = interruptKernel;
    async function shutdownKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id));
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const msg = `The kernel "${id}" does not exist on the server`;
        console.warn(msg);
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownKernel = shutdownKernel;
    async function getKernelModel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id));
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status === 404) {
        return void 0;
      } else if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.getKernelModel = getKernelModel;
  }
});

// ../../node_modules/@lumino/disposable/dist/index.es6.js
var index_es6_exports4 = {};
__export(index_es6_exports4, {
  DisposableDelegate: () => DisposableDelegate,
  DisposableSet: () => DisposableSet,
  ObservableDisposableDelegate: () => ObservableDisposableDelegate,
  ObservableDisposableSet: () => ObservableDisposableSet
});
var DisposableDelegate, ObservableDisposableDelegate, DisposableSet, ObservableDisposableSet;
var init_index_es65 = __esm({
  "../../node_modules/@lumino/disposable/dist/index.es6.js"() {
    init_index_es63();
    DisposableDelegate = class {
      /**
       * Construct a new disposable delegate.
       *
       * @param fn - The callback function to invoke on dispose.
       */
      constructor(fn) {
        this._fn = fn;
      }
      /**
       * Test whether the delegate has been disposed.
       */
      get isDisposed() {
        return !this._fn;
      }
      /**
       * Dispose of the delegate and invoke the callback function.
       */
      dispose() {
        if (!this._fn) {
          return;
        }
        let fn = this._fn;
        this._fn = null;
        fn();
      }
    };
    ObservableDisposableDelegate = class extends DisposableDelegate {
      constructor() {
        super(...arguments);
        this._disposed = new Signal(this);
      }
      /**
       * A signal emitted when the delegate is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Dispose of the delegate and invoke the callback function.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._disposed.emit(void 0);
        Signal.clearData(this);
      }
    };
    DisposableSet = class {
      constructor() {
        this._isDisposed = false;
        this._items = /* @__PURE__ */ new Set();
      }
      /**
       * Test whether the set has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the set and the items it contains.
       *
       * #### Notes
       * Items are disposed in the order they are added to the set.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._items.forEach((item) => {
          item.dispose();
        });
        this._items.clear();
      }
      /**
       * Test whether the set contains a specific item.
       *
       * @param item - The item of interest.
       *
       * @returns `true` if the set contains the item, `false` otherwise.
       */
      contains(item) {
        return this._items.has(item);
      }
      /**
       * Add a disposable item to the set.
       *
       * @param item - The item to add to the set.
       *
       * #### Notes
       * If the item is already contained in the set, this is a no-op.
       */
      add(item) {
        this._items.add(item);
      }
      /**
       * Remove a disposable item from the set.
       *
       * @param item - The item to remove from the set.
       *
       * #### Notes
       * If the item is not contained in the set, this is a no-op.
       */
      remove(item) {
        this._items.delete(item);
      }
      /**
       * Remove all items from the set.
       */
      clear() {
        this._items.clear();
      }
    };
    (function(DisposableSet2) {
      function from2(items) {
        let set7 = new DisposableSet2();
        for (const item of items) {
          set7.add(item);
        }
        return set7;
      }
      DisposableSet2.from = from2;
    })(DisposableSet || (DisposableSet = {}));
    ObservableDisposableSet = class extends DisposableSet {
      constructor() {
        super(...arguments);
        this._disposed = new Signal(this);
      }
      /**
       * A signal emitted when the set is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Dispose of the set and the items it contains.
       *
       * #### Notes
       * Items are disposed in the order they are added to the set.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._disposed.emit(void 0);
        Signal.clearData(this);
      }
    };
    (function(ObservableDisposableSet2) {
      function from2(items) {
        let set7 = new ObservableDisposableSet2();
        for (const item of items) {
          set7.add(item);
        }
        return set7;
      }
      ObservableDisposableSet2.from = from2;
    })(ObservableDisposableSet || (ObservableDisposableSet = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/comm.js
var require_comm = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/comm.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommHandler = void 0;
    var disposable_1 = (init_index_es65(), __toCommonJS(index_es6_exports4));
    var KernelMessage = __importStar2(require_messages());
    var CommHandler = class extends disposable_1.DisposableDelegate {
      /**
       * Construct a new comm channel.
       */
      constructor(target2, id, kernel, disposeCb) {
        super(disposeCb);
        this._target = "";
        this._id = "";
        this._id = id;
        this._target = target2;
        this._kernel = kernel;
      }
      /**
       * The unique id for the comm channel.
       */
      get commId() {
        return this._id;
      }
      /**
       * The target name for the comm channel.
       */
      get targetName() {
        return this._target;
      }
      /**
       * Get the callback for a comm close event.
       *
       * #### Notes
       * This is called when the comm is closed from either the server or client.
       *
       * **See also:** [[ICommClose]], [[close]]
       */
      get onClose() {
        return this._onClose;
      }
      /**
       * Set the callback for a comm close event.
       *
       * #### Notes
       * This is called when the comm is closed from either the server or client. If
       * the function returns a promise, and the kernel was closed from the server,
       * kernel message processing will pause until the returned promise is
       * fulfilled.
       *
       * **See also:** [[close]]
       */
      set onClose(cb) {
        this._onClose = cb;
      }
      /**
       * Get the callback for a comm message received event.
       */
      get onMsg() {
        return this._onMsg;
      }
      /**
       * Set the callback for a comm message received event.
       *
       * #### Notes
       * This is called when a comm message is received. If the function returns a
       * promise, kernel message processing will pause until it is fulfilled.
       */
      set onMsg(cb) {
        this._onMsg = cb;
      }
      /**
       * Open a comm with optional data and metadata.
       *
       * #### Notes
       * This sends a `comm_open` message to the server.
       *
       * **See also:** [[ICommOpen]]
       */
      open(data, metadata, buffers = []) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot open");
        }
        const msg = KernelMessage.createMessage({
          msgType: "comm_open",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            target_name: this._target,
            data: data !== null && data !== void 0 ? data : {}
          },
          metadata,
          buffers
        });
        return this._kernel.sendShellMessage(msg, false, true);
      }
      /**
       * Send a `comm_msg` message to the kernel.
       *
       * #### Notes
       * This is a no-op if the comm has been closed.
       *
       * **See also:** [[ICommMsg]]
       */
      send(data, metadata, buffers = [], disposeOnDone = true) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot send");
        }
        const msg = KernelMessage.createMessage({
          msgType: "comm_msg",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            data
          },
          metadata,
          buffers
        });
        return this._kernel.sendShellMessage(msg, false, disposeOnDone);
      }
      /**
       * Close the comm.
       *
       * #### Notes
       * This will send a `comm_close` message to the kernel, and call the
       * `onClose` callback if set.
       *
       * This is a no-op if the comm is already closed.
       *
       * **See also:** [[ICommClose]], [[onClose]]
       */
      close(data, metadata, buffers = []) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot close");
        }
        const msg = KernelMessage.createMessage({
          msgType: "comm_close",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            data: data !== null && data !== void 0 ? data : {}
          },
          metadata,
          buffers
        });
        const future = this._kernel.sendShellMessage(msg, false, true);
        const onClose = this._onClose;
        if (onClose) {
          const ioMsg = KernelMessage.createMessage({
            msgType: "comm_close",
            channel: "iopub",
            username: this._kernel.username,
            session: this._kernel.clientId,
            content: {
              comm_id: this._id,
              data: data !== null && data !== void 0 ? data : {}
            },
            metadata,
            buffers
          });
          void onClose(ioMsg);
        }
        this.dispose();
        return future;
      }
    };
    exports2.CommHandler = CommHandler;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/future.js
var require_future = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/future.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelShellFutureHandler = exports2.KernelControlFutureHandler = exports2.KernelFutureHandler = void 0;
    var coreutils_12 = require_dist();
    var disposable_1 = (init_index_es65(), __toCommonJS(index_es6_exports4));
    var KernelMessage = __importStar2(require_messages());
    var KernelFutureHandler = class extends disposable_1.DisposableDelegate {
      /**
       * Construct a new KernelFutureHandler.
       */
      constructor(cb, msg, expectReply, disposeOnDone, kernel) {
        super(cb);
        this._status = 0;
        this._stdin = Private36.noOp;
        this._iopub = Private36.noOp;
        this._reply = Private36.noOp;
        this._done = new coreutils_12.PromiseDelegate();
        this._hooks = new Private36.HookList();
        this._disposeOnDone = true;
        this._msg = msg;
        if (!expectReply) {
          this._setFlag(Private36.KernelFutureFlag.GotReply);
        }
        this._disposeOnDone = disposeOnDone;
        this._kernel = kernel;
      }
      /**
       * Get the original outgoing message.
       */
      get msg() {
        return this._msg;
      }
      /**
       * A promise that resolves when the future is done.
       */
      get done() {
        return this._done.promise;
      }
      /**
       * Get the reply handler.
       */
      get onReply() {
        return this._reply;
      }
      /**
       * Set the reply handler.
       */
      set onReply(cb) {
        this._reply = cb;
      }
      /**
       * Get the iopub handler.
       */
      get onIOPub() {
        return this._iopub;
      }
      /**
       * Set the iopub handler.
       */
      set onIOPub(cb) {
        this._iopub = cb;
      }
      /**
       * Get the stdin handler.
       */
      get onStdin() {
        return this._stdin;
      }
      /**
       * Set the stdin handler.
       */
      set onStdin(cb) {
        this._stdin = cb;
      }
      /**
       * Register hook for IOPub messages.
       *
       * @param hook - The callback invoked for an IOPub message.
       *
       * #### Notes
       * The IOPub hook system allows you to preempt the handlers for IOPub
       * messages handled by the future.
       *
       * The most recently registered hook is run first. A hook can return a
       * boolean or a promise to a boolean, in which case all kernel message
       * processing pauses until the promise is fulfilled. If a hook return value
       * resolves to false, any later hooks will not run and the function will
       * return a promise resolving to false. If a hook throws an error, the error
       * is logged to the console and the next hook is run. If a hook is
       * registered during the hook processing, it will not run until the next
       * message. If a hook is removed during the hook processing, it will be
       * deactivated immediately.
       */
      registerMessageHook(hook) {
        if (this.isDisposed) {
          throw new Error("Kernel future is disposed");
        }
        this._hooks.add(hook);
      }
      /**
       * Remove a hook for IOPub messages.
       *
       * @param hook - The hook to remove.
       *
       * #### Notes
       * If a hook is removed during the hook processing, it will be deactivated immediately.
       */
      removeMessageHook(hook) {
        if (this.isDisposed) {
          return;
        }
        this._hooks.remove(hook);
      }
      /**
       * Send an `input_reply` message.
       */
      sendInputReply(content, parent_header) {
        this._kernel.sendInputReply(content, parent_header);
      }
      /**
       * Dispose and unregister the future.
       */
      dispose() {
        this._stdin = Private36.noOp;
        this._iopub = Private36.noOp;
        this._reply = Private36.noOp;
        this._hooks = null;
        if (!this._testFlag(Private36.KernelFutureFlag.IsDone)) {
          this._done.promise.catch(() => {
          });
          this._done.reject(new Error(`Canceled future for ${this.msg.header.msg_type} message before replies were done`));
        }
        super.dispose();
      }
      /**
       * Handle an incoming kernel message.
       */
      async handleMsg(msg) {
        switch (msg.channel) {
          case "control":
          case "shell":
            if (msg.channel === this.msg.channel && msg.parent_header.msg_id === this.msg.header.msg_id) {
              await this._handleReply(msg);
            }
            break;
          case "stdin":
            await this._handleStdin(msg);
            break;
          case "iopub":
            await this._handleIOPub(msg);
            break;
          default:
            break;
        }
      }
      async _handleReply(msg) {
        const reply = this._reply;
        if (reply) {
          await reply(msg);
        }
        this._replyMsg = msg;
        this._setFlag(Private36.KernelFutureFlag.GotReply);
        if (this._testFlag(Private36.KernelFutureFlag.GotIdle)) {
          this._handleDone();
        }
      }
      async _handleStdin(msg) {
        this._kernel.hasPendingInput = true;
        const stdin = this._stdin;
        if (stdin) {
          await stdin(msg);
        }
      }
      async _handleIOPub(msg) {
        const process2 = await this._hooks.process(msg);
        const iopub = this._iopub;
        if (process2 && iopub) {
          await iopub(msg);
        }
        if (KernelMessage.isStatusMsg(msg) && msg.content.execution_state === "idle") {
          this._setFlag(Private36.KernelFutureFlag.GotIdle);
          if (this._testFlag(Private36.KernelFutureFlag.GotReply)) {
            this._handleDone();
          }
        }
      }
      _handleDone() {
        if (this._testFlag(Private36.KernelFutureFlag.IsDone)) {
          return;
        }
        this._setFlag(Private36.KernelFutureFlag.IsDone);
        this._done.resolve(this._replyMsg);
        if (this._disposeOnDone) {
          this.dispose();
        }
      }
      /**
       * Test whether the given future flag is set.
       */
      _testFlag(flag) {
        return (this._status & flag) !== 0;
      }
      /**
       * Set the given future flag.
       */
      _setFlag(flag) {
        this._status |= flag;
      }
    };
    exports2.KernelFutureHandler = KernelFutureHandler;
    var KernelControlFutureHandler = class extends KernelFutureHandler {
    };
    exports2.KernelControlFutureHandler = KernelControlFutureHandler;
    var KernelShellFutureHandler = class extends KernelFutureHandler {
    };
    exports2.KernelShellFutureHandler = KernelShellFutureHandler;
    var Private36;
    (function(Private37) {
      Private37.noOp = () => {
      };
      const defer = (() => {
        const ok = typeof requestAnimationFrame === "function";
        return ok ? requestAnimationFrame : setImmediate;
      })();
      class HookList {
        constructor() {
          this._hooks = [];
        }
        /**
         * Register a hook.
         *
         * @param hook - The callback to register.
         */
        add(hook) {
          this.remove(hook);
          this._hooks.push(hook);
        }
        /**
         * Remove a hook, if it exists in the hook list.
         *
         * @param hook - The callback to remove.
         */
        remove(hook) {
          const index = this._hooks.indexOf(hook);
          if (index >= 0) {
            this._hooks[index] = null;
            this._scheduleCompact();
          }
        }
        /**
         * Process a message through the hooks.
         *
         * @returns a promise resolving to false if any hook resolved as false,
         * otherwise true
         *
         * #### Notes
         * The most recently registered hook is run first. A hook can return a
         * boolean or a promise to a boolean, in which case processing pauses until
         * the promise is fulfilled. If a hook return value resolves to false, any
         * later hooks will not run and the function will return a promise resolving
         * to false. If a hook throws an error, the error is logged to the console
         * and the next hook is run. If a hook is registered during the hook
         * processing, it will not run until the next message. If a hook is removed
         * during the hook processing, it will be deactivated immediately.
         */
        async process(msg) {
          await this._processing;
          const processing = new coreutils_12.PromiseDelegate();
          this._processing = processing.promise;
          let continueHandling;
          for (let i = this._hooks.length - 1; i >= 0; i--) {
            const hook = this._hooks[i];
            if (hook === null) {
              continue;
            }
            try {
              continueHandling = await hook(msg);
            } catch (err) {
              continueHandling = true;
              console.error(err);
            }
            if (continueHandling === false) {
              processing.resolve(void 0);
              return false;
            }
          }
          processing.resolve(void 0);
          return true;
        }
        /**
         * Schedule a cleanup of the list, removing any hooks that have been nulled out.
         */
        _scheduleCompact() {
          if (!this._compactScheduled) {
            this._compactScheduled = true;
            defer(() => {
              this._processing = this._processing.then(() => {
                this._compactScheduled = false;
                this._compact();
              });
            });
          }
        }
        /**
         * Compact the list, removing any nulls.
         */
        _compact() {
          let numNulls = 0;
          for (let i = 0, len = this._hooks.length; i < len; i++) {
            const hook = this._hooks[i];
            if (this._hooks[i] === null) {
              numNulls++;
            } else {
              this._hooks[i - numNulls] = hook;
            }
          }
          this._hooks.length -= numNulls;
        }
      }
      Private37.HookList = HookList;
      let KernelFutureFlag;
      (function(KernelFutureFlag2) {
        KernelFutureFlag2[KernelFutureFlag2["GotReply"] = 1] = "GotReply";
        KernelFutureFlag2[KernelFutureFlag2["GotIdle"] = 2] = "GotIdle";
        KernelFutureFlag2[KernelFutureFlag2["IsDone"] = 4] = "IsDone";
        KernelFutureFlag2[KernelFutureFlag2["DisposeOnDone"] = 8] = "DisposeOnDone";
      })(KernelFutureFlag = Private37.KernelFutureFlag || (Private37.KernelFutureFlag = {}));
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernelspec/kernelspec.js
var require_kernelspec = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernelspec/kernelspec.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernelspec/validate.js
var require_validate4 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernelspec/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSpecModels = exports2.validateSpecModel = void 0;
    var validate_1 = require_validate();
    function validateSpecModel(data) {
      const spec = data.spec;
      if (!spec) {
        throw new Error("Invalid kernel spec");
      }
      (0, validate_1.validateProperty)(data, "name", "string");
      (0, validate_1.validateProperty)(data, "resources", "object");
      (0, validate_1.validateProperty)(spec, "language", "string");
      (0, validate_1.validateProperty)(spec, "display_name", "string");
      (0, validate_1.validateProperty)(spec, "argv", "array");
      let metadata = null;
      if (spec.hasOwnProperty("metadata")) {
        (0, validate_1.validateProperty)(spec, "metadata", "object");
        metadata = spec.metadata;
      }
      let env = null;
      if (spec.hasOwnProperty("env")) {
        (0, validate_1.validateProperty)(spec, "env", "object");
        env = spec.env;
      }
      return {
        name: data.name,
        resources: data.resources,
        language: spec.language,
        display_name: spec.display_name,
        argv: spec.argv,
        metadata,
        env
      };
    }
    exports2.validateSpecModel = validateSpecModel;
    function validateSpecModels(data) {
      if (!data.hasOwnProperty("kernelspecs")) {
        throw new Error("No kernelspecs found");
      }
      let keys = Object.keys(data.kernelspecs);
      const kernelspecs = /* @__PURE__ */ Object.create(null);
      let defaultSpec = data.default;
      for (let i = 0; i < keys.length; i++) {
        const ks = data.kernelspecs[keys[i]];
        try {
          kernelspecs[keys[i]] = validateSpecModel(ks);
        } catch (err) {
          console.warn(`Removing errant kernel spec: ${keys[i]}`);
        }
      }
      keys = Object.keys(kernelspecs);
      if (!keys.length) {
        throw new Error("No valid kernelspecs found");
      }
      if (!defaultSpec || typeof defaultSpec !== "string" || !(defaultSpec in kernelspecs)) {
        defaultSpec = keys[0];
        console.warn(`Default kernel not found, using '${keys[0]}'`);
      }
      return {
        default: defaultSpec,
        kernelspecs
      };
    }
    exports2.validateSpecModels = validateSpecModels;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernelspec/restapi.js
var require_restapi2 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernelspec/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSpecs = void 0;
    var serverconnection_1 = require_serverconnection();
    var validate_1 = require_validate4();
    var coreutils_12 = require_lib2();
    var KERNELSPEC_SERVICE_URL = "api/kernelspecs";
    async function getSpecs(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, KERNELSPEC_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      return (0, validate_1.validateSpecModels)(data);
    }
    exports2.getSpecs = getSpecs;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernelspec/manager.js
var require_manager = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernelspec/manager.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelSpecManager = void 0;
    var coreutils_12 = require_dist();
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var restapi = __importStar2(require_restapi2());
    var basemanager_1 = require_basemanager();
    var KernelSpecManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new kernel spec manager.
       *
       * @param options - The default options for kernel.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._connectionFailure = new signaling_1.Signal(this);
        this._specs = null;
        this._specsChanged = new signaling_1.Signal(this);
        this._ready = Promise.all([this.requestSpecs()]).then((_) => void 0).catch((_) => void 0).then(() => {
          if (this.isDisposed) {
            return;
          }
          this._isReady = true;
        });
        this._pollSpecs = new polling_1.Poll({
          auto: false,
          factory: () => this.requestSpecs(),
          frequency: {
            interval: 61 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:KernelSpecManager#specs`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        void this.ready.then(() => {
          void this._pollSpecs.start();
        });
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * Get the most recently fetched kernel specs.
       */
      get specs() {
        return this._specs;
      }
      /**
       * A signal emitted when the specs change.
       */
      get specsChanged() {
        return this._specsChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        this._pollSpecs.dispose();
        super.dispose();
      }
      /**
       * Force a refresh of the specs from the server.
       *
       * @returns A promise that resolves when the specs are fetched.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshSpecs() {
        await this._pollSpecs.refresh();
        await this._pollSpecs.tick;
      }
      /**
       * Execute a request to the server to poll specs and update state.
       */
      async requestSpecs() {
        const specs = await restapi.getSpecs(this.serverSettings);
        if (this.isDisposed) {
          return;
        }
        if (!coreutils_12.JSONExt.deepEqual(specs, this._specs)) {
          this._specs = specs;
          this._specsChanged.emit(specs);
        }
      }
    };
    exports2.KernelSpecManager = KernelSpecManager;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernelspec/index.js
var require_kernelspec2 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernelspec/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelSpecAPI = exports2.KernelSpec = void 0;
    var KernelSpec = __importStar2(require_kernelspec());
    exports2.KernelSpec = KernelSpec;
    var KernelSpecAPI = __importStar2(require_restapi2());
    exports2.KernelSpecAPI = KernelSpecAPI;
    __exportStar2(require_manager(), exports2);
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/default.js
var require_default = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/default.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelConnection = void 0;
    var coreutils_12 = require_lib2();
    var coreutils_2 = require_dist();
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib3();
    var comm_1 = require_comm();
    var KernelMessage = __importStar2(require_messages());
    var future_1 = require_future();
    var validate = __importStar2(require_validate3());
    var kernelspec_1 = require_kernelspec2();
    var restapi = __importStar2(require_restapi());
    var KERNEL_INFO_TIMEOUT = 3e3;
    var RESTARTING_KERNEL_SESSION = "_RESTARTING_";
    var STARTING_KERNEL_SESSION = "";
    var KernelConnection = class {
      /**
       * Construct a kernel object.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        this._createSocket = (useProtocols = true) => {
          this._errorIfDisposed();
          this._clearSocket();
          this._updateConnectionStatus("connecting");
          const settings = this.serverSettings;
          const partialUrl = coreutils_12.URLExt.join(settings.wsUrl, restapi.KERNEL_SERVICE_URL, encodeURIComponent(this._id));
          const display2 = partialUrl.replace(/^((?:\w+:)?\/\/)(?:[^@\/]+@)/, "$1");
          console.debug(`Starting WebSocket: ${display2}`);
          let url = coreutils_12.URLExt.join(partialUrl, "channels?session_id=" + encodeURIComponent(this._clientId));
          const token = settings.token;
          if (settings.appendToken && token !== "") {
            url = url + `&token=${encodeURIComponent(token)}`;
          }
          const supportedProtocols = useProtocols ? this._supportedProtocols : [];
          this._ws = new settings.WebSocket(url, supportedProtocols);
          this._ws.binaryType = "arraybuffer";
          let alreadyCalledOnclose = false;
          const getKernelModel = async (evt) => {
            var _a2, _b2;
            if (this._isDisposed) {
              return;
            }
            this._reason = "";
            this._model = void 0;
            try {
              const model = await restapi.getKernelModel(this._id, settings);
              this._model = model;
              if ((model === null || model === void 0 ? void 0 : model.execution_state) === "dead") {
                this._updateStatus("dead");
              } else {
                this._onWSClose(evt);
              }
            } catch (err) {
              if (err instanceof __1.ServerConnection.NetworkError || ((_a2 = err.response) === null || _a2 === void 0 ? void 0 : _a2.status) === 503 || ((_b2 = err.response) === null || _b2 === void 0 ? void 0 : _b2.status) === 424) {
                const timeout = Private36.getRandomIntInclusive(10, 30) * 1e3;
                setTimeout(getKernelModel, timeout, evt);
              } else {
                this._reason = "Kernel died unexpectedly";
                this._updateStatus("dead");
              }
            }
            return;
          };
          const earlyClose = async (evt) => {
            if (alreadyCalledOnclose) {
              return;
            }
            alreadyCalledOnclose = true;
            await getKernelModel(evt);
            return;
          };
          this._ws.onmessage = this._onWSMessage;
          this._ws.onopen = this._onWSOpen;
          this._ws.onclose = earlyClose;
          this._ws.onerror = earlyClose;
        };
        this._onWSOpen = (evt) => {
          if (this._ws.protocol !== "" && !this._supportedProtocols.includes(this._ws.protocol)) {
            console.log("Server selected unknown kernel wire protocol:", this._ws.protocol);
            this._updateStatus("dead");
            throw new Error(`Unknown kernel wire protocol:  ${this._ws.protocol}`);
          }
          this._selectedProtocol = this._ws.protocol;
          this._ws.onclose = this._onWSClose;
          this._ws.onerror = this._onWSClose;
          this._updateConnectionStatus("connected");
        };
        this._onWSMessage = (evt) => {
          let msg;
          try {
            msg = this.serverSettings.serializer.deserialize(evt.data, this._ws.protocol);
            validate.validateMessage(msg);
          } catch (error) {
            error.message = `Kernel message validation error: ${error.message}`;
            throw error;
          }
          this._kernelSession = msg.header.session;
          this._msgChain = this._msgChain.then(() => {
            return this._handleMessage(msg);
          }).catch((error) => {
            if (error.message.startsWith("Canceled future for ")) {
              console.error(error);
            }
          });
          this._anyMessage.emit({ msg, direction: "recv" });
        };
        this._onWSClose = (evt) => {
          if (!this.isDisposed) {
            this._reconnect();
          }
        };
        this._id = "";
        this._name = "";
        this._status = "unknown";
        this._connectionStatus = "connecting";
        this._kernelSession = "";
        this._isDisposed = false;
        this._ws = null;
        this._username = "";
        this._reconnectLimit = 7;
        this._reconnectAttempt = 0;
        this._reconnectTimeout = null;
        this._supportedProtocols = Object.values(KernelMessage.supportedKernelWebSocketProtocols);
        this._selectedProtocol = "";
        this._futures = /* @__PURE__ */ new Map();
        this._comms = /* @__PURE__ */ new Map();
        this._targetRegistry = /* @__PURE__ */ Object.create(null);
        this._info = new coreutils_2.PromiseDelegate();
        this._pendingMessages = [];
        this._statusChanged = new signaling_1.Signal(this);
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._disposed = new signaling_1.Signal(this);
        this._iopubMessage = new signaling_1.Signal(this);
        this._anyMessage = new signaling_1.Signal(this);
        this._pendingInput = new signaling_1.Signal(this);
        this._unhandledMessage = new signaling_1.Signal(this);
        this._displayIdToParentIds = /* @__PURE__ */ new Map();
        this._msgIdToDisplayIds = /* @__PURE__ */ new Map();
        this._msgChain = Promise.resolve();
        this._hasPendingInput = false;
        this._reason = "";
        this._noOp = () => {
        };
        this._name = options.model.name;
        this._id = options.model.id;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._clientId = (_b = options.clientId) !== null && _b !== void 0 ? _b : coreutils_2.UUID.uuid4();
        this._username = (_c = options.username) !== null && _c !== void 0 ? _c : "";
        this.handleComms = (_d = options.handleComms) !== null && _d !== void 0 ? _d : true;
        this._createSocket();
      }
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when the kernel status changes.
       */
      get statusChanged() {
        return this._statusChanged;
      }
      /**
       * A signal emitted when the kernel status changes.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * A signal emitted for iopub kernel messages.
       *
       * #### Notes
       * This signal is emitted after the iopub message is handled asynchronously.
       */
      get iopubMessage() {
        return this._iopubMessage;
      }
      /**
       * A signal emitted for unhandled kernel message.
       *
       * #### Notes
       * This signal is emitted for a message that was not handled. It is emitted
       * during the asynchronous message handling code.
       */
      get unhandledMessage() {
        return this._unhandledMessage;
      }
      /**
       * The kernel model
       */
      get model() {
        return this._model || {
          id: this.id,
          name: this.name,
          reason: this._reason
        };
      }
      /**
       * A signal emitted for any kernel message.
       *
       * #### Notes
       * This signal is emitted when a message is received, before it is handled
       * asynchronously.
       *
       * This message is emitted when a message is queued for sending (either in
       * the websocket buffer, or our own pending message buffer). The message may
       * actually be sent across the wire at a later time.
       *
       * The message emitted in this signal should not be modified in any way.
       */
      get anyMessage() {
        return this._anyMessage;
      }
      /**
       * A signal emitted when a kernel has pending inputs from the user.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * The id of the server-side kernel.
       */
      get id() {
        return this._id;
      }
      /**
       * The name of the server-side kernel.
       */
      get name() {
        return this._name;
      }
      /**
       * The client username.
       */
      get username() {
        return this._username;
      }
      /**
       * The client unique id.
       */
      get clientId() {
        return this._clientId;
      }
      /**
       * The current status of the kernel.
       */
      get status() {
        return this._status;
      }
      /**
       * The current connection status of the kernel connection.
       */
      get connectionStatus() {
        return this._connectionStatus;
      }
      /**
       * Test whether the kernel has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * The cached kernel info.
       *
       * @returns A promise that resolves to the kernel info.
       */
      get info() {
        return this._info.promise;
      }
      /**
       * The kernel spec.
       *
       * @returns A promise that resolves to the kernel spec.
       */
      get spec() {
        if (this._specPromise) {
          return this._specPromise;
        }
        this._specPromise = kernelspec_1.KernelSpecAPI.getSpecs(this.serverSettings).then((specs) => {
          return specs.kernelspecs[this._name];
        });
        return this._specPromise;
      }
      /**
       * Clone the current kernel with a new clientId.
       */
      clone(options = {}) {
        return new KernelConnection({
          model: this.model,
          username: this.username,
          serverSettings: this.serverSettings,
          // handleComms defaults to false since that is safer
          handleComms: false,
          ...options
        });
      }
      /**
       * Dispose of the resources held by the kernel.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        this._updateConnectionStatus("disconnected");
        this._clearKernelState();
        this._pendingMessages = [];
        this._clearSocket();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Send a shell message to the kernel.
       *
       * #### Notes
       * Send a message to the kernel's shell channel, yielding a future object
       * for accepting replies.
       *
       * If `expectReply` is given and `true`, the future is disposed when both a
       * shell reply and an idle status message are received. If `expectReply`
       * is not given or is `false`, the future is resolved when an idle status
       * message is received.
       * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.
       * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.
       *
       * All replies are validated as valid kernel messages.
       *
       * If the kernel status is `dead`, this will throw an error.
       */
      sendShellMessage(msg, expectReply = false, disposeOnDone = true) {
        return this._sendKernelShellControl(future_1.KernelShellFutureHandler, msg, expectReply, disposeOnDone);
      }
      /**
       * Send a control message to the kernel.
       *
       * #### Notes
       * Send a message to the kernel's control channel, yielding a future object
       * for accepting replies.
       *
       * If `expectReply` is given and `true`, the future is disposed when both a
       * control reply and an idle status message are received. If `expectReply`
       * is not given or is `false`, the future is resolved when an idle status
       * message is received.
       * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.
       * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.
       *
       * All replies are validated as valid kernel messages.
       *
       * If the kernel status is `dead`, this will throw an error.
       */
      sendControlMessage(msg, expectReply = false, disposeOnDone = true) {
        return this._sendKernelShellControl(future_1.KernelControlFutureHandler, msg, expectReply, disposeOnDone);
      }
      _sendKernelShellControl(ctor, msg, expectReply = false, disposeOnDone = true) {
        this._sendMessage(msg);
        this._anyMessage.emit({ msg, direction: "send" });
        const future = new ctor(() => {
          const msgId = msg.header.msg_id;
          this._futures.delete(msgId);
          const displayIds = this._msgIdToDisplayIds.get(msgId);
          if (!displayIds) {
            return;
          }
          displayIds.forEach((displayId) => {
            const msgIds = this._displayIdToParentIds.get(displayId);
            if (msgIds) {
              const idx = msgIds.indexOf(msgId);
              if (idx === -1) {
                return;
              }
              if (msgIds.length === 1) {
                this._displayIdToParentIds.delete(displayId);
              } else {
                msgIds.splice(idx, 1);
                this._displayIdToParentIds.set(displayId, msgIds);
              }
            }
          });
          this._msgIdToDisplayIds.delete(msgId);
        }, msg, expectReply, disposeOnDone, this);
        this._futures.set(msg.header.msg_id, future);
        return future;
      }
      /**
       * Send a message on the websocket.
       *
       * If queue is true, queue the message for later sending if we cannot send
       * now. Otherwise throw an error.
       *
       * #### Notes
       * As an exception to the queueing, if we are sending a kernel_info_request
       * message while we think the kernel is restarting, we send the message
       * immediately without queueing. This is so that we can trigger a message
       * back, which will then clear the kernel restarting state.
       */
      _sendMessage(msg, queue = true) {
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        if ((this._kernelSession === STARTING_KERNEL_SESSION || this._kernelSession === RESTARTING_KERNEL_SESSION) && KernelMessage.isInfoRequestMsg(msg)) {
          if (this.connectionStatus === "connected") {
            this._ws.send(this.serverSettings.serializer.serialize(msg, this._ws.protocol));
            return;
          } else {
            throw new Error("Could not send message: status is not connected");
          }
        }
        if (queue && this._pendingMessages.length > 0) {
          this._pendingMessages.push(msg);
          return;
        }
        if (this.connectionStatus === "connected" && this._kernelSession !== RESTARTING_KERNEL_SESSION) {
          this._ws.send(this.serverSettings.serializer.serialize(msg, this._ws.protocol));
        } else if (queue) {
          this._pendingMessages.push(msg);
        } else {
          throw new Error("Could not send message");
        }
      }
      /**
       * Interrupt a kernel.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * It is assumed that the API call does not mutate the kernel id or name.
       *
       * The promise will be rejected if the kernel status is `Dead` or if the
       * request fails or the response is invalid.
       */
      async interrupt() {
        this.hasPendingInput = false;
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        return restapi.interruptKernel(this.id, this.serverSettings);
      }
      /**
       * Request a kernel restart.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels)
       * and validates the response model.
       *
       * Any existing Future or Comm objects are cleared once the kernel has
       * actually be restarted.
       *
       * The promise is fulfilled on a valid server response (after the kernel restarts)
       * and rejected otherwise.
       *
       * It is assumed that the API call does not mutate the kernel id or name.
       *
       * The promise will be rejected if the request fails or the response is
       * invalid.
       */
      async restart() {
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        this._updateStatus("restarting");
        this._clearKernelState();
        this._kernelSession = RESTARTING_KERNEL_SESSION;
        await restapi.restartKernel(this.id, this.serverSettings);
        await this.reconnect();
        this.hasPendingInput = false;
      }
      /**
       * Reconnect to a kernel.
       *
       * #### Notes
       * This may try multiple times to reconnect to a kernel, and will sever any
       * existing connection.
       */
      reconnect() {
        this._errorIfDisposed();
        const result = new coreutils_2.PromiseDelegate();
        const fulfill = (sender, status) => {
          if (status === "connected") {
            result.resolve();
            this.connectionStatusChanged.disconnect(fulfill, this);
          } else if (status === "disconnected") {
            result.reject(new Error("Kernel connection disconnected"));
            this.connectionStatusChanged.disconnect(fulfill, this);
          }
        };
        this.connectionStatusChanged.connect(fulfill, this);
        this._reconnectAttempt = 0;
        this._reconnect();
        return result.promise;
      }
      /**
       * Shutdown a kernel.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * On a valid response, disposes this kernel connection.
       *
       * If the kernel is already `dead`, disposes this kernel connection without
       * a server request.
       */
      async shutdown() {
        if (this.status !== "dead") {
          await restapi.shutdownKernel(this.id, this.serverSettings);
        }
        this.handleShutdown();
      }
      /**
       * Handles a kernel shutdown.
       *
       * #### Notes
       * This method should be called if we know from outside information that a
       * kernel is dead (for example, we cannot find the kernel model on the
       * server).
       */
      handleShutdown() {
        this._updateStatus("dead");
        this.dispose();
      }
      /**
       * Send a `kernel_info_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#kernel-info).
       *
       * Fulfills with the `kernel_info_response` content when the shell reply is
       * received and validated.
       */
      async requestKernelInfo() {
        const msg = KernelMessage.createMessage({
          msgType: "kernel_info_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content: {}
        });
        let reply;
        try {
          reply = await Private36.handleShellMessage(this, msg);
        } catch (e) {
          if (this.isDisposed) {
            return;
          } else {
            throw e;
          }
        }
        this._errorIfDisposed();
        if (!reply) {
          return;
        }
        if (reply.content.status === void 0) {
          reply.content.status = "ok";
        }
        if (reply.content.status !== "ok") {
          this._info.reject("Kernel info reply errored");
          return reply;
        }
        this._info.resolve(reply.content);
        this._kernelSession = reply.header.session;
        return reply;
      }
      /**
       * Send a `complete_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#completion).
       *
       * Fulfills with the `complete_reply` content when the shell reply is
       * received and validated.
       */
      requestComplete(content) {
        const msg = KernelMessage.createMessage({
          msgType: "complete_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private36.handleShellMessage(this, msg);
      }
      /**
       * Send an `inspect_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#introspection).
       *
       * Fulfills with the `inspect_reply` content when the shell reply is
       * received and validated.
       */
      requestInspect(content) {
        const msg = KernelMessage.createMessage({
          msgType: "inspect_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private36.handleShellMessage(this, msg);
      }
      /**
       * Send a `history_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#history).
       *
       * Fulfills with the `history_reply` content when the shell reply is
       * received and validated.
       */
      requestHistory(content) {
        const msg = KernelMessage.createMessage({
          msgType: "history_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private36.handleShellMessage(this, msg);
      }
      /**
       * Send an `execute_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#execute).
       *
       * Future `onReply` is called with the `execute_reply` content when the
       * shell reply is received and validated. The future will resolve when
       * this message is received and the `idle` iopub status is received.
       * The future will also be disposed at this point unless `disposeOnDone`
       * is specified and `false`, in which case it is up to the caller to dispose
       * of the future.
       *
       * **See also:** [[IExecuteReply]]
       */
      requestExecute(content, disposeOnDone = true, metadata) {
        const defaults = {
          silent: false,
          store_history: true,
          user_expressions: {},
          allow_stdin: true,
          stop_on_error: false
        };
        const msg = KernelMessage.createMessage({
          msgType: "execute_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content: { ...defaults, ...content },
          metadata
        });
        return this.sendShellMessage(msg, true, disposeOnDone);
      }
      /**
       * Send an experimental `debug_request` message.
       *
       * @hidden
       *
       * #### Notes
       * Debug messages are experimental messages that are not in the official
       * kernel message specification. As such, this function is *NOT* considered
       * part of the public API, and may change without notice.
       */
      requestDebug(content, disposeOnDone = true) {
        const msg = KernelMessage.createMessage({
          msgType: "debug_request",
          channel: "control",
          username: this._username,
          session: this._clientId,
          content
        });
        return this.sendControlMessage(msg, true, disposeOnDone);
      }
      /**
       * Send an `is_complete_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#code-completeness).
       *
       * Fulfills with the `is_complete_response` content when the shell reply is
       * received and validated.
       */
      requestIsComplete(content) {
        const msg = KernelMessage.createMessage({
          msgType: "is_complete_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private36.handleShellMessage(this, msg);
      }
      /**
       * Send a `comm_info_request` message.
       *
       * #### Notes
       * Fulfills with the `comm_info_reply` content when the shell reply is
       * received and validated.
       */
      requestCommInfo(content) {
        const msg = KernelMessage.createMessage({
          msgType: "comm_info_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private36.handleShellMessage(this, msg);
      }
      /**
       * Send an `input_reply` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#messages-on-the-stdin-router-dealer-sockets).
       */
      sendInputReply(content, parent_header) {
        const msg = KernelMessage.createMessage({
          msgType: "input_reply",
          channel: "stdin",
          username: this._username,
          session: this._clientId,
          content
        });
        msg.parent_header = parent_header;
        this._sendMessage(msg);
        this._anyMessage.emit({ msg, direction: "send" });
        this.hasPendingInput = false;
      }
      /**
       * Create a new comm.
       *
       * #### Notes
       * If a client-side comm already exists with the given commId, an error is thrown.
       * If the kernel does not handle comms, an error is thrown.
       */
      createComm(targetName, commId = coreutils_2.UUID.uuid4()) {
        if (!this.handleComms) {
          throw new Error("Comms are disabled on this kernel connection");
        }
        if (this._comms.has(commId)) {
          throw new Error("Comm is already created");
        }
        const comm = new comm_1.CommHandler(targetName, commId, this, () => {
          this._unregisterComm(commId);
        });
        this._comms.set(commId, comm);
        return comm;
      }
      /**
       * Check if a comm exists.
       */
      hasComm(commId) {
        return this._comms.has(commId);
      }
      /**
       * Register a comm target handler.
       *
       * @param targetName - The name of the comm target.
       *
       * @param callback - The callback invoked for a comm open message.
       *
       * @returns A disposable used to unregister the comm target.
       *
       * #### Notes
       * Only one comm target can be registered to a target name at a time, an
       * existing callback for the same target name will be overridden.  A registered
       * comm target handler will take precedence over a comm which specifies a
       * `target_module`.
       *
       * If the callback returns a promise, kernel message processing will pause
       * until the returned promise is fulfilled.
       */
      registerCommTarget(targetName, callback) {
        if (!this.handleComms) {
          return;
        }
        this._targetRegistry[targetName] = callback;
      }
      /**
       * Remove a comm target handler.
       *
       * @param targetName - The name of the comm target to remove.
       *
       * @param callback - The callback to remove.
       *
       * #### Notes
       * The comm target is only removed if the callback argument matches.
       */
      removeCommTarget(targetName, callback) {
        if (!this.handleComms) {
          return;
        }
        if (!this.isDisposed && this._targetRegistry[targetName] === callback) {
          delete this._targetRegistry[targetName];
        }
      }
      /**
       * Register an IOPub message hook.
       *
       * @param msg_id - The parent_header message id the hook will intercept.
       *
       * @param hook - The callback invoked for the message.
       *
       * #### Notes
       * The IOPub hook system allows you to preempt the handlers for IOPub
       * messages that are responses to a given message id.
       *
       * The most recently registered hook is run first. A hook can return a
       * boolean or a promise to a boolean, in which case all kernel message
       * processing pauses until the promise is fulfilled. If a hook return value
       * resolves to false, any later hooks will not run and the function will
       * return a promise resolving to false. If a hook throws an error, the error
       * is logged to the console and the next hook is run. If a hook is
       * registered during the hook processing, it will not run until the next
       * message. If a hook is removed during the hook processing, it will be
       * deactivated immediately.
       *
       * See also [[IFuture.registerMessageHook]].
       */
      registerMessageHook(msgId, hook) {
        var _a;
        const future = (_a = this._futures) === null || _a === void 0 ? void 0 : _a.get(msgId);
        if (future) {
          future.registerMessageHook(hook);
        }
      }
      /**
       * Remove an IOPub message hook.
       *
       * @param msg_id - The parent_header message id the hook intercepted.
       *
       * @param hook - The callback invoked for the message.
       *
       */
      removeMessageHook(msgId, hook) {
        var _a;
        const future = (_a = this._futures) === null || _a === void 0 ? void 0 : _a.get(msgId);
        if (future) {
          future.removeMessageHook(hook);
        }
      }
      /**
       * Remove the input guard, if any.
       */
      removeInputGuard() {
        this.hasPendingInput = false;
      }
      /**
       * Handle a message with a display id.
       *
       * @returns Whether the message was handled.
       */
      async _handleDisplayId(displayId, msg) {
        var _a, _b;
        const msgId = msg.parent_header.msg_id;
        let parentIds = this._displayIdToParentIds.get(displayId);
        if (parentIds) {
          const updateMsg = {
            header: coreutils_2.JSONExt.deepCopy(msg.header),
            parent_header: coreutils_2.JSONExt.deepCopy(msg.parent_header),
            metadata: coreutils_2.JSONExt.deepCopy(msg.metadata),
            content: coreutils_2.JSONExt.deepCopy(msg.content),
            channel: msg.channel,
            buffers: msg.buffers ? msg.buffers.slice() : []
          };
          updateMsg.header.msg_type = "update_display_data";
          await Promise.all(parentIds.map(async (parentId) => {
            const future = this._futures && this._futures.get(parentId);
            if (future) {
              await future.handleMsg(updateMsg);
            }
          }));
        }
        if (msg.header.msg_type === "update_display_data") {
          return true;
        }
        parentIds = (_a = this._displayIdToParentIds.get(displayId)) !== null && _a !== void 0 ? _a : [];
        if (parentIds.indexOf(msgId) === -1) {
          parentIds.push(msgId);
        }
        this._displayIdToParentIds.set(displayId, parentIds);
        const displayIds = (_b = this._msgIdToDisplayIds.get(msgId)) !== null && _b !== void 0 ? _b : [];
        if (displayIds.indexOf(msgId) === -1) {
          displayIds.push(msgId);
        }
        this._msgIdToDisplayIds.set(msgId, displayIds);
        return false;
      }
      /**
       * Forcefully clear the socket state.
       *
       * #### Notes
       * This will clear all socket state without calling any handlers and will
       * not update the connection status. If you call this method, you are
       * responsible for updating the connection status as needed and recreating
       * the socket if you plan to reconnect.
       */
      _clearSocket() {
        if (this._ws !== null) {
          this._ws.onopen = this._noOp;
          this._ws.onclose = this._noOp;
          this._ws.onerror = this._noOp;
          this._ws.onmessage = this._noOp;
          this._ws.close();
          this._ws = null;
        }
      }
      /**
       * Handle status iopub messages from the kernel.
       */
      _updateStatus(status) {
        if (this._status === status || this._status === "dead") {
          return;
        }
        this._status = status;
        Private36.logKernelStatus(this);
        this._statusChanged.emit(status);
        if (status === "dead") {
          this.dispose();
        }
      }
      /**
       * Send pending messages to the kernel.
       */
      _sendPending() {
        while (this.connectionStatus === "connected" && this._kernelSession !== RESTARTING_KERNEL_SESSION && this._pendingMessages.length > 0) {
          this._sendMessage(this._pendingMessages[0], false);
          this._pendingMessages.shift();
        }
      }
      /**
       * Clear the internal state.
       */
      _clearKernelState() {
        this._kernelSession = "";
        this._pendingMessages = [];
        this._futures.forEach((future) => {
          future.dispose();
        });
        this._comms.forEach((comm) => {
          comm.dispose();
        });
        this._msgChain = Promise.resolve();
        this._futures = /* @__PURE__ */ new Map();
        this._comms = /* @__PURE__ */ new Map();
        this._displayIdToParentIds.clear();
        this._msgIdToDisplayIds.clear();
      }
      /**
       * Check to make sure it is okay to proceed to handle a message.
       *
       * #### Notes
       * Because we handle messages asynchronously, before a message is handled the
       * kernel might be disposed or restarted (and have a different session id).
       * This function throws an error in each of these cases. This is meant to be
       * called at the start of an asynchronous message handler to cancel message
       * processing if the message no longer is valid.
       */
      _assertCurrentMessage(msg) {
        this._errorIfDisposed();
        if (msg.header.session !== this._kernelSession) {
          throw new Error(`Canceling handling of old message: ${msg.header.msg_type}`);
        }
      }
      /**
       * Handle a `comm_open` kernel message.
       */
      async _handleCommOpen(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = new comm_1.CommHandler(content.target_name, content.comm_id, this, () => {
          this._unregisterComm(content.comm_id);
        });
        this._comms.set(content.comm_id, comm);
        try {
          const target2 = await Private36.loadObject(content.target_name, content.target_module, this._targetRegistry);
          await target2(comm, msg);
        } catch (e) {
          comm.close();
          console.error("Exception opening new comm");
          throw e;
        }
      }
      /**
       * Handle 'comm_close' kernel message.
       */
      async _handleCommClose(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = this._comms.get(content.comm_id);
        if (!comm) {
          console.error("Comm not found for comm id " + content.comm_id);
          return;
        }
        this._unregisterComm(comm.commId);
        const onClose = comm.onClose;
        if (onClose) {
          await onClose(msg);
        }
        comm.dispose();
      }
      /**
       * Handle a 'comm_msg' kernel message.
       */
      async _handleCommMsg(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = this._comms.get(content.comm_id);
        if (!comm) {
          return;
        }
        const onMsg = comm.onMsg;
        if (onMsg) {
          await onMsg(msg);
        }
      }
      /**
       * Unregister a comm instance.
       */
      _unregisterComm(commId) {
        this._comms.delete(commId);
      }
      /**
       * Handle connection status changes.
       */
      _updateConnectionStatus(connectionStatus) {
        if (this._connectionStatus === connectionStatus) {
          return;
        }
        this._connectionStatus = connectionStatus;
        if (connectionStatus !== "connecting") {
          this._reconnectAttempt = 0;
          clearTimeout(this._reconnectTimeout);
        }
        if (this.status !== "dead") {
          if (connectionStatus === "connected") {
            let restarting = this._kernelSession === RESTARTING_KERNEL_SESSION;
            let p = this.requestKernelInfo();
            let sendPendingCalled = false;
            let sendPendingOnce = () => {
              if (sendPendingCalled) {
                return;
              }
              sendPendingCalled = true;
              if (restarting && this._kernelSession === RESTARTING_KERNEL_SESSION) {
                this._kernelSession = "";
              }
              clearTimeout(timeoutHandle);
              if (this._pendingMessages.length > 0) {
                this._sendPending();
              }
            };
            void p.then(sendPendingOnce);
            let timeoutHandle = setTimeout(sendPendingOnce, KERNEL_INFO_TIMEOUT);
          } else {
            this._updateStatus("unknown");
          }
        }
        this._connectionStatusChanged.emit(connectionStatus);
      }
      async _handleMessage(msg) {
        var _a, _b;
        let handled = false;
        if (msg.parent_header && msg.channel === "iopub" && (KernelMessage.isDisplayDataMsg(msg) || KernelMessage.isUpdateDisplayDataMsg(msg) || KernelMessage.isExecuteResultMsg(msg))) {
          const transient = (_a = msg.content.transient) !== null && _a !== void 0 ? _a : {};
          const displayId = transient["display_id"];
          if (displayId) {
            handled = await this._handleDisplayId(displayId, msg);
            this._assertCurrentMessage(msg);
          }
        }
        if (!handled && msg.parent_header) {
          const parentHeader = msg.parent_header;
          const future = (_b = this._futures) === null || _b === void 0 ? void 0 : _b.get(parentHeader.msg_id);
          if (future) {
            await future.handleMsg(msg);
            this._assertCurrentMessage(msg);
          } else {
            const owned = parentHeader.session === this.clientId;
            if (msg.channel !== "iopub" && owned) {
              this._unhandledMessage.emit(msg);
            }
          }
        }
        if (msg.channel === "iopub") {
          switch (msg.header.msg_type) {
            case "status": {
              const executionState = msg.content.execution_state;
              if (executionState === "restarting") {
                void Promise.resolve().then(async () => {
                  this._updateStatus("autorestarting");
                  this._clearKernelState();
                  await this.reconnect();
                });
              }
              this._updateStatus(executionState);
              break;
            }
            case "comm_open":
              if (this.handleComms) {
                await this._handleCommOpen(msg);
              }
              break;
            case "comm_msg":
              if (this.handleComms) {
                await this._handleCommMsg(msg);
              }
              break;
            case "comm_close":
              if (this.handleComms) {
                await this._handleCommClose(msg);
              }
              break;
            default:
              break;
          }
          if (!this.isDisposed) {
            this._assertCurrentMessage(msg);
            this._iopubMessage.emit(msg);
          }
        }
      }
      /**
       * Attempt a connection if we have not exhausted connection attempts.
       */
      _reconnect() {
        this._errorIfDisposed();
        clearTimeout(this._reconnectTimeout);
        if (this._reconnectAttempt < this._reconnectLimit) {
          this._updateConnectionStatus("connecting");
          const timeout = Private36.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
          console.warn(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`);
          const useProtocols = this._selectedProtocol !== "" ? true : false;
          this._reconnectTimeout = setTimeout(this._createSocket, timeout, useProtocols);
          this._reconnectAttempt += 1;
        } else {
          this._updateConnectionStatus("disconnected");
        }
        this._clearSocket();
      }
      /**
       * Utility function to throw an error if this instance is disposed.
       */
      _errorIfDisposed() {
        if (this.isDisposed) {
          throw new Error("Kernel connection is disposed");
        }
      }
      get hasPendingInput() {
        return this._hasPendingInput;
      }
      set hasPendingInput(value) {
        this._hasPendingInput = value;
        this._pendingInput.emit(value);
      }
    };
    exports2.KernelConnection = KernelConnection;
    var Private36;
    (function(Private37) {
      function logKernelStatus(kernel) {
        switch (kernel.status) {
          case "idle":
          case "busy":
          case "unknown":
            return;
          default:
            console.debug(`Kernel: ${kernel.status} (${kernel.id})`);
            break;
        }
      }
      Private37.logKernelStatus = logKernelStatus;
      async function handleShellMessage(kernel, msg) {
        const future = kernel.sendShellMessage(msg, true);
        return future.done;
      }
      Private37.handleShellMessage = handleShellMessage;
      function loadObject(name2, moduleName, registry) {
        return new Promise((resolve, reject) => {
          if (moduleName) {
            if (typeof requirejs === "undefined") {
              throw new Error("requirejs not found");
            }
            requirejs([moduleName], (mod) => {
              if (mod[name2] === void 0) {
                const msg = `Object '${name2}' not found in module '${moduleName}'`;
                reject(new Error(msg));
              } else {
                resolve(mod[name2]);
              }
            }, reject);
          } else {
            if (registry === null || registry === void 0 ? void 0 : registry[name2]) {
              resolve(registry[name2]);
            } else {
              reject(new Error(`Object '${name2}' not found in registry`));
            }
          }
        });
      }
      Private37.loadObject = loadObject;
      function getRandomIntInclusive(min, max2) {
        min = Math.ceil(min);
        max2 = Math.floor(max2);
        return Math.floor(Math.random() * (max2 - min + 1)) + min;
      }
      Private37.getRandomIntInclusive = getRandomIntInclusive;
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/manager.js
var require_manager2 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelManager = void 0;
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib3();
    var basemanager_1 = require_basemanager();
    var restapi_1 = require_restapi();
    var default_1 = require_default();
    var KernelManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new kernel manager.
       *
       * @param options - The default options for kernel.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._kernelConnections = /* @__PURE__ */ new Set();
        this._models = /* @__PURE__ */ new Map();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:KernelManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running kernels change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._models.clear();
        this._kernelConnections.forEach((x) => x.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /**
       * Connect to an existing kernel.
       *
       * @returns The new kernel connection.
       *
       * #### Notes
       * This will use the manager's server settings and ignore any server
       * settings passed in the options.
       */
      connectTo(options) {
        var _a;
        const { id } = options.model;
        let handleComms = (_a = options.handleComms) !== null && _a !== void 0 ? _a : true;
        if (options.handleComms === void 0) {
          for (const kc of this._kernelConnections) {
            if (kc.id === id && kc.handleComms) {
              handleComms = false;
              break;
            }
          }
        }
        const kernelConnection = new default_1.KernelConnection({
          handleComms,
          ...options,
          serverSettings: this.serverSettings
        });
        this._onStarted(kernelConnection);
        if (!this._models.has(id)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return kernelConnection;
      }
      /**
       * Create an iterator over the most recent running kernels.
       *
       * @returns A new iterator over the running kernels.
       */
      running() {
        return this._models.values();
      }
      /**
       * Force a refresh of the running kernels.
       *
       * @returns A promise that resolves when the running list has been refreshed.
       *
       * #### Notes
       * This is not typically meant to be called by the user, since the
       * manager maintains its own internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Start a new kernel.
       *
       * @param createOptions - The kernel creation options
       *
       * @param connectOptions - The kernel connection options
       *
       * @returns A promise that resolves with the kernel connection.
       *
       * #### Notes
       * The manager `serverSettings` will be always be used.
       */
      async startNew(createOptions = {}, connectOptions = {}) {
        const model = await (0, restapi_1.startNew)(createOptions, this.serverSettings);
        return this.connectTo({
          ...connectOptions,
          model
        });
      }
      /**
       * Shut down a kernel by id.
       *
       * @param id - The id of the target kernel.
       *
       * @returns A promise that resolves when the operation is complete.
       */
      async shutdown(id) {
        await (0, restapi_1.shutdownKernel)(id, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all kernels.
       *
       * @returns A promise that resolves when all of the kernels are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all([...this._models.keys()].map((id) => (0, restapi_1.shutdownKernel)(id, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Find a kernel by id.
       *
       * @param id - The id of the target kernel.
       *
       * @returns A promise that resolves with the kernel's model.
       */
      async findById(id) {
        if (this._models.has(id)) {
          return this._models.get(id);
        }
        await this.refreshRunning();
        return this._models.get(id);
      }
      /**
       * Execute a request to the server to poll running kernels and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof __1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        if (this._models.size === models.length && models.every((model) => {
          const existing = this._models.get(model.id);
          if (!existing) {
            return false;
          }
          return existing.connections === model.connections && existing.execution_state === model.execution_state && existing.last_activity === model.last_activity && existing.name === model.name && existing.reason === model.reason && existing.traceback === model.traceback;
        })) {
          return;
        }
        this._models = new Map(models.map((x) => [x.id, x]));
        this._kernelConnections.forEach((kc) => {
          if (!this._models.has(kc.id)) {
            kc.handleShutdown();
          }
        });
        this._runningChanged.emit(models);
      }
      /**
       * Handle a kernel starting.
       */
      _onStarted(kernelConnection) {
        this._kernelConnections.add(kernelConnection);
        kernelConnection.statusChanged.connect(this._onStatusChanged, this);
        kernelConnection.disposed.connect(this._onDisposed, this);
      }
      _onDisposed(kernelConnection) {
        this._kernelConnections.delete(kernelConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      _onStatusChanged(kernelConnection, status) {
        if (status === "dead") {
          void this.refreshRunning().catch(() => {
          });
        }
      }
    };
    exports2.KernelManager = KernelManager;
    (function(KernelManager2) {
      class NoopManager extends KernelManager2 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * Start a new kernel - throws an error since it is not supported.
         */
        async startNew(createOptions = {}, connectOptions = {}) {
          return Promise.reject(new Error("Not implemented in no-op Kernel Manager"));
        }
        /**
         * Connect to an existing kernel - throws an error since it is not supported.
         */
        connectTo(options) {
          throw new Error("Not implemented in no-op Kernel Manager");
        }
        /**
         * Shut down a kernel by id - throws an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Kernel Manager"));
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Execute a request to the server to poll running kernels and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      KernelManager2.NoopManager = NoopManager;
    })(KernelManager || (exports2.KernelManager = KernelManager = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/index.js
var require_kernel2 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/kernel/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelConnection = exports2.KernelAPI = exports2.KernelMessage = exports2.Kernel = void 0;
    var Kernel = __importStar2(require_kernel());
    exports2.Kernel = Kernel;
    var KernelMessage = __importStar2(require_messages());
    exports2.KernelMessage = KernelMessage;
    var KernelAPI = __importStar2(require_restapi());
    exports2.KernelAPI = KernelAPI;
    var default_1 = require_default();
    Object.defineProperty(exports2, "KernelConnection", { enumerable: true, get: function() {
      return default_1.KernelConnection;
    } });
    __exportStar2(require_manager2(), exports2);
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/builder/index.js
var require_builder = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/builder/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BuildManager = void 0;
    var coreutils_12 = require_lib2();
    var serverconnection_1 = require_serverconnection();
    var BUILD_SETTINGS_URL = "api/build";
    var BuildManager = class {
      /**
       * Create a new setting manager.
       */
      constructor(options = {}) {
        var _a;
        this._url = "";
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        const { baseUrl, appUrl } = this.serverSettings;
        this._url = coreutils_12.URLExt.join(baseUrl, appUrl, BUILD_SETTINGS_URL);
      }
      /**
       * Test whether the build service is available.
       */
      get isAvailable() {
        return coreutils_12.PageConfig.getOption("buildAvailable").toLowerCase() === "true";
      }
      /**
       * Test whether to check build status automatically.
       */
      get shouldCheck() {
        return coreutils_12.PageConfig.getOption("buildCheck").toLowerCase() === "true";
      }
      /**
       * Get whether the application should be built.
       */
      getStatus() {
        const { _url, serverSettings } = this;
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, {}, serverSettings);
        return promise.then((response) => {
          if (response.status !== 200) {
            throw new serverconnection_1.ServerConnection.ResponseError(response);
          }
          return response.json();
        }).then((data) => {
          if (typeof data.status !== "string") {
            throw new Error("Invalid data");
          }
          if (typeof data.message !== "string") {
            throw new Error("Invalid data");
          }
          return data;
        });
      }
      /**
       * Build the application.
       */
      build() {
        const { _url, serverSettings } = this;
        const init = { method: "POST" };
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, init, serverSettings);
        return promise.then((response) => {
          if (response.status === 400) {
            throw new serverconnection_1.ServerConnection.ResponseError(response, "Build aborted");
          }
          if (response.status !== 200) {
            const message = `Build failed with ${response.status}.

        If you are experiencing the build failure after installing an extension (or trying to include previously installed extension after updating JupyterLab) please check the extension repository for new installation instructions as many extensions migrated to the prebuilt extensions system which no longer requires rebuilding JupyterLab (but uses a different installation procedure, typically involving a package manager such as 'pip' or 'conda').

        If you specifically intended to install a source extension, please run 'jupyter lab build' on the server for full output.`;
            throw new serverconnection_1.ServerConnection.ResponseError(response, message);
          }
        });
      }
      /**
       * Cancel an active build.
       */
      cancel() {
        const { _url, serverSettings } = this;
        const init = { method: "DELETE" };
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, init, serverSettings);
        return promise.then((response) => {
          if (response.status !== 204) {
            throw new serverconnection_1.ServerConnection.ResponseError(response);
          }
        });
      }
    };
    exports2.BuildManager = BuildManager;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/nbconvert/index.js
var require_nbconvert = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/nbconvert/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NbConvertManager = void 0;
    var coreutils_12 = require_lib2();
    var serverconnection_1 = require_serverconnection();
    var coreutils_2 = require_dist();
    var NBCONVERT_SETTINGS_URL = "api/nbconvert";
    var NbConvertManager = class {
      /**
       * Create a new nbconvert manager.
       */
      constructor(options = {}) {
        var _a;
        this._exportFormats = null;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch and cache the export formats from the expensive nbconvert handler.
       */
      async fetchExportFormats() {
        this._requestingFormats = new coreutils_2.PromiseDelegate();
        this._exportFormats = null;
        const base = this.serverSettings.baseUrl;
        const url = coreutils_12.URLExt.join(base, NBCONVERT_SETTINGS_URL);
        const { serverSettings } = this;
        const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        const exportList = {};
        const keys = Object.keys(data);
        keys.forEach(function(key2) {
          const mimeType = data[key2].output_mimetype;
          exportList[key2] = { output_mimetype: mimeType };
        });
        this._exportFormats = exportList;
        this._requestingFormats.resolve(exportList);
        return exportList;
      }
      /**
       * Get the list of export formats, preferring pre-cached ones.
       */
      async getExportFormats(force = true) {
        if (this._requestingFormats) {
          return this._requestingFormats.promise;
        }
        if (force || !this._exportFormats) {
          return await this.fetchExportFormats();
        }
        return this._exportFormats;
      }
    };
    exports2.NbConvertManager = NbConvertManager;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/session/session.js
var require_session = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/session/session.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/session/validate.js
var require_validate5 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/session/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateModels = exports2.updateLegacySessionModel = exports2.validateModel = void 0;
    var validate_1 = require_validate3();
    var validate_2 = require_validate();
    function validateModel(data) {
      (0, validate_2.validateProperty)(data, "id", "string");
      (0, validate_2.validateProperty)(data, "type", "string");
      (0, validate_2.validateProperty)(data, "name", "string");
      (0, validate_2.validateProperty)(data, "path", "string");
      (0, validate_2.validateProperty)(data, "kernel", "object");
      (0, validate_1.validateModel)(data.kernel);
    }
    exports2.validateModel = validateModel;
    function updateLegacySessionModel(data) {
      if (data.path === void 0 && data.notebook !== void 0) {
        data.path = data.notebook.path;
        data.type = "notebook";
        data.name = "";
      }
    }
    exports2.updateLegacySessionModel = updateLegacySessionModel;
    function validateModels(models) {
      if (!Array.isArray(models)) {
        throw new Error("Invalid session list");
      }
      models.forEach((d) => validateModel(d));
    }
    exports2.validateModels = validateModels;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/session/restapi.js
var require_restapi3 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/session/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateSession = exports2.startSession = exports2.getSessionModel = exports2.shutdownSession = exports2.getSessionUrl = exports2.listRunning = exports2.SESSION_SERVICE_URL = void 0;
    var serverconnection_1 = require_serverconnection();
    var coreutils_12 = require_lib2();
    var validate_1 = require_validate5();
    exports2.SESSION_SERVICE_URL = "api/sessions";
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.SESSION_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error("Invalid Session list");
      }
      data.forEach((m) => {
        (0, validate_1.updateLegacySessionModel)(m);
        (0, validate_1.validateModel)(m);
      });
      return data;
    }
    exports2.listRunning = listRunning;
    function getSessionUrl(baseUrl, id) {
      const servicesBase = coreutils_12.URLExt.join(baseUrl, exports2.SESSION_SERVICE_URL);
      const result = coreutils_12.URLExt.join(servicesBase, id);
      if (!result.startsWith(servicesBase)) {
        throw new Error("Can only be used for services requests");
      }
      return result;
    }
    exports2.getSessionUrl = getSessionUrl;
    async function shutdownSession(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      var _a;
      const url = getSessionUrl(settings.baseUrl, id);
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const data = await response.json();
        const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The session "${id}"" does not exist on the server`;
        console.warn(msg);
      } else if (response.status === 410) {
        throw new serverconnection_1.ServerConnection.ResponseError(response, "The kernel was deleted but the session was not");
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownSession = shutdownSession;
    async function getSessionModel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = getSessionUrl(settings.baseUrl, id);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.getSessionModel = getSessionModel;
    async function startSession(options, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.SESSION_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify(options)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 201) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.startSession = startSession;
    async function updateSession(model, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = getSessionUrl(settings.baseUrl, model.id);
      const init = {
        method: "PATCH",
        body: JSON.stringify(model)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.updateSession = updateSession;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/session/default.js
var require_default2 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/session/default.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionConnection = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib3();
    var restapi_1 = require_restapi3();
    var coreutils_12 = require_dist();
    var SessionConnection = class {
      /**
       * Construct a new session.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        this._id = "";
        this._path = "";
        this._name = "";
        this._type = "";
        this._kernel = null;
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this._kernelChanged = new signaling_1.Signal(this);
        this._statusChanged = new signaling_1.Signal(this);
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._pendingInput = new signaling_1.Signal(this);
        this._iopubMessage = new signaling_1.Signal(this);
        this._unhandledMessage = new signaling_1.Signal(this);
        this._anyMessage = new signaling_1.Signal(this);
        this._propertyChanged = new signaling_1.Signal(this);
        this._id = options.model.id;
        this._name = options.model.name;
        this._path = options.model.path;
        this._type = options.model.type;
        this._username = (_a = options.username) !== null && _a !== void 0 ? _a : "";
        this._clientId = (_b = options.clientId) !== null && _b !== void 0 ? _b : coreutils_12.UUID.uuid4();
        this._connectToKernel = options.connectToKernel;
        this._kernelConnectionOptions = (_c = options.kernelConnectionOptions) !== null && _c !== void 0 ? _c : {};
        this.serverSettings = (_d = options.serverSettings) !== null && _d !== void 0 ? _d : __1.ServerConnection.makeSettings();
        this.setupKernel(options.model.kernel);
      }
      /**
       * A signal emitted when the session is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when the kernel changes.
       */
      get kernelChanged() {
        return this._kernelChanged;
      }
      /**
       * A signal proxied from the connection about the kernel status.
       */
      get statusChanged() {
        return this._statusChanged;
      }
      /**
       * A signal proxied from the kernel about the connection status.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * A signal proxied from the kernel pending input.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * A signal proxied from the kernel about iopub kernel messages.
       */
      get iopubMessage() {
        return this._iopubMessage;
      }
      /**
       * A signal proxied from the kernel for an unhandled kernel message.
       */
      get unhandledMessage() {
        return this._unhandledMessage;
      }
      /**
       * A signal proxied from the kernel emitted for any kernel message.
       *
       * #### Notes
       * The behavior is undefined if the message is modified during message
       * handling. As such, it should be treated as read-only.
       */
      get anyMessage() {
        return this._anyMessage;
      }
      /**
       * A signal emitted when a session property changes.
       */
      get propertyChanged() {
        return this._propertyChanged;
      }
      /**
       * Get the session id.
       */
      get id() {
        return this._id;
      }
      /**
       * Get the session kernel connection object.
       *
       * #### Notes
       * This is a read-only property, and can be altered by [changeKernel].
       */
      get kernel() {
        return this._kernel;
      }
      /**
       * Get the session path.
       */
      get path() {
        return this._path;
      }
      /**
       * Get the session type.
       */
      get type() {
        return this._type;
      }
      /**
       * Get the session name.
       */
      get name() {
        return this._name;
      }
      /**
       * Get the model associated with the session.
       */
      get model() {
        return {
          id: this.id,
          kernel: this.kernel && { id: this.kernel.id, name: this.kernel.name },
          path: this._path,
          type: this._type,
          name: this._name
        };
      }
      /**
       * Test whether the session has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Update the session based on a session model from the server.
       *
       * #### Notes
       * This only updates this session connection instance. Use `setPath`,
       * `setName`, `setType`, and `changeKernel` to change the session values on
       * the server.
       */
      update(model) {
        const oldModel = this.model;
        this._path = model.path;
        this._name = model.name;
        this._type = model.type;
        if (this._kernel === null && model.kernel !== null || this._kernel !== null && model.kernel === null || this._kernel !== null && model.kernel !== null && this._kernel.id !== model.kernel.id) {
          if (this._kernel !== null) {
            this._kernel.dispose();
          }
          const oldValue = this._kernel || null;
          this.setupKernel(model.kernel);
          const newValue = this._kernel || null;
          this._kernelChanged.emit({ name: "kernel", oldValue, newValue });
        }
        this._handleModelChange(oldModel);
      }
      /**
       * Dispose of the resources held by the session.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        if (this._kernel) {
          this._kernel.dispose();
          const oldValue = this._kernel;
          this._kernel = null;
          const newValue = this._kernel;
          this._kernelChanged.emit({ name: "kernel", oldValue, newValue });
        }
        signaling_1.Signal.clearData(this);
      }
      /**
       * Change the session path.
       *
       * @param path - The new session path.
       *
       * @returns A promise that resolves when the session has renamed.
       *
       * #### Notes
       * This uses the Jupyter REST API, and the response is validated.
       * The promise is fulfilled on a valid response and rejected otherwise.
       */
      async setPath(path2) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ path: path2 });
      }
      /**
       * Change the session name.
       */
      async setName(name2) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ name: name2 });
      }
      /**
       * Change the session type.
       */
      async setType(type) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ type });
      }
      /**
       * Change the kernel.
       *
       * @param options - The name or id of the new kernel.
       *
       * #### Notes
       * This shuts down the existing kernel and creates a new kernel,
       * keeping the existing session ID and session path.
       */
      async changeKernel(options) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ kernel: options });
        return this.kernel;
      }
      /**
       * Kill the kernel and shutdown the session.
       *
       * @returns - The promise fulfilled on a valid response from the server.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/sessions), and validates the response.
       * Disposes of the session and emits a [sessionDied] signal on success.
       */
      async shutdown() {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await (0, restapi_1.shutdownSession)(this.id, this.serverSettings);
        this.dispose();
      }
      /**
       * Create a new kernel connection and connect to its signals.
       *
       * #### Notes
       * This method is not meant to be subclassed.
       */
      setupKernel(model) {
        if (model === null) {
          this._kernel = null;
          return;
        }
        const kc = this._connectToKernel({
          ...this._kernelConnectionOptions,
          model,
          username: this._username,
          clientId: this._clientId,
          serverSettings: this.serverSettings
        });
        this._kernel = kc;
        kc.statusChanged.connect(this.onKernelStatus, this);
        kc.connectionStatusChanged.connect(this.onKernelConnectionStatus, this);
        kc.pendingInput.connect(this.onPendingInput, this);
        kc.unhandledMessage.connect(this.onUnhandledMessage, this);
        kc.iopubMessage.connect(this.onIOPubMessage, this);
        kc.anyMessage.connect(this.onAnyMessage, this);
      }
      /**
       * Handle to changes in the Kernel status.
       */
      onKernelStatus(sender, state) {
        this._statusChanged.emit(state);
      }
      /**
       * Handle to changes in the Kernel status.
       */
      onKernelConnectionStatus(sender, state) {
        this._connectionStatusChanged.emit(state);
      }
      /**
       * Handle a change in the pendingInput.
       */
      onPendingInput(sender, state) {
        this._pendingInput.emit(state);
      }
      /**
       * Handle iopub kernel messages.
       */
      onIOPubMessage(sender, msg) {
        this._iopubMessage.emit(msg);
      }
      /**
       * Handle unhandled kernel messages.
       */
      onUnhandledMessage(sender, msg) {
        this._unhandledMessage.emit(msg);
      }
      /**
       * Handle any kernel messages.
       */
      onAnyMessage(sender, args) {
        this._anyMessage.emit(args);
      }
      /**
       * Send a PATCH to the server, updating the session path or the kernel.
       */
      async _patch(body) {
        const model = await (0, restapi_1.updateSession)({ ...body, id: this._id }, this.serverSettings);
        this.update(model);
        return model;
      }
      /**
       * Handle a change to the model.
       */
      _handleModelChange(oldModel) {
        if (oldModel.name !== this._name) {
          this._propertyChanged.emit("name");
        }
        if (oldModel.type !== this._type) {
          this._propertyChanged.emit("type");
        }
        if (oldModel.path !== this._path) {
          this._propertyChanged.emit("path");
        }
      }
    };
    exports2.SessionConnection = SessionConnection;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/session/manager.js
var require_manager3 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/session/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionManager = void 0;
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var serverconnection_1 = require_serverconnection();
    var basemanager_1 = require_basemanager();
    var default_1 = require_default2();
    var restapi_1 = require_restapi3();
    var SessionManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new session manager.
       *
       * @param options - The default options for each session.
       */
      constructor(options) {
        var _a;
        super(options);
        this._isReady = false;
        this._sessionConnections = /* @__PURE__ */ new Set();
        this._models = /* @__PURE__ */ new Map();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._connectToKernel = (options2) => {
          return this._kernelManager.connectTo(options2);
        };
        this._kernelManager = options.kernelManager;
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:SessionManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          if (this._kernelManager.isActive) {
            await this._kernelManager.ready;
          }
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running sessions change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._models.clear();
        this._sessionConnections.forEach((x) => x.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /*
       * Connect to a running session.  See also [[connectToSession]].
       */
      connectTo(options) {
        const sessionConnection = new default_1.SessionConnection({
          ...options,
          connectToKernel: this._connectToKernel,
          serverSettings: this.serverSettings
        });
        this._onStarted(sessionConnection);
        if (!this._models.has(options.model.id)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return sessionConnection;
      }
      /**
       * Create an iterator over the most recent running sessions.
       *
       * @returns A new iterator over the running sessions.
       */
      running() {
        return this._models.values();
      }
      /**
       * Force a refresh of the running sessions.
       *
       * @returns A promise that with the list of running sessions.
       *
       * #### Notes
       * This is not typically meant to be called by the user, since the
       * manager maintains its own internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Start a new session.  See also [[startNewSession]].
       *
       * @param createOptions - Options for creating the session
       *
       * @param connectOptions - Options for connecting to the session
       */
      async startNew(createOptions, connectOptions = {}) {
        const model = await (0, restapi_1.startSession)(createOptions, this.serverSettings);
        await this.refreshRunning();
        return this.connectTo({ ...connectOptions, model });
      }
      /**
       * Shut down a session by id.
       */
      async shutdown(id) {
        await (0, restapi_1.shutdownSession)(id, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all sessions.
       *
       * @returns A promise that resolves when all of the kernels are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all([...this._models.keys()].map((id) => (0, restapi_1.shutdownSession)(id, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Find a session associated with a path and stop it if it is the only session
       * using that kernel.
       *
       * @param path - The path in question.
       *
       * @returns A promise that resolves when the relevant sessions are stopped.
       */
      async stopIfNeeded(path2) {
        try {
          const sessions = await (0, restapi_1.listRunning)(this.serverSettings);
          const matches2 = sessions.filter((value) => value.path === path2);
          if (matches2.length === 1) {
            const id = matches2[0].id;
            await this.shutdown(id);
          }
        } catch (error) {
        }
      }
      /**
       * Find a session by id.
       */
      async findById(id) {
        if (this._models.has(id)) {
          return this._models.get(id);
        }
        await this.refreshRunning();
        return this._models.get(id);
      }
      /**
       * Find a session by path.
       */
      async findByPath(path2) {
        for (const m of this._models.values()) {
          if (m.path === path2) {
            return m;
          }
        }
        await this.refreshRunning();
        for (const m of this._models.values()) {
          if (m.path === path2) {
            return m;
          }
        }
        return void 0;
      }
      /**
       * Execute a request to the server to poll running kernels and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof serverconnection_1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        if (this._models.size === models.length && models.every((model) => {
          var _a2, _b2, _c, _d;
          const existing = this._models.get(model.id);
          if (!existing) {
            return false;
          }
          return ((_a2 = existing.kernel) === null || _a2 === void 0 ? void 0 : _a2.id) === ((_b2 = model.kernel) === null || _b2 === void 0 ? void 0 : _b2.id) && ((_c = existing.kernel) === null || _c === void 0 ? void 0 : _c.name) === ((_d = model.kernel) === null || _d === void 0 ? void 0 : _d.name) && existing.name === model.name && existing.path === model.path && existing.type === model.type;
        })) {
          return;
        }
        this._models = new Map(models.map((x) => [x.id, x]));
        this._sessionConnections.forEach((sc) => {
          if (this._models.has(sc.id)) {
            sc.update(this._models.get(sc.id));
          } else {
            sc.dispose();
          }
        });
        this._runningChanged.emit(models);
      }
      /**
       * Handle a session starting.
       */
      _onStarted(sessionConnection) {
        this._sessionConnections.add(sessionConnection);
        sessionConnection.disposed.connect(this._onDisposed, this);
        sessionConnection.propertyChanged.connect(this._onChanged, this);
        sessionConnection.kernelChanged.connect(this._onChanged, this);
      }
      _onDisposed(sessionConnection) {
        this._sessionConnections.delete(sessionConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      _onChanged() {
        void this.refreshRunning().catch(() => {
        });
      }
    };
    exports2.SessionManager = SessionManager;
    (function(SessionManager2) {
      class NoopManager extends SessionManager2 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * Start a new session - throw an error since it is not supported.
         */
        async startNew(createOptions, connectOptions = {}) {
          return Promise.reject(new Error("Not implemented in no-op Session Manager"));
        }
        /*
         * Connect to a running session - throw an error since it is not supported.
         */
        connectTo(options) {
          throw Error("Not implemented in no-op Session Manager");
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Shut down a session by id - throw an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Session Manager"));
        }
        /**
         * Execute a request to the server to poll running sessions and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      SessionManager2.NoopManager = NoopManager;
    })(SessionManager || (exports2.SessionManager = SessionManager = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/session/index.js
var require_session2 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/session/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionAPI = exports2.Session = void 0;
    var Session = __importStar2(require_session());
    exports2.Session = Session;
    var SessionAPI = __importStar2(require_restapi3());
    exports2.SessionAPI = SessionAPI;
    __exportStar2(require_manager3(), exports2);
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/setting/index.js
var require_setting = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/setting/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SettingManager = void 0;
    var coreutils_12 = require_lib2();
    var statedb_1 = require_lib();
    var serverconnection_1 = require_serverconnection();
    var SERVICE_SETTINGS_URL = "api/settings";
    var SettingManager = class extends statedb_1.DataConnector {
      /**
       * Create a new setting manager.
       */
      constructor(options = {}) {
        var _a;
        super();
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch a plugin's settings.
       *
       * @param id - The plugin's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async fetch(id) {
        if (!id) {
          throw new Error("Plugin `id` parameter is required for settings fetch.");
        }
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private36.url(base, id);
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        return response.json();
      }
      /**
       * Fetch the list of all plugin setting bundles.
       *
       * @returns A promise that resolves if successful.
       */
      async list(query) {
        var _a, _b, _c, _d;
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private36.url(base, "", query === "ids");
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          throw new ResponseError(response);
        }
        const json = await response.json();
        const ids = (_b = (_a = json === null || json === void 0 ? void 0 : json["settings"]) === null || _a === void 0 ? void 0 : _a.map((plugin) => plugin.id)) !== null && _b !== void 0 ? _b : [];
        let values = [];
        if (!query) {
          values = (_d = (_c = json === null || json === void 0 ? void 0 : json["settings"]) === null || _c === void 0 ? void 0 : _c.map((plugin) => {
            plugin.data = { composite: {}, user: {} };
            return plugin;
          })) !== null && _d !== void 0 ? _d : [];
        }
        return { ids, values };
      }
      /**
       * Save a plugin's settings.
       *
       * @param id - The plugin's ID.
       *
       * @param raw - The user setting values as a raw string of JSON with comments.
       *
       * @returns A promise that resolves if successful.
       */
      async save(id, raw) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private36.url(base, id);
        const init = { body: JSON.stringify({ raw }), method: "PUT" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          throw new ResponseError(response);
        }
      }
    };
    exports2.SettingManager = SettingManager;
    var Private36;
    (function(Private37) {
      function url(base, id, idsOnly) {
        const idsOnlyParam = idsOnly ? coreutils_12.URLExt.objectToQueryString({ ids_only: true }) : "";
        const settingsBase = coreutils_12.URLExt.join(base, SERVICE_SETTINGS_URL);
        const result = coreutils_12.URLExt.join(settingsBase, id);
        if (!result.startsWith(settingsBase)) {
          throw new Error("Can only be used for workspaces requests");
        }
        return `${result}${idsOnlyParam}`;
      }
      Private37.url = url;
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/terminal/restapi.js
var require_restapi4 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/terminal/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shutdownTerminal = exports2.listRunning = exports2.startNew = exports2.isAvailable = exports2.TERMINAL_SERVICE_URL = void 0;
    var coreutils_12 = require_lib2();
    var serverconnection_1 = require_serverconnection();
    exports2.TERMINAL_SERVICE_URL = "api/terminals";
    function isAvailable() {
      const available = String(coreutils_12.PageConfig.getOption("terminalsAvailable"));
      return available.toLowerCase() === "true";
    }
    exports2.isAvailable = isAvailable;
    async function startNew(settings = serverconnection_1.ServerConnection.makeSettings(), name2, cwd) {
      Private36.errorIfNotAvailable();
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify({ name: name2, cwd })
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      return data;
    }
    exports2.startNew = startNew;
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      Private36.errorIfNotAvailable();
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error("Invalid terminal list");
      }
      return data;
    }
    exports2.listRunning = listRunning;
    async function shutdownTerminal(name2, settings = serverconnection_1.ServerConnection.makeSettings()) {
      var _a;
      Private36.errorIfNotAvailable();
      const workspacesBase = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const url = coreutils_12.URLExt.join(workspacesBase, name2);
      if (!url.startsWith(workspacesBase)) {
        throw new Error("Can only be used for terminal requests");
      }
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const data = await response.json();
        const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The terminal session "${name2}"" does not exist on the server`;
        console.warn(msg);
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownTerminal = shutdownTerminal;
    var Private36;
    (function(Private37) {
      function errorIfNotAvailable() {
        if (!isAvailable()) {
          throw new Error("Terminals Unavailable");
        }
      }
      Private37.errorIfNotAvailable = errorIfNotAvailable;
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/terminal/terminal.js
var require_terminal = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/terminal/terminal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAvailable = void 0;
    var restapi_1 = require_restapi4();
    Object.defineProperty(exports2, "isAvailable", { enumerable: true, get: function() {
      return restapi_1.isAvailable;
    } });
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/terminal/default.js
var require_default3 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/terminal/default.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalConnection = void 0;
    var coreutils_12 = require_lib2();
    var coreutils_2 = require_dist();
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib3();
    var restapi_1 = require_restapi4();
    var TerminalConnection = class {
      /**
       * Construct a new terminal session.
       */
      constructor(options) {
        var _a;
        this._createSocket = () => {
          this._errorIfDisposed();
          this._clearSocket();
          this._updateConnectionStatus("connecting");
          const name2 = this._name;
          const settings = this.serverSettings;
          let url = coreutils_12.URLExt.join(settings.wsUrl, "terminals", "websocket", encodeURIComponent(name2));
          const token = settings.token;
          if (settings.appendToken && token !== "") {
            url = url + `?token=${encodeURIComponent(token)}`;
          }
          this._ws = new settings.WebSocket(url);
          this._ws.onmessage = this._onWSMessage;
          this._ws.onclose = this._onWSClose;
          this._ws.onerror = this._onWSClose;
        };
        this._onWSMessage = (event) => {
          if (this._isDisposed) {
            return;
          }
          const data = JSON.parse(event.data);
          if (data[0] === "disconnect") {
            this.dispose();
          }
          if (this._connectionStatus === "connecting") {
            if (data[0] === "setup") {
              this._updateConnectionStatus("connected");
            }
            return;
          }
          this._messageReceived.emit({
            type: data[0],
            content: data.slice(1)
          });
        };
        this._onWSClose = (event) => {
          console.warn(`Terminal websocket closed: ${event.code}`);
          if (!this.isDisposed) {
            this._reconnect();
          }
        };
        this._connectionStatus = "connecting";
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this._messageReceived = new signaling_1.Signal(this);
        this._reconnectTimeout = null;
        this._ws = null;
        this._noOp = () => {
        };
        this._reconnectLimit = 7;
        this._reconnectAttempt = 0;
        this._pendingMessages = [];
        this._name = options.model.name;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._createSocket();
      }
      /**
       * A signal emitted when the session is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when a message is received from the server.
       */
      get messageReceived() {
        return this._messageReceived;
      }
      /**
       * Get the name of the terminal session.
       */
      get name() {
        return this._name;
      }
      /**
       * Get the model for the terminal session.
       */
      get model() {
        return { name: this._name };
      }
      /**
       * Test whether the session is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the session.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        this._updateConnectionStatus("disconnected");
        this._clearSocket();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Send a message to the terminal session.
       *
       * #### Notes
       * If the connection is down, the message will be queued for sending when
       * the connection comes back up.
       */
      send(message) {
        this._sendMessage(message);
      }
      /**
       * Send a message on the websocket, or possibly queue for later sending.
       *
       * @param queue - whether to queue the message if it cannot be sent
       */
      _sendMessage(message, queue = true) {
        if (this._isDisposed || !message.content) {
          return;
        }
        if (this.connectionStatus === "connected" && this._ws) {
          const msg = [message.type, ...message.content];
          this._ws.send(JSON.stringify(msg));
        } else if (queue) {
          this._pendingMessages.push(message);
        } else {
          throw new Error(`Could not send message: ${JSON.stringify(message)}`);
        }
      }
      /**
       * Send pending messages to the kernel.
       */
      _sendPending() {
        while (this.connectionStatus === "connected" && this._pendingMessages.length > 0) {
          this._sendMessage(this._pendingMessages[0], false);
          this._pendingMessages.shift();
        }
      }
      /**
       * Reconnect to a terminal.
       *
       * #### Notes
       * This may try multiple times to reconnect to a terminal, and will sever
       * any existing connection.
       */
      reconnect() {
        this._errorIfDisposed();
        const result = new coreutils_2.PromiseDelegate();
        const fulfill = (sender, status) => {
          if (status === "connected") {
            result.resolve();
            this.connectionStatusChanged.disconnect(fulfill, this);
          } else if (status === "disconnected") {
            result.reject(new Error("Terminal connection disconnected"));
            this.connectionStatusChanged.disconnect(fulfill, this);
          }
        };
        this.connectionStatusChanged.connect(fulfill, this);
        this._reconnectAttempt = 0;
        this._reconnect();
        return result.promise;
      }
      /**
       * Attempt a connection if we have not exhausted connection attempts.
       */
      _reconnect() {
        this._errorIfDisposed();
        clearTimeout(this._reconnectTimeout);
        if (this._reconnectAttempt < this._reconnectLimit) {
          this._updateConnectionStatus("connecting");
          const timeout = Private36.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
          console.error(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`);
          this._reconnectTimeout = setTimeout(this._createSocket, timeout);
          this._reconnectAttempt += 1;
        } else {
          this._updateConnectionStatus("disconnected");
        }
        this._clearSocket();
      }
      /**
       * Forcefully clear the socket state.
       *
       * #### Notes
       * This will clear all socket state without calling any handlers and will
       * not update the connection status. If you call this method, you are
       * responsible for updating the connection status as needed and recreating
       * the socket if you plan to reconnect.
       */
      _clearSocket() {
        if (this._ws !== null) {
          this._ws.onopen = this._noOp;
          this._ws.onclose = this._noOp;
          this._ws.onerror = this._noOp;
          this._ws.onmessage = this._noOp;
          this._ws.close();
          this._ws = null;
        }
      }
      /**
       * Shut down the terminal session.
       */
      async shutdown() {
        await (0, restapi_1.shutdownTerminal)(this.name, this.serverSettings);
        this.dispose();
      }
      /**
       * Clone the current terminal connection.
       */
      clone() {
        return new TerminalConnection(this);
      }
      /**
       * Handle connection status changes.
       */
      _updateConnectionStatus(connectionStatus) {
        if (this._connectionStatus === connectionStatus) {
          return;
        }
        this._connectionStatus = connectionStatus;
        if (connectionStatus !== "connecting") {
          this._reconnectAttempt = 0;
          clearTimeout(this._reconnectTimeout);
        }
        if (connectionStatus === "connected") {
          this._sendPending();
        }
        this._connectionStatusChanged.emit(connectionStatus);
      }
      /**
       * Utility function to throw an error if this instance is disposed.
       */
      _errorIfDisposed() {
        if (this.isDisposed) {
          throw new Error("Terminal connection is disposed");
        }
      }
      /**
       * A signal emitted when the terminal connection status changes.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * The current connection status of the terminal connection.
       */
      get connectionStatus() {
        return this._connectionStatus;
      }
    };
    exports2.TerminalConnection = TerminalConnection;
    var Private36;
    (function(Private37) {
      function getTermUrl(baseUrl, name2) {
        return coreutils_12.URLExt.join(baseUrl, restapi_1.TERMINAL_SERVICE_URL, encodeURIComponent(name2));
      }
      Private37.getTermUrl = getTermUrl;
      function getRandomIntInclusive(min, max2) {
        min = Math.ceil(min);
        max2 = Math.floor(max2);
        return Math.floor(Math.random() * (max2 - min + 1)) + min;
      }
      Private37.getRandomIntInclusive = getRandomIntInclusive;
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/terminal/manager.js
var require_manager4 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/terminal/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalManager = void 0;
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib3();
    var basemanager_1 = require_basemanager();
    var restapi_1 = require_restapi4();
    var default_1 = require_default3();
    var TerminalManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new terminal manager.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._names = [];
        this._terminalConnections = /* @__PURE__ */ new Set();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        if (!this.isAvailable()) {
          this._ready = Promise.reject("Terminals unavailable");
          this._ready.catch((_) => void 0);
          return;
        }
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:TerminalManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running terminals change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._names.length = 0;
        this._terminalConnections.forEach((x) => x.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /**
       * Whether the terminal service is available.
       */
      isAvailable() {
        return (0, restapi_1.isAvailable)();
      }
      /*
       * Connect to a running terminal.
       *
       * @param options - The options used to connect to the terminal.
       *
       * @returns The new terminal connection instance.
       *
       * #### Notes
       * The manager `serverSettings` will be used.
       */
      connectTo(options) {
        const terminalConnection = new default_1.TerminalConnection({
          ...options,
          serverSettings: this.serverSettings
        });
        this._onStarted(terminalConnection);
        if (!this._names.includes(options.model.name)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return terminalConnection;
      }
      /**
       * Create an iterator over the most recent running terminals.
       *
       * @returns A new iterator over the running terminals.
       */
      running() {
        return this._models[Symbol.iterator]();
      }
      /**
       * Force a refresh of the running terminals.
       *
       * @returns A promise that with the list of running terminals.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Create a new terminal session.
       *
       * @param options - The options used to create the terminal.
       *
       * @returns A promise that resolves with the terminal connection instance.
       *
       * #### Notes
       * The manager `serverSettings` will be used unless overridden in the
       * options.
       */
      async startNew(options) {
        const model = await (0, restapi_1.startNew)(this.serverSettings, options === null || options === void 0 ? void 0 : options.name, options === null || options === void 0 ? void 0 : options.cwd);
        await this.refreshRunning();
        return this.connectTo({ model });
      }
      /**
       * Shut down a terminal session by name.
       */
      async shutdown(name2) {
        await (0, restapi_1.shutdownTerminal)(name2, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all terminal sessions.
       *
       * @returns A promise that resolves when all of the sessions are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all(this._names.map((name2) => (0, restapi_1.shutdownTerminal)(name2, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Execute a request to the server to poll running terminals and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof __1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        const names = models.map(({ name: name2 }) => name2).sort();
        if (names === this._names) {
          return;
        }
        this._names = names;
        this._terminalConnections.forEach((tc) => {
          if (!names.includes(tc.name)) {
            tc.dispose();
          }
        });
        this._runningChanged.emit(this._models);
      }
      /**
       * Handle a session starting.
       */
      _onStarted(terminalConnection) {
        this._terminalConnections.add(terminalConnection);
        terminalConnection.disposed.connect(this._onDisposed, this);
      }
      /**
       * Handle a session terminating.
       */
      _onDisposed(terminalConnection) {
        this._terminalConnections.delete(terminalConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      get _models() {
        return this._names.map((name2) => {
          return { name: name2 };
        });
      }
    };
    exports2.TerminalManager = TerminalManager;
    (function(TerminalManager2) {
      class NoopManager extends TerminalManager2 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Create a new terminal session - throw an error since it is not supported.
         *
         */
        async startNew(options) {
          return Promise.reject(new Error("Not implemented in no-op Terminal Manager"));
        }
        /*
         * Connect to a running terminal - throw an error since it is not supported.
         */
        connectTo(options) {
          throw Error("Not implemented in no-op Terminal Manager");
        }
        /**
         * Shut down a session by id - throw an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Terminal Manager"));
        }
        /**
         * Execute a request to the server to poll running sessions and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      TerminalManager2.NoopManager = NoopManager;
    })(TerminalManager || (exports2.TerminalManager = TerminalManager = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/terminal/index.js
var require_terminal2 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/terminal/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalAPI = exports2.Terminal = void 0;
    var Terminal = __importStar2(require_terminal());
    exports2.Terminal = Terminal;
    var TerminalAPI = __importStar2(require_restapi4());
    exports2.TerminalAPI = TerminalAPI;
    __exportStar2(require_manager4(), exports2);
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/user/index.js
var require_user = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/user/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserManager = void 0;
    var coreutils_12 = require_lib2();
    var coreutils_2 = require_dist();
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var serverconnection_1 = require_serverconnection();
    var basemanager_1 = require_basemanager();
    var SERVICE_USER_URL = "api/me";
    var SERVICE_ID = "@jupyterlab/services:UserManager#user";
    var UserManager = class extends basemanager_1.BaseManager {
      /**
       * Create a new user manager.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._userChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._ready = this.requestUser().then(() => {
          if (this.isDisposed) {
            return;
          }
          this._isReady = true;
        }).catch((_) => (
          // Return a promise that will never resolve, so user service is never ready
          // This typically occurs when the backend has no user service
          new Promise(() => {
          })
        ));
        this._pollSpecs = new polling_1.Poll({
          auto: false,
          factory: () => this.requestUser(),
          frequency: {
            interval: 61 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: SERVICE_ID,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        void this.ready.then(() => {
          void this._pollSpecs.start();
        });
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * Get the most recently fetched identity.
       */
      get identity() {
        return this._identity;
      }
      /**
       * Get the most recently fetched permissions.
       */
      get permissions() {
        return this._permissions;
      }
      /**
       * A signal emitted when the user changes.
       */
      get userChanged() {
        return this._userChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        this._pollSpecs.dispose();
        super.dispose();
      }
      /**
       * Force a refresh of the specs from the server.
       *
       * @returns A promise that resolves when the specs are fetched.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshUser() {
        await this._pollSpecs.refresh();
        await this._pollSpecs.tick;
      }
      /**
       * Execute a request to the server to poll the user and update state.
       */
      async requestUser() {
        if (this.isDisposed) {
          return;
        }
        const { baseUrl } = this.serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const url = coreutils_12.URLExt.join(baseUrl, SERVICE_USER_URL);
        const response = await makeRequest(url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        const oldUser = {
          identity: this._identity,
          permissions: this._permissions
        };
        const newUser = await response.json();
        const identity = newUser.identity;
        const { localStorage } = window;
        const data = localStorage.getItem(SERVICE_ID);
        if (data && (!identity.initials || !identity.color)) {
          const localUser = JSON.parse(data);
          identity.initials = identity.initials || localUser.initials || identity.name.substring(0, 1);
          identity.color = identity.color || localUser.color || Private36.getRandomColor();
        }
        if (!coreutils_2.JSONExt.deepEqual(newUser, oldUser)) {
          this._identity = identity;
          this._permissions = newUser.permissions;
          localStorage.setItem(SERVICE_ID, JSON.stringify(identity));
          this._userChanged.emit(newUser);
        }
      }
    };
    exports2.UserManager = UserManager;
    var Private36;
    (function(Private37) {
      const userColors = [
        "var(--jp-collaborator-color1)",
        "var(--jp-collaborator-color2)",
        "var(--jp-collaborator-color3)",
        "var(--jp-collaborator-color4)",
        "var(--jp-collaborator-color5)",
        "var(--jp-collaborator-color6)",
        "var(--jp-collaborator-color7)"
      ];
      Private37.getRandomColor = () => userColors[Math.floor(Math.random() * userColors.length)];
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/workspace/index.js
var require_workspace = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/workspace/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceManager = void 0;
    var coreutils_12 = require_lib2();
    var statedb_1 = require_lib();
    var serverconnection_1 = require_serverconnection();
    var SERVICE_WORKSPACES_URL = "api/workspaces";
    var WorkspaceManager = class extends statedb_1.DataConnector {
      /**
       * Create a new workspace manager.
       */
      constructor(options = {}) {
        var _a;
        super();
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch a workspace.
       *
       * @param id - The workspace's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async fetch(id) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private36.url(base, id);
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        return response.json();
      }
      /**
       * Fetch the list of workspace IDs that exist on the server.
       *
       * @returns A promise that resolves if successful.
       */
      async list() {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private36.url(base, "");
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        const result = await response.json();
        return result.workspaces;
      }
      /**
       * Remove a workspace from the server.
       *
       * @param id - The workspaces's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async remove(id) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private36.url(base, id);
        const init = { method: "DELETE" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          const err = await ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Save a workspace.
       *
       * @param id - The workspace's ID.
       *
       * @param workspace - The workspace being saved.
       *
       * @returns A promise that resolves if successful.
       */
      async save(id, workspace) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private36.url(base, id);
        const init = { body: JSON.stringify(workspace), method: "PUT" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          const err = await ResponseError.create(response);
          throw err;
        }
      }
    };
    exports2.WorkspaceManager = WorkspaceManager;
    var Private36;
    (function(Private37) {
      function url(base, id) {
        const workspacesBase = coreutils_12.URLExt.join(base, SERVICE_WORKSPACES_URL);
        const result = coreutils_12.URLExt.join(workspacesBase, id);
        if (!result.startsWith(workspacesBase)) {
          throw new Error("Can only be used for workspaces requests");
        }
        return result;
      }
      Private37.url = url;
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/manager.js
var require_manager5 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServiceManager = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var builder_1 = require_builder();
    var contents_1 = require_contents();
    var event_1 = require_event();
    var kernel_1 = require_kernel2();
    var kernelspec_1 = require_kernelspec2();
    var nbconvert_1 = require_nbconvert();
    var serverconnection_1 = require_serverconnection();
    var session_1 = require_session2();
    var setting_1 = require_setting();
    var terminal_1 = require_terminal2();
    var user_1 = require_user();
    var workspace_1 = require_workspace();
    var ServiceManager = class {
      /**
       * Construct a new services provider.
       */
      constructor(options = {}) {
        var _a, _b;
        this._isDisposed = false;
        this._connectionFailure = new signaling_1.Signal(this);
        this._isReady = false;
        const defaultDrive = options.defaultDrive;
        const serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        const standby = (_b = options.standby) !== null && _b !== void 0 ? _b : "when-hidden";
        const normalized = { defaultDrive, serverSettings, standby };
        this.serverSettings = serverSettings;
        this.contents = options.contents || new contents_1.ContentsManager(normalized);
        this.events = options.events || new event_1.EventManager(normalized);
        this.kernels = options.kernels || new kernel_1.KernelManager(normalized);
        this.sessions = options.sessions || new session_1.SessionManager({
          ...normalized,
          kernelManager: this.kernels
        });
        this.settings = options.settings || new setting_1.SettingManager(normalized);
        this.terminals = options.terminals || new terminal_1.TerminalManager(normalized);
        this.builder = options.builder || new builder_1.BuildManager(normalized);
        this.workspaces = options.workspaces || new workspace_1.WorkspaceManager(normalized);
        this.nbconvert = options.nbconvert || new nbconvert_1.NbConvertManager(normalized);
        this.kernelspecs = options.kernelspecs || new kernelspec_1.KernelSpecManager(normalized);
        this.user = options.user || new user_1.UserManager(normalized);
        this.kernelspecs.connectionFailure.connect(this._onConnectionFailure, this);
        this.sessions.connectionFailure.connect(this._onConnectionFailure, this);
        this.terminals.connectionFailure.connect(this._onConnectionFailure, this);
        const readyList = [this.sessions.ready, this.kernelspecs.ready];
        if (this.terminals.isAvailable()) {
          readyList.push(this.terminals.ready);
        }
        this._readyPromise = Promise.all(readyList).then(() => {
          this._isReady = true;
        });
      }
      /**
       * A signal emitted when there is a connection failure with the kernel.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Test whether the service manager is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
        this.contents.dispose();
        this.events.dispose();
        this.sessions.dispose();
        this.terminals.dispose();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._readyPromise;
      }
      _onConnectionFailure(sender, err) {
        this._connectionFailure.emit(err);
      }
    };
    exports2.ServiceManager = ServiceManager;
  }
});

// ../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/@jupyterlab/translation/node_modules/@jupyterlab/services/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_basemanager(), exports2);
    __exportStar2(require_config(), exports2);
    __exportStar2(require_contents(), exports2);
    __exportStar2(require_event(), exports2);
    __exportStar2(require_kernel2(), exports2);
    __exportStar2(require_kernelspec2(), exports2);
    __exportStar2(require_manager5(), exports2);
    __exportStar2(require_serverconnection(), exports2);
    __exportStar2(require_session2(), exports2);
    __exportStar2(require_setting(), exports2);
    __exportStar2(require_terminal2(), exports2);
    __exportStar2(require_user(), exports2);
    __exportStar2(require_workspace(), exports2);
    __exportStar2(require_nbconvert(), exports2);
  }
});

// ../../node_modules/@jupyterlab/translation/lib/server.js
var import_services;
var init_server = __esm({
  "../../node_modules/@jupyterlab/translation/lib/server.js"() {
    import_services = __toESM(require_lib3());
  }
});

// ../../node_modules/@jupyterlab/translation/lib/tokens.js
var import_coreutils3, ITranslatorConnector, ITranslator;
var init_tokens = __esm({
  "../../node_modules/@jupyterlab/translation/lib/tokens.js"() {
    import_coreutils3 = __toESM(require_dist());
    init_server();
    ITranslatorConnector = new import_coreutils3.Token("@jupyterlab/translation:ITranslatorConnector", "A service to connect to the server translation endpoint.");
    ITranslator = new import_coreutils3.Token("@jupyterlab/translation:ITranslator", "A service to translate strings.");
  }
});

// ../../node_modules/@jupyterlab/translation/lib/manager.js
var init_manager = __esm({
  "../../node_modules/@jupyterlab/translation/lib/manager.js"() {
    init_gettext();
    init_tokens();
    init_utils();
  }
});

// ../../node_modules/@jupyterlab/translation/lib/index.js
var init_lib = __esm({
  "../../node_modules/@jupyterlab/translation/lib/index.js"() {
    init_base();
    init_gettext();
    init_manager();
    init_server();
    init_tokens();
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/debug/bad.svg
var bad_default;
var init_bad = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/debug/bad.svg"() {
    bad_default = "/build/_assets/bad-FQMIYYET.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/debug/blank.svg
var blank_default;
var init_blank = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/debug/blank.svg"() {
    blank_default = "/build/_assets/blank-US55MPOI.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/refresh.svg
var refresh_default;
var init_refresh = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/refresh.svg"() {
    refresh_default = "/build/_assets/refresh-3LT7D5B7.svg";
  }
});

// ../../node_modules/free-style/dist.es2015/index.js
var dist_exports = {};
__export(dist_exports, {
  Cache: () => Cache,
  FreeStyle: () => FreeStyle,
  Rule: () => Rule,
  Selector: () => Selector,
  Style: () => Style,
  create: () => create
});
function escape(str) {
  return str.replace(/[ !#$%&()*+,./;<=>?@[\]^`{|}~"'\\]/g, "\\$&");
}
function hyphenate(propertyName) {
  return propertyName.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`).replace(/^ms-/, "-ms-");
}
function stringHash(str) {
  let value = 5381;
  let len = str.length;
  while (len--)
    value = value * 33 ^ str.charCodeAt(len);
  return (value >>> 0).toString(36);
}
function styleToString(key2, value) {
  if (value && typeof value === "number" && !CSS_NUMBER[key2]) {
    return `${key2}:${value}px`;
  }
  return `${key2}:${value}`;
}
function sortTuples(value) {
  return value.sort((a, b) => a[0] > b[0] ? 1 : -1);
}
function parseStyles(styles, hasNestedStyles) {
  const properties = [];
  const nestedStyles = [];
  for (const key2 of Object.keys(styles)) {
    const name2 = key2.trim();
    const value = styles[key2];
    if (name2.charCodeAt(0) !== 36 && value != null) {
      if (typeof value === "object" && !Array.isArray(value)) {
        nestedStyles.push([name2, value]);
      } else {
        properties.push([hyphenate(name2), value]);
      }
    }
  }
  return {
    style: stringifyProperties(sortTuples(properties)),
    nested: hasNestedStyles ? nestedStyles : sortTuples(nestedStyles),
    isUnique: !!styles.$unique
  };
}
function stringifyProperties(properties) {
  return properties.map(([name2, value]) => {
    if (!Array.isArray(value))
      return styleToString(name2, value);
    return value.map((x) => styleToString(name2, x)).join(";");
  }).join(";");
}
function interpolate(selector, parent) {
  if (selector.indexOf("&") === -1)
    return `${parent} ${selector}`;
  return selector.replace(/&/g, parent);
}
function stylize(selector, styles, rulesList, stylesList, parent) {
  const { style, nested, isUnique } = parseStyles(styles, selector !== "");
  let pid = style;
  if (selector.charCodeAt(0) === 64) {
    const child = {
      selector,
      styles: [],
      rules: [],
      style: parent ? "" : style
    };
    rulesList.push(child);
    if (style && parent) {
      child.styles.push({ selector: parent, style, isUnique });
    }
    for (const [name2, value] of nested) {
      pid += name2 + stylize(name2, value, child.rules, child.styles, parent);
    }
  } else {
    const key2 = parent ? interpolate(selector, parent) : selector;
    if (style)
      stylesList.push({ selector: key2, style, isUnique });
    for (const [name2, value] of nested) {
      pid += name2 + stylize(name2, value, rulesList, stylesList, key2);
    }
  }
  return pid;
}
function composeStylize(cache2, pid, rulesList, stylesList, className, isStyle) {
  for (const { selector, style, isUnique } of stylesList) {
    const key2 = isStyle ? interpolate(selector, className) : selector;
    const id = isUnique ? `u\0${(++uniqueId).toString(36)}` : `s\0${pid}\0${style}`;
    const item = new Style(style, id);
    item.add(new Selector(key2, `k\0${pid}\0${key2}`));
    cache2.add(item);
  }
  for (const { selector, style, rules, styles } of rulesList) {
    const item = new Rule(selector, style, `r\0${pid}\0${selector}\0${style}`);
    composeStylize(item, pid, rules, styles, className, isStyle);
    cache2.add(item);
  }
}
function join(arr) {
  let res = "";
  for (let i = 0; i < arr.length; i++)
    res += arr[i];
  return res;
}
function key(pid, styles) {
  const key2 = `f${stringHash(pid)}`;
  if (!styles.$displayName)
    return key2;
  return `${styles.$displayName}_${key2}`;
}
function create(changes) {
  return new FreeStyle(`f${(++uniqueId).toString(36)}`, changes);
}
var uniqueId, CSS_NUMBER, CSS_NUMBER_KEYS, noopChanges, Cache, Selector, Style, Rule, FreeStyle;
var init_dist = __esm({
  "../../node_modules/free-style/dist.es2015/index.js"() {
    uniqueId = 0;
    CSS_NUMBER = /* @__PURE__ */ Object.create(null);
    CSS_NUMBER_KEYS = [
      "animation-iteration-count",
      "border-image-outset",
      "border-image-slice",
      "border-image-width",
      "box-flex",
      "box-flex-group",
      "box-ordinal-group",
      "column-count",
      "columns",
      "counter-increment",
      "counter-reset",
      "flex",
      "flex-grow",
      "flex-positive",
      "flex-shrink",
      "flex-negative",
      "flex-order",
      "font-weight",
      "grid-area",
      "grid-column",
      "grid-column-end",
      "grid-column-span",
      "grid-column-start",
      "grid-row",
      "grid-row-end",
      "grid-row-span",
      "grid-row-start",
      "line-clamp",
      "line-height",
      "opacity",
      "order",
      "orphans",
      "tab-size",
      "widows",
      "z-index",
      "zoom",
      // SVG properties.
      "fill-opacity",
      "flood-opacity",
      "stop-opacity",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width"
    ];
    for (const property of CSS_NUMBER_KEYS) {
      for (const prefix of ["-webkit-", "-ms-", "-moz-", "-o-", ""]) {
        CSS_NUMBER[prefix + property] = true;
      }
    }
    noopChanges = {
      add: () => void 0,
      change: () => void 0,
      remove: () => void 0
    };
    Cache = class {
      constructor(changes = noopChanges) {
        this.changes = changes;
        this.sheet = [];
        this.changeId = 0;
        this._keys = [];
        this._children = /* @__PURE__ */ Object.create(null);
        this._counters = /* @__PURE__ */ Object.create(null);
      }
      add(style) {
        const count = this._counters[style.id] || 0;
        const item = this._children[style.id] || style.clone();
        this._counters[style.id] = count + 1;
        if (count === 0) {
          this._children[item.id] = item;
          this._keys.push(item.id);
          this.sheet.push(item.getStyles());
          this.changeId++;
          this.changes.add(item, this._keys.length - 1);
        } else if (item instanceof Cache && style instanceof Cache) {
          const curIndex = this._keys.indexOf(style.id);
          const prevItemChangeId = item.changeId;
          item.merge(style);
          if (item.changeId !== prevItemChangeId) {
            this.sheet.splice(curIndex, 1, item.getStyles());
            this.changeId++;
            this.changes.change(item, curIndex, curIndex);
          }
        }
      }
      remove(style) {
        const count = this._counters[style.id];
        if (count) {
          this._counters[style.id] = count - 1;
          const item = this._children[style.id];
          const index = this._keys.indexOf(item.id);
          if (count === 1) {
            delete this._counters[style.id];
            delete this._children[style.id];
            this._keys.splice(index, 1);
            this.sheet.splice(index, 1);
            this.changeId++;
            this.changes.remove(item, index);
          } else if (item instanceof Cache && style instanceof Cache) {
            const prevChangeId = item.changeId;
            item.unmerge(style);
            if (item.changeId !== prevChangeId) {
              this.sheet.splice(index, 1, item.getStyles());
              this.changeId++;
              this.changes.change(item, index, index);
            }
          }
        }
      }
      values() {
        return this._keys.map((key2) => this._children[key2]);
      }
      merge(cache2) {
        for (const item of cache2.values())
          this.add(item);
        return this;
      }
      unmerge(cache2) {
        for (const item of cache2.values())
          this.remove(item);
        return this;
      }
      clone() {
        return new Cache().merge(this);
      }
    };
    Selector = class {
      constructor(selector, id) {
        this.selector = selector;
        this.id = id;
      }
      getStyles() {
        return this.selector;
      }
      clone() {
        return this;
      }
    };
    Style = class extends Cache {
      constructor(style, id) {
        super();
        this.style = style;
        this.id = id;
      }
      getStyles() {
        return `${this.sheet.join(",")}{${this.style}}`;
      }
      clone() {
        return new Style(this.style, this.id).merge(this);
      }
    };
    Rule = class extends Cache {
      constructor(rule, style, id) {
        super();
        this.rule = rule;
        this.style = style;
        this.id = id;
      }
      getStyles() {
        return `${this.rule}{${this.style}${join(this.sheet)}}`;
      }
      clone() {
        return new Rule(this.rule, this.style, this.id).merge(this);
      }
    };
    FreeStyle = class extends Cache {
      constructor(id, changes) {
        super(changes);
        this.id = id;
      }
      registerStyle(styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = stylize("&", styles, rulesList, stylesList);
        const id = key(pid, styles);
        const selector = `.${false ? id : escape(id)}`;
        composeStylize(this, pid, rulesList, stylesList, selector, true);
        return id;
      }
      registerKeyframes(keyframes) {
        return this.registerHashRule("@keyframes", keyframes);
      }
      registerHashRule(prefix, styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = stylize("", styles, rulesList, stylesList);
        const id = key(pid, styles);
        const selector = `${prefix} ${false ? id : escape(id)}`;
        const rule = new Rule(selector, "", `h\0${pid}\0${prefix}`);
        composeStylize(rule, pid, rulesList, stylesList, "", false);
        this.add(rule);
        return id;
      }
      registerRule(rule, styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = stylize(rule, styles, rulesList, stylesList);
        composeStylize(this, pid, rulesList, stylesList, "", false);
      }
      registerCss(styles) {
        return this.registerRule("", styles);
      }
      getStyles() {
        return join(this.sheet);
      }
      clone() {
        return new FreeStyle(this.id, this.changes).merge(this);
      }
    };
  }
});

// ../../node_modules/typestyle/lib/internal/formatting.js
var require_formatting = __commonJS({
  "../../node_modules/typestyle/lib/internal/formatting.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function convertToStyles(object) {
      var styles = {};
      for (var key2 in object) {
        var val = object[key2];
        if (key2 === "$nest") {
          var nested = val;
          for (var selector in nested) {
            var subproperties = nested[selector];
            styles[selector] = convertToStyles(subproperties);
          }
        } else if (key2 === "$debugName") {
          styles.$displayName = val;
        } else {
          styles[key2] = val;
        }
      }
      return styles;
    }
    exports2.convertToStyles = convertToStyles;
    function convertToKeyframes(frames) {
      var result = {};
      for (var offset in frames) {
        if (offset !== "$debugName") {
          result[offset] = frames[offset];
        }
      }
      if (frames.$debugName) {
        result.$displayName = frames.$debugName;
      }
      return result;
    }
    exports2.convertToKeyframes = convertToKeyframes;
  }
});

// ../../node_modules/typestyle/lib/internal/utilities.js
var require_utilities = __commonJS({
  "../../node_modules/typestyle/lib/internal/utilities.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.raf = typeof requestAnimationFrame === "undefined" ? function(cb) {
      return setTimeout(cb);
    } : typeof window === "undefined" ? requestAnimationFrame : requestAnimationFrame.bind(window);
    function classes2() {
      var classes3 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        classes3[_i] = arguments[_i];
      }
      return classes3.map(function(c) {
        return c && typeof c === "object" ? Object.keys(c).map(function(key2) {
          return !!c[key2] && key2;
        }) : [c];
      }).reduce(function(flattened, c) {
        return flattened.concat(c);
      }, []).filter(function(c) {
        return !!c;
      }).join(" ");
    }
    exports2.classes = classes2;
    function extend() {
      var objects = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
      }
      var result = {};
      for (var _a = 0, objects_1 = objects; _a < objects_1.length; _a++) {
        var object = objects_1[_a];
        if (object == null || object === false) {
          continue;
        }
        for (var key2 in object) {
          var val = object[key2];
          if (!val && val !== 0) {
            continue;
          }
          if (key2 === "$nest" && val) {
            result[key2] = result["$nest"] ? extend(result["$nest"], val) : val;
          } else if (key2.indexOf("&") !== -1 || key2.indexOf("@media") === 0) {
            result[key2] = result[key2] ? extend(result[key2], val) : val;
          } else {
            result[key2] = val;
          }
        }
      }
      return result;
    }
    exports2.extend = extend;
    exports2.media = function(mediaQuery) {
      var _a;
      var objects = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        objects[_i - 1] = arguments[_i];
      }
      var mediaQuerySections = [];
      if (mediaQuery.type)
        mediaQuerySections.push(mediaQuery.type);
      if (mediaQuery.orientation)
        mediaQuerySections.push("(orientation: " + mediaQuery.orientation + ")");
      if (mediaQuery.minWidth)
        mediaQuerySections.push("(min-width: " + mediaLength(mediaQuery.minWidth) + ")");
      if (mediaQuery.maxWidth)
        mediaQuerySections.push("(max-width: " + mediaLength(mediaQuery.maxWidth) + ")");
      if (mediaQuery.minHeight)
        mediaQuerySections.push("(min-height: " + mediaLength(mediaQuery.minHeight) + ")");
      if (mediaQuery.maxHeight)
        mediaQuerySections.push("(max-height: " + mediaLength(mediaQuery.maxHeight) + ")");
      if (mediaQuery.prefersColorScheme)
        mediaQuerySections.push("(prefers-color-scheme: " + mediaQuery.prefersColorScheme + ")");
      var stringMediaQuery = "@media " + mediaQuerySections.join(" and ");
      var object = {
        $nest: (_a = {}, _a[stringMediaQuery] = extend.apply(void 0, objects), _a)
      };
      return object;
    };
    var mediaLength = function(value) {
      return typeof value === "string" ? value : value + "px";
    };
  }
});

// ../../node_modules/typestyle/lib/internal/typestyle.js
var require_typestyle = __commonJS({
  "../../node_modules/typestyle/lib/internal/typestyle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var FreeStyle2 = (init_dist(), __toCommonJS(dist_exports));
    var formatting_1 = require_formatting();
    var utilities_1 = require_utilities();
    var createFreeStyle = function() {
      return FreeStyle2.create();
    };
    var TypeStyle = (
      /** @class */
      function() {
        function TypeStyle2(_a) {
          var _this = this;
          var autoGenerateTag = _a.autoGenerateTag;
          this.cssRaw = function(mustBeValidCSS) {
            if (!mustBeValidCSS) {
              return;
            }
            _this._raw += mustBeValidCSS || "";
            _this._pendingRawChange = true;
            _this._styleUpdated();
          };
          this.cssRule = function(selector) {
            var objects = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              objects[_i - 1] = arguments[_i];
            }
            var styles = formatting_1.convertToStyles(utilities_1.extend.apply(void 0, objects));
            _this._freeStyle.registerRule(selector, styles);
            _this._styleUpdated();
            return;
          };
          this.forceRenderStyles = function() {
            var target2 = _this._getTag();
            if (!target2) {
              return;
            }
            target2.textContent = _this.getStyles();
          };
          this.fontFace = function() {
            var fontFace = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              fontFace[_i] = arguments[_i];
            }
            var freeStyle2 = _this._freeStyle;
            for (var _a2 = 0, _b = fontFace; _a2 < _b.length; _a2++) {
              var face = _b[_a2];
              freeStyle2.registerRule("@font-face", face);
            }
            _this._styleUpdated();
            return;
          };
          this.getStyles = function() {
            return (_this._raw || "") + _this._freeStyle.getStyles();
          };
          this.keyframes = function(frames) {
            var keyframes = formatting_1.convertToKeyframes(frames);
            var animationName = _this._freeStyle.registerKeyframes(keyframes);
            _this._styleUpdated();
            return animationName;
          };
          this.reinit = function() {
            var freeStyle2 = createFreeStyle();
            _this._freeStyle = freeStyle2;
            _this._lastFreeStyleChangeId = freeStyle2.changeId;
            _this._raw = "";
            _this._pendingRawChange = false;
            var target2 = _this._getTag();
            if (target2) {
              target2.textContent = "";
            }
          };
          this.setStylesTarget = function(tag) {
            if (_this._tag) {
              _this._tag.textContent = "";
            }
            _this._tag = tag;
            _this.forceRenderStyles();
          };
          this.stylesheet = function(classes2) {
            var classNames = Object.getOwnPropertyNames(classes2);
            var result = {};
            for (var _i = 0, classNames_1 = classNames; _i < classNames_1.length; _i++) {
              var className = classNames_1[_i];
              var classDef = classes2[className];
              if (classDef) {
                classDef.$debugName = className;
                result[className] = _this.style(classDef);
              }
            }
            return result;
          };
          var freeStyle = createFreeStyle();
          this._autoGenerateTag = autoGenerateTag;
          this._freeStyle = freeStyle;
          this._lastFreeStyleChangeId = freeStyle.changeId;
          this._pending = 0;
          this._pendingRawChange = false;
          this._raw = "";
          this._tag = void 0;
          this.style = this.style.bind(this);
        }
        TypeStyle2.prototype._afterAllSync = function(cb) {
          var _this = this;
          this._pending++;
          var pending = this._pending;
          utilities_1.raf(function() {
            if (pending !== _this._pending) {
              return;
            }
            cb();
          });
        };
        TypeStyle2.prototype._getTag = function() {
          if (this._tag) {
            return this._tag;
          }
          if (this._autoGenerateTag) {
            var tag = typeof window === "undefined" ? { textContent: "" } : document.createElement("style");
            if (typeof document !== "undefined") {
              document.head.appendChild(tag);
            }
            this._tag = tag;
            return tag;
          }
          return void 0;
        };
        TypeStyle2.prototype._styleUpdated = function() {
          var _this = this;
          var changeId = this._freeStyle.changeId;
          var lastChangeId = this._lastFreeStyleChangeId;
          if (!this._pendingRawChange && changeId === lastChangeId) {
            return;
          }
          this._lastFreeStyleChangeId = changeId;
          this._pendingRawChange = false;
          this._afterAllSync(function() {
            return _this.forceRenderStyles();
          });
        };
        TypeStyle2.prototype.style = function() {
          var className = this._freeStyle.registerStyle(formatting_1.convertToStyles(utilities_1.extend.apply(void 0, arguments)));
          this._styleUpdated();
          return className;
        };
        return TypeStyle2;
      }()
    );
    exports2.TypeStyle = TypeStyle;
  }
});

// ../../node_modules/typestyle/lib/types.js
var require_types = __commonJS({
  "../../node_modules/typestyle/lib/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/typestyle/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/typestyle/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typestyle_1 = require_typestyle();
    exports2.TypeStyle = typestyle_1.TypeStyle;
    var types = require_types();
    exports2.types = types;
    var utilities_1 = require_utilities();
    exports2.extend = utilities_1.extend;
    exports2.classes = utilities_1.classes;
    exports2.media = utilities_1.media;
    var ts = new typestyle_1.TypeStyle({ autoGenerateTag: true });
    exports2.setStylesTarget = ts.setStylesTarget;
    exports2.cssRaw = ts.cssRaw;
    exports2.cssRule = ts.cssRule;
    exports2.forceRenderStyles = ts.forceRenderStyles;
    exports2.fontFace = ts.fontFace;
    exports2.getStyles = ts.getStyles;
    exports2.keyframes = ts.keyframes;
    exports2.reinit = ts.reinit;
    exports2.style = ts.style;
    exports2.stylesheet = ts.stylesheet;
    function createTypeStyle(target2) {
      var instance = new typestyle_1.TypeStyle({ autoGenerateTag: false });
      if (target2) {
        instance.setStylesTarget(target2);
      }
      return instance;
    }
    exports2.createTypeStyle = createTypeStyle;
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/style/icon.js
var import_lib, LabIconStyle;
var init_icon = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/style/icon.js"() {
    import_lib = __toESM(require_lib4());
    (function(LabIconStyle2) {
      const builtinSheets = {
        breadCrumb: {
          container: {
            $nest: {
              // `&` will be substituted for the generated classname (interpolation)
              "&:first-child svg": {
                bottom: "1px",
                marginLeft: "0px",
                position: "relative"
              },
              "&:hover": {
                backgroundColor: "var(--jp-layout-color2)"
              },
              [".jp-mod-dropTarget&"]: {
                backgroundColor: "var(--jp-brand-color2)",
                opacity: 0.7
              }
            }
          },
          element: {
            borderRadius: "var(--jp-border-radius)",
            cursor: "pointer",
            margin: "0px 2px",
            padding: "0px 2px",
            height: "16px",
            width: "16px",
            verticalAlign: "middle"
          }
        },
        commandPaletteHeader: {
          container: {
            height: "14px",
            margin: "0 14px 0 auto"
          },
          element: {
            height: "14px",
            width: "14px"
          },
          options: {
            elementPosition: "center"
          }
        },
        commandPaletteItem: {
          element: {
            height: "16px",
            width: "16px"
          },
          options: {
            elementPosition: "center"
          }
        },
        launcherCard: {
          container: {
            height: "52px",
            width: "52px"
          },
          element: {
            height: "52px",
            width: "52px"
          },
          options: {
            elementPosition: "center"
          }
        },
        launcherSection: {
          container: {
            boxSizing: "border-box",
            marginRight: "12px",
            height: "32px",
            width: "32px"
          },
          element: {
            height: "32px",
            width: "32px"
          },
          options: {
            elementPosition: "center"
          }
        },
        listing: {
          container: {
            flex: "0 0 20px",
            marginRight: "4px",
            position: "relative"
          },
          element: {
            height: "16px",
            width: "16px"
          },
          options: {
            elementPosition: "center"
          }
        },
        listingHeaderItem: {
          container: {
            display: "inline",
            height: "16px",
            width: "16px"
          },
          element: {
            height: "auto",
            margin: "-2px 0 0 0",
            width: "20px"
          },
          options: {
            elementPosition: "center"
          }
        },
        mainAreaTab: {
          container: {
            $nest: {
              ".lm-DockPanel-tabBar &": {
                marginRight: "4px"
              }
            }
          },
          element: {
            $nest: {
              ".lm-DockPanel-tabBar &": {
                height: "14px",
                width: "14px"
              }
            }
          },
          options: {
            elementPosition: "center"
          }
        },
        menuItem: {
          container: {
            display: "inline-block",
            verticalAlign: "middle"
          },
          element: {
            height: "16px",
            width: "16px"
          },
          options: {
            elementPosition: "center"
          }
        },
        runningItem: {
          container: {
            margin: "0px 4px 0px 4px"
          },
          element: {
            height: "16px",
            width: "16px"
          },
          options: {
            elementPosition: "center"
          }
        },
        select: {
          container: {
            pointerEvents: "none"
          },
          element: {
            position: "absolute",
            height: "auto",
            width: "16px"
          }
        },
        settingsEditor: {
          container: {
            display: "flex",
            flex: "0 0 20px",
            margin: "0 3px 0 0",
            position: "relative",
            height: "20px",
            width: "20px"
          },
          element: {
            height: "16px",
            width: "16px"
          },
          options: {
            elementPosition: "center"
          }
        },
        sideBar: {
          element: {
            height: "auto",
            width: "20px"
          },
          options: {
            elementPosition: "center"
          }
        },
        splash: {
          container: {
            animation: "0.3s fade-in linear forwards",
            height: "100%",
            width: "100%",
            zIndex: 1
          },
          element: {
            // width no height
            width: "100px"
          },
          options: {
            elementPosition: "center"
          }
        },
        statusBar: {
          element: {
            left: "0px",
            top: "0px",
            height: "18px",
            width: "20px",
            position: "relative"
          }
        },
        toolbarButton: {
          container: {
            display: "inline-block",
            verticalAlign: "middle"
          },
          element: {
            height: "16px",
            width: "16px"
          },
          options: {
            elementPosition: "center"
          }
        }
      };
      function _elementPositionFactory(extra) {
        return {
          container: {
            alignItems: "center",
            display: "flex"
          },
          element: {
            display: "block",
            ...extra
          }
        };
      }
      const positionSheets = {
        center: _elementPositionFactory({ margin: "0 auto", width: "100%" }),
        top: _elementPositionFactory({ margin: "0 0 auto 0" }),
        right: _elementPositionFactory({ margin: "0 0 0 auto" }),
        bottom: _elementPositionFactory({ margin: "auto 0 0 0" }),
        left: _elementPositionFactory({ margin: "0 auto 0 0" }),
        "top right": _elementPositionFactory({ margin: "0 0 auto auto" }),
        "bottom right": _elementPositionFactory({ margin: "auto 0 0 auto" }),
        "bottom left": _elementPositionFactory({ margin: "auto auto 0 0" }),
        "top left": _elementPositionFactory({ margin: "0 auto 0 auto" })
      };
      function _elementSizeFactory(size) {
        return {
          element: {
            height: size,
            width: size
          }
        };
      }
      const sizeSheets = {
        small: _elementSizeFactory("14px"),
        normal: _elementSizeFactory("16px"),
        large: _elementSizeFactory("20px"),
        xlarge: _elementSizeFactory("24px")
      };
      function mergeSheets(sheets) {
        return {
          container: Object.assign({}, ...sheets.map((s) => s.container)),
          element: Object.assign({}, ...sheets.map((s) => s.element))
        };
      }
      function resolveSheet(stylesheet) {
        if (!stylesheet) {
          return [];
        }
        if (!Array.isArray(stylesheet)) {
          stylesheet = [stylesheet];
        }
        return stylesheet.map((k) => typeof k === "string" ? builtinSheets[k] : k);
      }
      function applySheetOptions(sheets) {
        const options = Object.assign({}, ...sheets.map((s) => s.options));
        if (options.elementPosition) {
          sheets.unshift(positionSheets[options.elementPosition]);
        }
        if (options.elementSize) {
          sheets.unshift(sizeSheets[options.elementSize]);
        }
        return mergeSheets(sheets);
      }
      function resolveStyleClass(stylesheet) {
        var _a;
        return (0, import_lib.style)({
          ...stylesheet.container,
          $nest: {
            ...(_a = stylesheet.container) === null || _a === void 0 ? void 0 : _a.$nest,
            ["svg"]: stylesheet.element
          }
        });
      }
      const _styleClassCache = /* @__PURE__ */ new Map();
      function styleClass(props) {
        if (!props || Object.keys(props).length === 0) {
          return "";
        }
        let { elementPosition, elementSize, stylesheet, ...elementCSS } = props;
        const options = {
          ...elementPosition && { elementPosition },
          ...elementSize && { elementSize }
        };
        const cacheable = typeof stylesheet === "string" && Object.keys(elementCSS).length === 0;
        const cacheKey = cacheable ? [stylesheet, elementPosition, elementSize].join(",") : "";
        if (cacheable && _styleClassCache.has(cacheKey)) {
          return _styleClassCache.get(cacheKey);
        }
        const sheets = resolveSheet(stylesheet);
        sheets.push({ element: elementCSS, options });
        const cls = resolveStyleClass(applySheetOptions(sheets));
        if (cacheable) {
          _styleClassCache.set(cacheKey, cls);
        }
        return cls;
      }
      LabIconStyle2.styleClass = styleClass;
    })(LabIconStyle || (LabIconStyle = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/style/index.js
var init_style = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/style/index.js"() {
    init_icon();
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/activitymonitor.js
var require_activitymonitor2 = __commonJS({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/activitymonitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActivityMonitor = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var ActivityMonitor = class {
      /**
       * Construct a new activity monitor.
       */
      constructor(options) {
        this._timer = -1;
        this._timeout = -1;
        this._isDisposed = false;
        this._activityStopped = new signaling_1.Signal(this);
        options.signal.connect(this._onSignalFired, this);
        this._timeout = options.timeout || 1e3;
      }
      /**
       * A signal emitted when activity has ceased.
       */
      get activityStopped() {
        return this._activityStopped;
      }
      /**
       * The timeout associated with the monitor, in milliseconds.
       */
      get timeout() {
        return this._timeout;
      }
      set timeout(value) {
        this._timeout = value;
      }
      /**
       * Test whether the monitor has been disposed.
       *
       * #### Notes
       * This is a read-only property.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the activity monitor.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * A signal handler for the monitored signal.
       */
      _onSignalFired(sender, args) {
        clearTimeout(this._timer);
        this._sender = sender;
        this._args = args;
        this._timer = setTimeout(() => {
          this._activityStopped.emit({
            sender: this._sender,
            args: this._args
          });
        }, this._timeout);
      }
    };
    exports2.ActivityMonitor = ActivityMonitor;
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/interfaces.js
var require_interfaces3 = __commonJS({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/lru.js
var require_lru2 = __commonJS({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/lru.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LruCache = void 0;
    var DEFAULT_MAX_SIZE = 128;
    var LruCache = class {
      constructor(options = {}) {
        this._map = /* @__PURE__ */ new Map();
        this._maxSize = (options === null || options === void 0 ? void 0 : options.maxSize) || DEFAULT_MAX_SIZE;
      }
      /**
       * Return the current size of the cache.
       */
      get size() {
        return this._map.size;
      }
      /**
       * Clear the values in the cache.
       */
      clear() {
        this._map.clear();
      }
      /**
       * Get a value (or null) from the cache, pushing the item to the front of the cache.
       */
      get(key2) {
        const item = this._map.get(key2) || null;
        if (item != null) {
          this._map.delete(key2);
          this._map.set(key2, item);
        }
        return item;
      }
      /**
       * Set a value in the cache, potentially evicting an old item.
       */
      set(key2, value) {
        if (this._map.size >= this._maxSize) {
          this._map.delete(this._map.keys().next().value);
        }
        this._map.set(key2, value);
      }
    };
    exports2.LruCache = LruCache;
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js
var require_markdowncodeblocks2 = __commonJS({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MarkdownCodeBlocks = void 0;
    var MarkdownCodeBlocks;
    (function(MarkdownCodeBlocks2) {
      MarkdownCodeBlocks2.CODE_BLOCK_MARKER = "```";
      const markdownExtensions = [
        ".markdown",
        ".mdown",
        ".mkdn",
        ".md",
        ".mkd",
        ".mdwn",
        ".mdtxt",
        ".mdtext",
        ".text",
        ".txt",
        ".Rmd"
      ];
      class MarkdownCodeBlock {
        constructor(startLine) {
          this.startLine = startLine;
          this.code = "";
          this.endLine = -1;
        }
      }
      MarkdownCodeBlocks2.MarkdownCodeBlock = MarkdownCodeBlock;
      function isMarkdown(extension) {
        return markdownExtensions.indexOf(extension) > -1;
      }
      MarkdownCodeBlocks2.isMarkdown = isMarkdown;
      function findMarkdownCodeBlocks(text) {
        if (!text || text === "") {
          return [];
        }
        const lines = text.split("\n");
        const codeBlocks = [];
        let currentBlock = null;
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
          const line = lines[lineIndex];
          const lineContainsMarker = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER) === 0;
          const constructingBlock = currentBlock != null;
          if (!lineContainsMarker && !constructingBlock) {
            continue;
          }
          if (!constructingBlock) {
            currentBlock = new MarkdownCodeBlock(lineIndex);
            const firstIndex = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const lastIndex = line.lastIndexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const isSingleLine = firstIndex !== lastIndex;
            if (isSingleLine) {
              currentBlock.code = line.substring(firstIndex + MarkdownCodeBlocks2.CODE_BLOCK_MARKER.length, lastIndex);
              currentBlock.endLine = lineIndex;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            }
          } else if (currentBlock) {
            if (lineContainsMarker) {
              currentBlock.endLine = lineIndex - 1;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            } else {
              currentBlock.code += line + "\n";
            }
          }
        }
        return codeBlocks;
      }
      MarkdownCodeBlocks2.findMarkdownCodeBlocks = findMarkdownCodeBlocks;
    })(MarkdownCodeBlocks || (exports2.MarkdownCodeBlocks = MarkdownCodeBlocks = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/url.js
var require_url2 = __commonJS({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/url.js"(exports2) {
    "use strict";
    var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLExt = void 0;
    var path_1 = __require("path");
    var url_parse_1 = __importDefault3(require_url_parse());
    var URLExt;
    (function(URLExt2) {
      function parse(url) {
        if (typeof document !== "undefined" && document) {
          const a = document.createElement("a");
          a.href = url;
          return a;
        }
        return (0, url_parse_1.default)(url);
      }
      URLExt2.parse = parse;
      function getHostName(url) {
        return (0, url_parse_1.default)(url).hostname;
      }
      URLExt2.getHostName = getHostName;
      function normalize2(url) {
        return url && parse(url).toString();
      }
      URLExt2.normalize = normalize2;
      function join2(...parts) {
        let u = (0, url_parse_1.default)(parts[0], {});
        const isSchemaLess = u.protocol === "" && u.slashes;
        if (isSchemaLess) {
          u = (0, url_parse_1.default)(parts[0], "https:" + parts[0]);
        }
        const prefix = `${isSchemaLess ? "" : u.protocol}${u.slashes ? "//" : ""}${u.auth}${u.auth ? "@" : ""}${u.host}`;
        const path2 = path_1.posix.join(`${!!prefix && u.pathname[0] !== "/" ? "/" : ""}${u.pathname}`, ...parts.slice(1));
        return `${prefix}${path2 === "." ? "" : path2}`;
      }
      URLExt2.join = join2;
      function encodeParts(url) {
        return join2(...url.split("/").map(encodeURIComponent));
      }
      URLExt2.encodeParts = encodeParts;
      function objectToQueryString(value) {
        const keys = Object.keys(value).filter((key2) => key2.length > 0);
        if (!keys.length) {
          return "";
        }
        return "?" + keys.map((key2) => {
          const content = encodeURIComponent(String(value[key2]));
          return key2 + (content ? "=" + content : "");
        }).join("&");
      }
      URLExt2.objectToQueryString = objectToQueryString;
      function queryStringToObject(value) {
        return value.replace(/^\?/, "").split("&").reduce((acc, val) => {
          const [key2, value2] = val.split("=");
          if (key2.length > 0) {
            acc[key2] = decodeURIComponent(value2 || "");
          }
          return acc;
        }, {});
      }
      URLExt2.queryStringToObject = queryStringToObject;
      function isLocal(url, allowRoot = false) {
        const { protocol } = parse(url);
        return (!protocol || url.toLowerCase().indexOf(protocol) !== 0) && (allowRoot ? url.indexOf("//") !== 0 : url.indexOf("/") !== 0);
      }
      URLExt2.isLocal = isLocal;
    })(URLExt || (exports2.URLExt = URLExt = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/pageconfig.js
var require_pageconfig2 = __commonJS({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/pageconfig.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageConfig = void 0;
    var coreutils_1 = require_dist();
    var minimist_1 = __importDefault(require_minimist());
    var url_1 = require_url2();
    var PageConfig;
    (function(PageConfig) {
      function getOption(name) {
        if (configData) {
          return configData[name] || getBodyData(name);
        }
        configData = /* @__PURE__ */ Object.create(null);
        let found = false;
        if (typeof document !== "undefined" && document) {
          const el = document.getElementById("jupyter-config-data");
          if (el) {
            configData = JSON.parse(el.textContent || "");
            found = true;
          }
        }
        if (!found && typeof process !== "undefined" && process.argv) {
          try {
            const cli = (0, minimist_1.default)(process.argv.slice(2));
            const path = __require("path");
            let fullPath = "";
            if ("jupyter-config-data" in cli) {
              fullPath = path.resolve(cli["jupyter-config-data"]);
            } else if ("JUPYTER_CONFIG_DATA" in process.env) {
              fullPath = path.resolve(process.env["JUPYTER_CONFIG_DATA"]);
            }
            if (fullPath) {
              configData = eval("require")(fullPath);
            }
          } catch (e) {
            console.error(e);
          }
        }
        if (!coreutils_1.JSONExt.isObject(configData)) {
          configData = /* @__PURE__ */ Object.create(null);
        } else {
          for (const key2 in configData) {
            if (typeof configData[key2] !== "string") {
              configData[key2] = JSON.stringify(configData[key2]);
            }
          }
        }
        return configData[name] || getBodyData(name);
      }
      PageConfig.getOption = getOption;
      function setOption(name2, value) {
        const last = getOption(name2);
        configData[name2] = value;
        return last;
      }
      PageConfig.setOption = setOption;
      function getBaseUrl() {
        return url_1.URLExt.normalize(getOption("baseUrl") || "/");
      }
      PageConfig.getBaseUrl = getBaseUrl;
      function getTreeUrl() {
        return url_1.URLExt.join(getBaseUrl(), getOption("treeUrl"));
      }
      PageConfig.getTreeUrl = getTreeUrl;
      function getShareUrl() {
        return url_1.URLExt.normalize(getOption("shareUrl") || getBaseUrl());
      }
      PageConfig.getShareUrl = getShareUrl;
      function getTreeShareUrl() {
        return url_1.URLExt.normalize(url_1.URLExt.join(getShareUrl(), getOption("treeUrl")));
      }
      PageConfig.getTreeShareUrl = getTreeShareUrl;
      function getUrl(options) {
        var _a, _b, _c, _d;
        let path2 = options.toShare ? getShareUrl() : getBaseUrl();
        const mode = (_a = options.mode) !== null && _a !== void 0 ? _a : getOption("mode");
        const workspace = (_b = options.workspace) !== null && _b !== void 0 ? _b : getOption("workspace");
        const labOrDoc = mode === "single-document" ? "doc" : "lab";
        path2 = url_1.URLExt.join(path2, labOrDoc);
        if (workspace !== PageConfig.defaultWorkspace) {
          path2 = url_1.URLExt.join(path2, "workspaces", encodeURIComponent((_c = getOption("workspace")) !== null && _c !== void 0 ? _c : PageConfig.defaultWorkspace));
        }
        const treePath = (_d = options.treePath) !== null && _d !== void 0 ? _d : getOption("treePath");
        if (treePath) {
          path2 = url_1.URLExt.join(path2, "tree", url_1.URLExt.encodeParts(treePath));
        }
        return path2;
      }
      PageConfig.getUrl = getUrl;
      PageConfig.defaultWorkspace = "default";
      function getWsUrl(baseUrl) {
        let wsUrl = getOption("wsUrl");
        if (!wsUrl) {
          baseUrl = baseUrl ? url_1.URLExt.normalize(baseUrl) : getBaseUrl();
          if (baseUrl.indexOf("http") !== 0) {
            return "";
          }
          wsUrl = "ws" + baseUrl.slice(4);
        }
        return url_1.URLExt.normalize(wsUrl);
      }
      PageConfig.getWsUrl = getWsUrl;
      function getNBConvertURL({ path: path2, format, download }) {
        const notebookPath = url_1.URLExt.encodeParts(path2);
        const url = url_1.URLExt.join(getBaseUrl(), "nbconvert", format, notebookPath);
        if (download) {
          return url + "?download=true";
        }
        return url;
      }
      PageConfig.getNBConvertURL = getNBConvertURL;
      function getToken() {
        return getOption("token") || getBodyData("jupyterApiToken");
      }
      PageConfig.getToken = getToken;
      function getNotebookVersion() {
        const notebookVersion = getOption("notebookVersion");
        if (notebookVersion === "") {
          return [0, 0, 0];
        }
        return JSON.parse(notebookVersion);
      }
      PageConfig.getNotebookVersion = getNotebookVersion;
      let configData = null;
      function getBodyData(key2) {
        if (typeof document === "undefined" || !document.body) {
          return "";
        }
        const val = document.body.dataset[key2];
        if (typeof val === "undefined") {
          return "";
        }
        return decodeURIComponent(val);
      }
      let Extension;
      (function(Extension2) {
        function populate(key2) {
          try {
            const raw = getOption(key2);
            if (raw) {
              return JSON.parse(raw);
            }
          } catch (error) {
            console.warn(`Unable to parse ${key2}.`, error);
          }
          return [];
        }
        Extension2.deferred = populate("deferredExtensions");
        Extension2.disabled = populate("disabledExtensions");
        function isDeferred(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.deferred.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDeferred = isDeferred;
        function isDisabled(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.disabled.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDisabled = isDisabled;
      })(Extension = PageConfig.Extension || (PageConfig.Extension = {}));
    })(PageConfig || (exports.PageConfig = PageConfig = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/path.js
var require_path2 = __commonJS({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathExt = void 0;
    var path_1 = __require("path");
    var PathExt2;
    (function(PathExt3) {
      function join2(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : removeSlash(path2);
      }
      PathExt3.join = join2;
      function joinWithLeadingSlash(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : path2;
      }
      PathExt3.joinWithLeadingSlash = joinWithLeadingSlash;
      function basename(path2, ext) {
        return path_1.posix.basename(path2, ext);
      }
      PathExt3.basename = basename;
      function dirname(path2) {
        const dir = removeSlash(path_1.posix.dirname(path2));
        return dir === "." ? "" : dir;
      }
      PathExt3.dirname = dirname;
      function extname(path2) {
        return path_1.posix.extname(path2);
      }
      PathExt3.extname = extname;
      function normalize2(path2) {
        if (path2 === "") {
          return "";
        }
        return removeSlash(path_1.posix.normalize(path2));
      }
      PathExt3.normalize = normalize2;
      function resolve(...parts) {
        return removeSlash(path_1.posix.resolve(...parts));
      }
      PathExt3.resolve = resolve;
      function relative(from2, to) {
        return removeSlash(path_1.posix.relative(from2, to));
      }
      PathExt3.relative = relative;
      function normalizeExtension(extension) {
        if (extension.length > 0 && extension.indexOf(".") !== 0) {
          extension = `.${extension}`;
        }
        return extension;
      }
      PathExt3.normalizeExtension = normalizeExtension;
      function removeSlash(path2) {
        if (path2.indexOf("/") === 0) {
          path2 = path2.slice(1);
        }
        return path2;
      }
      PathExt3.removeSlash = removeSlash;
    })(PathExt2 || (exports2.PathExt = PathExt2 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/signal.js
var require_signal2 = __commonJS({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/signal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signalToPromise = void 0;
    var coreutils_12 = require_dist();
    function signalToPromise(signal, timeout) {
      const waitForSignal = new coreutils_12.PromiseDelegate();
      function cleanup() {
        signal.disconnect(slot);
      }
      function slot(sender, args) {
        cleanup();
        waitForSignal.resolve([sender, args]);
      }
      signal.connect(slot);
      if ((timeout !== null && timeout !== void 0 ? timeout : 0) > 0) {
        setTimeout(() => {
          cleanup();
          waitForSignal.reject(`Signal not emitted within ${timeout} ms.`);
        }, timeout);
      }
      return waitForSignal.promise;
    }
    exports2.signalToPromise = signalToPromise;
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/text.js
var require_text2 = __commonJS({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/text.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Text = void 0;
    var Text3;
    (function(Text4) {
      const HAS_SURROGATES = "\u{1D41A}".length > 1;
      function jsIndexToCharIndex(jsIdx, text) {
        if (HAS_SURROGATES) {
          return jsIdx;
        }
        let charIdx = jsIdx;
        for (let i = 0; i + 1 < text.length && i < jsIdx; i++) {
          const charCode = text.charCodeAt(i);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              charIdx--;
              i++;
            }
          }
        }
        return charIdx;
      }
      Text4.jsIndexToCharIndex = jsIndexToCharIndex;
      function charIndexToJsIndex(charIdx, text) {
        if (HAS_SURROGATES) {
          return charIdx;
        }
        let jsIdx = charIdx;
        for (let i = 0; i + 1 < text.length && i < jsIdx; i++) {
          const charCode = text.charCodeAt(i);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              jsIdx++;
              i++;
            }
          }
        }
        return jsIdx;
      }
      Text4.charIndexToJsIndex = charIndexToJsIndex;
      function camelCase(str, upper = false) {
        return str.replace(/^(\w)|[\s-_:]+(\w)/g, function(match, p1, p2) {
          if (p2) {
            return p2.toUpperCase();
          } else {
            return upper ? p1.toUpperCase() : p1.toLowerCase();
          }
        });
      }
      Text4.camelCase = camelCase;
      function titleCase(str) {
        return (str || "").toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
      }
      Text4.titleCase = titleCase;
    })(Text3 || (exports2.Text = Text3 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/time.js
var require_time2 = __commonJS({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Time = void 0;
    var UNITS = [
      { name: "years", milliseconds: 365 * 24 * 60 * 60 * 1e3 },
      { name: "months", milliseconds: 30 * 24 * 60 * 60 * 1e3 },
      { name: "days", milliseconds: 24 * 60 * 60 * 1e3 },
      { name: "hours", milliseconds: 60 * 60 * 1e3 },
      { name: "minutes", milliseconds: 60 * 1e3 },
      { name: "seconds", milliseconds: 1e3 }
    ];
    var Time;
    (function(Time2) {
      function formatHuman(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.RelativeTimeFormat(lang, { numeric: "auto" });
        const delta = new Date(value).getTime() - Date.now();
        for (let unit of UNITS) {
          const amount = Math.ceil(delta / unit.milliseconds);
          if (amount === 0) {
            continue;
          }
          return formatter.format(amount, unit.name);
        }
        return formatter.format(0, "seconds");
      }
      Time2.formatHuman = formatHuman;
      function format(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.DateTimeFormat(lang, {
          dateStyle: "short",
          timeStyle: "short"
        });
        return formatter.format(new Date(value));
      }
      Time2.format = format;
    })(Time || (exports2.Time = Time = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/index.js
var require_lib5 = __commonJS({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@jupyterlab/coreutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_activitymonitor2(), exports2);
    __exportStar2(require_interfaces3(), exports2);
    __exportStar2(require_lru2(), exports2);
    __exportStar2(require_markdowncodeblocks2(), exports2);
    __exportStar2(require_pageconfig2(), exports2);
    __exportStar2(require_path2(), exports2);
    __exportStar2(require_signal2(), exports2);
    __exportStar2(require_text2(), exports2);
    __exportStar2(require_time2(), exports2);
    __exportStar2(require_url2(), exports2);
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/utils.js
function _classes(classes2) {
  return classes2.map((c) => c && typeof c === "object" ? Object.keys(c).map((key2) => !!c[key2] && key2) : typeof c === "string" ? c.split(/\s+/) : []).reduce((flattened, c) => flattened.concat(c), []).filter((c) => !!c);
}
function classes(...classes2) {
  return _classes(classes2).join(" ");
}
function getReactAttrs(elem, { ignore: ignore2 = [] } = {}) {
  return elem.getAttributeNames().reduce((d, name2) => {
    if (name2 === "style" || ignore2.includes(name2)) {
    } else if (name2.startsWith("data")) {
      d[name2] = elem.getAttribute(name2);
    } else {
      d[import_coreutils4.Text.camelCase(name2)] = elem.getAttribute(name2);
    }
    return d;
  }, {});
}
var import_coreutils4;
var init_utils2 = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/utils.js"() {
    import_coreutils4 = __toESM(require_lib5());
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/icon/labicon.js
var import_coreutils5, import_react, import_client, LabIcon, Private5, badIcon, blankIcon;
var init_labicon = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/icon/labicon.js"() {
    import_coreutils5 = __toESM(require_dist());
    init_index_es63();
    import_react = __toESM(require_react());
    import_client = __toESM(require_client());
    init_bad();
    init_blank();
    init_refresh();
    init_style();
    init_utils2();
    LabIcon = class {
      /** *********
       * statics *
       ***********/
      /**
       * Remove any rendered icon from the element that contains it
       *
       * @param container - a DOM node into which an icon was
       * previously rendered
       *
       * @returns the cleaned container
       */
      static remove(container) {
        while (container.firstChild) {
          container.firstChild.remove();
        }
        container.className = "";
        return container;
      }
      /**
       * Resolve an icon name or a \{name, svgstr\} pair into an
       * actual LabIcon.
       *
       * @param icon - either a string with the name of an existing icon
       * or an object with \{name: string, svgstr: string\} fields.
       *
       * @returns a LabIcon instance
       */
      static resolve({ icon }) {
        if (icon instanceof LabIcon) {
          return icon;
        }
        if (typeof icon === "string") {
          const resolved = LabIcon._instances.get(icon);
          if (resolved) {
            return resolved;
          }
          if (LabIcon._debug) {
            console.warn(`Lookup failed for icon, creating loading icon. icon: ${icon}`);
          }
          return new LabIcon({ name: icon, svgstr: refresh_default, _loading: true });
        }
        return new LabIcon(icon);
      }
      /**
       * Resolve an icon name or a \{name, svgstr\} pair into a DOM element.
       * If icon arg is undefined, the function will fall back to trying to render
       * the icon as a CSS background image, via the iconClass arg.
       * If both icon and iconClass are undefined, this function will return
       * an empty div.
       *
       * @param icon - optional, either a string with the name of an existing icon
       * or an object with \{name: string, svgstr: string\} fields
       *
       * @param iconClass - optional, if the icon arg is not set, the iconClass arg
       * should be a CSS class associated with an existing CSS background-image
       *
       * @param fallback - DEPRECATED, optional, a LabIcon instance that will
       * be used if neither icon nor iconClass are defined
       *
       * @param props - any additional args are passed though to the element method
       * of the resolved icon on render
       *
       * @returns a DOM node with the resolved icon rendered into it
       */
      static resolveElement({ icon, iconClass, fallback, ...props }) {
        if (!Private5.isResolvable(icon)) {
          if (!iconClass && fallback) {
            return fallback.element(props);
          }
          props.className = classes(iconClass, props.className);
          return Private5.blankElement(props);
        }
        return LabIcon.resolve({ icon }).element(props);
      }
      /**
       * Resolve an icon name or a \{name, svgstr\} pair into a React component.
       * If icon arg is undefined, the function will fall back to trying to render
       * the icon as a CSS background image, via the iconClass arg.
       * If both icon and iconClass are undefined, the returned component
       * will simply render an empty div.
       *
       * @param icon - optional, either a string with the name of an existing icon
       * or an object with \{name: string, svgstr: string\} fields
       *
       * @param iconClass - optional, if the icon arg is not set, the iconClass arg
       * should be a CSS class associated with an existing CSS background-image
       *
       * @param fallback - DEPRECATED, optional, a LabIcon instance that will
       * be used if neither icon nor iconClass are defined
       *
       * @param props - any additional args are passed though to the React component
       * of the resolved icon on render
       *
       * @returns a React component that will render the resolved icon
       */
      static resolveReact({ icon, iconClass, fallback, ...props }) {
        if (!Private5.isResolvable(icon)) {
          if (!iconClass && fallback) {
            return import_react.default.createElement(fallback.react, { ...props });
          }
          props.className = classes(iconClass, props.className);
          return import_react.default.createElement(Private5.blankReact, { ...props });
        }
        const resolved = LabIcon.resolve({ icon });
        return import_react.default.createElement(resolved.react, { ...props });
      }
      /**
       * Resolve a \{name, svgstr\} pair into an actual svg node.
       */
      static resolveSvg({ name: name2, svgstr }) {
        const svgDoc = new DOMParser().parseFromString(Private5.svgstrShim(svgstr), "image/svg+xml");
        const svgError = svgDoc.querySelector("parsererror");
        if (svgError) {
          const errmsg = `SVG HTML was malformed for LabIcon instance.
name: ${name2}, svgstr: ${svgstr}`;
          if (LabIcon._debug) {
            console.error(errmsg);
            return svgError;
          } else {
            console.warn(errmsg);
            return null;
          }
        } else {
          return svgDoc.documentElement;
        }
      }
      /**
       * Toggle icon debug from off-to-on, or vice-versa.
       *
       * @param debug - optional boolean to force debug on or off
       */
      static toggleDebug(debug) {
        LabIcon._debug = debug !== null && debug !== void 0 ? debug : !LabIcon._debug;
      }
      /** *********
       * members *
       ***********/
      constructor({ name: name2, svgstr, render, unrender, _loading = false }) {
        this._props = {};
        this._svgReplaced = new Signal(this);
        this._svgElement = void 0;
        this._svgInnerHTML = void 0;
        this._svgReactAttrs = void 0;
        if (!(name2 && svgstr)) {
          console.error(`When defining a new LabIcon, name and svgstr must both be non-empty strings. name: ${name2}, svgstr: ${svgstr}`);
          return badIcon;
        }
        this._loading = _loading;
        if (LabIcon._instances.has(name2)) {
          const icon = LabIcon._instances.get(name2);
          if (this._loading) {
            icon.svgstr = svgstr;
            this._loading = false;
            return icon;
          } else {
            if (LabIcon._debug) {
              console.warn(`Redefining previously loaded icon svgstr. name: ${name2}, svgstrOld: ${icon.svgstr}, svgstr: ${svgstr}`);
            }
            icon.svgstr = svgstr;
            return icon;
          }
        }
        this.name = name2;
        this.react = this._initReact(name2);
        this.svgstr = svgstr;
        this._initRender({ render, unrender });
        LabIcon._instances.set(this.name, this);
      }
      /**
       * Get a view of this icon that is bound to the specified icon/style props
       *
       * @param optional icon/style props (same as args for .element
       * and .react methods). These will be bound to the resulting view
       *
       * @returns a view of this LabIcon instance
       */
      bindprops(props) {
        const view = Object.create(this);
        view._props = props;
        view.react = view._initReact(view.name + "_bind");
        return view;
      }
      /**
       * Create an icon as a DOM element
       *
       * @param className - a string that will be used as the class
       * of the container element. Overrides any existing class
       *
       * @param container - a preexisting DOM element that
       * will be used as the container for the svg element
       *
       * @param label - text that will be displayed adjacent
       * to the icon
       *
       * @param title - a tooltip for the icon
       *
       * @param tag - if container is not explicitly
       * provided, this tag will be used when creating the container
       *
       * @param stylesheet - optional string naming a builtin icon
       * stylesheet, for example 'menuItem' or `statusBar`. Can also be an
       * object defining a custom icon stylesheet, or a list of builtin
       * stylesheet names and/or custom stylesheet objects. If array,
       * the given stylesheets will be merged.
       *
       *   See @jupyterlab/ui-components/src/style/icon.ts for details
       *
       * @param elementPosition - optional position for the inner svg element
       *
       * @param elementSize - optional size for the inner svg element.
       * Set to 'normal' to get a standard 16px x 16px icon
       *
       * @param ...elementCSS - all additional args are treated as
       * overrides for the CSS props applied to the inner svg element
       *
       * @returns A DOM element that contains an (inline) svg element
       * that displays an icon
       */
      element(props = {}) {
        var _a;
        let { className, container, label, title, tag = "div", ...styleProps } = { ...this._props, ...props };
        const maybeSvgElement = container === null || container === void 0 ? void 0 : container.firstChild;
        if (((_a = maybeSvgElement === null || maybeSvgElement === void 0 ? void 0 : maybeSvgElement.dataset) === null || _a === void 0 ? void 0 : _a.iconId) === this._uuid) {
          return maybeSvgElement;
        }
        if (!this.svgElement) {
          return document.createElement("div");
        }
        if (container) {
          while (container.firstChild) {
            container.firstChild.remove();
          }
        } else if (tag) {
          container = document.createElement(tag);
        }
        const svgElement = this.svgElement.cloneNode(true);
        if (!container) {
          if (label) {
            console.warn();
          }
          return svgElement;
        }
        if (label != null) {
          container.textContent = label;
        }
        Private5.initContainer({
          container,
          className,
          styleProps,
          title
        });
        container.appendChild(svgElement);
        return container;
      }
      render(container, options) {
        var _a;
        let label = (_a = options === null || options === void 0 ? void 0 : options.children) === null || _a === void 0 ? void 0 : _a[0];
        if (typeof label !== "string") {
          label = void 0;
        }
        this.element({
          container,
          label,
          ...options === null || options === void 0 ? void 0 : options.props
        });
      }
      get svgElement() {
        if (this._svgElement === void 0) {
          this._svgElement = this._initSvg({ uuid: this._uuid });
        }
        return this._svgElement;
      }
      get svgInnerHTML() {
        if (this._svgInnerHTML === void 0) {
          if (this.svgElement === null) {
            this._svgInnerHTML = null;
          } else {
            this._svgInnerHTML = this.svgElement.innerHTML;
          }
        }
        return this._svgInnerHTML;
      }
      get svgReactAttrs() {
        if (this._svgReactAttrs === void 0) {
          if (this.svgElement === null) {
            this._svgReactAttrs = null;
          } else {
            this._svgReactAttrs = getReactAttrs(this.svgElement, {
              ignore: ["data-icon-id"]
            });
          }
        }
        return this._svgReactAttrs;
      }
      get svgstr() {
        return this._svgstr;
      }
      set svgstr(svgstr) {
        this._svgstr = svgstr;
        const uuid = import_coreutils5.UUID.uuid4();
        const uuidOld = this._uuid;
        this._uuid = uuid;
        this._svgElement = void 0;
        this._svgInnerHTML = void 0;
        this._svgReactAttrs = void 0;
        document.querySelectorAll(`[data-icon-id="${uuidOld}"]`).forEach((oldSvgElement) => {
          if (this.svgElement) {
            oldSvgElement.replaceWith(this.svgElement.cloneNode(true));
          }
        });
        this._svgReplaced.emit();
      }
      _initReact(displayName) {
        const component = import_react.default.forwardRef((props = {}, ref2) => {
          const { className, container, label, title, tag = "div", ...styleProps } = { ...this._props, ...props };
          const [, setId] = import_react.default.useState(this._uuid);
          import_react.default.useEffect(() => {
            const onSvgReplaced = () => {
              setId(this._uuid);
            };
            this._svgReplaced.connect(onSvgReplaced);
            return () => {
              this._svgReplaced.disconnect(onSvgReplaced);
            };
          });
          const Tag = tag !== null && tag !== void 0 ? tag : import_react.default.Fragment;
          if (!(this.svgInnerHTML && this.svgReactAttrs)) {
            return import_react.default.createElement(import_react.default.Fragment, null);
          }
          const svgComponent = import_react.default.createElement("svg", { ...this.svgReactAttrs, dangerouslySetInnerHTML: { __html: this.svgInnerHTML }, ref: ref2 });
          if (container) {
            Private5.initContainer({ container, className, styleProps, title });
            return import_react.default.createElement(
              import_react.default.Fragment,
              null,
              svgComponent,
              label
            );
          } else {
            let attributes = {};
            if (Tag !== import_react.default.Fragment) {
              attributes = {
                className: className || styleProps ? classes(className, LabIconStyle.styleClass(styleProps)) : void 0,
                title
              };
            }
            return import_react.default.createElement(
              Tag,
              { ...attributes },
              svgComponent,
              label
            );
          }
        });
        component.displayName = `LabIcon_${displayName}`;
        return component;
      }
      _initRender({ render, unrender }) {
        if (render) {
          this.render = render;
          if (unrender) {
            this.unrender = unrender;
          }
        } else if (unrender) {
          console.warn("In _initRender, ignoring unrender arg since render is undefined");
        }
      }
      _initSvg({ title, uuid } = {}) {
        const svgElement = LabIcon.resolveSvg(this);
        if (!svgElement) {
          return svgElement;
        }
        if (svgElement.tagName !== "parsererror") {
          svgElement.dataset.icon = this.name;
          if (uuid) {
            svgElement.dataset.iconId = uuid;
          }
          if (title) {
            Private5.setTitleSvg(svgElement, title);
          }
        }
        return svgElement;
      }
    };
    LabIcon._debug = false;
    LabIcon._instances = /* @__PURE__ */ new Map();
    (function(Private36) {
      function blankElement({ className = "", container, label, title, tag = "div", ...styleProps }) {
        if ((container === null || container === void 0 ? void 0 : container.className) === className) {
          return container;
        }
        if (container) {
          while (container.firstChild) {
            container.firstChild.remove();
          }
        } else {
          container = document.createElement(tag !== null && tag !== void 0 ? tag : "div");
        }
        if (label != null) {
          container.textContent = label;
        }
        Private36.initContainer({ container, className, styleProps, title });
        return container;
      }
      Private36.blankElement = blankElement;
      Private36.blankReact = import_react.default.forwardRef(({ className = "", container, label, title, tag = "div", ...styleProps }, ref2) => {
        const Tag = tag !== null && tag !== void 0 ? tag : "div";
        if (container) {
          initContainer({ container, className, styleProps, title });
          return import_react.default.createElement(import_react.default.Fragment, null);
        } else {
          return import_react.default.createElement(
            Tag,
            { className: classes(className, LabIconStyle.styleClass(styleProps)) },
            ref2 && blankIcon.react({ ref: ref2 }),
            label
          );
        }
      });
      Private36.blankReact.displayName = "BlankReact";
      function initContainer({ container, className, styleProps, title }) {
        if (title != null) {
          container.title = title;
        }
        const styleClass = LabIconStyle.styleClass(styleProps);
        if (className != null) {
          const classResolved = classes(className, styleClass);
          container.className = classResolved;
          return classResolved;
        } else if (styleClass) {
          container.classList.add(styleClass);
          return styleClass;
        } else {
          return "";
        }
      }
      Private36.initContainer = initContainer;
      function isResolvable(icon) {
        return !!(icon && (typeof icon === "string" || icon.name && icon.svgstr));
      }
      Private36.isResolvable = isResolvable;
      function setTitleSvg(svgNode, title) {
        const titleNodes = svgNode.getElementsByTagName("title");
        if (titleNodes.length) {
          titleNodes[0].textContent = title;
        } else {
          const titleNode = document.createElement("title");
          titleNode.textContent = title;
          svgNode.appendChild(titleNode);
        }
      }
      Private36.setTitleSvg = setTitleSvg;
      function svgstrShim(svgstr, strict = true) {
        const [, base64, raw] = decodeURIComponent(svgstr).replace(/>\s*\n\s*</g, "><").replace(/\s*\n\s*/g, " ").match(strict ? (
          // match based on data url schema
          /^(?:data:.*?(;base64)?,)?(.*)/
        ) : (
          // match based on open of svg tag
          /(?:(base64).*)?(<svg.*)/
        ));
        return base64 ? atob(raw) : raw;
      }
      Private36.svgstrShim = svgstrShim;
      class Renderer {
        constructor(_icon, _rendererOptions) {
          this._icon = _icon;
          this._rendererOptions = _rendererOptions;
        }
        // eslint-disable-next-line
        render(container, options) {
        }
      }
      Private36.Renderer = Renderer;
      class ElementRenderer extends Renderer {
        render(container, options) {
          var _a, _b;
          let label = (_a = options === null || options === void 0 ? void 0 : options.children) === null || _a === void 0 ? void 0 : _a[0];
          if (typeof label !== "string") {
            label = void 0;
          }
          this._icon.element({
            container,
            label,
            ...(_b = this._rendererOptions) === null || _b === void 0 ? void 0 : _b.props,
            ...options === null || options === void 0 ? void 0 : options.props
          });
        }
      }
      Private36.ElementRenderer = ElementRenderer;
      class ReactRenderer extends Renderer {
        constructor() {
          super(...arguments);
          this._rootDOM = null;
        }
        render(container, options) {
          var _a, _b;
          let label = (_a = options === null || options === void 0 ? void 0 : options.children) === null || _a === void 0 ? void 0 : _a[0];
          if (typeof label !== "string") {
            label = void 0;
          }
          const icon = this._icon;
          if (this._rootDOM !== null) {
            this._rootDOM.unmount();
          }
          this._rootDOM = (0, import_client.createRoot)(container);
          this._rootDOM.render(import_react.default.createElement(icon.react, { container, label, ...(_b = this._rendererOptions) === null || _b === void 0 ? void 0 : _b.props, ...options === null || options === void 0 ? void 0 : options.props }));
        }
        unrender(container) {
          if (this._rootDOM !== null) {
            this._rootDOM.unmount();
            this._rootDOM = null;
          }
        }
      }
      Private36.ReactRenderer = ReactRenderer;
    })(Private5 || (Private5 = {}));
    badIcon = new LabIcon({
      name: "ui-components:bad",
      svgstr: bad_default
    });
    blankIcon = new LabIcon({
      name: "ui-components:blank",
      svgstr: blank_default
    });
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/add-above.svg
var add_above_default;
var init_add_above = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/add-above.svg"() {
    add_above_default = "/build/_assets/add-above-5YUGWHEL.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/add-below.svg
var add_below_default;
var init_add_below = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/add-below.svg"() {
    add_below_default = "/build/_assets/add-below-XTZUELQC.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/add.svg
var add_default;
var init_add = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/add.svg"() {
    add_default = "/build/_assets/add-R4QSNJUY.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/bell.svg
var bell_default;
var init_bell = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/bell.svg"() {
    bell_default = "/build/_assets/bell-XTFPCACC.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/bug-dot.svg
var bug_dot_default;
var init_bug_dot = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/bug-dot.svg"() {
    bug_dot_default = "/build/_assets/bug-dot-GJV4IWQD.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/bug.svg
var bug_default;
var init_bug = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/bug.svg"() {
    bug_default = "/build/_assets/bug-4MAGJLKH.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/build.svg
var build_default;
var init_build = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/build.svg"() {
    build_default = "/build/_assets/build-4P67M2HU.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-down-empty.svg
var caret_down_empty_default;
var init_caret_down_empty = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-down-empty.svg"() {
    caret_down_empty_default = "/build/_assets/caret-down-empty-C224CN6A.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-down-empty-thin.svg
var caret_down_empty_thin_default;
var init_caret_down_empty_thin = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-down-empty-thin.svg"() {
    caret_down_empty_thin_default = "/build/_assets/caret-down-empty-thin-62EUTBPL.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-down.svg
var caret_down_default;
var init_caret_down = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-down.svg"() {
    caret_down_default = "/build/_assets/caret-down-CYALMSQQ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-left.svg
var caret_left_default;
var init_caret_left = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-left.svg"() {
    caret_left_default = "/build/_assets/caret-left-2YD4AJB4.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-right.svg
var caret_right_default;
var init_caret_right = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-right.svg"() {
    caret_right_default = "/build/_assets/caret-right-IW4L2CPJ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-up-empty-thin.svg
var caret_up_empty_thin_default;
var init_caret_up_empty_thin = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-up-empty-thin.svg"() {
    caret_up_empty_thin_default = "/build/_assets/caret-up-empty-thin-SETVTKOF.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-up.svg
var caret_up_default;
var init_caret_up = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-up.svg"() {
    caret_up_default = "/build/_assets/caret-up-TOMNEAKL.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/search/case-sensitive.svg
var case_sensitive_default;
var init_case_sensitive = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/search/case-sensitive.svg"() {
    case_sensitive_default = "/build/_assets/case-sensitive-5LX6IVLO.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/check.svg
var check_default;
var init_check = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/check.svg"() {
    check_default = "/build/_assets/check-BGI5YJWW.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/circle-empty.svg
var circle_empty_default;
var init_circle_empty = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/circle-empty.svg"() {
    circle_empty_default = "/build/_assets/circle-empty-JWWVJYTX.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/circle.svg
var circle_default;
var init_circle = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/circle.svg"() {
    circle_default = "/build/_assets/circle-CFDAPZA5.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/clear.svg
var clear_default;
var init_clear = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/clear.svg"() {
    clear_default = "/build/_assets/clear-6JK5E7JJ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/close.svg
var close_default;
var init_close = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/close.svg"() {
    close_default = "/build/_assets/close-KY5U6SOK.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/lsp/code-check.svg
var code_check_default;
var init_code_check = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/lsp/code-check.svg"() {
    code_check_default = "/build/_assets/code-check-THKPADVL.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/code.svg
var code_default;
var init_code = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/code.svg"() {
    code_default = "/build/_assets/code-7PPO5FGB.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/collapse-all.svg
var collapse_all_default;
var init_collapse_all = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/collapse-all.svg"() {
    collapse_all_default = "/build/_assets/collapse-all-IGZNY6Q5.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/output/collapse.svg
var collapse_default;
var init_collapse = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/output/collapse.svg"() {
    collapse_default = "/build/_assets/collapse-C2PMEO4Q.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/console.svg
var console_default;
var init_console = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/console.svg"() {
    console_default = "/build/_assets/console-K43B5JT7.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/copy.svg
var copy_default;
var init_copy = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/copy.svg"() {
    copy_default = "/build/_assets/copy-FP6F2OIW.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/licenses/copyright.svg
var copyright_default;
var init_copyright = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/licenses/copyright.svg"() {
    copyright_default = "/build/_assets/copyright-6OHU5QAV.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/cut.svg
var cut_default;
var init_cut = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/cut.svg"() {
    cut_default = "/build/_assets/cut-DDW54OJN.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/delete.svg
var delete_default;
var init_delete = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/delete.svg"() {
    delete_default = "/build/_assets/delete-U532KYVM.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/download.svg
var download_default;
var init_download = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/download.svg"() {
    download_default = "/build/_assets/download-4ASFXPY5.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/duplicate.svg
var duplicate_default;
var init_duplicate = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/duplicate.svg"() {
    duplicate_default = "/build/_assets/duplicate-RAKUKHXI.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/edit.svg
var edit_default;
var init_edit = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/edit.svg"() {
    edit_default = "/build/_assets/edit-P66G3NF6.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/ellipses.svg
var ellipses_default;
var init_ellipses = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/ellipses.svg"() {
    ellipses_default = "/build/_assets/ellipses-3ORICEZC.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/error.svg
var error_default;
var init_error = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/error.svg"() {
    error_default = "/build/_assets/error-BSXZ5JTK.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/expand-all.svg
var expand_all_default;
var init_expand_all = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/expand-all.svg"() {
    expand_all_default = "/build/_assets/expand-all-QG3DD7QQ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/output/expand.svg
var expand_default;
var init_expand = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/output/expand.svg"() {
    expand_default = "/build/_assets/expand-77OPYSCB.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/extension.svg
var extension_default;
var init_extension = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/extension.svg"() {
    extension_default = "/build/_assets/extension-KA4GVHFP.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/fast-forward.svg
var fast_forward_default;
var init_fast_forward = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/fast-forward.svg"() {
    fast_forward_default = "/build/_assets/fast-forward-7ARDBRH6.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/file.svg
var file_default;
var init_file = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/file.svg"() {
    file_default = "/build/_assets/file-QCU7GBDL.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/file-upload.svg
var file_upload_default;
var init_file_upload = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/file-upload.svg"() {
    file_upload_default = "/build/_assets/file-upload-IT6YG7XR.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/search/filter-dot.svg
var filter_dot_default;
var init_filter_dot = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/search/filter-dot.svg"() {
    filter_dot_default = "/build/_assets/filter-dot-I75JHRGQ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/filter-list.svg
var filter_list_default;
var init_filter_list = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/filter-list.svg"() {
    filter_list_default = "/build/_assets/filter-list-TZYMSOVE.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/search/filter.svg
var filter_default;
var init_filter = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/search/filter.svg"() {
    filter_default = "/build/_assets/filter-KOH6RC3B.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/folder-favorite.svg
var folder_favorite_default;
var init_folder_favorite = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/folder-favorite.svg"() {
    folder_favorite_default = "/build/_assets/folder-favorite-P6GJXVI6.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/folder.svg
var folder_default;
var init_folder = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/folder.svg"() {
    folder_default = "/build/_assets/folder-BURVVL75.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/history.svg
var history_default;
var init_history = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/history.svg"() {
    history_default = "/build/_assets/history-XTLSRP5T.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/home.svg
var home_default;
var init_home = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/home.svg"() {
    home_default = "/build/_assets/home-GKXJSXEV.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/html5.svg
var html5_default;
var init_html5 = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/html5.svg"() {
    html5_default = "/build/_assets/html5-5JBVHEQW.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/image.svg
var image_default;
var init_image = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/image.svg"() {
    image_default = "/build/_assets/image-QI2XIR4Y.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/info.svg
var info_default;
var init_info = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/info.svg"() {
    info_default = "/build/_assets/info-JWBOWQKJ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/inspector.svg
var inspector_default;
var init_inspector = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/inspector.svg"() {
    inspector_default = "/build/_assets/inspector-PEOMAXL2.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/json.svg
var json_default;
var init_json = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/json.svg"() {
    json_default = "/build/_assets/json-ULBJNO2U.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/julia.svg
var julia_default;
var init_julia = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/julia.svg"() {
    julia_default = "/build/_assets/julia-JGNMOTXV.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/jupyter/jupyter-favicon.svg
var jupyter_favicon_default;
var init_jupyter_favicon = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/jupyter/jupyter-favicon.svg"() {
    jupyter_favicon_default = "/build/_assets/jupyter-favicon-WGOYKUNP.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/jupyter/jupyter.svg
var jupyter_default;
var init_jupyter = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/jupyter/jupyter.svg"() {
    jupyter_default = "/build/_assets/jupyter-USEHDJ5T.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/jupyter/jupyterlab-wordmark.svg
var jupyterlab_wordmark_default;
var init_jupyterlab_wordmark = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/jupyter/jupyterlab-wordmark.svg"() {
    jupyterlab_wordmark_default = "/build/_assets/jupyterlab-wordmark-MKAFM6T5.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/kernel.svg
var kernel_default;
var init_kernel = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/kernel.svg"() {
    kernel_default = "/build/_assets/kernel-E46TPADG.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/keyboard.svg
var keyboard_default;
var init_keyboard = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/keyboard.svg"() {
    keyboard_default = "/build/_assets/keyboard-HMYUYZPR.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/launch.svg
var launch_default;
var init_launch = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/launch.svg"() {
    launch_default = "/build/_assets/launch-MQLWQPN7.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/launcher.svg
var launcher_default;
var init_launcher = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/launcher.svg"() {
    launcher_default = "/build/_assets/launcher-ARJ62GM7.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/line-form.svg
var line_form_default;
var init_line_form = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/line-form.svg"() {
    line_form_default = "/build/_assets/line-form-HY4KWCNU.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/link.svg
var link_default;
var init_link = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/link.svg"() {
    link_default = "/build/_assets/link-C4HM3C65.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/list.svg
var list_default;
var init_list = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/list.svg"() {
    list_default = "/build/_assets/list-YSFA3VHH.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/lock.svg
var lock_default;
var init_lock = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/lock.svg"() {
    lock_default = "/build/_assets/lock-DPKNOS2X.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/markdown.svg
var markdown_default;
var init_markdown = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/markdown.svg"() {
    markdown_default = "/build/_assets/markdown-MCLUEZEQ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/mermaid.svg
var mermaid_default;
var init_mermaid = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/mermaid.svg"() {
    mermaid_default = "/build/_assets/mermaid-ISW5FHBY.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/move-down.svg
var move_down_default;
var init_move_down = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/move-down.svg"() {
    move_down_default = "/build/_assets/move-down-LZFDSSAO.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/move-up.svg
var move_up_default;
var init_move_up = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/move-up.svg"() {
    move_up_default = "/build/_assets/move-up-7KAUBHLO.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/new-folder.svg
var new_folder_default;
var init_new_folder = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/new-folder.svg"() {
    new_folder_default = "/build/_assets/new-folder-4POV3OI6.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/not-trusted.svg
var not_trusted_default;
var init_not_trusted = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/not-trusted.svg"() {
    not_trusted_default = "/build/_assets/not-trusted-RPAXQIYX.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/notebook.svg
var notebook_default;
var init_notebook = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/notebook.svg"() {
    notebook_default = "/build/_assets/notebook-TNDUP2XK.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/numbering.svg
var numbering_default;
var init_numbering = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/numbering.svg"() {
    numbering_default = "/build/_assets/numbering-MCTHQ3MW.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/offline-bolt.svg
var offline_bolt_default;
var init_offline_bolt = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/offline-bolt.svg"() {
    offline_bolt_default = "/build/_assets/offline-bolt-RWKC3GUI.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/palette.svg
var palette_default;
var init_palette = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/palette.svg"() {
    palette_default = "/build/_assets/palette-CTCHBG7A.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/paste.svg
var paste_default;
var init_paste = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/paste.svg"() {
    paste_default = "/build/_assets/paste-HU6K3T27.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/pdf.svg
var pdf_default;
var init_pdf = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/pdf.svg"() {
    pdf_default = "/build/_assets/pdf-62Q5YWM4.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/python.svg
var python_default;
var init_python = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/python.svg"() {
    python_default = "/build/_assets/python-B77NBISZ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/r-kernel.svg
var r_kernel_default;
var init_r_kernel = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/r-kernel.svg"() {
    r_kernel_default = "/build/_assets/r-kernel-ZNBGLYKY.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/react.svg
var react_default;
var init_react = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/react.svg"() {
    react_default = "/build/_assets/react-ZAPRXB2F.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/redo.svg
var redo_default;
var init_redo = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/redo.svg"() {
    redo_default = "/build/_assets/redo-5TXV6DBU.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/search/regex.svg
var regex_default;
var init_regex = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/search/regex.svg"() {
    regex_default = "/build/_assets/regex-7KC5URCX.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/run.svg
var run_default;
var init_run = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/run.svg"() {
    run_default = "/build/_assets/run-ZPPLPQFU.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/running.svg
var running_default;
var init_running = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/running.svg"() {
    running_default = "/build/_assets/running-TCIMS2WE.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/save.svg
var save_default;
var init_save = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/save.svg"() {
    save_default = "/build/_assets/save-FSPSDJ5V.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/search.svg
var search_default;
var init_search = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/search.svg"() {
    search_default = "/build/_assets/search-O43R74CO.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/settings.svg
var settings_default;
var init_settings = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/settings.svg"() {
    settings_default = "/build/_assets/settings-IVH6KP2C.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/share.svg
var share_default;
var init_share = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/share.svg"() {
    share_default = "/build/_assets/share-ZS7CIGX5.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/spreadsheet.svg
var spreadsheet_default;
var init_spreadsheet = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/spreadsheet.svg"() {
    spreadsheet_default = "/build/_assets/spreadsheet-JBVNHDBW.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/stop.svg
var stop_default;
var init_stop = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/stop.svg"() {
    stop_default = "/build/_assets/stop-RBUW2A4K.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/tab.svg
var tab_default;
var init_tab = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/tab.svg"() {
    tab_default = "/build/_assets/tab-M5UDZMG6.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/table-rows.svg
var table_rows_default;
var init_table_rows = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/table-rows.svg"() {
    table_rows_default = "/build/_assets/table-rows-CBJWS37D.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/tag.svg
var tag_default;
var init_tag = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/tag.svg"() {
    tag_default = "/build/_assets/tag-RCD4RZM3.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/terminal.svg
var terminal_default;
var init_terminal = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/terminal.svg"() {
    terminal_default = "/build/_assets/terminal-BKHLQYWP.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/text-editor.svg
var text_editor_default;
var init_text_editor = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/text-editor.svg"() {
    text_editor_default = "/build/_assets/text-editor-KKUF4F2Y.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/toc.svg
var toc_default;
var init_toc = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/toc.svg"() {
    toc_default = "/build/_assets/toc-AVEQ4F4P.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/tree-view.svg
var tree_view_default;
var init_tree_view = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/tree-view.svg"() {
    tree_view_default = "/build/_assets/tree-view-BKKNCOY2.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/trusted.svg
var trusted_default;
var init_trusted = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/trusted.svg"() {
    trusted_default = "/build/_assets/trusted-HLBBEL7Z.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/undo.svg
var undo_default;
var init_undo = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/undo.svg"() {
    undo_default = "/build/_assets/undo-BRNP5XMB.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/user.svg
var user_default;
var init_user = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/user.svg"() {
    user_default = "/build/_assets/user-UEYWBMNL.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/users.svg
var users_default;
var init_users = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/users.svg"() {
    users_default = "/build/_assets/users-ZOUO3MZX.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/vega.svg
var vega_default;
var init_vega = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/vega.svg"() {
    vega_default = "/build/_assets/vega-YCXHCRWI.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/search/word.svg
var word_default;
var init_word = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/search/word.svg"() {
    word_default = "/build/_assets/word-ZGJUELHU.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/yaml.svg
var yaml_default;
var init_yaml = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/yaml.svg"() {
    yaml_default = "/build/_assets/yaml-EZ7PS4QK.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/icon/iconimports.js
var addAboveIcon, addBelowIcon, addIcon, bellIcon, bugDotIcon, bugIcon, buildIcon, caretDownEmptyIcon, caretDownEmptyThinIcon, caretDownIcon, caretLeftIcon, caretRightIcon, caretUpEmptyThinIcon, caretUpIcon, caseSensitiveIcon, checkIcon, circleEmptyIcon, circleIcon, clearIcon, closeIcon, codeCheckIcon, codeIcon, collapseAllIcon, collapseIcon, consoleIcon, copyIcon, copyrightIcon, cutIcon, deleteIcon, downloadIcon, duplicateIcon, editIcon, ellipsesIcon, errorIcon, expandAllIcon, expandIcon, extensionIcon, fastForwardIcon, fileIcon, fileUploadIcon, filterDotIcon, filterIcon, filterListIcon, folderFavoriteIcon, folderIcon, historyIcon, homeIcon, html5Icon, imageIcon, infoIcon, inspectorIcon, jsonIcon, juliaIcon, jupyterFaviconIcon, jupyterIcon, jupyterlabWordmarkIcon, kernelIcon, keyboardIcon, launchIcon, launcherIcon, lineFormIcon, linkIcon, listIcon, lockIcon, markdownIcon, mermaidIcon, moveDownIcon, moveUpIcon, newFolderIcon, notTrustedIcon, notebookIcon, numberingIcon, offlineBoltIcon, paletteIcon, pasteIcon, pdfIcon, pythonIcon, rKernelIcon, reactIcon, redoIcon, refreshIcon, regexIcon, runIcon, runningIcon, saveIcon, searchIcon, settingsIcon, shareIcon, spreadsheetIcon, stopIcon, tabIcon, tableRowsIcon, tagIcon, terminalIcon, textEditorIcon, tocIcon, treeViewIcon, trustedIcon, undoIcon, userIcon, usersIcon, vegaIcon, wordIcon, yamlIcon;
var init_iconimports = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/icon/iconimports.js"() {
    init_labicon();
    init_add_above();
    init_add_below();
    init_add();
    init_bell();
    init_bug_dot();
    init_bug();
    init_build();
    init_caret_down_empty();
    init_caret_down_empty_thin();
    init_caret_down();
    init_caret_left();
    init_caret_right();
    init_caret_up_empty_thin();
    init_caret_up();
    init_case_sensitive();
    init_check();
    init_circle_empty();
    init_circle();
    init_clear();
    init_close();
    init_code_check();
    init_code();
    init_collapse_all();
    init_collapse();
    init_console();
    init_copy();
    init_copyright();
    init_cut();
    init_delete();
    init_download();
    init_duplicate();
    init_edit();
    init_ellipses();
    init_error();
    init_expand_all();
    init_expand();
    init_extension();
    init_fast_forward();
    init_file();
    init_file_upload();
    init_filter_dot();
    init_filter_list();
    init_filter();
    init_folder_favorite();
    init_folder();
    init_history();
    init_home();
    init_html5();
    init_image();
    init_info();
    init_inspector();
    init_json();
    init_julia();
    init_jupyter_favicon();
    init_jupyter();
    init_jupyterlab_wordmark();
    init_kernel();
    init_keyboard();
    init_launch();
    init_launcher();
    init_line_form();
    init_link();
    init_list();
    init_lock();
    init_markdown();
    init_mermaid();
    init_move_down();
    init_move_up();
    init_new_folder();
    init_not_trusted();
    init_notebook();
    init_numbering();
    init_offline_bolt();
    init_palette();
    init_paste();
    init_pdf();
    init_python();
    init_r_kernel();
    init_react();
    init_redo();
    init_refresh();
    init_regex();
    init_run();
    init_running();
    init_save();
    init_search();
    init_settings();
    init_share();
    init_spreadsheet();
    init_stop();
    init_tab();
    init_table_rows();
    init_tag();
    init_terminal();
    init_text_editor();
    init_toc();
    init_tree_view();
    init_trusted();
    init_undo();
    init_user();
    init_users();
    init_vega();
    init_word();
    init_yaml();
    addAboveIcon = new LabIcon({ name: "ui-components:add-above", svgstr: add_above_default });
    addBelowIcon = new LabIcon({ name: "ui-components:add-below", svgstr: add_below_default });
    addIcon = new LabIcon({ name: "ui-components:add", svgstr: add_default });
    bellIcon = new LabIcon({ name: "ui-components:bell", svgstr: bell_default });
    bugDotIcon = new LabIcon({ name: "ui-components:bug-dot", svgstr: bug_dot_default });
    bugIcon = new LabIcon({ name: "ui-components:bug", svgstr: bug_default });
    buildIcon = new LabIcon({ name: "ui-components:build", svgstr: build_default });
    caretDownEmptyIcon = new LabIcon({ name: "ui-components:caret-down-empty", svgstr: caret_down_empty_default });
    caretDownEmptyThinIcon = new LabIcon({ name: "ui-components:caret-down-empty-thin", svgstr: caret_down_empty_thin_default });
    caretDownIcon = new LabIcon({ name: "ui-components:caret-down", svgstr: caret_down_default });
    caretLeftIcon = new LabIcon({ name: "ui-components:caret-left", svgstr: caret_left_default });
    caretRightIcon = new LabIcon({ name: "ui-components:caret-right", svgstr: caret_right_default });
    caretUpEmptyThinIcon = new LabIcon({ name: "ui-components:caret-up-empty-thin", svgstr: caret_up_empty_thin_default });
    caretUpIcon = new LabIcon({ name: "ui-components:caret-up", svgstr: caret_up_default });
    caseSensitiveIcon = new LabIcon({ name: "ui-components:case-sensitive", svgstr: case_sensitive_default });
    checkIcon = new LabIcon({ name: "ui-components:check", svgstr: check_default });
    circleEmptyIcon = new LabIcon({ name: "ui-components:circle-empty", svgstr: circle_empty_default });
    circleIcon = new LabIcon({ name: "ui-components:circle", svgstr: circle_default });
    clearIcon = new LabIcon({ name: "ui-components:clear", svgstr: clear_default });
    closeIcon = new LabIcon({ name: "ui-components:close", svgstr: close_default });
    codeCheckIcon = new LabIcon({ name: "ui-components:code-check", svgstr: code_check_default });
    codeIcon = new LabIcon({ name: "ui-components:code", svgstr: code_default });
    collapseAllIcon = new LabIcon({ name: "ui-components:collapse-all", svgstr: collapse_all_default });
    collapseIcon = new LabIcon({ name: "ui-components:collapse", svgstr: collapse_default });
    consoleIcon = new LabIcon({ name: "ui-components:console", svgstr: console_default });
    copyIcon = new LabIcon({ name: "ui-components:copy", svgstr: copy_default });
    copyrightIcon = new LabIcon({ name: "ui-components:copyright", svgstr: copyright_default });
    cutIcon = new LabIcon({ name: "ui-components:cut", svgstr: cut_default });
    deleteIcon = new LabIcon({ name: "ui-components:delete", svgstr: delete_default });
    downloadIcon = new LabIcon({ name: "ui-components:download", svgstr: download_default });
    duplicateIcon = new LabIcon({ name: "ui-components:duplicate", svgstr: duplicate_default });
    editIcon = new LabIcon({ name: "ui-components:edit", svgstr: edit_default });
    ellipsesIcon = new LabIcon({ name: "ui-components:ellipses", svgstr: ellipses_default });
    errorIcon = new LabIcon({ name: "ui-components:error", svgstr: error_default });
    expandAllIcon = new LabIcon({ name: "ui-components:expand-all", svgstr: expand_all_default });
    expandIcon = new LabIcon({ name: "ui-components:expand", svgstr: expand_default });
    extensionIcon = new LabIcon({ name: "ui-components:extension", svgstr: extension_default });
    fastForwardIcon = new LabIcon({ name: "ui-components:fast-forward", svgstr: fast_forward_default });
    fileIcon = new LabIcon({ name: "ui-components:file", svgstr: file_default });
    fileUploadIcon = new LabIcon({ name: "ui-components:file-upload", svgstr: file_upload_default });
    filterDotIcon = new LabIcon({ name: "ui-components:filter-dot", svgstr: filter_dot_default });
    filterIcon = new LabIcon({ name: "ui-components:filter", svgstr: filter_default });
    filterListIcon = new LabIcon({ name: "ui-components:filter-list", svgstr: filter_list_default });
    folderFavoriteIcon = new LabIcon({ name: "ui-components:folder-favorite", svgstr: folder_favorite_default });
    folderIcon = new LabIcon({ name: "ui-components:folder", svgstr: folder_default });
    historyIcon = new LabIcon({ name: "ui-components:history", svgstr: history_default });
    homeIcon = new LabIcon({ name: "ui-components:home", svgstr: home_default });
    html5Icon = new LabIcon({ name: "ui-components:html5", svgstr: html5_default });
    imageIcon = new LabIcon({ name: "ui-components:image", svgstr: image_default });
    infoIcon = new LabIcon({ name: "ui-components:info", svgstr: info_default });
    inspectorIcon = new LabIcon({ name: "ui-components:inspector", svgstr: inspector_default });
    jsonIcon = new LabIcon({ name: "ui-components:json", svgstr: json_default });
    juliaIcon = new LabIcon({ name: "ui-components:julia", svgstr: julia_default });
    jupyterFaviconIcon = new LabIcon({ name: "ui-components:jupyter-favicon", svgstr: jupyter_favicon_default });
    jupyterIcon = new LabIcon({ name: "ui-components:jupyter", svgstr: jupyter_default });
    jupyterlabWordmarkIcon = new LabIcon({ name: "ui-components:jupyterlab-wordmark", svgstr: jupyterlab_wordmark_default });
    kernelIcon = new LabIcon({ name: "ui-components:kernel", svgstr: kernel_default });
    keyboardIcon = new LabIcon({ name: "ui-components:keyboard", svgstr: keyboard_default });
    launchIcon = new LabIcon({ name: "ui-components:launch", svgstr: launch_default });
    launcherIcon = new LabIcon({ name: "ui-components:launcher", svgstr: launcher_default });
    lineFormIcon = new LabIcon({ name: "ui-components:line-form", svgstr: line_form_default });
    linkIcon = new LabIcon({ name: "ui-components:link", svgstr: link_default });
    listIcon = new LabIcon({ name: "ui-components:list", svgstr: list_default });
    lockIcon = new LabIcon({ name: "ui-components:lock", svgstr: lock_default });
    markdownIcon = new LabIcon({ name: "ui-components:markdown", svgstr: markdown_default });
    mermaidIcon = new LabIcon({ name: "ui-components:mermaid", svgstr: mermaid_default });
    moveDownIcon = new LabIcon({ name: "ui-components:move-down", svgstr: move_down_default });
    moveUpIcon = new LabIcon({ name: "ui-components:move-up", svgstr: move_up_default });
    newFolderIcon = new LabIcon({ name: "ui-components:new-folder", svgstr: new_folder_default });
    notTrustedIcon = new LabIcon({ name: "ui-components:not-trusted", svgstr: not_trusted_default });
    notebookIcon = new LabIcon({ name: "ui-components:notebook", svgstr: notebook_default });
    numberingIcon = new LabIcon({ name: "ui-components:numbering", svgstr: numbering_default });
    offlineBoltIcon = new LabIcon({ name: "ui-components:offline-bolt", svgstr: offline_bolt_default });
    paletteIcon = new LabIcon({ name: "ui-components:palette", svgstr: palette_default });
    pasteIcon = new LabIcon({ name: "ui-components:paste", svgstr: paste_default });
    pdfIcon = new LabIcon({ name: "ui-components:pdf", svgstr: pdf_default });
    pythonIcon = new LabIcon({ name: "ui-components:python", svgstr: python_default });
    rKernelIcon = new LabIcon({ name: "ui-components:r-kernel", svgstr: r_kernel_default });
    reactIcon = new LabIcon({ name: "ui-components:react", svgstr: react_default });
    redoIcon = new LabIcon({ name: "ui-components:redo", svgstr: redo_default });
    refreshIcon = new LabIcon({ name: "ui-components:refresh", svgstr: refresh_default });
    regexIcon = new LabIcon({ name: "ui-components:regex", svgstr: regex_default });
    runIcon = new LabIcon({ name: "ui-components:run", svgstr: run_default });
    runningIcon = new LabIcon({ name: "ui-components:running", svgstr: running_default });
    saveIcon = new LabIcon({ name: "ui-components:save", svgstr: save_default });
    searchIcon = new LabIcon({ name: "ui-components:search", svgstr: search_default });
    settingsIcon = new LabIcon({ name: "ui-components:settings", svgstr: settings_default });
    shareIcon = new LabIcon({ name: "ui-components:share", svgstr: share_default });
    spreadsheetIcon = new LabIcon({ name: "ui-components:spreadsheet", svgstr: spreadsheet_default });
    stopIcon = new LabIcon({ name: "ui-components:stop", svgstr: stop_default });
    tabIcon = new LabIcon({ name: "ui-components:tab", svgstr: tab_default });
    tableRowsIcon = new LabIcon({ name: "ui-components:table-rows", svgstr: table_rows_default });
    tagIcon = new LabIcon({ name: "ui-components:tag", svgstr: tag_default });
    terminalIcon = new LabIcon({ name: "ui-components:terminal", svgstr: terminal_default });
    textEditorIcon = new LabIcon({ name: "ui-components:text-editor", svgstr: text_editor_default });
    tocIcon = new LabIcon({ name: "ui-components:toc", svgstr: toc_default });
    treeViewIcon = new LabIcon({ name: "ui-components:tree-view", svgstr: tree_view_default });
    trustedIcon = new LabIcon({ name: "ui-components:trusted", svgstr: trusted_default });
    undoIcon = new LabIcon({ name: "ui-components:undo", svgstr: undo_default });
    userIcon = new LabIcon({ name: "ui-components:user", svgstr: user_default });
    usersIcon = new LabIcon({ name: "ui-components:users", svgstr: users_default });
    vegaIcon = new LabIcon({ name: "ui-components:vega", svgstr: vega_default });
    wordIcon = new LabIcon({ name: "ui-components:word", svgstr: word_default });
    yamlIcon = new LabIcon({ name: "ui-components:yaml", svgstr: yaml_default });
  }
});

// ../../node_modules/@lumino/virtualdom/node_modules/@lumino/algorithm/dist/index.es6.js
var ArrayExt2, Private6, StringExt2;
var init_index_es66 = __esm({
  "../../node_modules/@lumino/virtualdom/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt8) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start + i) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start - i + n) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start + i) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findFirstIndex = findFirstIndex;
      function findLastIndex2(array, fn, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let d;
        if (start < stop) {
          d = start + 1 + (n - stop);
        } else {
          d = start - stop + 1;
        }
        for (let i = 0; i < d; ++i) {
          let j = (start - i + n) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findLastIndex = findLastIndex2;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index = findFirstIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index = findLastIndex2(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt8.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt8.upperBound = upperBound;
      function shallowEqual(a, b, fn) {
        if (a === b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0, n = a.length; i < n; ++i) {
          if (fn ? !fn(a[i], b[i]) : a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt8.shallowEqual = shallowEqual;
      function slice(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n = array.length;
        if (start === void 0) {
          start = step < 0 ? n - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n, step < 0 ? -1 : 0);
        } else if (start >= n) {
          start = step < 0 ? n - 1 : n;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n;
        } else if (stop < 0) {
          stop = Math.max(stop + n, step < 0 ? -1 : 0);
        } else if (stop >= n) {
          stop = step < 0 ? n - 1 : n;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result = [];
        for (let i = 0; i < length; ++i) {
          result[i] = array[start + i * step];
        }
        return result;
      }
      ArrayExt8.slice = slice;
      function move(array, fromIndex, toIndex) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n);
        } else {
          fromIndex = Math.min(fromIndex, n - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n);
        } else {
          toIndex = Math.min(toIndex, n - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d = fromIndex < toIndex ? 1 : -1;
        for (let i = fromIndex; i !== toIndex; i += d) {
          array[i] = array[i + d];
        }
        array[toIndex] = value;
      }
      ArrayExt8.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        while (start < stop) {
          let a = array[start];
          let b = array[stop];
          array[start++] = b;
          array[stop--] = a;
        }
      }
      ArrayExt8.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt8.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          array[(start + i) % n] = value;
        }
      }
      ArrayExt8.fill = fill;
      function insert(array, index, value) {
        let n = array.length;
        if (index < 0) {
          index = Math.max(0, index + n);
        } else {
          index = Math.min(index, n);
        }
        for (let i = n; i > index; --i) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      ArrayExt8.insert = insert;
      function removeAt(array, index) {
        let n = array.length;
        if (index < 0) {
          index += n;
        }
        if (index < 0 || index >= n) {
          return void 0;
        }
        let value = array[index];
        for (let i = index + 1; i < n; ++i) {
          array[i - 1] = array[i];
        }
        array.length = n - 1;
        return value;
      }
      ArrayExt8.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index = firstIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index = lastIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i = 0; i < n; ++i) {
          if (start <= stop && i >= start && i <= stop && array[i] === value) {
            count++;
          } else if (stop < start && (i <= stop || i >= start) && array[i] === value) {
            count++;
          } else if (count > 0) {
            array[i - count] = array[i];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index = findFirstIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index = findLastIndex2(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i = 0; i < n; ++i) {
          if (start <= stop && i >= start && i <= stop && fn(array[i], i)) {
            count++;
          } else if (stop < start && (i <= stop || i >= start) && fn(array[i], i)) {
            count++;
          } else if (count > 0) {
            array[i - count] = array[i];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllWhere = removeAllWhere;
    })(ArrayExt2 || (ArrayExt2 = {}));
    (function(Private36) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private36.rangeLength = rangeLength;
    })(Private6 || (Private6 = {}));
    (function(StringExt8) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i = 0, j = start, n = query.length; i < n; ++i, ++j) {
          j = source.indexOf(query[i], j);
          if (j === -1) {
            return null;
          }
          indices[i] = j;
        }
        return indices;
      }
      StringExt8.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i = 0, n = indices.length; i < n; ++i) {
          let j = indices[i] - start;
          score += j * j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last = start - 1;
        for (let i = 0, n = indices.length; i < n; ++i) {
          let j = indices[i];
          score += j - last - 1;
          last = j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result = [];
        let k = 0;
        let last = 0;
        let n = indices.length;
        while (k < n) {
          let i = indices[k];
          let j = indices[k];
          while (++k < n && indices[k] === j + 1) {
            j++;
          }
          if (last < i) {
            result.push(source.slice(last, i));
          }
          if (i < j + 1) {
            result.push(fn(source.slice(i, j + 1)));
          }
          last = j + 1;
        }
        if (last < source.length) {
          result.push(source.slice(last));
        }
        return result;
      }
      StringExt8.highlight = highlight;
      function cmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      StringExt8.cmp = cmp;
    })(StringExt2 || (StringExt2 = {}));
  }
});

// ../../node_modules/@lumino/virtualdom/dist/index.es6.js
function h(tag) {
  let attrs = {};
  let renderer;
  let children2 = [];
  for (let i = 1, n = arguments.length; i < n; ++i) {
    let arg = arguments[i];
    if (typeof arg === "string") {
      children2.push(new VirtualText(arg));
    } else if (arg instanceof VirtualText) {
      children2.push(arg);
    } else if (arg instanceof VirtualElement) {
      children2.push(arg);
    } else if (arg instanceof Array) {
      extend(children2, arg);
    } else if ((i === 1 || i === 2) && arg && typeof arg === "object") {
      if ("render" in arg) {
        renderer = arg;
      } else {
        attrs = arg;
      }
    }
  }
  return new VirtualElement(tag, attrs, children2, renderer);
  function extend(array, values) {
    for (let child of values) {
      if (typeof child === "string") {
        array.push(new VirtualText(child));
      } else if (child instanceof VirtualText) {
        array.push(child);
      } else if (child instanceof VirtualElement) {
        array.push(child);
      }
    }
  }
}
function hpass(tag) {
  let attrs = {};
  let renderer = null;
  if (arguments.length === 2) {
    const arg = arguments[1];
    if ("render" in arg) {
      renderer = arg;
    } else {
      attrs = arg;
    }
  } else if (arguments.length === 3) {
    attrs = arguments[1];
    renderer = arguments[2];
  } else if (arguments.length > 3) {
    throw new Error("hpass() should be called with 1, 2, or 3 arguments");
  }
  return new VirtualElementPass(tag, attrs, renderer);
}
var VirtualText, VirtualElement, VirtualElementPass, VirtualDOM, Private7;
var init_index_es67 = __esm({
  "../../node_modules/@lumino/virtualdom/dist/index.es6.js"() {
    init_index_es66();
    VirtualText = class {
      /**
       * Construct a new virtual text node.
       *
       * @param content - The text content for the node.
       */
      constructor(content) {
        this.type = "text";
        this.content = content;
      }
    };
    VirtualElement = class {
      /**
       * Construct a new virtual element node.
       *
       * @param tag - The element tag name.
       *
       * @param attrs - The element attributes.
       *
       * @param children - The element children.
       *
       * @param renderer - An optional custom renderer for the element.
       */
      constructor(tag, attrs, children2, renderer) {
        this.type = "element";
        this.tag = tag;
        this.attrs = attrs;
        this.children = children2;
        this.renderer = renderer;
      }
    };
    VirtualElementPass = class extends VirtualElement {
      /**
       * DEPRECATED - use VirtualElement with a defined renderer param instead
       *
       * Construct a new virtual element pass thru node.
       *
       * @param tag - the tag of the parent element of this node. Once the parent
       * element is rendered, it will be passed as an argument to
       * renderer.render
       *
       * @param attrs - attributes that will assigned to the
       * parent element
       *
       * @param renderer - an object with render and unrender
       * functions, each of which should take a single argument of type
       * HTMLElement and return nothing. If null, the parent element
       * will be rendered barren without any children.
       */
      constructor(tag, attrs, renderer) {
        super(tag, attrs, [], renderer || void 0);
      }
    };
    (function(h2) {
      h2.a = h2.bind(void 0, "a");
      h2.abbr = h2.bind(void 0, "abbr");
      h2.address = h2.bind(void 0, "address");
      h2.area = h2.bind(void 0, "area");
      h2.article = h2.bind(void 0, "article");
      h2.aside = h2.bind(void 0, "aside");
      h2.audio = h2.bind(void 0, "audio");
      h2.b = h2.bind(void 0, "b");
      h2.bdi = h2.bind(void 0, "bdi");
      h2.bdo = h2.bind(void 0, "bdo");
      h2.blockquote = h2.bind(void 0, "blockquote");
      h2.br = h2.bind(void 0, "br");
      h2.button = h2.bind(void 0, "button");
      h2.canvas = h2.bind(void 0, "canvas");
      h2.caption = h2.bind(void 0, "caption");
      h2.cite = h2.bind(void 0, "cite");
      h2.code = h2.bind(void 0, "code");
      h2.col = h2.bind(void 0, "col");
      h2.colgroup = h2.bind(void 0, "colgroup");
      h2.data = h2.bind(void 0, "data");
      h2.datalist = h2.bind(void 0, "datalist");
      h2.dd = h2.bind(void 0, "dd");
      h2.del = h2.bind(void 0, "del");
      h2.dfn = h2.bind(void 0, "dfn");
      h2.div = h2.bind(void 0, "div");
      h2.dl = h2.bind(void 0, "dl");
      h2.dt = h2.bind(void 0, "dt");
      h2.em = h2.bind(void 0, "em");
      h2.embed = h2.bind(void 0, "embed");
      h2.fieldset = h2.bind(void 0, "fieldset");
      h2.figcaption = h2.bind(void 0, "figcaption");
      h2.figure = h2.bind(void 0, "figure");
      h2.footer = h2.bind(void 0, "footer");
      h2.form = h2.bind(void 0, "form");
      h2.h1 = h2.bind(void 0, "h1");
      h2.h2 = h2.bind(void 0, "h2");
      h2.h3 = h2.bind(void 0, "h3");
      h2.h4 = h2.bind(void 0, "h4");
      h2.h5 = h2.bind(void 0, "h5");
      h2.h6 = h2.bind(void 0, "h6");
      h2.header = h2.bind(void 0, "header");
      h2.hr = h2.bind(void 0, "hr");
      h2.i = h2.bind(void 0, "i");
      h2.iframe = h2.bind(void 0, "iframe");
      h2.img = h2.bind(void 0, "img");
      h2.input = h2.bind(void 0, "input");
      h2.ins = h2.bind(void 0, "ins");
      h2.kbd = h2.bind(void 0, "kbd");
      h2.label = h2.bind(void 0, "label");
      h2.legend = h2.bind(void 0, "legend");
      h2.li = h2.bind(void 0, "li");
      h2.main = h2.bind(void 0, "main");
      h2.map = h2.bind(void 0, "map");
      h2.mark = h2.bind(void 0, "mark");
      h2.meter = h2.bind(void 0, "meter");
      h2.nav = h2.bind(void 0, "nav");
      h2.noscript = h2.bind(void 0, "noscript");
      h2.object = h2.bind(void 0, "object");
      h2.ol = h2.bind(void 0, "ol");
      h2.optgroup = h2.bind(void 0, "optgroup");
      h2.option = h2.bind(void 0, "option");
      h2.output = h2.bind(void 0, "output");
      h2.p = h2.bind(void 0, "p");
      h2.param = h2.bind(void 0, "param");
      h2.pre = h2.bind(void 0, "pre");
      h2.progress = h2.bind(void 0, "progress");
      h2.q = h2.bind(void 0, "q");
      h2.rp = h2.bind(void 0, "rp");
      h2.rt = h2.bind(void 0, "rt");
      h2.ruby = h2.bind(void 0, "ruby");
      h2.s = h2.bind(void 0, "s");
      h2.samp = h2.bind(void 0, "samp");
      h2.section = h2.bind(void 0, "section");
      h2.select = h2.bind(void 0, "select");
      h2.small = h2.bind(void 0, "small");
      h2.source = h2.bind(void 0, "source");
      h2.span = h2.bind(void 0, "span");
      h2.strong = h2.bind(void 0, "strong");
      h2.sub = h2.bind(void 0, "sub");
      h2.summary = h2.bind(void 0, "summary");
      h2.sup = h2.bind(void 0, "sup");
      h2.table = h2.bind(void 0, "table");
      h2.tbody = h2.bind(void 0, "tbody");
      h2.td = h2.bind(void 0, "td");
      h2.textarea = h2.bind(void 0, "textarea");
      h2.tfoot = h2.bind(void 0, "tfoot");
      h2.th = h2.bind(void 0, "th");
      h2.thead = h2.bind(void 0, "thead");
      h2.time = h2.bind(void 0, "time");
      h2.title = h2.bind(void 0, "title");
      h2.tr = h2.bind(void 0, "tr");
      h2.track = h2.bind(void 0, "track");
      h2.u = h2.bind(void 0, "u");
      h2.ul = h2.bind(void 0, "ul");
      h2.var_ = h2.bind(void 0, "var");
      h2.video = h2.bind(void 0, "video");
      h2.wbr = h2.bind(void 0, "wbr");
    })(h || (h = {}));
    (function(VirtualDOM2) {
      function realize(node) {
        return Private7.createDOMNode(node);
      }
      VirtualDOM2.realize = realize;
      function render(content, host) {
        let oldContent = Private7.hostMap.get(host) || [];
        let newContent = Private7.asContentArray(content);
        Private7.hostMap.set(host, newContent);
        Private7.updateContent(host, oldContent, newContent);
      }
      VirtualDOM2.render = render;
    })(VirtualDOM || (VirtualDOM = {}));
    (function(Private36) {
      Private36.hostMap = /* @__PURE__ */ new WeakMap();
      function asContentArray(value) {
        if (!value) {
          return [];
        }
        if (value instanceof Array) {
          return value;
        }
        return [value];
      }
      Private36.asContentArray = asContentArray;
      function createDOMNode(node) {
        let host = arguments[1] || null;
        const before = arguments[2] || null;
        if (host) {
          host.insertBefore(createDOMNode(node), before);
        } else {
          if (node.type === "text") {
            return document.createTextNode(node.content);
          }
          host = document.createElement(node.tag);
          addAttrs(host, node.attrs);
          if (node.renderer) {
            node.renderer.render(host, {
              attrs: node.attrs,
              children: node.children
            });
            return host;
          }
          for (let i = 0, n = node.children.length; i < n; ++i) {
            createDOMNode(node.children[i], host);
          }
        }
        return host;
      }
      Private36.createDOMNode = createDOMNode;
      function updateContent(host, oldContent, newContent) {
        if (oldContent === newContent) {
          return;
        }
        let oldKeyed = collectKeys(host, oldContent);
        let oldCopy = oldContent.slice();
        let currElem = host.firstChild;
        let newCount = newContent.length;
        for (let i = 0; i < newCount; ++i) {
          if (i >= oldCopy.length) {
            createDOMNode(newContent[i], host);
            continue;
          }
          let oldVNode = oldCopy[i];
          let newVNode = newContent[i];
          if (oldVNode === newVNode) {
            currElem = currElem.nextSibling;
            continue;
          }
          if (oldVNode.type === "text" && newVNode.type === "text") {
            if (currElem.textContent !== newVNode.content) {
              currElem.textContent = newVNode.content;
            }
            currElem = currElem.nextSibling;
            continue;
          }
          if (oldVNode.type === "text" || newVNode.type === "text") {
            ArrayExt2.insert(oldCopy, i, newVNode);
            createDOMNode(newVNode, host, currElem);
            continue;
          }
          if (!oldVNode.renderer != !newVNode.renderer) {
            ArrayExt2.insert(oldCopy, i, newVNode);
            createDOMNode(newVNode, host, currElem);
            continue;
          }
          let newKey = newVNode.attrs.key;
          if (newKey && newKey in oldKeyed) {
            let pair = oldKeyed[newKey];
            if (pair.vNode !== oldVNode) {
              ArrayExt2.move(oldCopy, oldCopy.indexOf(pair.vNode, i + 1), i);
              host.insertBefore(pair.element, currElem);
              oldVNode = pair.vNode;
              currElem = pair.element;
            }
          }
          if (oldVNode === newVNode) {
            currElem = currElem.nextSibling;
            continue;
          }
          let oldKey = oldVNode.attrs.key;
          if (oldKey && oldKey !== newKey) {
            ArrayExt2.insert(oldCopy, i, newVNode);
            createDOMNode(newVNode, host, currElem);
            continue;
          }
          if (oldVNode.tag !== newVNode.tag) {
            ArrayExt2.insert(oldCopy, i, newVNode);
            createDOMNode(newVNode, host, currElem);
            continue;
          }
          updateAttrs(currElem, oldVNode.attrs, newVNode.attrs);
          if (newVNode.renderer) {
            newVNode.renderer.render(currElem, {
              attrs: newVNode.attrs,
              children: newVNode.children
            });
          } else {
            updateContent(currElem, oldVNode.children, newVNode.children);
          }
          currElem = currElem.nextSibling;
        }
        removeContent(host, oldCopy, newCount, true);
      }
      Private36.updateContent = updateContent;
      function removeContent(host, oldContent, newCount, _sentinel) {
        for (let i = oldContent.length - 1; i >= newCount; --i) {
          const oldNode = oldContent[i];
          const child = _sentinel ? host.lastChild : host.childNodes[i];
          if (oldNode.type === "text")
            ;
          else if (oldNode.renderer && oldNode.renderer.unrender) {
            oldNode.renderer.unrender(child, {
              attrs: oldNode.attrs,
              children: oldNode.children
            });
          } else {
            removeContent(child, oldNode.children, 0, false);
          }
          if (_sentinel) {
            host.removeChild(child);
          }
        }
      }
      const specialAttrs = {
        key: true,
        className: true,
        htmlFor: true,
        dataset: true,
        style: true
      };
      function addAttrs(element, attrs) {
        for (let name2 in attrs) {
          if (name2 in specialAttrs) {
            continue;
          }
          if (name2.substr(0, 2) === "on") {
            element[name2] = attrs[name2];
          } else {
            element.setAttribute(name2, attrs[name2]);
          }
        }
        if (attrs.className !== void 0) {
          element.setAttribute("class", attrs.className);
        }
        if (attrs.htmlFor !== void 0) {
          element.setAttribute("for", attrs.htmlFor);
        }
        if (attrs.dataset) {
          addDataset(element, attrs.dataset);
        }
        if (attrs.style) {
          addStyle(element, attrs.style);
        }
      }
      function updateAttrs(element, oldAttrs, newAttrs) {
        if (oldAttrs === newAttrs) {
          return;
        }
        let name2;
        for (name2 in oldAttrs) {
          if (name2 in specialAttrs || name2 in newAttrs) {
            continue;
          }
          if (name2.substr(0, 2) === "on") {
            element[name2] = null;
          } else {
            element.removeAttribute(name2);
          }
        }
        for (name2 in newAttrs) {
          if (name2 in specialAttrs || oldAttrs[name2] === newAttrs[name2]) {
            continue;
          }
          if (name2.substr(0, 2) === "on") {
            element[name2] = newAttrs[name2];
          } else {
            element.setAttribute(name2, newAttrs[name2]);
          }
        }
        if (oldAttrs.className !== newAttrs.className) {
          if (newAttrs.className !== void 0) {
            element.setAttribute("class", newAttrs.className);
          } else {
            element.removeAttribute("class");
          }
        }
        if (oldAttrs.htmlFor !== newAttrs.htmlFor) {
          if (newAttrs.htmlFor !== void 0) {
            element.setAttribute("for", newAttrs.htmlFor);
          } else {
            element.removeAttribute("for");
          }
        }
        if (oldAttrs.dataset !== newAttrs.dataset) {
          updateDataset(element, oldAttrs.dataset || {}, newAttrs.dataset || {});
        }
        if (oldAttrs.style !== newAttrs.style) {
          updateStyle(element, oldAttrs.style || {}, newAttrs.style || {});
        }
      }
      function addDataset(element, dataset) {
        for (let name2 in dataset) {
          element.setAttribute(`data-${name2}`, dataset[name2]);
        }
      }
      function updateDataset(element, oldDataset, newDataset) {
        for (let name2 in oldDataset) {
          if (!(name2 in newDataset)) {
            element.removeAttribute(`data-${name2}`);
          }
        }
        for (let name2 in newDataset) {
          if (oldDataset[name2] !== newDataset[name2]) {
            element.setAttribute(`data-${name2}`, newDataset[name2]);
          }
        }
      }
      function addStyle(element, style) {
        let elemStyle = element.style;
        let name2;
        for (name2 in style) {
          elemStyle[name2] = style[name2];
        }
      }
      function updateStyle(element, oldStyle, newStyle) {
        let elemStyle = element.style;
        let name2;
        for (name2 in oldStyle) {
          if (!(name2 in newStyle)) {
            elemStyle[name2] = "";
          }
        }
        for (name2 in newStyle) {
          if (oldStyle[name2] !== newStyle[name2]) {
            elemStyle[name2] = newStyle[name2];
          }
        }
      }
      function collectKeys(host, content) {
        let node = host.firstChild;
        let keyMap = /* @__PURE__ */ Object.create(null);
        for (let vNode of content) {
          if (vNode.type === "element" && vNode.attrs.key) {
            keyMap[vNode.attrs.key] = { vNode, element: node };
          }
          node = node.nextSibling;
        }
        return keyMap;
      }
    })(Private7 || (Private7 = {}));
  }
});

// ../../node_modules/@lumino/widgets/node_modules/@lumino/algorithm/dist/index.es6.js
function* empty() {
  return;
}
function find2(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return value;
    }
  }
  return void 0;
}
function max(object, fn) {
  let result = void 0;
  for (const value of object) {
    if (result === void 0) {
      result = value;
      continue;
    }
    if (fn(value, result) > 0) {
      result = value;
    }
  }
  return result;
}
function every(object, fn) {
  let index = 0;
  for (const value of object) {
    if (false === fn(value, index++)) {
      return false;
    }
  }
  return true;
}
function some(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return true;
    }
  }
  return false;
}
function* retro(object) {
  if (typeof object.retro === "function") {
    yield* object.retro();
  } else {
    for (let index = object.length - 1; index > -1; index--) {
      yield object[index];
    }
  }
}
var ArrayExt3, Private8, StringExt3;
var init_index_es68 = __esm({
  "../../node_modules/@lumino/widgets/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt8) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start + i) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start - i + n) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start + i) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findFirstIndex = findFirstIndex;
      function findLastIndex2(array, fn, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let d;
        if (start < stop) {
          d = start + 1 + (n - stop);
        } else {
          d = start - stop + 1;
        }
        for (let i = 0; i < d; ++i) {
          let j = (start - i + n) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findLastIndex = findLastIndex2;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index = findFirstIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index = findLastIndex2(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt8.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt8.upperBound = upperBound;
      function shallowEqual(a, b, fn) {
        if (a === b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0, n = a.length; i < n; ++i) {
          if (fn ? !fn(a[i], b[i]) : a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt8.shallowEqual = shallowEqual;
      function slice(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n = array.length;
        if (start === void 0) {
          start = step < 0 ? n - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n, step < 0 ? -1 : 0);
        } else if (start >= n) {
          start = step < 0 ? n - 1 : n;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n;
        } else if (stop < 0) {
          stop = Math.max(stop + n, step < 0 ? -1 : 0);
        } else if (stop >= n) {
          stop = step < 0 ? n - 1 : n;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result = [];
        for (let i = 0; i < length; ++i) {
          result[i] = array[start + i * step];
        }
        return result;
      }
      ArrayExt8.slice = slice;
      function move(array, fromIndex, toIndex) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n);
        } else {
          fromIndex = Math.min(fromIndex, n - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n);
        } else {
          toIndex = Math.min(toIndex, n - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d = fromIndex < toIndex ? 1 : -1;
        for (let i = fromIndex; i !== toIndex; i += d) {
          array[i] = array[i + d];
        }
        array[toIndex] = value;
      }
      ArrayExt8.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        while (start < stop) {
          let a = array[start];
          let b = array[stop];
          array[start++] = b;
          array[stop--] = a;
        }
      }
      ArrayExt8.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt8.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          array[(start + i) % n] = value;
        }
      }
      ArrayExt8.fill = fill;
      function insert(array, index, value) {
        let n = array.length;
        if (index < 0) {
          index = Math.max(0, index + n);
        } else {
          index = Math.min(index, n);
        }
        for (let i = n; i > index; --i) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      ArrayExt8.insert = insert;
      function removeAt(array, index) {
        let n = array.length;
        if (index < 0) {
          index += n;
        }
        if (index < 0 || index >= n) {
          return void 0;
        }
        let value = array[index];
        for (let i = index + 1; i < n; ++i) {
          array[i - 1] = array[i];
        }
        array.length = n - 1;
        return value;
      }
      ArrayExt8.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index = firstIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index = lastIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i = 0; i < n; ++i) {
          if (start <= stop && i >= start && i <= stop && array[i] === value) {
            count++;
          } else if (stop < start && (i <= stop || i >= start) && array[i] === value) {
            count++;
          } else if (count > 0) {
            array[i - count] = array[i];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index = findFirstIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index = findLastIndex2(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i = 0; i < n; ++i) {
          if (start <= stop && i >= start && i <= stop && fn(array[i], i)) {
            count++;
          } else if (stop < start && (i <= stop || i >= start) && fn(array[i], i)) {
            count++;
          } else if (count > 0) {
            array[i - count] = array[i];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllWhere = removeAllWhere;
    })(ArrayExt3 || (ArrayExt3 = {}));
    (function(Private36) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private36.rangeLength = rangeLength;
    })(Private8 || (Private8 = {}));
    (function(StringExt8) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i = 0, j = start, n = query.length; i < n; ++i, ++j) {
          j = source.indexOf(query[i], j);
          if (j === -1) {
            return null;
          }
          indices[i] = j;
        }
        return indices;
      }
      StringExt8.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i = 0, n = indices.length; i < n; ++i) {
          let j = indices[i] - start;
          score += j * j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last = start - 1;
        for (let i = 0, n = indices.length; i < n; ++i) {
          let j = indices[i];
          score += j - last - 1;
          last = j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result = [];
        let k = 0;
        let last = 0;
        let n = indices.length;
        while (k < n) {
          let i = indices[k];
          let j = indices[k];
          while (++k < n && indices[k] === j + 1) {
            j++;
          }
          if (last < i) {
            result.push(source.slice(last, i));
          }
          if (i < j + 1) {
            result.push(fn(source.slice(i, j + 1)));
          }
          last = j + 1;
        }
        if (last < source.length) {
          result.push(source.slice(last));
        }
        return result;
      }
      StringExt8.highlight = highlight;
      function cmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      StringExt8.cmp = cmp;
    })(StringExt3 || (StringExt3 = {}));
  }
});

// ../../node_modules/@lumino/widgets/node_modules/@lumino/domutils/dist/index.es6.js
var ClipboardExt, ElementExt, Platform, Selector2, Private9;
var init_index_es69 = __esm({
  "../../node_modules/@lumino/widgets/node_modules/@lumino/domutils/dist/index.es6.js"() {
    (function(ClipboardExt4) {
      function copyText(text) {
        const body = document.body;
        const handler = (event) => {
          event.preventDefault();
          event.stopPropagation();
          event.clipboardData.setData("text", text);
          body.removeEventListener("copy", handler, true);
        };
        body.addEventListener("copy", handler, true);
        document.execCommand("copy");
      }
      ClipboardExt4.copyText = copyText;
    })(ClipboardExt || (ClipboardExt = {}));
    (function(ElementExt4) {
      function boxSizing(element) {
        let style = window.getComputedStyle(element);
        let bt = parseFloat(style.borderTopWidth) || 0;
        let bl = parseFloat(style.borderLeftWidth) || 0;
        let br = parseFloat(style.borderRightWidth) || 0;
        let bb = parseFloat(style.borderBottomWidth) || 0;
        let pt = parseFloat(style.paddingTop) || 0;
        let pl = parseFloat(style.paddingLeft) || 0;
        let pr = parseFloat(style.paddingRight) || 0;
        let pb = parseFloat(style.paddingBottom) || 0;
        let hs = bl + pl + pr + br;
        let vs = bt + pt + pb + bb;
        return {
          borderTop: bt,
          borderLeft: bl,
          borderRight: br,
          borderBottom: bb,
          paddingTop: pt,
          paddingLeft: pl,
          paddingRight: pr,
          paddingBottom: pb,
          horizontalSum: hs,
          verticalSum: vs
        };
      }
      ElementExt4.boxSizing = boxSizing;
      function sizeLimits(element) {
        let style = window.getComputedStyle(element);
        let minWidth = parseFloat(style.minWidth) || 0;
        let minHeight = parseFloat(style.minHeight) || 0;
        let maxWidth = parseFloat(style.maxWidth) || Infinity;
        let maxHeight = parseFloat(style.maxHeight) || Infinity;
        maxWidth = Math.max(minWidth, maxWidth);
        maxHeight = Math.max(minHeight, maxHeight);
        return { minWidth, minHeight, maxWidth, maxHeight };
      }
      ElementExt4.sizeLimits = sizeLimits;
      function hitTest(element, clientX, clientY) {
        let rect = element.getBoundingClientRect();
        return clientX >= rect.left && clientX < rect.right && clientY >= rect.top && clientY < rect.bottom;
      }
      ElementExt4.hitTest = hitTest;
      function scrollIntoViewIfNeeded(area, element) {
        let ar = area.getBoundingClientRect();
        let er = element.getBoundingClientRect();
        if (er.top <= ar.top && er.bottom >= ar.bottom) {
          return;
        }
        if (er.top < ar.top && er.height <= ar.height) {
          area.scrollTop -= ar.top - er.top;
          return;
        }
        if (er.bottom > ar.bottom && er.height >= ar.height) {
          area.scrollTop -= ar.top - er.top;
          return;
        }
        if (er.top < ar.top && er.height > ar.height) {
          area.scrollTop -= ar.bottom - er.bottom;
          return;
        }
        if (er.bottom > ar.bottom && er.height < ar.height) {
          area.scrollTop -= ar.bottom - er.bottom;
          return;
        }
      }
      ElementExt4.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;
    })(ElementExt || (ElementExt = {}));
    (function(Platform4) {
      Platform4.IS_MAC = !!navigator.platform.match(/Mac/i);
      Platform4.IS_WIN = !!navigator.platform.match(/Win/i);
      Platform4.IS_IE = /Trident/.test(navigator.userAgent);
      Platform4.IS_EDGE = /Edge/.test(navigator.userAgent);
      function accelKey(event) {
        return Platform4.IS_MAC ? event.metaKey : event.ctrlKey;
      }
      Platform4.accelKey = accelKey;
    })(Platform || (Platform = {}));
    (function(Selector5) {
      function calculateSpecificity(selector) {
        if (selector in Private9.specificityCache) {
          return Private9.specificityCache[selector];
        }
        let result = Private9.calculateSingle(selector);
        return Private9.specificityCache[selector] = result;
      }
      Selector5.calculateSpecificity = calculateSpecificity;
      function isValid(selector) {
        if (selector in Private9.validityCache) {
          return Private9.validityCache[selector];
        }
        let result = true;
        try {
          Private9.testElem.querySelector(selector);
        } catch (err) {
          result = false;
        }
        return Private9.validityCache[selector] = result;
      }
      Selector5.isValid = isValid;
      function matches2(element, selector) {
        return Private9.protoMatchFunc.call(element, selector);
      }
      Selector5.matches = matches2;
    })(Selector2 || (Selector2 = {}));
    (function(Private36) {
      Private36.specificityCache = /* @__PURE__ */ Object.create(null);
      Private36.validityCache = /* @__PURE__ */ Object.create(null);
      Private36.testElem = document.createElement("div");
      Private36.protoMatchFunc = (() => {
        let proto = Element.prototype;
        return proto.matches || proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector || function(selector) {
          let elem = this;
          let matches2 = elem.ownerDocument ? elem.ownerDocument.querySelectorAll(selector) : [];
          return Array.prototype.indexOf.call(matches2, elem) !== -1;
        };
      })();
      function calculateSingle(selector) {
        selector = selector.split(",", 1)[0];
        let a = 0;
        let b = 0;
        let c = 0;
        function match(re) {
          let match2 = selector.match(re);
          if (match2 === null) {
            return false;
          }
          selector = selector.slice(match2[0].length);
          return true;
        }
        selector = selector.replace(NEGATION_RE, " $1 ");
        while (selector.length > 0) {
          if (match(ID_RE)) {
            a++;
            continue;
          }
          if (match(CLASS_RE)) {
            b++;
            continue;
          }
          if (match(ATTR_RE)) {
            b++;
            continue;
          }
          if (match(PSEUDO_ELEM_RE)) {
            c++;
            continue;
          }
          if (match(PSEDUO_CLASS_RE)) {
            b++;
            continue;
          }
          if (match(TYPE_RE)) {
            c++;
            continue;
          }
          if (match(IGNORE_RE)) {
            continue;
          }
          return 0;
        }
        a = Math.min(a, 255);
        b = Math.min(b, 255);
        c = Math.min(c, 255);
        return a << 16 | b << 8 | c;
      }
      Private36.calculateSingle = calculateSingle;
      const ID_RE = /^#[^\s\+>~#\.\[:]+/;
      const CLASS_RE = /^\.[^\s\+>~#\.\[:]+/;
      const ATTR_RE = /^\[[^\]]+\]/;
      const TYPE_RE = /^[^\s\+>~#\.\[:]+/;
      const PSEUDO_ELEM_RE = /^(::[^\s\+>~#\.\[:]+|:first-line|:first-letter|:before|:after)/;
      const PSEDUO_CLASS_RE = /^:[^\s\+>~#\.\[:]+/;
      const IGNORE_RE = /^[\s\+>~\*]+/;
      const NEGATION_RE = /:not\(([^\)]+)\)/g;
    })(Private9 || (Private9 = {}));
  }
});

// ../../node_modules/@lumino/widgets/node_modules/@lumino/collections/dist/index.es6.js
var LinkedList, Private10;
var init_index_es610 = __esm({
  "../../node_modules/@lumino/widgets/node_modules/@lumino/collections/dist/index.es6.js"() {
    LinkedList = class {
      constructor() {
        this._first = null;
        this._last = null;
        this._size = 0;
      }
      /**
       * Whether the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get isEmpty() {
        return this._size === 0;
      }
      /**
       * The size of the list.
       *
       * #### Complexity
       * `O(1)`
       *
       * #### Notes
       * This is equivalent to `length`.
       */
      get size() {
        return this._size;
      }
      /**
       * The length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `size`.
       *
       * This property is deprecated.
       */
      get length() {
        return this._size;
      }
      /**
       * The first value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get first() {
        return this._first ? this._first.value : void 0;
      }
      /**
       * The last value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get last() {
        return this._last ? this._last.value : void 0;
      }
      /**
       * The first node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get firstNode() {
        return this._first;
      }
      /**
       * The last node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get lastNode() {
        return this._last;
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting with the first value.
       *
       * #### Complexity
       * Constant.
       */
      *[Symbol.iterator]() {
        let node = this._first;
        while (node) {
          yield node.value;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the values in the list.
       *
       * @returns A new iterator starting with the last value.
       *
       * #### Complexity
       * Constant.
       */
      *retro() {
        let node = this._last;
        while (node) {
          yield node.value;
          node = node.prev;
        }
      }
      /**
       * Create an iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the first node.
       *
       * #### Complexity
       * Constant.
       */
      *nodes() {
        let node = this._first;
        while (node) {
          yield node;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the last node.
       *
       * #### Complexity
       * Constant.
       */
      *retroNodes() {
        let node = this._last;
        while (node) {
          yield node;
          node = node.prev;
        }
      }
      /**
       * Assign new values to the list, replacing all current values.
       *
       * @param values - The values to assign to the list.
       *
       * #### Complexity
       * Linear.
       */
      assign(values) {
        this.clear();
        for (const value of values) {
          this.addLast(value);
        }
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addLast`.
       */
      push(value) {
        this.addLast(value);
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeLast`.
       */
      pop() {
        return this.removeLast();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addFirst`.
       */
      shift(value) {
        this.addFirst(value);
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeFirst`.
       */
      unshift() {
        return this.removeFirst();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addFirst(value) {
        let node = new Private10.LinkedListNode(this, value);
        if (!this._first) {
          this._first = node;
          this._last = node;
        } else {
          node.next = this._first;
          this._first.prev = node;
          this._first = node;
        }
        this._size++;
        return node;
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addLast(value) {
        let node = new Private10.LinkedListNode(this, value);
        if (!this._last) {
          this._first = node;
          this._last = node;
        } else {
          node.prev = this._last;
          this._last.next = node;
          this._last = node;
        }
        this._size++;
        return node;
      }
      /**
       * Insert a value before a specific node in the list.
       *
       * @param value - The value to insert before the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertBefore(value, ref2) {
        if (!ref2 || ref2 === this._first) {
          return this.addFirst(value);
        }
        if (!(ref2 instanceof Private10.LinkedListNode) || ref2.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private10.LinkedListNode(this, value);
        let _ref = ref2;
        let prev = _ref.prev;
        node.next = _ref;
        node.prev = prev;
        _ref.prev = node;
        prev.next = node;
        this._size++;
        return node;
      }
      /**
       * Insert a value after a specific node in the list.
       *
       * @param value - The value to insert after the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertAfter(value, ref2) {
        if (!ref2 || ref2 === this._last) {
          return this.addLast(value);
        }
        if (!(ref2 instanceof Private10.LinkedListNode) || ref2.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private10.LinkedListNode(this, value);
        let _ref = ref2;
        let next = _ref.next;
        node.next = next;
        node.prev = _ref;
        _ref.next = node;
        next.prev = node;
        this._size++;
        return node;
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeFirst() {
        let node = this._first;
        if (!node) {
          return void 0;
        }
        if (node === this._last) {
          this._first = null;
          this._last = null;
        } else {
          this._first = node.next;
          this._first.prev = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeLast() {
        let node = this._last;
        if (!node) {
          return void 0;
        }
        if (node === this._first) {
          this._first = null;
          this._last = null;
        } else {
          this._last = node.prev;
          this._last.next = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove a specific node from the list.
       *
       * @param node - The node to remove from the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * The node must be owned by the list.
       */
      removeNode(node) {
        if (!(node instanceof Private10.LinkedListNode) || node.list !== this) {
          throw new Error("Node is not owned by the list.");
        }
        let _node = node;
        if (_node === this._first && _node === this._last) {
          this._first = null;
          this._last = null;
        } else if (_node === this._first) {
          this._first = _node.next;
          this._first.prev = null;
        } else if (_node === this._last) {
          this._last = _node.prev;
          this._last.next = null;
        } else {
          _node.next.prev = _node.prev;
          _node.prev.next = _node.next;
        }
        _node.list = null;
        _node.next = null;
        _node.prev = null;
        this._size--;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       */
      clear() {
        let node = this._first;
        while (node) {
          let next = node.next;
          node.list = null;
          node.prev = null;
          node.next = null;
          node = next;
        }
        this._first = null;
        this._last = null;
        this._size = 0;
      }
    };
    (function(LinkedList4) {
      function from2(values) {
        let list = new LinkedList4();
        list.assign(values);
        return list;
      }
      LinkedList4.from = from2;
    })(LinkedList || (LinkedList = {}));
    (function(Private36) {
      class LinkedListNode {
        /**
         * Construct a new linked list node.
         *
         * @param list - The list which owns the node.
         *
         * @param value - The value for the link.
         */
        constructor(list, value) {
          this.list = null;
          this.next = null;
          this.prev = null;
          this.list = list;
          this.value = value;
        }
      }
      Private36.LinkedListNode = LinkedListNode;
    })(Private10 || (Private10 = {}));
  }
});

// ../../node_modules/@lumino/widgets/node_modules/@lumino/messaging/dist/index.es6.js
var Message, ConflatableMessage, MessageLoop;
var init_index_es611 = __esm({
  "../../node_modules/@lumino/widgets/node_modules/@lumino/messaging/dist/index.es6.js"() {
    init_index_es68();
    init_index_es610();
    Message = class {
      /**
       * Construct a new message.
       *
       * @param type - The type of the message.
       */
      constructor(type) {
        this.type = type;
      }
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * If a conflatable message is posted to a handler while another
       * conflatable message of the same `type` has already been posted
       * to the handler, the `conflate()` method of the existing message
       * will be invoked. If that method returns `true`, the new message
       * will not be enqueued. This allows messages to be compressed, so
       * that only a single instance of the message type is processed per
       * cycle, no matter how many times messages of that type are posted.
       *
       * Custom message types may reimplement this property.
       *
       * The default implementation is always `false`.
       */
      get isConflatable() {
        return false;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * @param other - A conflatable message of the same `type`.
       *
       * @returns `true` if the message was successfully conflated, or
       *   `false` otherwise.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * This method is called automatically by the message loop when the
       * given message is posted to the handler paired with this message.
       * This message will already be enqueued and conflatable, and the
       * given message will have the same `type` and also be conflatable.
       *
       * This method should merge the state of the other message into this
       * message as needed so that when this message is finally delivered
       * to the handler, it receives the most up-to-date information.
       *
       * If this method returns `true`, it signals that the other message
       * was successfully conflated and that message will not be enqueued.
       *
       * If this method returns `false`, the other message will be enqueued
       * for normal delivery.
       *
       * Custom message types may reimplement this method.
       *
       * The default implementation always returns `false`.
       */
      conflate(other) {
        return false;
      }
    };
    ConflatableMessage = class extends Message {
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * This property is always `true`.
       */
      get isConflatable() {
        return true;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * #### Notes
       * This method always returns `true`.
       */
      conflate(other) {
        return true;
      }
    };
    (function(MessageLoop4) {
      let pending = null;
      const schedule = ((resolved) => (fn) => {
        let rejected = false;
        resolved.then(() => !rejected && fn());
        return () => {
          rejected = true;
        };
      })(Promise.resolve());
      function sendMessage(handler, msg) {
        let hooks = messageHooks.get(handler);
        if (!hooks || hooks.length === 0) {
          invokeHandler(handler, msg);
          return;
        }
        let passed = every(retro(hooks), (hook) => {
          return hook ? invokeHook(hook, handler, msg) : true;
        });
        if (passed) {
          invokeHandler(handler, msg);
        }
      }
      MessageLoop4.sendMessage = sendMessage;
      function postMessage(handler, msg) {
        if (!msg.isConflatable) {
          enqueueMessage(handler, msg);
          return;
        }
        let conflated = some(messageQueue, (posted) => {
          if (posted.handler !== handler) {
            return false;
          }
          if (!posted.msg) {
            return false;
          }
          if (posted.msg.type !== msg.type) {
            return false;
          }
          if (!posted.msg.isConflatable) {
            return false;
          }
          return posted.msg.conflate(msg);
        });
        if (!conflated) {
          enqueueMessage(handler, msg);
        }
      }
      MessageLoop4.postMessage = postMessage;
      function installMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.indexOf(hook) !== -1) {
          return;
        }
        if (!hooks) {
          messageHooks.set(handler, [hook]);
        } else {
          hooks.push(hook);
        }
      }
      MessageLoop4.installMessageHook = installMessageHook;
      function removeMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (!hooks) {
          return;
        }
        let i = hooks.indexOf(hook);
        if (i === -1) {
          return;
        }
        hooks[i] = null;
        scheduleCleanup(hooks);
      }
      MessageLoop4.removeMessageHook = removeMessageHook;
      function clearData(handler) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.length > 0) {
          ArrayExt3.fill(hooks, null);
          scheduleCleanup(hooks);
        }
        for (const posted of messageQueue) {
          if (posted.handler === handler) {
            posted.handler = null;
            posted.msg = null;
          }
        }
      }
      MessageLoop4.clearData = clearData;
      function flush() {
        if (flushGuard || pending === null) {
          return;
        }
        pending();
        pending = null;
        flushGuard = true;
        runMessageLoop();
        flushGuard = false;
      }
      MessageLoop4.flush = flush;
      function getExceptionHandler() {
        return exceptionHandler;
      }
      MessageLoop4.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = exceptionHandler;
        exceptionHandler = handler;
        return old;
      }
      MessageLoop4.setExceptionHandler = setExceptionHandler;
      const messageQueue = new LinkedList();
      const messageHooks = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      let exceptionHandler = (err) => {
        console.error(err);
      };
      let flushGuard = false;
      function invokeHook(hook, handler, msg) {
        let result = true;
        try {
          if (typeof hook === "function") {
            result = hook(handler, msg);
          } else {
            result = hook.messageHook(handler, msg);
          }
        } catch (err) {
          exceptionHandler(err);
        }
        return result;
      }
      function invokeHandler(handler, msg) {
        try {
          handler.processMessage(msg);
        } catch (err) {
          exceptionHandler(err);
        }
      }
      function enqueueMessage(handler, msg) {
        messageQueue.addLast({ handler, msg });
        if (pending !== null) {
          return;
        }
        pending = schedule(runMessageLoop);
      }
      function runMessageLoop() {
        pending = null;
        if (messageQueue.isEmpty) {
          return;
        }
        let sentinel = { handler: null, msg: null };
        messageQueue.addLast(sentinel);
        while (true) {
          let posted = messageQueue.removeFirst();
          if (posted === sentinel) {
            return;
          }
          if (posted.handler && posted.msg) {
            sendMessage(posted.handler, posted.msg);
          }
        }
      }
      function scheduleCleanup(hooks) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(hooks);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupHooks);
        dirtySet.clear();
      }
      function cleanupHooks(hooks) {
        ArrayExt3.removeAllWhere(hooks, isNull);
      }
      function isNull(value) {
        return value === null;
      }
    })(MessageLoop || (MessageLoop = {}));
  }
});

// ../../node_modules/@lumino/widgets/node_modules/@lumino/properties/dist/index.es6.js
var AttachedProperty2, Private11;
var init_index_es612 = __esm({
  "../../node_modules/@lumino/widgets/node_modules/@lumino/properties/dist/index.es6.js"() {
    AttachedProperty2 = class {
      /**
       * Construct a new attached property.
       *
       * @param options - The options for initializing the property.
       */
      constructor(options) {
        this._pid = Private11.nextPID();
        this.name = options.name;
        this._create = options.create;
        this._coerce = options.coerce || null;
        this._compare = options.compare || null;
        this._changed = options.changed || null;
      }
      /**
       * Get the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @returns The current value of the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and assigned as the current value of the property.
       */
      get(owner) {
        let value;
        let map2 = Private11.ensureMap(owner);
        if (this._pid in map2) {
          value = map2[this._pid];
        } else {
          value = map2[this._pid] = this._createValue(owner);
        }
        return value;
      }
      /**
       * Set the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @param value - The value for the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      set(owner, value) {
        let oldValue;
        let map2 = Private11.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, value);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Explicitly coerce the current property value for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      coerce(owner) {
        let oldValue;
        let map2 = Private11.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, oldValue);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Get or create the default value for the given owner.
       */
      _createValue(owner) {
        let create5 = this._create;
        return create5(owner);
      }
      /**
       * Coerce the value for the given owner.
       */
      _coerceValue(owner, value) {
        let coerce = this._coerce;
        return coerce ? coerce(owner, value) : value;
      }
      /**
       * Compare the old value and new value for equality.
       */
      _compareValue(oldValue, newValue) {
        let compare = this._compare;
        return compare ? compare(oldValue, newValue) : oldValue === newValue;
      }
      /**
       * Run the change notification if the given values are different.
       */
      _maybeNotify(owner, oldValue, newValue) {
        let changed = this._changed;
        if (changed && !this._compareValue(oldValue, newValue)) {
          changed(owner, oldValue, newValue);
        }
      }
    };
    (function(AttachedProperty5) {
      function clearData(owner) {
        Private11.ownerData.delete(owner);
      }
      AttachedProperty5.clearData = clearData;
    })(AttachedProperty2 || (AttachedProperty2 = {}));
    (function(Private36) {
      Private36.ownerData = /* @__PURE__ */ new WeakMap();
      Private36.nextPID = (() => {
        let id = 0;
        return () => {
          let rand = Math.random();
          let stem = `${rand}`.slice(2);
          return `pid-${stem}-${id++}`;
        };
      })();
      function ensureMap(owner) {
        let map2 = Private36.ownerData.get(owner);
        if (map2) {
          return map2;
        }
        map2 = /* @__PURE__ */ Object.create(null);
        Private36.ownerData.set(owner, map2);
        return map2;
      }
      Private36.ensureMap = ensureMap;
    })(Private11 || (Private11 = {}));
  }
});

// ../../node_modules/@lumino/dragdrop/dist/index.es6.js
var Drag, Private12;
var init_index_es613 = __esm({
  "../../node_modules/@lumino/dragdrop/dist/index.es6.js"() {
    init_index_es65();
    Drag = class {
      /**
       * Construct a new drag object.
       *
       * @param options - The options for initializing the drag.
       */
      constructor(options) {
        this._onScrollFrame = () => {
          if (!this._scrollTarget) {
            return;
          }
          let { element, edge, distance } = this._scrollTarget;
          let d = Private12.SCROLL_EDGE_SIZE - distance;
          let f = Math.pow(d / Private12.SCROLL_EDGE_SIZE, 2);
          let s = Math.max(1, Math.round(f * Private12.SCROLL_EDGE_SIZE));
          switch (edge) {
            case "top":
              element.scrollTop -= s;
              break;
            case "left":
              element.scrollLeft -= s;
              break;
            case "right":
              element.scrollLeft += s;
              break;
            case "bottom":
              element.scrollTop += s;
              break;
          }
          requestAnimationFrame(this._onScrollFrame);
        };
        this._disposed = false;
        this._dropAction = "none";
        this._override = null;
        this._currentTarget = null;
        this._currentElement = null;
        this._promise = null;
        this._scrollTarget = null;
        this._resolve = null;
        this.document = options.document || document;
        this.mimeData = options.mimeData;
        this.dragImage = options.dragImage || null;
        this.proposedAction = options.proposedAction || "copy";
        this.supportedActions = options.supportedActions || "all";
        this.source = options.source || null;
      }
      /**
       * Dispose of the resources held by the drag object.
       *
       * #### Notes
       * This will cancel the drag operation if it is active.
       */
      dispose() {
        if (this._disposed) {
          return;
        }
        this._disposed = true;
        if (this._currentTarget) {
          let event = new PointerEvent("pointerup", {
            bubbles: true,
            cancelable: true,
            clientX: -1,
            clientY: -1
          });
          Private12.dispatchDragLeave(this, this._currentTarget, null, event);
        }
        this._finalize("none");
      }
      /**
       * Test whether the drag object is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Start the drag operation at the specified client position.
       *
       * @param clientX - The client X position for the drag start.
       *
       * @param clientY - The client Y position for the drag start.
       *
       * @returns A promise which resolves to the result of the drag.
       *
       * #### Notes
       * If the drag has already been started, the promise created by the
       * first call to `start` is returned.
       *
       * If the drag operation has ended, or if the drag object has been
       * disposed, the returned promise will resolve to `'none'`.
       *
       * The drag object will be automatically disposed when drag operation
       * completes. This means `Drag` objects are for single-use only.
       *
       * This method assumes the left mouse button is already held down.
       */
      start(clientX, clientY) {
        if (this._disposed) {
          return Promise.resolve("none");
        }
        if (this._promise) {
          return this._promise;
        }
        this._addListeners();
        this._attachDragImage(clientX, clientY);
        this._promise = new Promise((resolve) => {
          this._resolve = resolve;
        });
        let event = new PointerEvent("pointermove", {
          bubbles: true,
          cancelable: true,
          clientX,
          clientY
        });
        document.dispatchEvent(event);
        return this._promise;
      }
      /**
       * Handle the DOM events for the drag operation.
       *
       * @param event - The DOM event sent to the drag object.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the document. It should not be
       * called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          default:
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * Move the drag image element to the specified location.
       *
       * This is a no-op if there is no drag image element.
       */
      moveDragImage(clientX, clientY) {
        if (!this.dragImage) {
          return;
        }
        let style = this.dragImage.style;
        style.transform = `translate(${clientX}px, ${clientY}px)`;
      }
      /**
       * Handle the `'pointermove'` event for the drag object.
       */
      _evtPointerMove(event) {
        event.preventDefault();
        event.stopPropagation();
        this._updateCurrentTarget(event);
        this._updateDragScroll(event);
        this.moveDragImage(event.clientX, event.clientY);
      }
      /**
       * Handle the `'pointerup'` event for the drag object.
       */
      _evtPointerUp(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.button !== 0) {
          return;
        }
        this._updateCurrentTarget(event);
        if (!this._currentTarget) {
          this._finalize("none");
          return;
        }
        if (this._dropAction === "none") {
          Private12.dispatchDragLeave(this, this._currentTarget, null, event);
          this._finalize("none");
          return;
        }
        let action = Private12.dispatchDrop(this, this._currentTarget, event);
        this._finalize(action);
      }
      /**
       * Handle the `'keydown'` event for the drag object.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.keyCode === 27) {
          this.dispose();
        }
      }
      /**
       * Add the document event listeners for the drag object.
       */
      _addListeners() {
        document.addEventListener("pointerdown", this, true);
        document.addEventListener("pointermove", this, true);
        document.addEventListener("pointerup", this, true);
        document.addEventListener("pointerenter", this, true);
        document.addEventListener("pointerleave", this, true);
        document.addEventListener("pointerover", this, true);
        document.addEventListener("pointerout", this, true);
        document.addEventListener("keydown", this, true);
        document.addEventListener("keyup", this, true);
        document.addEventListener("keypress", this, true);
        document.addEventListener("contextmenu", this, true);
      }
      /**
       * Remove the document event listeners for the drag object.
       */
      _removeListeners() {
        document.removeEventListener("pointerdown", this, true);
        document.removeEventListener("pointermove", this, true);
        document.removeEventListener("pointerup", this, true);
        document.removeEventListener("pointerenter", this, true);
        document.removeEventListener("pointerleave", this, true);
        document.removeEventListener("pointerover", this, true);
        document.removeEventListener("pointerout", this, true);
        document.removeEventListener("keydown", this, true);
        document.removeEventListener("keyup", this, true);
        document.removeEventListener("keypress", this, true);
        document.removeEventListener("contextmenu", this, true);
      }
      /**
       * Update the drag scroll element under the mouse.
       */
      _updateDragScroll(event) {
        let target2 = Private12.findScrollTarget(event);
        if (!this._scrollTarget && !target2) {
          return;
        }
        if (!this._scrollTarget) {
          setTimeout(this._onScrollFrame, 500);
        }
        this._scrollTarget = target2;
      }
      /**
       * Update the current target node using the given mouse event.
       */
      _updateCurrentTarget(event) {
        let prevTarget = this._currentTarget;
        let currTarget = this._currentTarget;
        let prevElem = this._currentElement;
        let currElem = Private12.findElementBehindBackdrop(event, this.document);
        this._currentElement = currElem;
        if (currElem !== prevElem && currElem !== currTarget) {
          Private12.dispatchDragExit(this, currTarget, currElem, event);
        }
        if (currElem !== prevElem && currElem !== currTarget) {
          currTarget = Private12.dispatchDragEnter(this, currElem, currTarget, event);
        }
        if (currTarget !== prevTarget) {
          this._currentTarget = currTarget;
          Private12.dispatchDragLeave(this, prevTarget, currTarget, event);
        }
        let action = Private12.dispatchDragOver(this, currTarget, event);
        this._setDropAction(action);
      }
      /**
       * Attach the drag image element at the specified location.
       *
       * This is a no-op if there is no drag image element.
       */
      _attachDragImage(clientX, clientY) {
        if (!this.dragImage) {
          return;
        }
        this.dragImage.classList.add("lm-mod-drag-image");
        let style = this.dragImage.style;
        style.pointerEvents = "none";
        style.position = "fixed";
        style.transform = `translate(${clientX}px, ${clientY}px)`;
        const body = this.document instanceof Document ? this.document.body : this.document.firstElementChild;
        body.appendChild(this.dragImage);
      }
      /**
       * Detach the drag image element from the DOM.
       *
       * This is a no-op if there is no drag image element.
       */
      _detachDragImage() {
        if (!this.dragImage) {
          return;
        }
        let parent = this.dragImage.parentNode;
        if (!parent) {
          return;
        }
        parent.removeChild(this.dragImage);
      }
      /**
       * Set the internal drop action state and update the drag cursor.
       */
      _setDropAction(action) {
        action = Private12.validateAction(action, this.supportedActions);
        if (this._override && this._dropAction === action) {
          return;
        }
        switch (action) {
          case "none":
            this._dropAction = action;
            this._override = Drag.overrideCursor("no-drop", this.document);
            break;
          case "copy":
            this._dropAction = action;
            this._override = Drag.overrideCursor("copy", this.document);
            break;
          case "link":
            this._dropAction = action;
            this._override = Drag.overrideCursor("alias", this.document);
            break;
          case "move":
            this._dropAction = action;
            this._override = Drag.overrideCursor("move", this.document);
            break;
        }
      }
      /**
       * Finalize the drag operation and resolve the drag promise.
       */
      _finalize(action) {
        let resolve = this._resolve;
        this._removeListeners();
        this._detachDragImage();
        if (this._override) {
          this._override.dispose();
          this._override = null;
        }
        this.mimeData.clear();
        this._disposed = true;
        this._dropAction = "none";
        this._currentTarget = null;
        this._currentElement = null;
        this._scrollTarget = null;
        this._promise = null;
        this._resolve = null;
        if (resolve) {
          resolve(action);
        }
      }
    };
    (function(Drag2) {
      class Event2 extends DragEvent {
        constructor(event, options) {
          super(options.type, {
            bubbles: true,
            cancelable: true,
            altKey: event.altKey,
            button: event.button,
            clientX: event.clientX,
            clientY: event.clientY,
            ctrlKey: event.ctrlKey,
            detail: 0,
            metaKey: event.metaKey,
            relatedTarget: options.related,
            screenX: event.screenX,
            screenY: event.screenY,
            shiftKey: event.shiftKey,
            view: window
          });
          const { drag } = options;
          this.dropAction = "none";
          this.mimeData = drag.mimeData;
          this.proposedAction = drag.proposedAction;
          this.supportedActions = drag.supportedActions;
          this.source = drag.source;
        }
      }
      Drag2.Event = Event2;
      function overrideCursor(cursor, doc = document) {
        return Private12.overrideCursor(cursor, doc);
      }
      Drag2.overrideCursor = overrideCursor;
    })(Drag || (Drag = {}));
    (function(Private36) {
      Private36.SCROLL_EDGE_SIZE = 20;
      function validateAction(action, supported) {
        return actionTable[action] & supportedTable[supported] ? action : "none";
      }
      Private36.validateAction = validateAction;
      function findElementBehindBackdrop(event, root = document) {
        if (event) {
          if (lastElementEventSearch && event == lastElementEventSearch.event) {
            return lastElementEventSearch.element;
          }
          Private36.cursorBackdrop.style.zIndex = "-1000";
          const element = root.elementFromPoint(event.clientX, event.clientY);
          Private36.cursorBackdrop.style.zIndex = "";
          lastElementEventSearch = { event, element };
          return element;
        } else {
          const transform2 = Private36.cursorBackdrop.style.transform;
          if (lastElementSearch && transform2 === lastElementSearch.transform) {
            return lastElementSearch.element;
          }
          const bbox = Private36.cursorBackdrop.getBoundingClientRect();
          Private36.cursorBackdrop.style.zIndex = "-1000";
          const element = root.elementFromPoint(bbox.left + bbox.width / 2, bbox.top + bbox.height / 2);
          Private36.cursorBackdrop.style.zIndex = "";
          lastElementSearch = { transform: transform2, element };
          return element;
        }
      }
      Private36.findElementBehindBackdrop = findElementBehindBackdrop;
      let lastElementEventSearch = null;
      let lastElementSearch = null;
      function findScrollTarget(event) {
        let x = event.clientX;
        let y = event.clientY;
        let element = findElementBehindBackdrop(event);
        for (; element; element = element.parentElement) {
          if (!element.hasAttribute("data-lm-dragscroll")) {
            continue;
          }
          let offsetX = 0;
          let offsetY = 0;
          if (element === document.body) {
            offsetX = window.pageXOffset;
            offsetY = window.pageYOffset;
          }
          let r = element.getBoundingClientRect();
          let top = r.top + offsetY;
          let left = r.left + offsetX;
          let right = left + r.width;
          let bottom = top + r.height;
          if (x < left || x >= right || y < top || y >= bottom) {
            continue;
          }
          let dl = x - left + 1;
          let dt = y - top + 1;
          let dr = right - x;
          let db = bottom - y;
          let distance = Math.min(dl, dt, dr, db);
          if (distance > Private36.SCROLL_EDGE_SIZE) {
            continue;
          }
          let edge;
          switch (distance) {
            case db:
              edge = "bottom";
              break;
            case dt:
              edge = "top";
              break;
            case dr:
              edge = "right";
              break;
            case dl:
              edge = "left";
              break;
            default:
              throw "unreachable";
          }
          let dsw = element.scrollWidth - element.clientWidth;
          let dsh = element.scrollHeight - element.clientHeight;
          let shouldScroll;
          switch (edge) {
            case "top":
              shouldScroll = dsh > 0 && element.scrollTop > 0;
              break;
            case "left":
              shouldScroll = dsw > 0 && element.scrollLeft > 0;
              break;
            case "right":
              shouldScroll = dsw > 0 && element.scrollLeft < dsw;
              break;
            case "bottom":
              shouldScroll = dsh > 0 && element.scrollTop < dsh;
              break;
            default:
              throw "unreachable";
          }
          if (!shouldScroll) {
            continue;
          }
          return { element, edge, distance };
        }
        return null;
      }
      Private36.findScrollTarget = findScrollTarget;
      function dispatchDragEnter(drag, currElem, currTarget, event) {
        if (!currElem) {
          return null;
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragenter"
        });
        let canceled = !currElem.dispatchEvent(dragEvent);
        if (canceled) {
          return currElem;
        }
        const body = drag.document instanceof Document ? drag.document.body : drag.document.firstElementChild;
        if (currElem === body) {
          return currTarget;
        }
        dragEvent = new Drag.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragenter"
        });
        body.dispatchEvent(dragEvent);
        return body;
      }
      Private36.dispatchDragEnter = dispatchDragEnter;
      function dispatchDragExit(drag, prevTarget, currTarget, event) {
        if (!prevTarget) {
          return;
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragexit"
        });
        prevTarget.dispatchEvent(dragEvent);
      }
      Private36.dispatchDragExit = dispatchDragExit;
      function dispatchDragLeave(drag, prevTarget, currTarget, event) {
        if (!prevTarget) {
          return;
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragleave"
        });
        prevTarget.dispatchEvent(dragEvent);
      }
      Private36.dispatchDragLeave = dispatchDragLeave;
      function dispatchDragOver(drag, currTarget, event) {
        if (!currTarget) {
          return "none";
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: null,
          type: "lm-dragover"
        });
        let canceled = !currTarget.dispatchEvent(dragEvent);
        if (canceled) {
          return dragEvent.dropAction;
        }
        return "none";
      }
      Private36.dispatchDragOver = dispatchDragOver;
      function dispatchDrop(drag, currTarget, event) {
        if (!currTarget) {
          return "none";
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: null,
          type: "lm-drop"
        });
        let canceled = !currTarget.dispatchEvent(dragEvent);
        if (canceled) {
          return dragEvent.dropAction;
        }
        return "none";
      }
      Private36.dispatchDrop = dispatchDrop;
      const actionTable = {
        none: 0,
        copy: 1,
        link: 2,
        move: 4
      };
      const supportedTable = {
        none: actionTable["none"],
        copy: actionTable["copy"],
        link: actionTable["link"],
        move: actionTable["move"],
        "copy-link": actionTable["copy"] | actionTable["link"],
        "copy-move": actionTable["copy"] | actionTable["move"],
        "link-move": actionTable["link"] | actionTable["move"],
        all: actionTable["copy"] | actionTable["link"] | actionTable["move"]
      };
      function overrideCursor(cursor, doc = document) {
        let id = ++overrideCursorID;
        const body = doc instanceof Document ? doc.body : doc.firstElementChild;
        if (!Private36.cursorBackdrop.isConnected) {
          Private36.cursorBackdrop.style.transform = "scale(0)";
          body.appendChild(Private36.cursorBackdrop);
          resetBackdropScroll();
          document.addEventListener("pointermove", alignBackdrop, {
            capture: true,
            passive: true
          });
          Private36.cursorBackdrop.addEventListener("scroll", propagateBackdropScroll, {
            capture: true,
            passive: true
          });
        }
        Private36.cursorBackdrop.style.cursor = cursor;
        return new DisposableDelegate(() => {
          if (id === overrideCursorID && Private36.cursorBackdrop.isConnected) {
            document.removeEventListener("pointermove", alignBackdrop, true);
            Private36.cursorBackdrop.removeEventListener("scroll", propagateBackdropScroll, true);
            body.removeChild(Private36.cursorBackdrop);
          }
        });
      }
      Private36.overrideCursor = overrideCursor;
      function alignBackdrop(event) {
        if (!Private36.cursorBackdrop) {
          return;
        }
        Private36.cursorBackdrop.style.transform = `translate(${event.clientX}px, ${event.clientY}px)`;
      }
      function propagateBackdropScroll(_event) {
        if (!Private36.cursorBackdrop) {
          return;
        }
        let element = findElementBehindBackdrop();
        if (!element) {
          return;
        }
        const scrollTarget = element.closest("[data-lm-dragscroll]");
        if (!scrollTarget) {
          return;
        }
        scrollTarget.scrollTop += Private36.cursorBackdrop.scrollTop - backdropScrollOrigin;
        scrollTarget.scrollLeft += Private36.cursorBackdrop.scrollLeft - backdropScrollOrigin;
        resetBackdropScroll();
      }
      function resetBackdropScroll() {
        Private36.cursorBackdrop.scrollTop = backdropScrollOrigin;
        Private36.cursorBackdrop.scrollLeft = backdropScrollOrigin;
      }
      const backdropScrollOrigin = 500;
      function createCursorBackdrop() {
        const backdrop = document.createElement("div");
        backdrop.classList.add("lm-cursor-backdrop");
        return backdrop;
      }
      let overrideCursorID = 0;
      Private36.cursorBackdrop = createCursorBackdrop();
    })(Private12 || (Private12 = {}));
  }
});

// ../../node_modules/@lumino/commands/node_modules/@lumino/algorithm/dist/index.es6.js
var ArrayExt4, Private13, StringExt4;
var init_index_es614 = __esm({
  "../../node_modules/@lumino/commands/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt8) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start + i) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start - i + n) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start + i) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findFirstIndex = findFirstIndex;
      function findLastIndex2(array, fn, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let d;
        if (start < stop) {
          d = start + 1 + (n - stop);
        } else {
          d = start - stop + 1;
        }
        for (let i = 0; i < d; ++i) {
          let j = (start - i + n) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findLastIndex = findLastIndex2;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index = findFirstIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index = findLastIndex2(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt8.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt8.upperBound = upperBound;
      function shallowEqual(a, b, fn) {
        if (a === b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0, n = a.length; i < n; ++i) {
          if (fn ? !fn(a[i], b[i]) : a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt8.shallowEqual = shallowEqual;
      function slice(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n = array.length;
        if (start === void 0) {
          start = step < 0 ? n - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n, step < 0 ? -1 : 0);
        } else if (start >= n) {
          start = step < 0 ? n - 1 : n;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n;
        } else if (stop < 0) {
          stop = Math.max(stop + n, step < 0 ? -1 : 0);
        } else if (stop >= n) {
          stop = step < 0 ? n - 1 : n;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result = [];
        for (let i = 0; i < length; ++i) {
          result[i] = array[start + i * step];
        }
        return result;
      }
      ArrayExt8.slice = slice;
      function move(array, fromIndex, toIndex) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n);
        } else {
          fromIndex = Math.min(fromIndex, n - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n);
        } else {
          toIndex = Math.min(toIndex, n - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d = fromIndex < toIndex ? 1 : -1;
        for (let i = fromIndex; i !== toIndex; i += d) {
          array[i] = array[i + d];
        }
        array[toIndex] = value;
      }
      ArrayExt8.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        while (start < stop) {
          let a = array[start];
          let b = array[stop];
          array[start++] = b;
          array[stop--] = a;
        }
      }
      ArrayExt8.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt8.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          array[(start + i) % n] = value;
        }
      }
      ArrayExt8.fill = fill;
      function insert(array, index, value) {
        let n = array.length;
        if (index < 0) {
          index = Math.max(0, index + n);
        } else {
          index = Math.min(index, n);
        }
        for (let i = n; i > index; --i) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      ArrayExt8.insert = insert;
      function removeAt(array, index) {
        let n = array.length;
        if (index < 0) {
          index += n;
        }
        if (index < 0 || index >= n) {
          return void 0;
        }
        let value = array[index];
        for (let i = index + 1; i < n; ++i) {
          array[i - 1] = array[i];
        }
        array.length = n - 1;
        return value;
      }
      ArrayExt8.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index = firstIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index = lastIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i = 0; i < n; ++i) {
          if (start <= stop && i >= start && i <= stop && array[i] === value) {
            count++;
          } else if (stop < start && (i <= stop || i >= start) && array[i] === value) {
            count++;
          } else if (count > 0) {
            array[i - count] = array[i];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index = findFirstIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index = findLastIndex2(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i = 0; i < n; ++i) {
          if (start <= stop && i >= start && i <= stop && fn(array[i], i)) {
            count++;
          } else if (stop < start && (i <= stop || i >= start) && fn(array[i], i)) {
            count++;
          } else if (count > 0) {
            array[i - count] = array[i];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllWhere = removeAllWhere;
    })(ArrayExt4 || (ArrayExt4 = {}));
    (function(Private36) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private36.rangeLength = rangeLength;
    })(Private13 || (Private13 = {}));
    (function(StringExt8) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i = 0, j = start, n = query.length; i < n; ++i, ++j) {
          j = source.indexOf(query[i], j);
          if (j === -1) {
            return null;
          }
          indices[i] = j;
        }
        return indices;
      }
      StringExt8.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i = 0, n = indices.length; i < n; ++i) {
          let j = indices[i] - start;
          score += j * j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last = start - 1;
        for (let i = 0, n = indices.length; i < n; ++i) {
          let j = indices[i];
          score += j - last - 1;
          last = j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result = [];
        let k = 0;
        let last = 0;
        let n = indices.length;
        while (k < n) {
          let i = indices[k];
          let j = indices[k];
          while (++k < n && indices[k] === j + 1) {
            j++;
          }
          if (last < i) {
            result.push(source.slice(last, i));
          }
          if (i < j + 1) {
            result.push(fn(source.slice(i, j + 1)));
          }
          last = j + 1;
        }
        if (last < source.length) {
          result.push(source.slice(last));
        }
        return result;
      }
      StringExt8.highlight = highlight;
      function cmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      StringExt8.cmp = cmp;
    })(StringExt4 || (StringExt4 = {}));
  }
});

// ../../node_modules/@lumino/commands/node_modules/@lumino/domutils/dist/index.es6.js
var ClipboardExt2, ElementExt2, Platform2, Selector3, Private14;
var init_index_es615 = __esm({
  "../../node_modules/@lumino/commands/node_modules/@lumino/domutils/dist/index.es6.js"() {
    (function(ClipboardExt4) {
      function copyText(text) {
        const body = document.body;
        const handler = (event) => {
          event.preventDefault();
          event.stopPropagation();
          event.clipboardData.setData("text", text);
          body.removeEventListener("copy", handler, true);
        };
        body.addEventListener("copy", handler, true);
        document.execCommand("copy");
      }
      ClipboardExt4.copyText = copyText;
    })(ClipboardExt2 || (ClipboardExt2 = {}));
    (function(ElementExt4) {
      function boxSizing(element) {
        let style = window.getComputedStyle(element);
        let bt = parseFloat(style.borderTopWidth) || 0;
        let bl = parseFloat(style.borderLeftWidth) || 0;
        let br = parseFloat(style.borderRightWidth) || 0;
        let bb = parseFloat(style.borderBottomWidth) || 0;
        let pt = parseFloat(style.paddingTop) || 0;
        let pl = parseFloat(style.paddingLeft) || 0;
        let pr = parseFloat(style.paddingRight) || 0;
        let pb = parseFloat(style.paddingBottom) || 0;
        let hs = bl + pl + pr + br;
        let vs = bt + pt + pb + bb;
        return {
          borderTop: bt,
          borderLeft: bl,
          borderRight: br,
          borderBottom: bb,
          paddingTop: pt,
          paddingLeft: pl,
          paddingRight: pr,
          paddingBottom: pb,
          horizontalSum: hs,
          verticalSum: vs
        };
      }
      ElementExt4.boxSizing = boxSizing;
      function sizeLimits(element) {
        let style = window.getComputedStyle(element);
        let minWidth = parseFloat(style.minWidth) || 0;
        let minHeight = parseFloat(style.minHeight) || 0;
        let maxWidth = parseFloat(style.maxWidth) || Infinity;
        let maxHeight = parseFloat(style.maxHeight) || Infinity;
        maxWidth = Math.max(minWidth, maxWidth);
        maxHeight = Math.max(minHeight, maxHeight);
        return { minWidth, minHeight, maxWidth, maxHeight };
      }
      ElementExt4.sizeLimits = sizeLimits;
      function hitTest(element, clientX, clientY) {
        let rect = element.getBoundingClientRect();
        return clientX >= rect.left && clientX < rect.right && clientY >= rect.top && clientY < rect.bottom;
      }
      ElementExt4.hitTest = hitTest;
      function scrollIntoViewIfNeeded(area, element) {
        let ar = area.getBoundingClientRect();
        let er = element.getBoundingClientRect();
        if (er.top <= ar.top && er.bottom >= ar.bottom) {
          return;
        }
        if (er.top < ar.top && er.height <= ar.height) {
          area.scrollTop -= ar.top - er.top;
          return;
        }
        if (er.bottom > ar.bottom && er.height >= ar.height) {
          area.scrollTop -= ar.top - er.top;
          return;
        }
        if (er.top < ar.top && er.height > ar.height) {
          area.scrollTop -= ar.bottom - er.bottom;
          return;
        }
        if (er.bottom > ar.bottom && er.height < ar.height) {
          area.scrollTop -= ar.bottom - er.bottom;
          return;
        }
      }
      ElementExt4.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;
    })(ElementExt2 || (ElementExt2 = {}));
    (function(Platform4) {
      Platform4.IS_MAC = !!navigator.platform.match(/Mac/i);
      Platform4.IS_WIN = !!navigator.platform.match(/Win/i);
      Platform4.IS_IE = /Trident/.test(navigator.userAgent);
      Platform4.IS_EDGE = /Edge/.test(navigator.userAgent);
      function accelKey(event) {
        return Platform4.IS_MAC ? event.metaKey : event.ctrlKey;
      }
      Platform4.accelKey = accelKey;
    })(Platform2 || (Platform2 = {}));
    (function(Selector5) {
      function calculateSpecificity(selector) {
        if (selector in Private14.specificityCache) {
          return Private14.specificityCache[selector];
        }
        let result = Private14.calculateSingle(selector);
        return Private14.specificityCache[selector] = result;
      }
      Selector5.calculateSpecificity = calculateSpecificity;
      function isValid(selector) {
        if (selector in Private14.validityCache) {
          return Private14.validityCache[selector];
        }
        let result = true;
        try {
          Private14.testElem.querySelector(selector);
        } catch (err) {
          result = false;
        }
        return Private14.validityCache[selector] = result;
      }
      Selector5.isValid = isValid;
      function matches2(element, selector) {
        return Private14.protoMatchFunc.call(element, selector);
      }
      Selector5.matches = matches2;
    })(Selector3 || (Selector3 = {}));
    (function(Private36) {
      Private36.specificityCache = /* @__PURE__ */ Object.create(null);
      Private36.validityCache = /* @__PURE__ */ Object.create(null);
      Private36.testElem = document.createElement("div");
      Private36.protoMatchFunc = (() => {
        let proto = Element.prototype;
        return proto.matches || proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector || function(selector) {
          let elem = this;
          let matches2 = elem.ownerDocument ? elem.ownerDocument.querySelectorAll(selector) : [];
          return Array.prototype.indexOf.call(matches2, elem) !== -1;
        };
      })();
      function calculateSingle(selector) {
        selector = selector.split(",", 1)[0];
        let a = 0;
        let b = 0;
        let c = 0;
        function match(re) {
          let match2 = selector.match(re);
          if (match2 === null) {
            return false;
          }
          selector = selector.slice(match2[0].length);
          return true;
        }
        selector = selector.replace(NEGATION_RE, " $1 ");
        while (selector.length > 0) {
          if (match(ID_RE)) {
            a++;
            continue;
          }
          if (match(CLASS_RE)) {
            b++;
            continue;
          }
          if (match(ATTR_RE)) {
            b++;
            continue;
          }
          if (match(PSEUDO_ELEM_RE)) {
            c++;
            continue;
          }
          if (match(PSEDUO_CLASS_RE)) {
            b++;
            continue;
          }
          if (match(TYPE_RE)) {
            c++;
            continue;
          }
          if (match(IGNORE_RE)) {
            continue;
          }
          return 0;
        }
        a = Math.min(a, 255);
        b = Math.min(b, 255);
        c = Math.min(c, 255);
        return a << 16 | b << 8 | c;
      }
      Private36.calculateSingle = calculateSingle;
      const ID_RE = /^#[^\s\+>~#\.\[:]+/;
      const CLASS_RE = /^\.[^\s\+>~#\.\[:]+/;
      const ATTR_RE = /^\[[^\]]+\]/;
      const TYPE_RE = /^[^\s\+>~#\.\[:]+/;
      const PSEUDO_ELEM_RE = /^(::[^\s\+>~#\.\[:]+|:first-line|:first-letter|:before|:after)/;
      const PSEDUO_CLASS_RE = /^:[^\s\+>~#\.\[:]+/;
      const IGNORE_RE = /^[\s\+>~\*]+/;
      const NEGATION_RE = /:not\(([^\)]+)\)/g;
    })(Private14 || (Private14 = {}));
  }
});

// ../../node_modules/@lumino/keyboard/dist/index.es6.js
function getKeyboardLayout() {
  return Private15.keyboardLayout;
}
var KeycodeLayout, EN_US, Private15;
var init_index_es616 = __esm({
  "../../node_modules/@lumino/keyboard/dist/index.es6.js"() {
    KeycodeLayout = class {
      /**
       * Construct a new keycode layout.
       *
       * @param name - The human readable name for the layout.
       *
       * @param codes - A mapping of keycode to key value.
       *
       * @param modifierKeys - Array of modifier key names
       */
      constructor(name2, codes, modifierKeys = []) {
        this.name = name2;
        this._codes = codes;
        this._keys = KeycodeLayout.extractKeys(codes);
        this._modifierKeys = KeycodeLayout.convertToKeySet(modifierKeys);
      }
      /**
       * Get an array of the key values supported by the layout.
       *
       * @returns A new array of the supported key values.
       */
      keys() {
        return Object.keys(this._keys);
      }
      /**
       * Test whether the given key is a valid value for the layout.
       *
       * @param key - The user provided key to test for validity.
       *
       * @returns `true` if the key is valid, `false` otherwise.
       */
      isValidKey(key2) {
        return key2 in this._keys;
      }
      /**
       * Test whether the given key is a modifier key.
       *
       * @param key - The user provided key.
       *
       * @returns `true` if the key is a modifier key, `false` otherwise.
       */
      isModifierKey(key2) {
        return key2 in this._modifierKeys;
      }
      /**
       * Get the key for a `'keydown'` event.
       *
       * @param event - The event object for a `'keydown'` event.
       *
       * @returns The associated key value, or an empty string if
       *   the event does not represent a valid primary key.
       */
      keyForKeydownEvent(event) {
        return this._codes[event.keyCode] || "";
      }
    };
    (function(KeycodeLayout2) {
      function extractKeys(codes) {
        let keys = /* @__PURE__ */ Object.create(null);
        for (let c in codes) {
          keys[codes[c]] = true;
        }
        return keys;
      }
      KeycodeLayout2.extractKeys = extractKeys;
      function convertToKeySet(keys) {
        let keySet = Object(null);
        for (let i = 0, n = keys.length; i < n; ++i) {
          keySet[keys[i]] = true;
        }
        return keySet;
      }
      KeycodeLayout2.convertToKeySet = convertToKeySet;
    })(KeycodeLayout || (KeycodeLayout = {}));
    EN_US = new KeycodeLayout(
      "en-us",
      {
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        27: "Escape",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        48: "0",
        49: "1",
        50: "2",
        51: "3",
        52: "4",
        53: "5",
        54: "6",
        55: "7",
        56: "8",
        57: "9",
        59: ";",
        61: "=",
        65: "A",
        66: "B",
        67: "C",
        68: "D",
        69: "E",
        70: "F",
        71: "G",
        72: "H",
        73: "I",
        74: "J",
        75: "K",
        76: "L",
        77: "M",
        78: "N",
        79: "O",
        80: "P",
        81: "Q",
        82: "R",
        83: "S",
        84: "T",
        85: "U",
        86: "V",
        87: "W",
        88: "X",
        89: "Y",
        90: "Z",
        91: "Meta",
        93: "ContextMenu",
        96: "0",
        97: "1",
        98: "2",
        99: "3",
        100: "4",
        101: "5",
        102: "6",
        103: "7",
        104: "8",
        105: "9",
        106: "*",
        107: "+",
        109: "-",
        110: ".",
        111: "/",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        224: "Meta"
        // firefox
      },
      ["Shift", "Ctrl", "Alt", "Meta"]
      // modifier keys
    );
    (function(Private36) {
      Private36.keyboardLayout = EN_US;
    })(Private15 || (Private15 = {}));
  }
});

// ../../node_modules/@lumino/commands/dist/index.es6.js
var import_coreutils6, CommandRegistry, Private16;
var init_index_es617 = __esm({
  "../../node_modules/@lumino/commands/dist/index.es6.js"() {
    init_index_es614();
    import_coreutils6 = __toESM(require_dist());
    init_index_es65();
    init_index_es615();
    init_index_es616();
    init_index_es63();
    CommandRegistry = class {
      constructor() {
        this._timerID = 0;
        this._replaying = false;
        this._keystrokes = [];
        this._keydownEvents = [];
        this._keyBindings = [];
        this._exactKeyMatch = null;
        this._commands = /* @__PURE__ */ new Map();
        this._commandChanged = new Signal(this);
        this._commandExecuted = new Signal(this);
        this._keyBindingChanged = new Signal(this);
        this._holdKeyBindingPromises = /* @__PURE__ */ new Map();
      }
      /**
       * A signal emitted when a command has changed.
       *
       * #### Notes
       * This signal is useful for visual representations of commands which
       * need to refresh when the state of a relevant command has changed.
       */
      get commandChanged() {
        return this._commandChanged;
      }
      /**
       * A signal emitted when a command has executed.
       *
       * #### Notes
       * Care should be taken when consuming this signal. The command system is used
       * by many components for many user actions. Handlers registered with this
       * signal must return quickly to ensure the overall application remains responsive.
       */
      get commandExecuted() {
        return this._commandExecuted;
      }
      /**
       * A signal emitted when a key binding is changed.
       */
      get keyBindingChanged() {
        return this._keyBindingChanged;
      }
      /**
       * A read-only array of the key bindings in the registry.
       */
      get keyBindings() {
        return this._keyBindings;
      }
      /**
       * List the ids of the registered commands.
       *
       * @returns A new array of the registered command ids.
       */
      listCommands() {
        return Array.from(this._commands.keys());
      }
      /**
       * Test whether a specific command is registered.
       *
       * @param id - The id of the command of interest.
       *
       * @returns `true` if the command is registered, `false` otherwise.
       */
      hasCommand(id) {
        return this._commands.has(id);
      }
      /**
       * Add a command to the registry.
       *
       * @param id - The unique id of the command.
       *
       * @param options - The options for the command.
       *
       * @returns A disposable which will remove the command.
       *
       * @throws An error if the given `id` is already registered.
       */
      addCommand(id, options) {
        if (this._commands.has(id)) {
          throw new Error(`Command '${id}' already registered.`);
        }
        this._commands.set(id, Private16.createCommand(options));
        this._commandChanged.emit({ id, type: "added" });
        return new DisposableDelegate(() => {
          this._commands.delete(id);
          this._commandChanged.emit({ id, type: "removed" });
        });
      }
      /**
       * Notify listeners that the state of a command has changed.
       *
       * @param id - The id of the command which has changed. If more than
       *   one command has changed, this argument should be omitted.
       *
       * @throws An error if the given `id` is not registered.
       *
       * #### Notes
       * This method should be called by the command author whenever the
       * application state changes such that the results of the command
       * metadata functions may have changed.
       *
       * This will cause the `commandChanged` signal to be emitted.
       */
      notifyCommandChanged(id) {
        if (id !== void 0 && !this._commands.has(id)) {
          throw new Error(`Command '${id}' is not registered.`);
        }
        this._commandChanged.emit({ id, type: id ? "changed" : "many-changed" });
      }
      /**
       * Get the description for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The description for the command.
       */
      describedBy(id, args = import_coreutils6.JSONExt.emptyObject) {
        var _a;
        let cmd = this._commands.get(id);
        return Promise.resolve((_a = cmd === null || cmd === void 0 ? void 0 : cmd.describedBy.call(void 0, args)) !== null && _a !== void 0 ? _a : { args: null });
      }
      /**
       * Get the display label for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The display label for the command, or an empty string
       *   if the command is not registered.
       */
      label(id, args = import_coreutils6.JSONExt.emptyObject) {
        var _a;
        let cmd = this._commands.get(id);
        return (_a = cmd === null || cmd === void 0 ? void 0 : cmd.label.call(void 0, args)) !== null && _a !== void 0 ? _a : "";
      }
      /**
       * Get the mnemonic index for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The mnemonic index for the command, or `-1` if the
       *   command is not registered.
       */
      mnemonic(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.mnemonic.call(void 0, args) : -1;
      }
      /**
       * Get the icon renderer for a specific command.
       *
       * DEPRECATED: if set to a string value, the .icon field will
       * function as an alias for the .iconClass field, for backwards
       * compatibility. In the future when this is removed, the default
       * return type will become undefined.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The icon renderer for the command or `undefined`.
       */
      icon(id, args = import_coreutils6.JSONExt.emptyObject) {
        var _a;
        return (_a = this._commands.get(id)) === null || _a === void 0 ? void 0 : _a.icon.call(void 0, args);
      }
      /**
       * Get the icon class for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The icon class for the command, or an empty string if
       *   the command is not registered.
       */
      iconClass(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.iconClass.call(void 0, args) : "";
      }
      /**
       * Get the icon label for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The icon label for the command, or an empty string if
       *   the command is not registered.
       */
      iconLabel(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.iconLabel.call(void 0, args) : "";
      }
      /**
       * Get the short form caption for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The caption for the command, or an empty string if the
       *   command is not registered.
       */
      caption(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.caption.call(void 0, args) : "";
      }
      /**
       * Get the usage help text for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The usage text for the command, or an empty string if
       *   the command is not registered.
       */
      usage(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.usage.call(void 0, args) : "";
      }
      /**
       * Get the extra class name for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The class name for the command, or an empty string if
       *   the command is not registered.
       */
      className(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.className.call(void 0, args) : "";
      }
      /**
       * Get the dataset for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The dataset for the command, or an empty dataset if
       *   the command is not registered.
       */
      dataset(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.dataset.call(void 0, args) : {};
      }
      /**
       * Test whether a specific command is enabled.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns A boolean indicating whether the command is enabled,
       *   or `false` if the command is not registered.
       */
      isEnabled(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.isEnabled.call(void 0, args) : false;
      }
      /**
       * Test whether a specific command is toggled.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns A boolean indicating whether the command is toggled,
       *   or `false` if the command is not registered.
       */
      isToggled(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.isToggled.call(void 0, args) : false;
      }
      /**
       * Test whether a specific command is toggleable.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns A boolean indicating whether the command is toggleable,
       *   or `false` if the command is not registered.
       */
      isToggleable(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.isToggleable : false;
      }
      /**
       * Test whether a specific command is visible.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns A boolean indicating whether the command is visible,
       *   or `false` if the command is not registered.
       */
      isVisible(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.isVisible.call(void 0, args) : false;
      }
      /**
       * Execute a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns A promise which resolves with the result of the command.
       *
       * #### Notes
       * The promise will reject if the command throws an exception,
       * or if the command is not registered.
       */
      execute(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        if (!cmd) {
          return Promise.reject(new Error(`Command '${id}' not registered.`));
        }
        let value;
        try {
          value = cmd.execute.call(void 0, args);
        } catch (err) {
          value = Promise.reject(err);
        }
        let result = Promise.resolve(value);
        this._commandExecuted.emit({ id, args, result });
        return result;
      }
      /**
       * Add a key binding to the registry.
       *
       * @param options - The options for creating the key binding.
       *
       * @returns A disposable which removes the added key binding.
       *
       * #### Notes
       * If multiple key bindings are registered for the same sequence, the
       * binding with the highest selector specificity is executed first. A
       * tie is broken by using the most recently added key binding.
       *
       * Ambiguous key bindings are resolved with a timeout. As an example,
       * suppose two key bindings are registered: one with the key sequence
       * `['Ctrl D']`, and another with `['Ctrl D', 'Ctrl W']`. If the user
       * presses `Ctrl D`, the first binding cannot be immediately executed
       * since the user may intend to complete the chord with `Ctrl W`. For
       * such cases, a timer is used to allow the chord to be completed. If
       * the chord is not completed before the timeout, the first binding
       * is executed.
       */
      addKeyBinding(options) {
        let binding = Private16.createKeyBinding(options);
        this._keyBindings.push(binding);
        this._keyBindingChanged.emit({ binding, type: "added" });
        return new DisposableDelegate(() => {
          ArrayExt4.removeFirstOf(this._keyBindings, binding);
          this._keyBindingChanged.emit({ binding, type: "removed" });
        });
      }
      /**
       * Process a `'keydown'` event and invoke a matching key binding.
       *
       * @param event - The event object for a `'keydown'` event.
       *
       * #### Notes
       * This should be called in response to a `'keydown'` event in order
       * to invoke the command for the best matching key binding.
       *
       * The registry **does not** install its own listener for `'keydown'`
       * events. This allows the application full control over the nodes
       * and phase for which the registry processes `'keydown'` events.
       *
       * When the keydown event is processed, if the event target or any of its
       * ancestor nodes has a `data-lm-suppress-shortcuts` attribute, its keydown
       * events will not invoke commands.
       */
      processKeydownEvent(event) {
        if (event.defaultPrevented || this._replaying || CommandRegistry.isModifierKeyPressed(event)) {
          return;
        }
        const keystroke = CommandRegistry.keystrokeForKeydownEvent(event);
        if (!keystroke) {
          this._replayKeydownEvents();
          this._clearPendingState();
          return;
        }
        this._keystrokes.push(keystroke);
        const { exact, partial } = Private16.matchKeyBinding(this._keyBindings, this._keystrokes, event);
        const hasPartial = partial.length !== 0;
        if (!exact && !hasPartial) {
          this._replayKeydownEvents();
          this._clearPendingState();
          return;
        }
        if ((exact === null || exact === void 0 ? void 0 : exact.preventDefault) || partial.some((match) => match.preventDefault)) {
          event.preventDefault();
          event.stopPropagation();
        }
        this._keydownEvents.push(event);
        if (exact && !hasPartial) {
          this._executeKeyBinding(exact);
          this._clearPendingState();
          return;
        }
        if (exact) {
          this._exactKeyMatch = exact;
        }
        this._startTimer();
      }
      /**
       * Delay the execution of any command matched against the given 'keydown' event
       * until the `permission` to execute is granted.
       *
       * @param event - The event object for a `'keydown'` event.
       * @param permission - The promise with value indicating whether to proceed with the execution.
       *
       * ### Note
       * This enables the caller of `processKeydownEvent` to asynchronously prevent the
       * execution of the command based on external events.
       */
      holdKeyBindingExecution(event, permission) {
        this._holdKeyBindingPromises.set(event, permission);
      }
      /**
       * Start or restart the pending timeout.
       */
      _startTimer() {
        this._clearTimer();
        this._timerID = window.setTimeout(() => {
          this._onPendingTimeout();
        }, Private16.CHORD_TIMEOUT);
      }
      /**
       * Clear the pending timeout.
       */
      _clearTimer() {
        if (this._timerID !== 0) {
          clearTimeout(this._timerID);
          this._timerID = 0;
        }
      }
      /**
       * Replay the keydown events which were suppressed.
       */
      _replayKeydownEvents() {
        if (this._keydownEvents.length === 0) {
          return;
        }
        this._replaying = true;
        this._keydownEvents.forEach(Private16.replayKeyEvent);
        this._replaying = false;
      }
      /**
       * Execute the command for the given key binding.
       *
       * If the command is missing or disabled, a warning will be logged.
       *
       * The execution will not proceed if any of the events leading to
       * the keybinding matching were held with the permission resolving to false.
       */
      async _executeKeyBinding(binding) {
        if (this._holdKeyBindingPromises.size !== 0) {
          const keydownEvents = [...this._keydownEvents];
          const executionAllowed = (await Promise.race([
            Promise.all(keydownEvents.map(async (event) => {
              var _a;
              return (_a = this._holdKeyBindingPromises.get(event)) !== null && _a !== void 0 ? _a : Promise.resolve(true);
            })),
            new Promise((resolve) => {
              setTimeout(() => resolve([false]), Private16.KEYBINDING_HOLD_TIMEOUT);
            })
          ])).every(Boolean);
          this._holdKeyBindingPromises.clear();
          if (!executionAllowed) {
            return;
          }
        }
        let { command, args } = binding;
        let newArgs = {
          _luminoEvent: { type: "keybinding", keys: binding.keys },
          ...args
        };
        if (!this.hasCommand(command) || !this.isEnabled(command, newArgs)) {
          let word = this.hasCommand(command) ? "enabled" : "registered";
          let keys = binding.keys.join(", ");
          let msg1 = `Cannot execute key binding '${keys}':`;
          let msg2 = `command '${command}' is not ${word}.`;
          console.warn(`${msg1} ${msg2}`);
          return;
        }
        await this.execute(command, newArgs);
      }
      /**
       * Clear the internal pending state.
       */
      _clearPendingState() {
        this._clearTimer();
        this._exactKeyMatch = null;
        this._keystrokes.length = 0;
        this._keydownEvents.length = 0;
      }
      /**
       * Handle the partial match timeout.
       */
      _onPendingTimeout() {
        this._timerID = 0;
        if (this._exactKeyMatch) {
          this._executeKeyBinding(this._exactKeyMatch);
        } else {
          this._replayKeydownEvents();
        }
        this._clearPendingState();
      }
    };
    (function(CommandRegistry2) {
      function parseKeystroke(keystroke) {
        let key2 = "";
        let alt = false;
        let cmd = false;
        let ctrl = false;
        let shift = false;
        for (let token of keystroke.split(/\s+/)) {
          if (token === "Accel") {
            if (Platform2.IS_MAC) {
              cmd = true;
            } else {
              ctrl = true;
            }
          } else if (token === "Alt") {
            alt = true;
          } else if (token === "Cmd") {
            cmd = true;
          } else if (token === "Ctrl") {
            ctrl = true;
          } else if (token === "Shift") {
            shift = true;
          } else if (token.length > 0) {
            key2 = token;
          }
        }
        return { cmd, ctrl, alt, shift, key: key2 };
      }
      CommandRegistry2.parseKeystroke = parseKeystroke;
      function normalizeKeystroke(keystroke) {
        let mods = "";
        let parts = parseKeystroke(keystroke);
        if (parts.ctrl) {
          mods += "Ctrl ";
        }
        if (parts.alt) {
          mods += "Alt ";
        }
        if (parts.shift) {
          mods += "Shift ";
        }
        if (parts.cmd && Platform2.IS_MAC) {
          mods += "Cmd ";
        }
        return mods + parts.key;
      }
      CommandRegistry2.normalizeKeystroke = normalizeKeystroke;
      function normalizeKeys(options) {
        let keys;
        if (Platform2.IS_WIN) {
          keys = options.winKeys || options.keys;
        } else if (Platform2.IS_MAC) {
          keys = options.macKeys || options.keys;
        } else {
          keys = options.linuxKeys || options.keys;
        }
        return keys.map(normalizeKeystroke);
      }
      CommandRegistry2.normalizeKeys = normalizeKeys;
      function formatKeystroke(keystroke) {
        return typeof keystroke === "string" ? formatSingleKey(keystroke) : keystroke.map(formatSingleKey).join(", ");
        function formatSingleKey(key2) {
          let mods = [];
          let separator = Platform2.IS_MAC ? " " : "+";
          let parts = parseKeystroke(key2);
          if (parts.ctrl) {
            mods.push("Ctrl");
          }
          if (parts.alt) {
            mods.push("Alt");
          }
          if (parts.shift) {
            mods.push("Shift");
          }
          if (Platform2.IS_MAC && parts.cmd) {
            mods.push("Cmd");
          }
          mods.push(parts.key);
          return mods.map(Private16.formatKey).join(separator);
        }
      }
      CommandRegistry2.formatKeystroke = formatKeystroke;
      function isModifierKeyPressed(event) {
        let layout = getKeyboardLayout();
        let key2 = layout.keyForKeydownEvent(event);
        return layout.isModifierKey(key2);
      }
      CommandRegistry2.isModifierKeyPressed = isModifierKeyPressed;
      function keystrokeForKeydownEvent(event) {
        let layout = getKeyboardLayout();
        let key2 = layout.keyForKeydownEvent(event);
        if (!key2 || layout.isModifierKey(key2)) {
          return "";
        }
        let mods = [];
        if (event.ctrlKey) {
          mods.push("Ctrl");
        }
        if (event.altKey) {
          mods.push("Alt");
        }
        if (event.shiftKey) {
          mods.push("Shift");
        }
        if (event.metaKey && Platform2.IS_MAC) {
          mods.push("Cmd");
        }
        mods.push(key2);
        return mods.join(" ");
      }
      CommandRegistry2.keystrokeForKeydownEvent = keystrokeForKeydownEvent;
    })(CommandRegistry || (CommandRegistry = {}));
    (function(Private36) {
      Private36.CHORD_TIMEOUT = 1e3;
      Private36.KEYBINDING_HOLD_TIMEOUT = 1e3;
      function createCommand(options) {
        return {
          execute: options.execute,
          describedBy: asFunc(typeof options.describedBy === "function" ? options.describedBy : { args: null, ...options.describedBy }, () => {
            return { args: null };
          }),
          label: asFunc(options.label, emptyStringFunc),
          mnemonic: asFunc(options.mnemonic, negativeOneFunc),
          icon: asFunc(options.icon, undefinedFunc),
          iconClass: asFunc(options.iconClass, emptyStringFunc),
          iconLabel: asFunc(options.iconLabel, emptyStringFunc),
          caption: asFunc(options.caption, emptyStringFunc),
          usage: asFunc(options.usage, emptyStringFunc),
          className: asFunc(options.className, emptyStringFunc),
          dataset: asFunc(options.dataset, emptyDatasetFunc),
          isEnabled: options.isEnabled || trueFunc,
          isToggled: options.isToggled || falseFunc,
          isToggleable: options.isToggleable || !!options.isToggled,
          isVisible: options.isVisible || trueFunc
        };
      }
      Private36.createCommand = createCommand;
      function createKeyBinding(options) {
        var _a;
        return {
          keys: CommandRegistry.normalizeKeys(options),
          selector: validateSelector(options),
          command: options.command,
          args: options.args || import_coreutils6.JSONExt.emptyObject,
          preventDefault: (_a = options.preventDefault) !== null && _a !== void 0 ? _a : true
        };
      }
      Private36.createKeyBinding = createKeyBinding;
      function matchKeyBinding(bindings, keys, event) {
        let exact = null;
        let partial = [];
        let distance = Infinity;
        let specificity = 0;
        for (let i = 0, n = bindings.length; i < n; ++i) {
          let binding = bindings[i];
          let sqm = matchSequence(binding.keys, keys);
          if (sqm === 0) {
            continue;
          }
          if (sqm === 2) {
            if (targetDistance(binding.selector, event) !== -1) {
              partial.push(binding);
            }
            continue;
          }
          let td = targetDistance(binding.selector, event);
          if (td === -1 || td > distance) {
            continue;
          }
          let sp = Selector3.calculateSpecificity(binding.selector);
          if (!exact || td < distance || sp >= specificity) {
            exact = binding;
            distance = td;
            specificity = sp;
          }
        }
        return { exact, partial };
      }
      Private36.matchKeyBinding = matchKeyBinding;
      function replayKeyEvent(event) {
        event.target.dispatchEvent(cloneKeyboardEvent(event));
      }
      Private36.replayKeyEvent = replayKeyEvent;
      function formatKey(key2) {
        if (Platform2.IS_MAC) {
          return MAC_DISPLAY.hasOwnProperty(key2) ? MAC_DISPLAY[key2] : key2;
        } else {
          return WIN_DISPLAY.hasOwnProperty(key2) ? WIN_DISPLAY[key2] : key2;
        }
      }
      Private36.formatKey = formatKey;
      const MAC_DISPLAY = {
        Backspace: "\u232B",
        Tab: "\u21E5",
        Enter: "\u23CE",
        Shift: "\u21E7",
        Ctrl: "\u2303",
        Alt: "\u2325",
        Escape: "\u238B",
        PageUp: "\u21DE",
        PageDown: "\u21DF",
        End: "\u2198",
        Home: "\u2196",
        ArrowLeft: "\u2190",
        ArrowUp: "\u2191",
        ArrowRight: "\u2192",
        ArrowDown: "\u2193",
        Delete: "\u2326",
        Cmd: "\u2318"
      };
      const WIN_DISPLAY = {
        Escape: "Esc",
        PageUp: "Page Up",
        PageDown: "Page Down",
        ArrowLeft: "Left",
        ArrowUp: "Up",
        ArrowRight: "Right",
        ArrowDown: "Down",
        Delete: "Del"
      };
      const emptyStringFunc = () => "";
      const negativeOneFunc = () => -1;
      const trueFunc = () => true;
      const falseFunc = () => false;
      const emptyDatasetFunc = () => ({});
      const undefinedFunc = () => void 0;
      function asFunc(value, dfault) {
        if (value === void 0) {
          return dfault;
        }
        if (typeof value === "function") {
          return value;
        }
        return () => value;
      }
      function validateSelector(options) {
        if (options.selector.indexOf(",") !== -1) {
          throw new Error(`Selector cannot contain commas: ${options.selector}`);
        }
        if (!Selector3.isValid(options.selector)) {
          throw new Error(`Invalid selector: ${options.selector}`);
        }
        return options.selector;
      }
      function matchSequence(bindKeys, userKeys) {
        if (bindKeys.length < userKeys.length) {
          return 0;
        }
        for (let i = 0, n = userKeys.length; i < n; ++i) {
          if (bindKeys[i] !== userKeys[i]) {
            return 0;
          }
        }
        if (bindKeys.length > userKeys.length) {
          return 2;
        }
        return 1;
      }
      function targetDistance(selector, event) {
        let targ = event.target;
        let curr = event.currentTarget;
        for (let dist = 0; targ !== null; targ = targ.parentElement, ++dist) {
          if (targ.hasAttribute("data-lm-suppress-shortcuts")) {
            return -1;
          }
          if (Selector3.matches(targ, selector)) {
            return dist;
          }
          if (targ === curr) {
            return -1;
          }
        }
        return -1;
      }
      function cloneKeyboardEvent(event) {
        let clone = document.createEvent("Event");
        let bubbles = event.bubbles || true;
        let cancelable = event.cancelable || true;
        clone.initEvent(event.type || "keydown", bubbles, cancelable);
        clone.key = event.key || "";
        clone.keyCode = event.keyCode || 0;
        clone.which = event.keyCode || 0;
        clone.ctrlKey = event.ctrlKey || false;
        clone.altKey = event.altKey || false;
        clone.shiftKey = event.shiftKey || false;
        clone.metaKey = event.metaKey || false;
        clone.view = event.view || window;
        return clone;
      }
    })(Private16 || (Private16 = {}));
  }
});

// ../../node_modules/@lumino/widgets/dist/index.es6.js
var import_coreutils7, BoxSizer, BoxEngine, Title, Widget, Private$j, Layout, LayoutItem, Private$i, PanelLayout, Utils, Utils$1, SplitLayout, Private$h, AccordionLayout, Private$g, Panel, Private$f, SplitPanel, Private$e, AccordionPanel, Private$d, BoxLayout, Private$c, BoxPanel, Private$b, CommandPalette, Private$a, Menu, Private$9, Private$8, ARROW_KEYS, TabBar, Private$7, DockLayout, Private$6, DockPanel, Private$5, FocusTracker, GridLayout, Private$4, MenuBar, Private$3, Private$2, SingletonLayout, StackedLayout, Private$1, Private17;
var init_index_es618 = __esm({
  "../../node_modules/@lumino/widgets/dist/index.es6.js"() {
    init_index_es68();
    import_coreutils7 = __toESM(require_dist());
    init_index_es69();
    init_index_es611();
    init_index_es612();
    init_index_es63();
    init_index_es613();
    init_index_es617();
    init_index_es67();
    init_index_es65();
    init_index_es616();
    BoxSizer = class {
      constructor() {
        this.sizeHint = 0;
        this.minSize = 0;
        this.maxSize = Infinity;
        this.stretch = 1;
        this.size = 0;
        this.done = false;
      }
    };
    (function(BoxEngine2) {
      function calc(sizers, space) {
        let count = sizers.length;
        if (count === 0) {
          return space;
        }
        let totalMin = 0;
        let totalMax = 0;
        let totalSize = 0;
        let totalStretch = 0;
        let stretchCount = 0;
        for (let i = 0; i < count; ++i) {
          let sizer = sizers[i];
          let min = sizer.minSize;
          let max2 = sizer.maxSize;
          let hint = sizer.sizeHint;
          sizer.done = false;
          sizer.size = Math.max(min, Math.min(hint, max2));
          totalSize += sizer.size;
          totalMin += min;
          totalMax += max2;
          if (sizer.stretch > 0) {
            totalStretch += sizer.stretch;
            stretchCount++;
          }
        }
        if (space === totalSize) {
          return 0;
        }
        if (space <= totalMin) {
          for (let i = 0; i < count; ++i) {
            let sizer = sizers[i];
            sizer.size = sizer.minSize;
          }
          return space - totalMin;
        }
        if (space >= totalMax) {
          for (let i = 0; i < count; ++i) {
            let sizer = sizers[i];
            sizer.size = sizer.maxSize;
          }
          return space - totalMax;
        }
        let nearZero = 0.01;
        let notDoneCount = count;
        if (space < totalSize) {
          let freeSpace = totalSize - space;
          while (stretchCount > 0 && freeSpace > nearZero) {
            let distSpace = freeSpace;
            let distStretch = totalStretch;
            for (let i = 0; i < count; ++i) {
              let sizer = sizers[i];
              if (sizer.done || sizer.stretch === 0) {
                continue;
              }
              let amt = sizer.stretch * distSpace / distStretch;
              if (sizer.size - amt <= sizer.minSize) {
                freeSpace -= sizer.size - sizer.minSize;
                totalStretch -= sizer.stretch;
                sizer.size = sizer.minSize;
                sizer.done = true;
                notDoneCount--;
                stretchCount--;
              } else {
                freeSpace -= amt;
                sizer.size -= amt;
              }
            }
          }
          while (notDoneCount > 0 && freeSpace > nearZero) {
            let amt = freeSpace / notDoneCount;
            for (let i = 0; i < count; ++i) {
              let sizer = sizers[i];
              if (sizer.done) {
                continue;
              }
              if (sizer.size - amt <= sizer.minSize) {
                freeSpace -= sizer.size - sizer.minSize;
                sizer.size = sizer.minSize;
                sizer.done = true;
                notDoneCount--;
              } else {
                freeSpace -= amt;
                sizer.size -= amt;
              }
            }
          }
        } else {
          let freeSpace = space - totalSize;
          while (stretchCount > 0 && freeSpace > nearZero) {
            let distSpace = freeSpace;
            let distStretch = totalStretch;
            for (let i = 0; i < count; ++i) {
              let sizer = sizers[i];
              if (sizer.done || sizer.stretch === 0) {
                continue;
              }
              let amt = sizer.stretch * distSpace / distStretch;
              if (sizer.size + amt >= sizer.maxSize) {
                freeSpace -= sizer.maxSize - sizer.size;
                totalStretch -= sizer.stretch;
                sizer.size = sizer.maxSize;
                sizer.done = true;
                notDoneCount--;
                stretchCount--;
              } else {
                freeSpace -= amt;
                sizer.size += amt;
              }
            }
          }
          while (notDoneCount > 0 && freeSpace > nearZero) {
            let amt = freeSpace / notDoneCount;
            for (let i = 0; i < count; ++i) {
              let sizer = sizers[i];
              if (sizer.done) {
                continue;
              }
              if (sizer.size + amt >= sizer.maxSize) {
                freeSpace -= sizer.maxSize - sizer.size;
                sizer.size = sizer.maxSize;
                sizer.done = true;
                notDoneCount--;
              } else {
                freeSpace -= amt;
                sizer.size += amt;
              }
            }
          }
        }
        return 0;
      }
      BoxEngine2.calc = calc;
      function adjust(sizers, index, delta) {
        if (sizers.length === 0 || delta === 0) {
          return;
        }
        if (delta > 0) {
          growSizer(sizers, index, delta);
        } else {
          shrinkSizer(sizers, index, -delta);
        }
      }
      BoxEngine2.adjust = adjust;
      function growSizer(sizers, index, delta) {
        let growLimit = 0;
        for (let i = 0; i <= index; ++i) {
          let sizer = sizers[i];
          growLimit += sizer.maxSize - sizer.size;
        }
        let shrinkLimit = 0;
        for (let i = index + 1, n = sizers.length; i < n; ++i) {
          let sizer = sizers[i];
          shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        let grow = delta;
        for (let i = index; i >= 0 && grow > 0; --i) {
          let sizer = sizers[i];
          let limit2 = sizer.maxSize - sizer.size;
          if (limit2 >= grow) {
            sizer.sizeHint = sizer.size + grow;
            grow = 0;
          } else {
            sizer.sizeHint = sizer.size + limit2;
            grow -= limit2;
          }
        }
        let shrink = delta;
        for (let i = index + 1, n = sizers.length; i < n && shrink > 0; ++i) {
          let sizer = sizers[i];
          let limit2 = sizer.size - sizer.minSize;
          if (limit2 >= shrink) {
            sizer.sizeHint = sizer.size - shrink;
            shrink = 0;
          } else {
            sizer.sizeHint = sizer.size - limit2;
            shrink -= limit2;
          }
        }
      }
      function shrinkSizer(sizers, index, delta) {
        let growLimit = 0;
        for (let i = index + 1, n = sizers.length; i < n; ++i) {
          let sizer = sizers[i];
          growLimit += sizer.maxSize - sizer.size;
        }
        let shrinkLimit = 0;
        for (let i = 0; i <= index; ++i) {
          let sizer = sizers[i];
          shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        let grow = delta;
        for (let i = index + 1, n = sizers.length; i < n && grow > 0; ++i) {
          let sizer = sizers[i];
          let limit2 = sizer.maxSize - sizer.size;
          if (limit2 >= grow) {
            sizer.sizeHint = sizer.size + grow;
            grow = 0;
          } else {
            sizer.sizeHint = sizer.size + limit2;
            grow -= limit2;
          }
        }
        let shrink = delta;
        for (let i = index; i >= 0 && shrink > 0; --i) {
          let sizer = sizers[i];
          let limit2 = sizer.size - sizer.minSize;
          if (limit2 >= shrink) {
            sizer.sizeHint = sizer.size - shrink;
            shrink = 0;
          } else {
            sizer.sizeHint = sizer.size - limit2;
            shrink -= limit2;
          }
        }
      }
    })(BoxEngine || (BoxEngine = {}));
    Title = class {
      /**
       * Construct a new title.
       *
       * @param options - The options for initializing the title.
       */
      constructor(options) {
        this._label = "";
        this._caption = "";
        this._mnemonic = -1;
        this._icon = void 0;
        this._iconClass = "";
        this._iconLabel = "";
        this._className = "";
        this._closable = false;
        this._changed = new Signal(this);
        this._isDisposed = false;
        this.owner = options.owner;
        if (options.label !== void 0) {
          this._label = options.label;
        }
        if (options.mnemonic !== void 0) {
          this._mnemonic = options.mnemonic;
        }
        if (options.icon !== void 0) {
          this._icon = options.icon;
        }
        if (options.iconClass !== void 0) {
          this._iconClass = options.iconClass;
        }
        if (options.iconLabel !== void 0) {
          this._iconLabel = options.iconLabel;
        }
        if (options.caption !== void 0) {
          this._caption = options.caption;
        }
        if (options.className !== void 0) {
          this._className = options.className;
        }
        if (options.closable !== void 0) {
          this._closable = options.closable;
        }
        this._dataset = options.dataset || {};
      }
      /**
       * A signal emitted when the state of the title changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Get the label for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get label() {
        return this._label;
      }
      /**
       * Set the label for the title.
       */
      set label(value) {
        if (this._label === value) {
          return;
        }
        this._label = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the mnemonic index for the title.
       *
       * #### Notes
       * The default value is `-1`.
       */
      get mnemonic() {
        return this._mnemonic;
      }
      /**
       * Set the mnemonic index for the title.
       */
      set mnemonic(value) {
        if (this._mnemonic === value) {
          return;
        }
        this._mnemonic = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon renderer for the title.
       *
       * #### Notes
       * The default value is undefined.
       */
      get icon() {
        return this._icon;
      }
      /**
       * Set the icon renderer for the title.
       *
       * #### Notes
       * A renderer is an object that supplies a render and unrender function.
       */
      set icon(value) {
        if (this._icon === value) {
          return;
        }
        this._icon = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon class name for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get iconClass() {
        return this._iconClass;
      }
      /**
       * Set the icon class name for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set iconClass(value) {
        if (this._iconClass === value) {
          return;
        }
        this._iconClass = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon label for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get iconLabel() {
        return this._iconLabel;
      }
      /**
       * Set the icon label for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set iconLabel(value) {
        if (this._iconLabel === value) {
          return;
        }
        this._iconLabel = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the caption for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get caption() {
        return this._caption;
      }
      /**
       * Set the caption for the title.
       */
      set caption(value) {
        if (this._caption === value) {
          return;
        }
        this._caption = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the extra class name for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get className() {
        return this._className;
      }
      /**
       * Set the extra class name for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set className(value) {
        if (this._className === value) {
          return;
        }
        this._className = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the closable state for the title.
       *
       * #### Notes
       * The default value is `false`.
       */
      get closable() {
        return this._closable;
      }
      /**
       * Set the closable state for the title.
       *
       * #### Notes
       * This controls the presence of a close icon when applicable.
       */
      set closable(value) {
        if (this._closable === value) {
          return;
        }
        this._closable = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the dataset for the title.
       *
       * #### Notes
       * The default value is an empty dataset.
       */
      get dataset() {
        return this._dataset;
      }
      /**
       * Set the dataset for the title.
       *
       * #### Notes
       * This controls the data attributes when applicable.
       */
      set dataset(value) {
        if (this._dataset === value) {
          return;
        }
        this._dataset = value;
        this._changed.emit(void 0);
      }
      /**
       * Test whether the title has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the title.
       *
       * #### Notes
       * It is the responsibility of the owner to call the title disposal.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
      }
    };
    Widget = class {
      /**
       * Construct a new widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options = {}) {
        this._flags = 0;
        this._layout = null;
        this._parent = null;
        this._disposed = new Signal(this);
        this._hiddenMode = Widget.HiddenMode.Display;
        this.node = Private$j.createNode(options);
        this.addClass("lm-Widget");
      }
      /**
       * Dispose of the widget and its descendant widgets.
       *
       * #### Notes
       * It is unsafe to use the widget after it has been disposed.
       *
       * All calls made to this method after the first are a no-op.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this.setFlag(Widget.Flag.IsDisposed);
        this._disposed.emit(void 0);
        if (this.parent) {
          this.parent = null;
        } else if (this.isAttached) {
          Widget.detach(this);
        }
        if (this._layout) {
          this._layout.dispose();
          this._layout = null;
        }
        this.title.dispose();
        Signal.clearData(this);
        MessageLoop.clearData(this);
        AttachedProperty2.clearData(this);
      }
      /**
       * A signal emitted when the widget is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Test whether the widget has been disposed.
       */
      get isDisposed() {
        return this.testFlag(Widget.Flag.IsDisposed);
      }
      /**
       * Test whether the widget's node is attached to the DOM.
       */
      get isAttached() {
        return this.testFlag(Widget.Flag.IsAttached);
      }
      /**
       * Test whether the widget is explicitly hidden.
       */
      get isHidden() {
        return this.testFlag(Widget.Flag.IsHidden);
      }
      /**
       * Test whether the widget is visible.
       *
       * #### Notes
       * A widget is visible when it is attached to the DOM, is not
       * explicitly hidden, and has no explicitly hidden ancestors.
       */
      get isVisible() {
        return this.testFlag(Widget.Flag.IsVisible);
      }
      /**
       * The title object for the widget.
       *
       * #### Notes
       * The title object is used by some container widgets when displaying
       * the widget alongside some title, such as a tab panel or side bar.
       *
       * Since not all widgets will use the title, it is created on demand.
       *
       * The `owner` property of the title is set to this widget.
       */
      get title() {
        return Private$j.titleProperty.get(this);
      }
      /**
       * Get the id of the widget's DOM node.
       */
      get id() {
        return this.node.id;
      }
      /**
       * Set the id of the widget's DOM node.
       */
      set id(value) {
        this.node.id = value;
      }
      /**
       * The dataset for the widget's DOM node.
       */
      get dataset() {
        return this.node.dataset;
      }
      /**
       * Get the method for hiding the widget.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      /**
       * Set the method for hiding the widget.
       */
      set hiddenMode(value) {
        if (this._hiddenMode === value) {
          return;
        }
        if (this.isHidden) {
          this._toggleHidden(false);
        }
        if (value == Widget.HiddenMode.Scale) {
          this.node.style.willChange = "transform";
        } else {
          this.node.style.willChange = "auto";
        }
        this._hiddenMode = value;
        if (this.isHidden) {
          this._toggleHidden(true);
        }
      }
      /**
       * Get the parent of the widget.
       */
      get parent() {
        return this._parent;
      }
      /**
       * Set the parent of the widget.
       *
       * #### Notes
       * Children are typically added to a widget by using a layout, which
       * means user code will not normally set the parent widget directly.
       *
       * The widget will be automatically removed from its old parent.
       *
       * This is a no-op if there is no effective parent change.
       */
      set parent(value) {
        if (this._parent === value) {
          return;
        }
        if (value && this.contains(value)) {
          throw new Error("Invalid parent widget.");
        }
        if (this._parent && !this._parent.isDisposed) {
          let msg = new Widget.ChildMessage("child-removed", this);
          MessageLoop.sendMessage(this._parent, msg);
        }
        this._parent = value;
        if (this._parent && !this._parent.isDisposed) {
          let msg = new Widget.ChildMessage("child-added", this);
          MessageLoop.sendMessage(this._parent, msg);
        }
        if (!this.isDisposed) {
          MessageLoop.sendMessage(this, Widget.Msg.ParentChanged);
        }
      }
      /**
       * Get the layout for the widget.
       */
      get layout() {
        return this._layout;
      }
      /**
       * Set the layout for the widget.
       *
       * #### Notes
       * The layout is single-use only. It cannot be changed after the
       * first assignment.
       *
       * The layout is disposed automatically when the widget is disposed.
       */
      set layout(value) {
        if (this._layout === value) {
          return;
        }
        if (this.testFlag(Widget.Flag.DisallowLayout)) {
          throw new Error("Cannot set widget layout.");
        }
        if (this._layout) {
          throw new Error("Cannot change widget layout.");
        }
        if (value.parent) {
          throw new Error("Cannot change layout parent.");
        }
        this._layout = value;
        value.parent = this;
      }
      /**
       * Create an iterator over the widget's children.
       *
       * @returns A new iterator over the children of the widget.
       *
       * #### Notes
       * The widget must have a populated layout in order to have children.
       *
       * If a layout is not installed, the returned iterator will be empty.
       */
      *children() {
        if (this._layout) {
          yield* this._layout;
        }
      }
      /**
       * Test whether a widget is a descendant of this widget.
       *
       * @param widget - The descendant widget of interest.
       *
       * @returns `true` if the widget is a descendant, `false` otherwise.
       */
      contains(widget) {
        for (let value = widget; value; value = value._parent) {
          if (value === this) {
            return true;
          }
        }
        return false;
      }
      /**
       * Test whether the widget's DOM node has the given class name.
       *
       * @param name - The class name of interest.
       *
       * @returns `true` if the node has the class, `false` otherwise.
       */
      hasClass(name2) {
        return this.node.classList.contains(name2);
      }
      /**
       * Add a class name to the widget's DOM node.
       *
       * @param name - The class name to add to the node.
       *
       * #### Notes
       * If the class name is already added to the node, this is a no-op.
       *
       * The class name must not contain whitespace.
       */
      addClass(name2) {
        this.node.classList.add(name2);
      }
      /**
       * Remove a class name from the widget's DOM node.
       *
       * @param name - The class name to remove from the node.
       *
       * #### Notes
       * If the class name is not yet added to the node, this is a no-op.
       *
       * The class name must not contain whitespace.
       */
      removeClass(name2) {
        this.node.classList.remove(name2);
      }
      /**
       * Toggle a class name on the widget's DOM node.
       *
       * @param name - The class name to toggle on the node.
       *
       * @param force - Whether to force add the class (`true`) or force
       *   remove the class (`false`). If not provided, the presence of
       *   the class will be toggled from its current state.
       *
       * @returns `true` if the class is now present, `false` otherwise.
       *
       * #### Notes
       * The class name must not contain whitespace.
       */
      toggleClass(name2, force) {
        if (force === true) {
          this.node.classList.add(name2);
          return true;
        }
        if (force === false) {
          this.node.classList.remove(name2);
          return false;
        }
        return this.node.classList.toggle(name2);
      }
      /**
       * Post an `'update-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      update() {
        MessageLoop.postMessage(this, Widget.Msg.UpdateRequest);
      }
      /**
       * Post a `'fit-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      fit() {
        MessageLoop.postMessage(this, Widget.Msg.FitRequest);
      }
      /**
       * Post an `'activate-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      activate() {
        MessageLoop.postMessage(this, Widget.Msg.ActivateRequest);
      }
      /**
       * Send a `'close-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for sending the message.
       */
      close() {
        MessageLoop.sendMessage(this, Widget.Msg.CloseRequest);
      }
      /**
       * Show the widget and make it visible to its parent widget.
       *
       * #### Notes
       * This causes the {@link isHidden} property to be `false`.
       *
       * If the widget is not explicitly hidden, this is a no-op.
       */
      show() {
        if (!this.testFlag(Widget.Flag.IsHidden)) {
          return;
        }
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop.sendMessage(this, Widget.Msg.BeforeShow);
        }
        this.clearFlag(Widget.Flag.IsHidden);
        this._toggleHidden(false);
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop.sendMessage(this, Widget.Msg.AfterShow);
        }
        if (this.parent) {
          let msg = new Widget.ChildMessage("child-shown", this);
          MessageLoop.sendMessage(this.parent, msg);
        }
      }
      /**
       * Hide the widget and make it hidden to its parent widget.
       *
       * #### Notes
       * This causes the {@link isHidden} property to be `true`.
       *
       * If the widget is explicitly hidden, this is a no-op.
       */
      hide() {
        if (this.testFlag(Widget.Flag.IsHidden)) {
          return;
        }
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop.sendMessage(this, Widget.Msg.BeforeHide);
        }
        this.setFlag(Widget.Flag.IsHidden);
        this._toggleHidden(true);
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop.sendMessage(this, Widget.Msg.AfterHide);
        }
        if (this.parent) {
          let msg = new Widget.ChildMessage("child-hidden", this);
          MessageLoop.sendMessage(this.parent, msg);
        }
      }
      /**
       * Show or hide the widget according to a boolean value.
       *
       * @param hidden - `true` to hide the widget, or `false` to show it.
       *
       * #### Notes
       * This is a convenience method for `hide()` and `show()`.
       */
      setHidden(hidden2) {
        if (hidden2) {
          this.hide();
        } else {
          this.show();
        }
      }
      /**
       * Test whether the given widget flag is set.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       */
      testFlag(flag) {
        return (this._flags & flag) !== 0;
      }
      /**
       * Set the given widget flag.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       */
      setFlag(flag) {
        this._flags |= flag;
      }
      /**
       * Clear the given widget flag.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       */
      clearFlag(flag) {
        this._flags &= ~flag;
      }
      /**
       * Process a message sent to the widget.
       *
       * @param msg - The message sent to the widget.
       *
       * #### Notes
       * Subclasses may reimplement this method as needed.
       */
      processMessage(msg) {
        switch (msg.type) {
          case "resize":
            this.notifyLayout(msg);
            this.onResize(msg);
            break;
          case "update-request":
            this.notifyLayout(msg);
            this.onUpdateRequest(msg);
            break;
          case "fit-request":
            this.notifyLayout(msg);
            this.onFitRequest(msg);
            break;
          case "before-show":
            this.notifyLayout(msg);
            this.onBeforeShow(msg);
            break;
          case "after-show":
            this.setFlag(Widget.Flag.IsVisible);
            this.notifyLayout(msg);
            this.onAfterShow(msg);
            break;
          case "before-hide":
            this.notifyLayout(msg);
            this.onBeforeHide(msg);
            break;
          case "after-hide":
            this.clearFlag(Widget.Flag.IsVisible);
            this.notifyLayout(msg);
            this.onAfterHide(msg);
            break;
          case "before-attach":
            this.notifyLayout(msg);
            this.onBeforeAttach(msg);
            break;
          case "after-attach":
            if (!this.isHidden && (!this.parent || this.parent.isVisible)) {
              this.setFlag(Widget.Flag.IsVisible);
            }
            this.setFlag(Widget.Flag.IsAttached);
            this.notifyLayout(msg);
            this.onAfterAttach(msg);
            break;
          case "before-detach":
            this.notifyLayout(msg);
            this.onBeforeDetach(msg);
            break;
          case "after-detach":
            this.clearFlag(Widget.Flag.IsVisible);
            this.clearFlag(Widget.Flag.IsAttached);
            this.notifyLayout(msg);
            this.onAfterDetach(msg);
            break;
          case "activate-request":
            this.notifyLayout(msg);
            this.onActivateRequest(msg);
            break;
          case "close-request":
            this.notifyLayout(msg);
            this.onCloseRequest(msg);
            break;
          case "child-added":
            this.notifyLayout(msg);
            this.onChildAdded(msg);
            break;
          case "child-removed":
            this.notifyLayout(msg);
            this.onChildRemoved(msg);
            break;
          default:
            this.notifyLayout(msg);
            break;
        }
      }
      /**
       * Invoke the message processing routine of the widget's layout.
       *
       * @param msg - The message to dispatch to the layout.
       *
       * #### Notes
       * This is a no-op if the widget does not have a layout.
       *
       * This will not typically be called directly by user code.
       */
      notifyLayout(msg) {
        if (this._layout) {
          this._layout.processParentMessage(msg);
        }
      }
      /**
       * A message handler invoked on a `'close-request'` message.
       *
       * #### Notes
       * The default implementation unparents or detaches the widget.
       */
      onCloseRequest(msg) {
        if (this.parent) {
          this.parent = null;
        } else if (this.isAttached) {
          Widget.detach(this);
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onResize(msg) {
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onUpdateRequest(msg) {
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onFitRequest(msg) {
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onActivateRequest(msg) {
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeShow(msg) {
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterShow(msg) {
      }
      /**
       * A message handler invoked on a `'before-hide'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeHide(msg) {
      }
      /**
       * A message handler invoked on an `'after-hide'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterHide(msg) {
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeAttach(msg) {
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterAttach(msg) {
      }
      /**
       * A message handler invoked on a `'before-detach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeDetach(msg) {
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterDetach(msg) {
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildAdded(msg) {
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildRemoved(msg) {
      }
      _toggleHidden(hidden2) {
        if (hidden2) {
          switch (this._hiddenMode) {
            case Widget.HiddenMode.Display:
              this.addClass("lm-mod-hidden");
              break;
            case Widget.HiddenMode.Scale:
              this.node.style.transform = "scale(0)";
              this.node.setAttribute("aria-hidden", "true");
              break;
            case Widget.HiddenMode.ContentVisibility:
              this.node.style.contentVisibility = "hidden";
              this.node.style.zIndex = "-1";
              break;
          }
        } else {
          switch (this._hiddenMode) {
            case Widget.HiddenMode.Display:
              this.removeClass("lm-mod-hidden");
              break;
            case Widget.HiddenMode.Scale:
              this.node.style.transform = "";
              this.node.removeAttribute("aria-hidden");
              break;
            case Widget.HiddenMode.ContentVisibility:
              this.node.style.contentVisibility = "";
              this.node.style.zIndex = "";
              break;
          }
        }
      }
    };
    (function(Widget2) {
      (function(HiddenMode) {
        HiddenMode[HiddenMode["Display"] = 0] = "Display";
        HiddenMode[HiddenMode["Scale"] = 1] = "Scale";
        HiddenMode[HiddenMode["ContentVisibility"] = 2] = "ContentVisibility";
      })(Widget2.HiddenMode || (Widget2.HiddenMode = {}));
      (function(Flag) {
        Flag[Flag["IsDisposed"] = 1] = "IsDisposed";
        Flag[Flag["IsAttached"] = 2] = "IsAttached";
        Flag[Flag["IsHidden"] = 4] = "IsHidden";
        Flag[Flag["IsVisible"] = 8] = "IsVisible";
        Flag[Flag["DisallowLayout"] = 16] = "DisallowLayout";
      })(Widget2.Flag || (Widget2.Flag = {}));
      (function(Msg) {
        Msg.BeforeShow = new Message("before-show");
        Msg.AfterShow = new Message("after-show");
        Msg.BeforeHide = new Message("before-hide");
        Msg.AfterHide = new Message("after-hide");
        Msg.BeforeAttach = new Message("before-attach");
        Msg.AfterAttach = new Message("after-attach");
        Msg.BeforeDetach = new Message("before-detach");
        Msg.AfterDetach = new Message("after-detach");
        Msg.ParentChanged = new Message("parent-changed");
        Msg.UpdateRequest = new ConflatableMessage("update-request");
        Msg.FitRequest = new ConflatableMessage("fit-request");
        Msg.ActivateRequest = new ConflatableMessage("activate-request");
        Msg.CloseRequest = new ConflatableMessage("close-request");
      })(Widget2.Msg || (Widget2.Msg = {}));
      class ChildMessage extends Message {
        /**
         * Construct a new child message.
         *
         * @param type - The message type.
         *
         * @param child - The child widget for the message.
         */
        constructor(type, child) {
          super(type);
          this.child = child;
        }
      }
      Widget2.ChildMessage = ChildMessage;
      class ResizeMessage extends Message {
        /**
         * Construct a new resize message.
         *
         * @param width - The **offset width** of the widget, or `-1` if
         *   the width is not known.
         *
         * @param height - The **offset height** of the widget, or `-1` if
         *   the height is not known.
         */
        constructor(width, height) {
          super("resize");
          this.width = width;
          this.height = height;
        }
      }
      Widget2.ResizeMessage = ResizeMessage;
      (function(ResizeMessage2) {
        ResizeMessage2.UnknownSize = new ResizeMessage2(-1, -1);
      })(ResizeMessage = Widget2.ResizeMessage || (Widget2.ResizeMessage = {}));
      function attach(widget, host, ref2 = null) {
        if (widget.parent) {
          throw new Error("Cannot attach a child widget.");
        }
        if (widget.isAttached || widget.node.isConnected) {
          throw new Error("Widget is already attached.");
        }
        if (!host.isConnected) {
          throw new Error("Host is not attached.");
        }
        MessageLoop.sendMessage(widget, Widget2.Msg.BeforeAttach);
        host.insertBefore(widget.node, ref2);
        MessageLoop.sendMessage(widget, Widget2.Msg.AfterAttach);
      }
      Widget2.attach = attach;
      function detach(widget) {
        if (widget.parent) {
          throw new Error("Cannot detach a child widget.");
        }
        if (!widget.isAttached || !widget.node.isConnected) {
          throw new Error("Widget is not attached.");
        }
        MessageLoop.sendMessage(widget, Widget2.Msg.BeforeDetach);
        widget.node.parentNode.removeChild(widget.node);
        MessageLoop.sendMessage(widget, Widget2.Msg.AfterDetach);
      }
      Widget2.detach = detach;
    })(Widget || (Widget = {}));
    (function(Private36) {
      Private36.titleProperty = new AttachedProperty2({
        name: "title",
        create: (owner) => new Title({ owner })
      });
      function createNode(options) {
        return options.node || document.createElement(options.tag || "div");
      }
      Private36.createNode = createNode;
    })(Private$j || (Private$j = {}));
    Layout = class {
      /**
       * Construct a new layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        this._disposed = false;
        this._parent = null;
        this._fitPolicy = options.fitPolicy || "set-min-size";
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This should be reimplemented to clear and dispose of the widgets.
       *
       * All reimplementations should call the superclass method.
       *
       * This method is called automatically when the parent is disposed.
       */
      dispose() {
        this._parent = null;
        this._disposed = true;
        Signal.clearData(this);
        AttachedProperty2.clearData(this);
      }
      /**
       * Test whether the layout is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Get the parent widget of the layout.
       */
      get parent() {
        return this._parent;
      }
      /**
       * Set the parent widget of the layout.
       *
       * #### Notes
       * This is set automatically when installing the layout on the parent
       * widget. The parent widget should not be set directly by user code.
       */
      set parent(value) {
        if (this._parent === value) {
          return;
        }
        if (this._parent) {
          throw new Error("Cannot change parent widget.");
        }
        if (value.layout !== this) {
          throw new Error("Invalid parent widget.");
        }
        this._parent = value;
        this.init();
      }
      /**
       * Get the fit policy for the layout.
       *
       * #### Notes
       * The fit policy controls the computed size constraints which are
       * applied to the parent widget by the layout.
       *
       * Some layout implementations may ignore the fit policy.
       */
      get fitPolicy() {
        return this._fitPolicy;
      }
      /**
       * Set the fit policy for the layout.
       *
       * #### Notes
       * The fit policy controls the computed size constraints which are
       * applied to the parent widget by the layout.
       *
       * Some layout implementations may ignore the fit policy.
       *
       * Changing the fit policy will clear the current size constraint
       * for the parent widget and then re-fit the parent.
       */
      set fitPolicy(value) {
        if (this._fitPolicy === value) {
          return;
        }
        this._fitPolicy = value;
        if (this._parent) {
          let style = this._parent.node.style;
          style.minWidth = "";
          style.minHeight = "";
          style.maxWidth = "";
          style.maxHeight = "";
          this._parent.fit();
        }
      }
      /**
       * Process a message sent to the parent widget.
       *
       * @param msg - The message sent to the parent widget.
       *
       * #### Notes
       * This method is called by the parent widget to process a message.
       *
       * Subclasses may reimplement this method as needed.
       */
      processParentMessage(msg) {
        switch (msg.type) {
          case "resize":
            this.onResize(msg);
            break;
          case "update-request":
            this.onUpdateRequest(msg);
            break;
          case "fit-request":
            this.onFitRequest(msg);
            break;
          case "before-show":
            this.onBeforeShow(msg);
            break;
          case "after-show":
            this.onAfterShow(msg);
            break;
          case "before-hide":
            this.onBeforeHide(msg);
            break;
          case "after-hide":
            this.onAfterHide(msg);
            break;
          case "before-attach":
            this.onBeforeAttach(msg);
            break;
          case "after-attach":
            this.onAfterAttach(msg);
            break;
          case "before-detach":
            this.onBeforeDetach(msg);
            break;
          case "after-detach":
            this.onAfterDetach(msg);
            break;
          case "child-removed":
            this.onChildRemoved(msg);
            break;
          case "child-shown":
            this.onChildShown(msg);
            break;
          case "child-hidden":
            this.onChildHidden(msg);
            break;
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       *
       * #### Notes
       * This method is invoked immediately after the layout is installed
       * on the parent widget.
       *
       * The default implementation reparents all of the widgets to the
       * layout parent widget.
       *
       * Subclasses should reimplement this method and attach the child
       * widget nodes to the parent widget's node.
       */
      init() {
        for (const widget of this) {
          widget.parent = this.parent;
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       *
       * #### Notes
       * The layout should ensure that its widgets are resized according
       * to the specified layout space, and that they are sent a `'resize'`
       * message if appropriate.
       *
       * The default implementation of this method sends an `UnknownSize`
       * resize message to all widgets.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onResize(msg) {
        for (const widget of this) {
          MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * The layout should ensure that its widgets are resized according
       * to the available layout space, and that they are sent a `'resize'`
       * message if appropriate.
       *
       * The default implementation of this method sends an `UnknownSize`
       * resize message to all widgets.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onUpdateRequest(msg) {
        for (const widget of this) {
          MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeAttach(msg) {
        for (const widget of this) {
          MessageLoop.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterAttach(msg) {
        for (const widget of this) {
          MessageLoop.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on a `'before-detach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeDetach(msg) {
        for (const widget of this) {
          MessageLoop.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterDetach(msg) {
        for (const widget of this) {
          MessageLoop.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeShow(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterShow(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on a `'before-hide'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeHide(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on an `'after-hide'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterHide(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       *
       * #### Notes
       * This will remove the child widget from the layout.
       *
       * Subclasses should **not** typically reimplement this method.
       */
      onChildRemoved(msg) {
        this.removeWidget(msg.child);
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onFitRequest(msg) {
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildShown(msg) {
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildHidden(msg) {
      }
    };
    (function(Layout2) {
      function getHorizontalAlignment(widget) {
        return Private$i.horizontalAlignmentProperty.get(widget);
      }
      Layout2.getHorizontalAlignment = getHorizontalAlignment;
      function setHorizontalAlignment(widget, value) {
        Private$i.horizontalAlignmentProperty.set(widget, value);
      }
      Layout2.setHorizontalAlignment = setHorizontalAlignment;
      function getVerticalAlignment(widget) {
        return Private$i.verticalAlignmentProperty.get(widget);
      }
      Layout2.getVerticalAlignment = getVerticalAlignment;
      function setVerticalAlignment(widget, value) {
        Private$i.verticalAlignmentProperty.set(widget, value);
      }
      Layout2.setVerticalAlignment = setVerticalAlignment;
    })(Layout || (Layout = {}));
    LayoutItem = class {
      /**
       * Construct a new layout item.
       *
       * @param widget - The widget to be managed by the item.
       *
       * #### Notes
       * The widget will be set to absolute positioning.
       * The widget will use strict CSS containment.
       */
      constructor(widget) {
        this._top = NaN;
        this._left = NaN;
        this._width = NaN;
        this._height = NaN;
        this._minWidth = 0;
        this._minHeight = 0;
        this._maxWidth = Infinity;
        this._maxHeight = Infinity;
        this._disposed = false;
        this.widget = widget;
        this.widget.node.style.position = "absolute";
        this.widget.node.style.contain = "strict";
      }
      /**
       * Dispose of the the layout item.
       *
       * #### Notes
       * This will reset the positioning of the widget.
       */
      dispose() {
        if (this._disposed) {
          return;
        }
        this._disposed = true;
        let style = this.widget.node.style;
        style.position = "";
        style.top = "";
        style.left = "";
        style.width = "";
        style.height = "";
        style.contain = "";
      }
      /**
       * The computed minimum width of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get minWidth() {
        return this._minWidth;
      }
      /**
       * The computed minimum height of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get minHeight() {
        return this._minHeight;
      }
      /**
       * The computed maximum width of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get maxWidth() {
        return this._maxWidth;
      }
      /**
       * The computed maximum height of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get maxHeight() {
        return this._maxHeight;
      }
      /**
       * Whether the layout item is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Whether the managed widget is hidden.
       */
      get isHidden() {
        return this.widget.isHidden;
      }
      /**
       * Whether the managed widget is visible.
       */
      get isVisible() {
        return this.widget.isVisible;
      }
      /**
       * Whether the managed widget is attached.
       */
      get isAttached() {
        return this.widget.isAttached;
      }
      /**
       * Update the computed size limits of the managed widget.
       */
      fit() {
        let limits = ElementExt.sizeLimits(this.widget.node);
        this._minWidth = limits.minWidth;
        this._minHeight = limits.minHeight;
        this._maxWidth = limits.maxWidth;
        this._maxHeight = limits.maxHeight;
      }
      /**
       * Update the position and size of the managed widget.
       *
       * @param left - The left edge position of the layout box.
       *
       * @param top - The top edge position of the layout box.
       *
       * @param width - The width of the layout box.
       *
       * @param height - The height of the layout box.
       */
      update(left, top, width, height) {
        let clampW = Math.max(this._minWidth, Math.min(width, this._maxWidth));
        let clampH = Math.max(this._minHeight, Math.min(height, this._maxHeight));
        if (clampW < width) {
          switch (Layout.getHorizontalAlignment(this.widget)) {
            case "left":
              break;
            case "center":
              left += (width - clampW) / 2;
              break;
            case "right":
              left += width - clampW;
              break;
            default:
              throw "unreachable";
          }
        }
        if (clampH < height) {
          switch (Layout.getVerticalAlignment(this.widget)) {
            case "top":
              break;
            case "center":
              top += (height - clampH) / 2;
              break;
            case "bottom":
              top += height - clampH;
              break;
            default:
              throw "unreachable";
          }
        }
        let resized = false;
        let style = this.widget.node.style;
        if (this._top !== top) {
          this._top = top;
          style.top = `${top}px`;
        }
        if (this._left !== left) {
          this._left = left;
          style.left = `${left}px`;
        }
        if (this._width !== clampW) {
          resized = true;
          this._width = clampW;
          style.width = `${clampW}px`;
        }
        if (this._height !== clampH) {
          resized = true;
          this._height = clampH;
          style.height = `${clampH}px`;
        }
        if (resized) {
          let msg = new Widget.ResizeMessage(clampW, clampH);
          MessageLoop.sendMessage(this.widget, msg);
        }
      }
    };
    (function(Private36) {
      Private36.horizontalAlignmentProperty = new AttachedProperty2({
        name: "horizontalAlignment",
        create: () => "center",
        changed: onAlignmentChanged
      });
      Private36.verticalAlignmentProperty = new AttachedProperty2({
        name: "verticalAlignment",
        create: () => "top",
        changed: onAlignmentChanged
      });
      function onAlignmentChanged(child) {
        if (child.parent && child.parent.layout) {
          child.parent.update();
        }
      }
    })(Private$i || (Private$i = {}));
    PanelLayout = class extends Layout {
      constructor() {
        super(...arguments);
        this._widgets = [];
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This will clear and dispose all widgets in the layout.
       *
       * All reimplementations should call the superclass method.
       *
       * This method is called automatically when the parent is disposed.
       */
      dispose() {
        while (this._widgets.length > 0) {
          this._widgets.pop().dispose();
        }
        super.dispose();
      }
      /**
       * A read-only array of the widgets in the layout.
       */
      get widgets() {
        return this._widgets;
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        yield* this._widgets;
      }
      /**
       * Add a widget to the end of the layout.
       *
       * @param widget - The widget to add to the layout.
       *
       * #### Notes
       * If the widget is already contained in the layout, it will be moved.
       */
      addWidget(widget) {
        this.insertWidget(this._widgets.length, widget);
      }
      /**
       * Insert a widget into the layout at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into the layout.
       *
       * #### Notes
       * The index will be clamped to the bounds of the widgets.
       *
       * If the widget is already added to the layout, it will be moved.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insertWidget(index, widget) {
        widget.parent = this.parent;
        let i = this._widgets.indexOf(widget);
        let j = Math.max(0, Math.min(index, this._widgets.length));
        if (i === -1) {
          ArrayExt3.insert(this._widgets, j, widget);
          if (this.parent) {
            this.attachWidget(j, widget);
          }
          return;
        }
        if (j === this._widgets.length) {
          j--;
        }
        if (i === j) {
          return;
        }
        ArrayExt3.move(this._widgets, i, j);
        if (this.parent) {
          this.moveWidget(i, j, widget);
        }
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        this.removeWidgetAt(this._widgets.indexOf(widget));
      }
      /**
       * Remove the widget at a given index from the layout.
       *
       * @param index - The index of the widget to remove.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      removeWidgetAt(index) {
        let widget = ArrayExt3.removeAt(this._widgets, index);
        if (widget && this.parent) {
          this.detachWidget(index, widget);
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        let index = 0;
        for (const widget of this) {
          this.attachWidget(index++, widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation adds the widgets's node to the parent's
       * node at the proper location, and sends the appropriate attach
       * messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is added to the parent's node.
       */
      attachWidget(index, widget) {
        let ref2 = this.parent.node.children[index];
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.insertBefore(widget.node, ref2);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation moves the widget's node to the proper
       * location in the parent's node and sends the appropriate attach and
       * detach messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is moved in the parent's node.
       */
      moveWidget(fromIndex, toIndex, widget) {
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
        let ref2 = this.parent.node.children[toIndex];
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.insertBefore(widget.node, ref2);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation removes the widget's node from the
       * parent's node, and sends the appropriate detach messages to the
       * widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is removed from the parent's node.
       */
      detachWidget(index, widget) {
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
      }
    };
    (function(Utils2) {
      function clampDimension(value) {
        return Math.max(0, Math.floor(value));
      }
      Utils2.clampDimension = clampDimension;
    })(Utils || (Utils = {}));
    Utils$1 = Utils;
    SplitLayout = class extends PanelLayout {
      /**
       * Construct a new split layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options) {
        super();
        this.widgetOffset = 0;
        this._fixed = 0;
        this._spacing = 4;
        this._dirty = false;
        this._hasNormedSizes = false;
        this._sizers = [];
        this._items = [];
        this._handles = [];
        this._box = null;
        this._alignment = "start";
        this._orientation = "horizontal";
        this.renderer = options.renderer;
        if (options.orientation !== void 0) {
          this._orientation = options.orientation;
        }
        if (options.alignment !== void 0) {
          this._alignment = options.alignment;
        }
        if (options.spacing !== void 0) {
          this._spacing = Utils.clampDimension(options.spacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._sizers.length = 0;
        this._handles.length = 0;
        super.dispose();
      }
      /**
       * Get the layout orientation for the split layout.
       */
      get orientation() {
        return this._orientation;
      }
      /**
       * Set the layout orientation for the split layout.
       */
      set orientation(value) {
        if (this._orientation === value) {
          return;
        }
        this._orientation = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["orientation"] = value;
        this.parent.fit();
      }
      /**
       * Get the content alignment for the split layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand  to fill the
       * entire split layout.
       */
      get alignment() {
        return this._alignment;
      }
      /**
       * Set the content alignment for the split layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand  to fill the
       * entire split layout.
       */
      set alignment(value) {
        if (this._alignment === value) {
          return;
        }
        this._alignment = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["alignment"] = value;
        this.parent.update();
      }
      /**
       * Get the inter-element spacing for the split layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the split layout.
       */
      set spacing(value) {
        value = Utils.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * A read-only array of the split handles in the layout.
       */
      get handles() {
        return this._handles;
      }
      /**
       * Get the absolute sizes of the widgets in the layout.
       *
       * @returns A new array of the absolute sizes of the widgets.
       *
       * This method **does not** measure the DOM nodes.
       */
      absoluteSizes() {
        return this._sizers.map((sizer) => sizer.size);
      }
      /**
       * Get the relative sizes of the widgets in the layout.
       *
       * @returns A new array of the relative sizes of the widgets.
       *
       * #### Notes
       * The returned sizes reflect the sizes of the widgets normalized
       * relative to their siblings.
       *
       * This method **does not** measure the DOM nodes.
       */
      relativeSizes() {
        return Private$h.normalize(this._sizers.map((sizer) => sizer.size));
      }
      /**
       * Set the relative sizes for the widgets in the layout.
       *
       * @param sizes - The relative sizes for the widgets in the panel.
       * @param update - Update the layout after setting relative sizes.
       * Default is True.
       *
       * #### Notes
       * Extra values are ignored, too few will yield an undefined layout.
       *
       * The actual geometry of the DOM nodes is updated asynchronously.
       */
      setRelativeSizes(sizes, update = true) {
        let n = this._sizers.length;
        let temp = sizes.slice(0, n);
        while (temp.length < n) {
          temp.push(0);
        }
        let normed = Private$h.normalize(temp);
        for (let i = 0; i < n; ++i) {
          let sizer = this._sizers[i];
          sizer.sizeHint = normed[i];
          sizer.size = normed[i];
        }
        this._hasNormedSizes = true;
        if (update && this.parent) {
          this.parent.update();
        }
      }
      /**
       * Move the offset position of a split handle.
       *
       * @param index - The index of the handle of the interest.
       *
       * @param position - The desired offset position of the handle.
       *
       * #### Notes
       * The position is relative to the offset parent.
       *
       * This will move the handle as close as possible to the desired
       * position. The sibling widgets will be adjusted as necessary.
       */
      moveHandle(index, position) {
        let handle = this._handles[index];
        if (!handle || handle.classList.contains("lm-mod-hidden")) {
          return;
        }
        let delta;
        if (this._orientation === "horizontal") {
          delta = position - handle.offsetLeft;
        } else {
          delta = position - handle.offsetTop;
        }
        if (delta === 0) {
          return;
        }
        for (let sizer of this._sizers) {
          if (sizer.size > 0) {
            sizer.sizeHint = sizer.size;
          }
        }
        BoxEngine.adjust(this._sizers, index, delta);
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        this.parent.dataset["orientation"] = this.orientation;
        this.parent.dataset["alignment"] = this.alignment;
        super.init();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index, widget) {
        let item = new LayoutItem(widget);
        let handle = Private$h.createHandle(this.renderer);
        let average = Private$h.averageSize(this._sizers);
        let sizer = Private$h.createSizer(average);
        ArrayExt3.insert(this._items, index, item);
        ArrayExt3.insert(this._sizers, index, sizer);
        ArrayExt3.insert(this._handles, index, handle);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        this.parent.node.appendChild(handle);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt3.move(this._items, fromIndex, toIndex);
        ArrayExt3.move(this._sizers, fromIndex, toIndex);
        ArrayExt3.move(this._handles, fromIndex, toIndex);
        this.parent.fit();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index, widget) {
        let item = ArrayExt3.removeAt(this._items, index);
        let handle = ArrayExt3.removeAt(this._handles, index);
        ArrayExt3.removeAt(this._sizers, index);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        this.parent.node.removeChild(handle);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Update the item position.
       *
       * @param i Item index
       * @param isHorizontal Whether the layout is horizontal or not
       * @param left Left position in pixels
       * @param top Top position in pixels
       * @param height Item height
       * @param width Item width
       * @param size Item size
       */
      updateItemPosition(i, isHorizontal, left, top, height, width, size) {
        const item = this._items[i];
        if (item.isHidden) {
          return;
        }
        let handleStyle = this._handles[i].style;
        if (isHorizontal) {
          left += this.widgetOffset;
          item.update(left, top, size, height);
          left += size;
          handleStyle.top = `${top}px`;
          handleStyle.left = `${left}px`;
          handleStyle.width = `${this._spacing}px`;
          handleStyle.height = `${height}px`;
        } else {
          top += this.widgetOffset;
          item.update(left, top, width, size);
          top += size;
          handleStyle.top = `${top}px`;
          handleStyle.left = `${left}px`;
          handleStyle.width = `${width}px`;
          handleStyle.height = `${this._spacing}px`;
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let nVisible = 0;
        let lastHandleIndex = -1;
        for (let i = 0, n = this._items.length; i < n; ++i) {
          if (this._items[i].isHidden) {
            this._handles[i].classList.add("lm-mod-hidden");
          } else {
            this._handles[i].classList.remove("lm-mod-hidden");
            lastHandleIndex = i;
            nVisible++;
          }
        }
        if (lastHandleIndex !== -1) {
          this._handles[lastHandleIndex].classList.add("lm-mod-hidden");
        }
        this._fixed = this._spacing * Math.max(0, nVisible - 1) + this.widgetOffset * this._items.length;
        let horz = this._orientation === "horizontal";
        let minW = horz ? this._fixed : 0;
        let minH = horz ? 0 : this._fixed;
        for (let i = 0, n = this._items.length; i < n; ++i) {
          let item = this._items[i];
          let sizer = this._sizers[i];
          if (sizer.size > 0) {
            sizer.sizeHint = sizer.size;
          }
          if (item.isHidden) {
            sizer.minSize = 0;
            sizer.maxSize = 0;
            continue;
          }
          item.fit();
          sizer.stretch = SplitLayout.getStretch(item.widget);
          if (horz) {
            sizer.minSize = item.minWidth;
            sizer.maxSize = item.maxWidth;
            minW += item.minWidth;
            minH = Math.max(minH, item.minHeight);
          } else {
            sizer.minSize = item.minHeight;
            sizer.maxSize = item.maxHeight;
            minH += item.minHeight;
            minW = Math.max(minW, item.minWidth);
          }
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i = 0, n = this._items.length; i < n; ++i) {
          nVisible += +!this._items[i].isHidden;
        }
        if (nVisible === 0 && this.widgetOffset === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let extra = 0;
        let offset = 0;
        let horz = this._orientation === "horizontal";
        if (nVisible > 0) {
          let space;
          if (horz) {
            space = Math.max(0, width - this._fixed);
          } else {
            space = Math.max(0, height - this._fixed);
          }
          if (this._hasNormedSizes) {
            for (let sizer of this._sizers) {
              sizer.sizeHint *= space;
            }
            this._hasNormedSizes = false;
          }
          let delta = BoxEngine.calc(this._sizers, space);
          if (delta > 0) {
            switch (this._alignment) {
              case "start":
                break;
              case "center":
                extra = 0;
                offset = delta / 2;
                break;
              case "end":
                extra = 0;
                offset = delta;
                break;
              case "justify":
                extra = delta / nVisible;
                offset = 0;
                break;
              default:
                throw "unreachable";
            }
          }
        }
        for (let i = 0, n = this._items.length; i < n; ++i) {
          const item = this._items[i];
          const size = item.isHidden ? 0 : this._sizers[i].size + extra;
          this.updateItemPosition(i, horz, horz ? left + offset : left, horz ? top : top + offset, height, width, size);
          const fullOffset = this.widgetOffset + (this._handles[i].classList.contains("lm-mod-hidden") ? 0 : this._spacing);
          if (horz) {
            left += size + fullOffset;
          } else {
            top += size + fullOffset;
          }
        }
      }
    };
    (function(SplitLayout2) {
      function getStretch(widget) {
        return Private$h.stretchProperty.get(widget);
      }
      SplitLayout2.getStretch = getStretch;
      function setStretch(widget, value) {
        Private$h.stretchProperty.set(widget, value);
      }
      SplitLayout2.setStretch = setStretch;
    })(SplitLayout || (SplitLayout = {}));
    (function(Private36) {
      Private36.stretchProperty = new AttachedProperty2({
        name: "stretch",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      function createSizer(size) {
        let sizer = new BoxSizer();
        sizer.sizeHint = Math.floor(size);
        return sizer;
      }
      Private36.createSizer = createSizer;
      function createHandle(renderer) {
        let handle = renderer.createHandle();
        handle.style.position = "absolute";
        handle.style.contain = "style";
        return handle;
      }
      Private36.createHandle = createHandle;
      function averageSize(sizers) {
        return sizers.reduce((v, s) => v + s.size, 0) / sizers.length || 0;
      }
      Private36.averageSize = averageSize;
      function normalize2(values) {
        let n = values.length;
        if (n === 0) {
          return [];
        }
        let sum = values.reduce((a, b) => a + Math.abs(b), 0);
        return sum === 0 ? values.map((v) => 1 / n) : values.map((v) => v / sum);
      }
      Private36.normalize = normalize2;
      function onChildSizingChanged(child) {
        if (child.parent && child.parent.layout instanceof SplitLayout) {
          child.parent.fit();
        }
      }
    })(Private$h || (Private$h = {}));
    AccordionLayout = class extends SplitLayout {
      /**
       * Construct a new accordion layout.
       *
       * @param options - The options for initializing the layout.
       *
       * #### Notes
       * The default orientation will be vertical.
       *
       * Titles must be rotated for horizontal accordion panel using CSS: see accordionpanel.css
       */
      constructor(options) {
        super({ ...options, orientation: options.orientation || "vertical" });
        this._titles = [];
        this.titleSpace = options.titleSpace || 22;
      }
      /**
       * The section title height or width depending on the orientation.
       */
      get titleSpace() {
        return this.widgetOffset;
      }
      set titleSpace(value) {
        value = Utils$1.clampDimension(value);
        if (this.widgetOffset === value) {
          return;
        }
        this.widgetOffset = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * A read-only array of the section titles in the panel.
       */
      get titles() {
        return this._titles;
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._titles.length = 0;
        super.dispose();
      }
      updateTitle(index, widget) {
        const oldTitle = this._titles[index];
        const expanded = oldTitle.classList.contains("lm-mod-expanded");
        const newTitle = Private$g.createTitle(this.renderer, widget.title, expanded);
        this._titles[index] = newTitle;
        this.parent.node.replaceChild(newTitle, oldTitle);
      }
      /**
       * Insert a widget into the layout at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into the layout.
       *
       * #### Notes
       * The index will be clamped to the bounds of the widgets.
       *
       * If the widget is already added to the layout, it will be moved.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insertWidget(index, widget) {
        if (!widget.id) {
          widget.id = `id-${import_coreutils7.UUID.uuid4()}`;
        }
        super.insertWidget(index, widget);
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       */
      attachWidget(index, widget) {
        const title = Private$g.createTitle(this.renderer, widget.title);
        ArrayExt3.insert(this._titles, index, title);
        this.parent.node.appendChild(title);
        widget.node.setAttribute("role", "region");
        widget.node.setAttribute("aria-labelledby", title.id);
        super.attachWidget(index, widget);
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt3.move(this._titles, fromIndex, toIndex);
        super.moveWidget(fromIndex, toIndex, widget);
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index, widget) {
        const title = ArrayExt3.removeAt(this._titles, index);
        this.parent.node.removeChild(title);
        super.detachWidget(index, widget);
      }
      /**
       * Update the item position.
       *
       * @param i Item index
       * @param isHorizontal Whether the layout is horizontal or not
       * @param left Left position in pixels
       * @param top Top position in pixels
       * @param height Item height
       * @param width Item width
       * @param size Item size
       */
      updateItemPosition(i, isHorizontal, left, top, height, width, size) {
        const titleStyle = this._titles[i].style;
        titleStyle.top = `${top}px`;
        titleStyle.left = `${left}px`;
        titleStyle.height = `${this.widgetOffset}px`;
        if (isHorizontal) {
          titleStyle.width = `${height}px`;
        } else {
          titleStyle.width = `${width}px`;
        }
        super.updateItemPosition(i, isHorizontal, left, top, height, width, size);
      }
    };
    (function(Private36) {
      function createTitle(renderer, data, expanded = true) {
        const title = renderer.createSectionTitle(data);
        title.style.position = "absolute";
        title.style.contain = "strict";
        title.setAttribute("aria-label", `${data.label} Section`);
        title.setAttribute("aria-expanded", expanded ? "true" : "false");
        title.setAttribute("aria-controls", data.owner.id);
        if (expanded) {
          title.classList.add("lm-mod-expanded");
        }
        return title;
      }
      Private36.createTitle = createTitle;
    })(Private$g || (Private$g = {}));
    Panel = class extends Widget {
      /**
       * Construct a new panel.
       *
       * @param options - The options for initializing the panel.
       */
      constructor(options = {}) {
        super();
        this.addClass("lm-Panel");
        this.layout = Private$f.createLayout(options);
      }
      /**
       * A read-only array of the widgets in the panel.
       */
      get widgets() {
        return this.layout.widgets;
      }
      /**
       * Add a widget to the end of the panel.
       *
       * @param widget - The widget to add to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      addWidget(widget) {
        this.layout.addWidget(widget);
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index, widget) {
        this.layout.insertWidget(index, widget);
      }
    };
    (function(Private36) {
      function createLayout(options) {
        return options.layout || new PanelLayout();
      }
      Private36.createLayout = createLayout;
    })(Private$f || (Private$f = {}));
    SplitPanel = class extends Panel {
      /**
       * Construct a new split panel.
       *
       * @param options - The options for initializing the split panel.
       */
      constructor(options = {}) {
        super({ layout: Private$e.createLayout(options) });
        this._handleMoved = new Signal(this);
        this._pressData = null;
        this.addClass("lm-SplitPanel");
      }
      /**
       * Dispose of the resources held by the panel.
       */
      dispose() {
        this._releaseMouse();
        super.dispose();
      }
      /**
       * Get the layout orientation for the split panel.
       */
      get orientation() {
        return this.layout.orientation;
      }
      /**
       * Set the layout orientation for the split panel.
       */
      set orientation(value) {
        this.layout.orientation = value;
      }
      /**
       * Get the content alignment for the split panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire split panel.
       */
      get alignment() {
        return this.layout.alignment;
      }
      /**
       * Set the content alignment for the split panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire split panel.
       */
      set alignment(value) {
        this.layout.alignment = value;
      }
      /**
       * Get the inter-element spacing for the split panel.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the inter-element spacing for the split panel.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * The renderer used by the split panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * A signal emitted when a split handle has moved.
       */
      get handleMoved() {
        return this._handleMoved;
      }
      /**
       * A read-only array of the split handles in the panel.
       */
      get handles() {
        return this.layout.handles;
      }
      /**
       * Get the relative sizes of the widgets in the panel.
       *
       * @returns A new array of the relative sizes of the widgets.
       *
       * #### Notes
       * The returned sizes reflect the sizes of the widgets normalized
       * relative to their siblings.
       *
       * This method **does not** measure the DOM nodes.
       */
      relativeSizes() {
        return this.layout.relativeSizes();
      }
      /**
       * Set the relative sizes for the widgets in the panel.
       *
       * @param sizes - The relative sizes for the widgets in the panel.
       * @param update - Update the layout after setting relative sizes.
       * Default is True.
       *
       * #### Notes
       * Extra values are ignored, too few will yield an undefined layout.
       *
       * The actual geometry of the DOM nodes is updated asynchronously.
       */
      setRelativeSizes(sizes, update = true) {
        this.layout.setRelativeSizes(sizes, update);
      }
      /**
       * Handle the DOM events for the split panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("pointerdown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("pointerdown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        msg.child.addClass("lm-SplitPanel-child");
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        msg.child.removeClass("lm-SplitPanel-child");
        this._releaseMouse();
      }
      /**
       * Handle the `'keydown'` event for the split panel.
       */
      _evtKeyDown(event) {
        if (this._pressData) {
          event.preventDefault();
          event.stopPropagation();
        }
        if (event.keyCode === 27) {
          this._releaseMouse();
        }
      }
      /**
       * Handle the `'pointerdown'` event for the split panel.
       */
      _evtPointerDown(event) {
        if (event.button !== 0) {
          return;
        }
        let layout = this.layout;
        let index = ArrayExt3.findFirstIndex(layout.handles, (handle2) => {
          return handle2.contains(event.target);
        });
        if (index === -1) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        document.addEventListener("pointerup", this, true);
        document.addEventListener("pointermove", this, true);
        document.addEventListener("keydown", this, true);
        document.addEventListener("contextmenu", this, true);
        let delta;
        let handle = layout.handles[index];
        let rect = handle.getBoundingClientRect();
        if (layout.orientation === "horizontal") {
          delta = event.clientX - rect.left;
        } else {
          delta = event.clientY - rect.top;
        }
        let style = window.getComputedStyle(handle);
        let override = Drag.overrideCursor(style.cursor);
        this._pressData = { index, delta, override };
      }
      /**
       * Handle the `'pointermove'` event for the split panel.
       */
      _evtPointerMove(event) {
        event.preventDefault();
        event.stopPropagation();
        let pos;
        let layout = this.layout;
        let rect = this.node.getBoundingClientRect();
        if (layout.orientation === "horizontal") {
          pos = event.clientX - rect.left - this._pressData.delta;
        } else {
          pos = event.clientY - rect.top - this._pressData.delta;
        }
        layout.moveHandle(this._pressData.index, pos);
      }
      /**
       * Handle the `'pointerup'` event for the split panel.
       */
      _evtPointerUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._releaseMouse();
      }
      /**
       * Release the mouse grab for the split panel.
       */
      _releaseMouse() {
        if (!this._pressData) {
          return;
        }
        this._pressData.override.dispose();
        this._pressData = null;
        this._handleMoved.emit();
        document.removeEventListener("keydown", this, true);
        document.removeEventListener("pointerup", this, true);
        document.removeEventListener("pointermove", this, true);
        document.removeEventListener("contextmenu", this, true);
      }
    };
    (function(SplitPanel2) {
      class Renderer {
        /**
         * Create a new handle for use with a split panel.
         *
         * @returns A new handle element for a split panel.
         */
        createHandle() {
          let handle = document.createElement("div");
          handle.className = "lm-SplitPanel-handle";
          return handle;
        }
      }
      SplitPanel2.Renderer = Renderer;
      SplitPanel2.defaultRenderer = new Renderer();
      function getStretch(widget) {
        return SplitLayout.getStretch(widget);
      }
      SplitPanel2.getStretch = getStretch;
      function setStretch(widget, value) {
        SplitLayout.setStretch(widget, value);
      }
      SplitPanel2.setStretch = setStretch;
    })(SplitPanel || (SplitPanel = {}));
    (function(Private36) {
      function createLayout(options) {
        return options.layout || new SplitLayout({
          renderer: options.renderer || SplitPanel.defaultRenderer,
          orientation: options.orientation,
          alignment: options.alignment,
          spacing: options.spacing
        });
      }
      Private36.createLayout = createLayout;
    })(Private$e || (Private$e = {}));
    AccordionPanel = class extends SplitPanel {
      /**
       * Construct a new accordion panel.
       *
       * @param options - The options for initializing the accordion panel.
       */
      constructor(options = {}) {
        super({ ...options, layout: Private$d.createLayout(options) });
        this._widgetSizesCache = /* @__PURE__ */ new WeakMap();
        this._expansionToggled = new Signal(this);
        this.addClass("lm-AccordionPanel");
      }
      /**
       * The renderer used by the accordion panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * The section title space.
       *
       * This is the height if the panel is vertical and the width if it is
       * horizontal.
       */
      get titleSpace() {
        return this.layout.titleSpace;
      }
      set titleSpace(value) {
        this.layout.titleSpace = value;
      }
      /**
       * A read-only array of the section titles in the panel.
       */
      get titles() {
        return this.layout.titles;
      }
      /**
       * A signal emitted when a widget of the AccordionPanel is collapsed or expanded.
       */
      get expansionToggled() {
        return this._expansionToggled;
      }
      /**
       * Add a widget to the end of the panel.
       *
       * @param widget - The widget to add to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      addWidget(widget) {
        super.addWidget(widget);
        widget.title.changed.connect(this._onTitleChanged, this);
      }
      /**
       * Collapse the widget at position `index`.
       *
       * #### Notes
       * If no widget is found for `index`, this will bail.
       *
       * @param index Widget index
       */
      collapse(index) {
        const widget = this.layout.widgets[index];
        if (widget && !widget.isHidden) {
          this._toggleExpansion(index);
        }
      }
      /**
       * Expand the widget at position `index`.
       *
       * #### Notes
       * If no widget is found for `index`, this will bail.
       *
       * @param index Widget index
       */
      expand(index) {
        const widget = this.layout.widgets[index];
        if (widget && widget.isHidden) {
          this._toggleExpansion(index);
        }
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index, widget) {
        super.insertWidget(index, widget);
        widget.title.changed.connect(this._onTitleChanged, this);
      }
      /**
       * Handle the DOM events for the accordion panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        super.handleEvent(event);
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          case "keydown":
            this._eventKeyDown(event);
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("click", this);
        this.node.addEventListener("keydown", this);
        super.onBeforeAttach(msg);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        super.onAfterDetach(msg);
        this.node.removeEventListener("click", this);
        this.node.removeEventListener("keydown", this);
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        const index = ArrayExt3.findFirstIndex(this.widgets, (widget) => {
          return widget.contains(sender.owner);
        });
        if (index >= 0) {
          this.layout.updateTitle(index, sender.owner);
          this.update();
        }
      }
      /**
       * Compute the size of widgets in this panel on the title click event.
       * On closing, the size of the widget is cached and we will try to expand
       * the last opened widget.
       * On opening, we will use the cached size if it is available to restore the
       * widget.
       * In both cases, if we can not compute the size of widgets, we will let
       * `SplitLayout` decide.
       *
       * @param index - The index of widget to be opened of closed
       *
       * @returns Relative size of widgets in this panel, if this size can
       * not be computed, return `undefined`
       */
      _computeWidgetSize(index) {
        const layout = this.layout;
        const widget = layout.widgets[index];
        if (!widget) {
          return void 0;
        }
        const isHidden3 = widget.isHidden;
        const widgetSizes = layout.absoluteSizes();
        const delta = (isHidden3 ? -1 : 1) * this.spacing;
        const totalSize = widgetSizes.reduce((prev, curr) => prev + curr);
        let newSize = [...widgetSizes];
        if (!isHidden3) {
          const currentSize = widgetSizes[index];
          this._widgetSizesCache.set(widget, currentSize);
          newSize[index] = 0;
          const widgetToCollapse = newSize.map((sz) => sz > 0).lastIndexOf(true);
          if (widgetToCollapse === -1) {
            return void 0;
          }
          newSize[widgetToCollapse] = widgetSizes[widgetToCollapse] + currentSize + delta;
        } else {
          const previousSize = this._widgetSizesCache.get(widget);
          if (!previousSize) {
            return void 0;
          }
          newSize[index] += previousSize;
          const widgetToCollapse = newSize.map((sz) => sz - previousSize > 0).lastIndexOf(true);
          if (widgetToCollapse === -1) {
            newSize.forEach((_, idx) => {
              if (idx !== index) {
                newSize[idx] -= widgetSizes[idx] / totalSize * (previousSize - delta);
              }
            });
          } else {
            newSize[widgetToCollapse] -= previousSize - delta;
          }
        }
        return newSize.map((sz) => sz / (totalSize + delta));
      }
      /**
       * Handle the `'click'` event for the accordion panel
       */
      _evtClick(event) {
        const target2 = event.target;
        if (target2) {
          const index = ArrayExt3.findFirstIndex(this.titles, (title) => {
            return title.contains(target2);
          });
          if (index >= 0) {
            event.preventDefault();
            event.stopPropagation();
            this._toggleExpansion(index);
          }
        }
      }
      /**
       * Handle the `'keydown'` event for the accordion panel.
       */
      _eventKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        const target2 = event.target;
        let handled = false;
        if (target2) {
          const index = ArrayExt3.findFirstIndex(this.titles, (title) => {
            return title.contains(target2);
          });
          if (index >= 0) {
            const keyCode = event.keyCode.toString();
            if (event.key.match(/Space|Enter/) || keyCode.match(/13|32/)) {
              target2.click();
              handled = true;
            } else if (this.orientation === "horizontal" ? event.key.match(/ArrowLeft|ArrowRight/) || keyCode.match(/37|39/) : event.key.match(/ArrowUp|ArrowDown/) || keyCode.match(/38|40/)) {
              const direction2 = event.key.match(/ArrowLeft|ArrowUp/) || keyCode.match(/37|38/) ? -1 : 1;
              const length = this.titles.length;
              const newIndex = (index + length + direction2) % length;
              this.titles[newIndex].focus();
              handled = true;
            } else if (event.key === "End" || keyCode === "35") {
              this.titles[this.titles.length - 1].focus();
              handled = true;
            } else if (event.key === "Home" || keyCode === "36") {
              this.titles[0].focus();
              handled = true;
            }
          }
          if (handled) {
            event.preventDefault();
          }
        }
      }
      _toggleExpansion(index) {
        const title = this.titles[index];
        const widget = this.layout.widgets[index];
        const newSize = this._computeWidgetSize(index);
        if (newSize) {
          this.setRelativeSizes(newSize, false);
        }
        if (widget.isHidden) {
          title.classList.add("lm-mod-expanded");
          title.setAttribute("aria-expanded", "true");
          widget.show();
        } else {
          title.classList.remove("lm-mod-expanded");
          title.setAttribute("aria-expanded", "false");
          widget.hide();
        }
        this._expansionToggled.emit(index);
      }
    };
    (function(AccordionPanel2) {
      class Renderer extends SplitPanel.Renderer {
        constructor() {
          super();
          this.titleClassName = "lm-AccordionPanel-title";
          this._titleID = 0;
          this._titleKeys = /* @__PURE__ */ new WeakMap();
          this._uuid = ++Renderer._nInstance;
        }
        /**
         * Render the collapse indicator for a section title.
         *
         * @param data - The data to use for rendering the section title.
         *
         * @returns A element representing the collapse indicator.
         */
        createCollapseIcon(data) {
          return document.createElement("span");
        }
        /**
         * Render the element for a section title.
         *
         * @param data - The data to use for rendering the section title.
         *
         * @returns A element representing the section title.
         */
        createSectionTitle(data) {
          const handle = document.createElement("h3");
          handle.setAttribute("tabindex", "0");
          handle.id = this.createTitleKey(data);
          handle.className = this.titleClassName;
          for (const aData in data.dataset) {
            handle.dataset[aData] = data.dataset[aData];
          }
          const collapser = handle.appendChild(this.createCollapseIcon(data));
          collapser.className = "lm-AccordionPanel-titleCollapser";
          const label = handle.appendChild(document.createElement("span"));
          label.className = "lm-AccordionPanel-titleLabel";
          label.textContent = data.label;
          label.title = data.caption || data.label;
          return handle;
        }
        /**
         * Create a unique render key for the title.
         *
         * @param data - The data to use for the title.
         *
         * @returns The unique render key for the title.
         *
         * #### Notes
         * This method caches the key against the section title the first time
         * the key is generated.
         */
        createTitleKey(data) {
          let key2 = this._titleKeys.get(data);
          if (key2 === void 0) {
            key2 = `title-key-${this._uuid}-${this._titleID++}`;
            this._titleKeys.set(data, key2);
          }
          return key2;
        }
      }
      Renderer._nInstance = 0;
      AccordionPanel2.Renderer = Renderer;
      AccordionPanel2.defaultRenderer = new Renderer();
    })(AccordionPanel || (AccordionPanel = {}));
    (function(Private36) {
      function createLayout(options) {
        return options.layout || new AccordionLayout({
          renderer: options.renderer || AccordionPanel.defaultRenderer,
          orientation: options.orientation,
          alignment: options.alignment,
          spacing: options.spacing,
          titleSpace: options.titleSpace
        });
      }
      Private36.createLayout = createLayout;
    })(Private$d || (Private$d = {}));
    BoxLayout = class extends PanelLayout {
      /**
       * Construct a new box layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        super();
        this._fixed = 0;
        this._spacing = 4;
        this._dirty = false;
        this._sizers = [];
        this._items = [];
        this._box = null;
        this._alignment = "start";
        this._direction = "top-to-bottom";
        if (options.direction !== void 0) {
          this._direction = options.direction;
        }
        if (options.alignment !== void 0) {
          this._alignment = options.alignment;
        }
        if (options.spacing !== void 0) {
          this._spacing = Utils$1.clampDimension(options.spacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._sizers.length = 0;
        super.dispose();
      }
      /**
       * Get the layout direction for the box layout.
       */
      get direction() {
        return this._direction;
      }
      /**
       * Set the layout direction for the box layout.
       */
      set direction(value) {
        if (this._direction === value) {
          return;
        }
        this._direction = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["direction"] = value;
        this.parent.fit();
      }
      /**
       * Get the content alignment for the box layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      get alignment() {
        return this._alignment;
      }
      /**
       * Set the content alignment for the box layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      set alignment(value) {
        if (this._alignment === value) {
          return;
        }
        this._alignment = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["alignment"] = value;
        this.parent.update();
      }
      /**
       * Get the inter-element spacing for the box layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the box layout.
       */
      set spacing(value) {
        value = Utils$1.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        this.parent.dataset["direction"] = this.direction;
        this.parent.dataset["alignment"] = this.alignment;
        super.init();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index, widget) {
        ArrayExt3.insert(this._items, index, new LayoutItem(widget));
        ArrayExt3.insert(this._sizers, index, new BoxSizer());
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt3.move(this._items, fromIndex, toIndex);
        ArrayExt3.move(this._sizers, fromIndex, toIndex);
        this.parent.update();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index, widget) {
        let item = ArrayExt3.removeAt(this._items, index);
        ArrayExt3.removeAt(this._sizers, index);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let nVisible = 0;
        for (let i = 0, n = this._items.length; i < n; ++i) {
          nVisible += +!this._items[i].isHidden;
        }
        this._fixed = this._spacing * Math.max(0, nVisible - 1);
        let horz = Private$c.isHorizontal(this._direction);
        let minW = horz ? this._fixed : 0;
        let minH = horz ? 0 : this._fixed;
        for (let i = 0, n = this._items.length; i < n; ++i) {
          let item = this._items[i];
          let sizer = this._sizers[i];
          if (item.isHidden) {
            sizer.minSize = 0;
            sizer.maxSize = 0;
            continue;
          }
          item.fit();
          sizer.sizeHint = BoxLayout.getSizeBasis(item.widget);
          sizer.stretch = BoxLayout.getStretch(item.widget);
          if (horz) {
            sizer.minSize = item.minWidth;
            sizer.maxSize = item.maxWidth;
            minW += item.minWidth;
            minH = Math.max(minH, item.minHeight);
          } else {
            sizer.minSize = item.minHeight;
            sizer.maxSize = item.maxHeight;
            minH += item.minHeight;
            minW = Math.max(minW, item.minWidth);
          }
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i = 0, n = this._items.length; i < n; ++i) {
          nVisible += +!this._items[i].isHidden;
        }
        if (nVisible === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let delta;
        switch (this._direction) {
          case "left-to-right":
            delta = BoxEngine.calc(this._sizers, Math.max(0, width - this._fixed));
            break;
          case "top-to-bottom":
            delta = BoxEngine.calc(this._sizers, Math.max(0, height - this._fixed));
            break;
          case "right-to-left":
            delta = BoxEngine.calc(this._sizers, Math.max(0, width - this._fixed));
            left += width;
            break;
          case "bottom-to-top":
            delta = BoxEngine.calc(this._sizers, Math.max(0, height - this._fixed));
            top += height;
            break;
          default:
            throw "unreachable";
        }
        let extra = 0;
        let offset = 0;
        if (delta > 0) {
          switch (this._alignment) {
            case "start":
              break;
            case "center":
              extra = 0;
              offset = delta / 2;
              break;
            case "end":
              extra = 0;
              offset = delta;
              break;
            case "justify":
              extra = delta / nVisible;
              offset = 0;
              break;
            default:
              throw "unreachable";
          }
        }
        for (let i = 0, n = this._items.length; i < n; ++i) {
          let item = this._items[i];
          if (item.isHidden) {
            continue;
          }
          let size = this._sizers[i].size;
          switch (this._direction) {
            case "left-to-right":
              item.update(left + offset, top, size + extra, height);
              left += size + extra + this._spacing;
              break;
            case "top-to-bottom":
              item.update(left, top + offset, width, size + extra);
              top += size + extra + this._spacing;
              break;
            case "right-to-left":
              item.update(left - offset - size - extra, top, size + extra, height);
              left -= size + extra + this._spacing;
              break;
            case "bottom-to-top":
              item.update(left, top - offset - size - extra, width, size + extra);
              top -= size + extra + this._spacing;
              break;
            default:
              throw "unreachable";
          }
        }
      }
    };
    (function(BoxLayout2) {
      function getStretch(widget) {
        return Private$c.stretchProperty.get(widget);
      }
      BoxLayout2.getStretch = getStretch;
      function setStretch(widget, value) {
        Private$c.stretchProperty.set(widget, value);
      }
      BoxLayout2.setStretch = setStretch;
      function getSizeBasis(widget) {
        return Private$c.sizeBasisProperty.get(widget);
      }
      BoxLayout2.getSizeBasis = getSizeBasis;
      function setSizeBasis(widget, value) {
        Private$c.sizeBasisProperty.set(widget, value);
      }
      BoxLayout2.setSizeBasis = setSizeBasis;
    })(BoxLayout || (BoxLayout = {}));
    (function(Private36) {
      Private36.stretchProperty = new AttachedProperty2({
        name: "stretch",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      Private36.sizeBasisProperty = new AttachedProperty2({
        name: "sizeBasis",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      function isHorizontal(dir) {
        return dir === "left-to-right" || dir === "right-to-left";
      }
      Private36.isHorizontal = isHorizontal;
      function clampSpacing(value) {
        return Math.max(0, Math.floor(value));
      }
      Private36.clampSpacing = clampSpacing;
      function onChildSizingChanged(child) {
        if (child.parent && child.parent.layout instanceof BoxLayout) {
          child.parent.fit();
        }
      }
    })(Private$c || (Private$c = {}));
    BoxPanel = class extends Panel {
      /**
       * Construct a new box panel.
       *
       * @param options - The options for initializing the box panel.
       */
      constructor(options = {}) {
        super({ layout: Private$b.createLayout(options) });
        this.addClass("lm-BoxPanel");
      }
      /**
       * Get the layout direction for the box panel.
       */
      get direction() {
        return this.layout.direction;
      }
      /**
       * Set the layout direction for the box panel.
       */
      set direction(value) {
        this.layout.direction = value;
      }
      /**
       * Get the content alignment for the box panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      get alignment() {
        return this.layout.alignment;
      }
      /**
       * Set the content alignment for the box panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      set alignment(value) {
        this.layout.alignment = value;
      }
      /**
       * Get the inter-element spacing for the box panel.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the inter-element spacing for the box panel.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        msg.child.addClass("lm-BoxPanel-child");
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        msg.child.removeClass("lm-BoxPanel-child");
      }
    };
    (function(BoxPanel2) {
      function getStretch(widget) {
        return BoxLayout.getStretch(widget);
      }
      BoxPanel2.getStretch = getStretch;
      function setStretch(widget, value) {
        BoxLayout.setStretch(widget, value);
      }
      BoxPanel2.setStretch = setStretch;
      function getSizeBasis(widget) {
        return BoxLayout.getSizeBasis(widget);
      }
      BoxPanel2.getSizeBasis = getSizeBasis;
      function setSizeBasis(widget, value) {
        BoxLayout.setSizeBasis(widget, value);
      }
      BoxPanel2.setSizeBasis = setSizeBasis;
    })(BoxPanel || (BoxPanel = {}));
    (function(Private36) {
      function createLayout(options) {
        return options.layout || new BoxLayout(options);
      }
      Private36.createLayout = createLayout;
    })(Private$b || (Private$b = {}));
    CommandPalette = class extends Widget {
      /**
       * Construct a new command palette.
       *
       * @param options - The options for initializing the palette.
       */
      constructor(options) {
        super({ node: Private$a.createNode() });
        this._activeIndex = -1;
        this._items = [];
        this._results = null;
        this.addClass("lm-CommandPalette");
        this.setFlag(Widget.Flag.DisallowLayout);
        this.commands = options.commands;
        this.renderer = options.renderer || CommandPalette.defaultRenderer;
        this.commands.commandChanged.connect(this._onGenericChange, this);
        this.commands.keyBindingChanged.connect(this._onGenericChange, this);
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._items.length = 0;
        this._results = null;
        super.dispose();
      }
      /**
       * The command palette search node.
       *
       * #### Notes
       * This is the node which contains the search-related elements.
       */
      get searchNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-search")[0];
      }
      /**
       * The command palette input node.
       *
       * #### Notes
       * This is the actual input node for the search area.
       */
      get inputNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-input")[0];
      }
      /**
       * The command palette content node.
       *
       * #### Notes
       * This is the node which holds the command item nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-content")[0];
      }
      /**
       * A read-only array of the command items in the palette.
       */
      get items() {
        return this._items;
      }
      /**
       * Add a command item to the command palette.
       *
       * @param options - The options for creating the command item.
       *
       * @returns The command item added to the palette.
       */
      addItem(options) {
        let item = Private$a.createItem(this.commands, options);
        this._items.push(item);
        this.refresh();
        return item;
      }
      /**
       * Adds command items to the command palette.
       *
       * @param items - An array of options for creating each command item.
       *
       * @returns The command items added to the palette.
       */
      addItems(items) {
        const newItems = items.map((item) => Private$a.createItem(this.commands, item));
        newItems.forEach((item) => this._items.push(item));
        this.refresh();
        return newItems;
      }
      /**
       * Remove an item from the command palette.
       *
       * @param item - The item to remove from the palette.
       *
       * #### Notes
       * This is a no-op if the item is not in the palette.
       */
      removeItem(item) {
        this.removeItemAt(this._items.indexOf(item));
      }
      /**
       * Remove the item at a given index from the command palette.
       *
       * @param index - The index of the item to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeItemAt(index) {
        let item = ArrayExt3.removeAt(this._items, index);
        if (!item) {
          return;
        }
        this.refresh();
      }
      /**
       * Remove all items from the command palette.
       */
      clearItems() {
        if (this._items.length === 0) {
          return;
        }
        this._items.length = 0;
        this.refresh();
      }
      /**
       * Clear the search results and schedule an update.
       *
       * #### Notes
       * This should be called whenever the search results of the palette
       * should be updated.
       *
       * This is typically called automatically by the palette as needed,
       * but can be called manually if the input text is programatically
       * changed.
       *
       * The rendered results are updated asynchronously.
       */
      refresh() {
        this._results = null;
        if (this.inputNode.value !== "") {
          let clear = this.node.getElementsByClassName("lm-close-icon")[0];
          clear.style.display = "inherit";
        } else {
          let clear = this.node.getElementsByClassName("lm-close-icon")[0];
          clear.style.display = "none";
        }
        this.update();
      }
      /**
       * Handle the DOM events for the command palette.
       *
       * @param event - The DOM event sent to the command palette.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the command palette's DOM node.
       * It should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "input":
            this.refresh();
            break;
          case "focus":
          case "blur":
            this._toggleFocused();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("click", this);
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("input", this);
        this.node.addEventListener("focus", this, true);
        this.node.addEventListener("blur", this, true);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("click", this);
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("input", this);
        this.node.removeEventListener("focus", this, true);
        this.node.removeEventListener("blur", this, true);
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       */
      onAfterShow(msg) {
        this.update();
        super.onAfterShow(msg);
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          let input = this.inputNode;
          input.focus();
          input.select();
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.isHidden) {
          return;
        }
        let query = this.inputNode.value;
        let contentNode = this.contentNode;
        let results = this._results;
        if (!results) {
          results = this._results = Private$a.search(this._items, query);
          this._activeIndex = query ? ArrayExt3.findFirstIndex(results, Private$a.canActivate) : -1;
        }
        if (!query && results.length === 0) {
          VirtualDOM.render(null, contentNode);
          return;
        }
        if (query && results.length === 0) {
          let content2 = this.renderer.renderEmptyMessage({ query });
          VirtualDOM.render(content2, contentNode);
          return;
        }
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let content = new Array(results.length);
        for (let i = 0, n = results.length; i < n; ++i) {
          let result = results[i];
          if (result.type === "header") {
            let indices = result.indices;
            let category = result.category;
            content[i] = renderer.renderHeader({ category, indices });
          } else {
            let item = result.item;
            let indices = result.indices;
            let active = i === activeIndex;
            content[i] = renderer.renderItem({ item, indices, active });
          }
        }
        VirtualDOM.render(content, contentNode);
        if (activeIndex < 0 || activeIndex >= results.length) {
          contentNode.scrollTop = 0;
        } else {
          let element = contentNode.children[activeIndex];
          ElementExt.scrollIntoViewIfNeeded(contentNode, element);
        }
      }
      /**
       * Handle the `'click'` event for the command palette.
       */
      _evtClick(event) {
        if (event.button !== 0) {
          return;
        }
        if (event.target.classList.contains("lm-close-icon")) {
          this.inputNode.value = "";
          this.refresh();
          return;
        }
        let index = ArrayExt3.findFirstIndex(this.contentNode.children, (node) => {
          return node.contains(event.target);
        });
        if (index === -1) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._execute(index);
      }
      /**
       * Handle the `'keydown'` event for the command palette.
       */
      _evtKeyDown(event) {
        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
          return;
        }
        switch (event.keyCode) {
          case 13:
            event.preventDefault();
            event.stopPropagation();
            this._execute(this._activeIndex);
            break;
          case 38:
            event.preventDefault();
            event.stopPropagation();
            this._activatePreviousItem();
            break;
          case 40:
            event.preventDefault();
            event.stopPropagation();
            this._activateNextItem();
            break;
        }
      }
      /**
       * Activate the next enabled command item.
       */
      _activateNextItem() {
        if (!this._results || this._results.length === 0) {
          return;
        }
        let ai = this._activeIndex;
        let n = this._results.length;
        let start = ai < n - 1 ? ai + 1 : 0;
        let stop = start === 0 ? n - 1 : start - 1;
        this._activeIndex = ArrayExt3.findFirstIndex(this._results, Private$a.canActivate, start, stop);
        this.update();
      }
      /**
       * Activate the previous enabled command item.
       */
      _activatePreviousItem() {
        if (!this._results || this._results.length === 0) {
          return;
        }
        let ai = this._activeIndex;
        let n = this._results.length;
        let start = ai <= 0 ? n - 1 : ai - 1;
        let stop = start === n - 1 ? 0 : start + 1;
        this._activeIndex = ArrayExt3.findLastIndex(this._results, Private$a.canActivate, start, stop);
        this.update();
      }
      /**
       * Execute the command item at the given index, if possible.
       */
      _execute(index) {
        if (!this._results) {
          return;
        }
        let part = this._results[index];
        if (!part) {
          return;
        }
        if (part.type === "header") {
          let input = this.inputNode;
          input.value = `${part.category.toLowerCase()} `;
          input.focus();
          this.refresh();
          return;
        }
        if (!part.item.isEnabled) {
          return;
        }
        this.commands.execute(part.item.command, part.item.args);
        this.inputNode.value = "";
        this.refresh();
      }
      /**
       * Toggle the focused modifier based on the input node focus state.
       */
      _toggleFocused() {
        let focused = document.activeElement === this.inputNode;
        this.toggleClass("lm-mod-focused", focused);
      }
      /**
       * A signal handler for generic command changes.
       */
      _onGenericChange() {
        this.refresh();
      }
    };
    (function(CommandPalette2) {
      class Renderer {
        /**
         * Render the virtual element for a command palette header.
         *
         * @param data - The data to use for rendering the header.
         *
         * @returns A virtual element representing the header.
         */
        renderHeader(data) {
          let content = this.formatHeader(data);
          return h.li({ className: "lm-CommandPalette-header" }, content);
        }
        /**
         * Render the virtual element for a command palette item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          if (data.item.isToggleable) {
            return h.li({
              className,
              dataset,
              role: "menuitemcheckbox",
              "aria-checked": `${data.item.isToggled}`
            }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));
          }
          return h.li({
            className,
            dataset,
            role: "menuitem"
          }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));
        }
        /**
         * Render the empty results message for a command palette.
         *
         * @param data - The data to use for rendering the message.
         *
         * @returns A virtual element representing the message.
         */
        renderEmptyMessage(data) {
          let content = this.formatEmptyMessage(data);
          return h.li({ className: "lm-CommandPalette-emptyMessage" }, content);
        }
        /**
         * Render the icon for a command palette item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the icon.
         */
        renderItemIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Render the content for a command palette item.
         *
         * @param data - The data to use for rendering the content.
         *
         * @returns A virtual element representing the content.
         */
        renderItemContent(data) {
          return h.div({ className: "lm-CommandPalette-itemContent" }, this.renderItemLabel(data), this.renderItemCaption(data));
        }
        /**
         * Render the label for a command palette item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the label.
         */
        renderItemLabel(data) {
          let content = this.formatItemLabel(data);
          return h.div({ className: "lm-CommandPalette-itemLabel" }, content);
        }
        /**
         * Render the caption for a command palette item.
         *
         * @param data - The data to use for rendering the caption.
         *
         * @returns A virtual element representing the caption.
         */
        renderItemCaption(data) {
          let content = this.formatItemCaption(data);
          return h.div({ className: "lm-CommandPalette-itemCaption" }, content);
        }
        /**
         * Render the shortcut for a command palette item.
         *
         * @param data - The data to use for rendering the shortcut.
         *
         * @returns A virtual element representing the shortcut.
         */
        renderItemShortcut(data) {
          let content = this.formatItemShortcut(data);
          return h.div({ className: "lm-CommandPalette-itemShortcut" }, content);
        }
        /**
         * Create the class name for the command palette item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the command palette item.
         */
        createItemClass(data) {
          let name2 = "lm-CommandPalette-item";
          if (!data.item.isEnabled) {
            name2 += " lm-mod-disabled";
          }
          if (data.item.isToggled) {
            name2 += " lm-mod-toggled";
          }
          if (data.active) {
            name2 += " lm-mod-active";
          }
          let extra = data.item.className;
          if (extra) {
            name2 += ` ${extra}`;
          }
          return name2;
        }
        /**
         * Create the dataset for the command palette item.
         *
         * @param data - The data to use for creating the dataset.
         *
         * @returns The dataset for the command palette item.
         */
        createItemDataset(data) {
          return { ...data.item.dataset, command: data.item.command };
        }
        /**
         * Create the class name for the command item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name2 = "lm-CommandPalette-itemIcon";
          let extra = data.item.iconClass;
          return extra ? `${name2} ${extra}` : name2;
        }
        /**
         * Create the render content for the header node.
         *
         * @param data - The data to use for the header content.
         *
         * @returns The content to add to the header node.
         */
        formatHeader(data) {
          if (!data.indices || data.indices.length === 0) {
            return data.category;
          }
          return StringExt3.highlight(data.category, data.indices, h.mark);
        }
        /**
         * Create the render content for the empty message node.
         *
         * @param data - The data to use for the empty message content.
         *
         * @returns The content to add to the empty message node.
         */
        formatEmptyMessage(data) {
          return `No commands found that match '${data.query}'`;
        }
        /**
         * Create the render content for the item shortcut node.
         *
         * @param data - The data to use for the shortcut content.
         *
         * @returns The content to add to the shortcut node.
         */
        formatItemShortcut(data) {
          let kb = data.item.keyBinding;
          return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;
        }
        /**
         * Create the render content for the item label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatItemLabel(data) {
          if (!data.indices || data.indices.length === 0) {
            return data.item.label;
          }
          return StringExt3.highlight(data.item.label, data.indices, h.mark);
        }
        /**
         * Create the render content for the item caption node.
         *
         * @param data - The data to use for the caption content.
         *
         * @returns The content to add to the caption node.
         */
        formatItemCaption(data) {
          return data.item.caption;
        }
      }
      CommandPalette2.Renderer = Renderer;
      CommandPalette2.defaultRenderer = new Renderer();
    })(CommandPalette || (CommandPalette = {}));
    (function(Private36) {
      function createNode() {
        let node = document.createElement("div");
        let search2 = document.createElement("div");
        let wrapper = document.createElement("div");
        let input = document.createElement("input");
        let content = document.createElement("ul");
        let clear = document.createElement("button");
        search2.className = "lm-CommandPalette-search";
        wrapper.className = "lm-CommandPalette-wrapper";
        input.className = "lm-CommandPalette-input";
        clear.className = "lm-close-icon";
        content.className = "lm-CommandPalette-content";
        content.setAttribute("role", "menu");
        input.spellcheck = false;
        wrapper.appendChild(input);
        wrapper.appendChild(clear);
        search2.appendChild(wrapper);
        node.appendChild(search2);
        node.appendChild(content);
        return node;
      }
      Private36.createNode = createNode;
      function createItem(commands, options) {
        return new CommandItem(commands, options);
      }
      Private36.createItem = createItem;
      function search(items, query) {
        let scores = matchItems(items, query);
        scores.sort(scoreCmp);
        return createResults(scores);
      }
      Private36.search = search;
      function canActivate(result) {
        return result.type === "item" && result.item.isEnabled;
      }
      Private36.canActivate = canActivate;
      function normalizeCategory(category) {
        return category.trim().replace(/\s+/g, " ");
      }
      function normalizeQuery(text) {
        return text.replace(/\s+/g, "").toLowerCase();
      }
      function matchItems(items, query) {
        query = normalizeQuery(query);
        let scores = [];
        for (let i = 0, n = items.length; i < n; ++i) {
          let item = items[i];
          if (!item.isVisible) {
            continue;
          }
          if (!query) {
            scores.push({
              matchType: 3,
              categoryIndices: null,
              labelIndices: null,
              score: 0,
              item
            });
            continue;
          }
          let score = fuzzySearch(item, query);
          if (!score) {
            continue;
          }
          if (!item.isEnabled) {
            score.score += 1e3;
          }
          scores.push(score);
        }
        return scores;
      }
      function fuzzySearch(item, query) {
        let category = item.category.toLowerCase();
        let label = item.label.toLowerCase();
        let source = `${category} ${label}`;
        let score = Infinity;
        let indices = null;
        let rgx = /\b\w/g;
        while (true) {
          let rgxMatch = rgx.exec(source);
          if (!rgxMatch) {
            break;
          }
          let match = StringExt3.matchSumOfDeltas(source, query, rgxMatch.index);
          if (!match) {
            break;
          }
          if (match.score <= score) {
            score = match.score;
            indices = match.indices;
          }
        }
        if (!indices || score === Infinity) {
          return null;
        }
        let pivot = category.length + 1;
        let j = ArrayExt3.lowerBound(indices, pivot, (a, b) => a - b);
        let categoryIndices = indices.slice(0, j);
        let labelIndices = indices.slice(j);
        for (let i = 0, n = labelIndices.length; i < n; ++i) {
          labelIndices[i] -= pivot;
        }
        if (categoryIndices.length === 0) {
          return {
            matchType: 0,
            categoryIndices: null,
            labelIndices,
            score,
            item
          };
        }
        if (labelIndices.length === 0) {
          return {
            matchType: 1,
            categoryIndices,
            labelIndices: null,
            score,
            item
          };
        }
        return {
          matchType: 2,
          categoryIndices,
          labelIndices,
          score,
          item
        };
      }
      function scoreCmp(a, b) {
        let m1 = a.matchType - b.matchType;
        if (m1 !== 0) {
          return m1;
        }
        let d1 = a.score - b.score;
        if (d1 !== 0) {
          return d1;
        }
        let i1 = 0;
        let i2 = 0;
        switch (a.matchType) {
          case 0:
            i1 = a.labelIndices[0];
            i2 = b.labelIndices[0];
            break;
          case 1:
          case 2:
            i1 = a.categoryIndices[0];
            i2 = b.categoryIndices[0];
            break;
        }
        if (i1 !== i2) {
          return i1 - i2;
        }
        let d2 = a.item.category.localeCompare(b.item.category);
        if (d2 !== 0) {
          return d2;
        }
        let r1 = a.item.rank;
        let r2 = b.item.rank;
        if (r1 !== r2) {
          return r1 < r2 ? -1 : 1;
        }
        return a.item.label.localeCompare(b.item.label);
      }
      function createResults(scores) {
        let visited = new Array(scores.length);
        ArrayExt3.fill(visited, false);
        let results = [];
        for (let i = 0, n = scores.length; i < n; ++i) {
          if (visited[i]) {
            continue;
          }
          let { item, categoryIndices } = scores[i];
          let category = item.category;
          results.push({ type: "header", category, indices: categoryIndices });
          for (let j = i; j < n; ++j) {
            if (visited[j]) {
              continue;
            }
            let { item: item2, labelIndices } = scores[j];
            if (item2.category !== category) {
              continue;
            }
            results.push({ type: "item", item: item2, indices: labelIndices });
            visited[j] = true;
          }
        }
        return results;
      }
      class CommandItem {
        /**
         * Construct a new command item.
         */
        constructor(commands, options) {
          this._commands = commands;
          this.category = normalizeCategory(options.category);
          this.command = options.command;
          this.args = options.args || import_coreutils7.JSONExt.emptyObject;
          this.rank = options.rank !== void 0 ? options.rank : Infinity;
        }
        /**
         * The display label for the command item.
         */
        get label() {
          return this._commands.label(this.command, this.args);
        }
        /**
         * The icon renderer for the command item.
         */
        get icon() {
          return this._commands.icon(this.command, this.args);
        }
        /**
         * The icon class for the command item.
         */
        get iconClass() {
          return this._commands.iconClass(this.command, this.args);
        }
        /**
         * The icon label for the command item.
         */
        get iconLabel() {
          return this._commands.iconLabel(this.command, this.args);
        }
        /**
         * The display caption for the command item.
         */
        get caption() {
          return this._commands.caption(this.command, this.args);
        }
        /**
         * The extra class name for the command item.
         */
        get className() {
          return this._commands.className(this.command, this.args);
        }
        /**
         * The dataset for the command item.
         */
        get dataset() {
          return this._commands.dataset(this.command, this.args);
        }
        /**
         * Whether the command item is enabled.
         */
        get isEnabled() {
          return this._commands.isEnabled(this.command, this.args);
        }
        /**
         * Whether the command item is toggled.
         */
        get isToggled() {
          return this._commands.isToggled(this.command, this.args);
        }
        /**
         * Whether the command item is toggleable.
         */
        get isToggleable() {
          return this._commands.isToggleable(this.command, this.args);
        }
        /**
         * Whether the command item is visible.
         */
        get isVisible() {
          return this._commands.isVisible(this.command, this.args);
        }
        /**
         * The key binding for the command item.
         */
        get keyBinding() {
          let { command, args } = this;
          return ArrayExt3.findLastValue(this._commands.keyBindings, (kb) => {
            return kb.command === command && import_coreutils7.JSONExt.deepEqual(kb.args, args);
          }) || null;
        }
      }
    })(Private$a || (Private$a = {}));
    Menu = class extends Widget {
      /**
       * Construct a new menu.
       *
       * @param options - The options for initializing the menu.
       */
      constructor(options) {
        super({ node: Private$9.createNode() });
        this._childIndex = -1;
        this._activeIndex = -1;
        this._openTimerID = 0;
        this._closeTimerID = 0;
        this._items = [];
        this._childMenu = null;
        this._parentMenu = null;
        this._aboutToClose = new Signal(this);
        this._menuRequested = new Signal(this);
        this.addClass("lm-Menu");
        this.setFlag(Widget.Flag.DisallowLayout);
        this.commands = options.commands;
        this.renderer = options.renderer || Menu.defaultRenderer;
      }
      /**
       * Dispose of the resources held by the menu.
       */
      dispose() {
        this.close();
        this._items.length = 0;
        super.dispose();
      }
      /**
       * A signal emitted just before the menu is closed.
       *
       * #### Notes
       * This signal is emitted when the menu receives a `'close-request'`
       * message, just before it removes itself from the DOM.
       *
       * This signal is not emitted if the menu is already detached from
       * the DOM when it receives the `'close-request'` message.
       */
      get aboutToClose() {
        return this._aboutToClose;
      }
      /**
       * A signal emitted when a new menu is requested by the user.
       *
       * #### Notes
       * This signal is emitted whenever the user presses the right or left
       * arrow keys, and a submenu cannot be opened or closed in response.
       *
       * This signal is useful when implementing menu bars in order to open
       * the next or previous menu in response to a user key press.
       *
       * This signal is only emitted for the root menu in a hierarchy.
       */
      get menuRequested() {
        return this._menuRequested;
      }
      /**
       * The parent menu of the menu.
       *
       * #### Notes
       * This is `null` unless the menu is an open submenu.
       */
      get parentMenu() {
        return this._parentMenu;
      }
      /**
       * The child menu of the menu.
       *
       * #### Notes
       * This is `null` unless the menu has an open submenu.
       */
      get childMenu() {
        return this._childMenu;
      }
      /**
       * The root menu of the menu hierarchy.
       */
      get rootMenu() {
        let menu = this;
        while (menu._parentMenu) {
          menu = menu._parentMenu;
        }
        return menu;
      }
      /**
       * The leaf menu of the menu hierarchy.
       */
      get leafMenu() {
        let menu = this;
        while (menu._childMenu) {
          menu = menu._childMenu;
        }
        return menu;
      }
      /**
       * The menu content node.
       *
       * #### Notes
       * This is the node which holds the menu item nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-Menu-content")[0];
      }
      /**
       * Get the currently active menu item.
       */
      get activeItem() {
        return this._items[this._activeIndex] || null;
      }
      /**
       * Set the currently active menu item.
       *
       * #### Notes
       * If the item cannot be activated, the item will be set to `null`.
       */
      set activeItem(value) {
        this.activeIndex = value ? this._items.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently active menu item.
       *
       * #### Notes
       * This will be `-1` if no menu item is active.
       */
      get activeIndex() {
        return this._activeIndex;
      }
      /**
       * Set the index of the currently active menu item.
       *
       * #### Notes
       * If the item cannot be activated, the index will be set to `-1`.
       */
      set activeIndex(value) {
        if (value < 0 || value >= this._items.length) {
          value = -1;
        }
        if (value !== -1 && !Private$9.canActivate(this._items[value])) {
          value = -1;
        }
        if (this._activeIndex === value) {
          return;
        }
        this._activeIndex = value;
        if (this._activeIndex >= 0 && this.contentNode.childNodes[this._activeIndex]) {
          this.contentNode.childNodes[this._activeIndex].focus();
        }
        this.update();
      }
      /**
       * A read-only array of the menu items in the menu.
       */
      get items() {
        return this._items;
      }
      /**
       * Activate the next selectable item in the menu.
       *
       * #### Notes
       * If no item is selectable, the index will be set to `-1`.
       */
      activateNextItem() {
        let n = this._items.length;
        let ai = this._activeIndex;
        let start = ai < n - 1 ? ai + 1 : 0;
        let stop = start === 0 ? n - 1 : start - 1;
        this.activeIndex = ArrayExt3.findFirstIndex(this._items, Private$9.canActivate, start, stop);
      }
      /**
       * Activate the previous selectable item in the menu.
       *
       * #### Notes
       * If no item is selectable, the index will be set to `-1`.
       */
      activatePreviousItem() {
        let n = this._items.length;
        let ai = this._activeIndex;
        let start = ai <= 0 ? n - 1 : ai - 1;
        let stop = start === n - 1 ? 0 : start + 1;
        this.activeIndex = ArrayExt3.findLastIndex(this._items, Private$9.canActivate, start, stop);
      }
      /**
       * Trigger the active menu item.
       *
       * #### Notes
       * If the active item is a submenu, it will be opened and the first
       * item will be activated.
       *
       * If the active item is a command, the command will be executed.
       *
       * If the menu is not attached, this is a no-op.
       *
       * If there is no active item, this is a no-op.
       */
      triggerActiveItem() {
        if (!this.isAttached) {
          return;
        }
        let item = this.activeItem;
        if (!item) {
          return;
        }
        this._cancelOpenTimer();
        this._cancelCloseTimer();
        if (item.type === "submenu") {
          this._openChildMenu(true);
          return;
        }
        this.rootMenu.close();
        let { command, args } = item;
        if (this.commands.isEnabled(command, args)) {
          this.commands.execute(command, args);
        } else {
          console.log(`Command '${command}' is disabled.`);
        }
      }
      /**
       * Add a menu item to the end of the menu.
       *
       * @param options - The options for creating the menu item.
       *
       * @returns The menu item added to the menu.
       */
      addItem(options) {
        return this.insertItem(this._items.length, options);
      }
      /**
       * Insert a menu item into the menu at the specified index.
       *
       * @param index - The index at which to insert the item.
       *
       * @param options - The options for creating the menu item.
       *
       * @returns The menu item added to the menu.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       */
      insertItem(index, options) {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        let i = Math.max(0, Math.min(index, this._items.length));
        let item = Private$9.createItem(this, options);
        ArrayExt3.insert(this._items, i, item);
        this.update();
        return item;
      }
      /**
       * Remove an item from the menu.
       *
       * @param item - The item to remove from the menu.
       *
       * #### Notes
       * This is a no-op if the item is not in the menu.
       */
      removeItem(item) {
        this.removeItemAt(this._items.indexOf(item));
      }
      /**
       * Remove the item at a given index from the menu.
       *
       * @param index - The index of the item to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeItemAt(index) {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        let item = ArrayExt3.removeAt(this._items, index);
        if (!item) {
          return;
        }
        this.update();
      }
      /**
       * Remove all menu items from the menu.
       */
      clearItems() {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        if (this._items.length === 0) {
          return;
        }
        this._items.length = 0;
        this.update();
      }
      /**
       * Open the menu at the specified location.
       *
       * @param x - The client X coordinate of the menu location.
       *
       * @param y - The client Y coordinate of the menu location.
       *
       * @param options - The additional options for opening the menu.
       *
       * #### Notes
       * The menu will be opened at the given location unless it will not
       * fully fit on the screen. If it will not fit, it will be adjusted
       * to fit naturally on the screen.
       *
       * This is a no-op if the menu is already attached to the DOM.
       */
      open(x, y, options = {}) {
        if (this.isAttached) {
          return;
        }
        let forceX = options.forceX || false;
        let forceY = options.forceY || false;
        Private$9.openRootMenu(this, x, y, forceX, forceY);
        this.activate();
      }
      /**
       * Handle the DOM events for the menu.
       *
       * @param event - The DOM event sent to the menu.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the menu's DOM nodes. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "mouseup":
            this._evtMouseUp(event);
            break;
          case "mousemove":
            this._evtMouseMove(event);
            break;
          case "mouseenter":
            this._evtMouseEnter(event);
            break;
          case "mouseleave":
            this._evtMouseLeave(event);
            break;
          case "mousedown":
            this._evtMouseDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("mouseup", this);
        this.node.addEventListener("mousemove", this);
        this.node.addEventListener("mouseenter", this);
        this.node.addEventListener("mouseleave", this);
        this.node.addEventListener("contextmenu", this);
        document.addEventListener("mousedown", this, true);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("mouseup", this);
        this.node.removeEventListener("mousemove", this);
        this.node.removeEventListener("mouseenter", this);
        this.node.removeEventListener("mouseleave", this);
        this.node.removeEventListener("contextmenu", this);
        document.removeEventListener("mousedown", this, true);
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          this.node.focus();
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        let items = this._items;
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let collapsedFlags = Private$9.computeCollapsed(items);
        let content = new Array(items.length);
        for (let i = 0, n = items.length; i < n; ++i) {
          let item = items[i];
          let active = i === activeIndex;
          let collapsed = collapsedFlags[i];
          content[i] = renderer.renderItem({
            item,
            active,
            collapsed,
            onfocus: () => {
              this.activeIndex = i;
            }
          });
        }
        VirtualDOM.render(content, this.contentNode);
      }
      /**
       * A message handler invoked on a `'close-request'` message.
       */
      onCloseRequest(msg) {
        this._cancelOpenTimer();
        this._cancelCloseTimer();
        this.activeIndex = -1;
        let childMenu = this._childMenu;
        if (childMenu) {
          this._childIndex = -1;
          this._childMenu = null;
          childMenu._parentMenu = null;
          childMenu.close();
        }
        let parentMenu = this._parentMenu;
        if (parentMenu) {
          this._parentMenu = null;
          parentMenu._childIndex = -1;
          parentMenu._childMenu = null;
          parentMenu.activate();
        }
        if (this.isAttached) {
          this._aboutToClose.emit(void 0);
        }
        super.onCloseRequest(msg);
      }
      /**
       * Handle the `'keydown'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        let kc = event.keyCode;
        if (kc === 13) {
          this.triggerActiveItem();
          return;
        }
        if (kc === 27) {
          this.close();
          return;
        }
        if (kc === 37) {
          if (this._parentMenu) {
            this.close();
          } else {
            this._menuRequested.emit("previous");
          }
          return;
        }
        if (kc === 38) {
          this.activatePreviousItem();
          return;
        }
        if (kc === 39) {
          let item = this.activeItem;
          if (item && item.type === "submenu") {
            this.triggerActiveItem();
          } else {
            this.rootMenu._menuRequested.emit("next");
          }
          return;
        }
        if (kc === 40) {
          this.activateNextItem();
          return;
        }
        let key2 = getKeyboardLayout().keyForKeydownEvent(event);
        if (!key2) {
          return;
        }
        let start = this._activeIndex + 1;
        let result = Private$9.findMnemonic(this._items, key2, start);
        if (result.index !== -1 && !result.multiple) {
          this.activeIndex = result.index;
          this.triggerActiveItem();
        } else if (result.index !== -1) {
          this.activeIndex = result.index;
        } else if (result.auto !== -1) {
          this.activeIndex = result.auto;
        }
      }
      /**
       * Handle the `'mouseup'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.triggerActiveItem();
      }
      /**
       * Handle the `'mousemove'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseMove(event) {
        let index = ArrayExt3.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index === this._activeIndex) {
          return;
        }
        this.activeIndex = index;
        index = this.activeIndex;
        if (index === this._childIndex) {
          this._cancelOpenTimer();
          this._cancelCloseTimer();
          return;
        }
        if (this._childIndex !== -1) {
          this._startCloseTimer();
        }
        this._cancelOpenTimer();
        let item = this.activeItem;
        if (!item || item.type !== "submenu" || !item.submenu) {
          return;
        }
        this._startOpenTimer();
      }
      /**
       * Handle the `'mouseenter'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseEnter(event) {
        for (let menu = this._parentMenu; menu; menu = menu._parentMenu) {
          menu._cancelOpenTimer();
          menu._cancelCloseTimer();
          menu.activeIndex = menu._childIndex;
        }
      }
      /**
       * Handle the `'mouseleave'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseLeave(event) {
        this._cancelOpenTimer();
        if (!this._childMenu) {
          this.activeIndex = -1;
          return;
        }
        let { clientX, clientY } = event;
        if (ElementExt.hitTest(this._childMenu.node, clientX, clientY)) {
          this._cancelCloseTimer();
          return;
        }
        this.activeIndex = -1;
        this._startCloseTimer();
      }
      /**
       * Handle the `'mousedown'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the document node.
       */
      _evtMouseDown(event) {
        if (this._parentMenu) {
          return;
        }
        if (Private$9.hitTestMenus(this, event.clientX, event.clientY)) {
          event.preventDefault();
          event.stopPropagation();
        } else {
          this.close();
        }
      }
      /**
       * Open the child menu at the active index immediately.
       *
       * If a different child menu is already open, it will be closed,
       * even if the active item is not a valid submenu.
       */
      _openChildMenu(activateFirst = false) {
        let item = this.activeItem;
        if (!item || item.type !== "submenu" || !item.submenu) {
          this._closeChildMenu();
          return;
        }
        let submenu = item.submenu;
        if (submenu === this._childMenu) {
          return;
        }
        Menu.saveWindowData();
        this._closeChildMenu();
        this._childMenu = submenu;
        this._childIndex = this._activeIndex;
        submenu._parentMenu = this;
        MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);
        let itemNode = this.contentNode.children[this._activeIndex];
        Private$9.openSubmenu(submenu, itemNode);
        if (activateFirst) {
          submenu.activeIndex = -1;
          submenu.activateNextItem();
        }
        submenu.activate();
      }
      /**
       * Close the child menu immediately.
       *
       * This is a no-op if a child menu is not open.
       */
      _closeChildMenu() {
        if (this._childMenu) {
          this._childMenu.close();
        }
      }
      /**
       * Start the open timer, unless it is already pending.
       */
      _startOpenTimer() {
        if (this._openTimerID === 0) {
          this._openTimerID = window.setTimeout(() => {
            this._openTimerID = 0;
            this._openChildMenu();
          }, Private$9.TIMER_DELAY);
        }
      }
      /**
       * Start the close timer, unless it is already pending.
       */
      _startCloseTimer() {
        if (this._closeTimerID === 0) {
          this._closeTimerID = window.setTimeout(() => {
            this._closeTimerID = 0;
            this._closeChildMenu();
          }, Private$9.TIMER_DELAY);
        }
      }
      /**
       * Cancel the open timer, if the timer is pending.
       */
      _cancelOpenTimer() {
        if (this._openTimerID !== 0) {
          clearTimeout(this._openTimerID);
          this._openTimerID = 0;
        }
      }
      /**
       * Cancel the close timer, if the timer is pending.
       */
      _cancelCloseTimer() {
        if (this._closeTimerID !== 0) {
          clearTimeout(this._closeTimerID);
          this._closeTimerID = 0;
        }
      }
      /**
       * Save window data used for menu positioning in transient cache.
       *
       * In order to avoid layout trashing it is recommended to invoke this
       * method immediately prior to opening the menu and any DOM modifications
       * (like closing previously visible menu, or adding a class to menu widget).
       *
       * The transient cache will be released upon `open()` call.
       */
      static saveWindowData() {
        Private$9.saveWindowData();
      }
    };
    (function(Menu5) {
      class Renderer {
        /**
         * Render the virtual element for a menu item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          let aria = this.createItemARIA(data);
          return h.li({
            className,
            dataset,
            tabindex: "0",
            onfocus: data.onfocus,
            ...aria
          }, this.renderIcon(data), this.renderLabel(data), this.renderShortcut(data), this.renderSubmenu(data));
        }
        /**
         * Render the icon element for a menu item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the item icon.
         */
        renderIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Render the label element for a menu item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the item label.
         */
        renderLabel(data) {
          let content = this.formatLabel(data);
          return h.div({ className: "lm-Menu-itemLabel" }, content);
        }
        /**
         * Render the shortcut element for a menu item.
         *
         * @param data - The data to use for rendering the shortcut.
         *
         * @returns A virtual element representing the item shortcut.
         */
        renderShortcut(data) {
          let content = this.formatShortcut(data);
          return h.div({ className: "lm-Menu-itemShortcut" }, content);
        }
        /**
         * Render the submenu icon element for a menu item.
         *
         * @param data - The data to use for rendering the submenu icon.
         *
         * @returns A virtual element representing the submenu icon.
         */
        renderSubmenu(data) {
          return h.div({ className: "lm-Menu-itemSubmenuIcon" });
        }
        /**
         * Create the class name for the menu item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the menu item.
         */
        createItemClass(data) {
          let name2 = "lm-Menu-item";
          if (!data.item.isEnabled) {
            name2 += " lm-mod-disabled";
          }
          if (data.item.isToggled) {
            name2 += " lm-mod-toggled";
          }
          if (!data.item.isVisible) {
            name2 += " lm-mod-hidden";
          }
          if (data.active) {
            name2 += " lm-mod-active";
          }
          if (data.collapsed) {
            name2 += " lm-mod-collapsed";
          }
          let extra = data.item.className;
          if (extra) {
            name2 += ` ${extra}`;
          }
          return name2;
        }
        /**
         * Create the dataset for the menu item.
         *
         * @param data - The data to use for creating the dataset.
         *
         * @returns The dataset for the menu item.
         */
        createItemDataset(data) {
          let result;
          let { type, command, dataset } = data.item;
          if (type === "command") {
            result = { ...dataset, type, command };
          } else {
            result = { ...dataset, type };
          }
          return result;
        }
        /**
         * Create the class name for the menu item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name2 = "lm-Menu-itemIcon";
          let extra = data.item.iconClass;
          return extra ? `${name2} ${extra}` : name2;
        }
        /**
         * Create the aria attributes for menu item.
         *
         * @param data - The data to use for the aria attributes.
         *
         * @returns The aria attributes object for the item.
         */
        createItemARIA(data) {
          let aria = {};
          switch (data.item.type) {
            case "separator":
              aria.role = "presentation";
              break;
            case "submenu":
              aria["aria-haspopup"] = "true";
              if (!data.item.isEnabled) {
                aria["aria-disabled"] = "true";
              }
              break;
            default:
              if (!data.item.isEnabled) {
                aria["aria-disabled"] = "true";
              }
              aria.role = "menuitem";
          }
          return aria;
        }
        /**
         * Create the render content for the label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatLabel(data) {
          let { label, mnemonic } = data.item;
          if (mnemonic < 0 || mnemonic >= label.length) {
            return label;
          }
          let prefix = label.slice(0, mnemonic);
          let suffix = label.slice(mnemonic + 1);
          let char = label[mnemonic];
          let span = h.span({ className: "lm-Menu-itemMnemonic" }, char);
          return [prefix, span, suffix];
        }
        /**
         * Create the render content for the shortcut node.
         *
         * @param data - The data to use for the shortcut content.
         *
         * @returns The content to add to the shortcut node.
         */
        formatShortcut(data) {
          let kb = data.item.keyBinding;
          return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;
        }
      }
      Menu5.Renderer = Renderer;
      Menu5.defaultRenderer = new Renderer();
    })(Menu || (Menu = {}));
    (function(Private36) {
      Private36.TIMER_DELAY = 300;
      Private36.SUBMENU_OVERLAP = 3;
      let transientWindowDataCache = null;
      let transientCacheCounter = 0;
      function getWindowData() {
        if (transientCacheCounter > 0) {
          transientCacheCounter--;
          return transientWindowDataCache;
        }
        return _getWindowData();
      }
      function saveWindowData() {
        transientWindowDataCache = _getWindowData();
        transientCacheCounter++;
      }
      Private36.saveWindowData = saveWindowData;
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.className = "lm-Menu-content";
        node.appendChild(content);
        content.setAttribute("role", "menu");
        node.tabIndex = 0;
        return node;
      }
      Private36.createNode = createNode;
      function canActivate(item) {
        return item.type !== "separator" && item.isEnabled && item.isVisible;
      }
      Private36.canActivate = canActivate;
      function createItem(owner, options) {
        return new MenuItem3(owner.commands, options);
      }
      Private36.createItem = createItem;
      function hitTestMenus(menu, x, y) {
        for (let temp = menu; temp; temp = temp.childMenu) {
          if (ElementExt.hitTest(temp.node, x, y)) {
            return true;
          }
        }
        return false;
      }
      Private36.hitTestMenus = hitTestMenus;
      function computeCollapsed(items) {
        let result = new Array(items.length);
        ArrayExt3.fill(result, false);
        let k1 = 0;
        let n = items.length;
        for (; k1 < n; ++k1) {
          let item = items[k1];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            break;
          }
          result[k1] = true;
        }
        let k2 = n - 1;
        for (; k2 >= 0; --k2) {
          let item = items[k2];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            break;
          }
          result[k2] = true;
        }
        let hide = false;
        while (++k1 < k2) {
          let item = items[k1];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            hide = false;
          } else if (hide) {
            result[k1] = true;
          } else {
            hide = true;
          }
        }
        return result;
      }
      Private36.computeCollapsed = computeCollapsed;
      function _getWindowData() {
        return {
          pageXOffset: window.pageXOffset,
          pageYOffset: window.pageYOffset,
          clientWidth: document.documentElement.clientWidth,
          clientHeight: document.documentElement.clientHeight
        };
      }
      function openRootMenu(menu, x, y, forceX, forceY) {
        const windowData = getWindowData();
        let px = windowData.pageXOffset;
        let py = windowData.pageYOffset;
        let cw = windowData.clientWidth;
        let ch = windowData.clientHeight;
        MessageLoop.sendMessage(menu, Widget.Msg.UpdateRequest);
        let maxHeight = ch - (forceY ? y : 0);
        let node = menu.node;
        let style = node.style;
        style.opacity = "0";
        style.maxHeight = `${maxHeight}px`;
        Widget.attach(menu, document.body);
        let { width, height } = node.getBoundingClientRect();
        if (!forceX && x + width > px + cw) {
          x = px + cw - width;
        }
        if (!forceY && y + height > py + ch) {
          if (y > py + ch) {
            y = py + ch - height;
          } else {
            y = y - height;
          }
        }
        style.transform = `translate(${Math.max(0, x)}px, ${Math.max(0, y)}px`;
        style.opacity = "1";
      }
      Private36.openRootMenu = openRootMenu;
      function openSubmenu(submenu, itemNode) {
        const windowData = getWindowData();
        let px = windowData.pageXOffset;
        let py = windowData.pageYOffset;
        let cw = windowData.clientWidth;
        let ch = windowData.clientHeight;
        MessageLoop.sendMessage(submenu, Widget.Msg.UpdateRequest);
        let maxHeight = ch;
        let node = submenu.node;
        let style = node.style;
        style.opacity = "0";
        style.maxHeight = `${maxHeight}px`;
        Widget.attach(submenu, document.body);
        let { width, height } = node.getBoundingClientRect();
        let box = ElementExt.boxSizing(submenu.node);
        let itemRect = itemNode.getBoundingClientRect();
        let x = itemRect.right - Private36.SUBMENU_OVERLAP;
        if (x + width > px + cw) {
          x = itemRect.left + Private36.SUBMENU_OVERLAP - width;
        }
        let y = itemRect.top - box.borderTop - box.paddingTop;
        if (y + height > py + ch) {
          y = itemRect.bottom + box.borderBottom + box.paddingBottom - height;
        }
        style.transform = `translate(${Math.max(0, x)}px, ${Math.max(0, y)}px`;
        style.opacity = "1";
      }
      Private36.openSubmenu = openSubmenu;
      function findMnemonic(items, key2, start) {
        let index = -1;
        let auto = -1;
        let multiple = false;
        let upperKey = key2.toUpperCase();
        for (let i = 0, n = items.length; i < n; ++i) {
          let k = (i + start) % n;
          let item = items[k];
          if (!canActivate(item)) {
            continue;
          }
          let label = item.label;
          if (label.length === 0) {
            continue;
          }
          let mn = item.mnemonic;
          if (mn >= 0 && mn < label.length) {
            if (label[mn].toUpperCase() === upperKey) {
              if (index === -1) {
                index = k;
              } else {
                multiple = true;
              }
            }
            continue;
          }
          if (auto === -1 && label[0].toUpperCase() === upperKey) {
            auto = k;
          }
        }
        return { index, multiple, auto };
      }
      Private36.findMnemonic = findMnemonic;
      class MenuItem3 {
        /**
         * Construct a new menu item.
         */
        constructor(commands, options) {
          this._commands = commands;
          this.type = options.type || "command";
          this.command = options.command || "";
          this.args = options.args || import_coreutils7.JSONExt.emptyObject;
          this.submenu = options.submenu || null;
        }
        /**
         * The display label for the menu item.
         */
        get label() {
          if (this.type === "command") {
            return this._commands.label(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.label;
          }
          return "";
        }
        /**
         * The mnemonic index for the menu item.
         */
        get mnemonic() {
          if (this.type === "command") {
            return this._commands.mnemonic(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.mnemonic;
          }
          return -1;
        }
        /**
         * The icon renderer for the menu item.
         */
        get icon() {
          if (this.type === "command") {
            return this._commands.icon(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.icon;
          }
          return void 0;
        }
        /**
         * The icon class for the menu item.
         */
        get iconClass() {
          if (this.type === "command") {
            return this._commands.iconClass(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.iconClass;
          }
          return "";
        }
        /**
         * The icon label for the menu item.
         */
        get iconLabel() {
          if (this.type === "command") {
            return this._commands.iconLabel(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.iconLabel;
          }
          return "";
        }
        /**
         * The display caption for the menu item.
         */
        get caption() {
          if (this.type === "command") {
            return this._commands.caption(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.caption;
          }
          return "";
        }
        /**
         * The extra class name for the menu item.
         */
        get className() {
          if (this.type === "command") {
            return this._commands.className(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.className;
          }
          return "";
        }
        /**
         * The dataset for the menu item.
         */
        get dataset() {
          if (this.type === "command") {
            return this._commands.dataset(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.dataset;
          }
          return {};
        }
        /**
         * Whether the menu item is enabled.
         */
        get isEnabled() {
          if (this.type === "command") {
            return this._commands.isEnabled(this.command, this.args);
          }
          if (this.type === "submenu") {
            return this.submenu !== null;
          }
          return true;
        }
        /**
         * Whether the menu item is toggled.
         */
        get isToggled() {
          if (this.type === "command") {
            return this._commands.isToggled(this.command, this.args);
          }
          return false;
        }
        /**
         * Whether the menu item is visible.
         */
        get isVisible() {
          if (this.type === "command") {
            return this._commands.isVisible(this.command, this.args);
          }
          if (this.type === "submenu") {
            return this.submenu !== null;
          }
          return true;
        }
        /**
         * The key binding for the menu item.
         */
        get keyBinding() {
          if (this.type === "command") {
            let { command, args } = this;
            return ArrayExt3.findLastValue(this._commands.keyBindings, (kb) => {
              return kb.command === command && import_coreutils7.JSONExt.deepEqual(kb.args, args);
            }) || null;
          }
          return null;
        }
      }
    })(Private$9 || (Private$9 = {}));
    (function(Private36) {
      function createItem(options, id) {
        let selector = validateSelector(options.selector);
        let rank = options.rank !== void 0 ? options.rank : Infinity;
        return { ...options, selector, rank, id };
      }
      Private36.createItem = createItem;
      function matchItems(items, event, groupByTarget, sortBySelector) {
        let target2 = event.target;
        if (!target2) {
          return null;
        }
        let currentTarget = event.currentTarget;
        if (!currentTarget) {
          return null;
        }
        if (!currentTarget.contains(target2)) {
          target2 = document.elementFromPoint(event.clientX, event.clientY);
          if (!target2 || !currentTarget.contains(target2)) {
            return null;
          }
        }
        let result = [];
        let availableItems = items.slice();
        while (target2 !== null) {
          let matches2 = [];
          for (let i = 0, n = availableItems.length; i < n; ++i) {
            let item = availableItems[i];
            if (!item) {
              continue;
            }
            if (!Selector2.matches(target2, item.selector)) {
              continue;
            }
            matches2.push(item);
            availableItems[i] = null;
          }
          if (matches2.length !== 0) {
            if (groupByTarget) {
              matches2.sort(sortBySelector ? itemCmp : itemCmpRank);
            }
            result.push(...matches2);
          }
          if (target2 === currentTarget) {
            break;
          }
          target2 = target2.parentElement;
        }
        if (!groupByTarget) {
          result.sort(sortBySelector ? itemCmp : itemCmpRank);
        }
        return result;
      }
      Private36.matchItems = matchItems;
      function validateSelector(selector) {
        if (selector.indexOf(",") !== -1) {
          throw new Error(`Selector cannot contain commas: ${selector}`);
        }
        if (!Selector2.isValid(selector)) {
          throw new Error(`Invalid selector: ${selector}`);
        }
        return selector;
      }
      function itemCmpRank(a, b) {
        let r1 = a.rank;
        let r2 = b.rank;
        if (r1 !== r2) {
          return r1 < r2 ? -1 : 1;
        }
        return a.id - b.id;
      }
      function itemCmp(a, b) {
        let s1 = Selector2.calculateSpecificity(a.selector);
        let s2 = Selector2.calculateSpecificity(b.selector);
        if (s1 !== s2) {
          return s2 - s1;
        }
        return itemCmpRank(a, b);
      }
    })(Private$8 || (Private$8 = {}));
    ARROW_KEYS = [
      "ArrowLeft",
      "ArrowUp",
      "ArrowRight",
      "ArrowDown",
      "Home",
      "End"
    ];
    TabBar = class extends Widget {
      /**
       * Construct a new tab bar.
       *
       * @param options - The options for initializing the tab bar.
       */
      constructor(options = {}) {
        super({ node: Private$7.createNode() });
        this._currentIndex = -1;
        this._titles = [];
        this._titlesEditable = false;
        this._previousTitle = null;
        this._dragData = null;
        this._addButtonEnabled = false;
        this._tabMoved = new Signal(this);
        this._currentChanged = new Signal(this);
        this._addRequested = new Signal(this);
        this._tabCloseRequested = new Signal(this);
        this._tabDetachRequested = new Signal(this);
        this._tabActivateRequested = new Signal(this);
        this.addClass("lm-TabBar");
        this.contentNode.setAttribute("role", "tablist");
        this.setFlag(Widget.Flag.DisallowLayout);
        this._document = options.document || document;
        this.tabsMovable = options.tabsMovable || false;
        this.titlesEditable = options.titlesEditable || false;
        this.allowDeselect = options.allowDeselect || false;
        this.addButtonEnabled = options.addButtonEnabled || false;
        this.insertBehavior = options.insertBehavior || "select-tab-if-needed";
        this.name = options.name || "";
        this.orientation = options.orientation || "horizontal";
        this.removeBehavior = options.removeBehavior || "select-tab-after";
        this.renderer = options.renderer || TabBar.defaultRenderer;
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._releaseMouse();
        this._titles.length = 0;
        this._previousTitle = null;
        super.dispose();
      }
      /**
       * A signal emitted when the current tab is changed.
       *
       * #### Notes
       * This signal is emitted when the currently selected tab is changed
       * either through user or programmatic interaction.
       *
       * Notably, this signal is not emitted when the index of the current
       * tab changes due to tabs being inserted, removed, or moved. It is
       * only emitted when the actual current tab node is changed.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * A signal emitted when a tab is moved by the user.
       *
       * #### Notes
       * This signal is emitted when a tab is moved by user interaction.
       *
       * This signal is not emitted when a tab is moved programmatically.
       */
      get tabMoved() {
        return this._tabMoved;
      }
      /**
       * A signal emitted when a tab is clicked by the user.
       *
       * #### Notes
       * If the clicked tab is not the current tab, the clicked tab will be
       * made current and the `currentChanged` signal will be emitted first.
       *
       * This signal is emitted even if the clicked tab is the current tab.
       */
      get tabActivateRequested() {
        return this._tabActivateRequested;
      }
      /**
       * A signal emitted when the tab bar add button is clicked.
       */
      get addRequested() {
        return this._addRequested;
      }
      /**
       * A signal emitted when a tab close icon is clicked.
       *
       * #### Notes
       * This signal is not emitted unless the tab title is `closable`.
       */
      get tabCloseRequested() {
        return this._tabCloseRequested;
      }
      /**
       * A signal emitted when a tab is dragged beyond the detach threshold.
       *
       * #### Notes
       * This signal is emitted when the user drags a tab with the mouse,
       * and mouse is dragged beyond the detach threshold.
       *
       * The consumer of the signal should call `releaseMouse` and remove
       * the tab in order to complete the detach.
       *
       * This signal is only emitted once per drag cycle.
       */
      get tabDetachRequested() {
        return this._tabDetachRequested;
      }
      /**
       * The document to use with the tab bar.
       *
       * The default is the global `document` instance.
       */
      get document() {
        return this._document;
      }
      /**
       * Whether the titles can be user-edited.
       *
       */
      get titlesEditable() {
        return this._titlesEditable;
      }
      /**
       * Set whether titles can be user edited.
       *
       */
      set titlesEditable(value) {
        this._titlesEditable = value;
      }
      /**
       * Get the currently selected title.
       *
       * #### Notes
       * This will be `null` if no tab is selected.
       */
      get currentTitle() {
        return this._titles[this._currentIndex] || null;
      }
      /**
       * Set the currently selected title.
       *
       * #### Notes
       * If the title does not exist, the title will be set to `null`.
       */
      set currentTitle(value) {
        this.currentIndex = value ? this._titles.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently selected tab.
       *
       * #### Notes
       * This will be `-1` if no tab is selected.
       */
      get currentIndex() {
        return this._currentIndex;
      }
      /**
       * Set the index of the currently selected tab.
       *
       * #### Notes
       * If the value is out of range, the index will be set to `-1`.
       */
      set currentIndex(value) {
        if (value < 0 || value >= this._titles.length) {
          value = -1;
        }
        if (this._currentIndex === value) {
          return;
        }
        let pi = this._currentIndex;
        let pt = this._titles[pi] || null;
        let ci = value;
        let ct = this._titles[ci] || null;
        this._currentIndex = ci;
        this._previousTitle = pt;
        this.update();
        this._currentChanged.emit({
          previousIndex: pi,
          previousTitle: pt,
          currentIndex: ci,
          currentTitle: ct
        });
      }
      /**
       * Get the name of the tab bar.
       */
      get name() {
        return this._name;
      }
      /**
       * Set the name of the tab bar.
       */
      set name(value) {
        this._name = value;
        if (value) {
          this.contentNode.setAttribute("aria-label", value);
        } else {
          this.contentNode.removeAttribute("aria-label");
        }
      }
      /**
       * Get the orientation of the tab bar.
       *
       * #### Notes
       * This controls whether the tabs are arranged in a row or column.
       */
      get orientation() {
        return this._orientation;
      }
      /**
       * Set the orientation of the tab bar.
       *
       * #### Notes
       * This controls whether the tabs are arranged in a row or column.
       */
      set orientation(value) {
        if (this._orientation === value) {
          return;
        }
        this._releaseMouse();
        this._orientation = value;
        this.dataset["orientation"] = value;
        this.contentNode.setAttribute("aria-orientation", value);
      }
      /**
       * Whether the add button is enabled.
       */
      get addButtonEnabled() {
        return this._addButtonEnabled;
      }
      /**
       * Set whether the add button is enabled.
       */
      set addButtonEnabled(value) {
        if (this._addButtonEnabled === value) {
          return;
        }
        this._addButtonEnabled = value;
        if (value) {
          this.addButtonNode.classList.remove("lm-mod-hidden");
        } else {
          this.addButtonNode.classList.add("lm-mod-hidden");
        }
      }
      /**
       * A read-only array of the titles in the tab bar.
       */
      get titles() {
        return this._titles;
      }
      /**
       * The tab bar content node.
       *
       * #### Notes
       * This is the node which holds the tab nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-TabBar-content")[0];
      }
      /**
       * The tab bar add button node.
       *
       * #### Notes
       * This is the node which holds the add button.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get addButtonNode() {
        return this.node.getElementsByClassName("lm-TabBar-addButton")[0];
      }
      /**
       * Add a tab to the end of the tab bar.
       *
       * @param value - The title which holds the data for the tab,
       *   or an options object to convert to a title.
       *
       * @returns The title object added to the tab bar.
       *
       * #### Notes
       * If the title is already added to the tab bar, it will be moved.
       */
      addTab(value) {
        return this.insertTab(this._titles.length, value);
      }
      /**
       * Insert a tab into the tab bar at the specified index.
       *
       * @param index - The index at which to insert the tab.
       *
       * @param value - The title which holds the data for the tab,
       *   or an options object to convert to a title.
       *
       * @returns The title object added to the tab bar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the tabs.
       *
       * If the title is already added to the tab bar, it will be moved.
       */
      insertTab(index, value) {
        this._releaseMouse();
        let title = Private$7.asTitle(value);
        let i = this._titles.indexOf(title);
        let j = Math.max(0, Math.min(index, this._titles.length));
        if (i === -1) {
          ArrayExt3.insert(this._titles, j, title);
          title.changed.connect(this._onTitleChanged, this);
          this.update();
          this._adjustCurrentForInsert(j, title);
          return title;
        }
        if (j === this._titles.length) {
          j--;
        }
        if (i === j) {
          return title;
        }
        ArrayExt3.move(this._titles, i, j);
        this.update();
        this._adjustCurrentForMove(i, j);
        return title;
      }
      /**
       * Remove a tab from the tab bar.
       *
       * @param title - The title for the tab to remove.
       *
       * #### Notes
       * This is a no-op if the title is not in the tab bar.
       */
      removeTab(title) {
        this.removeTabAt(this._titles.indexOf(title));
      }
      /**
       * Remove the tab at a given index from the tab bar.
       *
       * @param index - The index of the tab to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeTabAt(index) {
        this._releaseMouse();
        let title = ArrayExt3.removeAt(this._titles, index);
        if (!title) {
          return;
        }
        title.changed.disconnect(this._onTitleChanged, this);
        if (title === this._previousTitle) {
          this._previousTitle = null;
        }
        this.update();
        this._adjustCurrentForRemove(index, title);
      }
      /**
       * Remove all tabs from the tab bar.
       */
      clearTabs() {
        if (this._titles.length === 0) {
          return;
        }
        this._releaseMouse();
        for (let title of this._titles) {
          title.changed.disconnect(this._onTitleChanged, this);
        }
        let pi = this.currentIndex;
        let pt = this.currentTitle;
        this._currentIndex = -1;
        this._previousTitle = null;
        this._titles.length = 0;
        this.update();
        if (pi === -1) {
          return;
        }
        this._currentChanged.emit({
          previousIndex: pi,
          previousTitle: pt,
          currentIndex: -1,
          currentTitle: null
        });
      }
      /**
       * Release the mouse and restore the non-dragged tab positions.
       *
       * #### Notes
       * This will cause the tab bar to stop handling mouse events and to
       * restore the tabs to their non-dragged positions.
       */
      releaseMouse() {
        this._releaseMouse();
      }
      /**
       * Handle the DOM events for the tab bar.
       *
       * @param event - The DOM event sent to the tab bar.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the tab bar's DOM node.
       *
       * This should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "dblclick":
            this._evtDblClick(event);
            break;
          case "keydown":
            event.eventPhase === Event.CAPTURING_PHASE ? this._evtKeyDownCapturing(event) : this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("pointerdown", this);
        this.node.addEventListener("dblclick", this);
        this.node.addEventListener("keydown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("pointerdown", this);
        this.node.removeEventListener("dblclick", this);
        this.node.removeEventListener("keydown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        var _a;
        let titles = this._titles;
        let renderer = this.renderer;
        let currentTitle = this.currentTitle;
        let content = new Array(titles.length);
        const tabHandlingTabindex = (_a = this._getCurrentTabindex()) !== null && _a !== void 0 ? _a : this._currentIndex > -1 ? this._currentIndex : 0;
        for (let i = 0, n = titles.length; i < n; ++i) {
          let title = titles[i];
          let current = title === currentTitle;
          let zIndex = current ? n : n - i - 1;
          let tabIndex = tabHandlingTabindex === i ? 0 : -1;
          content[i] = renderer.renderTab({ title, current, zIndex, tabIndex });
        }
        VirtualDOM.render(content, this.contentNode);
      }
      /**
       * Get the index of the tab which handles tabindex="0".
       * If the add button handles tabindex="0", -1 is returned.
       * If none of the previous handles tabindex="0", null is returned.
       */
      _getCurrentTabindex() {
        let index = null;
        const elemTabindex = this.contentNode.querySelector('li[tabindex="0"]');
        if (elemTabindex) {
          index = [...this.contentNode.children].indexOf(elemTabindex);
        } else if (this._addButtonEnabled && this.addButtonNode.getAttribute("tabindex") === "0") {
          index = -1;
        }
        return index;
      }
      /**
       * Handle the `'dblclick'` event for the tab bar.
       */
      _evtDblClick(event) {
        if (!this.titlesEditable) {
          return;
        }
        let tabs = this.contentNode.children;
        let index = ArrayExt3.findFirstIndex(tabs, (tab) => {
          return ElementExt.hitTest(tab, event.clientX, event.clientY);
        });
        if (index === -1) {
          return;
        }
        let title = this.titles[index];
        let label = tabs[index].querySelector(".lm-TabBar-tabLabel");
        if (label && label.contains(event.target)) {
          let value = title.label || "";
          let oldValue = label.innerHTML;
          label.innerHTML = "";
          let input = document.createElement("input");
          input.classList.add("lm-TabBar-tabInput");
          input.value = value;
          label.appendChild(input);
          let onblur = () => {
            input.removeEventListener("blur", onblur);
            label.innerHTML = oldValue;
            this.node.addEventListener("keydown", this);
          };
          input.addEventListener("dblclick", (event2) => event2.stopPropagation());
          input.addEventListener("blur", onblur);
          input.addEventListener("keydown", (event2) => {
            if (event2.key === "Enter") {
              if (input.value !== "") {
                title.label = title.caption = input.value;
              }
              onblur();
            } else if (event2.key === "Escape") {
              onblur();
            }
          });
          this.node.removeEventListener("keydown", this);
          input.select();
          input.focus();
          if (label.children.length > 0) {
            label.children[0].focus();
          }
        }
      }
      /**
       * Handle the `'keydown'` event for the tab bar at capturing phase.
       */
      _evtKeyDownCapturing(event) {
        if (event.eventPhase !== Event.CAPTURING_PHASE) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (event.key === "Escape") {
          this._releaseMouse();
        }
      }
      /**
       * Handle the `'keydown'` event for the tab bar at target phase.
       */
      _evtKeyDown(event) {
        var _a, _b, _c;
        if (event.key === "Tab" || event.eventPhase === Event.CAPTURING_PHASE) {
          return;
        }
        if (event.key === "Enter" || event.key === "Spacebar" || event.key === " ") {
          const focusedElement = document.activeElement;
          if (this.addButtonEnabled && this.addButtonNode.contains(focusedElement)) {
            event.preventDefault();
            event.stopPropagation();
            this._addRequested.emit();
          } else {
            const index = ArrayExt3.findFirstIndex(this.contentNode.children, (tab) => tab.contains(focusedElement));
            if (index >= 0) {
              event.preventDefault();
              event.stopPropagation();
              this.currentIndex = index;
            }
          }
        } else if (ARROW_KEYS.includes(event.key)) {
          const focusable = [...this.contentNode.children];
          if (this.addButtonEnabled) {
            focusable.push(this.addButtonNode);
          }
          if (focusable.length <= 1) {
            return;
          }
          event.preventDefault();
          event.stopPropagation();
          let focusedIndex = focusable.indexOf(document.activeElement);
          if (focusedIndex === -1) {
            focusedIndex = this._currentIndex;
          }
          let nextFocused;
          if (event.key === "ArrowRight" && this._orientation === "horizontal" || event.key === "ArrowDown" && this._orientation === "vertical") {
            nextFocused = (_a = focusable[focusedIndex + 1]) !== null && _a !== void 0 ? _a : focusable[0];
          } else if (event.key === "ArrowLeft" && this._orientation === "horizontal" || event.key === "ArrowUp" && this._orientation === "vertical") {
            nextFocused = (_b = focusable[focusedIndex - 1]) !== null && _b !== void 0 ? _b : focusable[focusable.length - 1];
          } else if (event.key === "Home") {
            nextFocused = focusable[0];
          } else if (event.key === "End") {
            nextFocused = focusable[focusable.length - 1];
          }
          if (nextFocused) {
            (_c = focusable[focusedIndex]) === null || _c === void 0 ? void 0 : _c.setAttribute("tabindex", "-1");
            nextFocused === null || nextFocused === void 0 ? void 0 : nextFocused.setAttribute("tabindex", "0");
            nextFocused.focus();
          }
        }
      }
      /**
       * Handle the `'pointerdown'` event for the tab bar.
       */
      _evtPointerDown(event) {
        if (event.button !== 0 && event.button !== 1) {
          return;
        }
        if (this._dragData) {
          return;
        }
        if (event.target.classList.contains("lm-TabBar-tabInput")) {
          return;
        }
        let addButtonClicked = this.addButtonEnabled && this.addButtonNode.contains(event.target);
        let tabs = this.contentNode.children;
        let index = ArrayExt3.findFirstIndex(tabs, (tab) => {
          return ElementExt.hitTest(tab, event.clientX, event.clientY);
        });
        if (index === -1 && !addButtonClicked) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._dragData = {
          tab: tabs[index],
          index,
          pressX: event.clientX,
          pressY: event.clientY,
          tabPos: -1,
          tabSize: -1,
          tabPressPos: -1,
          targetIndex: -1,
          tabLayout: null,
          contentRect: null,
          override: null,
          dragActive: false,
          dragAborted: false,
          detachRequested: false
        };
        this.document.addEventListener("pointerup", this, true);
        if (event.button === 1 || addButtonClicked) {
          return;
        }
        let icon = tabs[index].querySelector(this.renderer.closeIconSelector);
        if (icon && icon.contains(event.target)) {
          return;
        }
        if (this.tabsMovable) {
          this.document.addEventListener("pointermove", this, true);
          this.document.addEventListener("keydown", this, true);
          this.document.addEventListener("contextmenu", this, true);
        }
        if (this.allowDeselect && this.currentIndex === index) {
          this.currentIndex = -1;
        } else {
          this.currentIndex = index;
        }
        if (this.currentIndex === -1) {
          return;
        }
        this._tabActivateRequested.emit({
          index: this.currentIndex,
          title: this.currentTitle
        });
      }
      /**
       * Handle the `'pointermove'` event for the tab bar.
       */
      _evtPointerMove(event) {
        let data = this._dragData;
        if (!data) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        let tabs = this.contentNode.children;
        if (!data.dragActive && !Private$7.dragExceeded(data, event)) {
          return;
        }
        if (!data.dragActive) {
          let tabRect = data.tab.getBoundingClientRect();
          if (this._orientation === "horizontal") {
            data.tabPos = data.tab.offsetLeft;
            data.tabSize = tabRect.width;
            data.tabPressPos = data.pressX - tabRect.left;
          } else {
            data.tabPos = data.tab.offsetTop;
            data.tabSize = tabRect.height;
            data.tabPressPos = data.pressY - tabRect.top;
          }
          data.tabPressOffset = {
            x: data.pressX - tabRect.left,
            y: data.pressY - tabRect.top
          };
          data.tabLayout = Private$7.snapTabLayout(tabs, this._orientation);
          data.contentRect = this.contentNode.getBoundingClientRect();
          data.override = Drag.overrideCursor("default");
          data.tab.classList.add("lm-mod-dragging");
          this.addClass("lm-mod-dragging");
          data.dragActive = true;
        }
        if (!data.detachRequested && Private$7.detachExceeded(data, event)) {
          data.detachRequested = true;
          let index = data.index;
          let clientX = event.clientX;
          let clientY = event.clientY;
          let tab = tabs[index];
          let title = this._titles[index];
          this._tabDetachRequested.emit({
            index,
            title,
            tab,
            clientX,
            clientY,
            offset: data.tabPressOffset
          });
          if (data.dragAborted) {
            return;
          }
        }
        Private$7.layoutTabs(tabs, data, event, this._orientation);
      }
      /**
       * Handle the `'pointerup'` event for the document.
       */
      _evtPointerUp(event) {
        if (event.button !== 0 && event.button !== 1) {
          return;
        }
        const data = this._dragData;
        if (!data) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.document.removeEventListener("pointermove", this, true);
        this.document.removeEventListener("pointerup", this, true);
        this.document.removeEventListener("keydown", this, true);
        this.document.removeEventListener("contextmenu", this, true);
        if (!data.dragActive) {
          this._dragData = null;
          let addButtonClicked = this.addButtonEnabled && this.addButtonNode.contains(event.target);
          if (addButtonClicked) {
            this._addRequested.emit(void 0);
            return;
          }
          let tabs = this.contentNode.children;
          let index = ArrayExt3.findFirstIndex(tabs, (tab) => {
            return ElementExt.hitTest(tab, event.clientX, event.clientY);
          });
          if (index !== data.index) {
            return;
          }
          let title = this._titles[index];
          if (!title.closable) {
            return;
          }
          if (event.button === 1) {
            this._tabCloseRequested.emit({ index, title });
            return;
          }
          let icon = tabs[index].querySelector(this.renderer.closeIconSelector);
          if (icon && icon.contains(event.target)) {
            this._tabCloseRequested.emit({ index, title });
            return;
          }
          return;
        }
        if (event.button !== 0) {
          return;
        }
        Private$7.finalizeTabPosition(data, this._orientation);
        data.tab.classList.remove("lm-mod-dragging");
        let duration = Private$7.parseTransitionDuration(data.tab);
        setTimeout(() => {
          if (data.dragAborted) {
            return;
          }
          this._dragData = null;
          Private$7.resetTabPositions(this.contentNode.children, this._orientation);
          data.override.dispose();
          this.removeClass("lm-mod-dragging");
          let i = data.index;
          let j = data.targetIndex;
          if (j === -1 || i === j) {
            return;
          }
          ArrayExt3.move(this._titles, i, j);
          this._adjustCurrentForMove(i, j);
          this._tabMoved.emit({
            fromIndex: i,
            toIndex: j,
            title: this._titles[j]
          });
          MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);
        }, duration);
      }
      /**
       * Release the mouse and restore the non-dragged tab positions.
       */
      _releaseMouse() {
        let data = this._dragData;
        if (!data) {
          return;
        }
        this._dragData = null;
        this.document.removeEventListener("pointermove", this, true);
        this.document.removeEventListener("pointerup", this, true);
        this.document.removeEventListener("keydown", this, true);
        this.document.removeEventListener("contextmenu", this, true);
        data.dragAborted = true;
        if (!data.dragActive) {
          return;
        }
        Private$7.resetTabPositions(this.contentNode.children, this._orientation);
        data.override.dispose();
        data.tab.classList.remove("lm-mod-dragging");
        this.removeClass("lm-mod-dragging");
      }
      /**
       * Adjust the current index for a tab insert operation.
       *
       * This method accounts for the tab bar's insertion behavior when
       * adjusting the current index and emitting the changed signal.
       */
      _adjustCurrentForInsert(i, title) {
        let ct = this.currentTitle;
        let ci = this._currentIndex;
        let bh = this.insertBehavior;
        if (bh === "select-tab" || bh === "select-tab-if-needed" && ci === -1) {
          this._currentIndex = i;
          this._previousTitle = ct;
          this._currentChanged.emit({
            previousIndex: ci,
            previousTitle: ct,
            currentIndex: i,
            currentTitle: title
          });
          return;
        }
        if (ci >= i) {
          this._currentIndex++;
        }
      }
      /**
       * Adjust the current index for a tab move operation.
       *
       * This method will not cause the actual current tab to change.
       * It silently adjusts the index to account for the given move.
       */
      _adjustCurrentForMove(i, j) {
        if (this._currentIndex === i) {
          this._currentIndex = j;
        } else if (this._currentIndex < i && this._currentIndex >= j) {
          this._currentIndex++;
        } else if (this._currentIndex > i && this._currentIndex <= j) {
          this._currentIndex--;
        }
      }
      /**
       * Adjust the current index for a tab remove operation.
       *
       * This method accounts for the tab bar's remove behavior when
       * adjusting the current index and emitting the changed signal.
       */
      _adjustCurrentForRemove(i, title) {
        let ci = this._currentIndex;
        let bh = this.removeBehavior;
        if (ci !== i) {
          if (ci > i) {
            this._currentIndex--;
          }
          return;
        }
        if (this._titles.length === 0) {
          this._currentIndex = -1;
          this._currentChanged.emit({
            previousIndex: i,
            previousTitle: title,
            currentIndex: -1,
            currentTitle: null
          });
          return;
        }
        if (bh === "select-tab-after") {
          this._currentIndex = Math.min(i, this._titles.length - 1);
          this._currentChanged.emit({
            previousIndex: i,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        if (bh === "select-tab-before") {
          this._currentIndex = Math.max(0, i - 1);
          this._currentChanged.emit({
            previousIndex: i,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        if (bh === "select-previous-tab") {
          if (this._previousTitle) {
            this._currentIndex = this._titles.indexOf(this._previousTitle);
            this._previousTitle = null;
          } else {
            this._currentIndex = Math.min(i, this._titles.length - 1);
          }
          this._currentChanged.emit({
            previousIndex: i,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        this._currentIndex = -1;
        this._currentChanged.emit({
          previousIndex: i,
          previousTitle: title,
          currentIndex: -1,
          currentTitle: null
        });
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        this.update();
      }
    };
    (function(TabBar2) {
      class Renderer {
        constructor() {
          this.closeIconSelector = ".lm-TabBar-tabCloseIcon";
          this._tabID = 0;
          this._tabKeys = /* @__PURE__ */ new WeakMap();
          this._uuid = ++Renderer._nInstance;
        }
        /**
         * Render the virtual element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab.
         */
        renderTab(data) {
          let title = data.title.caption;
          let key2 = this.createTabKey(data);
          let id = key2;
          let style = this.createTabStyle(data);
          let className = this.createTabClass(data);
          let dataset = this.createTabDataset(data);
          let aria = this.createTabARIA(data);
          if (data.title.closable) {
            return h.li({ id, key: key2, className, title, style, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data), this.renderCloseIcon(data));
          } else {
            return h.li({ id, key: key2, className, title, style, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data));
          }
        }
        /**
         * Render the icon element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab icon.
         */
        renderIcon(data) {
          const { title } = data;
          let className = this.createIconClass(data);
          return h.div({ className }, title.icon, title.iconLabel);
        }
        /**
         * Render the label element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab label.
         */
        renderLabel(data) {
          return h.div({ className: "lm-TabBar-tabLabel" }, data.title.label);
        }
        /**
         * Render the close icon element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab close icon.
         */
        renderCloseIcon(data) {
          return h.div({ className: "lm-TabBar-tabCloseIcon" });
        }
        /**
         * Create a unique render key for the tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The unique render key for the tab.
         *
         * #### Notes
         * This method caches the key against the tab title the first time
         * the key is generated. This enables efficient rendering of moved
         * tabs and avoids subtle hover style artifacts.
         */
        createTabKey(data) {
          let key2 = this._tabKeys.get(data.title);
          if (key2 === void 0) {
            key2 = `tab-key-${this._uuid}-${this._tabID++}`;
            this._tabKeys.set(data.title, key2);
          }
          return key2;
        }
        /**
         * Create the inline style object for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The inline style data for the tab.
         */
        createTabStyle(data) {
          return { zIndex: `${data.zIndex}` };
        }
        /**
         * Create the class name for the tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The full class name for the tab.
         */
        createTabClass(data) {
          let name2 = "lm-TabBar-tab";
          if (data.title.className) {
            name2 += ` ${data.title.className}`;
          }
          if (data.title.closable) {
            name2 += " lm-mod-closable";
          }
          if (data.current) {
            name2 += " lm-mod-current";
          }
          return name2;
        }
        /**
         * Create the dataset for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The dataset for the tab.
         */
        createTabDataset(data) {
          return data.title.dataset;
        }
        /**
         * Create the ARIA attributes for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The ARIA attributes for the tab.
         */
        createTabARIA(data) {
          var _a;
          return {
            role: "tab",
            "aria-selected": data.current.toString(),
            tabindex: `${(_a = data.tabIndex) !== null && _a !== void 0 ? _a : "-1"}`
          };
        }
        /**
         * Create the class name for the tab icon.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The full class name for the tab icon.
         */
        createIconClass(data) {
          let name2 = "lm-TabBar-tabIcon";
          let extra = data.title.iconClass;
          return extra ? `${name2} ${extra}` : name2;
        }
      }
      Renderer._nInstance = 0;
      TabBar2.Renderer = Renderer;
      TabBar2.defaultRenderer = new Renderer();
      TabBar2.addButtonSelector = ".lm-TabBar-addButton";
    })(TabBar || (TabBar = {}));
    (function(Private36) {
      Private36.DRAG_THRESHOLD = 5;
      Private36.DETACH_THRESHOLD = 20;
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.setAttribute("role", "tablist");
        content.className = "lm-TabBar-content";
        node.appendChild(content);
        let add = document.createElement("div");
        add.className = "lm-TabBar-addButton lm-mod-hidden";
        add.setAttribute("tabindex", "-1");
        add.setAttribute("role", "button");
        node.appendChild(add);
        return node;
      }
      Private36.createNode = createNode;
      function asTitle(value) {
        return value instanceof Title ? value : new Title(value);
      }
      Private36.asTitle = asTitle;
      function parseTransitionDuration(tab) {
        let style = window.getComputedStyle(tab);
        return 1e3 * (parseFloat(style.transitionDuration) || 0);
      }
      Private36.parseTransitionDuration = parseTransitionDuration;
      function snapTabLayout(tabs, orientation) {
        let layout = new Array(tabs.length);
        for (let i = 0, n = tabs.length; i < n; ++i) {
          let node = tabs[i];
          let style = window.getComputedStyle(node);
          if (orientation === "horizontal") {
            layout[i] = {
              pos: node.offsetLeft,
              size: node.offsetWidth,
              margin: parseFloat(style.marginLeft) || 0
            };
          } else {
            layout[i] = {
              pos: node.offsetTop,
              size: node.offsetHeight,
              margin: parseFloat(style.marginTop) || 0
            };
          }
        }
        return layout;
      }
      Private36.snapTabLayout = snapTabLayout;
      function dragExceeded(data, event) {
        let dx = Math.abs(event.clientX - data.pressX);
        let dy = Math.abs(event.clientY - data.pressY);
        return dx >= Private36.DRAG_THRESHOLD || dy >= Private36.DRAG_THRESHOLD;
      }
      Private36.dragExceeded = dragExceeded;
      function detachExceeded(data, event) {
        let rect = data.contentRect;
        return event.clientX < rect.left - Private36.DETACH_THRESHOLD || event.clientX >= rect.right + Private36.DETACH_THRESHOLD || event.clientY < rect.top - Private36.DETACH_THRESHOLD || event.clientY >= rect.bottom + Private36.DETACH_THRESHOLD;
      }
      Private36.detachExceeded = detachExceeded;
      function layoutTabs(tabs, data, event, orientation) {
        let pressPos;
        let localPos;
        let clientPos;
        let clientSize;
        if (orientation === "horizontal") {
          pressPos = data.pressX;
          localPos = event.clientX - data.contentRect.left;
          clientPos = event.clientX;
          clientSize = data.contentRect.width;
        } else {
          pressPos = data.pressY;
          localPos = event.clientY - data.contentRect.top;
          clientPos = event.clientY;
          clientSize = data.contentRect.height;
        }
        let targetIndex = data.index;
        let targetPos = localPos - data.tabPressPos;
        let targetEnd = targetPos + data.tabSize;
        for (let i = 0, n = tabs.length; i < n; ++i) {
          let pxPos;
          let layout = data.tabLayout[i];
          let threshold = layout.pos + (layout.size >> 1);
          if (i < data.index && targetPos < threshold) {
            pxPos = `${data.tabSize + data.tabLayout[i + 1].margin}px`;
            targetIndex = Math.min(targetIndex, i);
          } else if (i > data.index && targetEnd > threshold) {
            pxPos = `${-data.tabSize - layout.margin}px`;
            targetIndex = Math.max(targetIndex, i);
          } else if (i === data.index) {
            let ideal = clientPos - pressPos;
            let limit2 = clientSize - (data.tabPos + data.tabSize);
            pxPos = `${Math.max(-data.tabPos, Math.min(ideal, limit2))}px`;
          } else {
            pxPos = "";
          }
          if (orientation === "horizontal") {
            tabs[i].style.left = pxPos;
          } else {
            tabs[i].style.top = pxPos;
          }
        }
        data.targetIndex = targetIndex;
      }
      Private36.layoutTabs = layoutTabs;
      function finalizeTabPosition(data, orientation) {
        let clientSize;
        if (orientation === "horizontal") {
          clientSize = data.contentRect.width;
        } else {
          clientSize = data.contentRect.height;
        }
        let ideal;
        if (data.targetIndex === data.index) {
          ideal = 0;
        } else if (data.targetIndex > data.index) {
          let tgt = data.tabLayout[data.targetIndex];
          ideal = tgt.pos + tgt.size - data.tabSize - data.tabPos;
        } else {
          let tgt = data.tabLayout[data.targetIndex];
          ideal = tgt.pos - data.tabPos;
        }
        let limit2 = clientSize - (data.tabPos + data.tabSize);
        let final = Math.max(-data.tabPos, Math.min(ideal, limit2));
        if (orientation === "horizontal") {
          data.tab.style.left = `${final}px`;
        } else {
          data.tab.style.top = `${final}px`;
        }
      }
      Private36.finalizeTabPosition = finalizeTabPosition;
      function resetTabPositions(tabs, orientation) {
        for (const tab of tabs) {
          if (orientation === "horizontal") {
            tab.style.left = "";
          } else {
            tab.style.top = "";
          }
        }
      }
      Private36.resetTabPositions = resetTabPositions;
    })(Private$7 || (Private$7 = {}));
    DockLayout = class extends Layout {
      /**
       * Construct a new dock layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options) {
        super();
        this._spacing = 4;
        this._dirty = false;
        this._root = null;
        this._box = null;
        this._items = /* @__PURE__ */ new Map();
        this.renderer = options.renderer;
        if (options.spacing !== void 0) {
          this._spacing = Utils$1.clampDimension(options.spacing);
        }
        this._document = options.document || document;
        this._hiddenMode = options.hiddenMode !== void 0 ? options.hiddenMode : Widget.HiddenMode.Display;
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This will clear and dispose all widgets in the layout.
       */
      dispose() {
        let widgets = this[Symbol.iterator]();
        this._items.forEach((item) => {
          item.dispose();
        });
        this._box = null;
        this._root = null;
        this._items.clear();
        for (const widget of widgets) {
          widget.dispose();
        }
        super.dispose();
      }
      /**
       * The method for hiding child widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      set hiddenMode(v) {
        if (this._hiddenMode === v) {
          return;
        }
        this._hiddenMode = v;
        for (const bar of this.tabBars()) {
          if (bar.titles.length > 1) {
            for (const title of bar.titles) {
              title.owner.hiddenMode = this._hiddenMode;
            }
          }
        }
      }
      /**
       * Get the inter-element spacing for the dock layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the dock layout.
       */
      set spacing(value) {
        value = Utils$1.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * Whether the dock layout is empty.
       */
      get isEmpty() {
        return this._root === null;
      }
      /**
       * Create an iterator over all widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       *
       * #### Notes
       * This iterator includes the generated tab bars.
       */
      [Symbol.iterator]() {
        return this._root ? this._root.iterAllWidgets() : empty();
      }
      /**
       * Create an iterator over the user widgets in the layout.
       *
       * @returns A new iterator over the user widgets in the layout.
       *
       * #### Notes
       * This iterator does not include the generated tab bars.
       */
      widgets() {
        return this._root ? this._root.iterUserWidgets() : empty();
      }
      /**
       * Create an iterator over the selected widgets in the layout.
       *
       * @returns A new iterator over the selected user widgets.
       *
       * #### Notes
       * This iterator yields the widgets corresponding to the current tab
       * of each tab bar in the layout.
       */
      selectedWidgets() {
        return this._root ? this._root.iterSelectedWidgets() : empty();
      }
      /**
       * Create an iterator over the tab bars in the layout.
       *
       * @returns A new iterator over the tab bars in the layout.
       *
       * #### Notes
       * This iterator does not include the user widgets.
       */
      tabBars() {
        return this._root ? this._root.iterTabBars() : empty();
      }
      /**
       * Create an iterator over the handles in the layout.
       *
       * @returns A new iterator over the handles in the layout.
       */
      handles() {
        return this._root ? this._root.iterHandles() : empty();
      }
      /**
       * Move a handle to the given offset position.
       *
       * @param handle - The handle to move.
       *
       * @param offsetX - The desired offset X position of the handle.
       *
       * @param offsetY - The desired offset Y position of the handle.
       *
       * #### Notes
       * If the given handle is not contained in the layout, this is no-op.
       *
       * The handle will be moved as close as possible to the desired
       * position without violating any of the layout constraints.
       *
       * Only one of the coordinates is used depending on the orientation
       * of the handle. This method accepts both coordinates to make it
       * easy to invoke from a mouse move event without needing to know
       * the handle orientation.
       */
      moveHandle(handle, offsetX, offsetY) {
        let hidden2 = handle.classList.contains("lm-mod-hidden");
        if (!this._root || hidden2) {
          return;
        }
        let data = this._root.findSplitNode(handle);
        if (!data) {
          return;
        }
        let delta;
        if (data.node.orientation === "horizontal") {
          delta = offsetX - handle.offsetLeft;
        } else {
          delta = offsetY - handle.offsetTop;
        }
        if (delta === 0) {
          return;
        }
        data.node.holdSizes();
        BoxEngine.adjust(data.node.sizers, data.index, delta);
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Save the current configuration of the dock layout.
       *
       * @returns A new config object for the current layout state.
       *
       * #### Notes
       * The return value can be provided to the `restoreLayout` method
       * in order to restore the layout to its current configuration.
       */
      saveLayout() {
        if (!this._root) {
          return { main: null };
        }
        this._root.holdAllSizes();
        return { main: this._root.createConfig() };
      }
      /**
       * Restore the layout to a previously saved configuration.
       *
       * @param config - The layout configuration to restore.
       *
       * #### Notes
       * Widgets which currently belong to the layout but which are not
       * contained in the config will be unparented.
       */
      restoreLayout(config) {
        let widgetSet = /* @__PURE__ */ new Set();
        let mainConfig;
        if (config.main) {
          mainConfig = Private$6.normalizeAreaConfig(config.main, widgetSet);
        } else {
          mainConfig = null;
        }
        let oldWidgets = this.widgets();
        let oldTabBars = this.tabBars();
        let oldHandles = this.handles();
        this._root = null;
        for (const widget of oldWidgets) {
          if (!widgetSet.has(widget)) {
            widget.parent = null;
          }
        }
        for (const tabBar of oldTabBars) {
          tabBar.dispose();
        }
        for (const handle of oldHandles) {
          if (handle.parentNode) {
            handle.parentNode.removeChild(handle);
          }
        }
        for (const widget of widgetSet) {
          widget.parent = this.parent;
        }
        if (mainConfig) {
          this._root = Private$6.realizeAreaConfig(mainConfig, {
            // Ignoring optional `document` argument as we must reuse `this._document`
            createTabBar: (document2) => this._createTabBar(),
            createHandle: () => this._createHandle()
          }, this._document);
        } else {
          this._root = null;
        }
        if (!this.parent) {
          return;
        }
        widgetSet.forEach((widget) => {
          this.attachWidget(widget);
        });
        this.parent.fit();
      }
      /**
       * Add a widget to the dock layout.
       *
       * @param widget - The widget to add to the dock layout.
       *
       * @param options - The additional options for adding the widget.
       *
       * #### Notes
       * The widget will be moved if it is already contained in the layout.
       *
       * An error will be thrown if the reference widget is invalid.
       */
      addWidget(widget, options = {}) {
        let ref2 = options.ref || null;
        let mode = options.mode || "tab-after";
        let refNode = null;
        if (this._root && ref2) {
          refNode = this._root.findTabNode(ref2);
        }
        if (ref2 && !refNode) {
          throw new Error("Reference widget is not in the layout.");
        }
        widget.parent = this.parent;
        switch (mode) {
          case "tab-after":
            this._insertTab(widget, ref2, refNode, true);
            break;
          case "tab-before":
            this._insertTab(widget, ref2, refNode, false);
            break;
          case "split-top":
            this._insertSplit(widget, ref2, refNode, "vertical", false);
            break;
          case "split-left":
            this._insertSplit(widget, ref2, refNode, "horizontal", false);
            break;
          case "split-right":
            this._insertSplit(widget, ref2, refNode, "horizontal", true);
            break;
          case "split-bottom":
            this._insertSplit(widget, ref2, refNode, "vertical", true);
            break;
          case "merge-top":
            this._insertSplit(widget, ref2, refNode, "vertical", false, true);
            break;
          case "merge-left":
            this._insertSplit(widget, ref2, refNode, "horizontal", false, true);
            break;
          case "merge-right":
            this._insertSplit(widget, ref2, refNode, "horizontal", true, true);
            break;
          case "merge-bottom":
            this._insertSplit(widget, ref2, refNode, "vertical", true, true);
            break;
        }
        if (!this.parent) {
          return;
        }
        this.attachWidget(widget);
        this.parent.fit();
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        this._removeWidget(widget);
        if (!this.parent) {
          return;
        }
        this.detachWidget(widget);
        this.parent.fit();
      }
      /**
       * Find the tab area which contains the given client position.
       *
       * @param clientX - The client X position of interest.
       *
       * @param clientY - The client Y position of interest.
       *
       * @returns The geometry of the tab area at the given position, or
       *   `null` if there is no tab area at the given position.
       */
      hitTestTabAreas(clientX, clientY) {
        if (!this._root || !this.parent || !this.parent.isVisible) {
          return null;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let rect = this.parent.node.getBoundingClientRect();
        let x = clientX - rect.left - this._box.borderLeft;
        let y = clientY - rect.top - this._box.borderTop;
        let tabNode = this._root.hitTestTabNodes(x, y);
        if (!tabNode) {
          return null;
        }
        let { tabBar, top, left, width, height } = tabNode;
        let borderWidth = this._box.borderLeft + this._box.borderRight;
        let borderHeight = this._box.borderTop + this._box.borderBottom;
        let right = rect.width - borderWidth - (left + width);
        let bottom = rect.height - borderHeight - (top + height);
        return { tabBar, x, y, top, left, right, bottom, width, height };
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
        for (const handle of this.handles()) {
          this.parent.node.appendChild(handle);
        }
        this.parent.fit();
      }
      /**
       * Attach the widget to the layout parent widget.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a no-op if the widget is already attached.
       */
      attachWidget(widget) {
        if (this.parent.node === widget.node.parentNode) {
          return;
        }
        this._items.set(widget, new LayoutItem(widget));
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
      }
      /**
       * Detach the widget from the layout parent widget.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a no-op if the widget is not attached.
       */
      detachWidget(widget) {
        if (this.parent.node !== widget.node.parentNode) {
          return;
        }
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
        let item = this._items.get(widget);
        if (item) {
          this._items.delete(widget);
          item.dispose();
        }
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Remove the specified widget from the layout structure.
       *
       * #### Notes
       * This is a no-op if the widget is not in the layout tree.
       *
       * This does not detach the widget from the parent node.
       */
      _removeWidget(widget) {
        if (!this._root) {
          return;
        }
        let tabNode = this._root.findTabNode(widget);
        if (!tabNode) {
          return;
        }
        Private$6.removeAria(widget);
        if (tabNode.tabBar.titles.length > 1) {
          tabNode.tabBar.removeTab(widget.title);
          if (this._hiddenMode === Widget.HiddenMode.Scale && tabNode.tabBar.titles.length == 1) {
            const existingWidget = tabNode.tabBar.titles[0].owner;
            existingWidget.hiddenMode = Widget.HiddenMode.Display;
          }
          return;
        }
        tabNode.tabBar.dispose();
        if (this._root === tabNode) {
          this._root = null;
          return;
        }
        this._root.holdAllSizes();
        let splitNode = tabNode.parent;
        tabNode.parent = null;
        let i = ArrayExt3.removeFirstOf(splitNode.children, tabNode);
        let handle = ArrayExt3.removeAt(splitNode.handles, i);
        ArrayExt3.removeAt(splitNode.sizers, i);
        if (handle.parentNode) {
          handle.parentNode.removeChild(handle);
        }
        if (splitNode.children.length > 1) {
          splitNode.syncHandles();
          return;
        }
        let maybeParent = splitNode.parent;
        splitNode.parent = null;
        let childNode = splitNode.children[0];
        let childHandle = splitNode.handles[0];
        splitNode.children.length = 0;
        splitNode.handles.length = 0;
        splitNode.sizers.length = 0;
        if (childHandle.parentNode) {
          childHandle.parentNode.removeChild(childHandle);
        }
        if (this._root === splitNode) {
          childNode.parent = null;
          this._root = childNode;
          return;
        }
        let parentNode = maybeParent;
        let j = parentNode.children.indexOf(splitNode);
        if (childNode instanceof Private$6.TabLayoutNode) {
          childNode.parent = parentNode;
          parentNode.children[j] = childNode;
          return;
        }
        let splitHandle = ArrayExt3.removeAt(parentNode.handles, j);
        ArrayExt3.removeAt(parentNode.children, j);
        ArrayExt3.removeAt(parentNode.sizers, j);
        if (splitHandle.parentNode) {
          splitHandle.parentNode.removeChild(splitHandle);
        }
        for (let i2 = 0, n = childNode.children.length; i2 < n; ++i2) {
          let gChild = childNode.children[i2];
          let gHandle = childNode.handles[i2];
          let gSizer = childNode.sizers[i2];
          ArrayExt3.insert(parentNode.children, j + i2, gChild);
          ArrayExt3.insert(parentNode.handles, j + i2, gHandle);
          ArrayExt3.insert(parentNode.sizers, j + i2, gSizer);
          gChild.parent = parentNode;
        }
        childNode.children.length = 0;
        childNode.handles.length = 0;
        childNode.sizers.length = 0;
        childNode.parent = null;
        parentNode.syncHandles();
      }
      /**
       * Create the tab layout node to hold the widget.
       */
      _createTabNode(widget) {
        let tabNode = new Private$6.TabLayoutNode(this._createTabBar());
        tabNode.tabBar.addTab(widget.title);
        Private$6.addAria(widget, tabNode.tabBar);
        return tabNode;
      }
      /**
       * Insert a widget next to an existing tab.
       *
       * #### Notes
       * This does not attach the widget to the parent widget.
       */
      _insertTab(widget, ref2, refNode, after) {
        if (widget === ref2) {
          return;
        }
        if (!this._root) {
          let tabNode = new Private$6.TabLayoutNode(this._createTabBar());
          tabNode.tabBar.addTab(widget.title);
          this._root = tabNode;
          Private$6.addAria(widget, tabNode.tabBar);
          return;
        }
        if (!refNode) {
          refNode = this._root.findFirstTabNode();
        }
        if (refNode.tabBar.titles.indexOf(widget.title) === -1) {
          this._removeWidget(widget);
          widget.hide();
        }
        let index;
        if (ref2) {
          index = refNode.tabBar.titles.indexOf(ref2.title);
        } else {
          index = refNode.tabBar.currentIndex;
        }
        if (this._hiddenMode === Widget.HiddenMode.Scale) {
          if (refNode.tabBar.titles.length === 0) {
            widget.hiddenMode = Widget.HiddenMode.Display;
          } else if (refNode.tabBar.titles.length == 1) {
            const existingWidget = refNode.tabBar.titles[0].owner;
            existingWidget.hiddenMode = Widget.HiddenMode.Scale;
          } else {
            widget.hiddenMode = Widget.HiddenMode.Scale;
          }
        } else {
          widget.hiddenMode = this._hiddenMode;
        }
        refNode.tabBar.insertTab(index + (after ? 1 : 0), widget.title);
        Private$6.addAria(widget, refNode.tabBar);
      }
      /**
       * Insert a widget as a new split area.
       *
       * #### Notes
       * This does not attach the widget to the parent widget.
       */
      _insertSplit(widget, ref2, refNode, orientation, after, merge2 = false) {
        if (widget === ref2 && refNode && refNode.tabBar.titles.length === 1) {
          return;
        }
        this._removeWidget(widget);
        if (!this._root) {
          this._root = this._createTabNode(widget);
          return;
        }
        if (!refNode || !refNode.parent) {
          let root = this._splitRoot(orientation);
          let i2 = after ? root.children.length : 0;
          root.normalizeSizes();
          let sizer = Private$6.createSizer(refNode ? 1 : Private$6.GOLDEN_RATIO);
          let tabNode2 = this._createTabNode(widget);
          ArrayExt3.insert(root.children, i2, tabNode2);
          ArrayExt3.insert(root.sizers, i2, sizer);
          ArrayExt3.insert(root.handles, i2, this._createHandle());
          tabNode2.parent = root;
          root.normalizeSizes();
          root.syncHandles();
          return;
        }
        let splitNode = refNode.parent;
        if (splitNode.orientation === orientation) {
          let i2 = splitNode.children.indexOf(refNode);
          if (merge2) {
            let j3 = i2 + (after ? 1 : -1);
            let sibling = splitNode.children[j3];
            if (sibling instanceof Private$6.TabLayoutNode) {
              this._insertTab(widget, null, sibling, true);
              ++sibling.tabBar.currentIndex;
              return;
            }
          }
          splitNode.normalizeSizes();
          let s = splitNode.sizers[i2].sizeHint /= 2;
          let j2 = i2 + (after ? 1 : 0);
          let tabNode2 = this._createTabNode(widget);
          ArrayExt3.insert(splitNode.children, j2, tabNode2);
          ArrayExt3.insert(splitNode.sizers, j2, Private$6.createSizer(s));
          ArrayExt3.insert(splitNode.handles, j2, this._createHandle());
          tabNode2.parent = splitNode;
          splitNode.syncHandles();
          return;
        }
        let i = ArrayExt3.removeFirstOf(splitNode.children, refNode);
        let childNode = new Private$6.SplitLayoutNode(orientation);
        childNode.normalized = true;
        childNode.children.push(refNode);
        childNode.sizers.push(Private$6.createSizer(0.5));
        childNode.handles.push(this._createHandle());
        refNode.parent = childNode;
        let j = after ? 1 : 0;
        let tabNode = this._createTabNode(widget);
        ArrayExt3.insert(childNode.children, j, tabNode);
        ArrayExt3.insert(childNode.sizers, j, Private$6.createSizer(0.5));
        ArrayExt3.insert(childNode.handles, j, this._createHandle());
        tabNode.parent = childNode;
        childNode.syncHandles();
        ArrayExt3.insert(splitNode.children, i, childNode);
        childNode.parent = splitNode;
      }
      /**
       * Ensure the root is a split node with the given orientation.
       */
      _splitRoot(orientation) {
        let oldRoot = this._root;
        if (oldRoot instanceof Private$6.SplitLayoutNode) {
          if (oldRoot.orientation === orientation) {
            return oldRoot;
          }
        }
        let newRoot = this._root = new Private$6.SplitLayoutNode(orientation);
        if (oldRoot) {
          newRoot.children.push(oldRoot);
          newRoot.sizers.push(Private$6.createSizer(0));
          newRoot.handles.push(this._createHandle());
          oldRoot.parent = newRoot;
        }
        return newRoot;
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let minW = 0;
        let minH = 0;
        if (this._root) {
          let limits = this._root.fit(this._spacing, this._items);
          minW = limits.minWidth;
          minH = limits.minHeight;
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        if (!this._root) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let x = this._box.paddingTop;
        let y = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        this._root.update(x, y, width, height, this._spacing, this._items);
      }
      /**
       * Create a new tab bar for use by the dock layout.
       *
       * #### Notes
       * The tab bar will be attached to the parent if it exists.
       */
      _createTabBar() {
        let tabBar = this.renderer.createTabBar(this._document);
        tabBar.orientation = "horizontal";
        if (this.parent) {
          this.attachWidget(tabBar);
        }
        return tabBar;
      }
      /**
       * Create a new handle for the dock layout.
       *
       * #### Notes
       * The handle will be attached to the parent if it exists.
       */
      _createHandle() {
        let handle = this.renderer.createHandle();
        let style = handle.style;
        style.position = "absolute";
        style.contain = "strict";
        style.top = "0";
        style.left = "0";
        style.width = "0";
        style.height = "0";
        if (this.parent) {
          this.parent.node.appendChild(handle);
        }
        return handle;
      }
    };
    (function(Private36) {
      Private36.GOLDEN_RATIO = 0.618;
      function createSizer(hint) {
        let sizer = new BoxSizer();
        sizer.sizeHint = hint;
        sizer.size = hint;
        return sizer;
      }
      Private36.createSizer = createSizer;
      function normalizeAreaConfig(config, widgetSet) {
        let result;
        if (config.type === "tab-area") {
          result = normalizeTabAreaConfig(config, widgetSet);
        } else {
          result = normalizeSplitAreaConfig(config, widgetSet);
        }
        return result;
      }
      Private36.normalizeAreaConfig = normalizeAreaConfig;
      function realizeAreaConfig(config, renderer, document2) {
        let node;
        if (config.type === "tab-area") {
          node = realizeTabAreaConfig(config, renderer, document2);
        } else {
          node = realizeSplitAreaConfig(config, renderer, document2);
        }
        return node;
      }
      Private36.realizeAreaConfig = realizeAreaConfig;
      class TabLayoutNode {
        /**
         * Construct a new tab layout node.
         *
         * @param tabBar - The tab bar to use for the layout node.
         */
        constructor(tabBar) {
          this.parent = null;
          this._top = 0;
          this._left = 0;
          this._width = 0;
          this._height = 0;
          let tabSizer = new BoxSizer();
          let widgetSizer = new BoxSizer();
          tabSizer.stretch = 0;
          widgetSizer.stretch = 1;
          this.tabBar = tabBar;
          this.sizers = [tabSizer, widgetSizer];
        }
        /**
         * The most recent value for the `top` edge of the layout box.
         */
        get top() {
          return this._top;
        }
        /**
         * The most recent value for the `left` edge of the layout box.
         */
        get left() {
          return this._left;
        }
        /**
         * The most recent value for the `width` of the layout box.
         */
        get width() {
          return this._width;
        }
        /**
         * The most recent value for the `height` of the layout box.
         */
        get height() {
          return this._height;
        }
        /**
         * Create an iterator for all widgets in the layout tree.
         */
        *iterAllWidgets() {
          yield this.tabBar;
          yield* this.iterUserWidgets();
        }
        /**
         * Create an iterator for the user widgets in the layout tree.
         */
        *iterUserWidgets() {
          for (const title of this.tabBar.titles) {
            yield title.owner;
          }
        }
        /**
         * Create an iterator for the selected widgets in the layout tree.
         */
        *iterSelectedWidgets() {
          let title = this.tabBar.currentTitle;
          if (title) {
            yield title.owner;
          }
        }
        /**
         * Create an iterator for the tab bars in the layout tree.
         */
        *iterTabBars() {
          yield this.tabBar;
        }
        /**
         * Create an iterator for the handles in the layout tree.
         */
        // eslint-disable-next-line require-yield
        *iterHandles() {
          return;
        }
        /**
         * Find the tab layout node which contains the given widget.
         */
        findTabNode(widget) {
          return this.tabBar.titles.indexOf(widget.title) !== -1 ? this : null;
        }
        /**
         * Find the split layout node which contains the given handle.
         */
        findSplitNode(handle) {
          return null;
        }
        /**
         * Find the first tab layout node in a layout tree.
         */
        findFirstTabNode() {
          return this;
        }
        /**
         * Find the tab layout node which contains the local point.
         */
        hitTestTabNodes(x, y) {
          if (x < this._left || x >= this._left + this._width) {
            return null;
          }
          if (y < this._top || y >= this._top + this._height) {
            return null;
          }
          return this;
        }
        /**
         * Create a configuration object for the layout tree.
         */
        createConfig() {
          let widgets = this.tabBar.titles.map((title) => title.owner);
          let currentIndex = this.tabBar.currentIndex;
          return { type: "tab-area", widgets, currentIndex };
        }
        /**
         * Recursively hold all of the sizes in the layout tree.
         *
         * This ignores the sizers of tab layout nodes.
         */
        holdAllSizes() {
          return;
        }
        /**
         * Fit the layout tree.
         */
        fit(spacing, items) {
          let minWidth = 0;
          let minHeight = 0;
          let maxWidth = Infinity;
          let maxHeight = Infinity;
          let tabBarItem = items.get(this.tabBar);
          let current = this.tabBar.currentTitle;
          let widgetItem = current ? items.get(current.owner) : void 0;
          let [tabBarSizer, widgetSizer] = this.sizers;
          if (tabBarItem) {
            tabBarItem.fit();
          }
          if (widgetItem) {
            widgetItem.fit();
          }
          if (tabBarItem && !tabBarItem.isHidden) {
            minWidth = Math.max(minWidth, tabBarItem.minWidth);
            minHeight += tabBarItem.minHeight;
            tabBarSizer.minSize = tabBarItem.minHeight;
            tabBarSizer.maxSize = tabBarItem.maxHeight;
          } else {
            tabBarSizer.minSize = 0;
            tabBarSizer.maxSize = 0;
          }
          if (widgetItem && !widgetItem.isHidden) {
            minWidth = Math.max(minWidth, widgetItem.minWidth);
            minHeight += widgetItem.minHeight;
            widgetSizer.minSize = widgetItem.minHeight;
            widgetSizer.maxSize = Infinity;
          } else {
            widgetSizer.minSize = 0;
            widgetSizer.maxSize = Infinity;
          }
          return { minWidth, minHeight, maxWidth, maxHeight };
        }
        /**
         * Update the layout tree.
         */
        update(left, top, width, height, spacing, items) {
          this._top = top;
          this._left = left;
          this._width = width;
          this._height = height;
          let tabBarItem = items.get(this.tabBar);
          let current = this.tabBar.currentTitle;
          let widgetItem = current ? items.get(current.owner) : void 0;
          BoxEngine.calc(this.sizers, height);
          if (tabBarItem && !tabBarItem.isHidden) {
            let size = this.sizers[0].size;
            tabBarItem.update(left, top, width, size);
            top += size;
          }
          if (widgetItem && !widgetItem.isHidden) {
            let size = this.sizers[1].size;
            widgetItem.update(left, top, width, size);
          }
        }
      }
      Private36.TabLayoutNode = TabLayoutNode;
      class SplitLayoutNode {
        /**
         * Construct a new split layout node.
         *
         * @param orientation - The orientation of the node.
         */
        constructor(orientation) {
          this.parent = null;
          this.normalized = false;
          this.children = [];
          this.sizers = [];
          this.handles = [];
          this.orientation = orientation;
        }
        /**
         * Create an iterator for all widgets in the layout tree.
         */
        *iterAllWidgets() {
          for (const child of this.children) {
            yield* child.iterAllWidgets();
          }
        }
        /**
         * Create an iterator for the user widgets in the layout tree.
         */
        *iterUserWidgets() {
          for (const child of this.children) {
            yield* child.iterUserWidgets();
          }
        }
        /**
         * Create an iterator for the selected widgets in the layout tree.
         */
        *iterSelectedWidgets() {
          for (const child of this.children) {
            yield* child.iterSelectedWidgets();
          }
        }
        /**
         * Create an iterator for the tab bars in the layout tree.
         */
        *iterTabBars() {
          for (const child of this.children) {
            yield* child.iterTabBars();
          }
        }
        /**
         * Create an iterator for the handles in the layout tree.
         */
        *iterHandles() {
          yield* this.handles;
          for (const child of this.children) {
            yield* child.iterHandles();
          }
        }
        /**
         * Find the tab layout node which contains the given widget.
         */
        findTabNode(widget) {
          for (let i = 0, n = this.children.length; i < n; ++i) {
            let result = this.children[i].findTabNode(widget);
            if (result) {
              return result;
            }
          }
          return null;
        }
        /**
         * Find the split layout node which contains the given handle.
         */
        findSplitNode(handle) {
          let index = this.handles.indexOf(handle);
          if (index !== -1) {
            return { index, node: this };
          }
          for (let i = 0, n = this.children.length; i < n; ++i) {
            let result = this.children[i].findSplitNode(handle);
            if (result) {
              return result;
            }
          }
          return null;
        }
        /**
         * Find the first tab layout node in a layout tree.
         */
        findFirstTabNode() {
          if (this.children.length === 0) {
            return null;
          }
          return this.children[0].findFirstTabNode();
        }
        /**
         * Find the tab layout node which contains the local point.
         */
        hitTestTabNodes(x, y) {
          for (let i = 0, n = this.children.length; i < n; ++i) {
            let result = this.children[i].hitTestTabNodes(x, y);
            if (result) {
              return result;
            }
          }
          return null;
        }
        /**
         * Create a configuration object for the layout tree.
         */
        createConfig() {
          let orientation = this.orientation;
          let sizes = this.createNormalizedSizes();
          let children2 = this.children.map((child) => child.createConfig());
          return { type: "split-area", orientation, children: children2, sizes };
        }
        /**
         * Sync the visibility and orientation of the handles.
         */
        syncHandles() {
          this.handles.forEach((handle, i) => {
            handle.setAttribute("data-orientation", this.orientation);
            if (i === this.handles.length - 1) {
              handle.classList.add("lm-mod-hidden");
            } else {
              handle.classList.remove("lm-mod-hidden");
            }
          });
        }
        /**
         * Hold the current sizes of the box sizers.
         *
         * This sets the size hint of each sizer to its current size.
         */
        holdSizes() {
          for (const sizer of this.sizers) {
            sizer.sizeHint = sizer.size;
          }
        }
        /**
         * Recursively hold all of the sizes in the layout tree.
         *
         * This ignores the sizers of tab layout nodes.
         */
        holdAllSizes() {
          for (const child of this.children) {
            child.holdAllSizes();
          }
          this.holdSizes();
        }
        /**
         * Normalize the sizes of the split layout node.
         */
        normalizeSizes() {
          let n = this.sizers.length;
          if (n === 0) {
            return;
          }
          this.holdSizes();
          let sum = this.sizers.reduce((v, sizer) => v + sizer.sizeHint, 0);
          if (sum === 0) {
            for (const sizer of this.sizers) {
              sizer.size = sizer.sizeHint = 1 / n;
            }
          } else {
            for (const sizer of this.sizers) {
              sizer.size = sizer.sizeHint /= sum;
            }
          }
          this.normalized = true;
        }
        /**
         * Snap the normalized sizes of the split layout node.
         */
        createNormalizedSizes() {
          let n = this.sizers.length;
          if (n === 0) {
            return [];
          }
          let sizes = this.sizers.map((sizer) => sizer.size);
          let sum = sizes.reduce((v, size) => v + size, 0);
          if (sum === 0) {
            for (let i = sizes.length - 1; i > -1; i--) {
              sizes[i] = 1 / n;
            }
          } else {
            for (let i = sizes.length - 1; i > -1; i--) {
              sizes[i] /= sum;
            }
          }
          return sizes;
        }
        /**
         * Fit the layout tree.
         */
        fit(spacing, items) {
          let horizontal = this.orientation === "horizontal";
          let fixed = Math.max(0, this.children.length - 1) * spacing;
          let minWidth = horizontal ? fixed : 0;
          let minHeight = horizontal ? 0 : fixed;
          let maxWidth = Infinity;
          let maxHeight = Infinity;
          for (let i = 0, n = this.children.length; i < n; ++i) {
            let limits = this.children[i].fit(spacing, items);
            if (horizontal) {
              minHeight = Math.max(minHeight, limits.minHeight);
              minWidth += limits.minWidth;
              this.sizers[i].minSize = limits.minWidth;
            } else {
              minWidth = Math.max(minWidth, limits.minWidth);
              minHeight += limits.minHeight;
              this.sizers[i].minSize = limits.minHeight;
            }
          }
          return { minWidth, minHeight, maxWidth, maxHeight };
        }
        /**
         * Update the layout tree.
         */
        update(left, top, width, height, spacing, items) {
          let horizontal = this.orientation === "horizontal";
          let fixed = Math.max(0, this.children.length - 1) * spacing;
          let space = Math.max(0, (horizontal ? width : height) - fixed);
          if (this.normalized) {
            for (const sizer of this.sizers) {
              sizer.sizeHint *= space;
            }
            this.normalized = false;
          }
          BoxEngine.calc(this.sizers, space);
          for (let i = 0, n = this.children.length; i < n; ++i) {
            let child = this.children[i];
            let size = this.sizers[i].size;
            let handleStyle = this.handles[i].style;
            if (horizontal) {
              child.update(left, top, size, height, spacing, items);
              left += size;
              handleStyle.top = `${top}px`;
              handleStyle.left = `${left}px`;
              handleStyle.width = `${spacing}px`;
              handleStyle.height = `${height}px`;
              left += spacing;
            } else {
              child.update(left, top, width, size, spacing, items);
              top += size;
              handleStyle.top = `${top}px`;
              handleStyle.left = `${left}px`;
              handleStyle.width = `${width}px`;
              handleStyle.height = `${spacing}px`;
              top += spacing;
            }
          }
        }
      }
      Private36.SplitLayoutNode = SplitLayoutNode;
      function addAria(widget, tabBar) {
        widget.node.setAttribute("role", "tabpanel");
        let renderer = tabBar.renderer;
        if (renderer instanceof TabBar.Renderer) {
          let tabId = renderer.createTabKey({
            title: widget.title,
            current: false,
            zIndex: 0
          });
          widget.node.setAttribute("aria-labelledby", tabId);
        }
      }
      Private36.addAria = addAria;
      function removeAria(widget) {
        widget.node.removeAttribute("role");
        widget.node.removeAttribute("aria-labelledby");
      }
      Private36.removeAria = removeAria;
      function normalizeTabAreaConfig(config, widgetSet) {
        if (config.widgets.length === 0) {
          return null;
        }
        let widgets = [];
        for (const widget of config.widgets) {
          if (!widgetSet.has(widget)) {
            widgetSet.add(widget);
            widgets.push(widget);
          }
        }
        if (widgets.length === 0) {
          return null;
        }
        let index = config.currentIndex;
        if (index !== -1 && (index < 0 || index >= widgets.length)) {
          index = 0;
        }
        return { type: "tab-area", widgets, currentIndex: index };
      }
      function normalizeSplitAreaConfig(config, widgetSet) {
        let orientation = config.orientation;
        let children2 = [];
        let sizes = [];
        for (let i = 0, n = config.children.length; i < n; ++i) {
          let child = normalizeAreaConfig(config.children[i], widgetSet);
          if (!child) {
            continue;
          }
          if (child.type === "tab-area" || child.orientation !== orientation) {
            children2.push(child);
            sizes.push(Math.abs(config.sizes[i] || 0));
          } else {
            children2.push(...child.children);
            sizes.push(...child.sizes);
          }
        }
        if (children2.length === 0) {
          return null;
        }
        if (children2.length === 1) {
          return children2[0];
        }
        return { type: "split-area", orientation, children: children2, sizes };
      }
      function realizeTabAreaConfig(config, renderer, document2) {
        let tabBar = renderer.createTabBar(document2);
        for (const widget of config.widgets) {
          widget.hide();
          tabBar.addTab(widget.title);
          Private36.addAria(widget, tabBar);
        }
        tabBar.currentIndex = config.currentIndex;
        return new TabLayoutNode(tabBar);
      }
      function realizeSplitAreaConfig(config, renderer, document2) {
        let node = new SplitLayoutNode(config.orientation);
        config.children.forEach((child, i) => {
          let childNode = realizeAreaConfig(child, renderer, document2);
          let sizer = createSizer(config.sizes[i]);
          let handle = renderer.createHandle();
          node.children.push(childNode);
          node.handles.push(handle);
          node.sizers.push(sizer);
          childNode.parent = node;
        });
        node.syncHandles();
        node.normalizeSizes();
        return node;
      }
    })(Private$6 || (Private$6 = {}));
    DockPanel = class extends Widget {
      /**
       * Construct a new dock panel.
       *
       * @param options - The options for initializing the panel.
       */
      constructor(options = {}) {
        super();
        this._drag = null;
        this._tabsMovable = true;
        this._tabsConstrained = false;
        this._addButtonEnabled = false;
        this._pressData = null;
        this._layoutModified = new Signal(this);
        this._addRequested = new Signal(this);
        this.addClass("lm-DockPanel");
        this._document = options.document || document;
        this._mode = options.mode || "multiple-document";
        this._renderer = options.renderer || DockPanel.defaultRenderer;
        this._edges = options.edges || Private$5.DEFAULT_EDGES;
        if (options.tabsMovable !== void 0) {
          this._tabsMovable = options.tabsMovable;
        }
        if (options.tabsConstrained !== void 0) {
          this._tabsConstrained = options.tabsConstrained;
        }
        if (options.addButtonEnabled !== void 0) {
          this._addButtonEnabled = options.addButtonEnabled;
        }
        this.dataset["mode"] = this._mode;
        let renderer = {
          createTabBar: () => this._createTabBar(),
          createHandle: () => this._createHandle()
        };
        this.layout = new DockLayout({
          document: this._document,
          renderer,
          spacing: options.spacing,
          hiddenMode: options.hiddenMode
        });
        this.overlay = options.overlay || new DockPanel.Overlay();
        this.node.appendChild(this.overlay.node);
      }
      /**
       * Dispose of the resources held by the panel.
       */
      dispose() {
        this._releaseMouse();
        this.overlay.hide(0);
        if (this._drag) {
          this._drag.dispose();
        }
        super.dispose();
      }
      /**
       * The method for hiding widgets.
       */
      get hiddenMode() {
        return this.layout.hiddenMode;
      }
      /**
       * Set the method for hiding widgets.
       */
      set hiddenMode(v) {
        this.layout.hiddenMode = v;
      }
      /**
       * A signal emitted when the layout configuration is modified.
       *
       * #### Notes
       * This signal is emitted whenever the current layout configuration
       * may have changed.
       *
       * This signal is emitted asynchronously in a collapsed fashion, so
       * that multiple synchronous modifications results in only a single
       * emit of the signal.
       */
      get layoutModified() {
        return this._layoutModified;
      }
      /**
       * A signal emitted when the add button on a tab bar is clicked.
       *
       */
      get addRequested() {
        return this._addRequested;
      }
      /**
       * The renderer used by the dock panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * Get the spacing between the widgets.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the spacing between the widgets.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * Get the mode for the dock panel.
       */
      get mode() {
        return this._mode;
      }
      /**
       * Set the mode for the dock panel.
       *
       * #### Notes
       * Changing the mode is a destructive operation with respect to the
       * panel's layout configuration. If layout state must be preserved,
       * save the current layout config before changing the mode.
       */
      set mode(value) {
        if (this._mode === value) {
          return;
        }
        this._mode = value;
        this.dataset["mode"] = value;
        let layout = this.layout;
        switch (value) {
          case "multiple-document":
            for (const tabBar of layout.tabBars()) {
              tabBar.show();
            }
            break;
          case "single-document":
            layout.restoreLayout(Private$5.createSingleDocumentConfig(this));
            break;
          default:
            throw "unreachable";
        }
        MessageLoop.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Whether the tabs can be dragged / moved at runtime.
       */
      get tabsMovable() {
        return this._tabsMovable;
      }
      /**
       * Enable / Disable draggable / movable tabs.
       */
      set tabsMovable(value) {
        this._tabsMovable = value;
        for (const tabBar of this.tabBars()) {
          tabBar.tabsMovable = value;
        }
      }
      /**
       * Whether the tabs are constrained to their source dock panel
       */
      get tabsConstrained() {
        return this._tabsConstrained;
      }
      /**
       * Constrain/Allow tabs to be dragged outside of this dock panel
       */
      set tabsConstrained(value) {
        this._tabsConstrained = value;
      }
      /**
       * Whether the add buttons for each tab bar are enabled.
       */
      get addButtonEnabled() {
        return this._addButtonEnabled;
      }
      /**
       * Set whether the add buttons for each tab bar are enabled.
       */
      set addButtonEnabled(value) {
        this._addButtonEnabled = value;
        for (const tabBar of this.tabBars()) {
          tabBar.addButtonEnabled = value;
        }
      }
      /**
       * Whether the dock panel is empty.
       */
      get isEmpty() {
        return this.layout.isEmpty;
      }
      /**
       * Create an iterator over the user widgets in the panel.
       *
       * @returns A new iterator over the user widgets in the panel.
       *
       * #### Notes
       * This iterator does not include the generated tab bars.
       */
      *widgets() {
        yield* this.layout.widgets();
      }
      /**
       * Create an iterator over the selected widgets in the panel.
       *
       * @returns A new iterator over the selected user widgets.
       *
       * #### Notes
       * This iterator yields the widgets corresponding to the current tab
       * of each tab bar in the panel.
       */
      *selectedWidgets() {
        yield* this.layout.selectedWidgets();
      }
      /**
       * Create an iterator over the tab bars in the panel.
       *
       * @returns A new iterator over the tab bars in the panel.
       *
       * #### Notes
       * This iterator does not include the user widgets.
       */
      *tabBars() {
        yield* this.layout.tabBars();
      }
      /**
       * Create an iterator over the handles in the panel.
       *
       * @returns A new iterator over the handles in the panel.
       */
      *handles() {
        yield* this.layout.handles();
      }
      /**
       * Select a specific widget in the dock panel.
       *
       * @param widget - The widget of interest.
       *
       * #### Notes
       * This will make the widget the current widget in its tab area.
       */
      selectWidget(widget) {
        let tabBar = find2(this.tabBars(), (bar) => {
          return bar.titles.indexOf(widget.title) !== -1;
        });
        if (!tabBar) {
          throw new Error("Widget is not contained in the dock panel.");
        }
        tabBar.currentTitle = widget.title;
      }
      /**
       * Activate a specified widget in the dock panel.
       *
       * @param widget - The widget of interest.
       *
       * #### Notes
       * This will select and activate the given widget.
       */
      activateWidget(widget) {
        this.selectWidget(widget);
        widget.activate();
      }
      /**
       * Save the current layout configuration of the dock panel.
       *
       * @returns A new config object for the current layout state.
       *
       * #### Notes
       * The return value can be provided to the `restoreLayout` method
       * in order to restore the layout to its current configuration.
       */
      saveLayout() {
        return this.layout.saveLayout();
      }
      /**
       * Restore the layout to a previously saved configuration.
       *
       * @param config - The layout configuration to restore.
       *
       * #### Notes
       * Widgets which currently belong to the layout but which are not
       * contained in the config will be unparented.
       *
       * The dock panel automatically reverts to `'multiple-document'`
       * mode when a layout config is restored.
       */
      restoreLayout(config) {
        this._mode = "multiple-document";
        this.layout.restoreLayout(config);
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop.flush();
        }
        MessageLoop.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Add a widget to the dock panel.
       *
       * @param widget - The widget to add to the dock panel.
       *
       * @param options - The additional options for adding the widget.
       *
       * #### Notes
       * If the panel is in single document mode, the options are ignored
       * and the widget is always added as tab in the hidden tab bar.
       */
      addWidget(widget, options = {}) {
        if (this._mode === "single-document") {
          this.layout.addWidget(widget);
        } else {
          this.layout.addWidget(widget, options);
        }
        MessageLoop.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Process a message sent to the widget.
       *
       * @param msg - The message sent to the widget.
       */
      processMessage(msg) {
        if (msg.type === "layout-modified") {
          this._layoutModified.emit(void 0);
        } else {
          super.processMessage(msg);
        }
      }
      /**
       * Handle the DOM events for the dock panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "lm-dragenter":
            this._evtDragEnter(event);
            break;
          case "lm-dragleave":
            this._evtDragLeave(event);
            break;
          case "lm-dragover":
            this._evtDragOver(event);
            break;
          case "lm-drop":
            this._evtDrop(event);
            break;
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("lm-dragenter", this);
        this.node.addEventListener("lm-dragleave", this);
        this.node.addEventListener("lm-dragover", this);
        this.node.addEventListener("lm-drop", this);
        this.node.addEventListener("pointerdown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("lm-dragenter", this);
        this.node.removeEventListener("lm-dragleave", this);
        this.node.removeEventListener("lm-dragover", this);
        this.node.removeEventListener("lm-drop", this);
        this.node.removeEventListener("pointerdown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        if (Private$5.isGeneratedTabBarProperty.get(msg.child)) {
          return;
        }
        msg.child.addClass("lm-DockPanel-widget");
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        if (Private$5.isGeneratedTabBarProperty.get(msg.child)) {
          return;
        }
        msg.child.removeClass("lm-DockPanel-widget");
        MessageLoop.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Handle the `'lm-dragenter'` event for the dock panel.
       */
      _evtDragEnter(event) {
        if (event.mimeData.hasData("application/vnd.lumino.widget-factory")) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
      /**
       * Handle the `'lm-dragleave'` event for the dock panel.
       */
      _evtDragLeave(event) {
        event.preventDefault();
        if (this._tabsConstrained && event.source !== this)
          return;
        event.stopPropagation();
        this.overlay.hide(1);
      }
      /**
       * Handle the `'lm-dragover'` event for the dock panel.
       */
      _evtDragOver(event) {
        event.preventDefault();
        if (this._tabsConstrained && event.source !== this || this._showOverlay(event.clientX, event.clientY) === "invalid") {
          event.dropAction = "none";
        } else {
          event.stopPropagation();
          event.dropAction = event.proposedAction;
        }
      }
      /**
       * Handle the `'lm-drop'` event for the dock panel.
       */
      _evtDrop(event) {
        event.preventDefault();
        this.overlay.hide(0);
        if (event.proposedAction === "none") {
          event.dropAction = "none";
          return;
        }
        let { clientX, clientY } = event;
        let { zone, target: target2 } = Private$5.findDropTarget(this, clientX, clientY, this._edges);
        if (this._tabsConstrained && event.source !== this || zone === "invalid") {
          event.dropAction = "none";
          return;
        }
        let mimeData = event.mimeData;
        let factory = mimeData.getData("application/vnd.lumino.widget-factory");
        if (typeof factory !== "function") {
          event.dropAction = "none";
          return;
        }
        let widget = factory();
        if (!(widget instanceof Widget)) {
          event.dropAction = "none";
          return;
        }
        if (widget.contains(this)) {
          event.dropAction = "none";
          return;
        }
        let ref2 = target2 ? Private$5.getDropRef(target2.tabBar) : null;
        switch (zone) {
          case "root-all":
            this.addWidget(widget);
            break;
          case "root-top":
            this.addWidget(widget, { mode: "split-top" });
            break;
          case "root-left":
            this.addWidget(widget, { mode: "split-left" });
            break;
          case "root-right":
            this.addWidget(widget, { mode: "split-right" });
            break;
          case "root-bottom":
            this.addWidget(widget, { mode: "split-bottom" });
            break;
          case "widget-all":
            this.addWidget(widget, { mode: "tab-after", ref: ref2 });
            break;
          case "widget-top":
            this.addWidget(widget, { mode: "split-top", ref: ref2 });
            break;
          case "widget-left":
            this.addWidget(widget, { mode: "split-left", ref: ref2 });
            break;
          case "widget-right":
            this.addWidget(widget, { mode: "split-right", ref: ref2 });
            break;
          case "widget-bottom":
            this.addWidget(widget, { mode: "split-bottom", ref: ref2 });
            break;
          case "widget-tab":
            this.addWidget(widget, { mode: "tab-after", ref: ref2 });
            break;
          default:
            throw "unreachable";
        }
        event.dropAction = event.proposedAction;
        event.stopPropagation();
        this.activateWidget(widget);
      }
      /**
       * Handle the `'keydown'` event for the dock panel.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.keyCode === 27) {
          this._releaseMouse();
          MessageLoop.postMessage(this, Private$5.LayoutModified);
        }
      }
      /**
       * Handle the `'pointerdown'` event for the dock panel.
       */
      _evtPointerDown(event) {
        if (event.button !== 0) {
          return;
        }
        let layout = this.layout;
        let target2 = event.target;
        let handle = find2(layout.handles(), (handle2) => handle2.contains(target2));
        if (!handle) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._document.addEventListener("keydown", this, true);
        this._document.addEventListener("pointerup", this, true);
        this._document.addEventListener("pointermove", this, true);
        this._document.addEventListener("contextmenu", this, true);
        let rect = handle.getBoundingClientRect();
        let deltaX = event.clientX - rect.left;
        let deltaY = event.clientY - rect.top;
        let style = window.getComputedStyle(handle);
        let override = Drag.overrideCursor(style.cursor, this._document);
        this._pressData = { handle, deltaX, deltaY, override };
      }
      /**
       * Handle the `'pointermove'` event for the dock panel.
       */
      _evtPointerMove(event) {
        if (!this._pressData) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        let rect = this.node.getBoundingClientRect();
        let xPos = event.clientX - rect.left - this._pressData.deltaX;
        let yPos = event.clientY - rect.top - this._pressData.deltaY;
        let layout = this.layout;
        layout.moveHandle(this._pressData.handle, xPos, yPos);
      }
      /**
       * Handle the `'pointerup'` event for the dock panel.
       */
      _evtPointerUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._releaseMouse();
        MessageLoop.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Release the mouse grab for the dock panel.
       */
      _releaseMouse() {
        if (!this._pressData) {
          return;
        }
        this._pressData.override.dispose();
        this._pressData = null;
        this._document.removeEventListener("keydown", this, true);
        this._document.removeEventListener("pointerup", this, true);
        this._document.removeEventListener("pointermove", this, true);
        this._document.removeEventListener("contextmenu", this, true);
      }
      /**
       * Show the overlay indicator at the given client position.
       *
       * Returns the drop zone at the specified client position.
       *
       * #### Notes
       * If the position is not over a valid zone, the overlay is hidden.
       */
      _showOverlay(clientX, clientY) {
        let { zone, target: target2 } = Private$5.findDropTarget(this, clientX, clientY, this._edges);
        if (zone === "invalid") {
          this.overlay.hide(100);
          return zone;
        }
        let top;
        let left;
        let right;
        let bottom;
        let box = ElementExt.boxSizing(this.node);
        let rect = this.node.getBoundingClientRect();
        switch (zone) {
          case "root-all":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "root-top":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = rect.height * Private$5.GOLDEN_RATIO;
            break;
          case "root-left":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = rect.width * Private$5.GOLDEN_RATIO;
            bottom = box.paddingBottom;
            break;
          case "root-right":
            top = box.paddingTop;
            left = rect.width * Private$5.GOLDEN_RATIO;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "root-bottom":
            top = rect.height * Private$5.GOLDEN_RATIO;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "widget-all":
            top = target2.top;
            left = target2.left;
            right = target2.right;
            bottom = target2.bottom;
            break;
          case "widget-top":
            top = target2.top;
            left = target2.left;
            right = target2.right;
            bottom = target2.bottom + target2.height / 2;
            break;
          case "widget-left":
            top = target2.top;
            left = target2.left;
            right = target2.right + target2.width / 2;
            bottom = target2.bottom;
            break;
          case "widget-right":
            top = target2.top;
            left = target2.left + target2.width / 2;
            right = target2.right;
            bottom = target2.bottom;
            break;
          case "widget-bottom":
            top = target2.top + target2.height / 2;
            left = target2.left;
            right = target2.right;
            bottom = target2.bottom;
            break;
          case "widget-tab": {
            const tabHeight = target2.tabBar.node.getBoundingClientRect().height;
            top = target2.top;
            left = target2.left;
            right = target2.right;
            bottom = target2.bottom + target2.height - tabHeight;
            break;
          }
          default:
            throw "unreachable";
        }
        this.overlay.show({ top, left, right, bottom });
        return zone;
      }
      /**
       * Create a new tab bar for use by the panel.
       */
      _createTabBar() {
        let tabBar = this._renderer.createTabBar(this._document);
        Private$5.isGeneratedTabBarProperty.set(tabBar, true);
        if (this._mode === "single-document") {
          tabBar.hide();
        }
        tabBar.tabsMovable = this._tabsMovable;
        tabBar.allowDeselect = false;
        tabBar.addButtonEnabled = this._addButtonEnabled;
        tabBar.removeBehavior = "select-previous-tab";
        tabBar.insertBehavior = "select-tab-if-needed";
        tabBar.tabMoved.connect(this._onTabMoved, this);
        tabBar.currentChanged.connect(this._onCurrentChanged, this);
        tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);
        tabBar.tabDetachRequested.connect(this._onTabDetachRequested, this);
        tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);
        tabBar.addRequested.connect(this._onTabAddRequested, this);
        return tabBar;
      }
      /**
       * Create a new handle for use by the panel.
       */
      _createHandle() {
        return this._renderer.createHandle();
      }
      /**
       * Handle the `tabMoved` signal from a tab bar.
       */
      _onTabMoved() {
        MessageLoop.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Handle the `currentChanged` signal from a tab bar.
       */
      _onCurrentChanged(sender, args) {
        let { previousTitle, currentTitle } = args;
        if (previousTitle) {
          previousTitle.owner.hide();
        }
        if (currentTitle) {
          currentTitle.owner.show();
        }
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop.flush();
        }
        MessageLoop.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Handle the `addRequested` signal from a tab bar.
       */
      _onTabAddRequested(sender) {
        this._addRequested.emit(sender);
      }
      /**
       * Handle the `tabActivateRequested` signal from a tab bar.
       */
      _onTabActivateRequested(sender, args) {
        args.title.owner.activate();
      }
      /**
       * Handle the `tabCloseRequested` signal from a tab bar.
       */
      _onTabCloseRequested(sender, args) {
        args.title.owner.close();
      }
      /**
       * Handle the `tabDetachRequested` signal from a tab bar.
       */
      _onTabDetachRequested(sender, args) {
        if (this._drag) {
          return;
        }
        sender.releaseMouse();
        let { title, tab, clientX, clientY, offset } = args;
        let mimeData = new import_coreutils7.MimeData();
        let factory = () => title.owner;
        mimeData.setData("application/vnd.lumino.widget-factory", factory);
        let dragImage = tab.cloneNode(true);
        if (offset) {
          dragImage.style.top = `-${offset.y}px`;
          dragImage.style.left = `-${offset.x}px`;
        }
        this._drag = new Drag({
          document: this._document,
          mimeData,
          dragImage,
          proposedAction: "move",
          supportedActions: "move",
          source: this
        });
        tab.classList.add("lm-mod-hidden");
        let cleanup = () => {
          this._drag = null;
          tab.classList.remove("lm-mod-hidden");
        };
        this._drag.start(clientX, clientY).then(cleanup);
      }
    };
    (function(DockPanel2) {
      class Overlay {
        /**
         * Construct a new overlay.
         */
        constructor() {
          this._timer = -1;
          this._hidden = true;
          this.node = document.createElement("div");
          this.node.classList.add("lm-DockPanel-overlay");
          this.node.classList.add("lm-mod-hidden");
          this.node.style.position = "absolute";
          this.node.style.contain = "strict";
        }
        /**
         * Show the overlay using the given overlay geometry.
         *
         * @param geo - The desired geometry for the overlay.
         */
        show(geo) {
          let style = this.node.style;
          style.top = `${geo.top}px`;
          style.left = `${geo.left}px`;
          style.right = `${geo.right}px`;
          style.bottom = `${geo.bottom}px`;
          clearTimeout(this._timer);
          this._timer = -1;
          if (!this._hidden) {
            return;
          }
          this._hidden = false;
          this.node.classList.remove("lm-mod-hidden");
        }
        /**
         * Hide the overlay node.
         *
         * @param delay - The delay (in ms) before hiding the overlay.
         *   A delay value <= 0 will hide the overlay immediately.
         */
        hide(delay) {
          if (this._hidden) {
            return;
          }
          if (delay <= 0) {
            clearTimeout(this._timer);
            this._timer = -1;
            this._hidden = true;
            this.node.classList.add("lm-mod-hidden");
            return;
          }
          if (this._timer !== -1) {
            return;
          }
          this._timer = window.setTimeout(() => {
            this._timer = -1;
            this._hidden = true;
            this.node.classList.add("lm-mod-hidden");
          }, delay);
        }
      }
      DockPanel2.Overlay = Overlay;
      class Renderer {
        /**
         * Create a new tab bar for use with a dock panel.
         *
         * @returns A new tab bar for a dock panel.
         */
        createTabBar(document2) {
          let bar = new TabBar({ document: document2 });
          bar.addClass("lm-DockPanel-tabBar");
          return bar;
        }
        /**
         * Create a new handle node for use with a dock panel.
         *
         * @returns A new handle node for a dock panel.
         */
        createHandle() {
          let handle = document.createElement("div");
          handle.className = "lm-DockPanel-handle";
          return handle;
        }
      }
      DockPanel2.Renderer = Renderer;
      DockPanel2.defaultRenderer = new Renderer();
    })(DockPanel || (DockPanel = {}));
    (function(Private36) {
      Private36.GOLDEN_RATIO = 0.618;
      Private36.DEFAULT_EDGES = {
        /**
         * The size of the top edge dock zone for the root panel, in pixels.
         * This is different from the others to distinguish between the top
         * tab bar and the top root zone.
         */
        top: 12,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        right: 40,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        bottom: 40,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        left: 40
      };
      Private36.LayoutModified = new ConflatableMessage("layout-modified");
      Private36.isGeneratedTabBarProperty = new AttachedProperty2({
        name: "isGeneratedTabBar",
        create: () => false
      });
      function createSingleDocumentConfig(panel) {
        if (panel.isEmpty) {
          return { main: null };
        }
        let widgets = Array.from(panel.widgets());
        let selected = panel.selectedWidgets().next().value;
        let currentIndex = selected ? widgets.indexOf(selected) : -1;
        return { main: { type: "tab-area", widgets, currentIndex } };
      }
      Private36.createSingleDocumentConfig = createSingleDocumentConfig;
      function findDropTarget(panel, clientX, clientY, edges) {
        if (!ElementExt.hitTest(panel.node, clientX, clientY)) {
          return { zone: "invalid", target: null };
        }
        let layout = panel.layout;
        if (layout.isEmpty) {
          return { zone: "root-all", target: null };
        }
        if (panel.mode === "multiple-document") {
          let panelRect = panel.node.getBoundingClientRect();
          let pl = clientX - panelRect.left + 1;
          let pt = clientY - panelRect.top + 1;
          let pr = panelRect.right - clientX;
          let pb = panelRect.bottom - clientY;
          let pd = Math.min(pt, pr, pb, pl);
          switch (pd) {
            case pt:
              if (pt < edges.top) {
                return { zone: "root-top", target: null };
              }
              break;
            case pr:
              if (pr < edges.right) {
                return { zone: "root-right", target: null };
              }
              break;
            case pb:
              if (pb < edges.bottom) {
                return { zone: "root-bottom", target: null };
              }
              break;
            case pl:
              if (pl < edges.left) {
                return { zone: "root-left", target: null };
              }
              break;
            default:
              throw "unreachable";
          }
        }
        let target2 = layout.hitTestTabAreas(clientX, clientY);
        if (!target2) {
          return { zone: "invalid", target: null };
        }
        if (panel.mode === "single-document") {
          return { zone: "widget-all", target: target2 };
        }
        let al = target2.x - target2.left + 1;
        let at = target2.y - target2.top + 1;
        let ar = target2.left + target2.width - target2.x;
        let ab = target2.top + target2.height - target2.y;
        const tabHeight = target2.tabBar.node.getBoundingClientRect().height;
        if (at < tabHeight) {
          return { zone: "widget-tab", target: target2 };
        }
        let rx = Math.round(target2.width / 3);
        let ry = Math.round(target2.height / 3);
        if (al > rx && ar > rx && at > ry && ab > ry) {
          return { zone: "widget-all", target: target2 };
        }
        al /= rx;
        at /= ry;
        ar /= rx;
        ab /= ry;
        let ad = Math.min(al, at, ar, ab);
        let zone;
        switch (ad) {
          case al:
            zone = "widget-left";
            break;
          case at:
            zone = "widget-top";
            break;
          case ar:
            zone = "widget-right";
            break;
          case ab:
            zone = "widget-bottom";
            break;
          default:
            throw "unreachable";
        }
        return { zone, target: target2 };
      }
      Private36.findDropTarget = findDropTarget;
      function getDropRef(tabBar) {
        if (tabBar.titles.length === 0) {
          return null;
        }
        if (tabBar.currentTitle) {
          return tabBar.currentTitle.owner;
        }
        return tabBar.titles[tabBar.titles.length - 1].owner;
      }
      Private36.getDropRef = getDropRef;
    })(Private$5 || (Private$5 = {}));
    FocusTracker = class {
      constructor() {
        this._counter = 0;
        this._widgets = [];
        this._activeWidget = null;
        this._currentWidget = null;
        this._numbers = /* @__PURE__ */ new Map();
        this._nodes = /* @__PURE__ */ new Map();
        this._activeChanged = new Signal(this);
        this._currentChanged = new Signal(this);
      }
      /**
       * Dispose of the resources held by the tracker.
       */
      dispose() {
        if (this._counter < 0) {
          return;
        }
        this._counter = -1;
        Signal.clearData(this);
        for (const widget of this._widgets) {
          widget.node.removeEventListener("focus", this, true);
          widget.node.removeEventListener("blur", this, true);
        }
        this._activeWidget = null;
        this._currentWidget = null;
        this._nodes.clear();
        this._numbers.clear();
        this._widgets.length = 0;
      }
      /**
       * A signal emitted when the current widget has changed.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * A signal emitted when the active widget has changed.
       */
      get activeChanged() {
        return this._activeChanged;
      }
      /**
       * A flag indicating whether the tracker is disposed.
       */
      get isDisposed() {
        return this._counter < 0;
      }
      /**
       * The current widget in the tracker.
       *
       * #### Notes
       * The current widget is the widget among the tracked widgets which
       * has the *descendant node* which has most recently been focused.
       *
       * The current widget will not be updated if the node loses focus. It
       * will only be updated when a different tracked widget gains focus.
       *
       * If the current widget is removed from the tracker, the previous
       * current widget will be restored.
       *
       * This behavior is intended to follow a user's conceptual model of
       * a semantically "current" widget, where the "last thing of type X"
       * to be interacted with is the "current instance of X", regardless
       * of whether that instance still has focus.
       */
      get currentWidget() {
        return this._currentWidget;
      }
      /**
       * The active widget in the tracker.
       *
       * #### Notes
       * The active widget is the widget among the tracked widgets which
       * has the *descendant node* which is currently focused.
       */
      get activeWidget() {
        return this._activeWidget;
      }
      /**
       * A read only array of the widgets being tracked.
       */
      get widgets() {
        return this._widgets;
      }
      /**
       * Get the focus number for a particular widget in the tracker.
       *
       * @param widget - The widget of interest.
       *
       * @returns The focus number for the given widget, or `-1` if the
       *   widget has not had focus since being added to the tracker, or
       *   is not contained by the tracker.
       *
       * #### Notes
       * The focus number indicates the relative order in which the widgets
       * have gained focus. A widget with a larger number has gained focus
       * more recently than a widget with a smaller number.
       *
       * The `currentWidget` will always have the largest focus number.
       *
       * All widgets start with a focus number of `-1`, which indicates that
       * the widget has not been focused since being added to the tracker.
       */
      focusNumber(widget) {
        let n = this._numbers.get(widget);
        return n === void 0 ? -1 : n;
      }
      /**
       * Test whether the focus tracker contains a given widget.
       *
       * @param widget - The widget of interest.
       *
       * @returns `true` if the widget is tracked, `false` otherwise.
       */
      has(widget) {
        return this._numbers.has(widget);
      }
      /**
       * Add a widget to the focus tracker.
       *
       * @param widget - The widget of interest.
       *
       * #### Notes
       * A widget will be automatically removed from the tracker if it
       * is disposed after being added.
       *
       * If the widget is already tracked, this is a no-op.
       */
      add(widget) {
        if (this._numbers.has(widget)) {
          return;
        }
        let focused = widget.node.contains(document.activeElement);
        let n = focused ? this._counter++ : -1;
        this._widgets.push(widget);
        this._numbers.set(widget, n);
        this._nodes.set(widget.node, widget);
        widget.node.addEventListener("focus", this, true);
        widget.node.addEventListener("blur", this, true);
        widget.disposed.connect(this._onWidgetDisposed, this);
        if (focused) {
          this._setWidgets(widget, widget);
        }
      }
      /**
       * Remove a widget from the focus tracker.
       *
       * #### Notes
       * If the widget is the `currentWidget`, the previous current widget
       * will become the new `currentWidget`.
       *
       * A widget will be automatically removed from the tracker if it
       * is disposed after being added.
       *
       * If the widget is not tracked, this is a no-op.
       */
      remove(widget) {
        if (!this._numbers.has(widget)) {
          return;
        }
        widget.disposed.disconnect(this._onWidgetDisposed, this);
        widget.node.removeEventListener("focus", this, true);
        widget.node.removeEventListener("blur", this, true);
        ArrayExt3.removeFirstOf(this._widgets, widget);
        this._nodes.delete(widget.node);
        this._numbers.delete(widget);
        if (this._currentWidget !== widget) {
          return;
        }
        let valid = this._widgets.filter((w) => this._numbers.get(w) !== -1);
        let previous = max(valid, (first, second) => {
          let a = this._numbers.get(first);
          let b = this._numbers.get(second);
          return a - b;
        }) || null;
        this._setWidgets(previous, null);
      }
      /**
       * Handle the DOM events for the focus tracker.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the tracked nodes. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "focus":
            this._evtFocus(event);
            break;
          case "blur":
            this._evtBlur(event);
            break;
        }
      }
      /**
       * Set the current and active widgets for the tracker.
       */
      _setWidgets(current, active) {
        let oldCurrent = this._currentWidget;
        this._currentWidget = current;
        let oldActive = this._activeWidget;
        this._activeWidget = active;
        if (oldCurrent !== current) {
          this._currentChanged.emit({ oldValue: oldCurrent, newValue: current });
        }
        if (oldActive !== active) {
          this._activeChanged.emit({ oldValue: oldActive, newValue: active });
        }
      }
      /**
       * Handle the `'focus'` event for a tracked widget.
       */
      _evtFocus(event) {
        let widget = this._nodes.get(event.currentTarget);
        if (widget !== this._currentWidget) {
          this._numbers.set(widget, this._counter++);
        }
        this._setWidgets(widget, widget);
      }
      /**
       * Handle the `'blur'` event for a tracked widget.
       */
      _evtBlur(event) {
        let widget = this._nodes.get(event.currentTarget);
        let focusTarget = event.relatedTarget;
        if (!focusTarget) {
          this._setWidgets(this._currentWidget, null);
          return;
        }
        if (widget.node.contains(focusTarget)) {
          return;
        }
        if (!find2(this._widgets, (w) => w.node.contains(focusTarget))) {
          this._setWidgets(this._currentWidget, null);
          return;
        }
      }
      /**
       * Handle the `disposed` signal for a tracked widget.
       */
      _onWidgetDisposed(sender) {
        this.remove(sender);
      }
    };
    GridLayout = class extends Layout {
      /**
       * Construct a new grid layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        super(options);
        this._dirty = false;
        this._rowSpacing = 4;
        this._columnSpacing = 4;
        this._items = [];
        this._rowStarts = [];
        this._columnStarts = [];
        this._rowSizers = [new BoxSizer()];
        this._columnSizers = [new BoxSizer()];
        this._box = null;
        if (options.rowCount !== void 0) {
          Private$4.reallocSizers(this._rowSizers, options.rowCount);
        }
        if (options.columnCount !== void 0) {
          Private$4.reallocSizers(this._columnSizers, options.columnCount);
        }
        if (options.rowSpacing !== void 0) {
          this._rowSpacing = Private$4.clampValue(options.rowSpacing);
        }
        if (options.columnSpacing !== void 0) {
          this._columnSpacing = Private$4.clampValue(options.columnSpacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          let widget = item.widget;
          item.dispose();
          widget.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._rowStarts.length = 0;
        this._rowSizers.length = 0;
        this._columnStarts.length = 0;
        this._columnSizers.length = 0;
        super.dispose();
      }
      /**
       * Get the number of rows in the layout.
       */
      get rowCount() {
        return this._rowSizers.length;
      }
      /**
       * Set the number of rows in the layout.
       *
       * #### Notes
       * The minimum row count is `1`.
       */
      set rowCount(value) {
        if (value === this.rowCount) {
          return;
        }
        Private$4.reallocSizers(this._rowSizers, value);
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the number of columns in the layout.
       */
      get columnCount() {
        return this._columnSizers.length;
      }
      /**
       * Set the number of columns in the layout.
       *
       * #### Notes
       * The minimum column count is `1`.
       */
      set columnCount(value) {
        if (value === this.columnCount) {
          return;
        }
        Private$4.reallocSizers(this._columnSizers, value);
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the row spacing for the layout.
       */
      get rowSpacing() {
        return this._rowSpacing;
      }
      /**
       * Set the row spacing for the layout.
       */
      set rowSpacing(value) {
        value = Private$4.clampValue(value);
        if (this._rowSpacing === value) {
          return;
        }
        this._rowSpacing = value;
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the column spacing for the layout.
       */
      get columnSpacing() {
        return this._columnSpacing;
      }
      /**
       * Set the col spacing for the layout.
       */
      set columnSpacing(value) {
        value = Private$4.clampValue(value);
        if (this._columnSpacing === value) {
          return;
        }
        this._columnSpacing = value;
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the stretch factor for a specific row.
       *
       * @param index - The row index of interest.
       *
       * @returns The stretch factor for the row.
       *
       * #### Notes
       * This returns `-1` if the index is out of range.
       */
      rowStretch(index) {
        let sizer = this._rowSizers[index];
        return sizer ? sizer.stretch : -1;
      }
      /**
       * Set the stretch factor for a specific row.
       *
       * @param index - The row index of interest.
       *
       * @param value - The stretch factor for the row.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      setRowStretch(index, value) {
        let sizer = this._rowSizers[index];
        if (!sizer) {
          return;
        }
        value = Private$4.clampValue(value);
        if (sizer.stretch === value) {
          return;
        }
        sizer.stretch = value;
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Get the stretch factor for a specific column.
       *
       * @param index - The column index of interest.
       *
       * @returns The stretch factor for the column.
       *
       * #### Notes
       * This returns `-1` if the index is out of range.
       */
      columnStretch(index) {
        let sizer = this._columnSizers[index];
        return sizer ? sizer.stretch : -1;
      }
      /**
       * Set the stretch factor for a specific column.
       *
       * @param index - The column index of interest.
       *
       * @param value - The stretch factor for the column.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      setColumnStretch(index, value) {
        let sizer = this._columnSizers[index];
        if (!sizer) {
          return;
        }
        value = Private$4.clampValue(value);
        if (sizer.stretch === value) {
          return;
        }
        sizer.stretch = value;
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        for (const item of this._items) {
          yield item.widget;
        }
      }
      /**
       * Add a widget to the grid layout.
       *
       * @param widget - The widget to add to the layout.
       *
       * #### Notes
       * If the widget is already contained in the layout, this is no-op.
       */
      addWidget(widget) {
        let i = ArrayExt3.findFirstIndex(this._items, (it) => it.widget === widget);
        if (i !== -1) {
          return;
        }
        this._items.push(new LayoutItem(widget));
        if (this.parent) {
          this.attachWidget(widget);
        }
      }
      /**
       * Remove a widget from the grid layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        let i = ArrayExt3.findFirstIndex(this._items, (it) => it.widget === widget);
        if (i === -1) {
          return;
        }
        let item = ArrayExt3.removeAt(this._items, i);
        if (this.parent) {
          this.detachWidget(widget);
        }
        item.dispose();
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param widget - The widget to attach to the parent.
       */
      attachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param widget - The widget to detach from the parent.
       */
      detachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        for (let i = 0, n = this.rowCount; i < n; ++i) {
          this._rowSizers[i].minSize = 0;
        }
        for (let i = 0, n = this.columnCount; i < n; ++i) {
          this._columnSizers[i].minSize = 0;
        }
        let items = this._items.filter((it) => !it.isHidden);
        for (let i = 0, n = items.length; i < n; ++i) {
          items[i].fit();
        }
        let maxRow = this.rowCount - 1;
        let maxCol = this.columnCount - 1;
        items.sort(Private$4.rowSpanCmp);
        for (let i = 0, n = items.length; i < n; ++i) {
          let item = items[i];
          let config = GridLayout.getCellConfig(item.widget);
          let r1 = Math.min(config.row, maxRow);
          let r2 = Math.min(config.row + config.rowSpan - 1, maxRow);
          Private$4.distributeMin(this._rowSizers, r1, r2, item.minHeight);
        }
        items.sort(Private$4.columnSpanCmp);
        for (let i = 0, n = items.length; i < n; ++i) {
          let item = items[i];
          let config = GridLayout.getCellConfig(item.widget);
          let c1 = Math.min(config.column, maxCol);
          let c2 = Math.min(config.column + config.columnSpan - 1, maxCol);
          Private$4.distributeMin(this._columnSizers, c1, c2, item.minWidth);
        }
        if (this.fitPolicy === "set-no-constraint") {
          MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
          return;
        }
        let minH = maxRow * this._rowSpacing;
        let minW = maxCol * this._columnSpacing;
        for (let i = 0, n = this.rowCount; i < n; ++i) {
          minH += this._rowSizers[i].minSize;
        }
        for (let i = 0, n = this.columnCount; i < n; ++i) {
          minW += this._columnSizers[i].minSize;
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let maxRow = this.rowCount - 1;
        let maxCol = this.columnCount - 1;
        let fixedRowSpace = maxRow * this._rowSpacing;
        let fixedColSpace = maxCol * this._columnSpacing;
        BoxEngine.calc(this._rowSizers, Math.max(0, height - fixedRowSpace));
        BoxEngine.calc(this._columnSizers, Math.max(0, width - fixedColSpace));
        for (let i = 0, pos = top, n = this.rowCount; i < n; ++i) {
          this._rowStarts[i] = pos;
          pos += this._rowSizers[i].size + this._rowSpacing;
        }
        for (let i = 0, pos = left, n = this.columnCount; i < n; ++i) {
          this._columnStarts[i] = pos;
          pos += this._columnSizers[i].size + this._columnSpacing;
        }
        for (let i = 0, n = this._items.length; i < n; ++i) {
          let item = this._items[i];
          if (item.isHidden) {
            continue;
          }
          let config = GridLayout.getCellConfig(item.widget);
          let r1 = Math.min(config.row, maxRow);
          let c1 = Math.min(config.column, maxCol);
          let r2 = Math.min(config.row + config.rowSpan - 1, maxRow);
          let c2 = Math.min(config.column + config.columnSpan - 1, maxCol);
          let x = this._columnStarts[c1];
          let y = this._rowStarts[r1];
          let w = this._columnStarts[c2] + this._columnSizers[c2].size - x;
          let h2 = this._rowStarts[r2] + this._rowSizers[r2].size - y;
          item.update(x, y, w, h2);
        }
      }
    };
    (function(GridLayout2) {
      function getCellConfig(widget) {
        return Private$4.cellConfigProperty.get(widget);
      }
      GridLayout2.getCellConfig = getCellConfig;
      function setCellConfig(widget, value) {
        Private$4.cellConfigProperty.set(widget, Private$4.normalizeConfig(value));
      }
      GridLayout2.setCellConfig = setCellConfig;
    })(GridLayout || (GridLayout = {}));
    (function(Private36) {
      Private36.cellConfigProperty = new AttachedProperty2({
        name: "cellConfig",
        create: () => ({ row: 0, column: 0, rowSpan: 1, columnSpan: 1 }),
        changed: onChildCellConfigChanged
      });
      function normalizeConfig(config) {
        let row = Math.max(0, Math.floor(config.row || 0));
        let column = Math.max(0, Math.floor(config.column || 0));
        let rowSpan = Math.max(1, Math.floor(config.rowSpan || 0));
        let columnSpan = Math.max(1, Math.floor(config.columnSpan || 0));
        return { row, column, rowSpan, columnSpan };
      }
      Private36.normalizeConfig = normalizeConfig;
      function clampValue(value) {
        return Math.max(0, Math.floor(value));
      }
      Private36.clampValue = clampValue;
      function rowSpanCmp(a, b) {
        let c1 = Private36.cellConfigProperty.get(a.widget);
        let c2 = Private36.cellConfigProperty.get(b.widget);
        return c1.rowSpan - c2.rowSpan;
      }
      Private36.rowSpanCmp = rowSpanCmp;
      function columnSpanCmp(a, b) {
        let c1 = Private36.cellConfigProperty.get(a.widget);
        let c2 = Private36.cellConfigProperty.get(b.widget);
        return c1.columnSpan - c2.columnSpan;
      }
      Private36.columnSpanCmp = columnSpanCmp;
      function reallocSizers(sizers, count) {
        count = Math.max(1, Math.floor(count));
        while (sizers.length < count) {
          sizers.push(new BoxSizer());
        }
        if (sizers.length > count) {
          sizers.length = count;
        }
      }
      Private36.reallocSizers = reallocSizers;
      function distributeMin(sizers, i1, i2, minSize) {
        if (i2 < i1) {
          return;
        }
        if (i1 === i2) {
          let sizer = sizers[i1];
          sizer.minSize = Math.max(sizer.minSize, minSize);
          return;
        }
        let totalMin = 0;
        for (let i = i1; i <= i2; ++i) {
          totalMin += sizers[i].minSize;
        }
        if (totalMin >= minSize) {
          return;
        }
        let portion = (minSize - totalMin) / (i2 - i1 + 1);
        for (let i = i1; i <= i2; ++i) {
          sizers[i].minSize += portion;
        }
      }
      Private36.distributeMin = distributeMin;
      function onChildCellConfigChanged(child) {
        if (child.parent && child.parent.layout instanceof GridLayout) {
          child.parent.fit();
        }
      }
    })(Private$4 || (Private$4 = {}));
    MenuBar = class extends Widget {
      /**
       * Construct a new menu bar.
       *
       * @param options - The options for initializing the menu bar.
       */
      constructor(options = {}) {
        super({ node: Private$3.createNode() });
        this._activeIndex = -1;
        this._tabFocusIndex = 0;
        this._menus = [];
        this._childMenu = null;
        this._overflowMenu = null;
        this._menuItemSizes = [];
        this._overflowIndex = -1;
        this.addClass("lm-MenuBar");
        this.setFlag(Widget.Flag.DisallowLayout);
        this.renderer = options.renderer || MenuBar.defaultRenderer;
        this._forceItemsPosition = options.forceItemsPosition || {
          forceX: true,
          forceY: true
        };
        this._overflowMenuOptions = options.overflowMenuOptions || {
          isVisible: true
        };
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._closeChildMenu();
        this._menus.length = 0;
        super.dispose();
      }
      /**
       * The child menu of the menu bar.
       *
       * #### Notes
       * This will be `null` if the menu bar does not have an open menu.
       */
      get childMenu() {
        return this._childMenu;
      }
      /**
       * The overflow index of the menu bar.
       */
      get overflowIndex() {
        return this._overflowIndex;
      }
      /**
       * The overflow menu of the menu bar.
       */
      get overflowMenu() {
        return this._overflowMenu;
      }
      /**
       * Get the menu bar content node.
       *
       * #### Notes
       * This is the node which holds the menu title nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-MenuBar-content")[0];
      }
      /**
       * Get the currently active menu.
       */
      get activeMenu() {
        return this._menus[this._activeIndex] || null;
      }
      /**
       * Set the currently active menu.
       *
       * #### Notes
       * If the menu does not exist, the menu will be set to `null`.
       */
      set activeMenu(value) {
        this.activeIndex = value ? this._menus.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently active menu.
       *
       * #### Notes
       * This will be `-1` if no menu is active.
       */
      get activeIndex() {
        return this._activeIndex;
      }
      /**
       * Set the index of the currently active menu.
       *
       * #### Notes
       * If the menu cannot be activated, the index will be set to `-1`.
       */
      set activeIndex(value) {
        if (value < 0 || value >= this._menus.length) {
          value = -1;
        }
        if (value > -1 && this._menus[value].items.length === 0) {
          value = -1;
        }
        if (this._activeIndex === value) {
          return;
        }
        this._activeIndex = value;
        this.update();
      }
      /**
       * A read-only array of the menus in the menu bar.
       */
      get menus() {
        return this._menus;
      }
      /**
       * Open the active menu and activate its first menu item.
       *
       * #### Notes
       * If there is no active menu, this is a no-op.
       */
      openActiveMenu() {
        if (this._activeIndex === -1) {
          return;
        }
        this._openChildMenu();
        if (this._childMenu) {
          this._childMenu.activeIndex = -1;
          this._childMenu.activateNextItem();
        }
      }
      /**
       * Add a menu to the end of the menu bar.
       *
       * @param menu - The menu to add to the menu bar.
       *
       * #### Notes
       * If the menu is already added to the menu bar, it will be moved.
       */
      addMenu(menu, update = true) {
        this.insertMenu(this._menus.length, menu, update);
      }
      /**
       * Insert a menu into the menu bar at the specified index.
       *
       * @param index - The index at which to insert the menu.
       *
       * @param menu - The menu to insert into the menu bar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the menus.
       *
       * If the menu is already added to the menu bar, it will be moved.
       */
      insertMenu(index, menu, update = true) {
        this._closeChildMenu();
        let i = this._menus.indexOf(menu);
        let j = Math.max(0, Math.min(index, this._menus.length));
        if (i === -1) {
          ArrayExt3.insert(this._menus, j, menu);
          menu.addClass("lm-MenuBar-menu");
          menu.aboutToClose.connect(this._onMenuAboutToClose, this);
          menu.menuRequested.connect(this._onMenuMenuRequested, this);
          menu.title.changed.connect(this._onTitleChanged, this);
          if (update) {
            this.update();
          }
          return;
        }
        if (j === this._menus.length) {
          j--;
        }
        if (i === j) {
          return;
        }
        ArrayExt3.move(this._menus, i, j);
        if (update) {
          this.update();
        }
      }
      /**
       * Remove a menu from the menu bar.
       *
       * @param menu - The menu to remove from the menu bar.
       *
       * #### Notes
       * This is a no-op if the menu is not in the menu bar.
       */
      removeMenu(menu, update = true) {
        this.removeMenuAt(this._menus.indexOf(menu), update);
      }
      /**
       * Remove the menu at a given index from the menu bar.
       *
       * @param index - The index of the menu to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeMenuAt(index, update = true) {
        this._closeChildMenu();
        let menu = ArrayExt3.removeAt(this._menus, index);
        if (!menu) {
          return;
        }
        menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
        menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
        menu.title.changed.disconnect(this._onTitleChanged, this);
        menu.removeClass("lm-MenuBar-menu");
        if (update) {
          this.update();
        }
      }
      /**
       * Remove all menus from the menu bar.
       */
      clearMenus() {
        if (this._menus.length === 0) {
          return;
        }
        this._closeChildMenu();
        for (let menu of this._menus) {
          menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
          menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
          menu.title.changed.disconnect(this._onTitleChanged, this);
          menu.removeClass("lm-MenuBar-menu");
        }
        this._menus.length = 0;
        this.update();
      }
      /**
       * Handle the DOM events for the menu bar.
       *
       * @param event - The DOM event sent to the menu bar.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the menu bar's DOM nodes. It
       * should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "mousedown":
            this._evtMouseDown(event);
            break;
          case "mousemove":
            this._evtMouseMove(event);
            break;
          case "focusout":
            this._evtFocusOut(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("mousedown", this);
        this.node.addEventListener("mousemove", this);
        this.node.addEventListener("focusout", this);
        this.node.addEventListener("contextmenu", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("mousedown", this);
        this.node.removeEventListener("mousemove", this);
        this.node.removeEventListener("focusout", this);
        this.node.removeEventListener("contextmenu", this);
        this._closeChildMenu();
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          this._focusItemAt(0);
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        this.update();
        super.onResize(msg);
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        var _a;
        let menus = this._menus;
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let tabFocusIndex = this._tabFocusIndex >= 0 && this._tabFocusIndex < menus.length ? this._tabFocusIndex : 0;
        let length = this._overflowIndex > -1 ? this._overflowIndex : menus.length;
        let totalMenuSize = 0;
        let isVisible = false;
        length = this._overflowMenu !== null ? length - 1 : length;
        let content = new Array(length);
        for (let i = 0; i < length; ++i) {
          content[i] = renderer.renderItem({
            title: menus[i].title,
            active: i === activeIndex,
            tabbable: i === tabFocusIndex,
            disabled: menus[i].items.length === 0,
            onfocus: () => {
              this._tabFocusIndex = i;
              this.activeIndex = i;
            }
          });
          totalMenuSize += this._menuItemSizes[i];
          if (menus[i].title.label === this._overflowMenuOptions.title) {
            isVisible = true;
            length--;
          }
        }
        if (this._overflowMenuOptions.isVisible) {
          if (this._overflowIndex > -1 && !isVisible) {
            if (this._overflowMenu === null) {
              const overflowMenuTitle = (_a = this._overflowMenuOptions.title) !== null && _a !== void 0 ? _a : "...";
              this._overflowMenu = new Menu({ commands: new CommandRegistry() });
              this._overflowMenu.title.label = overflowMenuTitle;
              this._overflowMenu.title.mnemonic = 0;
              this.addMenu(this._overflowMenu, false);
            }
            for (let i = menus.length - 2; i >= length; i--) {
              const submenu = this.menus[i];
              submenu.title.mnemonic = 0;
              this._overflowMenu.insertItem(0, {
                type: "submenu",
                submenu
              });
              this.removeMenu(submenu, false);
            }
            content[length] = renderer.renderItem({
              title: this._overflowMenu.title,
              active: length === activeIndex && menus[length].items.length !== 0,
              tabbable: length === tabFocusIndex,
              disabled: menus[length].items.length === 0,
              onfocus: () => {
                this._tabFocusIndex = length;
                this.activeIndex = length;
              }
            });
            length++;
          } else if (this._overflowMenu !== null) {
            let overflowMenuItems = this._overflowMenu.items;
            let screenSize = this.node.offsetWidth;
            let n = this._overflowMenu.items.length;
            for (let i = 0; i < n; ++i) {
              let index = menus.length - 1 - i;
              if (screenSize - totalMenuSize > this._menuItemSizes[index]) {
                let menu = overflowMenuItems[0].submenu;
                this._overflowMenu.removeItemAt(0);
                this.insertMenu(length, menu, false);
                content[length] = renderer.renderItem({
                  title: menu.title,
                  active: false,
                  tabbable: length === tabFocusIndex,
                  disabled: menus[length].items.length === 0,
                  onfocus: () => {
                    this._tabFocusIndex = length;
                    this.activeIndex = length;
                  }
                });
                length++;
              }
            }
            if (this._overflowMenu.items.length === 0) {
              this.removeMenu(this._overflowMenu, false);
              content.pop();
              this._overflowMenu = null;
              this._overflowIndex = -1;
            }
          }
        }
        VirtualDOM.render(content, this.contentNode);
        this._updateOverflowIndex();
      }
      /**
       * Calculate and update the current overflow index.
       */
      _updateOverflowIndex() {
        if (!this._overflowMenuOptions.isVisible) {
          return;
        }
        const itemMenus = this.contentNode.childNodes;
        let screenSize = this.node.offsetWidth;
        let totalMenuSize = 0;
        let index = -1;
        let n = itemMenus.length;
        if (this._menuItemSizes.length == 0) {
          for (let i = 0; i < n; i++) {
            let item = itemMenus[i];
            totalMenuSize += item.offsetWidth;
            this._menuItemSizes.push(item.offsetWidth);
            if (totalMenuSize > screenSize && index === -1) {
              index = i;
            }
          }
        } else {
          for (let i = 0; i < this._menuItemSizes.length; i++) {
            totalMenuSize += this._menuItemSizes[i];
            if (totalMenuSize > screenSize) {
              index = i;
              break;
            }
          }
        }
        this._overflowIndex = index;
      }
      /**
       * Handle the `'keydown'` event for the menu bar.
       *
       * #### Notes
       * All keys are trapped except the tab key that is ignored.
       */
      _evtKeyDown(event) {
        let kc = event.keyCode;
        if (kc === 9) {
          this.activeIndex = -1;
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (kc === 13 || kc === 32 || kc === 38 || kc === 40) {
          this.activeIndex = this._tabFocusIndex;
          if (this.activeIndex !== this._tabFocusIndex) {
            return;
          }
          this.openActiveMenu();
          return;
        }
        if (kc === 27) {
          this._closeChildMenu();
          this._focusItemAt(this.activeIndex);
          return;
        }
        if (kc === 37 || kc === 39) {
          let direction2 = kc === 37 ? -1 : 1;
          let start2 = this._tabFocusIndex + direction2;
          let n = this._menus.length;
          for (let i = 0; i < n; i++) {
            let index = (n + start2 + direction2 * i) % n;
            if (this._menus[index].items.length) {
              this._focusItemAt(index);
              return;
            }
          }
          return;
        }
        let key2 = getKeyboardLayout().keyForKeydownEvent(event);
        if (!key2) {
          return;
        }
        let start = this._activeIndex + 1;
        let result = Private$3.findMnemonic(this._menus, key2, start);
        if (result.index !== -1 && !result.multiple) {
          this.activeIndex = result.index;
          this.openActiveMenu();
        } else if (result.index !== -1) {
          this.activeIndex = result.index;
          this._focusItemAt(this.activeIndex);
        } else if (result.auto !== -1) {
          this.activeIndex = result.auto;
          this._focusItemAt(this.activeIndex);
        }
      }
      /**
       * Handle the `'mousedown'` event for the menu bar.
       */
      _evtMouseDown(event) {
        if (!ElementExt.hitTest(this.node, event.clientX, event.clientY)) {
          return;
        }
        event.stopPropagation();
        event.stopImmediatePropagation();
        let index = ArrayExt3.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index === -1) {
          this._closeChildMenu();
          return;
        }
        if (event.button !== 0) {
          return;
        }
        if (this._childMenu) {
          this._closeChildMenu();
          this.activeIndex = index;
        } else {
          event.preventDefault();
          const position = this._positionForMenu(index);
          Menu.saveWindowData();
          this.activeIndex = index;
          this._openChildMenu(position);
        }
      }
      /**
       * Handle the `'mousemove'` event for the menu bar.
       */
      _evtMouseMove(event) {
        let index = ArrayExt3.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index === this._activeIndex) {
          return;
        }
        if (index === -1 && this._childMenu) {
          return;
        }
        const position = index >= 0 && this._childMenu ? this._positionForMenu(index) : null;
        Menu.saveWindowData();
        this.activeIndex = index;
        if (position) {
          this._openChildMenu(position);
        }
      }
      /**
       * Find initial position for the menu based on menubar item position.
       *
       * NOTE: this should be called before updating active index to avoid
       * an additional layout and style invalidation as changing active
       * index modifies DOM.
       */
      _positionForMenu(index) {
        let itemNode = this.contentNode.children[index];
        let { left, bottom } = itemNode.getBoundingClientRect();
        return {
          top: bottom,
          left
        };
      }
      /**
       * Handle the `'focusout'` event for the menu bar.
       */
      _evtFocusOut(event) {
        if (!this._childMenu && !this.node.contains(event.relatedTarget)) {
          this.activeIndex = -1;
        }
      }
      /**
       * Focus an item in the menu bar.
       *
       * #### Notes
       * Does not open the associated menu.
       */
      _focusItemAt(index) {
        const itemNode = this.contentNode.childNodes[index];
        if (itemNode) {
          itemNode.focus();
        }
      }
      /**
       * Open the child menu at the active index immediately.
       *
       * If a different child menu is already open, it will be closed,
       * even if there is no active menu.
       */
      _openChildMenu(options = {}) {
        let newMenu = this.activeMenu;
        if (!newMenu) {
          this._closeChildMenu();
          return;
        }
        let oldMenu = this._childMenu;
        if (oldMenu === newMenu) {
          return;
        }
        this._childMenu = newMenu;
        if (oldMenu) {
          oldMenu.close();
        } else {
          document.addEventListener("mousedown", this, true);
        }
        this._tabFocusIndex = this.activeIndex;
        MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);
        let { left, top } = options;
        if (typeof left === "undefined" || typeof top === "undefined") {
          ({ left, top } = this._positionForMenu(this._activeIndex));
        }
        if (!oldMenu) {
          this.addClass("lm-mod-active");
        }
        if (newMenu.items.length > 0) {
          newMenu.open(left, top, this._forceItemsPosition);
        }
      }
      /**
       * Close the child menu immediately.
       *
       * This is a no-op if a child menu is not open.
       */
      _closeChildMenu() {
        if (!this._childMenu) {
          return;
        }
        this.removeClass("lm-mod-active");
        document.removeEventListener("mousedown", this, true);
        let menu = this._childMenu;
        this._childMenu = null;
        menu.close();
        this.activeIndex = -1;
      }
      /**
       * Handle the `aboutToClose` signal of a menu.
       */
      _onMenuAboutToClose(sender) {
        if (sender !== this._childMenu) {
          return;
        }
        this.removeClass("lm-mod-active");
        document.removeEventListener("mousedown", this, true);
        this._childMenu = null;
        this.activeIndex = -1;
      }
      /**
       * Handle the `menuRequested` signal of a child menu.
       */
      _onMenuMenuRequested(sender, args) {
        if (sender !== this._childMenu) {
          return;
        }
        let i = this._activeIndex;
        let n = this._menus.length;
        switch (args) {
          case "next":
            this.activeIndex = i === n - 1 ? 0 : i + 1;
            break;
          case "previous":
            this.activeIndex = i === 0 ? n - 1 : i - 1;
            break;
        }
        this.openActiveMenu();
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged() {
        this.update();
      }
    };
    (function(MenuBar2) {
      class Renderer {
        /**
         * Render the virtual element for a menu bar item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          let aria = this.createItemARIA(data);
          return h.li({
            className,
            dataset,
            ...data.disabled ? {} : { tabindex: data.tabbable ? "0" : "-1" },
            onfocus: data.onfocus,
            ...aria
          }, this.renderIcon(data), this.renderLabel(data));
        }
        /**
         * Render the icon element for a menu bar item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the item icon.
         */
        renderIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.title.icon, data.title.iconLabel);
        }
        /**
         * Render the label element for a menu item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the item label.
         */
        renderLabel(data) {
          let content = this.formatLabel(data);
          return h.div({ className: "lm-MenuBar-itemLabel" }, content);
        }
        /**
         * Create the class name for the menu bar item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the menu item.
         */
        createItemClass(data) {
          let name2 = "lm-MenuBar-item";
          if (data.title.className) {
            name2 += ` ${data.title.className}`;
          }
          if (data.active && !data.disabled) {
            name2 += " lm-mod-active";
          }
          return name2;
        }
        /**
         * Create the dataset for a menu bar item.
         *
         * @param data - The data to use for the item.
         *
         * @returns The dataset for the menu bar item.
         */
        createItemDataset(data) {
          return data.title.dataset;
        }
        /**
         * Create the aria attributes for menu bar item.
         *
         * @param data - The data to use for the aria attributes.
         *
         * @returns The aria attributes object for the item.
         */
        createItemARIA(data) {
          return {
            role: "menuitem",
            "aria-haspopup": "true",
            "aria-disabled": data.disabled ? "true" : "false"
          };
        }
        /**
         * Create the class name for the menu bar item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name2 = "lm-MenuBar-itemIcon";
          let extra = data.title.iconClass;
          return extra ? `${name2} ${extra}` : name2;
        }
        /**
         * Create the render content for the label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatLabel(data) {
          let { label, mnemonic } = data.title;
          if (mnemonic < 0 || mnemonic >= label.length) {
            return label;
          }
          let prefix = label.slice(0, mnemonic);
          let suffix = label.slice(mnemonic + 1);
          let char = label[mnemonic];
          let span = h.span({ className: "lm-MenuBar-itemMnemonic" }, char);
          return [prefix, span, suffix];
        }
      }
      MenuBar2.Renderer = Renderer;
      MenuBar2.defaultRenderer = new Renderer();
    })(MenuBar || (MenuBar = {}));
    (function(Private36) {
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.className = "lm-MenuBar-content";
        node.appendChild(content);
        content.setAttribute("role", "menubar");
        return node;
      }
      Private36.createNode = createNode;
      function findMnemonic(menus, key2, start) {
        let index = -1;
        let auto = -1;
        let multiple = false;
        let upperKey = key2.toUpperCase();
        for (let i = 0, n = menus.length; i < n; ++i) {
          let k = (i + start) % n;
          let title = menus[k].title;
          if (title.label.length === 0) {
            continue;
          }
          let mn = title.mnemonic;
          if (mn >= 0 && mn < title.label.length) {
            if (title.label[mn].toUpperCase() === upperKey) {
              if (index === -1) {
                index = k;
              } else {
                multiple = true;
              }
            }
            continue;
          }
          if (auto === -1 && title.label[0].toUpperCase() === upperKey) {
            auto = k;
          }
        }
        return { index, multiple, auto };
      }
      Private36.findMnemonic = findMnemonic;
    })(Private$3 || (Private$3 = {}));
    (function(Private36) {
      function createNode() {
        let node = document.createElement("div");
        let decrement = document.createElement("div");
        let increment = document.createElement("div");
        let track = document.createElement("div");
        let thumb = document.createElement("div");
        decrement.className = "lm-ScrollBar-button";
        increment.className = "lm-ScrollBar-button";
        decrement.dataset["action"] = "decrement";
        increment.dataset["action"] = "increment";
        track.className = "lm-ScrollBar-track";
        thumb.className = "lm-ScrollBar-thumb";
        track.appendChild(thumb);
        node.appendChild(decrement);
        node.appendChild(track);
        node.appendChild(increment);
        return node;
      }
      Private36.createNode = createNode;
      function findPart(scrollBar, target2) {
        if (scrollBar.thumbNode.contains(target2)) {
          return "thumb";
        }
        if (scrollBar.trackNode.contains(target2)) {
          return "track";
        }
        if (scrollBar.decrementNode.contains(target2)) {
          return "decrement";
        }
        if (scrollBar.incrementNode.contains(target2)) {
          return "increment";
        }
        return null;
      }
      Private36.findPart = findPart;
    })(Private$2 || (Private$2 = {}));
    SingletonLayout = class extends Layout {
      constructor() {
        super(...arguments);
        this._widget = null;
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        if (this._widget) {
          let widget = this._widget;
          this._widget = null;
          widget.dispose();
        }
        super.dispose();
      }
      /**
       * Get the child widget for the layout.
       */
      get widget() {
        return this._widget;
      }
      /**
       * Set the child widget for the layout.
       *
       * #### Notes
       * Setting the child widget will cause the old child widget to be
       * automatically disposed. If that is not desired, set the parent
       * of the old child to `null` before assigning a new child.
       */
      set widget(widget) {
        if (widget) {
          widget.parent = this.parent;
        }
        if (this._widget === widget) {
          return;
        }
        if (this._widget) {
          this._widget.dispose();
        }
        this._widget = widget;
        if (this.parent && widget) {
          this.attachWidget(widget);
        }
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        if (this._widget) {
          yield this._widget;
        }
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        if (this._widget !== widget) {
          return;
        }
        this._widget = null;
        if (this.parent) {
          this.detachWidget(widget);
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This method is called automatically by the single layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation adds the widgets's node to the parent's
       * node at the proper location, and sends the appropriate attach
       * messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is added to the parent's node.
       */
      attachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This method is called automatically by the single layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation removes the widget's node from the
       * parent's node, and sends the appropriate detach messages to the
       * widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is removed from the parent's node.
       */
      detachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
      }
    };
    StackedLayout = class extends PanelLayout {
      constructor(options = {}) {
        super(options);
        this._dirty = false;
        this._items = [];
        this._box = null;
        this._hiddenMode = options.hiddenMode !== void 0 ? options.hiddenMode : Widget.HiddenMode.Display;
      }
      /**
       * The method for hiding widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      /**
       * Set the method for hiding widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      set hiddenMode(v) {
        if (this._hiddenMode === v) {
          return;
        }
        this._hiddenMode = v;
        if (this.widgets.length > 1) {
          this.widgets.forEach((w) => {
            w.hiddenMode = this._hiddenMode;
          });
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        super.dispose();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index, widget) {
        if (this._hiddenMode === Widget.HiddenMode.Scale && this._items.length > 0) {
          if (this._items.length === 1) {
            this.widgets[0].hiddenMode = Widget.HiddenMode.Scale;
          }
          widget.hiddenMode = Widget.HiddenMode.Scale;
        } else {
          widget.hiddenMode = Widget.HiddenMode.Display;
        }
        ArrayExt3.insert(this._items, index, new LayoutItem(widget));
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt3.move(this._items, fromIndex, toIndex);
        this.parent.update();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index, widget) {
        let item = ArrayExt3.removeAt(this._items, index);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
        item.widget.node.style.zIndex = "";
        if (this._hiddenMode === Widget.HiddenMode.Scale) {
          widget.hiddenMode = Widget.HiddenMode.Display;
          if (this._items.length === 1) {
            this._items[0].widget.hiddenMode = Widget.HiddenMode.Display;
          }
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let minW = 0;
        let minH = 0;
        for (let i = 0, n = this._items.length; i < n; ++i) {
          let item = this._items[i];
          if (item.isHidden) {
            continue;
          }
          item.fit();
          minW = Math.max(minW, item.minWidth);
          minH = Math.max(minH, item.minHeight);
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i = 0, n = this._items.length; i < n; ++i) {
          nVisible += +!this._items[i].isHidden;
        }
        if (nVisible === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        for (let i = 0, n = this._items.length; i < n; ++i) {
          let item = this._items[i];
          if (item.isHidden) {
            continue;
          }
          item.widget.node.style.zIndex = `${i}`;
          item.update(left, top, width, height);
        }
      }
    };
    (function(Private36) {
      function createLayout(options) {
        return options.layout || new StackedLayout();
      }
      Private36.createLayout = createLayout;
    })(Private$1 || (Private$1 = {}));
    (function(Private36) {
      function orientationFromPlacement(plc) {
        return placementToOrientationMap[plc];
      }
      Private36.orientationFromPlacement = orientationFromPlacement;
      function directionFromPlacement(plc) {
        return placementToDirectionMap[plc];
      }
      Private36.directionFromPlacement = directionFromPlacement;
      const placementToOrientationMap = {
        top: "horizontal",
        left: "vertical",
        right: "vertical",
        bottom: "horizontal"
      };
      const placementToDirectionMap = {
        top: "top-to-bottom",
        left: "left-to-right",
        right: "right-to-left",
        bottom: "bottom-to-top"
      };
    })(Private17 || (Private17 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/commandpalettesvg.js
var searchHeaderIcon, CommandPaletteSvg;
var init_commandpalettesvg = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/commandpalettesvg.js"() {
    init_index_es67();
    init_index_es618();
    init_style();
    init_utils2();
    init_iconimports();
    searchHeaderIcon = filterListIcon.bindprops({
      stylesheet: "commandPaletteHeader",
      className: "jp-icon-hoverShow-content"
    });
    (function(CommandPaletteSvg2) {
      class Renderer extends CommandPalette.Renderer {
        /**
         * Render the virtual element for a command palette header.
         *
         * @param data - The data to use for rendering the header.
         *
         * @returns A virtual element representing the header.
         */
        renderHeader(data) {
          const content = this.formatHeader(data);
          return h.li({
            className: classes("lm-CommandPalette-header", "jp-icon-hoverShow")
          }, content, h.span(searchHeaderIcon));
        }
        /**
         * Render the icon for a command palette item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the icon.
         */
        renderItemIcon(data) {
          const className = this.createIconClass(data);
          if (data.item.isToggled) {
            return h.div({ className }, checkIcon, data.item.iconLabel);
          }
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Create the class name for the command item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name2 = "lm-CommandPalette-itemIcon";
          return classes(LabIconStyle.styleClass({
            stylesheet: "commandPaletteItem"
          }), data.item.iconClass, name2);
        }
      }
      CommandPaletteSvg2.Renderer = Renderer;
      CommandPaletteSvg2.defaultRenderer = new Renderer();
    })(CommandPaletteSvg || (CommandPaletteSvg = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/menusvg.js
var submenuIcon, MenuSvg;
var init_menusvg = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/menusvg.js"() {
    init_index_es63();
    init_index_es67();
    init_index_es618();
    init_style();
    init_utils2();
    init_iconimports();
    submenuIcon = caretRightIcon.bindprops({
      stylesheet: "menuItem"
    });
    MenuSvg = class extends Menu {
      /**
       * construct a new menu. Overrides the default renderer
       *
       * @param options - The options for initializing the tab bar.
       */
      constructor(options) {
        options.renderer = options.renderer || MenuSvg.defaultRenderer;
        super(options);
      }
      /**
       * insert a menu item into the menu at the specified index. Replaces the
       * default renderer for submenus
       *
       * @param index - The index at which to insert the item.
       *
       * @param options - The options for creating the menu item.
       *
       * @returns The menu item added to the menu.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       */
      insertItem(index, options) {
        if (options.submenu) {
          MenuSvg.overrideDefaultRenderer(options.submenu);
        }
        return super.insertItem(index, options);
      }
    };
    (function(MenuSvg2) {
      function overrideDefaultRenderer(menu) {
        if (menu.renderer === Menu.defaultRenderer) {
          menu.renderer = MenuSvg2.defaultRenderer;
        }
        const originalInsertItem = menu.insertItem.bind(menu);
        menu.insertItem = (index, options) => {
          if (options.submenu) {
            MenuSvg2.overrideDefaultRenderer(options.submenu);
          }
          return originalInsertItem(index, options);
        };
        for (const item of menu._items) {
          if (item.submenu) {
            overrideDefaultRenderer(item.submenu);
          }
        }
      }
      MenuSvg2.overrideDefaultRenderer = overrideDefaultRenderer;
      class Renderer extends Menu.Renderer {
        /**
         * Render the icon element for a menu item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the item icon.
         */
        renderIcon(data) {
          const className = this.createIconClass(data);
          if (data.item.isToggled) {
            return h.div({ className }, checkIcon, data.item.iconLabel);
          }
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Create the class name for the menu item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name2 = "lm-Menu-itemIcon";
          if (data.item.type === "separator") {
            return classes(data.item.iconClass, name2);
          } else {
            return classes(LabIconStyle.styleClass({ stylesheet: "menuItem" }), data.item.iconClass, name2);
          }
        }
        /**
         * Render the submenu icon element for a menu item.
         *
         * @param data - The data to use for rendering the submenu icon.
         *
         * @returns A virtual element representing the submenu icon.
         */
        renderSubmenu(data) {
          const className = "lm-Menu-itemSubmenuIcon";
          if (data.item.type === "submenu") {
            return h.div({ className }, submenuIcon);
          } else {
            return h.div({ className });
          }
        }
      }
      MenuSvg2.Renderer = Renderer;
      MenuSvg2.defaultRenderer = new Renderer();
    })(MenuSvg || (MenuSvg = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/tabbarsvg.js
var TabBarSvg, DockPanelSvg;
var init_tabbarsvg = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/tabbarsvg.js"() {
    init_lib();
    init_index_es67();
    init_index_es618();
    init_style();
    init_utils2();
    init_iconimports();
    TabBarSvg = class extends TabBar {
      /**
       * Construct a new tab bar. Overrides the default renderer.
       *
       * @param options - The options for initializing the tab bar.
       */
      constructor(options = {}) {
        var _a;
        super({ renderer: TabBarSvg.defaultRenderer, ...options });
        const trans = ((_a = TabBarSvg.translator) !== null && _a !== void 0 ? _a : nullTranslator).load("jupyterlab");
        addIcon.element({
          container: this.addButtonNode,
          title: trans.__("New Launcher")
        });
      }
    };
    TabBarSvg.translator = null;
    (function(TabBarSvg2) {
      class Renderer extends TabBar.Renderer {
        /**
         * Render the close icon element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab close icon.
         */
        renderCloseIcon(data) {
          var _a;
          const trans = ((_a = TabBarSvg2.translator) !== null && _a !== void 0 ? _a : nullTranslator).load("jupyterlab");
          const title = data.title.label ? trans.__("Close %1", data.title.label) : trans.__("Close tab");
          const className = classes("jp-icon-hover lm-TabBar-tabCloseIcon", LabIconStyle.styleClass({
            elementPosition: "center",
            height: "16px",
            width: "16px"
          }));
          return hpass("div", { className, title }, closeIcon);
        }
      }
      TabBarSvg2.Renderer = Renderer;
      TabBarSvg2.defaultRenderer = new Renderer();
    })(TabBarSvg || (TabBarSvg = {}));
    DockPanelSvg = class extends DockPanel {
      /**
       * Construct a new dock panel.
       *
       * @param options - The options for initializing the panel.
       */
      constructor(options = {}) {
        super({
          renderer: DockPanelSvg.defaultRenderer,
          ...options
        });
      }
    };
    (function(DockPanelSvg2) {
      class Renderer extends DockPanel.Renderer {
        /**
         * Create a new tab bar (with inline svg icons enabled
         * for use with a dock panel.
         *
         * @returns A new tab bar for a dock panel.
         */
        createTabBar() {
          const bar = new TabBarSvg();
          bar.addClass("lm-DockPanel-tabBar");
          return bar;
        }
      }
      DockPanelSvg2.Renderer = Renderer;
      DockPanelSvg2.defaultRenderer = new Renderer();
    })(DockPanelSvg || (DockPanelSvg = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/index.js
var init_widgets = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/index.js"() {
    init_commandpalettesvg();
    init_menusvg();
    init_tabbarsvg();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/icon/index.js
var init_icon2 = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/icon/index.js"() {
    init_iconimports();
    init_labicon();
    init_widgets();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/inputgroup.js
function InputGroup(props) {
  const { className, inputRef, rightIcon, ...others } = props;
  return import_react3.default.createElement(
    "div",
    { className: classes("jp-InputGroup", className) },
    import_react3.default.createElement("input", { ref: inputRef, ...others }),
    rightIcon && import_react3.default.createElement("span", { className: "jp-InputGroupAction" }, typeof rightIcon === "string" ? import_react3.default.createElement(LabIcon.resolveReact, { icon: rightIcon, elementPosition: "center", tag: "span" }) : import_react3.default.createElement(rightIcon.react, { elementPosition: "center", tag: "span" }))
  );
}
var import_react3;
var init_inputgroup = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/inputgroup.js"() {
    import_react3 = __toESM(require_react());
    init_icon2();
    init_utils2();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/button.js
function Button(props) {
  const { minimal, small, children: children2, ...others } = props;
  return import_react4.default.createElement("button", { ...others, className: classes(props.className, minimal ? "jp-mod-minimal" : "", small ? "jp-mod-small" : "", "jp-Button") }, children2);
}
var import_react4;
var init_button = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/button.js"() {
    import_react4 = __toESM(require_react());
    init_utils2();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/collapser.js
var init_collapser = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/collapser.js"() {
    init_index_es63();
    init_index_es618();
  }
});

// ../../node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "../../node_modules/react/cjs/react-jsx-runtime.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React20 = require_react();
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React20.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name2, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component8) {
          var prototype = Component8.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has5 = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has5(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self2) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type, key2, ref2, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key: key2,
            ref: ref2,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type, config, maybeKey, source, self2) {
          {
            var propName;
            var props = {};
            var key2 = null;
            var ref2 = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key2 = "" + maybeKey;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key2 = "" + config.key;
            }
            if (hasValidRef(config)) {
              ref2 = config.ref;
              warnIfStringRefCannotBeAutoConverted(config, self2);
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            if (key2 || ref2) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key2) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref2) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type, key2, ref2, self2, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name2 = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name2) {
                return "\n\nCheck the render method of `" + name2 + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name2 = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name2, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key2 = keys[i];
              if (key2 !== "children" && key2 !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key2);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function jsxWithValidation(type, props, key2, isStaticChildren, source, self2) {
          {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type, props, key2, source, self2);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children2 = props.children;
              if (children2 !== void 0) {
                if (isStaticChildren) {
                  if (isArray(children2)) {
                    for (var i = 0; i < children2.length; i++) {
                      validateChildKeys(children2[i], type);
                    }
                    if (Object.freeze) {
                      Object.freeze(children2);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children2, type);
                }
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type, props, key2) {
          {
            return jsxWithValidation(type, props, key2, true);
          }
        }
        function jsxWithValidationDynamic(type, props, key2) {
          {
            return jsxWithValidation(type, props, key2, false);
          }
        }
        var jsx = jsxWithValidationDynamic;
        var jsxs = jsxWithValidationStatic;
        exports2.Fragment = REACT_FRAGMENT_TYPE;
        exports2.jsx = jsx;
        exports2.jsxs = jsxs;
      })();
    }
  }
});

// ../../node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "../../node_modules/react/jsx-runtime.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_jsx_runtime_development();
    }
  }
});

// ../../node_modules/@rjsf/utils/lib/isObject.js
var init_isObject = __esm({
  "../../node_modules/@rjsf/utils/lib/isObject.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/allowAdditionalItems.js
var init_allowAdditionalItems = __esm({
  "../../node_modules/@rjsf/utils/lib/allowAdditionalItems.js"() {
    init_isObject();
  }
});

// ../../node_modules/@rjsf/utils/lib/asNumber.js
var init_asNumber = __esm({
  "../../node_modules/@rjsf/utils/lib/asNumber.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/constants.js
var ID_KEY;
var init_constants = __esm({
  "../../node_modules/@rjsf/utils/lib/constants.js"() {
    ID_KEY = "$id";
  }
});

// ../../node_modules/@rjsf/utils/lib/getUiOptions.js
var init_getUiOptions = __esm({
  "../../node_modules/@rjsf/utils/lib/getUiOptions.js"() {
    init_constants();
    init_isObject();
  }
});

// ../../node_modules/@rjsf/utils/lib/canExpand.js
var init_canExpand = __esm({
  "../../node_modules/@rjsf/utils/lib/canExpand.js"() {
    init_getUiOptions();
  }
});

// ../../node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    module2.exports = freeGlobal;
  }
});

// ../../node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// ../../node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// ../../node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// ../../node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// ../../node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// ../../node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../../node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    module2.exports = overArg;
  }
});

// ../../node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "../../node_modules/lodash/_getPrototype.js"(exports2, module2) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// ../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// ../../node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "../../node_modules/lodash/isPlainObject.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject4(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject4;
  }
});

// ../../node_modules/@rjsf/utils/lib/createErrorHandler.js
var import_isPlainObject;
var init_createErrorHandler = __esm({
  "../../node_modules/@rjsf/utils/lib/createErrorHandler.js"() {
    import_isPlainObject = __toESM(require_isPlainObject());
    init_constants();
  }
});

// ../../node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "../../node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// ../../node_modules/lodash/eq.js
var require_eq = __commonJS({
  "../../node_modules/lodash/eq.js"(exports2, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// ../../node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "../../node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key2) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key2)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// ../../node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "../../node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key2) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// ../../node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "../../node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key2) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// ../../node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "../../node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key2) {
      return assocIndexOf(this.__data__, key2) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// ../../node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "../../node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key2, value) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      if (index < 0) {
        ++this.size;
        data.push([key2, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// ../../node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "../../node_modules/lodash/_ListCache.js"(exports2, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// ../../node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "../../node_modules/lodash/_stackClear.js"(exports2, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// ../../node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "../../node_modules/lodash/_stackDelete.js"(exports2, module2) {
    function stackDelete(key2) {
      var data = this.__data__, result = data["delete"](key2);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// ../../node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "../../node_modules/lodash/_stackGet.js"(exports2, module2) {
    function stackGet(key2) {
      return this.__data__.get(key2);
    }
    module2.exports = stackGet;
  }
});

// ../../node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "../../node_modules/lodash/_stackHas.js"(exports2, module2) {
    function stackHas(key2) {
      return this.__data__.has(key2);
    }
    module2.exports = stackHas;
  }
});

// ../../node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject9(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject9;
  }
});

// ../../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../../node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject9 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction2(value) {
      if (!isObject9(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction2;
  }
});

// ../../node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "../../node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// ../../node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "../../node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// ../../node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "../../node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// ../../node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "../../node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction2 = require_isFunction();
    var isMasked = require_isMasked();
    var isObject9 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject9(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// ../../node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "../../node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue(object, key2) {
      return object == null ? void 0 : object[key2];
    }
    module2.exports = getValue;
  }
});

// ../../node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "../../node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key2) {
      var value = getValue(object, key2);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// ../../node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "../../node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// ../../node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "../../node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// ../../node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "../../node_modules/lodash/_hashClear.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// ../../node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "../../node_modules/lodash/_hashDelete.js"(exports2, module2) {
    function hashDelete(key2) {
      var result = this.has(key2) && delete this.__data__[key2];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// ../../node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "../../node_modules/lodash/_hashGet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key2) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key2];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key2) ? data[key2] : void 0;
    }
    module2.exports = hashGet;
  }
});

// ../../node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "../../node_modules/lodash/_hashHas.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key2) {
      var data = this.__data__;
      return nativeCreate ? data[key2] !== void 0 : hasOwnProperty.call(data, key2);
    }
    module2.exports = hashHas;
  }
});

// ../../node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "../../node_modules/lodash/_hashSet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key2, value) {
      var data = this.__data__;
      this.size += this.has(key2) ? 0 : 1;
      data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// ../../node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "../../node_modules/lodash/_Hash.js"(exports2, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// ../../node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "../../node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// ../../node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "../../node_modules/lodash/_isKeyable.js"(exports2, module2) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// ../../node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "../../node_modules/lodash/_getMapData.js"(exports2, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map2, key2) {
      var data = map2.__data__;
      return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// ../../node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "../../node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key2) {
      var result = getMapData(this, key2)["delete"](key2);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// ../../node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "../../node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key2) {
      return getMapData(this, key2).get(key2);
    }
    module2.exports = mapCacheGet;
  }
});

// ../../node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "../../node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key2) {
      return getMapData(this, key2).has(key2);
    }
    module2.exports = mapCacheHas;
  }
});

// ../../node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "../../node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key2, value) {
      var data = getMapData(this, key2), size = data.size;
      data.set(key2, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// ../../node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "../../node_modules/lodash/_MapCache.js"(exports2, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// ../../node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "../../node_modules/lodash/_stackSet.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key2, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key2, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key2, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// ../../node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "../../node_modules/lodash/_Stack.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// ../../node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "../../node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// ../../node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "../../node_modules/lodash/_setCacheHas.js"(exports2, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// ../../node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "../../node_modules/lodash/_SetCache.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// ../../node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "../../node_modules/lodash/_arraySome.js"(exports2, module2) {
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// ../../node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "../../node_modules/lodash/_cacheHas.js"(exports2, module2) {
    function cacheHas(cache2, key2) {
      return cache2.has(key2);
    }
    module2.exports = cacheHas;
  }
});

// ../../node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "../../node_modules/lodash/_equalArrays.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// ../../node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "../../node_modules/lodash/_Uint8Array.js"(exports2, module2) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// ../../node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "../../node_modules/lodash/_mapToArray.js"(exports2, module2) {
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key2) {
        result[++index] = [key2, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// ../../node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "../../node_modules/lodash/_setToArray.js"(exports2, module2) {
    function setToArray(set7) {
      var index = -1, result = Array(set7.size);
      set7.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// ../../node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "../../node_modules/lodash/_equalByTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// ../../node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "../../node_modules/lodash/_arrayPush.js"(exports2, module2) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module2.exports = arrayPush;
  }
});

// ../../node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../../node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// ../../node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "../../node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys;
  }
});

// ../../node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "../../node_modules/lodash/_arrayFilter.js"(exports2, module2) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// ../../node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "../../node_modules/lodash/stubArray.js"(exports2, module2) {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// ../../node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "../../node_modules/lodash/_getSymbols.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// ../../node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "../../node_modules/lodash/_baseTimes.js"(exports2, module2) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// ../../node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "../../node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// ../../node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/lodash/isArguments.js"(exports2, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// ../../node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "../../node_modules/lodash/stubFalse.js"(exports2, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// ../../node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "../../node_modules/lodash/isBuffer.js"(exports2, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// ../../node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../../node_modules/lodash/_isIndex.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// ../../node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "../../node_modules/lodash/isLength.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// ../../node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "../../node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// ../../node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "../../node_modules/lodash/_baseUnary.js"(exports2, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// ../../node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "../../node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// ../../node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "../../node_modules/lodash/isTypedArray.js"(exports2, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// ../../node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "../../node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
        isIndex(key2, length)))) {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// ../../node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "../../node_modules/lodash/_isPrototype.js"(exports2, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// ../../node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "../../node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// ../../node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "../../node_modules/lodash/_baseKeys.js"(exports2, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key2 in Object(object)) {
        if (hasOwnProperty.call(object, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// ../../node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../../node_modules/lodash/isArrayLike.js"(exports2, module2) {
    var isFunction2 = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    module2.exports = isArrayLike;
  }
});

// ../../node_modules/lodash/keys.js
var require_keys = __commonJS({
  "../../node_modules/lodash/keys.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// ../../node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "../../node_modules/lodash/_getAllKeys.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// ../../node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "../../node_modules/lodash/_equalObjects.js"(exports2, module2) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key2 = objProps[index];
        if (!(isPartial ? key2 in other : hasOwnProperty.call(other, key2))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key2 = objProps[index];
        var objValue = object[key2], othValue = other[key2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key2 == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// ../../node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "../../node_modules/lodash/_DataView.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module2.exports = DataView2;
  }
});

// ../../node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "../../node_modules/lodash/_Promise.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// ../../node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "../../node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// ../../node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "../../node_modules/lodash/_WeakMap.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module2.exports = WeakMap2;
  }
});

// ../../node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "../../node_modules/lodash/_getTag.js"(exports2, module2) {
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  }
});

// ../../node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "../../node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// ../../node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "../../node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module2.exports = baseIsEqual;
  }
});

// ../../node_modules/lodash/isEqualWith.js
var require_isEqualWith = __commonJS({
  "../../node_modules/lodash/isEqualWith.js"(exports2, module2) {
    var baseIsEqual = require_baseIsEqual();
    function isEqualWith2(value, other, customizer) {
      customizer = typeof customizer == "function" ? customizer : void 0;
      var result = customizer ? customizer(value, other) : void 0;
      return result === void 0 ? baseIsEqual(value, other, void 0, customizer) : !!result;
    }
    module2.exports = isEqualWith2;
  }
});

// ../../node_modules/@rjsf/utils/lib/deepEquals.js
var import_isEqualWith;
var init_deepEquals = __esm({
  "../../node_modules/@rjsf/utils/lib/deepEquals.js"() {
    import_isEqualWith = __toESM(require_isEqualWith());
  }
});

// ../../node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "../../node_modules/lodash/isSymbol.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// ../../node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "../../node_modules/lodash/_isKey.js"(exports2, module2) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey;
  }
});

// ../../node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "../../node_modules/lodash/memoize.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key2)) {
          return cache2.get(key2);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key2, result) || cache2;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module2.exports = memoize;
  }
});

// ../../node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "../../node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key2) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key2;
      });
      var cache2 = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// ../../node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "../../node_modules/lodash/_stringToPath.js"(exports2, module2) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// ../../node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "../../node_modules/lodash/_arrayMap.js"(exports2, module2) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// ../../node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "../../node_modules/lodash/_baseToString.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// ../../node_modules/lodash/toString.js
var require_toString = __commonJS({
  "../../node_modules/lodash/toString.js"(exports2, module2) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString;
  }
});

// ../../node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "../../node_modules/lodash/_castPath.js"(exports2, module2) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module2.exports = castPath;
  }
});

// ../../node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "../../node_modules/lodash/_toKey.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// ../../node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "../../node_modules/lodash/_baseGet.js"(exports2, module2) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path2) {
      path2 = castPath(path2, object);
      var index = 0, length = path2.length;
      while (object != null && index < length) {
        object = object[toKey(path2[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module2.exports = baseGet;
  }
});

// ../../node_modules/lodash/get.js
var require_get = __commonJS({
  "../../node_modules/lodash/get.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function get17(object, path2, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path2);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get17;
  }
});

// ../../node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
  "../../node_modules/lodash/isEmpty.js"(exports2, module2) {
    var baseKeys = require_baseKeys();
    var getTag = require_getTag();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLike = require_isArrayLike();
    var isBuffer = require_isBuffer();
    var isPrototype = require_isPrototype();
    var isTypedArray = require_isTypedArray();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function isEmpty5(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key2 in value) {
        if (hasOwnProperty.call(value, key2)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = isEmpty5;
  }
});

// ../../node_modules/jsonpointer/jsonpointer.js
var require_jsonpointer = __commonJS({
  "../../node_modules/jsonpointer/jsonpointer.js"(exports2) {
    var hasExcape = /~/;
    var escapeMatcher = /~[01]/g;
    function escapeReplacer(m) {
      switch (m) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + m);
    }
    function untilde(str) {
      if (!hasExcape.test(str))
        return str;
      return str.replace(escapeMatcher, escapeReplacer);
    }
    function setter(obj, pointer, value) {
      var part;
      var hasNextPart;
      for (var p = 1, len = pointer.length; p < len; ) {
        if (pointer[p] === "constructor" || pointer[p] === "prototype" || pointer[p] === "__proto__")
          return obj;
        part = untilde(pointer[p++]);
        hasNextPart = len > p;
        if (typeof obj[part] === "undefined") {
          if (Array.isArray(obj) && part === "-") {
            part = obj.length;
          }
          if (hasNextPart) {
            if (pointer[p] !== "" && pointer[p] < Infinity || pointer[p] === "-")
              obj[part] = [];
            else
              obj[part] = {};
          }
        }
        if (!hasNextPart)
          break;
        obj = obj[part];
      }
      var oldValue = obj[part];
      if (value === void 0)
        delete obj[part];
      else
        obj[part] = value;
      return oldValue;
    }
    function compilePointer(pointer) {
      if (typeof pointer === "string") {
        pointer = pointer.split("/");
        if (pointer[0] === "")
          return pointer;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(pointer)) {
        for (const part of pointer) {
          if (typeof part !== "string" && typeof part !== "number") {
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
          }
        }
        return pointer;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function get17(obj, pointer) {
      if (typeof obj !== "object")
        throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      var len = pointer.length;
      if (len === 1)
        return obj;
      for (var p = 1; p < len; ) {
        obj = obj[untilde(pointer[p++])];
        if (len === p)
          return obj;
        if (typeof obj !== "object" || obj === null)
          return void 0;
      }
    }
    function set7(obj, pointer, value) {
      if (typeof obj !== "object")
        throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      if (pointer.length === 0)
        throw new Error("Invalid JSON pointer for set.");
      return setter(obj, pointer, value);
    }
    function compile(pointer) {
      var compiled = compilePointer(pointer);
      return {
        get: function(object) {
          return get17(object, compiled);
        },
        set: function(object, value) {
          return set7(object, compiled, value);
        }
      };
    }
    exports2.get = get17;
    exports2.set = set7;
    exports2.compile = compile;
  }
});

// ../../node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "../../node_modules/lodash/_arrayEach.js"(exports2, module2) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module2.exports = arrayEach;
  }
});

// ../../node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "../../node_modules/lodash/_defineProperty.js"(exports2, module2) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// ../../node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "../../node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key2, value) {
      if (key2 == "__proto__" && defineProperty) {
        defineProperty(object, key2, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key2] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// ../../node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "../../node_modules/lodash/_assignValue.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key2, value) {
      var objValue = object[key2];
      if (!(hasOwnProperty.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
        baseAssignValue(object, key2, value);
      }
    }
    module2.exports = assignValue;
  }
});

// ../../node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "../../node_modules/lodash/_copyObject.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key2 = props[index];
        var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key2];
        }
        if (isNew) {
          baseAssignValue(object, key2, newValue);
        } else {
          assignValue(object, key2, newValue);
        }
      }
      return object;
    }
    module2.exports = copyObject;
  }
});

// ../../node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "../../node_modules/lodash/_baseAssign.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module2.exports = baseAssign;
  }
});

// ../../node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "../../node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key2 in Object(object)) {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = nativeKeysIn;
  }
});

// ../../node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "../../node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
    var isObject9 = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject9(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key2 in object) {
        if (!(key2 == "constructor" && (isProto || !hasOwnProperty.call(object, key2)))) {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = baseKeysIn;
  }
});

// ../../node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "../../node_modules/lodash/keysIn.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = keysIn;
  }
});

// ../../node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "../../node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module2.exports = baseAssignIn;
  }
});

// ../../node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "../../node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
    var root = require_root();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module2.exports = cloneBuffer;
  }
});

// ../../node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "../../node_modules/lodash/_copyArray.js"(exports2, module2) {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module2.exports = copyArray;
  }
});

// ../../node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "../../node_modules/lodash/_copySymbols.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module2.exports = copySymbols;
  }
});

// ../../node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "../../node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module2.exports = getSymbolsIn;
  }
});

// ../../node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "../../node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module2.exports = copySymbolsIn;
  }
});

// ../../node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "../../node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module2.exports = getAllKeysIn;
  }
});

// ../../node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "../../node_modules/lodash/_initCloneArray.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module2.exports = initCloneArray;
  }
});

// ../../node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "../../node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module2.exports = cloneArrayBuffer;
  }
});

// ../../node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "../../node_modules/lodash/_cloneDataView.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView;
  }
});

// ../../node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "../../node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module2.exports = cloneRegExp;
  }
});

// ../../node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "../../node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module2.exports = cloneSymbol;
  }
});

// ../../node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "../../node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray;
  }
});

// ../../node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "../../node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module2.exports = initCloneByTag;
  }
});

// ../../node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "../../node_modules/lodash/_baseCreate.js"(exports2, module2) {
    var isObject9 = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject9(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module2.exports = baseCreate;
  }
});

// ../../node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "../../node_modules/lodash/_initCloneObject.js"(exports2, module2) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module2.exports = initCloneObject;
  }
});

// ../../node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "../../node_modules/lodash/_baseIsMap.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module2.exports = baseIsMap;
  }
});

// ../../node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "../../node_modules/lodash/isMap.js"(exports2, module2) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module2.exports = isMap;
  }
});

// ../../node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "../../node_modules/lodash/_baseIsSet.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module2.exports = baseIsSet;
  }
});

// ../../node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "../../node_modules/lodash/isSet.js"(exports2, module2) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module2.exports = isSet;
  }
});

// ../../node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "../../node_modules/lodash/_baseClone.js"(exports2, module2) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject9 = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key2, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key2, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject9(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key3) {
          result.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key3) {
        if (props) {
          key3 = subValue;
          subValue = value[key3];
        }
        assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
      });
      return result;
    }
    module2.exports = baseClone;
  }
});

// ../../node_modules/lodash/last.js
var require_last = __commonJS({
  "../../node_modules/lodash/last.js"(exports2, module2) {
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    module2.exports = last;
  }
});

// ../../node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "../../node_modules/lodash/_baseSlice.js"(exports2, module2) {
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    module2.exports = baseSlice;
  }
});

// ../../node_modules/lodash/_parent.js
var require_parent = __commonJS({
  "../../node_modules/lodash/_parent.js"(exports2, module2) {
    var baseGet = require_baseGet();
    var baseSlice = require_baseSlice();
    function parent(object, path2) {
      return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
    }
    module2.exports = parent;
  }
});

// ../../node_modules/lodash/_baseUnset.js
var require_baseUnset = __commonJS({
  "../../node_modules/lodash/_baseUnset.js"(exports2, module2) {
    var castPath = require_castPath();
    var last = require_last();
    var parent = require_parent();
    var toKey = require_toKey();
    function baseUnset(object, path2) {
      path2 = castPath(path2, object);
      object = parent(object, path2);
      return object == null || delete object[toKey(last(path2))];
    }
    module2.exports = baseUnset;
  }
});

// ../../node_modules/lodash/_customOmitClone.js
var require_customOmitClone = __commonJS({
  "../../node_modules/lodash/_customOmitClone.js"(exports2, module2) {
    var isPlainObject4 = require_isPlainObject();
    function customOmitClone(value) {
      return isPlainObject4(value) ? void 0 : value;
    }
    module2.exports = customOmitClone;
  }
});

// ../../node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "../../node_modules/lodash/_isFlattenable.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module2.exports = isFlattenable;
  }
});

// ../../node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "../../node_modules/lodash/_baseFlatten.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module2.exports = baseFlatten;
  }
});

// ../../node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "../../node_modules/lodash/flatten.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    module2.exports = flatten;
  }
});

// ../../node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "../../node_modules/lodash/_apply.js"(exports2, module2) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module2.exports = apply;
  }
});

// ../../node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "../../node_modules/lodash/_overRest.js"(exports2, module2) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform2) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform2(array);
        return apply(func, this, otherArgs);
      };
    }
    module2.exports = overRest;
  }
});

// ../../node_modules/lodash/constant.js
var require_constant = __commonJS({
  "../../node_modules/lodash/constant.js"(exports2, module2) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module2.exports = constant;
  }
});

// ../../node_modules/lodash/identity.js
var require_identity = __commonJS({
  "../../node_modules/lodash/identity.js"(exports2, module2) {
    function identity(value) {
      return value;
    }
    module2.exports = identity;
  }
});

// ../../node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "../../node_modules/lodash/_baseSetToString.js"(exports2, module2) {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module2.exports = baseSetToString;
  }
});

// ../../node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "../../node_modules/lodash/_shortOut.js"(exports2, module2) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module2.exports = shortOut;
  }
});

// ../../node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "../../node_modules/lodash/_setToString.js"(exports2, module2) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module2.exports = setToString;
  }
});

// ../../node_modules/lodash/_flatRest.js
var require_flatRest = __commonJS({
  "../../node_modules/lodash/_flatRest.js"(exports2, module2) {
    var flatten = require_flatten();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function flatRest(func) {
      return setToString(overRest(func, void 0, flatten), func + "");
    }
    module2.exports = flatRest;
  }
});

// ../../node_modules/lodash/omit.js
var require_omit = __commonJS({
  "../../node_modules/lodash/omit.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseClone = require_baseClone();
    var baseUnset = require_baseUnset();
    var castPath = require_castPath();
    var copyObject = require_copyObject();
    var customOmitClone = require_customOmitClone();
    var flatRest = require_flatRest();
    var getAllKeysIn = require_getAllKeysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var omit4 = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path2) {
        path2 = castPath(path2, object);
        isDeep || (isDeep = path2.length > 1);
        return path2;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });
    module2.exports = omit4;
  }
});

// ../../node_modules/@rjsf/utils/lib/findSchemaDefinition.js
var import_jsonpointer, import_omit;
var init_findSchemaDefinition = __esm({
  "../../node_modules/@rjsf/utils/lib/findSchemaDefinition.js"() {
    import_jsonpointer = __toESM(require_jsonpointer());
    import_omit = __toESM(require_omit());
    init_constants();
  }
});

// ../../node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "../../node_modules/lodash/_baseHas.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseHas(object, key2) {
      return object != null && hasOwnProperty.call(object, key2);
    }
    module2.exports = baseHas;
  }
});

// ../../node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "../../node_modules/lodash/_hasPath.js"(exports2, module2) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path2, hasFunc) {
      path2 = castPath(path2, object);
      var index = -1, length = path2.length, result = false;
      while (++index < length) {
        var key2 = toKey(path2[index]);
        if (!(result = object != null && hasFunc(object, key2))) {
          break;
        }
        object = object[key2];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key2, length) && (isArray(object) || isArguments(object));
    }
    module2.exports = hasPath;
  }
});

// ../../node_modules/lodash/has.js
var require_has = __commonJS({
  "../../node_modules/lodash/has.js"(exports2, module2) {
    var baseHas = require_baseHas();
    var hasPath = require_hasPath();
    function has5(object, path2) {
      return object != null && hasPath(object, path2, baseHas);
    }
    module2.exports = has5;
  }
});

// ../../node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
  "../../node_modules/lodash/isNumber.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var numberTag = "[object Number]";
    function isNumber3(value) {
      return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
    }
    module2.exports = isNumber3;
  }
});

// ../../node_modules/lodash/isString.js
var require_isString = __commonJS({
  "../../node_modules/lodash/isString.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isArray = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString4(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    module2.exports = isString4;
  }
});

// ../../node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "../../node_modules/lodash/_arrayReduce.js"(exports2, module2) {
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    module2.exports = arrayReduce;
  }
});

// ../../node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "../../node_modules/lodash/_createBaseFor.js"(exports2, module2) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key2 = props[fromRight ? length : ++index];
          if (iteratee(iterable[key2], key2, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module2.exports = createBaseFor;
  }
});

// ../../node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "../../node_modules/lodash/_baseFor.js"(exports2, module2) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// ../../node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "../../node_modules/lodash/_baseForOwn.js"(exports2, module2) {
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module2.exports = baseForOwn;
  }
});

// ../../node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "../../node_modules/lodash/_createBaseEach.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module2.exports = createBaseEach;
  }
});

// ../../node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "../../node_modules/lodash/_baseEach.js"(exports2, module2) {
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module2.exports = baseEach;
  }
});

// ../../node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "../../node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key2 = data[0], objValue = object[key2], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key2 in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key2, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch;
  }
});

// ../../node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "../../node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
    var isObject9 = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject9(value);
    }
    module2.exports = isStrictComparable;
  }
});

// ../../node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "../../node_modules/lodash/_getMatchData.js"(exports2, module2) {
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key2 = result[length], value = object[key2];
        result[length] = [key2, value, isStrictComparable(value)];
      }
      return result;
    }
    module2.exports = getMatchData;
  }
});

// ../../node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "../../node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
    function matchesStrictComparable(key2, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object));
      };
    }
    module2.exports = matchesStrictComparable;
  }
});

// ../../node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "../../node_modules/lodash/_baseMatches.js"(exports2, module2) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    module2.exports = baseMatches;
  }
});

// ../../node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "../../node_modules/lodash/_baseHasIn.js"(exports2, module2) {
    function baseHasIn(object, key2) {
      return object != null && key2 in Object(object);
    }
    module2.exports = baseHasIn;
  }
});

// ../../node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "../../node_modules/lodash/hasIn.js"(exports2, module2) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path2) {
      return object != null && hasPath(object, path2, baseHasIn);
    }
    module2.exports = hasIn;
  }
});

// ../../node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "../../node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
    var baseIsEqual = require_baseIsEqual();
    var get17 = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path2, srcValue) {
      if (isKey(path2) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path2), srcValue);
      }
      return function(object) {
        var objValue = get17(object, path2);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module2.exports = baseMatchesProperty;
  }
});

// ../../node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "../../node_modules/lodash/_baseProperty.js"(exports2, module2) {
    function baseProperty(key2) {
      return function(object) {
        return object == null ? void 0 : object[key2];
      };
    }
    module2.exports = baseProperty;
  }
});

// ../../node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "../../node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path2) {
      return function(object) {
        return baseGet(object, path2);
      };
    }
    module2.exports = basePropertyDeep;
  }
});

// ../../node_modules/lodash/property.js
var require_property = __commonJS({
  "../../node_modules/lodash/property.js"(exports2, module2) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path2) {
      return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
    }
    module2.exports = property;
  }
});

// ../../node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "../../node_modules/lodash/_baseIteratee.js"(exports2, module2) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module2.exports = baseIteratee;
  }
});

// ../../node_modules/lodash/_baseReduce.js
var require_baseReduce = __commonJS({
  "../../node_modules/lodash/_baseReduce.js"(exports2, module2) {
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    module2.exports = baseReduce;
  }
});

// ../../node_modules/lodash/reduce.js
var require_reduce = __commonJS({
  "../../node_modules/lodash/reduce.js"(exports2, module2) {
    var arrayReduce = require_arrayReduce();
    var baseEach = require_baseEach();
    var baseIteratee = require_baseIteratee();
    var baseReduce = require_baseReduce();
    var isArray = require_isArray();
    function reduce2(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    module2.exports = reduce2;
  }
});

// ../../node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "../../node_modules/lodash/_castFunction.js"(exports2, module2) {
    var identity = require_identity();
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    module2.exports = castFunction;
  }
});

// ../../node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "../../node_modules/lodash/_trimmedEndIndex.js"(exports2, module2) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    module2.exports = trimmedEndIndex;
  }
});

// ../../node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "../../node_modules/lodash/_baseTrim.js"(exports2, module2) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module2.exports = baseTrim;
  }
});

// ../../node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "../../node_modules/lodash/toNumber.js"(exports2, module2) {
    var baseTrim = require_baseTrim();
    var isObject9 = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject9(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject9(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = toNumber;
  }
});

// ../../node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "../../node_modules/lodash/toFinite.js"(exports2, module2) {
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    module2.exports = toFinite;
  }
});

// ../../node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "../../node_modules/lodash/toInteger.js"(exports2, module2) {
    var toFinite = require_toFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    module2.exports = toInteger;
  }
});

// ../../node_modules/lodash/times.js
var require_times = __commonJS({
  "../../node_modules/lodash/times.js"(exports2, module2) {
    var baseTimes = require_baseTimes();
    var castFunction = require_castFunction();
    var toInteger = require_toInteger();
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_ARRAY_LENGTH = 4294967295;
    var nativeMin = Math.min;
    function times3(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
      iteratee = castFunction(iteratee);
      n -= MAX_ARRAY_LENGTH;
      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }
    module2.exports = times3;
  }
});

// ../../node_modules/@rjsf/utils/lib/getOptionMatchingSimpleDiscriminator.js
var import_get;
var init_getOptionMatchingSimpleDiscriminator = __esm({
  "../../node_modules/@rjsf/utils/lib/getOptionMatchingSimpleDiscriminator.js"() {
    import_get = __toESM(require_get());
    init_constants();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/getMatchingOption.js
var import_get2, import_has, import_isNumber;
var init_getMatchingOption = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/getMatchingOption.js"() {
    import_get2 = __toESM(require_get());
    import_has = __toESM(require_has());
    import_isNumber = __toESM(require_isNumber());
    init_constants();
    init_getOptionMatchingSimpleDiscriminator();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/getFirstMatchingOption.js
var init_getFirstMatchingOption = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/getFirstMatchingOption.js"() {
    init_getMatchingOption();
  }
});

// ../../node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
  "../../node_modules/lodash/isEqual.js"(exports2, module2) {
    var baseIsEqual = require_baseIsEqual();
    function isEqual8(value, other) {
      return baseIsEqual(value, other);
    }
    module2.exports = isEqual8;
  }
});

// ../../node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "../../node_modules/lodash/_baseSet.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject9 = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path2, value, customizer) {
      if (!isObject9(object)) {
        return object;
      }
      path2 = castPath(path2, object);
      var index = -1, length = path2.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key2 = toKey(path2[index]), newValue = value;
        if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
          return object;
        }
        if (index != lastIndex) {
          var objValue = nested[key2];
          newValue = customizer ? customizer(objValue, key2, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject9(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key2, newValue);
        nested = nested[key2];
      }
      return object;
    }
    module2.exports = baseSet;
  }
});

// ../../node_modules/lodash/set.js
var require_set = __commonJS({
  "../../node_modules/lodash/set.js"(exports2, module2) {
    var baseSet = require_baseSet();
    function set7(object, path2, value) {
      return object == null ? object : baseSet(object, path2, value);
    }
    module2.exports = set7;
  }
});

// ../../node_modules/lodash/transform.js
var require_transform = __commonJS({
  "../../node_modules/lodash/transform.js"(exports2, module2) {
    var arrayEach = require_arrayEach();
    var baseCreate = require_baseCreate();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    var getPrototype = require_getPrototype();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isFunction2 = require_isFunction();
    var isObject9 = require_isObject();
    var isTypedArray = require_isTypedArray();
    function transform2(object, iteratee, accumulator) {
      var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
      iteratee = baseIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor() : [];
        } else if (isObject9(object)) {
          accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
        } else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
        return iteratee(accumulator, value, index, object2);
      });
      return accumulator;
    }
    module2.exports = transform2;
  }
});

// ../../node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  "../../node_modules/lodash/_assignMergeValue.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object, key2, value) {
      if (value !== void 0 && !eq(object[key2], value) || value === void 0 && !(key2 in object)) {
        baseAssignValue(object, key2, value);
      }
    }
    module2.exports = assignMergeValue;
  }
});

// ../../node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "../../node_modules/lodash/isArrayLikeObject.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module2.exports = isArrayLikeObject;
  }
});

// ../../node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  "../../node_modules/lodash/_safeGet.js"(exports2, module2) {
    function safeGet(object, key2) {
      if (key2 === "constructor" && typeof object[key2] === "function") {
        return;
      }
      if (key2 == "__proto__") {
        return;
      }
      return object[key2];
    }
    module2.exports = safeGet;
  }
});

// ../../node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  "../../node_modules/lodash/toPlainObject.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    module2.exports = toPlainObject;
  }
});

// ../../node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  "../../node_modules/lodash/_baseMergeDeep.js"(exports2, module2) {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction2 = require_isFunction();
    var isObject9 = require_isObject();
    var isPlainObject4 = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key2, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key2), srcValue = safeGet(source, key2), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key2, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject4(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject9(objValue) || isFunction2(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key2, newValue);
    }
    module2.exports = baseMergeDeep;
  }
});

// ../../node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  "../../node_modules/lodash/_baseMerge.js"(exports2, module2) {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject9 = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key2) {
        stack || (stack = new Stack());
        if (isObject9(srcValue)) {
          baseMergeDeep(object, source, key2, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key2, newValue);
        }
      }, keysIn);
    }
    module2.exports = baseMerge;
  }
});

// ../../node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "../../node_modules/lodash/_baseRest.js"(exports2, module2) {
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module2.exports = baseRest;
  }
});

// ../../node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "../../node_modules/lodash/_isIterateeCall.js"(exports2, module2) {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject9 = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject9(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module2.exports = isIterateeCall;
  }
});

// ../../node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "../../node_modules/lodash/_createAssigner.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module2.exports = createAssigner;
  }
});

// ../../node_modules/lodash/merge.js
var require_merge = __commonJS({
  "../../node_modules/lodash/merge.js"(exports2, module2) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var merge2 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    module2.exports = merge2;
  }
});

// ../../node_modules/lodash/flattenDeep.js
var require_flattenDeep = __commonJS({
  "../../node_modules/lodash/flattenDeep.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    var INFINITY = 1 / 0;
    function flattenDeep2(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }
    module2.exports = flattenDeep2;
  }
});

// ../../node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "../../node_modules/lodash/_baseFindIndex.js"(exports2, module2) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseFindIndex;
  }
});

// ../../node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "../../node_modules/lodash/_baseIsNaN.js"(exports2, module2) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module2.exports = baseIsNaN;
  }
});

// ../../node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "../../node_modules/lodash/_strictIndexOf.js"(exports2, module2) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = strictIndexOf;
  }
});

// ../../node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "../../node_modules/lodash/_baseIndexOf.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module2.exports = baseIndexOf;
  }
});

// ../../node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "../../node_modules/lodash/_arrayIncludes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module2.exports = arrayIncludes;
  }
});

// ../../node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "../../node_modules/lodash/_arrayIncludesWith.js"(exports2, module2) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arrayIncludesWith;
  }
});

// ../../node_modules/lodash/noop.js
var require_noop = __commonJS({
  "../../node_modules/lodash/noop.js"(exports2, module2) {
    function noop() {
    }
    module2.exports = noop;
  }
});

// ../../node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "../../node_modules/lodash/_createSet.js"(exports2, module2) {
    var Set2 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    module2.exports = createSet;
  }
});

// ../../node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "../../node_modules/lodash/_baseUniq.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set7 = iteratee ? null : createSet(array);
        if (set7) {
          return setToArray(set7);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseUniq;
  }
});

// ../../node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "../../node_modules/lodash/uniq.js"(exports2, module2) {
    var baseUniq = require_baseUniq();
    function uniq2(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module2.exports = uniq2;
  }
});

// ../../node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "../../node_modules/lodash/cloneDeep.js"(exports2, module2) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep3(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module2.exports = cloneDeep3;
  }
});

// ../../node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "../../node_modules/lodash/_baseMap.js"(exports2, module2) {
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key2, collection2) {
        result[++index] = iteratee(value, key2, collection2);
      });
      return result;
    }
    module2.exports = baseMap;
  }
});

// ../../node_modules/lodash/_baseSortBy.js
var require_baseSortBy = __commonJS({
  "../../node_modules/lodash/_baseSortBy.js"(exports2, module2) {
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    module2.exports = baseSortBy;
  }
});

// ../../node_modules/lodash/_compareAscending.js
var require_compareAscending = __commonJS({
  "../../node_modules/lodash/_compareAscending.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    module2.exports = compareAscending;
  }
});

// ../../node_modules/lodash/_compareMultiple.js
var require_compareMultiple = __commonJS({
  "../../node_modules/lodash/_compareMultiple.js"(exports2, module2) {
    var compareAscending = require_compareAscending();
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    module2.exports = compareMultiple;
  }
});

// ../../node_modules/lodash/_baseOrderBy.js
var require_baseOrderBy = __commonJS({
  "../../node_modules/lodash/_baseOrderBy.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseGet = require_baseGet();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var baseSortBy = require_baseSortBy();
    var baseUnary = require_baseUnary();
    var compareMultiple = require_compareMultiple();
    var identity = require_identity();
    var isArray = require_isArray();
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }
      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key2, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    module2.exports = baseOrderBy;
  }
});

// ../../node_modules/lodash/sortBy.js
var require_sortBy = __commonJS({
  "../../node_modules/lodash/sortBy.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    var baseOrderBy = require_baseOrderBy();
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    module2.exports = sortBy;
  }
});

// ../../node_modules/lodash/uniqWith.js
var require_uniqWith = __commonJS({
  "../../node_modules/lodash/uniqWith.js"(exports2, module2) {
    var baseUniq = require_baseUniq();
    function uniqWith(array, comparator) {
      comparator = typeof comparator == "function" ? comparator : void 0;
      return array && array.length ? baseUniq(array, void 0, comparator) : [];
    }
    module2.exports = uniqWith;
  }
});

// ../../node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "../../node_modules/lodash/defaults.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key2 = props[propsIndex];
          var value = object[key2];
          if (value === void 0 || eq(value, objectProto[key2]) && !hasOwnProperty.call(object, key2)) {
            object[key2] = source[key2];
          }
        }
      }
      return object;
    });
    module2.exports = defaults;
  }
});

// ../../node_modules/lodash/_baseIntersection.js
var require_baseIntersection = __commonJS({
  "../../node_modules/lodash/_baseIntersection.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var nativeMin = Math.min;
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : void 0;
      }
      array = arrays[0];
      var index = -1, seen = caches[0];
      outer:
        while (++index < length && result.length < maxLength) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
            othIndex = othLength;
            while (--othIndex) {
              var cache2 = caches[othIndex];
              if (!(cache2 ? cacheHas(cache2, computed) : includes(arrays[othIndex], computed, comparator))) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseIntersection;
  }
});

// ../../node_modules/lodash/_castArrayLikeObject.js
var require_castArrayLikeObject = __commonJS({
  "../../node_modules/lodash/_castArrayLikeObject.js"(exports2, module2) {
    var isArrayLikeObject = require_isArrayLikeObject();
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }
    module2.exports = castArrayLikeObject;
  }
});

// ../../node_modules/lodash/intersectionWith.js
var require_intersectionWith = __commonJS({
  "../../node_modules/lodash/intersectionWith.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIntersection = require_baseIntersection();
    var baseRest = require_baseRest();
    var castArrayLikeObject = require_castArrayLikeObject();
    var last = require_last();
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
      comparator = typeof comparator == "function" ? comparator : void 0;
      if (comparator) {
        mapped.pop();
      }
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, void 0, comparator) : [];
    });
    module2.exports = intersectionWith;
  }
});

// ../../node_modules/lodash/isBoolean.js
var require_isBoolean = __commonJS({
  "../../node_modules/lodash/isBoolean.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var boolTag = "[object Boolean]";
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
    }
    module2.exports = isBoolean;
  }
});

// ../../node_modules/json-schema-compare/src/index.js
var require_src = __commonJS({
  "../../node_modules/json-schema-compare/src/index.js"(exports2, module2) {
    var isEqual8 = require_isEqual();
    var sortBy = require_sortBy();
    var uniq2 = require_uniq();
    var uniqWith = require_uniqWith();
    var defaults = require_defaults();
    var intersectionWith = require_intersectionWith();
    var isPlainObject4 = require_isPlainObject();
    var isBoolean = require_isBoolean();
    var normalizeArray = (val) => Array.isArray(val) ? val : [val];
    var undef = (val) => val === void 0;
    var keys = (obj) => isPlainObject4(obj) || Array.isArray(obj) ? Object.keys(obj) : [];
    var has5 = (obj, key2) => obj.hasOwnProperty(key2);
    var stringArray = (arr) => sortBy(uniq2(arr));
    var undefEmpty = (val) => undef(val) || Array.isArray(val) && val.length === 0;
    var keyValEqual = (a, b, key2, compare2) => b && has5(b, key2) && a && has5(a, key2) && compare2(a[key2], b[key2]);
    var undefAndZero = (a, b) => undef(a) && b === 0 || undef(b) && a === 0 || isEqual8(a, b);
    var falseUndefined = (a, b) => undef(a) && b === false || undef(b) && a === false || isEqual8(a, b);
    var emptySchema = (schema) => undef(schema) || isEqual8(schema, {}) || schema === true;
    var emptyObjUndef = (schema) => undef(schema) || isEqual8(schema, {});
    var isSchema = (val) => undef(val) || isPlainObject4(val) || val === true || val === false;
    function undefArrayEqual(a, b) {
      if (undefEmpty(a) && undefEmpty(b)) {
        return true;
      } else {
        return isEqual8(stringArray(a), stringArray(b));
      }
    }
    function unsortedNormalizedArray(a, b) {
      a = normalizeArray(a);
      b = normalizeArray(b);
      return isEqual8(stringArray(a), stringArray(b));
    }
    function schemaGroup(a, b, key2, compare2) {
      var allProps = uniq2(keys(a).concat(keys(b)));
      if (emptyObjUndef(a) && emptyObjUndef(b)) {
        return true;
      } else if (emptyObjUndef(a) && keys(b).length) {
        return false;
      } else if (emptyObjUndef(b) && keys(a).length) {
        return false;
      }
      return allProps.every(function(key3) {
        var aVal = a[key3];
        var bVal = b[key3];
        if (Array.isArray(aVal) && Array.isArray(bVal)) {
          return isEqual8(stringArray(a), stringArray(b));
        } else if (Array.isArray(aVal) && !Array.isArray(bVal)) {
          return false;
        } else if (Array.isArray(bVal) && !Array.isArray(aVal)) {
          return false;
        }
        return keyValEqual(a, b, key3, compare2);
      });
    }
    function items(a, b, key2, compare2) {
      if (isPlainObject4(a) && isPlainObject4(b)) {
        return compare2(a, b);
      } else if (Array.isArray(a) && Array.isArray(b)) {
        return schemaGroup(a, b, key2, compare2);
      } else {
        return isEqual8(a, b);
      }
    }
    function unsortedArray(a, b, key2, compare2) {
      var uniqueA = uniqWith(a, compare2);
      var uniqueB = uniqWith(b, compare2);
      var inter = intersectionWith(uniqueA, uniqueB, compare2);
      return inter.length === Math.max(uniqueA.length, uniqueB.length);
    }
    var comparers = {
      title: isEqual8,
      uniqueItems: falseUndefined,
      minLength: undefAndZero,
      minItems: undefAndZero,
      minProperties: undefAndZero,
      required: undefArrayEqual,
      enum: undefArrayEqual,
      type: unsortedNormalizedArray,
      items,
      anyOf: unsortedArray,
      allOf: unsortedArray,
      oneOf: unsortedArray,
      properties: schemaGroup,
      patternProperties: schemaGroup,
      dependencies: schemaGroup
    };
    var acceptsUndefined = [
      "properties",
      "patternProperties",
      "dependencies",
      "uniqueItems",
      "minLength",
      "minItems",
      "minProperties",
      "required"
    ];
    var schemaProps = ["additionalProperties", "additionalItems", "contains", "propertyNames", "not"];
    function compare(a, b, options) {
      options = defaults(options, {
        ignore: []
      });
      if (emptySchema(a) && emptySchema(b)) {
        return true;
      }
      if (!isSchema(a) || !isSchema(b)) {
        throw new Error("Either of the values are not a JSON schema.");
      }
      if (a === b) {
        return true;
      }
      if (isBoolean(a) && isBoolean(b)) {
        return a === b;
      }
      if (a === void 0 && b === false || b === void 0 && a === false) {
        return false;
      }
      if (undef(a) && !undef(b) || !undef(a) && undef(b)) {
        return false;
      }
      var allKeys = uniq2(Object.keys(a).concat(Object.keys(b)));
      if (options.ignore.length) {
        allKeys = allKeys.filter((k) => options.ignore.indexOf(k) === -1);
      }
      if (!allKeys.length) {
        return true;
      }
      function innerCompare(a2, b2) {
        return compare(a2, b2, options);
      }
      return allKeys.every(function(key2) {
        var aValue = a[key2];
        var bValue = b[key2];
        if (schemaProps.indexOf(key2) !== -1) {
          return compare(aValue, bValue, options);
        }
        var comparer = comparers[key2];
        if (!comparer) {
          comparer = isEqual8;
        }
        if (isEqual8(aValue, bValue)) {
          return true;
        }
        if (acceptsUndefined.indexOf(key2) === -1) {
          if (!has5(a, key2) && has5(b, key2) || has5(a, key2) && !has5(b, key2)) {
            return aValue === bValue;
          }
        }
        var result = comparer(aValue, bValue, key2, innerCompare);
        if (!isBoolean(result)) {
          throw new Error("Comparer must return true or false");
        }
        return result;
      });
    }
    module2.exports = compare;
  }
});

// ../../node_modules/validate.io-array/lib/index.js
var require_lib6 = __commonJS({
  "../../node_modules/validate.io-array/lib/index.js"(exports2, module2) {
    "use strict";
    function isArray(value) {
      return Object.prototype.toString.call(value) === "[object Array]";
    }
    module2.exports = Array.isArray || isArray;
  }
});

// ../../node_modules/validate.io-number/lib/index.js
var require_lib7 = __commonJS({
  "../../node_modules/validate.io-number/lib/index.js"(exports2, module2) {
    "use strict";
    function isNumber3(value) {
      return (typeof value === "number" || Object.prototype.toString.call(value) === "[object Number]") && value.valueOf() === value.valueOf();
    }
    module2.exports = isNumber3;
  }
});

// ../../node_modules/validate.io-integer/lib/index.js
var require_lib8 = __commonJS({
  "../../node_modules/validate.io-integer/lib/index.js"(exports2, module2) {
    "use strict";
    var isNumber3 = require_lib7();
    function isInteger(value) {
      return isNumber3(value) && value % 1 === 0;
    }
    module2.exports = isInteger;
  }
});

// ../../node_modules/validate.io-integer-array/lib/index.js
var require_lib9 = __commonJS({
  "../../node_modules/validate.io-integer-array/lib/index.js"(exports2, module2) {
    "use strict";
    var isArray = require_lib6();
    var isInteger = require_lib8();
    function isIntegerArray(value) {
      var len;
      if (!isArray(value)) {
        return false;
      }
      len = value.length;
      if (!len) {
        return false;
      }
      for (var i = 0; i < len; i++) {
        if (!isInteger(value[i])) {
          return false;
        }
      }
      return true;
    }
    module2.exports = isIntegerArray;
  }
});

// ../../node_modules/validate.io-function/lib/index.js
var require_lib10 = __commonJS({
  "../../node_modules/validate.io-function/lib/index.js"(exports2, module2) {
    "use strict";
    function isFunction2(value) {
      return typeof value === "function";
    }
    module2.exports = isFunction2;
  }
});

// ../../node_modules/compute-gcd/lib/index.js
var require_lib11 = __commonJS({
  "../../node_modules/compute-gcd/lib/index.js"(exports2, module2) {
    "use strict";
    var isArray = require_lib6();
    var isIntegerArray = require_lib9();
    var isFunction2 = require_lib10();
    var MAXINT = Math.pow(2, 31) - 1;
    function gcd(a, b) {
      var k = 1, t;
      if (a === 0) {
        return b;
      }
      if (b === 0) {
        return a;
      }
      while (a % 2 === 0 && b % 2 === 0) {
        a = a / 2;
        b = b / 2;
        k = k * 2;
      }
      while (a % 2 === 0) {
        a = a / 2;
      }
      while (b) {
        while (b % 2 === 0) {
          b = b / 2;
        }
        if (a > b) {
          t = b;
          b = a;
          a = t;
        }
        b = b - a;
      }
      return k * a;
    }
    function bitwise(a, b) {
      var k = 0, t;
      if (a === 0) {
        return b;
      }
      if (b === 0) {
        return a;
      }
      while ((a & 1) === 0 && (b & 1) === 0) {
        a >>>= 1;
        b >>>= 1;
        k++;
      }
      while ((a & 1) === 0) {
        a >>>= 1;
      }
      while (b) {
        while ((b & 1) === 0) {
          b >>>= 1;
        }
        if (a > b) {
          t = b;
          b = a;
          a = t;
        }
        b = b - a;
      }
      return a << k;
    }
    function compute() {
      var nargs = arguments.length, args, clbk, arr, len, a, b, i;
      args = new Array(nargs);
      for (i = 0; i < nargs; i++) {
        args[i] = arguments[i];
      }
      if (isIntegerArray(args)) {
        if (nargs === 2) {
          a = args[0];
          b = args[1];
          if (a < 0) {
            a = -a;
          }
          if (b < 0) {
            b = -b;
          }
          if (a <= MAXINT && b <= MAXINT) {
            return bitwise(a, b);
          } else {
            return gcd(a, b);
          }
        }
        arr = args;
      } else if (!isArray(args[0])) {
        throw new TypeError("gcd()::invalid input argument. Must provide an array of integers. Value: `" + args[0] + "`.");
      } else if (nargs > 1) {
        arr = args[0];
        clbk = args[1];
        if (!isFunction2(clbk)) {
          throw new TypeError("gcd()::invalid input argument. Accessor must be a function. Value: `" + clbk + "`.");
        }
      } else {
        arr = args[0];
      }
      len = arr.length;
      if (len < 2) {
        return null;
      }
      if (clbk) {
        a = new Array(len);
        for (i = 0; i < len; i++) {
          a[i] = clbk(arr[i], i);
        }
        arr = a;
      }
      if (nargs < 3) {
        if (!isIntegerArray(arr)) {
          throw new TypeError("gcd()::invalid input argument. Accessed array values must be integers. Value: `" + arr + "`.");
        }
      }
      for (i = 0; i < len; i++) {
        a = arr[i];
        if (a < 0) {
          arr[i] = -a;
        }
      }
      a = arr[0];
      for (i = 1; i < len; i++) {
        b = arr[i];
        if (b <= MAXINT && a <= MAXINT) {
          a = bitwise(a, b);
        } else {
          a = gcd(a, b);
        }
      }
      return a;
    }
    module2.exports = compute;
  }
});

// ../../node_modules/compute-lcm/lib/index.js
var require_lib12 = __commonJS({
  "../../node_modules/compute-lcm/lib/index.js"(exports2, module2) {
    "use strict";
    var gcd = require_lib11();
    var isArray = require_lib6();
    var isIntegerArray = require_lib9();
    var isFunction2 = require_lib10();
    function lcm() {
      var nargs = arguments.length, args, clbk, arr, len, a, b, i;
      args = new Array(nargs);
      for (i = 0; i < nargs; i++) {
        args[i] = arguments[i];
      }
      if (isIntegerArray(args)) {
        if (nargs === 2) {
          a = args[0];
          b = args[1];
          if (a < 0) {
            a = -a;
          }
          if (b < 0) {
            b = -b;
          }
          if (a === 0 || b === 0) {
            return 0;
          }
          return a / gcd(a, b) * b;
        }
        arr = args;
      } else if (!isArray(args[0])) {
        throw new TypeError("lcm()::invalid input argument. Must provide an array of integers. Value: `" + args[0] + "`.");
      } else if (nargs > 1) {
        arr = args[0];
        clbk = args[1];
        if (!isFunction2(clbk)) {
          throw new TypeError("lcm()::invalid input argument. Accessor must be a function. Value: `" + clbk + "`.");
        }
      } else {
        arr = args[0];
      }
      len = arr.length;
      if (len < 2) {
        return null;
      }
      if (clbk) {
        a = new Array(len);
        for (i = 0; i < len; i++) {
          a[i] = clbk(arr[i], i);
        }
        arr = a;
      }
      if (nargs < 3) {
        if (!isIntegerArray(arr)) {
          throw new TypeError("lcm()::invalid input argument. Accessed array values must be integers. Value: `" + arr + "`.");
        }
      }
      for (i = 0; i < len; i++) {
        a = arr[i];
        if (a < 0) {
          arr[i] = -a;
        }
      }
      a = arr[0];
      for (i = 1; i < len; i++) {
        b = arr[i];
        if (a === 0 || b === 0) {
          return 0;
        }
        a = a / gcd(a, b) * b;
      }
      return a;
    }
    module2.exports = lcm;
  }
});

// ../../node_modules/lodash/_customDefaultsMerge.js
var require_customDefaultsMerge = __commonJS({
  "../../node_modules/lodash/_customDefaultsMerge.js"(exports2, module2) {
    var baseMerge = require_baseMerge();
    var isObject9 = require_isObject();
    function customDefaultsMerge(objValue, srcValue, key2, object, source, stack) {
      if (isObject9(objValue) && isObject9(srcValue)) {
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);
        stack["delete"](srcValue);
      }
      return objValue;
    }
    module2.exports = customDefaultsMerge;
  }
});

// ../../node_modules/lodash/mergeWith.js
var require_mergeWith = __commonJS({
  "../../node_modules/lodash/mergeWith.js"(exports2, module2) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    module2.exports = mergeWith;
  }
});

// ../../node_modules/lodash/defaultsDeep.js
var require_defaultsDeep = __commonJS({
  "../../node_modules/lodash/defaultsDeep.js"(exports2, module2) {
    var apply = require_apply();
    var baseRest = require_baseRest();
    var customDefaultsMerge = require_customDefaultsMerge();
    var mergeWith = require_mergeWith();
    var defaultsDeep = baseRest(function(args) {
      args.push(void 0, customDefaultsMerge);
      return apply(mergeWith, void 0, args);
    });
    module2.exports = defaultsDeep;
  }
});

// ../../node_modules/lodash/intersection.js
var require_intersection = __commonJS({
  "../../node_modules/lodash/intersection.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIntersection = require_baseIntersection();
    var baseRest = require_baseRest();
    var castArrayLikeObject = require_castArrayLikeObject();
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
    });
    module2.exports = intersection;
  }
});

// ../../node_modules/lodash/_baseIndexOfWith.js
var require_baseIndexOfWith = __commonJS({
  "../../node_modules/lodash/_baseIndexOfWith.js"(exports2, module2) {
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseIndexOfWith;
  }
});

// ../../node_modules/lodash/_basePullAll.js
var require_basePullAll = __commonJS({
  "../../node_modules/lodash/_basePullAll.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIndexOf = require_baseIndexOf();
    var baseIndexOfWith = require_baseIndexOfWith();
    var baseUnary = require_baseUnary();
    var copyArray = require_copyArray();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }
    module2.exports = basePullAll;
  }
});

// ../../node_modules/lodash/pullAll.js
var require_pullAll = __commonJS({
  "../../node_modules/lodash/pullAll.js"(exports2, module2) {
    var basePullAll = require_basePullAll();
    function pullAll(array, values) {
      return array && array.length && values && values.length ? basePullAll(array, values) : array;
    }
    module2.exports = pullAll;
  }
});

// ../../node_modules/lodash/forEach.js
var require_forEach = __commonJS({
  "../../node_modules/lodash/forEach.js"(exports2, module2) {
    var arrayEach = require_arrayEach();
    var baseEach = require_baseEach();
    var castFunction = require_castFunction();
    var isArray = require_isArray();
    function forEach2(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    module2.exports = forEach2;
  }
});

// ../../node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "../../node_modules/lodash/_baseDifference.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseDifference;
  }
});

// ../../node_modules/lodash/without.js
var require_without = __commonJS({
  "../../node_modules/lodash/without.js"(exports2, module2) {
    var baseDifference = require_baseDifference();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, values) : [];
    });
    module2.exports = without;
  }
});

// ../../node_modules/json-schema-merge-allof/src/common.js
var require_common = __commonJS({
  "../../node_modules/json-schema-merge-allof/src/common.js"(exports2, module2) {
    var flatten = require_flatten();
    var flattenDeep2 = require_flattenDeep();
    var isPlainObject4 = require_isPlainObject();
    var uniq2 = require_uniq();
    var uniqWith = require_uniqWith();
    var without = require_without();
    function deleteUndefinedProps(returnObject) {
      for (const prop in returnObject) {
        if (has5(returnObject, prop) && isEmptySchema(returnObject[prop])) {
          delete returnObject[prop];
        }
      }
      return returnObject;
    }
    var allUniqueKeys = (arr) => uniq2(flattenDeep2(arr.map(keys)));
    var getValues = (schemas, key2) => schemas.map((schema) => schema && schema[key2]);
    var has5 = (obj, propName) => Object.prototype.hasOwnProperty.call(obj, propName);
    var keys = (obj) => {
      if (isPlainObject4(obj) || Array.isArray(obj)) {
        return Object.keys(obj);
      } else {
        return [];
      }
    };
    var notUndefined = (val) => val !== void 0;
    var isSchema = (val) => isPlainObject4(val) || val === true || val === false;
    var isEmptySchema = (obj) => !keys(obj).length && obj !== false && obj !== true;
    var withoutArr = (arr, ...rest) => without.apply(null, [arr].concat(flatten(rest)));
    module2.exports = {
      allUniqueKeys,
      deleteUndefinedProps,
      getValues,
      has: has5,
      isEmptySchema,
      isSchema,
      keys,
      notUndefined,
      uniqWith,
      withoutArr
    };
  }
});

// ../../node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js
var require_properties = __commonJS({
  "../../node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js"(exports2, module2) {
    var compare = require_src();
    var forEach2 = require_forEach();
    var {
      allUniqueKeys,
      deleteUndefinedProps,
      getValues,
      keys,
      notUndefined,
      uniqWith,
      withoutArr
    } = require_common();
    function removeFalseSchemas(target2) {
      forEach2(target2, function(schema, prop) {
        if (schema === false) {
          delete target2[prop];
        }
      });
    }
    function mergeSchemaGroup(group, mergeSchemas2) {
      const allKeys = allUniqueKeys(group);
      return allKeys.reduce(function(all2, key2) {
        const schemas = getValues(group, key2);
        const compacted = uniqWith(schemas.filter(notUndefined), compare);
        all2[key2] = mergeSchemas2(compacted, key2);
        return all2;
      }, {});
    }
    module2.exports = {
      keywords: ["properties", "patternProperties", "additionalProperties"],
      resolver(values, parents, mergers, options) {
        if (!options.ignoreAdditionalProperties) {
          values.forEach(function(subSchema) {
            const otherSubSchemas = values.filter((s) => s !== subSchema);
            const ownKeys = keys(subSchema.properties);
            const ownPatternKeys = keys(subSchema.patternProperties);
            const ownPatterns = ownPatternKeys.map((k) => new RegExp(k));
            otherSubSchemas.forEach(function(other) {
              const allOtherKeys = keys(other.properties);
              const keysMatchingPattern = allOtherKeys.filter((k) => ownPatterns.some((pk) => pk.test(k)));
              const additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern);
              additionalKeys.forEach(function(key2) {
                other.properties[key2] = mergers.properties([
                  other.properties[key2],
                  subSchema.additionalProperties
                ], key2);
              });
            });
          });
          values.forEach(function(subSchema) {
            const otherSubSchemas = values.filter((s) => s !== subSchema);
            const ownPatternKeys = keys(subSchema.patternProperties);
            if (subSchema.additionalProperties === false) {
              otherSubSchemas.forEach(function(other) {
                const allOtherPatterns = keys(other.patternProperties);
                const additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys);
                additionalPatternKeys.forEach((key2) => delete other.patternProperties[key2]);
              });
            }
          });
        }
        const returnObject = {
          additionalProperties: mergers.additionalProperties(values.map((s) => s.additionalProperties)),
          patternProperties: mergeSchemaGroup(values.map((s) => s.patternProperties), mergers.patternProperties),
          properties: mergeSchemaGroup(values.map((s) => s.properties), mergers.properties)
        };
        if (returnObject.additionalProperties === false) {
          removeFalseSchemas(returnObject.properties);
        }
        return deleteUndefinedProps(returnObject);
      }
    };
  }
});

// ../../node_modules/json-schema-merge-allof/src/complex-resolvers/items.js
var require_items = __commonJS({
  "../../node_modules/json-schema-merge-allof/src/complex-resolvers/items.js"(exports2, module2) {
    var compare = require_src();
    var forEach2 = require_forEach();
    var {
      allUniqueKeys,
      deleteUndefinedProps,
      has: has5,
      isSchema,
      notUndefined,
      uniqWith
    } = require_common();
    function removeFalseSchemasFromArray(target2) {
      forEach2(target2, function(schema, index) {
        if (schema === false) {
          target2.splice(index, 1);
        }
      });
    }
    function getItemSchemas(subSchemas, key2) {
      return subSchemas.map(function(sub) {
        if (!sub) {
          return void 0;
        }
        if (Array.isArray(sub.items)) {
          const schemaAtPos = sub.items[key2];
          if (isSchema(schemaAtPos)) {
            return schemaAtPos;
          } else if (has5(sub, "additionalItems")) {
            return sub.additionalItems;
          }
        } else {
          return sub.items;
        }
        return void 0;
      });
    }
    function getAdditionalSchemas(subSchemas) {
      return subSchemas.map(function(sub) {
        if (!sub) {
          return void 0;
        }
        if (Array.isArray(sub.items)) {
          return sub.additionalItems;
        }
        return sub.items;
      });
    }
    function mergeItems(group, mergeSchemas2, items) {
      const allKeys = allUniqueKeys(items);
      return allKeys.reduce(function(all2, key2) {
        const schemas = getItemSchemas(group, key2);
        const compacted = uniqWith(schemas.filter(notUndefined), compare);
        all2[key2] = mergeSchemas2(compacted, key2);
        return all2;
      }, []);
    }
    module2.exports = {
      keywords: ["items", "additionalItems"],
      resolver(values, parents, mergers) {
        const items = values.map((s) => s.items);
        const itemsCompacted = items.filter(notUndefined);
        const returnObject = {};
        if (itemsCompacted.every(isSchema)) {
          returnObject.items = mergers.items(items);
        } else {
          returnObject.items = mergeItems(values, mergers.items, items);
        }
        let schemasAtLastPos;
        if (itemsCompacted.every(Array.isArray)) {
          schemasAtLastPos = values.map((s) => s.additionalItems);
        } else if (itemsCompacted.some(Array.isArray)) {
          schemasAtLastPos = getAdditionalSchemas(values);
        }
        if (schemasAtLastPos) {
          returnObject.additionalItems = mergers.additionalItems(schemasAtLastPos);
        }
        if (returnObject.additionalItems === false && Array.isArray(returnObject.items)) {
          removeFalseSchemasFromArray(returnObject.items);
        }
        return deleteUndefinedProps(returnObject);
      }
    };
  }
});

// ../../node_modules/json-schema-merge-allof/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/json-schema-merge-allof/src/index.js"(exports2, module2) {
    var cloneDeep3 = require_cloneDeep();
    var compare = require_src();
    var computeLcm = require_lib12();
    var defaultsDeep = require_defaultsDeep();
    var flatten = require_flatten();
    var flattenDeep2 = require_flattenDeep();
    var intersection = require_intersection();
    var intersectionWith = require_intersectionWith();
    var isEqual8 = require_isEqual();
    var isPlainObject4 = require_isPlainObject();
    var pullAll = require_pullAll();
    var sortBy = require_sortBy();
    var uniq2 = require_uniq();
    var uniqWith = require_uniqWith();
    var propertiesResolver = require_properties();
    var itemsResolver = require_items();
    var contains = (arr, val) => arr.indexOf(val) !== -1;
    var isSchema = (val) => isPlainObject4(val) || val === true || val === false;
    var isFalse = (val) => val === false;
    var isTrue = (val) => val === true;
    var schemaResolver = (compacted, key2, mergeSchemas2) => mergeSchemas2(compacted);
    var stringArray = (values) => sortBy(uniq2(flattenDeep2(values)));
    var notUndefined = (val) => val !== void 0;
    var allUniqueKeys = (arr) => uniq2(flattenDeep2(arr.map(keys)));
    var first = (compacted) => compacted[0];
    var required = (compacted) => stringArray(compacted);
    var maximumValue = (compacted) => Math.max.apply(Math, compacted);
    var minimumValue = (compacted) => Math.min.apply(Math, compacted);
    var uniqueItems = (compacted) => compacted.some(isTrue);
    var examples = (compacted) => uniqWith(flatten(compacted), isEqual8);
    function compareProp(key2) {
      return function(a, b) {
        return compare({
          [key2]: a
        }, { [key2]: b });
      };
    }
    function getAllOf(schema) {
      let { allOf = [], ...copy } = schema;
      copy = isPlainObject4(schema) ? copy : schema;
      return [copy, ...allOf.map(getAllOf)];
    }
    function getValues(schemas, key2) {
      return schemas.map((schema) => schema && schema[key2]);
    }
    function tryMergeSchemaGroups(schemaGroups, mergeSchemas2) {
      return schemaGroups.map(function(schemas, index) {
        try {
          return mergeSchemas2(schemas, index);
        } catch (e) {
          return void 0;
        }
      }).filter(notUndefined);
    }
    function keys(obj) {
      if (isPlainObject4(obj) || Array.isArray(obj)) {
        return Object.keys(obj);
      } else {
        return [];
      }
    }
    function getAnyOfCombinations(arrOfArrays, combinations) {
      combinations = combinations || [];
      if (!arrOfArrays.length) {
        return combinations;
      }
      const values = arrOfArrays.slice(0).shift();
      const rest = arrOfArrays.slice(1);
      if (combinations.length) {
        return getAnyOfCombinations(rest, flatten(combinations.map((combination) => values.map((item) => [item].concat(combination)))));
      }
      return getAnyOfCombinations(rest, values.map((item) => item));
    }
    function throwIncompatible(values, paths) {
      let asJSON;
      try {
        asJSON = values.map(function(val) {
          return JSON.stringify(val, null, 2);
        }).join("\n");
      } catch (variable) {
        asJSON = values.join(", ");
      }
      throw new Error('Could not resolve values for path:"' + paths.join(".") + '". They are probably incompatible. Values: \n' + asJSON);
    }
    function callGroupResolver(complexKeywords, resolverName, schemas, mergeSchemas2, options, parents) {
      if (complexKeywords.length) {
        const resolverConfig = options.complexResolvers[resolverName];
        if (!resolverConfig || !resolverConfig.resolver) {
          throw new Error("No resolver found for " + resolverName);
        }
        const extractedKeywordsOnly = schemas.map((schema) => complexKeywords.reduce((all2, key2) => {
          if (schema[key2] !== void 0)
            all2[key2] = schema[key2];
          return all2;
        }, {}));
        const unique = uniqWith(extractedKeywordsOnly, compare);
        const mergers = resolverConfig.keywords.reduce((all2, key2) => ({
          ...all2,
          [key2]: (schemas2, extraKey = []) => mergeSchemas2(schemas2, null, parents.concat(key2, extraKey))
        }), {});
        const result = resolverConfig.resolver(unique, parents.concat(resolverName), mergers, options);
        if (!isPlainObject4(result)) {
          throwIncompatible(unique, parents.concat(resolverName));
        }
        return result;
      }
    }
    function createRequiredMetaArray(arr) {
      return { required: arr };
    }
    var schemaGroupProps = ["properties", "patternProperties", "definitions", "dependencies"];
    var schemaArrays = ["anyOf", "oneOf"];
    var schemaProps = [
      "additionalProperties",
      "additionalItems",
      "contains",
      "propertyNames",
      "not",
      "items"
    ];
    var defaultResolvers = {
      type(compacted) {
        if (compacted.some(Array.isArray)) {
          const normalized = compacted.map(function(val) {
            return Array.isArray(val) ? val : [val];
          });
          const common = intersection.apply(null, normalized);
          if (common.length === 1) {
            return common[0];
          } else if (common.length > 1) {
            return uniq2(common);
          }
        }
      },
      dependencies(compacted, paths, mergeSchemas2) {
        const allChildren = allUniqueKeys(compacted);
        return allChildren.reduce(function(all2, childKey) {
          const childSchemas = getValues(compacted, childKey);
          let innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual8);
          const innerArrays = innerCompacted.filter(Array.isArray);
          if (innerArrays.length) {
            if (innerArrays.length === innerCompacted.length) {
              all2[childKey] = stringArray(innerCompacted);
            } else {
              const innerSchemas = innerCompacted.filter(isSchema);
              const arrayMetaScheams = innerArrays.map(createRequiredMetaArray);
              all2[childKey] = mergeSchemas2(innerSchemas.concat(arrayMetaScheams), childKey);
            }
            return all2;
          }
          innerCompacted = uniqWith(innerCompacted, compare);
          all2[childKey] = mergeSchemas2(innerCompacted, childKey);
          return all2;
        }, {});
      },
      oneOf(compacted, paths, mergeSchemas2) {
        const combinations = getAnyOfCombinations(cloneDeep3(compacted));
        const result = tryMergeSchemaGroups(combinations, mergeSchemas2);
        const unique = uniqWith(result, compare);
        if (unique.length) {
          return unique;
        }
      },
      not(compacted) {
        return { anyOf: compacted };
      },
      pattern(compacted) {
        return compacted.map((r) => "(?=" + r + ")").join("");
      },
      multipleOf(compacted) {
        let integers = compacted.slice(0);
        let factor = 1;
        while (integers.some((n) => !Number.isInteger(n))) {
          integers = integers.map((n) => n * 10);
          factor = factor * 10;
        }
        return computeLcm(integers) / factor;
      },
      enum(compacted) {
        const enums = intersectionWith.apply(null, compacted.concat(isEqual8));
        if (enums.length) {
          return sortBy(enums);
        }
      }
    };
    defaultResolvers.$id = first;
    defaultResolvers.$ref = first;
    defaultResolvers.$schema = first;
    defaultResolvers.additionalItems = schemaResolver;
    defaultResolvers.additionalProperties = schemaResolver;
    defaultResolvers.anyOf = defaultResolvers.oneOf;
    defaultResolvers.contains = schemaResolver;
    defaultResolvers.default = first;
    defaultResolvers.definitions = defaultResolvers.dependencies;
    defaultResolvers.description = first;
    defaultResolvers.examples = examples;
    defaultResolvers.exclusiveMaximum = minimumValue;
    defaultResolvers.exclusiveMinimum = maximumValue;
    defaultResolvers.items = itemsResolver;
    defaultResolvers.maximum = minimumValue;
    defaultResolvers.maxItems = minimumValue;
    defaultResolvers.maxLength = minimumValue;
    defaultResolvers.maxProperties = minimumValue;
    defaultResolvers.minimum = maximumValue;
    defaultResolvers.minItems = maximumValue;
    defaultResolvers.minLength = maximumValue;
    defaultResolvers.minProperties = maximumValue;
    defaultResolvers.properties = propertiesResolver;
    defaultResolvers.propertyNames = schemaResolver;
    defaultResolvers.required = required;
    defaultResolvers.title = first;
    defaultResolvers.uniqueItems = uniqueItems;
    var defaultComplexResolvers = {
      properties: propertiesResolver,
      items: itemsResolver
    };
    function merger(rootSchema, options, totalSchemas) {
      totalSchemas = totalSchemas || [];
      options = defaultsDeep(options, {
        ignoreAdditionalProperties: false,
        resolvers: defaultResolvers,
        complexResolvers: defaultComplexResolvers,
        deep: true
      });
      const complexResolvers = Object.entries(options.complexResolvers);
      function mergeSchemas2(schemas, base, parents) {
        schemas = cloneDeep3(schemas.filter(notUndefined));
        parents = parents || [];
        const merged2 = isPlainObject4(base) ? base : {};
        if (!schemas.length) {
          return;
        }
        if (schemas.some(isFalse)) {
          return false;
        }
        if (schemas.every(isTrue)) {
          return true;
        }
        schemas = schemas.filter(isPlainObject4);
        const allKeys = allUniqueKeys(schemas);
        if (options.deep && contains(allKeys, "allOf")) {
          return merger({
            allOf: schemas
          }, options, totalSchemas);
        }
        const complexKeysArr = complexResolvers.map(([mainKeyWord, resolverConf]) => allKeys.filter((k) => resolverConf.keywords.includes(k)));
        complexKeysArr.forEach((keys2) => pullAll(allKeys, keys2));
        allKeys.forEach(function(key2) {
          const values = getValues(schemas, key2);
          const compacted = uniqWith(values.filter(notUndefined), compareProp(key2));
          if (compacted.length === 1 && contains(schemaArrays, key2)) {
            merged2[key2] = compacted[0].map((schema) => mergeSchemas2([schema], schema));
          } else if (compacted.length === 1 && !contains(schemaGroupProps, key2) && !contains(schemaProps, key2)) {
            merged2[key2] = compacted[0];
          } else {
            const resolver = options.resolvers[key2] || options.resolvers.defaultResolver;
            if (!resolver)
              throw new Error("No resolver found for key " + key2 + ". You can provide a resolver for this keyword in the options, or provide a default resolver.");
            const merger2 = (schemas2, extraKey = []) => mergeSchemas2(schemas2, null, parents.concat(key2, extraKey));
            merged2[key2] = resolver(compacted, parents.concat(key2), merger2, options);
            if (merged2[key2] === void 0) {
              throwIncompatible(compacted, parents.concat(key2));
            } else if (merged2[key2] === void 0) {
              delete merged2[key2];
            }
          }
        });
        return complexResolvers.reduce((all2, [resolverKeyword, config], index) => ({
          ...all2,
          ...callGroupResolver(complexKeysArr[index], resolverKeyword, schemas, mergeSchemas2, options, parents)
        }), merged2);
      }
      const allSchemas = flattenDeep2(getAllOf(rootSchema));
      const merged = mergeSchemas2(allSchemas);
      return merged;
    }
    merger.options = {
      resolvers: defaultResolvers
    };
    module2.exports = merger;
  }
});

// ../../node_modules/@rjsf/utils/lib/getDiscriminatorFieldFromSchema.js
var import_get3, import_isString;
var init_getDiscriminatorFieldFromSchema = __esm({
  "../../node_modules/@rjsf/utils/lib/getDiscriminatorFieldFromSchema.js"() {
    import_get3 = __toESM(require_get());
    import_isString = __toESM(require_isString());
  }
});

// ../../node_modules/@rjsf/utils/lib/guessType.js
var init_guessType = __esm({
  "../../node_modules/@rjsf/utils/lib/guessType.js"() {
  }
});

// ../../node_modules/lodash/union.js
var require_union = __commonJS({
  "../../node_modules/lodash/union.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var baseUniq = require_baseUniq();
    var isArrayLikeObject = require_isArrayLikeObject();
    var union2 = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });
    module2.exports = union2;
  }
});

// ../../node_modules/@rjsf/utils/lib/getSchemaType.js
var init_getSchemaType = __esm({
  "../../node_modules/@rjsf/utils/lib/getSchemaType.js"() {
    init_guessType();
  }
});

// ../../node_modules/@rjsf/utils/lib/mergeSchemas.js
var import_union;
var init_mergeSchemas = __esm({
  "../../node_modules/@rjsf/utils/lib/mergeSchemas.js"() {
    import_union = __toESM(require_union());
    init_constants();
    init_getSchemaType();
    init_isObject();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/retrieveSchema.js
var import_get4, import_isEqual, import_set, import_times, import_transform, import_merge, import_flattenDeep, import_uniq, import_json_schema_merge_allof;
var init_retrieveSchema = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/retrieveSchema.js"() {
    import_get4 = __toESM(require_get());
    import_isEqual = __toESM(require_isEqual());
    import_set = __toESM(require_set());
    import_times = __toESM(require_times());
    import_transform = __toESM(require_transform());
    import_merge = __toESM(require_merge());
    import_flattenDeep = __toESM(require_flattenDeep());
    import_uniq = __toESM(require_uniq());
    import_json_schema_merge_allof = __toESM(require_src2());
    init_constants();
    init_findSchemaDefinition();
    init_getDiscriminatorFieldFromSchema();
    init_guessType();
    init_isObject();
    init_mergeSchemas();
    init_getFirstMatchingOption();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/getClosestMatchingOption.js
var import_get5, import_has2, import_isNumber2, import_isObject5, import_isString2, import_reduce, import_times2;
var init_getClosestMatchingOption = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/getClosestMatchingOption.js"() {
    import_get5 = __toESM(require_get());
    import_has2 = __toESM(require_has());
    import_isNumber2 = __toESM(require_isNumber());
    import_isObject5 = __toESM(require_isObject());
    import_isString2 = __toESM(require_isString());
    import_reduce = __toESM(require_reduce());
    import_times2 = __toESM(require_times());
    init_getFirstMatchingOption();
    init_retrieveSchema();
    init_constants();
    init_guessType();
    init_getDiscriminatorFieldFromSchema();
    init_getOptionMatchingSimpleDiscriminator();
  }
});

// ../../node_modules/@rjsf/utils/lib/isFixedItems.js
var init_isFixedItems = __esm({
  "../../node_modules/@rjsf/utils/lib/isFixedItems.js"() {
    init_isObject();
  }
});

// ../../node_modules/@rjsf/utils/lib/mergeDefaultsWithFormData.js
var import_get6;
var init_mergeDefaultsWithFormData = __esm({
  "../../node_modules/@rjsf/utils/lib/mergeDefaultsWithFormData.js"() {
    import_get6 = __toESM(require_get());
    init_isObject();
  }
});

// ../../node_modules/@rjsf/utils/lib/mergeObjects.js
var init_mergeObjects = __esm({
  "../../node_modules/@rjsf/utils/lib/mergeObjects.js"() {
    init_isObject();
  }
});

// ../../node_modules/@rjsf/utils/lib/isConstant.js
var init_isConstant = __esm({
  "../../node_modules/@rjsf/utils/lib/isConstant.js"() {
    init_constants();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/isSelect.js
var init_isSelect = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/isSelect.js"() {
    init_isConstant();
    init_retrieveSchema();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/isMultiSelect.js
var init_isMultiSelect = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/isMultiSelect.js"() {
    init_isSelect();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js
var import_get7, import_isEmpty, AdditionalItemsHandling;
var init_getDefaultFormState = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js"() {
    import_get7 = __toESM(require_get());
    import_isEmpty = __toESM(require_isEmpty());
    init_constants();
    init_findSchemaDefinition();
    init_getClosestMatchingOption();
    init_getDiscriminatorFieldFromSchema();
    init_getSchemaType();
    init_isObject();
    init_isFixedItems();
    init_mergeDefaultsWithFormData();
    init_mergeObjects();
    init_mergeSchemas();
    init_isMultiSelect();
    init_retrieveSchema();
    (function(AdditionalItemsHandling2) {
      AdditionalItemsHandling2[AdditionalItemsHandling2["Ignore"] = 0] = "Ignore";
      AdditionalItemsHandling2[AdditionalItemsHandling2["Invert"] = 1] = "Invert";
      AdditionalItemsHandling2[AdditionalItemsHandling2["Fallback"] = 2] = "Fallback";
    })(AdditionalItemsHandling || (AdditionalItemsHandling = {}));
  }
});

// ../../node_modules/@rjsf/utils/lib/isCustomWidget.js
var init_isCustomWidget = __esm({
  "../../node_modules/@rjsf/utils/lib/isCustomWidget.js"() {
    init_getUiOptions();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/isFilesArray.js
var init_isFilesArray = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/isFilesArray.js"() {
    init_constants();
    init_retrieveSchema();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/getDisplayLabel.js
var init_getDisplayLabel = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/getDisplayLabel.js"() {
    init_constants();
    init_getSchemaType();
    init_getUiOptions();
    init_isCustomWidget();
    init_isFilesArray();
    init_isMultiSelect();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/mergeValidationData.js
var import_isEmpty2;
var init_mergeValidationData = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/mergeValidationData.js"() {
    import_isEmpty2 = __toESM(require_isEmpty());
    init_mergeObjects();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/sanitizeDataForNewSchema.js
var import_get8, import_has3, NO_VALUE;
var init_sanitizeDataForNewSchema = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/sanitizeDataForNewSchema.js"() {
    import_get8 = __toESM(require_get());
    import_has3 = __toESM(require_has());
    init_constants();
    init_retrieveSchema();
    NO_VALUE = Symbol("no Value");
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/toIdSchema.js
var import_get9, import_isEqual2;
var init_toIdSchema = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/toIdSchema.js"() {
    import_get9 = __toESM(require_get());
    import_isEqual2 = __toESM(require_isEqual());
    init_constants();
    init_isObject();
    init_retrieveSchema();
    init_getSchemaType();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/toPathSchema.js
var import_get10, import_isEqual3, import_set2;
var init_toPathSchema = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/toPathSchema.js"() {
    import_get10 = __toESM(require_get());
    import_isEqual3 = __toESM(require_isEqual());
    import_set2 = __toESM(require_set());
    init_constants();
    init_getDiscriminatorFieldFromSchema();
    init_getClosestMatchingOption();
    init_retrieveSchema();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/index.js
var init_schema = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/index.js"() {
    init_getDefaultFormState();
    init_getDisplayLabel();
    init_getClosestMatchingOption();
    init_getFirstMatchingOption();
    init_getMatchingOption();
    init_isFilesArray();
    init_isMultiSelect();
    init_isSelect();
    init_mergeValidationData();
    init_retrieveSchema();
    init_sanitizeDataForNewSchema();
    init_toIdSchema();
    init_toPathSchema();
  }
});

// ../../node_modules/@rjsf/utils/lib/createSchemaUtils.js
var init_createSchemaUtils = __esm({
  "../../node_modules/@rjsf/utils/lib/createSchemaUtils.js"() {
    init_deepEquals();
    init_schema();
  }
});

// ../../node_modules/@rjsf/utils/lib/dataURItoBlob.js
var init_dataURItoBlob = __esm({
  "../../node_modules/@rjsf/utils/lib/dataURItoBlob.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/replaceStringParameters.js
var init_replaceStringParameters = __esm({
  "../../node_modules/@rjsf/utils/lib/replaceStringParameters.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/englishStringTranslator.js
var init_englishStringTranslator = __esm({
  "../../node_modules/@rjsf/utils/lib/englishStringTranslator.js"() {
    init_replaceStringParameters();
  }
});

// ../../node_modules/@rjsf/utils/lib/enumOptionsValueForIndex.js
var init_enumOptionsValueForIndex = __esm({
  "../../node_modules/@rjsf/utils/lib/enumOptionsValueForIndex.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/enumOptionsDeselectValue.js
var import_isEqual4;
var init_enumOptionsDeselectValue = __esm({
  "../../node_modules/@rjsf/utils/lib/enumOptionsDeselectValue.js"() {
    import_isEqual4 = __toESM(require_isEqual());
    init_enumOptionsValueForIndex();
  }
});

// ../../node_modules/@rjsf/utils/lib/enumOptionsIsSelected.js
var import_isEqual5;
var init_enumOptionsIsSelected = __esm({
  "../../node_modules/@rjsf/utils/lib/enumOptionsIsSelected.js"() {
    import_isEqual5 = __toESM(require_isEqual());
  }
});

// ../../node_modules/@rjsf/utils/lib/enumOptionsIndexForValue.js
var init_enumOptionsIndexForValue = __esm({
  "../../node_modules/@rjsf/utils/lib/enumOptionsIndexForValue.js"() {
    init_enumOptionsIsSelected();
  }
});

// ../../node_modules/lodash/isNil.js
var require_isNil = __commonJS({
  "../../node_modules/lodash/isNil.js"(exports2, module2) {
    function isNil2(value) {
      return value == null;
    }
    module2.exports = isNil2;
  }
});

// ../../node_modules/@rjsf/utils/lib/enumOptionsSelectValue.js
var import_isNil;
var init_enumOptionsSelectValue = __esm({
  "../../node_modules/@rjsf/utils/lib/enumOptionsSelectValue.js"() {
    init_enumOptionsValueForIndex();
    import_isNil = __toESM(require_isNil());
  }
});

// ../../node_modules/@rjsf/utils/lib/ErrorSchemaBuilder.js
var import_cloneDeep, import_get11, import_set3;
var init_ErrorSchemaBuilder = __esm({
  "../../node_modules/@rjsf/utils/lib/ErrorSchemaBuilder.js"() {
    import_cloneDeep = __toESM(require_cloneDeep());
    import_get11 = __toESM(require_get());
    import_set3 = __toESM(require_set());
    init_constants();
  }
});

// ../../node_modules/@rjsf/utils/lib/getDateElementProps.js
var init_getDateElementProps = __esm({
  "../../node_modules/@rjsf/utils/lib/getDateElementProps.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/rangeSpec.js
var init_rangeSpec = __esm({
  "../../node_modules/@rjsf/utils/lib/rangeSpec.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/getInputProps.js
var init_getInputProps = __esm({
  "../../node_modules/@rjsf/utils/lib/getInputProps.js"() {
    init_rangeSpec();
  }
});

// ../../node_modules/@rjsf/utils/lib/getSubmitButtonOptions.js
var init_getSubmitButtonOptions = __esm({
  "../../node_modules/@rjsf/utils/lib/getSubmitButtonOptions.js"() {
    init_constants();
    init_getUiOptions();
  }
});

// ../../node_modules/@rjsf/utils/lib/getTemplate.js
var init_getTemplate = __esm({
  "../../node_modules/@rjsf/utils/lib/getTemplate.js"() {
  }
});

// ../../node_modules/@rjsf/utils/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "../../node_modules/@rjsf/utils/node_modules/react-is/cjs/react-is.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment2 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports2.ContextConsumer = ContextConsumer;
        exports2.ContextProvider = ContextProvider;
        exports2.Element = Element2;
        exports2.ForwardRef = ForwardRef;
        exports2.Fragment = Fragment2;
        exports2.Lazy = Lazy;
        exports2.Memo = Memo;
        exports2.Portal = Portal;
        exports2.Profiler = Profiler;
        exports2.StrictMode = StrictMode;
        exports2.Suspense = Suspense;
        exports2.SuspenseList = SuspenseList;
        exports2.isAsyncMode = isAsyncMode;
        exports2.isConcurrentMode = isConcurrentMode;
        exports2.isContextConsumer = isContextConsumer;
        exports2.isContextProvider = isContextProvider;
        exports2.isElement = isElement;
        exports2.isForwardRef = isForwardRef;
        exports2.isFragment = isFragment;
        exports2.isLazy = isLazy;
        exports2.isMemo = isMemo;
        exports2.isPortal = isPortal;
        exports2.isProfiler = isProfiler;
        exports2.isStrictMode = isStrictMode;
        exports2.isSuspense = isSuspense;
        exports2.isSuspenseList = isSuspenseList;
        exports2.isValidElementType = isValidElementType;
        exports2.typeOf = typeOf;
      })();
    }
  }
});

// ../../node_modules/@rjsf/utils/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "../../node_modules/@rjsf/utils/node_modules/react-is/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// ../../node_modules/@rjsf/utils/lib/getWidget.js
var import_jsx_runtime, import_react5, import_react_is, import_get12, import_set4;
var init_getWidget = __esm({
  "../../node_modules/@rjsf/utils/lib/getWidget.js"() {
    import_jsx_runtime = __toESM(require_jsx_runtime());
    import_react5 = __toESM(require_react());
    import_react_is = __toESM(require_react_is());
    import_get12 = __toESM(require_get());
    import_set4 = __toESM(require_set());
    init_getSchemaType();
  }
});

// ../../node_modules/@rjsf/utils/lib/hashForSchema.js
var init_hashForSchema = __esm({
  "../../node_modules/@rjsf/utils/lib/hashForSchema.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/hasWidget.js
var init_hasWidget = __esm({
  "../../node_modules/@rjsf/utils/lib/hasWidget.js"() {
    init_getWidget();
  }
});

// ../../node_modules/@rjsf/utils/lib/idGenerators.js
function idGenerator(id, suffix) {
  const theId = (0, import_isString3.default)(id) ? id : id[ID_KEY];
  return `${theId}__${suffix}`;
}
function descriptionId(id) {
  return idGenerator(id, "description");
}
function errorId(id) {
  return idGenerator(id, "error");
}
function examplesId(id) {
  return idGenerator(id, "examples");
}
function helpId(id) {
  return idGenerator(id, "help");
}
function ariaDescribedByIds(id, includeExamples = false) {
  const examples = includeExamples ? ` ${examplesId(id)}` : "";
  return `${errorId(id)} ${descriptionId(id)} ${helpId(id)}${examples}`;
}
var import_isString3;
var init_idGenerators = __esm({
  "../../node_modules/@rjsf/utils/lib/idGenerators.js"() {
    import_isString3 = __toESM(require_isString());
    init_constants();
  }
});

// ../../node_modules/@rjsf/utils/lib/labelValue.js
var init_labelValue = __esm({
  "../../node_modules/@rjsf/utils/lib/labelValue.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/localToUTC.js
var init_localToUTC = __esm({
  "../../node_modules/@rjsf/utils/lib/localToUTC.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/toConstant.js
var init_toConstant = __esm({
  "../../node_modules/@rjsf/utils/lib/toConstant.js"() {
    init_constants();
  }
});

// ../../node_modules/@rjsf/utils/lib/optionsList.js
var init_optionsList = __esm({
  "../../node_modules/@rjsf/utils/lib/optionsList.js"() {
    init_toConstant();
  }
});

// ../../node_modules/@rjsf/utils/lib/orderProperties.js
var init_orderProperties = __esm({
  "../../node_modules/@rjsf/utils/lib/orderProperties.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/pad.js
var init_pad = __esm({
  "../../node_modules/@rjsf/utils/lib/pad.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/parseDateString.js
var init_parseDateString = __esm({
  "../../node_modules/@rjsf/utils/lib/parseDateString.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/schemaRequiresTrueValue.js
var init_schemaRequiresTrueValue = __esm({
  "../../node_modules/@rjsf/utils/lib/schemaRequiresTrueValue.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/shouldRender.js
var init_shouldRender = __esm({
  "../../node_modules/@rjsf/utils/lib/shouldRender.js"() {
    init_deepEquals();
  }
});

// ../../node_modules/@rjsf/utils/lib/toDateString.js
var init_toDateString = __esm({
  "../../node_modules/@rjsf/utils/lib/toDateString.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/toErrorList.js
var import_isPlainObject2;
var init_toErrorList = __esm({
  "../../node_modules/@rjsf/utils/lib/toErrorList.js"() {
    import_isPlainObject2 = __toESM(require_isPlainObject());
    init_constants();
  }
});

// ../../node_modules/lodash/toPath.js
var require_toPath = __commonJS({
  "../../node_modules/lodash/toPath.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var copyArray = require_copyArray();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var stringToPath = require_stringToPath();
    var toKey = require_toKey();
    var toString = require_toString();
    function toPath2(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }
    module2.exports = toPath2;
  }
});

// ../../node_modules/@rjsf/utils/lib/toErrorSchema.js
var import_toPath;
var init_toErrorSchema = __esm({
  "../../node_modules/@rjsf/utils/lib/toErrorSchema.js"() {
    import_toPath = __toESM(require_toPath());
    init_ErrorSchemaBuilder();
  }
});

// ../../node_modules/@rjsf/utils/lib/unwrapErrorHandler.js
var import_isPlainObject3;
var init_unwrapErrorHandler = __esm({
  "../../node_modules/@rjsf/utils/lib/unwrapErrorHandler.js"() {
    import_isPlainObject3 = __toESM(require_isPlainObject());
  }
});

// ../../node_modules/@rjsf/utils/lib/utcToLocal.js
var init_utcToLocal = __esm({
  "../../node_modules/@rjsf/utils/lib/utcToLocal.js"() {
    init_pad();
  }
});

// ../../node_modules/@rjsf/utils/lib/validationDataMerge.js
var import_isEmpty3;
var init_validationDataMerge = __esm({
  "../../node_modules/@rjsf/utils/lib/validationDataMerge.js"() {
    import_isEmpty3 = __toESM(require_isEmpty());
    init_mergeObjects();
    init_toErrorList();
  }
});

// ../../node_modules/@rjsf/utils/lib/withIdRefPrefix.js
var import_isObject11;
var init_withIdRefPrefix = __esm({
  "../../node_modules/@rjsf/utils/lib/withIdRefPrefix.js"() {
    init_constants();
    import_isObject11 = __toESM(require_isObject());
  }
});

// ../../node_modules/@rjsf/utils/lib/types.js
var init_types = __esm({
  "../../node_modules/@rjsf/utils/lib/types.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/enums.js
var TranslatableString;
var init_enums = __esm({
  "../../node_modules/@rjsf/utils/lib/enums.js"() {
    (function(TranslatableString2) {
      TranslatableString2["ArrayItemTitle"] = "Item";
      TranslatableString2["MissingItems"] = "Missing items definition";
      TranslatableString2["YesLabel"] = "Yes";
      TranslatableString2["NoLabel"] = "No";
      TranslatableString2["CloseLabel"] = "Close";
      TranslatableString2["ErrorsLabel"] = "Errors";
      TranslatableString2["NewStringDefault"] = "New Value";
      TranslatableString2["AddButton"] = "Add";
      TranslatableString2["AddItemButton"] = "Add Item";
      TranslatableString2["CopyButton"] = "Copy";
      TranslatableString2["MoveDownButton"] = "Move down";
      TranslatableString2["MoveUpButton"] = "Move up";
      TranslatableString2["RemoveButton"] = "Remove";
      TranslatableString2["NowLabel"] = "Now";
      TranslatableString2["ClearLabel"] = "Clear";
      TranslatableString2["AriaDateLabel"] = "Select a date";
      TranslatableString2["PreviewLabel"] = "Preview";
      TranslatableString2["DecrementAriaLabel"] = "Decrease value by 1";
      TranslatableString2["IncrementAriaLabel"] = "Increase value by 1";
      TranslatableString2["UnknownFieldType"] = "Unknown field type %1";
      TranslatableString2["OptionPrefix"] = "Option %1";
      TranslatableString2["TitleOptionPrefix"] = "%1 option %2";
      TranslatableString2["KeyLabel"] = "%1 Key";
      TranslatableString2["InvalidObjectField"] = 'Invalid "%1" object field configuration: <em>%2</em>.';
      TranslatableString2["UnsupportedField"] = "Unsupported field schema.";
      TranslatableString2["UnsupportedFieldWithId"] = "Unsupported field schema for field <code>%1</code>.";
      TranslatableString2["UnsupportedFieldWithReason"] = "Unsupported field schema: <em>%1</em>.";
      TranslatableString2["UnsupportedFieldWithIdAndReason"] = "Unsupported field schema for field <code>%1</code>: <em>%2</em>.";
      TranslatableString2["FilesInfo"] = "**%1** (%2, %3 bytes)";
    })(TranslatableString || (TranslatableString = {}));
  }
});

// ../../node_modules/@rjsf/utils/lib/parser/ParserValidator.js
var import_get13, import_isEqual6;
var init_ParserValidator = __esm({
  "../../node_modules/@rjsf/utils/lib/parser/ParserValidator.js"() {
    import_get13 = __toESM(require_get());
    import_isEqual6 = __toESM(require_isEqual());
    init_constants();
    init_hashForSchema();
  }
});

// ../../node_modules/@rjsf/utils/lib/parser/schemaParser.js
var import_forEach, import_isEqual7;
var init_schemaParser = __esm({
  "../../node_modules/@rjsf/utils/lib/parser/schemaParser.js"() {
    import_forEach = __toESM(require_forEach());
    import_isEqual7 = __toESM(require_isEqual());
    init_constants();
    init_ParserValidator();
    init_retrieveSchema();
  }
});

// ../../node_modules/@rjsf/utils/lib/parser/index.js
var init_parser = __esm({
  "../../node_modules/@rjsf/utils/lib/parser/index.js"() {
    init_schemaParser();
  }
});

// ../../node_modules/@rjsf/utils/lib/index.js
var init_lib2 = __esm({
  "../../node_modules/@rjsf/utils/lib/index.js"() {
    init_allowAdditionalItems();
    init_asNumber();
    init_canExpand();
    init_createErrorHandler();
    init_createSchemaUtils();
    init_dataURItoBlob();
    init_deepEquals();
    init_englishStringTranslator();
    init_enumOptionsDeselectValue();
    init_enumOptionsIndexForValue();
    init_enumOptionsIsSelected();
    init_enumOptionsSelectValue();
    init_enumOptionsValueForIndex();
    init_ErrorSchemaBuilder();
    init_findSchemaDefinition();
    init_getDateElementProps();
    init_getDiscriminatorFieldFromSchema();
    init_getInputProps();
    init_getSchemaType();
    init_getSubmitButtonOptions();
    init_getTemplate();
    init_getUiOptions();
    init_getWidget();
    init_guessType();
    init_hashForSchema();
    init_hasWidget();
    init_idGenerators();
    init_isConstant();
    init_isCustomWidget();
    init_isFixedItems();
    init_isObject();
    init_labelValue();
    init_localToUTC();
    init_mergeDefaultsWithFormData();
    init_mergeObjects();
    init_mergeSchemas();
    init_optionsList();
    init_orderProperties();
    init_pad();
    init_parseDateString();
    init_rangeSpec();
    init_replaceStringParameters();
    init_schemaRequiresTrueValue();
    init_shouldRender();
    init_toConstant();
    init_toDateString();
    init_toErrorList();
    init_toErrorSchema();
    init_unwrapErrorHandler();
    init_utcToLocal();
    init_validationDataMerge();
    init_withIdRefPrefix();
    init_getOptionMatchingSimpleDiscriminator();
    init_types();
    init_enums();
    init_constants();
    init_parser();
    init_schema();
  }
});

// ../../node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "../../node_modules/lodash/_basePickBy.js"(exports2, module2) {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path2 = paths[index], value = baseGet(object, path2);
        if (predicate(value, path2)) {
          baseSet(result, castPath(path2, object), value);
        }
      }
      return result;
    }
    module2.exports = basePickBy;
  }
});

// ../../node_modules/lodash/_basePick.js
var require_basePick = __commonJS({
  "../../node_modules/lodash/_basePick.js"(exports2, module2) {
    var basePickBy = require_basePickBy();
    var hasIn = require_hasIn();
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path2) {
        return hasIn(object, path2);
      });
    }
    module2.exports = basePick;
  }
});

// ../../node_modules/lodash/pick.js
var require_pick = __commonJS({
  "../../node_modules/lodash/pick.js"(exports2, module2) {
    var basePick = require_basePick();
    var flatRest = require_flatRest();
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });
    module2.exports = pick;
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/ArrayField.js
var import_jsx_runtime2, import_react6, import_cloneDeep2, import_get14, import_isObject13, import_set5;
var init_ArrayField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/ArrayField.js"() {
    import_jsx_runtime2 = __toESM(require_jsx_runtime());
    import_react6 = __toESM(require_react());
    init_lib2();
    import_cloneDeep2 = __toESM(require_cloneDeep());
    import_get14 = __toESM(require_get());
    import_isObject13 = __toESM(require_isObject());
    import_set5 = __toESM(require_set());
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/BooleanField.js
var import_jsx_runtime3, import_isObject14;
var init_BooleanField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/BooleanField.js"() {
    import_jsx_runtime3 = __toESM(require_jsx_runtime());
    init_lib2();
    import_isObject14 = __toESM(require_isObject());
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/MultiSchemaField.js
var import_jsx_runtime4, import_react7, import_get15, import_isEmpty4, import_omit2;
var init_MultiSchemaField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/MultiSchemaField.js"() {
    import_jsx_runtime4 = __toESM(require_jsx_runtime());
    import_react7 = __toESM(require_react());
    import_get15 = __toESM(require_get());
    import_isEmpty4 = __toESM(require_isEmpty());
    import_omit2 = __toESM(require_omit());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/NumberField.js
var import_jsx_runtime5, import_react8;
var init_NumberField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/NumberField.js"() {
    import_jsx_runtime5 = __toESM(require_jsx_runtime());
    import_react8 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/lodash/unset.js
var require_unset = __commonJS({
  "../../node_modules/lodash/unset.js"(exports2, module2) {
    var baseUnset = require_baseUnset();
    function unset2(object, path2) {
      return object == null ? true : baseUnset(object, path2);
    }
    module2.exports = unset2;
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/ObjectField.js
var import_jsx_runtime6, import_react9, import_get16, import_has4, import_isObject15, import_set6, import_unset;
var init_ObjectField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/ObjectField.js"() {
    import_jsx_runtime6 = __toESM(require_jsx_runtime());
    import_react9 = __toESM(require_react());
    init_lib2();
    import_get16 = __toESM(require_get());
    import_has4 = __toESM(require_has());
    import_isObject15 = __toESM(require_isObject());
    import_set6 = __toESM(require_set());
    import_unset = __toESM(require_unset());
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/SchemaField.js
var import_jsx_runtime7, import_react10, import_isObject16, import_omit3;
var init_SchemaField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/SchemaField.js"() {
    import_jsx_runtime7 = __toESM(require_jsx_runtime());
    import_react10 = __toESM(require_react());
    init_lib2();
    import_isObject16 = __toESM(require_isObject());
    import_omit3 = __toESM(require_omit());
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/StringField.js
var import_jsx_runtime8;
var init_StringField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/StringField.js"() {
    import_jsx_runtime8 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/NullField.js
var import_react11;
var init_NullField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/NullField.js"() {
    import_react11 = __toESM(require_react());
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/index.js
var init_fields = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/index.js"() {
    init_ArrayField();
    init_BooleanField();
    init_MultiSchemaField();
    init_NumberField();
    init_ObjectField();
    init_SchemaField();
    init_StringField();
    init_NullField();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldDescriptionTemplate.js
var import_jsx_runtime9;
var init_ArrayFieldDescriptionTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldDescriptionTemplate.js"() {
    import_jsx_runtime9 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldItemTemplate.js
var import_jsx_runtime10;
var init_ArrayFieldItemTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldItemTemplate.js"() {
    import_jsx_runtime10 = __toESM(require_jsx_runtime());
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldTemplate.js
var import_jsx_runtime11;
var init_ArrayFieldTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldTemplate.js"() {
    import_jsx_runtime11 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldTitleTemplate.js
var import_jsx_runtime12;
var init_ArrayFieldTitleTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldTitleTemplate.js"() {
    import_jsx_runtime12 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/BaseInputTemplate.js
var import_jsx_runtime13, import_react12;
var init_BaseInputTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/BaseInputTemplate.js"() {
    import_jsx_runtime13 = __toESM(require_jsx_runtime());
    import_react12 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/SubmitButton.js
var import_jsx_runtime14;
var init_SubmitButton = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/SubmitButton.js"() {
    import_jsx_runtime14 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/IconButton.js
var import_jsx_runtime15;
var init_IconButton = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/IconButton.js"() {
    import_jsx_runtime15 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/AddButton.js
var import_jsx_runtime16;
var init_AddButton = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/AddButton.js"() {
    import_jsx_runtime16 = __toESM(require_jsx_runtime());
    init_lib2();
    init_IconButton();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/index.js
var init_ButtonTemplates = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/index.js"() {
    init_SubmitButton();
    init_AddButton();
    init_IconButton();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/DescriptionField.js
var import_jsx_runtime17;
var init_DescriptionField = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/DescriptionField.js"() {
    import_jsx_runtime17 = __toESM(require_jsx_runtime());
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ErrorList.js
var import_jsx_runtime18;
var init_ErrorList = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ErrorList.js"() {
    import_jsx_runtime18 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/Label.js
var import_jsx_runtime19;
var init_Label = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/Label.js"() {
    import_jsx_runtime19 = __toESM(require_jsx_runtime());
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/FieldTemplate.js
var import_jsx_runtime20;
var init_FieldTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/FieldTemplate.js"() {
    import_jsx_runtime20 = __toESM(require_jsx_runtime());
    init_lib2();
    init_Label();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/index.js
var init_FieldTemplate2 = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/index.js"() {
    init_FieldTemplate();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/FieldErrorTemplate.js
var import_jsx_runtime21;
var init_FieldErrorTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/FieldErrorTemplate.js"() {
    import_jsx_runtime21 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/FieldHelpTemplate.js
var import_jsx_runtime22;
var init_FieldHelpTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/FieldHelpTemplate.js"() {
    import_jsx_runtime22 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ObjectFieldTemplate.js
var import_jsx_runtime23;
var init_ObjectFieldTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ObjectFieldTemplate.js"() {
    import_jsx_runtime23 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/TitleField.js
var import_jsx_runtime24;
var init_TitleField = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/TitleField.js"() {
    import_jsx_runtime24 = __toESM(require_jsx_runtime());
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/UnsupportedField.js
var import_jsx_runtime25;
var init_UnsupportedField = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/UnsupportedField.js"() {
    import_jsx_runtime25 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/WrapIfAdditionalTemplate.js
var import_jsx_runtime26;
var init_WrapIfAdditionalTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/WrapIfAdditionalTemplate.js"() {
    import_jsx_runtime26 = __toESM(require_jsx_runtime());
    init_lib2();
    init_Label();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/index.js
var init_templates = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/index.js"() {
    init_ArrayFieldDescriptionTemplate();
    init_ArrayFieldItemTemplate();
    init_ArrayFieldTemplate();
    init_ArrayFieldTitleTemplate();
    init_BaseInputTemplate();
    init_ButtonTemplates();
    init_DescriptionField();
    init_ErrorList();
    init_FieldTemplate2();
    init_FieldErrorTemplate();
    init_FieldHelpTemplate();
    init_ObjectFieldTemplate();
    init_TitleField();
    init_UnsupportedField();
    init_WrapIfAdditionalTemplate();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/AltDateWidget.js
var import_jsx_runtime27, import_react13;
var init_AltDateWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/AltDateWidget.js"() {
    import_jsx_runtime27 = __toESM(require_jsx_runtime());
    import_react13 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/AltDateTimeWidget.js
var import_jsx_runtime28;
var init_AltDateTimeWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/AltDateTimeWidget.js"() {
    import_jsx_runtime28 = __toESM(require_jsx_runtime());
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/CheckboxWidget.js
var import_jsx_runtime29, import_react14;
var init_CheckboxWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/CheckboxWidget.js"() {
    import_jsx_runtime29 = __toESM(require_jsx_runtime());
    import_react14 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/CheckboxesWidget.js
var import_jsx_runtime30, import_react15;
var init_CheckboxesWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/CheckboxesWidget.js"() {
    import_jsx_runtime30 = __toESM(require_jsx_runtime());
    import_react15 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/ColorWidget.js
var import_jsx_runtime31;
var init_ColorWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/ColorWidget.js"() {
    import_jsx_runtime31 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/DateWidget.js
var import_jsx_runtime32, import_react16;
var init_DateWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/DateWidget.js"() {
    import_jsx_runtime32 = __toESM(require_jsx_runtime());
    import_react16 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/DateTimeWidget.js
var import_jsx_runtime33;
var init_DateTimeWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/DateTimeWidget.js"() {
    import_jsx_runtime33 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/EmailWidget.js
var import_jsx_runtime34;
var init_EmailWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/EmailWidget.js"() {
    import_jsx_runtime34 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/FileWidget.js
var import_jsx_runtime35, import_react17;
var init_FileWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/FileWidget.js"() {
    import_jsx_runtime35 = __toESM(require_jsx_runtime());
    import_react17 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/HiddenWidget.js
var import_jsx_runtime36;
var init_HiddenWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/HiddenWidget.js"() {
    import_jsx_runtime36 = __toESM(require_jsx_runtime());
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/PasswordWidget.js
var import_jsx_runtime37;
var init_PasswordWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/PasswordWidget.js"() {
    import_jsx_runtime37 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/RadioWidget.js
var import_jsx_runtime38, import_react18;
var init_RadioWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/RadioWidget.js"() {
    import_jsx_runtime38 = __toESM(require_jsx_runtime());
    import_react18 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/RangeWidget.js
var import_jsx_runtime39;
var init_RangeWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/RangeWidget.js"() {
    import_jsx_runtime39 = __toESM(require_jsx_runtime());
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/SelectWidget.js
var import_jsx_runtime40, import_react19;
var init_SelectWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/SelectWidget.js"() {
    import_jsx_runtime40 = __toESM(require_jsx_runtime());
    import_react19 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/TextareaWidget.js
function TextareaWidget({ id, options = {}, placeholder, value, required, disabled, readonly, autofocus = false, onChange, onBlur, onFocus }) {
  const handleChange = (0, import_react20.useCallback)(({ target: { value: value2 } }) => onChange(value2 === "" ? options.emptyValue : value2), [onChange, options.emptyValue]);
  const handleBlur = (0, import_react20.useCallback)(({ target: { value: value2 } }) => onBlur(id, value2), [onBlur, id]);
  const handleFocus = (0, import_react20.useCallback)(({ target: { value: value2 } }) => onFocus(id, value2), [id, onFocus]);
  return (0, import_jsx_runtime41.jsx)("textarea", { id, name: id, className: "form-control", value: value ? value : "", placeholder, required, disabled, readOnly: readonly, autoFocus: autofocus, rows: options.rows, onBlur: handleBlur, onFocus: handleFocus, onChange: handleChange, "aria-describedby": ariaDescribedByIds(id) });
}
var import_jsx_runtime41, import_react20;
var init_TextareaWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/TextareaWidget.js"() {
    import_jsx_runtime41 = __toESM(require_jsx_runtime());
    import_react20 = __toESM(require_react());
    init_lib2();
    TextareaWidget.defaultProps = {
      autofocus: false,
      options: {}
    };
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/TextWidget.js
var import_jsx_runtime42;
var init_TextWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/TextWidget.js"() {
    import_jsx_runtime42 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/TimeWidget.js
var import_jsx_runtime43, import_react21;
var init_TimeWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/TimeWidget.js"() {
    import_jsx_runtime43 = __toESM(require_jsx_runtime());
    import_react21 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/URLWidget.js
var import_jsx_runtime44;
var init_URLWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/URLWidget.js"() {
    import_jsx_runtime44 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/UpDownWidget.js
var import_jsx_runtime45;
var init_UpDownWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/UpDownWidget.js"() {
    import_jsx_runtime45 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/index.js
var init_widgets2 = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/index.js"() {
    init_AltDateWidget();
    init_AltDateTimeWidget();
    init_CheckboxWidget();
    init_CheckboxesWidget();
    init_ColorWidget();
    init_DateWidget();
    init_DateTimeWidget();
    init_EmailWidget();
    init_FileWidget();
    init_HiddenWidget();
    init_PasswordWidget();
    init_RadioWidget();
    init_RangeWidget();
    init_SelectWidget();
    init_TextareaWidget();
    init_TextWidget();
    init_TimeWidget();
    init_URLWidget();
    init_UpDownWidget();
  }
});

// ../../node_modules/@rjsf/core/lib/getDefaultRegistry.js
var init_getDefaultRegistry = __esm({
  "../../node_modules/@rjsf/core/lib/getDefaultRegistry.js"() {
    init_lib2();
    init_fields();
    init_templates();
    init_widgets2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/Form.js
var import_jsx_runtime46, import_react22, import_get17, import_isEmpty5, import_pick, import_toPath2;
var init_Form = __esm({
  "../../node_modules/@rjsf/core/lib/components/Form.js"() {
    import_jsx_runtime46 = __toESM(require_jsx_runtime());
    import_react22 = __toESM(require_react());
    init_lib2();
    import_get17 = __toESM(require_get());
    import_isEmpty5 = __toESM(require_isEmpty());
    import_pick = __toESM(require_pick());
    import_toPath2 = __toESM(require_toPath());
    init_getDefaultRegistry();
  }
});

// ../../node_modules/@rjsf/core/lib/withTheme.js
var import_jsx_runtime47, import_react23;
var init_withTheme = __esm({
  "../../node_modules/@rjsf/core/lib/withTheme.js"() {
    import_jsx_runtime47 = __toESM(require_jsx_runtime());
    import_react23 = __toESM(require_react());
    init_Form();
  }
});

// ../../node_modules/@rjsf/core/lib/index.js
var init_lib3 = __esm({
  "../../node_modules/@rjsf/core/lib/index.js"() {
    init_Form();
    init_withTheme();
    init_getDefaultRegistry();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/form.js
var import_coreutils8, import_react24;
var init_form = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/form.js"() {
    init_lib();
    import_coreutils8 = __toESM(require_dist());
    init_lib3();
    init_lib2();
    import_react24 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/interface.js
var init_interface = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/interface.js"() {
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/htmlselect.js
var React5;
var init_htmlselect = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/htmlselect.js"() {
    React5 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/iframe.js
var Private18;
var init_iframe = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/iframe.js"() {
    init_index_es618();
    (function(Private36) {
      function createNode() {
        const node = document.createElement("div");
        const iframe = document.createElement("iframe");
        iframe.setAttribute("sandbox", "");
        iframe.style.height = "100%";
        iframe.style.width = "100%";
        node.appendChild(iframe);
        return node;
      }
      Private36.createNode = createNode;
    })(Private18 || (Private18 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/algorithm/dist/index.es6.js
function find3(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return value;
    }
  }
  return void 0;
}
function every2(object, fn) {
  let index = 0;
  for (const value of object) {
    if (false === fn(value, index++)) {
      return false;
    }
  }
  return true;
}
function some2(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return true;
    }
  }
  return false;
}
function* map(object, fn) {
  let index = 0;
  for (const value of object) {
    yield fn(value, index++);
  }
}
function* retro2(object) {
  if (typeof object.retro === "function") {
    yield* object.retro();
  } else {
    for (let index = object.length - 1; index > -1; index--) {
      yield object[index];
    }
  }
}
var ArrayExt5, Private19, StringExt5;
var init_index_es619 = __esm({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt8) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start + i) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start - i + n) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start + i) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findFirstIndex = findFirstIndex;
      function findLastIndex2(array, fn, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let d;
        if (start < stop) {
          d = start + 1 + (n - stop);
        } else {
          d = start - stop + 1;
        }
        for (let i = 0; i < d; ++i) {
          let j = (start - i + n) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findLastIndex = findLastIndex2;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index = findFirstIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index = findLastIndex2(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt8.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt8.upperBound = upperBound;
      function shallowEqual(a, b, fn) {
        if (a === b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0, n = a.length; i < n; ++i) {
          if (fn ? !fn(a[i], b[i]) : a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt8.shallowEqual = shallowEqual;
      function slice(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n = array.length;
        if (start === void 0) {
          start = step < 0 ? n - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n, step < 0 ? -1 : 0);
        } else if (start >= n) {
          start = step < 0 ? n - 1 : n;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n;
        } else if (stop < 0) {
          stop = Math.max(stop + n, step < 0 ? -1 : 0);
        } else if (stop >= n) {
          stop = step < 0 ? n - 1 : n;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result = [];
        for (let i = 0; i < length; ++i) {
          result[i] = array[start + i * step];
        }
        return result;
      }
      ArrayExt8.slice = slice;
      function move(array, fromIndex, toIndex) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n);
        } else {
          fromIndex = Math.min(fromIndex, n - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n);
        } else {
          toIndex = Math.min(toIndex, n - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d = fromIndex < toIndex ? 1 : -1;
        for (let i = fromIndex; i !== toIndex; i += d) {
          array[i] = array[i + d];
        }
        array[toIndex] = value;
      }
      ArrayExt8.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        while (start < stop) {
          let a = array[start];
          let b = array[stop];
          array[start++] = b;
          array[stop--] = a;
        }
      }
      ArrayExt8.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt8.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          array[(start + i) % n] = value;
        }
      }
      ArrayExt8.fill = fill;
      function insert(array, index, value) {
        let n = array.length;
        if (index < 0) {
          index = Math.max(0, index + n);
        } else {
          index = Math.min(index, n);
        }
        for (let i = n; i > index; --i) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      ArrayExt8.insert = insert;
      function removeAt(array, index) {
        let n = array.length;
        if (index < 0) {
          index += n;
        }
        if (index < 0 || index >= n) {
          return void 0;
        }
        let value = array[index];
        for (let i = index + 1; i < n; ++i) {
          array[i - 1] = array[i];
        }
        array.length = n - 1;
        return value;
      }
      ArrayExt8.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index = firstIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index = lastIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i = 0; i < n; ++i) {
          if (start <= stop && i >= start && i <= stop && array[i] === value) {
            count++;
          } else if (stop < start && (i <= stop || i >= start) && array[i] === value) {
            count++;
          } else if (count > 0) {
            array[i - count] = array[i];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index = findFirstIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index = findLastIndex2(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i = 0; i < n; ++i) {
          if (start <= stop && i >= start && i <= stop && fn(array[i], i)) {
            count++;
          } else if (stop < start && (i <= stop || i >= start) && fn(array[i], i)) {
            count++;
          } else if (count > 0) {
            array[i - count] = array[i];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllWhere = removeAllWhere;
    })(ArrayExt5 || (ArrayExt5 = {}));
    (function(Private36) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private36.rangeLength = rangeLength;
    })(Private19 || (Private19 = {}));
    (function(StringExt8) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i = 0, j = start, n = query.length; i < n; ++i, ++j) {
          j = source.indexOf(query[i], j);
          if (j === -1) {
            return null;
          }
          indices[i] = j;
        }
        return indices;
      }
      StringExt8.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i = 0, n = indices.length; i < n; ++i) {
          let j = indices[i] - start;
          score += j * j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last = start - 1;
        for (let i = 0, n = indices.length; i < n; ++i) {
          let j = indices[i];
          score += j - last - 1;
          last = j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result = [];
        let k = 0;
        let last = 0;
        let n = indices.length;
        while (k < n) {
          let i = indices[k];
          let j = indices[k];
          while (++k < n && indices[k] === j + 1) {
            j++;
          }
          if (last < i) {
            result.push(source.slice(last, i));
          }
          if (i < j + 1) {
            result.push(fn(source.slice(i, j + 1)));
          }
          last = j + 1;
        }
        if (last < source.length) {
          result.push(source.slice(last));
        }
        return result;
      }
      StringExt8.highlight = highlight;
      function cmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      StringExt8.cmp = cmp;
    })(StringExt5 || (StringExt5 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/menu.js
var IRankedMenu;
var init_menu = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/menu.js"() {
    init_index_es619();
    init_index_es65();
    init_index_es63();
    init_index_es618();
    (function(IRankedMenu2) {
      IRankedMenu2.DEFAULT_RANK = 100;
    })(IRankedMenu || (IRankedMenu = {}));
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/math-utilities.js
function clamp(i, min, max2) {
  if (isNaN(i) || i <= min) {
    return min;
  } else if (i >= max2) {
    return max2;
  }
  return i;
}
function normalize(i, min, max2) {
  if (isNaN(i) || i <= min) {
    return 0;
  } else if (i >= max2) {
    return 1;
  }
  return i / (max2 - min);
}
function denormalize(i, min, max2) {
  if (isNaN(i)) {
    return min;
  }
  return min + i * (max2 - min);
}
function degreesToRadians(i) {
  return i * (Math.PI / 180);
}
function radiansToDegrees(i) {
  return i * (180 / Math.PI);
}
function getHexStringForByte(i) {
  const s = Math.round(clamp(i, 0, 255)).toString(16);
  if (s.length === 1) {
    return "0" + s;
  }
  return s;
}
function lerp(i, min, max2) {
  if (isNaN(i) || i <= 0) {
    return min;
  } else if (i >= 1) {
    return max2;
  }
  return min + i * (max2 - min);
}
function lerpAnglesInDegrees(i, min, max2) {
  if (i <= 0) {
    return min % 360;
  } else if (i >= 1) {
    return max2 % 360;
  }
  const a = (min - max2 + 360) % 360;
  const b = (max2 - min + 360) % 360;
  if (a <= b) {
    return (min - a * i + 360) % 360;
  }
  return (min + a * i + 360) % 360;
}
function roundToPrecisionSmall(i, precision) {
  const factor = Math.pow(10, precision);
  return Math.round(i * factor) / factor;
}
var TwoPI;
var init_math_utilities = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/math-utilities.js"() {
    TwoPI = Math.PI * 2;
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/color-hsl.js
var ColorHSL;
var init_color_hsl = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/color-hsl.js"() {
    init_math_utilities();
    ColorHSL = class {
      constructor(hue, sat, lum) {
        this.h = hue;
        this.s = sat;
        this.l = lum;
      }
      /**
       * Construct a {@link ColorHSL} from a config object.
       */
      static fromObject(data) {
        if (data && !isNaN(data.h) && !isNaN(data.s) && !isNaN(data.l)) {
          return new ColorHSL(data.h, data.s, data.l);
        }
        return null;
      }
      /**
       * Determines if a color is equal to another
       * @param rhs - the value to compare
       */
      equalValue(rhs) {
        return this.h === rhs.h && this.s === rhs.s && this.l === rhs.l;
      }
      /**
       * Returns a new {@link ColorHSL} rounded to the provided precision
       * @param precision - the precision to round to
       */
      roundToPrecision(precision) {
        return new ColorHSL(roundToPrecisionSmall(this.h, precision), roundToPrecisionSmall(this.s, precision), roundToPrecisionSmall(this.l, precision));
      }
      /**
       * Returns the {@link ColorHSL} formatted as an object.
       */
      toObject() {
        return { h: this.h, s: this.s, l: this.l };
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/color-hsv.js
var ColorHSV;
var init_color_hsv = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/color-hsv.js"() {
    init_math_utilities();
    ColorHSV = class {
      constructor(hue, sat, val) {
        this.h = hue;
        this.s = sat;
        this.v = val;
      }
      /**
       * Construct a {@link ColorHSV} from a config object.
       */
      static fromObject(data) {
        if (data && !isNaN(data.h) && !isNaN(data.s) && !isNaN(data.v)) {
          return new ColorHSV(data.h, data.s, data.v);
        }
        return null;
      }
      /**
       * Determines if a color is equal to another
       * @param rhs - the value to compare
       */
      equalValue(rhs) {
        return this.h === rhs.h && this.s === rhs.s && this.v === rhs.v;
      }
      /**
       * Returns a new {@link ColorHSV} rounded to the provided precision
       * @param precision - the precision to round to
       */
      roundToPrecision(precision) {
        return new ColorHSV(roundToPrecisionSmall(this.h, precision), roundToPrecisionSmall(this.s, precision), roundToPrecisionSmall(this.v, precision));
      }
      /**
       * Returns the {@link ColorHSV} formatted as an object.
       */
      toObject() {
        return { h: this.h, s: this.s, v: this.v };
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/color-lab.js
var ColorLAB;
var init_color_lab = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/color-lab.js"() {
    init_math_utilities();
    ColorLAB = class {
      constructor(l, a, b) {
        this.l = l;
        this.a = a;
        this.b = b;
      }
      /**
       * Construct a {@link ColorLAB} from a config object.
       */
      static fromObject(data) {
        if (data && !isNaN(data.l) && !isNaN(data.a) && !isNaN(data.b)) {
          return new ColorLAB(data.l, data.a, data.b);
        }
        return null;
      }
      /**
       * Determines if a color is equal to another
       * @param rhs - the value to compare
       */
      equalValue(rhs) {
        return this.l === rhs.l && this.a === rhs.a && this.b === rhs.b;
      }
      /**
       * Returns a new {@link ColorLAB} rounded to the provided precision
       * @param precision - the precision to round to
       */
      roundToPrecision(precision) {
        return new ColorLAB(roundToPrecisionSmall(this.l, precision), roundToPrecisionSmall(this.a, precision), roundToPrecisionSmall(this.b, precision));
      }
      /**
       * Returns the {@link ColorLAB} formatted as an object.
       */
      toObject() {
        return { l: this.l, a: this.a, b: this.b };
      }
    };
    ColorLAB.epsilon = 216 / 24389;
    ColorLAB.kappa = 24389 / 27;
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/color-lch.js
var ColorLCH;
var init_color_lch = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/color-lch.js"() {
    init_math_utilities();
    ColorLCH = class {
      constructor(l, c, h2) {
        this.l = l;
        this.c = c;
        this.h = h2;
      }
      /**
       * Construct a {@link ColorLCH} from a config object.
       * @param data - the config object
       */
      static fromObject(data) {
        if (data && !isNaN(data.l) && !isNaN(data.c) && !isNaN(data.h)) {
          return new ColorLCH(data.l, data.c, data.h);
        }
        return null;
      }
      /**
       * Determines if one color is equal to another.
       * @param rhs - the color to compare
       */
      equalValue(rhs) {
        return this.l === rhs.l && this.c === rhs.c && this.h === rhs.h;
      }
      /**
       * Returns a new {@link ColorLCH} rounded to the provided precision
       * @param precision - the precision to round to
       */
      roundToPrecision(precision) {
        return new ColorLCH(roundToPrecisionSmall(this.l, precision), roundToPrecisionSmall(this.c, precision), roundToPrecisionSmall(this.h, precision));
      }
      /**
       * Converts the {@link ColorLCH} to a config object.
       */
      toObject() {
        return { l: this.l, c: this.c, h: this.h };
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/color-rgba-64.js
var ColorRGBA64;
var init_color_rgba_64 = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/color-rgba-64.js"() {
    init_math_utilities();
    ColorRGBA64 = class {
      /**
       *
       * @param red - the red value
       * @param green - the green value
       * @param blue - the blue value
       * @param alpha - the alpha value
       */
      constructor(red, green, blue, alpha) {
        this.r = red;
        this.g = green;
        this.b = blue;
        this.a = typeof alpha === "number" && !isNaN(alpha) ? alpha : 1;
      }
      /**
       * Construct a {@link ColorRGBA64} from a {@link ColorRGBA64Config}
       * @param data - the config object
       */
      static fromObject(data) {
        return data && !isNaN(data.r) && !isNaN(data.g) && !isNaN(data.b) ? new ColorRGBA64(data.r, data.g, data.b, data.a) : null;
      }
      /**
       * Determines if one color is equal to another.
       * @param rhs - the color to compare
       */
      equalValue(rhs) {
        return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
      }
      /**
       * Returns the color formatted as a string; #RRGGBB
       */
      toStringHexRGB() {
        return "#" + [this.r, this.g, this.b].map(this.formatHexValue).join("");
      }
      /**
       * Returns the color formatted as a string; #RRGGBBAA
       */
      toStringHexRGBA() {
        return this.toStringHexRGB() + this.formatHexValue(this.a);
      }
      /**
       * Returns the color formatted as a string; #AARRGGBB
       */
      toStringHexARGB() {
        return "#" + [this.a, this.r, this.g, this.b].map(this.formatHexValue).join("");
      }
      /**
       * Returns the color formatted as a string; "rgb(0xRR, 0xGG, 0xBB)"
       */
      toStringWebRGB() {
        return `rgb(${Math.round(denormalize(this.r, 0, 255))},${Math.round(denormalize(this.g, 0, 255))},${Math.round(denormalize(this.b, 0, 255))})`;
      }
      /**
       * Returns the color formatted as a string; "rgba(0xRR, 0xGG, 0xBB, a)"
       * @remarks
       * Note that this follows the convention of putting alpha in the range [0.0,1.0] while the other three channels are [0,255]
       */
      toStringWebRGBA() {
        return `rgba(${Math.round(denormalize(this.r, 0, 255))},${Math.round(denormalize(this.g, 0, 255))},${Math.round(denormalize(this.b, 0, 255))},${clamp(this.a, 0, 1)})`;
      }
      /**
       * Returns a new {@link ColorRGBA64} rounded to the provided precision
       * @param precision - the precision to round to
       */
      roundToPrecision(precision) {
        return new ColorRGBA64(roundToPrecisionSmall(this.r, precision), roundToPrecisionSmall(this.g, precision), roundToPrecisionSmall(this.b, precision), roundToPrecisionSmall(this.a, precision));
      }
      /**
       * Returns a new {@link ColorRGBA64} with channel values clamped between 0 and 1.
       */
      clamp() {
        return new ColorRGBA64(clamp(this.r, 0, 1), clamp(this.g, 0, 1), clamp(this.b, 0, 1), clamp(this.a, 0, 1));
      }
      /**
       * Converts the {@link ColorRGBA64} to a {@link ColorRGBA64Config}.
       */
      toObject() {
        return { r: this.r, g: this.g, b: this.b, a: this.a };
      }
      formatHexValue(value) {
        return getHexStringForByte(denormalize(value, 0, 255));
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/color-xyz.js
var ColorXYZ;
var init_color_xyz = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/color-xyz.js"() {
    init_math_utilities();
    ColorXYZ = class {
      constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
      }
      /**
       * Construct a {@link ColorXYZ} from a config object.
       */
      static fromObject(data) {
        if (data && !isNaN(data.x) && !isNaN(data.y) && !isNaN(data.z)) {
          return new ColorXYZ(data.x, data.y, data.z);
        }
        return null;
      }
      /**
       * Determines if a color is equal to another
       * @param rhs - the value to compare
       */
      equalValue(rhs) {
        return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
      }
      /**
       * Returns a new {@link ColorXYZ} rounded to the provided precision
       * @param precision - the precision to round to
       */
      roundToPrecision(precision) {
        return new ColorXYZ(roundToPrecisionSmall(this.x, precision), roundToPrecisionSmall(this.y, precision), roundToPrecisionSmall(this.z, precision));
      }
      /**
       * Returns the {@link ColorXYZ} formatted as an object.
       */
      toObject() {
        return { x: this.x, y: this.y, z: this.z };
      }
    };
    ColorXYZ.whitePoint = new ColorXYZ(0.95047, 1, 1.08883);
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/color-converters.js
function rgbToLinearLuminance(rgb) {
  return rgb.r * 0.2126 + rgb.g * 0.7152 + rgb.b * 0.0722;
}
function rgbToRelativeLuminance(rgb) {
  function luminanceHelper(i) {
    if (i <= 0.03928) {
      return i / 12.92;
    }
    return Math.pow((i + 0.055) / 1.055, 2.4);
  }
  return rgbToLinearLuminance(new ColorRGBA64(luminanceHelper(rgb.r), luminanceHelper(rgb.g), luminanceHelper(rgb.b), 1));
}
function contrastRatio(a, b) {
  const luminanceA = rgbToRelativeLuminance(a);
  const luminanceB = rgbToRelativeLuminance(b);
  return luminanceA > luminanceB ? calculateContrastRatio(luminanceA, luminanceB) : calculateContrastRatio(luminanceB, luminanceA);
}
function rgbToHSL(rgb) {
  const max2 = Math.max(rgb.r, rgb.g, rgb.b);
  const min = Math.min(rgb.r, rgb.g, rgb.b);
  const delta = max2 - min;
  let hue = 0;
  if (delta !== 0) {
    if (max2 === rgb.r) {
      hue = 60 * ((rgb.g - rgb.b) / delta % 6);
    } else if (max2 === rgb.g) {
      hue = 60 * ((rgb.b - rgb.r) / delta + 2);
    } else {
      hue = 60 * ((rgb.r - rgb.g) / delta + 4);
    }
  }
  if (hue < 0) {
    hue += 360;
  }
  const lum = (max2 + min) / 2;
  let sat = 0;
  if (delta !== 0) {
    sat = delta / (1 - Math.abs(2 * lum - 1));
  }
  return new ColorHSL(hue, sat, lum);
}
function hslToRGB(hsl, alpha = 1) {
  const c = (1 - Math.abs(2 * hsl.l - 1)) * hsl.s;
  const x = c * (1 - Math.abs(hsl.h / 60 % 2 - 1));
  const m = hsl.l - c / 2;
  let r = 0;
  let g = 0;
  let b = 0;
  if (hsl.h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (hsl.h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (hsl.h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (hsl.h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (hsl.h < 300) {
    r = x;
    g = 0;
    b = c;
  } else if (hsl.h < 360) {
    r = c;
    g = 0;
    b = x;
  }
  return new ColorRGBA64(r + m, g + m, b + m, alpha);
}
function rgbToHSV(rgb) {
  const max2 = Math.max(rgb.r, rgb.g, rgb.b);
  const min = Math.min(rgb.r, rgb.g, rgb.b);
  const delta = max2 - min;
  let hue = 0;
  if (delta !== 0) {
    if (max2 === rgb.r) {
      hue = 60 * ((rgb.g - rgb.b) / delta % 6);
    } else if (max2 === rgb.g) {
      hue = 60 * ((rgb.b - rgb.r) / delta + 2);
    } else {
      hue = 60 * ((rgb.r - rgb.g) / delta + 4);
    }
  }
  if (hue < 0) {
    hue += 360;
  }
  let sat = 0;
  if (max2 !== 0) {
    sat = delta / max2;
  }
  return new ColorHSV(hue, sat, max2);
}
function hsvToRGB(hsv, alpha = 1) {
  const c = hsv.s * hsv.v;
  const x = c * (1 - Math.abs(hsv.h / 60 % 2 - 1));
  const m = hsv.v - c;
  let r = 0;
  let g = 0;
  let b = 0;
  if (hsv.h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (hsv.h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (hsv.h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (hsv.h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (hsv.h < 300) {
    r = x;
    g = 0;
    b = c;
  } else if (hsv.h < 360) {
    r = c;
    g = 0;
    b = x;
  }
  return new ColorRGBA64(r + m, g + m, b + m, alpha);
}
function lchToLAB(lch) {
  let a = 0;
  let b = 0;
  if (lch.h !== 0) {
    a = Math.cos(degreesToRadians(lch.h)) * lch.c;
    b = Math.sin(degreesToRadians(lch.h)) * lch.c;
  }
  return new ColorLAB(lch.l, a, b);
}
function labToLCH(lab) {
  let h2 = 0;
  if (Math.abs(lab.b) > 1e-3 || Math.abs(lab.a) > 1e-3) {
    h2 = radiansToDegrees(Math.atan2(lab.b, lab.a));
  }
  if (h2 < 0) {
    h2 += 360;
  }
  const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
  return new ColorLCH(lab.l, c, h2);
}
function labToXYZ(lab) {
  const fy = (lab.l + 16) / 116;
  const fx = fy + lab.a / 500;
  const fz = fy - lab.b / 200;
  const xcubed = Math.pow(fx, 3);
  const ycubed = Math.pow(fy, 3);
  const zcubed = Math.pow(fz, 3);
  let x = 0;
  if (xcubed > ColorLAB.epsilon) {
    x = xcubed;
  } else {
    x = (116 * fx - 16) / ColorLAB.kappa;
  }
  let y = 0;
  if (lab.l > ColorLAB.epsilon * ColorLAB.kappa) {
    y = ycubed;
  } else {
    y = lab.l / ColorLAB.kappa;
  }
  let z = 0;
  if (zcubed > ColorLAB.epsilon) {
    z = zcubed;
  } else {
    z = (116 * fz - 16) / ColorLAB.kappa;
  }
  x = ColorXYZ.whitePoint.x * x;
  y = ColorXYZ.whitePoint.y * y;
  z = ColorXYZ.whitePoint.z * z;
  return new ColorXYZ(x, y, z);
}
function xyzToLAB(xyz) {
  function xyzToLABHelper(i) {
    if (i > ColorLAB.epsilon) {
      return Math.pow(i, 1 / 3);
    }
    return (ColorLAB.kappa * i + 16) / 116;
  }
  const x = xyzToLABHelper(xyz.x / ColorXYZ.whitePoint.x);
  const y = xyzToLABHelper(xyz.y / ColorXYZ.whitePoint.y);
  const z = xyzToLABHelper(xyz.z / ColorXYZ.whitePoint.z);
  const l = 116 * y - 16;
  const a = 500 * (x - y);
  const b = 200 * (y - z);
  return new ColorLAB(l, a, b);
}
function rgbToXYZ(rgb) {
  function rgbToXYZHelper(i) {
    if (i <= 0.04045) {
      return i / 12.92;
    }
    return Math.pow((i + 0.055) / 1.055, 2.4);
  }
  const r = rgbToXYZHelper(rgb.r);
  const g = rgbToXYZHelper(rgb.g);
  const b = rgbToXYZHelper(rgb.b);
  const x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
  const y = r * 0.2126729 + g * 0.7151522 + b * 0.072175;
  const z = r * 0.0193339 + g * 0.119192 + b * 0.9503041;
  return new ColorXYZ(x, y, z);
}
function xyzToRGB(xyz, alpha = 1) {
  function xyzToRGBHelper(i) {
    if (i <= 31308e-7) {
      return i * 12.92;
    }
    return 1.055 * Math.pow(i, 1 / 2.4) - 0.055;
  }
  const r = xyzToRGBHelper(xyz.x * 3.2404542 - xyz.y * 1.5371385 - xyz.z * 0.4985314);
  const g = xyzToRGBHelper(xyz.x * -0.969266 + xyz.y * 1.8760108 + xyz.z * 0.041556);
  const b = xyzToRGBHelper(xyz.x * 0.0556434 - xyz.y * 0.2040259 + xyz.z * 1.0572252);
  return new ColorRGBA64(r, g, b, alpha);
}
function rgbToLAB(rgb) {
  return xyzToLAB(rgbToXYZ(rgb));
}
function labToRGB(lab, alpha = 1) {
  return xyzToRGB(labToXYZ(lab), alpha);
}
function rgbToLCH(rgb) {
  return labToLCH(rgbToLAB(rgb));
}
function lchToRGB(lch, alpha = 1) {
  return labToRGB(lchToLAB(lch), alpha);
}
var calculateContrastRatio;
var init_color_converters = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/color-converters.js"() {
    init_color_hsl();
    init_color_hsv();
    init_color_lab();
    init_color_lch();
    init_color_rgba_64();
    init_color_xyz();
    init_math_utilities();
    calculateContrastRatio = (a, b) => (a + 0.05) / (b + 0.05);
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/color-blending.js
function saturateViaLCH(input, saturation, saturationConstant = 18) {
  const lch = rgbToLCH(input);
  let sat = lch.c + saturation * saturationConstant;
  if (sat < 0) {
    sat = 0;
  }
  return lchToRGB(new ColorLCH(lch.l, sat, lch.h));
}
function blendMultiplyChannel(bottom, top) {
  return bottom * top;
}
function blendMultiply(bottom, top) {
  return new ColorRGBA64(blendMultiplyChannel(bottom.r, top.r), blendMultiplyChannel(bottom.g, top.g), blendMultiplyChannel(bottom.b, top.b), 1);
}
function blendOverlayChannel(bottom, top) {
  if (bottom < 0.5) {
    return clamp(2 * top * bottom, 0, 1);
  }
  return clamp(1 - 2 * (1 - top) * (1 - bottom), 0, 1);
}
function blendOverlay(bottom, top) {
  return new ColorRGBA64(blendOverlayChannel(bottom.r, top.r), blendOverlayChannel(bottom.g, top.g), blendOverlayChannel(bottom.b, top.b), 1);
}
var ColorBlendMode;
var init_color_blending = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/color-blending.js"() {
    init_color_converters();
    init_color_lch();
    init_color_rgba_64();
    init_math_utilities();
    (function(ColorBlendMode2) {
      ColorBlendMode2[ColorBlendMode2["Burn"] = 0] = "Burn";
      ColorBlendMode2[ColorBlendMode2["Color"] = 1] = "Color";
      ColorBlendMode2[ColorBlendMode2["Darken"] = 2] = "Darken";
      ColorBlendMode2[ColorBlendMode2["Dodge"] = 3] = "Dodge";
      ColorBlendMode2[ColorBlendMode2["Lighten"] = 4] = "Lighten";
      ColorBlendMode2[ColorBlendMode2["Multiply"] = 5] = "Multiply";
      ColorBlendMode2[ColorBlendMode2["Overlay"] = 6] = "Overlay";
      ColorBlendMode2[ColorBlendMode2["Screen"] = 7] = "Screen";
    })(ColorBlendMode || (ColorBlendMode = {}));
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/color-interpolation.js
function interpolateRGB(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorRGBA64(lerp(position, left.r, right.r), lerp(position, left.g, right.g), lerp(position, left.b, right.b), lerp(position, left.a, right.a));
}
function interpolateHSL(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorHSL(lerpAnglesInDegrees(position, left.h, right.h), lerp(position, left.s, right.s), lerp(position, left.l, right.l));
}
function interpolateHSV(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorHSV(lerpAnglesInDegrees(position, left.h, right.h), lerp(position, left.s, right.s), lerp(position, left.v, right.v));
}
function interpolateXYZ(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorXYZ(lerp(position, left.x, right.x), lerp(position, left.y, right.y), lerp(position, left.z, right.z));
}
function interpolateLAB(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorLAB(lerp(position, left.l, right.l), lerp(position, left.a, right.a), lerp(position, left.b, right.b));
}
function interpolateLCH(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorLCH(lerp(position, left.l, right.l), lerp(position, left.c, right.c), lerpAnglesInDegrees(position, left.h, right.h));
}
function interpolateByColorSpace(position, space, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  switch (space) {
    case ColorInterpolationSpace.HSL:
      return hslToRGB(interpolateHSL(position, rgbToHSL(left), rgbToHSL(right)));
    case ColorInterpolationSpace.HSV:
      return hsvToRGB(interpolateHSV(position, rgbToHSV(left), rgbToHSV(right)));
    case ColorInterpolationSpace.XYZ:
      return xyzToRGB(interpolateXYZ(position, rgbToXYZ(left), rgbToXYZ(right)));
    case ColorInterpolationSpace.LAB:
      return labToRGB(interpolateLAB(position, rgbToLAB(left), rgbToLAB(right)));
    case ColorInterpolationSpace.LCH:
      return lchToRGB(interpolateLCH(position, rgbToLCH(left), rgbToLCH(right)));
    default:
      return interpolateRGB(position, left, right);
  }
}
var ColorInterpolationSpace;
var init_color_interpolation = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/color-interpolation.js"() {
    init_color_converters();
    init_color_hsl();
    init_color_hsv();
    init_color_lab();
    init_color_lch();
    init_color_rgba_64();
    init_color_xyz();
    init_math_utilities();
    (function(ColorInterpolationSpace2) {
      ColorInterpolationSpace2[ColorInterpolationSpace2["RGB"] = 0] = "RGB";
      ColorInterpolationSpace2[ColorInterpolationSpace2["HSL"] = 1] = "HSL";
      ColorInterpolationSpace2[ColorInterpolationSpace2["HSV"] = 2] = "HSV";
      ColorInterpolationSpace2[ColorInterpolationSpace2["XYZ"] = 3] = "XYZ";
      ColorInterpolationSpace2[ColorInterpolationSpace2["LAB"] = 4] = "LAB";
      ColorInterpolationSpace2[ColorInterpolationSpace2["LCH"] = 5] = "LCH";
    })(ColorInterpolationSpace || (ColorInterpolationSpace = {}));
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/color-scale.js
var ColorScale;
var init_color_scale = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/color-scale.js"() {
    init_color_converters();
    init_color_interpolation();
    ColorScale = class {
      constructor(stops) {
        if (stops == null || stops.length === 0) {
          throw new Error("The stops argument must be non-empty");
        } else {
          this.stops = this.sortColorScaleStops(stops);
        }
      }
      static createBalancedColorScale(colors) {
        if (colors == null || colors.length === 0) {
          throw new Error("The colors argument must be non-empty");
        }
        const stops = new Array(colors.length);
        for (let i = 0; i < colors.length; i++) {
          if (i === 0) {
            stops[i] = { color: colors[i], position: 0 };
          } else if (i === colors.length - 1) {
            stops[i] = { color: colors[i], position: 1 };
          } else {
            stops[i] = {
              color: colors[i],
              position: i * (1 / (colors.length - 1))
            };
          }
        }
        return new ColorScale(stops);
      }
      getColor(position, interpolationMode = ColorInterpolationSpace.RGB) {
        if (this.stops.length === 1) {
          return this.stops[0].color;
        } else if (position <= 0) {
          return this.stops[0].color;
        } else if (position >= 1) {
          return this.stops[this.stops.length - 1].color;
        }
        let lowerIndex = 0;
        for (let i = 0; i < this.stops.length; i++) {
          if (this.stops[i].position <= position) {
            lowerIndex = i;
          }
        }
        let upperIndex = lowerIndex + 1;
        if (upperIndex >= this.stops.length) {
          upperIndex = this.stops.length - 1;
        }
        const scalePosition = (position - this.stops[lowerIndex].position) * (1 / (this.stops[upperIndex].position - this.stops[lowerIndex].position));
        return interpolateByColorSpace(scalePosition, interpolationMode, this.stops[lowerIndex].color, this.stops[upperIndex].color);
      }
      trim(lowerBound, upperBound, interpolationMode = ColorInterpolationSpace.RGB) {
        if (lowerBound < 0 || upperBound > 1 || upperBound < lowerBound) {
          throw new Error("Invalid bounds");
        }
        if (lowerBound === upperBound) {
          return new ColorScale([
            { color: this.getColor(lowerBound, interpolationMode), position: 0 }
          ]);
        }
        const containedStops = [];
        for (let i = 0; i < this.stops.length; i++) {
          if (this.stops[i].position >= lowerBound && this.stops[i].position <= upperBound) {
            containedStops.push(this.stops[i]);
          }
        }
        if (containedStops.length === 0) {
          return new ColorScale([
            { color: this.getColor(lowerBound), position: lowerBound },
            { color: this.getColor(upperBound), position: upperBound }
          ]);
        }
        if (containedStops[0].position !== lowerBound) {
          containedStops.unshift({
            color: this.getColor(lowerBound),
            position: lowerBound
          });
        }
        if (containedStops[containedStops.length - 1].position !== upperBound) {
          containedStops.push({
            color: this.getColor(upperBound),
            position: upperBound
          });
        }
        const range2 = upperBound - lowerBound;
        const finalStops = new Array(containedStops.length);
        for (let i = 0; i < containedStops.length; i++) {
          finalStops[i] = {
            color: containedStops[i].color,
            position: (containedStops[i].position - lowerBound) / range2
          };
        }
        return new ColorScale(finalStops);
      }
      findNextColor(position, contrast2, searchDown = false, interpolationMode = ColorInterpolationSpace.RGB, contrastErrorMargin = 5e-3, maxSearchIterations = 32) {
        if (isNaN(position) || position <= 0) {
          position = 0;
        } else if (position >= 1) {
          position = 1;
        }
        const startingColor = this.getColor(position, interpolationMode);
        const finalPosition = searchDown ? 0 : 1;
        const finalColor = this.getColor(finalPosition, interpolationMode);
        const finalContrast = contrastRatio(startingColor, finalColor);
        if (finalContrast <= contrast2) {
          return finalPosition;
        }
        let testRangeMin = searchDown ? 0 : position;
        let testRangeMax = searchDown ? position : 0;
        let mid = finalPosition;
        let iterations = 0;
        while (iterations <= maxSearchIterations) {
          mid = Math.abs(testRangeMax - testRangeMin) / 2 + testRangeMin;
          const midColor = this.getColor(mid, interpolationMode);
          const midContrast = contrastRatio(startingColor, midColor);
          if (Math.abs(midContrast - contrast2) <= contrastErrorMargin) {
            return mid;
          } else if (midContrast > contrast2) {
            if (searchDown) {
              testRangeMin = mid;
            } else {
              testRangeMax = mid;
            }
          } else {
            if (searchDown) {
              testRangeMax = mid;
            } else {
              testRangeMin = mid;
            }
          }
          iterations++;
        }
        return mid;
      }
      clone() {
        const newStops = new Array(this.stops.length);
        for (let i = 0; i < newStops.length; i++) {
          newStops[i] = {
            color: this.stops[i].color,
            position: this.stops[i].position
          };
        }
        return new ColorScale(newStops);
      }
      sortColorScaleStops(stops) {
        return stops.sort((a, b) => {
          const A = a.position;
          const B = b.position;
          if (A < B) {
            return -1;
          } else if (A > B) {
            return 1;
          } else {
            return 0;
          }
        });
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/named-colors.js
var namedColorsConfigs;
var init_named_colors = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/named-colors.js"() {
    namedColorsConfigs = {
      aliceblue: {
        r: 0.941176,
        g: 0.972549,
        b: 1
      },
      antiquewhite: {
        r: 0.980392,
        g: 0.921569,
        b: 0.843137
      },
      aqua: {
        r: 0,
        g: 1,
        b: 1
      },
      aquamarine: {
        r: 0.498039,
        g: 1,
        b: 0.831373
      },
      azure: {
        r: 0.941176,
        g: 1,
        b: 1
      },
      beige: {
        r: 0.960784,
        g: 0.960784,
        b: 0.862745
      },
      bisque: {
        r: 1,
        g: 0.894118,
        b: 0.768627
      },
      black: {
        r: 0,
        g: 0,
        b: 0
      },
      blanchedalmond: {
        r: 1,
        g: 0.921569,
        b: 0.803922
      },
      blue: {
        r: 0,
        g: 0,
        b: 1
      },
      blueviolet: {
        r: 0.541176,
        g: 0.168627,
        b: 0.886275
      },
      brown: {
        r: 0.647059,
        g: 0.164706,
        b: 0.164706
      },
      burlywood: {
        r: 0.870588,
        g: 0.721569,
        b: 0.529412
      },
      cadetblue: {
        r: 0.372549,
        g: 0.619608,
        b: 0.627451
      },
      chartreuse: {
        r: 0.498039,
        g: 1,
        b: 0
      },
      chocolate: {
        r: 0.823529,
        g: 0.411765,
        b: 0.117647
      },
      coral: {
        r: 1,
        g: 0.498039,
        b: 0.313725
      },
      cornflowerblue: {
        r: 0.392157,
        g: 0.584314,
        b: 0.929412
      },
      cornsilk: {
        r: 1,
        g: 0.972549,
        b: 0.862745
      },
      crimson: {
        r: 0.862745,
        g: 0.078431,
        b: 0.235294
      },
      cyan: {
        r: 0,
        g: 1,
        b: 1
      },
      darkblue: {
        r: 0,
        g: 0,
        b: 0.545098
      },
      darkcyan: {
        r: 0,
        g: 0.545098,
        b: 0.545098
      },
      darkgoldenrod: {
        r: 0.721569,
        g: 0.52549,
        b: 0.043137
      },
      darkgray: {
        r: 0.662745,
        g: 0.662745,
        b: 0.662745
      },
      darkgreen: {
        r: 0,
        g: 0.392157,
        b: 0
      },
      darkgrey: {
        r: 0.662745,
        g: 0.662745,
        b: 0.662745
      },
      darkkhaki: {
        r: 0.741176,
        g: 0.717647,
        b: 0.419608
      },
      darkmagenta: {
        r: 0.545098,
        g: 0,
        b: 0.545098
      },
      darkolivegreen: {
        r: 0.333333,
        g: 0.419608,
        b: 0.184314
      },
      darkorange: {
        r: 1,
        g: 0.54902,
        b: 0
      },
      darkorchid: {
        r: 0.6,
        g: 0.196078,
        b: 0.8
      },
      darkred: {
        r: 0.545098,
        g: 0,
        b: 0
      },
      darksalmon: {
        r: 0.913725,
        g: 0.588235,
        b: 0.478431
      },
      darkseagreen: {
        r: 0.560784,
        g: 0.737255,
        b: 0.560784
      },
      darkslateblue: {
        r: 0.282353,
        g: 0.239216,
        b: 0.545098
      },
      darkslategray: {
        r: 0.184314,
        g: 0.309804,
        b: 0.309804
      },
      darkslategrey: {
        r: 0.184314,
        g: 0.309804,
        b: 0.309804
      },
      darkturquoise: {
        r: 0,
        g: 0.807843,
        b: 0.819608
      },
      darkviolet: {
        r: 0.580392,
        g: 0,
        b: 0.827451
      },
      deeppink: {
        r: 1,
        g: 0.078431,
        b: 0.576471
      },
      deepskyblue: {
        r: 0,
        g: 0.74902,
        b: 1
      },
      dimgray: {
        r: 0.411765,
        g: 0.411765,
        b: 0.411765
      },
      dimgrey: {
        r: 0.411765,
        g: 0.411765,
        b: 0.411765
      },
      dodgerblue: {
        r: 0.117647,
        g: 0.564706,
        b: 1
      },
      firebrick: {
        r: 0.698039,
        g: 0.133333,
        b: 0.133333
      },
      floralwhite: {
        r: 1,
        g: 0.980392,
        b: 0.941176
      },
      forestgreen: {
        r: 0.133333,
        g: 0.545098,
        b: 0.133333
      },
      fuchsia: {
        r: 1,
        g: 0,
        b: 1
      },
      gainsboro: {
        r: 0.862745,
        g: 0.862745,
        b: 0.862745
      },
      ghostwhite: {
        r: 0.972549,
        g: 0.972549,
        b: 1
      },
      gold: {
        r: 1,
        g: 0.843137,
        b: 0
      },
      goldenrod: {
        r: 0.854902,
        g: 0.647059,
        b: 0.12549
      },
      gray: {
        r: 0.501961,
        g: 0.501961,
        b: 0.501961
      },
      green: {
        r: 0,
        g: 0.501961,
        b: 0
      },
      greenyellow: {
        r: 0.678431,
        g: 1,
        b: 0.184314
      },
      grey: {
        r: 0.501961,
        g: 0.501961,
        b: 0.501961
      },
      honeydew: {
        r: 0.941176,
        g: 1,
        b: 0.941176
      },
      hotpink: {
        r: 1,
        g: 0.411765,
        b: 0.705882
      },
      indianred: {
        r: 0.803922,
        g: 0.360784,
        b: 0.360784
      },
      indigo: {
        r: 0.294118,
        g: 0,
        b: 0.509804
      },
      ivory: {
        r: 1,
        g: 1,
        b: 0.941176
      },
      khaki: {
        r: 0.941176,
        g: 0.901961,
        b: 0.54902
      },
      lavender: {
        r: 0.901961,
        g: 0.901961,
        b: 0.980392
      },
      lavenderblush: {
        r: 1,
        g: 0.941176,
        b: 0.960784
      },
      lawngreen: {
        r: 0.486275,
        g: 0.988235,
        b: 0
      },
      lemonchiffon: {
        r: 1,
        g: 0.980392,
        b: 0.803922
      },
      lightblue: {
        r: 0.678431,
        g: 0.847059,
        b: 0.901961
      },
      lightcoral: {
        r: 0.941176,
        g: 0.501961,
        b: 0.501961
      },
      lightcyan: {
        r: 0.878431,
        g: 1,
        b: 1
      },
      lightgoldenrodyellow: {
        r: 0.980392,
        g: 0.980392,
        b: 0.823529
      },
      lightgray: {
        r: 0.827451,
        g: 0.827451,
        b: 0.827451
      },
      lightgreen: {
        r: 0.564706,
        g: 0.933333,
        b: 0.564706
      },
      lightgrey: {
        r: 0.827451,
        g: 0.827451,
        b: 0.827451
      },
      lightpink: {
        r: 1,
        g: 0.713725,
        b: 0.756863
      },
      lightsalmon: {
        r: 1,
        g: 0.627451,
        b: 0.478431
      },
      lightseagreen: {
        r: 0.12549,
        g: 0.698039,
        b: 0.666667
      },
      lightskyblue: {
        r: 0.529412,
        g: 0.807843,
        b: 0.980392
      },
      lightslategray: {
        r: 0.466667,
        g: 0.533333,
        b: 0.6
      },
      lightslategrey: {
        r: 0.466667,
        g: 0.533333,
        b: 0.6
      },
      lightsteelblue: {
        r: 0.690196,
        g: 0.768627,
        b: 0.870588
      },
      lightyellow: {
        r: 1,
        g: 1,
        b: 0.878431
      },
      lime: {
        r: 0,
        g: 1,
        b: 0
      },
      limegreen: {
        r: 0.196078,
        g: 0.803922,
        b: 0.196078
      },
      linen: {
        r: 0.980392,
        g: 0.941176,
        b: 0.901961
      },
      magenta: {
        r: 1,
        g: 0,
        b: 1
      },
      maroon: {
        r: 0.501961,
        g: 0,
        b: 0
      },
      mediumaquamarine: {
        r: 0.4,
        g: 0.803922,
        b: 0.666667
      },
      mediumblue: {
        r: 0,
        g: 0,
        b: 0.803922
      },
      mediumorchid: {
        r: 0.729412,
        g: 0.333333,
        b: 0.827451
      },
      mediumpurple: {
        r: 0.576471,
        g: 0.439216,
        b: 0.858824
      },
      mediumseagreen: {
        r: 0.235294,
        g: 0.701961,
        b: 0.443137
      },
      mediumslateblue: {
        r: 0.482353,
        g: 0.407843,
        b: 0.933333
      },
      mediumspringgreen: {
        r: 0,
        g: 0.980392,
        b: 0.603922
      },
      mediumturquoise: {
        r: 0.282353,
        g: 0.819608,
        b: 0.8
      },
      mediumvioletred: {
        r: 0.780392,
        g: 0.082353,
        b: 0.521569
      },
      midnightblue: {
        r: 0.098039,
        g: 0.098039,
        b: 0.439216
      },
      mintcream: {
        r: 0.960784,
        g: 1,
        b: 0.980392
      },
      mistyrose: {
        r: 1,
        g: 0.894118,
        b: 0.882353
      },
      moccasin: {
        r: 1,
        g: 0.894118,
        b: 0.709804
      },
      navajowhite: {
        r: 1,
        g: 0.870588,
        b: 0.678431
      },
      navy: {
        r: 0,
        g: 0,
        b: 0.501961
      },
      oldlace: {
        r: 0.992157,
        g: 0.960784,
        b: 0.901961
      },
      olive: {
        r: 0.501961,
        g: 0.501961,
        b: 0
      },
      olivedrab: {
        r: 0.419608,
        g: 0.556863,
        b: 0.137255
      },
      orange: {
        r: 1,
        g: 0.647059,
        b: 0
      },
      orangered: {
        r: 1,
        g: 0.270588,
        b: 0
      },
      orchid: {
        r: 0.854902,
        g: 0.439216,
        b: 0.839216
      },
      palegoldenrod: {
        r: 0.933333,
        g: 0.909804,
        b: 0.666667
      },
      palegreen: {
        r: 0.596078,
        g: 0.984314,
        b: 0.596078
      },
      paleturquoise: {
        r: 0.686275,
        g: 0.933333,
        b: 0.933333
      },
      palevioletred: {
        r: 0.858824,
        g: 0.439216,
        b: 0.576471
      },
      papayawhip: {
        r: 1,
        g: 0.937255,
        b: 0.835294
      },
      peachpuff: {
        r: 1,
        g: 0.854902,
        b: 0.72549
      },
      peru: {
        r: 0.803922,
        g: 0.521569,
        b: 0.247059
      },
      pink: {
        r: 1,
        g: 0.752941,
        b: 0.796078
      },
      plum: {
        r: 0.866667,
        g: 0.627451,
        b: 0.866667
      },
      powderblue: {
        r: 0.690196,
        g: 0.878431,
        b: 0.901961
      },
      purple: {
        r: 0.501961,
        g: 0,
        b: 0.501961
      },
      red: {
        r: 1,
        g: 0,
        b: 0
      },
      rosybrown: {
        r: 0.737255,
        g: 0.560784,
        b: 0.560784
      },
      royalblue: {
        r: 0.254902,
        g: 0.411765,
        b: 0.882353
      },
      saddlebrown: {
        r: 0.545098,
        g: 0.270588,
        b: 0.07451
      },
      salmon: {
        r: 0.980392,
        g: 0.501961,
        b: 0.447059
      },
      sandybrown: {
        r: 0.956863,
        g: 0.643137,
        b: 0.376471
      },
      seagreen: {
        r: 0.180392,
        g: 0.545098,
        b: 0.341176
      },
      seashell: {
        r: 1,
        g: 0.960784,
        b: 0.933333
      },
      sienna: {
        r: 0.627451,
        g: 0.321569,
        b: 0.176471
      },
      silver: {
        r: 0.752941,
        g: 0.752941,
        b: 0.752941
      },
      skyblue: {
        r: 0.529412,
        g: 0.807843,
        b: 0.921569
      },
      slateblue: {
        r: 0.415686,
        g: 0.352941,
        b: 0.803922
      },
      slategray: {
        r: 0.439216,
        g: 0.501961,
        b: 0.564706
      },
      slategrey: {
        r: 0.439216,
        g: 0.501961,
        b: 0.564706
      },
      snow: {
        r: 1,
        g: 0.980392,
        b: 0.980392
      },
      springgreen: {
        r: 0,
        g: 1,
        b: 0.498039
      },
      steelblue: {
        r: 0.27451,
        g: 0.509804,
        b: 0.705882
      },
      tan: {
        r: 0.823529,
        g: 0.705882,
        b: 0.54902
      },
      teal: {
        r: 0,
        g: 0.501961,
        b: 0.501961
      },
      thistle: {
        r: 0.847059,
        g: 0.74902,
        b: 0.847059
      },
      tomato: {
        r: 1,
        g: 0.388235,
        b: 0.278431
      },
      transparent: {
        r: 0,
        g: 0,
        b: 0,
        a: 0
      },
      turquoise: {
        r: 0.25098,
        g: 0.878431,
        b: 0.815686
      },
      violet: {
        r: 0.933333,
        g: 0.509804,
        b: 0.933333
      },
      wheat: {
        r: 0.960784,
        g: 0.870588,
        b: 0.701961
      },
      white: {
        r: 1,
        g: 1,
        b: 1
      },
      whitesmoke: {
        r: 0.960784,
        g: 0.960784,
        b: 0.960784
      },
      yellow: {
        r: 1,
        g: 1,
        b: 0
      },
      yellowgreen: {
        r: 0.603922,
        g: 0.803922,
        b: 0.196078
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/parse-color.js
function isColorStringHexRGB(raw) {
  return hexRGBRegex.test(raw);
}
function isColorStringHexARGB(raw) {
  return hexRGBARegex.test(raw);
}
function isColorStringHexRGBA(raw) {
  return isColorStringHexARGB(raw);
}
function isColorStringWebRGB(raw) {
  return webRGBRegex.test(raw);
}
function isColorStringWebRGBA(raw) {
  return webRGBARegex.test(raw);
}
function isColorNamed(raw) {
  return namedColorsConfigs.hasOwnProperty(raw);
}
function parseColorHexRGB(raw) {
  const result = hexRGBRegex.exec(raw);
  if (result === null) {
    return null;
  }
  let digits = result[1];
  if (digits.length === 3) {
    const r = digits.charAt(0);
    const g = digits.charAt(1);
    const b = digits.charAt(2);
    digits = r.concat(r, g, g, b, b);
  }
  const rawInt = parseInt(digits, 16);
  if (isNaN(rawInt)) {
    return null;
  }
  return new ColorRGBA64(normalize((rawInt & 16711680) >>> 16, 0, 255), normalize((rawInt & 65280) >>> 8, 0, 255), normalize(rawInt & 255, 0, 255), 1);
}
function parseColorHexARGB(raw) {
  const result = hexRGBARegex.exec(raw);
  if (result === null) {
    return null;
  }
  let digits = result[1];
  if (digits.length === 4) {
    const a = digits.charAt(0);
    const r = digits.charAt(1);
    const g = digits.charAt(2);
    const b = digits.charAt(3);
    digits = a.concat(a, r, r, g, g, b, b);
  }
  const rawInt = parseInt(digits, 16);
  if (isNaN(rawInt)) {
    return null;
  }
  return new ColorRGBA64(normalize((rawInt & 16711680) >>> 16, 0, 255), normalize((rawInt & 65280) >>> 8, 0, 255), normalize(rawInt & 255, 0, 255), normalize((rawInt & 4278190080) >>> 24, 0, 255));
}
function parseColorWebRGB(raw) {
  const result = webRGBRegex.exec(raw);
  if (result === null) {
    return null;
  }
  const split = result[1].split(",");
  return new ColorRGBA64(normalize(Number(split[0]), 0, 255), normalize(Number(split[1]), 0, 255), normalize(Number(split[2]), 0, 255), 1);
}
function parseColorWebRGBA(raw) {
  const result = webRGBARegex.exec(raw);
  if (result === null) {
    return null;
  }
  const split = result[1].split(",");
  if (split.length === 4) {
    return new ColorRGBA64(normalize(Number(split[0]), 0, 255), normalize(Number(split[1]), 0, 255), normalize(Number(split[2]), 0, 255), Number(split[3]));
  }
  return null;
}
function parseColorNamed(raw) {
  const config = namedColorsConfigs[raw.toLowerCase()];
  return config ? new ColorRGBA64(config.r, config.g, config.b, config.hasOwnProperty("a") ? config.a : void 0) : null;
}
function parseColor(raw) {
  const rawLower = raw.toLowerCase();
  return isColorStringHexRGB(rawLower) ? parseColorHexRGB(rawLower) : isColorStringHexRGBA(rawLower) ? parseColorHexARGB(rawLower) : isColorStringWebRGB(rawLower) ? parseColorWebRGB(rawLower) : isColorStringWebRGBA(rawLower) ? parseColorWebRGBA(rawLower) : isColorNamed(rawLower) ? parseColorNamed(rawLower) : null;
}
var webRGBRegex, webRGBARegex, hexRGBRegex, hexRGBARegex;
var init_parse_color = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/parse-color.js"() {
    init_color_rgba_64();
    init_math_utilities();
    init_named_colors();
    webRGBRegex = /^rgb\(\s*((?:(?:25[0-5]|2[0-4]\d|1\d\d|\d{1,2})\s*,\s*){2}(?:25[0-5]|2[0-4]\d|1\d\d|\d{1,2})\s*)\)$/i;
    webRGBARegex = /^rgba\(\s*((?:(?:25[0-5]|2[0-4]\d|1\d\d|\d{1,2})\s*,\s*){3}(?:0|1|0?\.\d*)\s*)\)$/i;
    hexRGBRegex = /^#((?:[0-9a-f]{6}|[0-9a-f]{3}))$/i;
    hexRGBARegex = /^#((?:[0-9a-f]{8}|[0-9a-f]{4}))$/i;
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/color-palette.js
var ColorPalette, defaultCenteredRescaleConfig;
var init_color_palette = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/color-palette.js"() {
    init_color_blending();
    init_color_converters();
    init_color_interpolation();
    init_color_rgba_64();
    init_color_scale();
    init_parse_color();
    ColorPalette = class {
      constructor(config) {
        this.config = Object.assign({}, ColorPalette.defaultPaletteConfig, config);
        this.palette = [];
        this.updatePaletteColors();
      }
      updatePaletteGenerationValues(newConfig) {
        let changed = false;
        for (const key2 in newConfig) {
          if (this.config[key2]) {
            if (this.config[key2].equalValue) {
              if (!this.config[key2].equalValue(newConfig[key2])) {
                this.config[key2] = newConfig[key2];
                changed = true;
              }
            } else {
              if (newConfig[key2] !== this.config[key2]) {
                this.config[key2] = newConfig[key2];
                changed = true;
              }
            }
          }
        }
        if (changed) {
          this.updatePaletteColors();
        }
        return changed;
      }
      updatePaletteColors() {
        const scale = this.generatePaletteColorScale();
        for (let i = 0; i < this.config.steps; i++) {
          this.palette[i] = scale.getColor(i / (this.config.steps - 1), this.config.interpolationMode);
        }
      }
      generatePaletteColorScale() {
        const baseColorHSL = rgbToHSL(this.config.baseColor);
        const baseScale = new ColorScale([
          { position: 0, color: this.config.scaleColorLight },
          { position: 0.5, color: this.config.baseColor },
          { position: 1, color: this.config.scaleColorDark }
        ]);
        const trimmedScale = baseScale.trim(this.config.clipLight, 1 - this.config.clipDark);
        const trimmedLight = trimmedScale.getColor(0);
        const trimmedDark = trimmedScale.getColor(1);
        let adjustedLight = trimmedLight;
        let adjustedDark = trimmedDark;
        if (baseColorHSL.s >= this.config.saturationAdjustmentCutoff) {
          adjustedLight = saturateViaLCH(adjustedLight, this.config.saturationLight);
          adjustedDark = saturateViaLCH(adjustedDark, this.config.saturationDark);
        }
        if (this.config.multiplyLight !== 0) {
          const multiply = blendMultiply(this.config.baseColor, adjustedLight);
          adjustedLight = interpolateByColorSpace(this.config.multiplyLight, this.config.interpolationMode, adjustedLight, multiply);
        }
        if (this.config.multiplyDark !== 0) {
          const multiply = blendMultiply(this.config.baseColor, adjustedDark);
          adjustedDark = interpolateByColorSpace(this.config.multiplyDark, this.config.interpolationMode, adjustedDark, multiply);
        }
        if (this.config.overlayLight !== 0) {
          const overlay = blendOverlay(this.config.baseColor, adjustedLight);
          adjustedLight = interpolateByColorSpace(this.config.overlayLight, this.config.interpolationMode, adjustedLight, overlay);
        }
        if (this.config.overlayDark !== 0) {
          const overlay = blendOverlay(this.config.baseColor, adjustedDark);
          adjustedDark = interpolateByColorSpace(this.config.overlayDark, this.config.interpolationMode, adjustedDark, overlay);
        }
        if (this.config.baseScalePosition) {
          if (this.config.baseScalePosition <= 0) {
            return new ColorScale([
              { position: 0, color: this.config.baseColor },
              { position: 1, color: adjustedDark.clamp() }
            ]);
          } else if (this.config.baseScalePosition >= 1) {
            return new ColorScale([
              { position: 0, color: adjustedLight.clamp() },
              { position: 1, color: this.config.baseColor }
            ]);
          }
          return new ColorScale([
            { position: 0, color: adjustedLight.clamp() },
            {
              position: this.config.baseScalePosition,
              color: this.config.baseColor
            },
            { position: 1, color: adjustedDark.clamp() }
          ]);
        }
        return new ColorScale([
          { position: 0, color: adjustedLight.clamp() },
          { position: 0.5, color: this.config.baseColor },
          { position: 1, color: adjustedDark.clamp() }
        ]);
      }
    };
    ColorPalette.defaultPaletteConfig = {
      baseColor: parseColorHexRGB("#808080"),
      steps: 11,
      interpolationMode: ColorInterpolationSpace.RGB,
      scaleColorLight: new ColorRGBA64(1, 1, 1, 1),
      scaleColorDark: new ColorRGBA64(0, 0, 0, 1),
      clipLight: 0.185,
      clipDark: 0.16,
      saturationAdjustmentCutoff: 0.05,
      saturationLight: 0.35,
      saturationDark: 1.25,
      overlayLight: 0,
      overlayDark: 0.25,
      multiplyLight: 0,
      multiplyDark: 0,
      baseScalePosition: 0.5
    };
    ColorPalette.greyscalePaletteConfig = {
      baseColor: parseColorHexRGB("#808080"),
      steps: 11,
      interpolationMode: ColorInterpolationSpace.RGB,
      scaleColorLight: new ColorRGBA64(1, 1, 1, 1),
      scaleColorDark: new ColorRGBA64(0, 0, 0, 1),
      clipLight: 0,
      clipDark: 0,
      saturationAdjustmentCutoff: 0,
      saturationLight: 0,
      saturationDark: 0,
      overlayLight: 0,
      overlayDark: 0,
      multiplyLight: 0,
      multiplyDark: 0,
      baseScalePosition: 0.5
    };
    defaultCenteredRescaleConfig = {
      targetSize: 63,
      spacing: 4,
      scaleColorLight: ColorPalette.defaultPaletteConfig.scaleColorLight,
      scaleColorDark: ColorPalette.defaultPaletteConfig.scaleColorDark
    };
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/histogram.js
var init_histogram = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/histogram.js"() {
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/pixel-box.js
var init_pixel_box = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/pixel-box.js"() {
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/color-quantization.js
var init_color_quantization = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/color-quantization.js"() {
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/component-state-color-palette.js
var ComponentStateColorPalette;
var init_component_state_color_palette = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/component-state-color-palette.js"() {
    init_color_rgba_64();
    init_color_palette();
    init_color_converters();
    init_color_scale();
    init_color_hsl();
    init_color_interpolation();
    init_parse_color();
    ComponentStateColorPalette = class {
      constructor(config) {
        this.palette = [];
        this.config = Object.assign({}, ComponentStateColorPalette.defaultPaletteConfig, config);
        this.regenPalettes();
      }
      regenPalettes() {
        let steps = this.config.steps;
        if (isNaN(steps) || steps < 3) {
          steps = 3;
        }
        const darkLum = 0.14;
        const darkestLum = 0.06;
        const darkLumColor = new ColorRGBA64(darkLum, darkLum, darkLum, 1);
        const stepsForLuminanceRamp = 94;
        const r = new ColorPalette(Object.assign(Object.assign({}, ColorPalette.greyscalePaletteConfig), { baseColor: darkLumColor, baseScalePosition: (1 - darkLum) * 100 / stepsForLuminanceRamp, steps }));
        const referencePalette = r.palette;
        const baseColorLum1 = rgbToLinearLuminance(this.config.baseColor);
        const baseColorLum2 = rgbToHSL(this.config.baseColor).l;
        const baseColorLum = (baseColorLum1 + baseColorLum2) / 2;
        const baseColorRefIndex = this.matchRelativeLuminanceIndex(baseColorLum, referencePalette);
        const baseColorPercent = baseColorRefIndex / (steps - 1);
        const darkRefIndex = this.matchRelativeLuminanceIndex(darkLum, referencePalette);
        const darkPercent = darkRefIndex / (steps - 1);
        const baseColorHSL = rgbToHSL(this.config.baseColor);
        const darkBaseColor = hslToRGB(ColorHSL.fromObject({
          h: baseColorHSL.h,
          s: baseColorHSL.s,
          l: darkLum
        }));
        const darkestBaseColor = hslToRGB(ColorHSL.fromObject({
          h: baseColorHSL.h,
          s: baseColorHSL.s,
          l: darkestLum
        }));
        const fullColorScaleStops = new Array(5);
        fullColorScaleStops[0] = {
          position: 0,
          color: new ColorRGBA64(1, 1, 1, 1)
        };
        fullColorScaleStops[1] = {
          position: baseColorPercent,
          color: this.config.baseColor
        };
        fullColorScaleStops[2] = {
          position: darkPercent,
          color: darkBaseColor
        };
        fullColorScaleStops[3] = {
          position: 0.99,
          color: darkestBaseColor
        };
        fullColorScaleStops[4] = {
          position: 1,
          color: new ColorRGBA64(0, 0, 0, 1)
        };
        const scale = new ColorScale(fullColorScaleStops);
        this.palette = new Array(steps);
        for (let i = 0; i < steps; i++) {
          const c = scale.getColor(i / (steps - 1), ColorInterpolationSpace.RGB);
          this.palette[i] = c;
        }
      }
      matchRelativeLuminanceIndex(input, reference) {
        let bestFitValue = Number.MAX_VALUE;
        let bestFitIndex = 0;
        let i = 0;
        const referenceLength = reference.length;
        for (; i < referenceLength; i++) {
          const fitValue = Math.abs(rgbToLinearLuminance(reference[i]) - input);
          if (fitValue < bestFitValue) {
            bestFitValue = fitValue;
            bestFitIndex = i;
          }
        }
        return bestFitIndex;
      }
    };
    ComponentStateColorPalette.defaultPaletteConfig = {
      baseColor: parseColorHexRGB("#808080"),
      steps: 94
    };
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/palette-extractor.js
var init_palette_extractor = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/palette-extractor.js"() {
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/pixel-blob.js
var init_pixel_blob = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/pixel-blob.js"() {
  }
});

// ../../node_modules/@microsoft/fast-colors/dist/index.js
var init_dist2 = __esm({
  "../../node_modules/@microsoft/fast-colors/dist/index.js"() {
    init_color_blending();
    init_color_converters();
    init_color_hsl();
    init_color_hsv();
    init_color_interpolation();
    init_color_lab();
    init_color_lch();
    init_color_palette();
    init_color_quantization();
    init_color_rgba_64();
    init_color_scale();
    init_color_xyz();
    init_component_state_color_palette();
    init_histogram();
    init_math_utilities();
    init_palette_extractor();
    init_parse_color();
    init_pixel_blob();
    init_pixel_box();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/utilities/relative-luminance.js
function contrast(a, b) {
  const L1 = a.relativeLuminance > b.relativeLuminance ? a : b;
  const L2 = a.relativeLuminance > b.relativeLuminance ? b : a;
  return (L1.relativeLuminance + 0.05) / (L2.relativeLuminance + 0.05);
}
var init_relative_luminance = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/utilities/relative-luminance.js"() {
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/swatch.js
function isSwatchRGB(value) {
  const test = {
    r: 0,
    g: 0,
    b: 0,
    toColorString: () => "",
    contrast: () => 0,
    relativeLuminance: 0
  };
  for (const key2 in test) {
    if (typeof test[key2] !== typeof value[key2]) {
      return false;
    }
  }
  return true;
}
var SwatchRGB, SwatchRGBImpl;
var init_swatch = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/swatch.js"() {
    init_dist2();
    init_relative_luminance();
    SwatchRGB = Object.freeze({
      create(r, g, b) {
        return new SwatchRGBImpl(r, g, b);
      },
      from(obj) {
        return new SwatchRGBImpl(obj.r, obj.g, obj.b);
      }
    });
    SwatchRGBImpl = class extends ColorRGBA64 {
      /**
       *
       * @param red - Red channel expressed as a number between 0 and 1
       * @param green - Green channel expressed as a number between 0 and 1
       * @param blue - Blue channel expressed as a number between 0 and 1
       */
      constructor(red, green, blue) {
        super(red, green, blue, 1);
        this.toColorString = this.toStringHexRGB;
        this.contrast = contrast.bind(null, this);
        this.createCSS = this.toColorString;
        this.relativeLuminance = rgbToRelativeLuminance(this);
      }
      static fromObject(obj) {
        return new SwatchRGBImpl(obj.r, obj.g, obj.b);
      }
    };
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/utilities/base-layer-luminance.js
function baseLayerLuminanceSwatch(luminance) {
  return SwatchRGB.create(luminance, luminance, luminance);
}
var StandardLuminance;
var init_base_layer_luminance = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/utilities/base-layer-luminance.js"() {
    init_swatch();
    StandardLuminance = {
      LightMode: 1,
      DarkMode: 0.23
    };
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/utilities/is-dark.js
function isDark(color) {
  return color.relativeLuminance <= target;
}
var target;
var init_is_dark = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/utilities/is-dark.js"() {
    target = (-0.1 + Math.sqrt(0.21)) / 2;
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/platform.js
function createMetadataLocator() {
  const metadataLookup = /* @__PURE__ */ new WeakMap();
  return function(target2) {
    let metadata = metadataLookup.get(target2);
    if (metadata === void 0) {
      let currentTarget = Reflect.getPrototypeOf(target2);
      while (metadata === void 0 && currentTarget !== null) {
        metadata = metadataLookup.get(currentTarget);
        currentTarget = Reflect.getPrototypeOf(currentTarget);
      }
      metadata = metadata === void 0 ? [] : metadata.slice(0);
      metadataLookup.set(target2, metadata);
    }
    return metadata;
  };
}
var $global, propConfig, FAST, emptyArray;
var init_platform = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/platform.js"() {
    $global = function() {
      if (typeof globalThis !== "undefined") {
        return globalThis;
      }
      if (typeof globalThis !== "undefined") {
        return globalThis;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      try {
        return new Function("return this")();
      } catch (_a) {
        return {};
      }
    }();
    if ($global.trustedTypes === void 0) {
      $global.trustedTypes = { createPolicy: (n, r) => r };
    }
    propConfig = {
      configurable: false,
      enumerable: false,
      writable: false
    };
    if ($global.FAST === void 0) {
      Reflect.defineProperty($global, "FAST", Object.assign({ value: /* @__PURE__ */ Object.create(null) }, propConfig));
    }
    FAST = $global.FAST;
    if (FAST.getById === void 0) {
      const storage = /* @__PURE__ */ Object.create(null);
      Reflect.defineProperty(FAST, "getById", Object.assign({ value(id, initialize) {
        let found2 = storage[id];
        if (found2 === void 0) {
          found2 = initialize ? storage[id] = initialize() : null;
        }
        return found2;
      } }, propConfig));
    }
    emptyArray = Object.freeze([]);
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/dom.js
var updateQueue, fastHTMLPolicy, htmlPolicy, marker, _interpolationStart, _interpolationEnd, DOM;
var init_dom = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/dom.js"() {
    init_platform();
    updateQueue = $global.FAST.getById(1, () => {
      const tasks = [];
      const pendingErrors = [];
      function throwFirstError() {
        if (pendingErrors.length) {
          throw pendingErrors.shift();
        }
      }
      function tryRunTask(task) {
        try {
          task.call();
        } catch (error) {
          pendingErrors.push(error);
          setTimeout(throwFirstError, 0);
        }
      }
      function process2() {
        const capacity = 1024;
        let index = 0;
        while (index < tasks.length) {
          tryRunTask(tasks[index]);
          index++;
          if (index > capacity) {
            for (let scan = 0, newLength = tasks.length - index; scan < newLength; scan++) {
              tasks[scan] = tasks[scan + index];
            }
            tasks.length -= index;
            index = 0;
          }
        }
        tasks.length = 0;
      }
      function enqueue(callable) {
        if (tasks.length < 1) {
          $global.requestAnimationFrame(process2);
        }
        tasks.push(callable);
      }
      return Object.freeze({
        enqueue,
        process: process2
      });
    });
    fastHTMLPolicy = $global.trustedTypes.createPolicy("fast-html", {
      createHTML: (html2) => html2
    });
    htmlPolicy = fastHTMLPolicy;
    marker = `fast-${Math.random().toString(36).substring(2, 8)}`;
    _interpolationStart = `${marker}{`;
    _interpolationEnd = `}${marker}`;
    DOM = Object.freeze({
      /**
       * Indicates whether the DOM supports the adoptedStyleSheets feature.
       */
      supportsAdoptedStyleSheets: Array.isArray(document.adoptedStyleSheets) && "replace" in CSSStyleSheet.prototype,
      /**
       * Sets the HTML trusted types policy used by the templating engine.
       * @param policy - The policy to set for HTML.
       * @remarks
       * This API can only be called once, for security reasons. It should be
       * called by the application developer at the start of their program.
       */
      setHTMLPolicy(policy) {
        if (htmlPolicy !== fastHTMLPolicy) {
          throw new Error("The HTML policy can only be set once.");
        }
        htmlPolicy = policy;
      },
      /**
       * Turns a string into trusted HTML using the configured trusted types policy.
       * @param html - The string to turn into trusted HTML.
       * @remarks
       * Used internally by the template engine when creating templates
       * and setting innerHTML.
       */
      createHTML(html2) {
        return htmlPolicy.createHTML(html2);
      },
      /**
       * Determines if the provided node is a template marker used by the runtime.
       * @param node - The node to test.
       */
      isMarker(node) {
        return node && node.nodeType === 8 && node.data.startsWith(marker);
      },
      /**
       * Given a marker node, extract the {@link HTMLDirective} index from the placeholder.
       * @param node - The marker node to extract the index from.
       */
      extractDirectiveIndexFromMarker(node) {
        return parseInt(node.data.replace(`${marker}:`, ""));
      },
      /**
       * Creates a placeholder string suitable for marking out a location *within*
       * an attribute value or HTML content.
       * @param index - The directive index to create the placeholder for.
       * @remarks
       * Used internally by binding directives.
       */
      createInterpolationPlaceholder(index) {
        return `${_interpolationStart}${index}${_interpolationEnd}`;
      },
      /**
       * Creates a placeholder that manifests itself as an attribute on an
       * element.
       * @param attributeName - The name of the custom attribute.
       * @param index - The directive index to create the placeholder for.
       * @remarks
       * Used internally by attribute directives such as `ref`, `slotted`, and `children`.
       */
      createCustomAttributePlaceholder(attributeName, index) {
        return `${attributeName}="${this.createInterpolationPlaceholder(index)}"`;
      },
      /**
       * Creates a placeholder that manifests itself as a marker within the DOM structure.
       * @param index - The directive index to create the placeholder for.
       * @remarks
       * Used internally by structural directives such as `repeat`.
       */
      createBlockPlaceholder(index) {
        return `<!--${marker}:${index}-->`;
      },
      /**
       * Schedules DOM update work in the next async batch.
       * @param callable - The callable function or object to queue.
       */
      queueUpdate: updateQueue.enqueue,
      /**
       * Immediately processes all work previously scheduled
       * through queueUpdate.
       * @remarks
       * This also forces nextUpdate promises
       * to resolve.
       */
      processUpdates: updateQueue.process,
      /**
       * Resolves with the next DOM update.
       */
      nextUpdate() {
        return new Promise(updateQueue.enqueue);
      },
      /**
       * Sets an attribute value on an element.
       * @param element - The element to set the attribute value on.
       * @param attributeName - The attribute name to set.
       * @param value - The value of the attribute to set.
       * @remarks
       * If the value is `null` or `undefined`, the attribute is removed, otherwise
       * it is set to the provided value using the standard `setAttribute` API.
       */
      setAttribute(element, attributeName, value) {
        if (value === null || value === void 0) {
          element.removeAttribute(attributeName);
        } else {
          element.setAttribute(attributeName, value);
        }
      },
      /**
       * Sets a boolean attribute value.
       * @param element - The element to set the boolean attribute value on.
       * @param attributeName - The attribute name to set.
       * @param value - The value of the attribute to set.
       * @remarks
       * If the value is true, the attribute is added; otherwise it is removed.
       */
      setBooleanAttribute(element, attributeName, value) {
        value ? element.setAttribute(attributeName, "") : element.removeAttribute(attributeName);
      },
      /**
       * Removes all the child nodes of the provided parent node.
       * @param parent - The node to remove the children from.
       */
      removeChildNodes(parent) {
        for (let child = parent.firstChild; child !== null; child = parent.firstChild) {
          parent.removeChild(child);
        }
      },
      /**
       * Creates a TreeWalker configured to walk a template fragment.
       * @param fragment - The fragment to walk.
       */
      createTemplateWalker(fragment) {
        return document.createTreeWalker(
          fragment,
          133,
          // element, text, comment
          null,
          false
        );
      }
    });
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/observation/notifier.js
var SubscriberSet, PropertyChangeNotifier;
var init_notifier = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/observation/notifier.js"() {
    SubscriberSet = class {
      /**
       * Creates an instance of SubscriberSet for the specified source.
       * @param source - The object source that subscribers will receive notifications from.
       * @param initialSubscriber - An initial subscriber to changes.
       */
      constructor(source, initialSubscriber) {
        this.sub1 = void 0;
        this.sub2 = void 0;
        this.spillover = void 0;
        this.source = source;
        this.sub1 = initialSubscriber;
      }
      /**
       * Checks whether the provided subscriber has been added to this set.
       * @param subscriber - The subscriber to test for inclusion in this set.
       */
      has(subscriber) {
        return this.spillover === void 0 ? this.sub1 === subscriber || this.sub2 === subscriber : this.spillover.indexOf(subscriber) !== -1;
      }
      /**
       * Subscribes to notification of changes in an object's state.
       * @param subscriber - The object that is subscribing for change notification.
       */
      subscribe(subscriber) {
        const spillover = this.spillover;
        if (spillover === void 0) {
          if (this.has(subscriber)) {
            return;
          }
          if (this.sub1 === void 0) {
            this.sub1 = subscriber;
            return;
          }
          if (this.sub2 === void 0) {
            this.sub2 = subscriber;
            return;
          }
          this.spillover = [this.sub1, this.sub2, subscriber];
          this.sub1 = void 0;
          this.sub2 = void 0;
        } else {
          const index = spillover.indexOf(subscriber);
          if (index === -1) {
            spillover.push(subscriber);
          }
        }
      }
      /**
       * Unsubscribes from notification of changes in an object's state.
       * @param subscriber - The object that is unsubscribing from change notification.
       */
      unsubscribe(subscriber) {
        const spillover = this.spillover;
        if (spillover === void 0) {
          if (this.sub1 === subscriber) {
            this.sub1 = void 0;
          } else if (this.sub2 === subscriber) {
            this.sub2 = void 0;
          }
        } else {
          const index = spillover.indexOf(subscriber);
          if (index !== -1) {
            spillover.splice(index, 1);
          }
        }
      }
      /**
       * Notifies all subscribers.
       * @param args - Data passed along to subscribers during notification.
       */
      notify(args) {
        const spillover = this.spillover;
        const source = this.source;
        if (spillover === void 0) {
          const sub1 = this.sub1;
          const sub2 = this.sub2;
          if (sub1 !== void 0) {
            sub1.handleChange(source, args);
          }
          if (sub2 !== void 0) {
            sub2.handleChange(source, args);
          }
        } else {
          for (let i = 0, ii = spillover.length; i < ii; ++i) {
            spillover[i].handleChange(source, args);
          }
        }
      }
    };
    PropertyChangeNotifier = class {
      /**
       * Creates an instance of PropertyChangeNotifier for the specified source.
       * @param source - The object source that subscribers will receive notifications from.
       */
      constructor(source) {
        this.subscribers = {};
        this.sourceSubscribers = null;
        this.source = source;
      }
      /**
       * Notifies all subscribers, based on the specified property.
       * @param propertyName - The property name, passed along to subscribers during notification.
       */
      notify(propertyName) {
        var _a;
        const subscribers = this.subscribers[propertyName];
        if (subscribers !== void 0) {
          subscribers.notify(propertyName);
        }
        (_a = this.sourceSubscribers) === null || _a === void 0 ? void 0 : _a.notify(propertyName);
      }
      /**
       * Subscribes to notification of changes in an object's state.
       * @param subscriber - The object that is subscribing for change notification.
       * @param propertyToWatch - The name of the property that the subscriber is interested in watching for changes.
       */
      subscribe(subscriber, propertyToWatch) {
        var _a;
        if (propertyToWatch) {
          let subscribers = this.subscribers[propertyToWatch];
          if (subscribers === void 0) {
            this.subscribers[propertyToWatch] = subscribers = new SubscriberSet(this.source);
          }
          subscribers.subscribe(subscriber);
        } else {
          this.sourceSubscribers = (_a = this.sourceSubscribers) !== null && _a !== void 0 ? _a : new SubscriberSet(this.source);
          this.sourceSubscribers.subscribe(subscriber);
        }
      }
      /**
       * Unsubscribes from notification of changes in an object's state.
       * @param subscriber - The object that is unsubscribing from change notification.
       * @param propertyToUnwatch - The name of the property that the subscriber is no longer interested in watching.
       */
      unsubscribe(subscriber, propertyToUnwatch) {
        var _a;
        if (propertyToUnwatch) {
          const subscribers = this.subscribers[propertyToUnwatch];
          if (subscribers !== void 0) {
            subscribers.unsubscribe(subscriber);
          }
        } else {
          (_a = this.sourceSubscribers) === null || _a === void 0 ? void 0 : _a.unsubscribe(subscriber);
        }
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/observation/observable.js
function observable(target2, nameOrAccessor) {
  Observable.defineProperty(target2, nameOrAccessor);
}
function volatile(target2, name2, descriptor) {
  return Object.assign({}, descriptor, {
    get: function() {
      Observable.trackVolatile();
      return descriptor.get.apply(this);
    }
  });
}
var Observable, contextEvent, ExecutionContext, defaultExecutionContext;
var init_observable = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/observation/observable.js"() {
    init_dom();
    init_platform();
    init_notifier();
    Observable = FAST.getById(2, () => {
      const volatileRegex = /(:|&&|\|\||if)/;
      const notifierLookup = /* @__PURE__ */ new WeakMap();
      const queueUpdate = DOM.queueUpdate;
      let watcher = void 0;
      let createArrayObserver = (array) => {
        throw new Error("Must call enableArrayObservation before observing arrays.");
      };
      function getNotifier(source) {
        let found2 = source.$fastController || notifierLookup.get(source);
        if (found2 === void 0) {
          if (Array.isArray(source)) {
            found2 = createArrayObserver(source);
          } else {
            notifierLookup.set(source, found2 = new PropertyChangeNotifier(source));
          }
        }
        return found2;
      }
      const getAccessors = createMetadataLocator();
      class DefaultObservableAccessor {
        constructor(name2) {
          this.name = name2;
          this.field = `_${name2}`;
          this.callback = `${name2}Changed`;
        }
        getValue(source) {
          if (watcher !== void 0) {
            watcher.watch(source, this.name);
          }
          return source[this.field];
        }
        setValue(source, newValue) {
          const field = this.field;
          const oldValue = source[field];
          if (oldValue !== newValue) {
            source[field] = newValue;
            const callback = source[this.callback];
            if (typeof callback === "function") {
              callback.call(source, oldValue, newValue);
            }
            getNotifier(source).notify(this.name);
          }
        }
      }
      class BindingObserverImplementation extends SubscriberSet {
        constructor(binding, initialSubscriber, isVolatileBinding = false) {
          super(binding, initialSubscriber);
          this.binding = binding;
          this.isVolatileBinding = isVolatileBinding;
          this.needsRefresh = true;
          this.needsQueue = true;
          this.first = this;
          this.last = null;
          this.propertySource = void 0;
          this.propertyName = void 0;
          this.notifier = void 0;
          this.next = void 0;
        }
        observe(source, context) {
          if (this.needsRefresh && this.last !== null) {
            this.disconnect();
          }
          const previousWatcher = watcher;
          watcher = this.needsRefresh ? this : void 0;
          this.needsRefresh = this.isVolatileBinding;
          const result = this.binding(source, context);
          watcher = previousWatcher;
          return result;
        }
        disconnect() {
          if (this.last !== null) {
            let current = this.first;
            while (current !== void 0) {
              current.notifier.unsubscribe(this, current.propertyName);
              current = current.next;
            }
            this.last = null;
            this.needsRefresh = this.needsQueue = true;
          }
        }
        watch(propertySource, propertyName) {
          const prev = this.last;
          const notifier = getNotifier(propertySource);
          const current = prev === null ? this.first : {};
          current.propertySource = propertySource;
          current.propertyName = propertyName;
          current.notifier = notifier;
          notifier.subscribe(this, propertyName);
          if (prev !== null) {
            if (!this.needsRefresh) {
              let prevValue;
              watcher = void 0;
              prevValue = prev.propertySource[prev.propertyName];
              watcher = this;
              if (propertySource === prevValue) {
                this.needsRefresh = true;
              }
            }
            prev.next = current;
          }
          this.last = current;
        }
        handleChange() {
          if (this.needsQueue) {
            this.needsQueue = false;
            queueUpdate(this);
          }
        }
        call() {
          if (this.last !== null) {
            this.needsQueue = true;
            this.notify(this);
          }
        }
        records() {
          let next = this.first;
          return {
            next: () => {
              const current = next;
              if (current === void 0) {
                return { value: void 0, done: true };
              } else {
                next = next.next;
                return {
                  value: current,
                  done: false
                };
              }
            },
            [Symbol.iterator]: function() {
              return this;
            }
          };
        }
      }
      return Object.freeze({
        /**
         * @internal
         * @param factory - The factory used to create array observers.
         */
        setArrayObserverFactory(factory) {
          createArrayObserver = factory;
        },
        /**
         * Gets a notifier for an object or Array.
         * @param source - The object or Array to get the notifier for.
         */
        getNotifier,
        /**
         * Records a property change for a source object.
         * @param source - The object to record the change against.
         * @param propertyName - The property to track as changed.
         */
        track(source, propertyName) {
          if (watcher !== void 0) {
            watcher.watch(source, propertyName);
          }
        },
        /**
         * Notifies watchers that the currently executing property getter or function is volatile
         * with respect to its observable dependencies.
         */
        trackVolatile() {
          if (watcher !== void 0) {
            watcher.needsRefresh = true;
          }
        },
        /**
         * Notifies subscribers of a source object of changes.
         * @param source - the object to notify of changes.
         * @param args - The change args to pass to subscribers.
         */
        notify(source, args) {
          getNotifier(source).notify(args);
        },
        /**
         * Defines an observable property on an object or prototype.
         * @param target - The target object to define the observable on.
         * @param nameOrAccessor - The name of the property to define as observable;
         * or a custom accessor that specifies the property name and accessor implementation.
         */
        defineProperty(target2, nameOrAccessor) {
          if (typeof nameOrAccessor === "string") {
            nameOrAccessor = new DefaultObservableAccessor(nameOrAccessor);
          }
          getAccessors(target2).push(nameOrAccessor);
          Reflect.defineProperty(target2, nameOrAccessor.name, {
            enumerable: true,
            get: function() {
              return nameOrAccessor.getValue(this);
            },
            set: function(newValue) {
              nameOrAccessor.setValue(this, newValue);
            }
          });
        },
        /**
         * Finds all the observable accessors defined on the target,
         * including its prototype chain.
         * @param target - The target object to search for accessor on.
         */
        getAccessors,
        /**
         * Creates a {@link BindingObserver} that can watch the
         * provided {@link Binding} for changes.
         * @param binding - The binding to observe.
         * @param initialSubscriber - An initial subscriber to changes in the binding value.
         * @param isVolatileBinding - Indicates whether the binding's dependency list must be re-evaluated on every value evaluation.
         */
        binding(binding, initialSubscriber, isVolatileBinding = this.isVolatileBinding(binding)) {
          return new BindingObserverImplementation(binding, initialSubscriber, isVolatileBinding);
        },
        /**
         * Determines whether a binding expression is volatile and needs to have its dependency list re-evaluated
         * on every evaluation of the value.
         * @param binding - The binding to inspect.
         */
        isVolatileBinding(binding) {
          return volatileRegex.test(binding.toString());
        }
      });
    });
    contextEvent = FAST.getById(3, () => {
      let current = null;
      return {
        get() {
          return current;
        },
        set(event) {
          current = event;
        }
      };
    });
    ExecutionContext = class {
      constructor() {
        this.index = 0;
        this.length = 0;
        this.parent = null;
        this.parentContext = null;
      }
      /**
       * The current event within an event handler.
       */
      get event() {
        return contextEvent.get();
      }
      /**
       * Indicates whether the current item within a repeat context
       * has an even index.
       */
      get isEven() {
        return this.index % 2 === 0;
      }
      /**
       * Indicates whether the current item within a repeat context
       * has an odd index.
       */
      get isOdd() {
        return this.index % 2 !== 0;
      }
      /**
       * Indicates whether the current item within a repeat context
       * is the first item in the collection.
       */
      get isFirst() {
        return this.index === 0;
      }
      /**
       * Indicates whether the current item within a repeat context
       * is somewhere in the middle of the collection.
       */
      get isInMiddle() {
        return !this.isFirst && !this.isLast;
      }
      /**
       * Indicates whether the current item within a repeat context
       * is the last item in the collection.
       */
      get isLast() {
        return this.index === this.length - 1;
      }
      /**
       * Sets the event for the current execution context.
       * @param event - The event to set.
       * @internal
       */
      static setEvent(event) {
        contextEvent.set(event);
      }
    };
    Observable.defineProperty(ExecutionContext.prototype, "index");
    Observable.defineProperty(ExecutionContext.prototype, "length");
    defaultExecutionContext = Object.seal(new ExecutionContext());
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/templating/html-directive.js
var HTMLDirective, TargetedHTMLDirective, AttachedBehaviorHTMLDirective;
var init_html_directive = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/templating/html-directive.js"() {
    init_dom();
    HTMLDirective = class {
      constructor() {
        this.targetIndex = 0;
      }
    };
    TargetedHTMLDirective = class extends HTMLDirective {
      constructor() {
        super(...arguments);
        this.createPlaceholder = DOM.createInterpolationPlaceholder;
      }
    };
    AttachedBehaviorHTMLDirective = class extends HTMLDirective {
      /**
       *
       * @param name - The name of the behavior; used as a custom attribute on the element.
       * @param behavior - The behavior to instantiate and attach to the element.
       * @param options - Options to pass to the behavior during creation.
       */
      constructor(name2, behavior, options) {
        super();
        this.name = name2;
        this.behavior = behavior;
        this.options = options;
      }
      /**
       * Creates a placeholder string based on the directive's index within the template.
       * @param index - The index of the directive within the template.
       * @remarks
       * Creates a custom attribute placeholder.
       */
      createPlaceholder(index) {
        return DOM.createCustomAttributePlaceholder(this.name, index);
      }
      /**
       * Creates a behavior for the provided target node.
       * @param target - The node instance to create the behavior for.
       * @remarks
       * Creates an instance of the `behavior` type this directive was constructed with
       * and passes the target and options to that `behavior`'s constructor.
       */
      createBehavior(target2) {
        return new this.behavior(target2, this.options);
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/templating/binding.js
function normalBind(source, context) {
  this.source = source;
  this.context = context;
  if (this.bindingObserver === null) {
    this.bindingObserver = Observable.binding(this.binding, this, this.isBindingVolatile);
  }
  this.updateTarget(this.bindingObserver.observe(source, context));
}
function triggerBind(source, context) {
  this.source = source;
  this.context = context;
  this.target.addEventListener(this.targetName, this);
}
function normalUnbind() {
  this.bindingObserver.disconnect();
  this.source = null;
  this.context = null;
}
function contentUnbind() {
  this.bindingObserver.disconnect();
  this.source = null;
  this.context = null;
  const view = this.target.$fastView;
  if (view !== void 0 && view.isComposed) {
    view.unbind();
    view.needsBindOnly = true;
  }
}
function triggerUnbind() {
  this.target.removeEventListener(this.targetName, this);
  this.source = null;
  this.context = null;
}
function updateAttributeTarget(value) {
  DOM.setAttribute(this.target, this.targetName, value);
}
function updateBooleanAttributeTarget(value) {
  DOM.setBooleanAttribute(this.target, this.targetName, value);
}
function updateContentTarget(value) {
  if (value === null || value === void 0) {
    value = "";
  }
  if (value.create) {
    this.target.textContent = "";
    let view = this.target.$fastView;
    if (view === void 0) {
      view = value.create();
    } else {
      if (this.target.$fastTemplate !== value) {
        if (view.isComposed) {
          view.remove();
          view.unbind();
        }
        view = value.create();
      }
    }
    if (!view.isComposed) {
      view.isComposed = true;
      view.bind(this.source, this.context);
      view.insertBefore(this.target);
      this.target.$fastView = view;
      this.target.$fastTemplate = value;
    } else if (view.needsBindOnly) {
      view.needsBindOnly = false;
      view.bind(this.source, this.context);
    }
  } else {
    const view = this.target.$fastView;
    if (view !== void 0 && view.isComposed) {
      view.isComposed = false;
      view.remove();
      if (view.needsBindOnly) {
        view.needsBindOnly = false;
      } else {
        view.unbind();
      }
    }
    this.target.textContent = value;
  }
}
function updatePropertyTarget(value) {
  this.target[this.targetName] = value;
}
function updateClassTarget(value) {
  const classVersions = this.classVersions || /* @__PURE__ */ Object.create(null);
  const target2 = this.target;
  let version = this.version || 0;
  if (value !== null && value !== void 0 && value.length) {
    const names = value.split(/\s+/);
    for (let i = 0, ii = names.length; i < ii; ++i) {
      const currentName = names[i];
      if (currentName === "") {
        continue;
      }
      classVersions[currentName] = version;
      target2.classList.add(currentName);
    }
  }
  this.classVersions = classVersions;
  this.version = version + 1;
  if (version === 0) {
    return;
  }
  version -= 1;
  for (const name2 in classVersions) {
    if (classVersions[name2] === version) {
      target2.classList.remove(name2);
    }
  }
}
var HTMLBindingDirective, BindingBehavior;
var init_binding = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/templating/binding.js"() {
    init_dom();
    init_observable();
    init_html_directive();
    HTMLBindingDirective = class extends TargetedHTMLDirective {
      /**
       * Creates an instance of BindingDirective.
       * @param binding - A binding that returns the data used to update the DOM.
       */
      constructor(binding) {
        super();
        this.binding = binding;
        this.bind = normalBind;
        this.unbind = normalUnbind;
        this.updateTarget = updateAttributeTarget;
        this.isBindingVolatile = Observable.isVolatileBinding(this.binding);
      }
      /**
       * Gets/sets the name of the attribute or property that this
       * binding is targeting.
       */
      get targetName() {
        return this.originalTargetName;
      }
      set targetName(value) {
        this.originalTargetName = value;
        if (value === void 0) {
          return;
        }
        switch (value[0]) {
          case ":":
            this.cleanedTargetName = value.substr(1);
            this.updateTarget = updatePropertyTarget;
            if (this.cleanedTargetName === "innerHTML") {
              const binding = this.binding;
              this.binding = (s, c) => DOM.createHTML(binding(s, c));
            }
            break;
          case "?":
            this.cleanedTargetName = value.substr(1);
            this.updateTarget = updateBooleanAttributeTarget;
            break;
          case "@":
            this.cleanedTargetName = value.substr(1);
            this.bind = triggerBind;
            this.unbind = triggerUnbind;
            break;
          default:
            this.cleanedTargetName = value;
            if (value === "class") {
              this.updateTarget = updateClassTarget;
            }
            break;
        }
      }
      /**
       * Makes this binding target the content of an element rather than
       * a particular attribute or property.
       */
      targetAtContent() {
        this.updateTarget = updateContentTarget;
        this.unbind = contentUnbind;
      }
      /**
       * Creates the runtime BindingBehavior instance based on the configuration
       * information stored in the BindingDirective.
       * @param target - The target node that the binding behavior should attach to.
       */
      createBehavior(target2) {
        return new BindingBehavior(target2, this.binding, this.isBindingVolatile, this.bind, this.unbind, this.updateTarget, this.cleanedTargetName);
      }
    };
    BindingBehavior = class {
      /**
       * Creates an instance of BindingBehavior.
       * @param target - The target of the data updates.
       * @param binding - The binding that returns the latest value for an update.
       * @param isBindingVolatile - Indicates whether the binding has volatile dependencies.
       * @param bind - The operation to perform during binding.
       * @param unbind - The operation to perform during unbinding.
       * @param updateTarget - The operation to perform when updating.
       * @param targetName - The name of the target attribute or property to update.
       */
      constructor(target2, binding, isBindingVolatile, bind, unbind, updateTarget, targetName) {
        this.source = null;
        this.context = null;
        this.bindingObserver = null;
        this.target = target2;
        this.binding = binding;
        this.isBindingVolatile = isBindingVolatile;
        this.bind = bind;
        this.unbind = unbind;
        this.updateTarget = updateTarget;
        this.targetName = targetName;
      }
      /** @internal */
      handleChange() {
        this.updateTarget(this.bindingObserver.observe(this.source, this.context));
      }
      /** @internal */
      handleEvent(event) {
        ExecutionContext.setEvent(event);
        const result = this.binding(this.source, this.context);
        ExecutionContext.setEvent(null);
        if (result !== true) {
          event.preventDefault();
        }
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/templating/compiler.js
function createAggregateBinding(parts) {
  if (parts.length === 1) {
    return parts[0];
  }
  let targetName;
  const partCount = parts.length;
  const finalParts = parts.map((x) => {
    if (typeof x === "string") {
      return () => x;
    }
    targetName = x.targetName || targetName;
    return x.binding;
  });
  const binding = (scope, context) => {
    let output = "";
    for (let i = 0; i < partCount; ++i) {
      output += finalParts[i](scope, context);
    }
    return output;
  };
  const directive = new HTMLBindingDirective(binding);
  directive.targetName = targetName;
  return directive;
}
function parseContent(context, value) {
  const valueParts = value.split(_interpolationStart);
  if (valueParts.length === 1) {
    return null;
  }
  const bindingParts = [];
  for (let i = 0, ii = valueParts.length; i < ii; ++i) {
    const current = valueParts[i];
    const index = current.indexOf(_interpolationEnd);
    let literal;
    if (index === -1) {
      literal = current;
    } else {
      const directiveIndex = parseInt(current.substring(0, index));
      bindingParts.push(context.directives[directiveIndex]);
      literal = current.substring(index + interpolationEndLength);
    }
    if (literal !== "") {
      bindingParts.push(literal);
    }
  }
  return bindingParts;
}
function compileAttributes(context, node, includeBasicValues = false) {
  const attributes = node.attributes;
  for (let i = 0, ii = attributes.length; i < ii; ++i) {
    const attr2 = attributes[i];
    const attrValue = attr2.value;
    const parseResult = parseContent(context, attrValue);
    let result = null;
    if (parseResult === null) {
      if (includeBasicValues) {
        result = new HTMLBindingDirective(() => attrValue);
        result.targetName = attr2.name;
      }
    } else {
      result = createAggregateBinding(parseResult);
    }
    if (result !== null) {
      node.removeAttributeNode(attr2);
      i--;
      ii--;
      context.addFactory(result);
    }
  }
}
function compileContent(context, node, walker) {
  const parseResult = parseContent(context, node.textContent);
  if (parseResult !== null) {
    let lastNode = node;
    for (let i = 0, ii = parseResult.length; i < ii; ++i) {
      const currentPart = parseResult[i];
      const currentNode = i === 0 ? node : lastNode.parentNode.insertBefore(document.createTextNode(""), lastNode.nextSibling);
      if (typeof currentPart === "string") {
        currentNode.textContent = currentPart;
      } else {
        currentNode.textContent = " ";
        context.captureContentBinding(currentPart);
      }
      lastNode = currentNode;
      context.targetIndex++;
      if (currentNode !== node) {
        walker.nextNode();
      }
    }
    context.targetIndex--;
  }
}
function compileTemplate(template, directives) {
  const fragment = template.content;
  document.adoptNode(fragment);
  const context = CompilationContext.borrow(directives);
  compileAttributes(context, template, true);
  const hostBehaviorFactories = context.behaviorFactories;
  context.reset();
  const walker = DOM.createTemplateWalker(fragment);
  let node;
  while (node = walker.nextNode()) {
    context.targetIndex++;
    switch (node.nodeType) {
      case 1:
        compileAttributes(context, node);
        break;
      case 3:
        compileContent(context, node, walker);
        break;
      case 8:
        if (DOM.isMarker(node)) {
          context.addFactory(directives[DOM.extractDirectiveIndexFromMarker(node)]);
        }
    }
  }
  let targetOffset = 0;
  if (
    // If the first node in a fragment is a marker, that means it's an unstable first node,
    // because something like a when, repeat, etc. could add nodes before the marker.
    // To mitigate this, we insert a stable first node. However, if we insert a node,
    // that will alter the result of the TreeWalker. So, we also need to offset the target index.
    DOM.isMarker(fragment.firstChild) || // Or if there is only one node and a directive, it means the template's content
    // is *only* the directive. In that case, HTMLView.dispose() misses any nodes inserted by
    // the directive. Inserting a new node ensures proper disposal of nodes added by the directive.
    fragment.childNodes.length === 1 && directives.length
  ) {
    fragment.insertBefore(document.createComment(""), fragment.firstChild);
    targetOffset = -1;
  }
  const viewBehaviorFactories = context.behaviorFactories;
  context.release();
  return {
    fragment,
    viewBehaviorFactories,
    hostBehaviorFactories,
    targetOffset
  };
}
var sharedContext, CompilationContext, interpolationEndLength;
var init_compiler = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/templating/compiler.js"() {
    init_dom();
    init_binding();
    sharedContext = null;
    CompilationContext = class {
      addFactory(factory) {
        factory.targetIndex = this.targetIndex;
        this.behaviorFactories.push(factory);
      }
      captureContentBinding(directive) {
        directive.targetAtContent();
        this.addFactory(directive);
      }
      reset() {
        this.behaviorFactories = [];
        this.targetIndex = -1;
      }
      release() {
        sharedContext = this;
      }
      static borrow(directives) {
        const shareable = sharedContext || new CompilationContext();
        shareable.directives = directives;
        shareable.reset();
        sharedContext = null;
        return shareable;
      }
    };
    interpolationEndLength = _interpolationEnd.length;
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/templating/view.js
var range, HTMLView;
var init_view = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/templating/view.js"() {
    range = document.createRange();
    HTMLView = class {
      /**
       * Constructs an instance of HTMLView.
       * @param fragment - The html fragment that contains the nodes for this view.
       * @param behaviors - The behaviors to be applied to this view.
       */
      constructor(fragment, behaviors) {
        this.fragment = fragment;
        this.behaviors = behaviors;
        this.source = null;
        this.context = null;
        this.firstChild = fragment.firstChild;
        this.lastChild = fragment.lastChild;
      }
      /**
       * Appends the view's DOM nodes to the referenced node.
       * @param node - The parent node to append the view's DOM nodes to.
       */
      appendTo(node) {
        node.appendChild(this.fragment);
      }
      /**
       * Inserts the view's DOM nodes before the referenced node.
       * @param node - The node to insert the view's DOM before.
       */
      insertBefore(node) {
        if (this.fragment.hasChildNodes()) {
          node.parentNode.insertBefore(this.fragment, node);
        } else {
          const end = this.lastChild;
          if (node.previousSibling === end)
            return;
          const parentNode = node.parentNode;
          let current = this.firstChild;
          let next;
          while (current !== end) {
            next = current.nextSibling;
            parentNode.insertBefore(current, node);
            current = next;
          }
          parentNode.insertBefore(end, node);
        }
      }
      /**
       * Removes the view's DOM nodes.
       * The nodes are not disposed and the view can later be re-inserted.
       */
      remove() {
        const fragment = this.fragment;
        const end = this.lastChild;
        let current = this.firstChild;
        let next;
        while (current !== end) {
          next = current.nextSibling;
          fragment.appendChild(current);
          current = next;
        }
        fragment.appendChild(end);
      }
      /**
       * Removes the view and unbinds its behaviors, disposing of DOM nodes afterward.
       * Once a view has been disposed, it cannot be inserted or bound again.
       */
      dispose() {
        const parent = this.firstChild.parentNode;
        const end = this.lastChild;
        let current = this.firstChild;
        let next;
        while (current !== end) {
          next = current.nextSibling;
          parent.removeChild(current);
          current = next;
        }
        parent.removeChild(end);
        const behaviors = this.behaviors;
        const oldSource = this.source;
        for (let i = 0, ii = behaviors.length; i < ii; ++i) {
          behaviors[i].unbind(oldSource);
        }
      }
      /**
       * Binds a view's behaviors to its binding source.
       * @param source - The binding source for the view's binding behaviors.
       * @param context - The execution context to run the behaviors within.
       */
      bind(source, context) {
        const behaviors = this.behaviors;
        if (this.source === source) {
          return;
        } else if (this.source !== null) {
          const oldSource = this.source;
          this.source = source;
          this.context = context;
          for (let i = 0, ii = behaviors.length; i < ii; ++i) {
            const current = behaviors[i];
            current.unbind(oldSource);
            current.bind(source, context);
          }
        } else {
          this.source = source;
          this.context = context;
          for (let i = 0, ii = behaviors.length; i < ii; ++i) {
            behaviors[i].bind(source, context);
          }
        }
      }
      /**
       * Unbinds a view's behaviors from its binding source.
       */
      unbind() {
        if (this.source === null) {
          return;
        }
        const behaviors = this.behaviors;
        const oldSource = this.source;
        for (let i = 0, ii = behaviors.length; i < ii; ++i) {
          behaviors[i].unbind(oldSource);
        }
        this.source = null;
      }
      /**
       * Efficiently disposes of a contiguous range of synthetic view instances.
       * @param views - A contiguous range of views to be disposed.
       */
      static disposeContiguousBatch(views) {
        if (views.length === 0) {
          return;
        }
        range.setStartBefore(views[0].firstChild);
        range.setEndAfter(views[views.length - 1].lastChild);
        range.deleteContents();
        for (let i = 0, ii = views.length; i < ii; ++i) {
          const view = views[i];
          const behaviors = view.behaviors;
          const oldSource = view.source;
          for (let j = 0, jj = behaviors.length; j < jj; ++j) {
            behaviors[j].unbind(oldSource);
          }
        }
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/templating/template.js
function html(strings, ...values) {
  const directives = [];
  let html2 = "";
  for (let i = 0, ii = strings.length - 1; i < ii; ++i) {
    const currentString = strings[i];
    let value = values[i];
    html2 += currentString;
    if (value instanceof ViewTemplate) {
      const template = value;
      value = () => template;
    }
    if (typeof value === "function") {
      value = new HTMLBindingDirective(value);
    }
    if (value instanceof TargetedHTMLDirective) {
      const match = lastAttributeNameRegex.exec(currentString);
      if (match !== null) {
        value.targetName = match[2];
      }
    }
    if (value instanceof HTMLDirective) {
      html2 += value.createPlaceholder(directives.length);
      directives.push(value);
    } else {
      html2 += value;
    }
  }
  html2 += strings[strings.length - 1];
  return new ViewTemplate(html2, directives);
}
var ViewTemplate, lastAttributeNameRegex;
var init_template = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/templating/template.js"() {
    init_dom();
    init_observable();
    init_compiler();
    init_view();
    init_html_directive();
    init_binding();
    ViewTemplate = class {
      /**
       * Creates an instance of ViewTemplate.
       * @param html - The html representing what this template will instantiate, including placeholders for directives.
       * @param directives - The directives that will be connected to placeholders in the html.
       */
      constructor(html2, directives) {
        this.behaviorCount = 0;
        this.hasHostBehaviors = false;
        this.fragment = null;
        this.targetOffset = 0;
        this.viewBehaviorFactories = null;
        this.hostBehaviorFactories = null;
        this.html = html2;
        this.directives = directives;
      }
      /**
       * Creates an HTMLView instance based on this template definition.
       * @param hostBindingTarget - The element that host behaviors will be bound to.
       */
      create(hostBindingTarget) {
        if (this.fragment === null) {
          let template;
          const html2 = this.html;
          if (typeof html2 === "string") {
            template = document.createElement("template");
            template.innerHTML = DOM.createHTML(html2);
            const fec = template.content.firstElementChild;
            if (fec !== null && fec.tagName === "TEMPLATE") {
              template = fec;
            }
          } else {
            template = html2;
          }
          const result = compileTemplate(template, this.directives);
          this.fragment = result.fragment;
          this.viewBehaviorFactories = result.viewBehaviorFactories;
          this.hostBehaviorFactories = result.hostBehaviorFactories;
          this.targetOffset = result.targetOffset;
          this.behaviorCount = this.viewBehaviorFactories.length + this.hostBehaviorFactories.length;
          this.hasHostBehaviors = this.hostBehaviorFactories.length > 0;
        }
        const fragment = this.fragment.cloneNode(true);
        const viewFactories = this.viewBehaviorFactories;
        const behaviors = new Array(this.behaviorCount);
        const walker = DOM.createTemplateWalker(fragment);
        let behaviorIndex = 0;
        let targetIndex = this.targetOffset;
        let node = walker.nextNode();
        for (let ii = viewFactories.length; behaviorIndex < ii; ++behaviorIndex) {
          const factory = viewFactories[behaviorIndex];
          const factoryIndex = factory.targetIndex;
          while (node !== null) {
            if (targetIndex === factoryIndex) {
              behaviors[behaviorIndex] = factory.createBehavior(node);
              break;
            } else {
              node = walker.nextNode();
              targetIndex++;
            }
          }
        }
        if (this.hasHostBehaviors) {
          const hostFactories = this.hostBehaviorFactories;
          for (let i = 0, ii = hostFactories.length; i < ii; ++i, ++behaviorIndex) {
            behaviors[behaviorIndex] = hostFactories[i].createBehavior(hostBindingTarget);
          }
        }
        return new HTMLView(fragment, behaviors);
      }
      /**
       * Creates an HTMLView from this template, binds it to the source, and then appends it to the host.
       * @param source - The data source to bind the template to.
       * @param host - The Element where the template will be rendered.
       * @param hostBindingTarget - An HTML element to target the host bindings at if different from the
       * host that the template is being attached to.
       */
      render(source, host, hostBindingTarget) {
        if (typeof host === "string") {
          host = document.getElementById(host);
        }
        if (hostBindingTarget === void 0) {
          hostBindingTarget = host;
        }
        const view = this.create(hostBindingTarget);
        view.bind(source, defaultExecutionContext);
        view.appendTo(host);
        return view;
      }
    };
    lastAttributeNameRegex = /* eslint-disable-next-line no-control-regex */
    /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/styles/element-styles.js
function reduceStyles(styles) {
  return styles.map((x) => x instanceof ElementStyles ? reduceStyles(x.styles) : [x]).reduce((prev, curr) => prev.concat(curr), []);
}
function reduceBehaviors(styles) {
  return styles.map((x) => x instanceof ElementStyles ? x.behaviors : null).reduce((prev, curr) => {
    if (curr === null) {
      return prev;
    }
    if (prev === null) {
      prev = [];
    }
    return prev.concat(curr);
  }, null);
}
function getNextStyleClass() {
  return `fast-style-class-${++styleClassId}`;
}
var ElementStyles, addAdoptedStyleSheets, removeAdoptedStyleSheets, AdoptedStyleSheetsStyles, styleClassId, StyleElementStyles;
var init_element_styles = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/styles/element-styles.js"() {
    init_dom();
    ElementStyles = class {
      constructor() {
        this.targets = /* @__PURE__ */ new WeakSet();
      }
      /** @internal */
      addStylesTo(target2) {
        this.targets.add(target2);
      }
      /** @internal */
      removeStylesFrom(target2) {
        this.targets.delete(target2);
      }
      /** @internal */
      isAttachedTo(target2) {
        return this.targets.has(target2);
      }
      /**
       * Associates behaviors with this set of styles.
       * @param behaviors - The behaviors to associate.
       */
      withBehaviors(...behaviors) {
        this.behaviors = this.behaviors === null ? behaviors : this.behaviors.concat(behaviors);
        return this;
      }
    };
    ElementStyles.create = (() => {
      if (DOM.supportsAdoptedStyleSheets) {
        const styleSheetCache = /* @__PURE__ */ new Map();
        return (styles) => (
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          new AdoptedStyleSheetsStyles(styles, styleSheetCache)
        );
      }
      return (styles) => new StyleElementStyles(styles);
    })();
    addAdoptedStyleSheets = (target2, sheets) => {
      target2.adoptedStyleSheets = [...target2.adoptedStyleSheets, ...sheets];
    };
    removeAdoptedStyleSheets = (target2, sheets) => {
      target2.adoptedStyleSheets = target2.adoptedStyleSheets.filter((x) => sheets.indexOf(x) === -1);
    };
    if (DOM.supportsAdoptedStyleSheets) {
      try {
        document.adoptedStyleSheets.push();
        document.adoptedStyleSheets.splice();
        addAdoptedStyleSheets = (target2, sheets) => {
          target2.adoptedStyleSheets.push(...sheets);
        };
        removeAdoptedStyleSheets = (target2, sheets) => {
          for (const sheet of sheets) {
            const index = target2.adoptedStyleSheets.indexOf(sheet);
            if (index !== -1) {
              target2.adoptedStyleSheets.splice(index, 1);
            }
          }
        };
      } catch (e) {
      }
    }
    AdoptedStyleSheetsStyles = class extends ElementStyles {
      constructor(styles, styleSheetCache) {
        super();
        this.styles = styles;
        this.styleSheetCache = styleSheetCache;
        this._styleSheets = void 0;
        this.behaviors = reduceBehaviors(styles);
      }
      get styleSheets() {
        if (this._styleSheets === void 0) {
          const styles = this.styles;
          const styleSheetCache = this.styleSheetCache;
          this._styleSheets = reduceStyles(styles).map((x) => {
            if (x instanceof CSSStyleSheet) {
              return x;
            }
            let sheet = styleSheetCache.get(x);
            if (sheet === void 0) {
              sheet = new CSSStyleSheet();
              sheet.replaceSync(x);
              styleSheetCache.set(x, sheet);
            }
            return sheet;
          });
        }
        return this._styleSheets;
      }
      addStylesTo(target2) {
        addAdoptedStyleSheets(target2, this.styleSheets);
        super.addStylesTo(target2);
      }
      removeStylesFrom(target2) {
        removeAdoptedStyleSheets(target2, this.styleSheets);
        super.removeStylesFrom(target2);
      }
    };
    styleClassId = 0;
    StyleElementStyles = class extends ElementStyles {
      constructor(styles) {
        super();
        this.styles = styles;
        this.behaviors = null;
        this.behaviors = reduceBehaviors(styles);
        this.styleSheets = reduceStyles(styles);
        this.styleClass = getNextStyleClass();
      }
      addStylesTo(target2) {
        const styleSheets = this.styleSheets;
        const styleClass = this.styleClass;
        target2 = this.normalizeTarget(target2);
        for (let i = 0; i < styleSheets.length; i++) {
          const element = document.createElement("style");
          element.innerHTML = styleSheets[i];
          element.className = styleClass;
          target2.append(element);
        }
        super.addStylesTo(target2);
      }
      removeStylesFrom(target2) {
        target2 = this.normalizeTarget(target2);
        const styles = target2.querySelectorAll(`.${this.styleClass}`);
        for (let i = 0, ii = styles.length; i < ii; ++i) {
          target2.removeChild(styles[i]);
        }
        super.removeStylesFrom(target2);
      }
      isAttachedTo(target2) {
        return super.isAttachedTo(this.normalizeTarget(target2));
      }
      normalizeTarget(target2) {
        return target2 === document ? document.body : target2;
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/components/attributes.js
function attr(configOrTarget, prop) {
  let config;
  function decorator($target, $prop) {
    if (arguments.length > 1) {
      config.property = $prop;
    }
    AttributeConfiguration.locate($target.constructor).push(config);
  }
  if (arguments.length > 1) {
    config = {};
    decorator(configOrTarget, prop);
    return;
  }
  config = configOrTarget === void 0 ? {} : configOrTarget;
  return decorator;
}
var AttributeConfiguration, booleanConverter, nullableNumberConverter, AttributeDefinition;
var init_attributes = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/components/attributes.js"() {
    init_observable();
    init_dom();
    init_platform();
    AttributeConfiguration = Object.freeze({
      /**
       * Locates all attribute configurations associated with a type.
       */
      locate: createMetadataLocator()
    });
    booleanConverter = {
      toView(value) {
        return value ? "true" : "false";
      },
      fromView(value) {
        if (value === null || value === void 0 || value === "false" || value === false || value === 0) {
          return false;
        }
        return true;
      }
    };
    nullableNumberConverter = {
      toView(value) {
        if (value === null || value === void 0) {
          return null;
        }
        const number = value * 1;
        return isNaN(number) ? null : number.toString();
      },
      fromView(value) {
        if (value === null || value === void 0) {
          return null;
        }
        const number = value * 1;
        return isNaN(number) ? null : number;
      }
    };
    AttributeDefinition = class {
      /**
       * Creates an instance of AttributeDefinition.
       * @param Owner - The class constructor that owns this attribute.
       * @param name - The name of the property associated with the attribute.
       * @param attribute - The name of the attribute in HTML.
       * @param mode - The {@link AttributeMode} that describes the behavior of this attribute.
       * @param converter - A {@link ValueConverter} that integrates with the property getter/setter
       * to convert values to and from a DOM string.
       */
      constructor(Owner, name2, attribute = name2.toLowerCase(), mode = "reflect", converter) {
        this.guards = /* @__PURE__ */ new Set();
        this.Owner = Owner;
        this.name = name2;
        this.attribute = attribute;
        this.mode = mode;
        this.converter = converter;
        this.fieldName = `_${name2}`;
        this.callbackName = `${name2}Changed`;
        this.hasCallback = this.callbackName in Owner.prototype;
        if (mode === "boolean" && converter === void 0) {
          this.converter = booleanConverter;
        }
      }
      /**
       * Sets the value of the attribute/property on the source element.
       * @param source - The source element to access.
       * @param value - The value to set the attribute/property to.
       */
      setValue(source, newValue) {
        const oldValue = source[this.fieldName];
        const converter = this.converter;
        if (converter !== void 0) {
          newValue = converter.fromView(newValue);
        }
        if (oldValue !== newValue) {
          source[this.fieldName] = newValue;
          this.tryReflectToAttribute(source);
          if (this.hasCallback) {
            source[this.callbackName](oldValue, newValue);
          }
          source.$fastController.notify(this.name);
        }
      }
      /**
       * Gets the value of the attribute/property on the source element.
       * @param source - The source element to access.
       */
      getValue(source) {
        Observable.track(source, this.name);
        return source[this.fieldName];
      }
      /** @internal */
      onAttributeChangedCallback(element, value) {
        if (this.guards.has(element)) {
          return;
        }
        this.guards.add(element);
        this.setValue(element, value);
        this.guards.delete(element);
      }
      tryReflectToAttribute(element) {
        const mode = this.mode;
        const guards = this.guards;
        if (guards.has(element) || mode === "fromView") {
          return;
        }
        DOM.queueUpdate(() => {
          guards.add(element);
          const latestValue = element[this.fieldName];
          switch (mode) {
            case "reflect":
              const converter = this.converter;
              DOM.setAttribute(element, this.attribute, converter !== void 0 ? converter.toView(latestValue) : latestValue);
              break;
            case "boolean":
              DOM.setBooleanAttribute(element, this.attribute, latestValue);
              break;
          }
          guards.delete(element);
        });
      }
      /**
       * Collects all attribute definitions associated with the owner.
       * @param Owner - The class constructor to collect attribute for.
       * @param attributeLists - Any existing attributes to collect and merge with those associated with the owner.
       * @internal
       */
      static collect(Owner, ...attributeLists) {
        const attributes = [];
        attributeLists.push(AttributeConfiguration.locate(Owner));
        for (let i = 0, ii = attributeLists.length; i < ii; ++i) {
          const list = attributeLists[i];
          if (list === void 0) {
            continue;
          }
          for (let j = 0, jj = list.length; j < jj; ++j) {
            const config = list[j];
            if (typeof config === "string") {
              attributes.push(new AttributeDefinition(Owner, config));
            } else {
              attributes.push(new AttributeDefinition(Owner, config.property, config.attribute, config.mode, config.converter));
            }
          }
        }
        return attributes;
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/components/fast-definitions.js
var defaultShadowOptions, defaultElementOptions, fastRegistry, FASTElementDefinition;
var init_fast_definitions = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/components/fast-definitions.js"() {
    init_platform();
    init_observable();
    init_element_styles();
    init_attributes();
    defaultShadowOptions = { mode: "open" };
    defaultElementOptions = {};
    fastRegistry = FAST.getById(4, () => {
      const typeToDefinition = /* @__PURE__ */ new Map();
      return Object.freeze({
        register(definition) {
          if (typeToDefinition.has(definition.type)) {
            return false;
          }
          typeToDefinition.set(definition.type, definition);
          return true;
        },
        getByType(key2) {
          return typeToDefinition.get(key2);
        }
      });
    });
    FASTElementDefinition = class {
      /**
       * Creates an instance of FASTElementDefinition.
       * @param type - The type this definition is being created for.
       * @param nameOrConfig - The name of the element to define or a config object
       * that describes the element to define.
       */
      constructor(type, nameOrConfig = type.definition) {
        if (typeof nameOrConfig === "string") {
          nameOrConfig = { name: nameOrConfig };
        }
        this.type = type;
        this.name = nameOrConfig.name;
        this.template = nameOrConfig.template;
        const attributes = AttributeDefinition.collect(type, nameOrConfig.attributes);
        const observedAttributes = new Array(attributes.length);
        const propertyLookup = {};
        const attributeLookup = {};
        for (let i = 0, ii = attributes.length; i < ii; ++i) {
          const current = attributes[i];
          observedAttributes[i] = current.attribute;
          propertyLookup[current.name] = current;
          attributeLookup[current.attribute] = current;
        }
        this.attributes = attributes;
        this.observedAttributes = observedAttributes;
        this.propertyLookup = propertyLookup;
        this.attributeLookup = attributeLookup;
        this.shadowOptions = nameOrConfig.shadowOptions === void 0 ? defaultShadowOptions : nameOrConfig.shadowOptions === null ? void 0 : Object.assign(Object.assign({}, defaultShadowOptions), nameOrConfig.shadowOptions);
        this.elementOptions = nameOrConfig.elementOptions === void 0 ? defaultElementOptions : Object.assign(Object.assign({}, defaultElementOptions), nameOrConfig.elementOptions);
        this.styles = nameOrConfig.styles === void 0 ? void 0 : Array.isArray(nameOrConfig.styles) ? ElementStyles.create(nameOrConfig.styles) : nameOrConfig.styles instanceof ElementStyles ? nameOrConfig.styles : ElementStyles.create([nameOrConfig.styles]);
      }
      /**
       * Indicates if this element has been defined in at least one registry.
       */
      get isDefined() {
        return !!fastRegistry.getByType(this.type);
      }
      /**
       * Defines a custom element based on this definition.
       * @param registry - The element registry to define the element in.
       */
      define(registry = customElements) {
        const type = this.type;
        if (fastRegistry.register(this)) {
          const attributes = this.attributes;
          const proto = type.prototype;
          for (let i = 0, ii = attributes.length; i < ii; ++i) {
            Observable.defineProperty(proto, attributes[i]);
          }
          Reflect.defineProperty(type, "observedAttributes", {
            value: this.observedAttributes,
            enumerable: true
          });
        }
        if (!registry.get(this.name)) {
          registry.define(this.name, type, this.elementOptions);
        }
        return this;
      }
    };
    FASTElementDefinition.forType = fastRegistry.getByType;
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/components/controller.js
function getShadowRoot(element) {
  return element.shadowRoot || shadowRoots.get(element) || null;
}
var shadowRoots, defaultEventOptions, Controller;
var init_controller = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/components/controller.js"() {
    init_dom();
    init_notifier();
    init_observable();
    init_fast_definitions();
    shadowRoots = /* @__PURE__ */ new WeakMap();
    defaultEventOptions = {
      bubbles: true,
      composed: true,
      cancelable: true
    };
    Controller = class extends PropertyChangeNotifier {
      /**
       * Creates a Controller to control the specified element.
       * @param element - The element to be controlled by this controller.
       * @param definition - The element definition metadata that instructs this
       * controller in how to handle rendering and other platform integrations.
       * @internal
       */
      constructor(element, definition) {
        super(element);
        this.boundObservables = null;
        this.behaviors = null;
        this.needsInitialization = true;
        this._template = null;
        this._styles = null;
        this._isConnected = false;
        this.$fastController = this;
        this.view = null;
        this.element = element;
        this.definition = definition;
        const shadowOptions = definition.shadowOptions;
        if (shadowOptions !== void 0) {
          const shadowRoot = element.attachShadow(shadowOptions);
          if (shadowOptions.mode === "closed") {
            shadowRoots.set(element, shadowRoot);
          }
        }
        const accessors = Observable.getAccessors(element);
        if (accessors.length > 0) {
          const boundObservables = this.boundObservables = /* @__PURE__ */ Object.create(null);
          for (let i = 0, ii = accessors.length; i < ii; ++i) {
            const propertyName = accessors[i].name;
            const value = element[propertyName];
            if (value !== void 0) {
              delete element[propertyName];
              boundObservables[propertyName] = value;
            }
          }
        }
      }
      /**
       * Indicates whether or not the custom element has been
       * connected to the document.
       */
      get isConnected() {
        Observable.track(this, "isConnected");
        return this._isConnected;
      }
      setIsConnected(value) {
        this._isConnected = value;
        Observable.notify(this, "isConnected");
      }
      /**
       * Gets/sets the template used to render the component.
       * @remarks
       * This value can only be accurately read after connect but can be set at any time.
       */
      get template() {
        return this._template;
      }
      set template(value) {
        if (this._template === value) {
          return;
        }
        this._template = value;
        if (!this.needsInitialization) {
          this.renderTemplate(value);
        }
      }
      /**
       * Gets/sets the primary styles used for the component.
       * @remarks
       * This value can only be accurately read after connect but can be set at any time.
       */
      get styles() {
        return this._styles;
      }
      set styles(value) {
        if (this._styles === value) {
          return;
        }
        if (this._styles !== null) {
          this.removeStyles(this._styles);
        }
        this._styles = value;
        if (!this.needsInitialization && value !== null) {
          this.addStyles(value);
        }
      }
      /**
       * Adds styles to this element. Providing an HTMLStyleElement will attach the element instance to the shadowRoot.
       * @param styles - The styles to add.
       */
      addStyles(styles) {
        const target2 = getShadowRoot(this.element) || this.element.getRootNode();
        if (styles instanceof HTMLStyleElement) {
          target2.append(styles);
        } else if (!styles.isAttachedTo(target2)) {
          const sourceBehaviors = styles.behaviors;
          styles.addStylesTo(target2);
          if (sourceBehaviors !== null) {
            this.addBehaviors(sourceBehaviors);
          }
        }
      }
      /**
       * Removes styles from this element. Providing an HTMLStyleElement will detach the element instance from the shadowRoot.
       * @param styles - the styles to remove.
       */
      removeStyles(styles) {
        const target2 = getShadowRoot(this.element) || this.element.getRootNode();
        if (styles instanceof HTMLStyleElement) {
          target2.removeChild(styles);
        } else if (styles.isAttachedTo(target2)) {
          const sourceBehaviors = styles.behaviors;
          styles.removeStylesFrom(target2);
          if (sourceBehaviors !== null) {
            this.removeBehaviors(sourceBehaviors);
          }
        }
      }
      /**
       * Adds behaviors to this element.
       * @param behaviors - The behaviors to add.
       */
      addBehaviors(behaviors) {
        const targetBehaviors = this.behaviors || (this.behaviors = /* @__PURE__ */ new Map());
        const length = behaviors.length;
        const behaviorsToBind = [];
        for (let i = 0; i < length; ++i) {
          const behavior = behaviors[i];
          if (targetBehaviors.has(behavior)) {
            targetBehaviors.set(behavior, targetBehaviors.get(behavior) + 1);
          } else {
            targetBehaviors.set(behavior, 1);
            behaviorsToBind.push(behavior);
          }
        }
        if (this._isConnected) {
          const element = this.element;
          for (let i = 0; i < behaviorsToBind.length; ++i) {
            behaviorsToBind[i].bind(element, defaultExecutionContext);
          }
        }
      }
      /**
       * Removes behaviors from this element.
       * @param behaviors - The behaviors to remove.
       * @param force - Forces unbinding of behaviors.
       */
      removeBehaviors(behaviors, force = false) {
        const targetBehaviors = this.behaviors;
        if (targetBehaviors === null) {
          return;
        }
        const length = behaviors.length;
        const behaviorsToUnbind = [];
        for (let i = 0; i < length; ++i) {
          const behavior = behaviors[i];
          if (targetBehaviors.has(behavior)) {
            const count = targetBehaviors.get(behavior) - 1;
            count === 0 || force ? targetBehaviors.delete(behavior) && behaviorsToUnbind.push(behavior) : targetBehaviors.set(behavior, count);
          }
        }
        if (this._isConnected) {
          const element = this.element;
          for (let i = 0; i < behaviorsToUnbind.length; ++i) {
            behaviorsToUnbind[i].unbind(element);
          }
        }
      }
      /**
       * Runs connected lifecycle behavior on the associated element.
       */
      onConnectedCallback() {
        if (this._isConnected) {
          return;
        }
        const element = this.element;
        if (this.needsInitialization) {
          this.finishInitialization();
        } else if (this.view !== null) {
          this.view.bind(element, defaultExecutionContext);
        }
        const behaviors = this.behaviors;
        if (behaviors !== null) {
          for (const [behavior] of behaviors) {
            behavior.bind(element, defaultExecutionContext);
          }
        }
        this.setIsConnected(true);
      }
      /**
       * Runs disconnected lifecycle behavior on the associated element.
       */
      onDisconnectedCallback() {
        if (!this._isConnected) {
          return;
        }
        this.setIsConnected(false);
        const view = this.view;
        if (view !== null) {
          view.unbind();
        }
        const behaviors = this.behaviors;
        if (behaviors !== null) {
          const element = this.element;
          for (const [behavior] of behaviors) {
            behavior.unbind(element);
          }
        }
      }
      /**
       * Runs the attribute changed callback for the associated element.
       * @param name - The name of the attribute that changed.
       * @param oldValue - The previous value of the attribute.
       * @param newValue - The new value of the attribute.
       */
      onAttributeChangedCallback(name2, oldValue, newValue) {
        const attrDef = this.definition.attributeLookup[name2];
        if (attrDef !== void 0) {
          attrDef.onAttributeChangedCallback(this.element, newValue);
        }
      }
      /**
       * Emits a custom HTML event.
       * @param type - The type name of the event.
       * @param detail - The event detail object to send with the event.
       * @param options - The event options. By default bubbles and composed.
       * @remarks
       * Only emits events if connected.
       */
      emit(type, detail, options) {
        if (this._isConnected) {
          return this.element.dispatchEvent(new CustomEvent(type, Object.assign(Object.assign({ detail }, defaultEventOptions), options)));
        }
        return false;
      }
      finishInitialization() {
        const element = this.element;
        const boundObservables = this.boundObservables;
        if (boundObservables !== null) {
          const propertyNames = Object.keys(boundObservables);
          for (let i = 0, ii = propertyNames.length; i < ii; ++i) {
            const propertyName = propertyNames[i];
            element[propertyName] = boundObservables[propertyName];
          }
          this.boundObservables = null;
        }
        const definition = this.definition;
        if (this._template === null) {
          if (this.element.resolveTemplate) {
            this._template = this.element.resolveTemplate();
          } else if (definition.template) {
            this._template = definition.template || null;
          }
        }
        if (this._template !== null) {
          this.renderTemplate(this._template);
        }
        if (this._styles === null) {
          if (this.element.resolveStyles) {
            this._styles = this.element.resolveStyles();
          } else if (definition.styles) {
            this._styles = definition.styles || null;
          }
        }
        if (this._styles !== null) {
          this.addStyles(this._styles);
        }
        this.needsInitialization = false;
      }
      renderTemplate(template) {
        const element = this.element;
        const host = getShadowRoot(element) || element;
        if (this.view !== null) {
          this.view.dispose();
          this.view = null;
        } else if (!this.needsInitialization) {
          DOM.removeChildNodes(host);
        }
        if (template) {
          this.view = template.render(element, host, element);
        }
      }
      /**
       * Locates or creates a controller for the specified element.
       * @param element - The element to return the controller for.
       * @remarks
       * The specified element must have a {@link FASTElementDefinition}
       * registered either through the use of the {@link customElement}
       * decorator or a call to `FASTElement.define`.
       */
      static forCustomElement(element) {
        const controller = element.$fastController;
        if (controller !== void 0) {
          return controller;
        }
        const definition = FASTElementDefinition.forType(element.constructor);
        if (definition === void 0) {
          throw new Error("Missing FASTElement definition.");
        }
        return element.$fastController = new Controller(element, definition);
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/components/fast-element.js
function createFASTElement(BaseType) {
  return class extends BaseType {
    constructor() {
      super();
      Controller.forCustomElement(this);
    }
    $emit(type, detail, options) {
      return this.$fastController.emit(type, detail, options);
    }
    connectedCallback() {
      this.$fastController.onConnectedCallback();
    }
    disconnectedCallback() {
      this.$fastController.onDisconnectedCallback();
    }
    attributeChangedCallback(name2, oldValue, newValue) {
      this.$fastController.onAttributeChangedCallback(name2, oldValue, newValue);
    }
  };
}
var FASTElement;
var init_fast_element = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/components/fast-element.js"() {
    init_controller();
    init_fast_definitions();
    FASTElement = Object.assign(createFASTElement(HTMLElement), {
      /**
       * Creates a new FASTElement base class inherited from the
       * provided base type.
       * @param BaseType - The base element type to inherit from.
       */
      from(BaseType) {
        return createFASTElement(BaseType);
      },
      /**
       * Defines a platform custom element based on the provided type and definition.
       * @param type - The custom element type to define.
       * @param nameOrDef - The name of the element to define or a definition object
       * that describes the element to define.
       */
      define(type, nameOrDef) {
        return new FASTElementDefinition(type, nameOrDef).define().type;
      }
    });
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/styles/css-directive.js
var CSSDirective;
var init_css_directive = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/styles/css-directive.js"() {
    CSSDirective = class {
      /**
       * Creates a CSS fragment to interpolate into the CSS document.
       * @returns - the string to interpolate into CSS
       */
      createCSS() {
        return "";
      }
      /**
       * Creates a behavior to bind to the host element.
       * @returns - the behavior to bind to the host element, or undefined.
       */
      createBehavior() {
        return void 0;
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/styles/css.js
function collectStyles(strings, values) {
  const styles = [];
  let cssString = "";
  const behaviors = [];
  for (let i = 0, ii = strings.length - 1; i < ii; ++i) {
    cssString += strings[i];
    let value = values[i];
    if (value instanceof CSSDirective) {
      const behavior = value.createBehavior();
      value = value.createCSS();
      if (behavior) {
        behaviors.push(behavior);
      }
    }
    if (value instanceof ElementStyles || value instanceof CSSStyleSheet) {
      if (cssString.trim() !== "") {
        styles.push(cssString);
        cssString = "";
      }
      styles.push(value);
    } else {
      cssString += value;
    }
  }
  cssString += strings[strings.length - 1];
  if (cssString.trim() !== "") {
    styles.push(cssString);
  }
  return {
    styles,
    behaviors
  };
}
function css(strings, ...values) {
  const { styles, behaviors } = collectStyles(strings, values);
  const elementStyles = ElementStyles.create(styles);
  if (behaviors.length) {
    elementStyles.withBehaviors(...behaviors);
  }
  return elementStyles;
}
function cssPartial(strings, ...values) {
  const { styles, behaviors } = collectStyles(strings, values);
  return new CSSPartial(styles, behaviors);
}
var CSSPartial;
var init_css = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/styles/css.js"() {
    init_css_directive();
    init_element_styles();
    CSSPartial = class extends CSSDirective {
      constructor(styles, behaviors) {
        super();
        this.behaviors = behaviors;
        this.css = "";
        const stylesheets = styles.reduce((accumulated, current) => {
          if (typeof current === "string") {
            this.css += current;
          } else {
            accumulated.push(current);
          }
          return accumulated;
        }, []);
        if (stylesheets.length) {
          this.styles = ElementStyles.create(stylesheets);
        }
      }
      createBehavior() {
        return this;
      }
      createCSS() {
        return this.css;
      }
      bind(el) {
        if (this.styles) {
          el.$fastController.addStyles(this.styles);
        }
        if (this.behaviors.length) {
          el.$fastController.addBehaviors(this.behaviors);
        }
      }
      unbind(el) {
        if (this.styles) {
          el.$fastController.removeStyles(this.styles);
        }
        if (this.behaviors.length) {
          el.$fastController.removeBehaviors(this.behaviors);
        }
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/observation/array-change-records.js
function newSplice(index, removed, addedCount) {
  return {
    index,
    removed,
    addedCount
  };
}
function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  const rowCount = oldEnd - oldStart + 1;
  const columnCount = currentEnd - currentStart + 1;
  const distances = new Array(rowCount);
  let north;
  let west;
  for (let i = 0; i < rowCount; ++i) {
    distances[i] = new Array(columnCount);
    distances[i][0] = i;
  }
  for (let j = 0; j < columnCount; ++j) {
    distances[0][j] = j;
  }
  for (let i = 1; i < rowCount; ++i) {
    for (let j = 1; j < columnCount; ++j) {
      if (current[currentStart + j - 1] === old[oldStart + i - 1]) {
        distances[i][j] = distances[i - 1][j - 1];
      } else {
        north = distances[i - 1][j] + 1;
        west = distances[i][j - 1] + 1;
        distances[i][j] = north < west ? north : west;
      }
    }
  }
  return distances;
}
function spliceOperationsFromEditDistances(distances) {
  let i = distances.length - 1;
  let j = distances[0].length - 1;
  let current = distances[i][j];
  const edits = [];
  while (i > 0 || j > 0) {
    if (i === 0) {
      edits.push(EDIT_ADD);
      j--;
      continue;
    }
    if (j === 0) {
      edits.push(EDIT_DELETE);
      i--;
      continue;
    }
    const northWest = distances[i - 1][j - 1];
    const west = distances[i - 1][j];
    const north = distances[i][j - 1];
    let min;
    if (west < north) {
      min = west < northWest ? west : northWest;
    } else {
      min = north < northWest ? north : northWest;
    }
    if (min === northWest) {
      if (northWest === current) {
        edits.push(EDIT_LEAVE);
      } else {
        edits.push(EDIT_UPDATE);
        current = northWest;
      }
      i--;
      j--;
    } else if (min === west) {
      edits.push(EDIT_DELETE);
      i--;
      current = west;
    } else {
      edits.push(EDIT_ADD);
      j--;
      current = north;
    }
  }
  edits.reverse();
  return edits;
}
function sharedPrefix(current, old, searchLength) {
  for (let i = 0; i < searchLength; ++i) {
    if (current[i] !== old[i]) {
      return i;
    }
  }
  return searchLength;
}
function sharedSuffix(current, old, searchLength) {
  let index1 = current.length;
  let index2 = old.length;
  let count = 0;
  while (count < searchLength && current[--index1] === old[--index2]) {
    count++;
  }
  return count;
}
function intersect(start1, end1, start2, end2) {
  if (end1 < start2 || end2 < start1) {
    return -1;
  }
  if (end1 === start2 || end2 === start1) {
    return 0;
  }
  if (start1 < start2) {
    if (end1 < end2) {
      return end1 - start2;
    }
    return end2 - start2;
  }
  if (end2 < end1) {
    return end2 - start1;
  }
  return end1 - start1;
}
function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  let prefixCount = 0;
  let suffixCount = 0;
  const minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
  if (currentStart === 0 && oldStart === 0) {
    prefixCount = sharedPrefix(current, old, minLength);
  }
  if (currentEnd === current.length && oldEnd === old.length) {
    suffixCount = sharedSuffix(current, old, minLength - prefixCount);
  }
  currentStart += prefixCount;
  oldStart += prefixCount;
  currentEnd -= suffixCount;
  oldEnd -= suffixCount;
  if (currentEnd - currentStart === 0 && oldEnd - oldStart === 0) {
    return emptyArray;
  }
  if (currentStart === currentEnd) {
    const splice2 = newSplice(currentStart, [], 0);
    while (oldStart < oldEnd) {
      splice2.removed.push(old[oldStart++]);
    }
    return [splice2];
  } else if (oldStart === oldEnd) {
    return [newSplice(currentStart, [], currentEnd - currentStart)];
  }
  const ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
  const splices = [];
  let splice = void 0;
  let index = currentStart;
  let oldIndex = oldStart;
  for (let i = 0; i < ops.length; ++i) {
    switch (ops[i]) {
      case EDIT_LEAVE:
        if (splice !== void 0) {
          splices.push(splice);
          splice = void 0;
        }
        index++;
        oldIndex++;
        break;
      case EDIT_UPDATE:
        if (splice === void 0) {
          splice = newSplice(index, [], 0);
        }
        splice.addedCount++;
        index++;
        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
      case EDIT_ADD:
        if (splice === void 0) {
          splice = newSplice(index, [], 0);
        }
        splice.addedCount++;
        index++;
        break;
      case EDIT_DELETE:
        if (splice === void 0) {
          splice = newSplice(index, [], 0);
        }
        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
    }
  }
  if (splice !== void 0) {
    splices.push(splice);
  }
  return splices;
}
function mergeSplice(splices, index, removed, addedCount) {
  const splice = newSplice(index, removed, addedCount);
  let inserted = false;
  let insertionOffset = 0;
  for (let i = 0; i < splices.length; i++) {
    const current = splices[i];
    current.index += insertionOffset;
    if (inserted) {
      continue;
    }
    const intersectCount = intersect(splice.index, splice.index + splice.removed.length, current.index, current.index + current.addedCount);
    if (intersectCount >= 0) {
      splices.splice(i, 1);
      i--;
      insertionOffset -= current.addedCount - current.removed.length;
      splice.addedCount += current.addedCount - intersectCount;
      const deleteCount = splice.removed.length + current.removed.length - intersectCount;
      if (!splice.addedCount && !deleteCount) {
        inserted = true;
      } else {
        let currentRemoved = current.removed;
        if (splice.index < current.index) {
          const prepend = splice.removed.slice(0, current.index - splice.index);
          $push.apply(prepend, currentRemoved);
          currentRemoved = prepend;
        }
        if (splice.index + splice.removed.length > current.index + current.addedCount) {
          const append = splice.removed.slice(current.index + current.addedCount - splice.index);
          $push.apply(currentRemoved, append);
        }
        splice.removed = currentRemoved;
        if (current.index < splice.index) {
          splice.index = current.index;
        }
      }
    } else if (splice.index < current.index) {
      inserted = true;
      splices.splice(i, 0, splice);
      i++;
      const offset = splice.addedCount - splice.removed.length;
      current.index += offset;
      insertionOffset += offset;
    }
  }
  if (!inserted) {
    splices.push(splice);
  }
}
function createInitialSplices(changeRecords) {
  const splices = [];
  for (let i = 0, ii = changeRecords.length; i < ii; i++) {
    const record = changeRecords[i];
    mergeSplice(splices, record.index, record.removed, record.addedCount);
  }
  return splices;
}
function projectArraySplices(array, changeRecords) {
  let splices = [];
  const initialSplices = createInitialSplices(changeRecords);
  for (let i = 0, ii = initialSplices.length; i < ii; ++i) {
    const splice = initialSplices[i];
    if (splice.addedCount === 1 && splice.removed.length === 1) {
      if (splice.removed[0] !== array[splice.index]) {
        splices.push(splice);
      }
      continue;
    }
    splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount, splice.removed, 0, splice.removed.length));
  }
  return splices;
}
var EDIT_LEAVE, EDIT_UPDATE, EDIT_ADD, EDIT_DELETE, $push;
var init_array_change_records = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/observation/array-change-records.js"() {
    init_platform();
    EDIT_LEAVE = 0;
    EDIT_UPDATE = 1;
    EDIT_ADD = 2;
    EDIT_DELETE = 3;
    $push = Array.prototype.push;
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/observation/array-observer.js
function adjustIndex(changeRecord, array) {
  let index = changeRecord.index;
  const arrayLength = array.length;
  if (index > arrayLength) {
    index = arrayLength - changeRecord.addedCount;
  } else if (index < 0) {
    index = arrayLength + changeRecord.removed.length + index - changeRecord.addedCount;
  }
  if (index < 0) {
    index = 0;
  }
  changeRecord.index = index;
  return changeRecord;
}
function enableArrayObservation() {
  if (arrayObservationEnabled) {
    return;
  }
  arrayObservationEnabled = true;
  Observable.setArrayObserverFactory((collection) => {
    return new ArrayObserver(collection);
  });
  const proto = Array.prototype;
  if (proto.$fastPatch) {
    return;
  }
  Reflect.defineProperty(proto, "$fastPatch", {
    value: 1,
    enumerable: false
  });
  const pop = proto.pop;
  const push = proto.push;
  const reverse = proto.reverse;
  const shift = proto.shift;
  const sort = proto.sort;
  const splice = proto.splice;
  const unshift = proto.unshift;
  proto.pop = function() {
    const notEmpty = this.length > 0;
    const methodCallResult = pop.apply(this, arguments);
    const o = this.$fastController;
    if (o !== void 0 && notEmpty) {
      o.addSplice(newSplice(this.length, [methodCallResult], 0));
    }
    return methodCallResult;
  };
  proto.push = function() {
    const methodCallResult = push.apply(this, arguments);
    const o = this.$fastController;
    if (o !== void 0) {
      o.addSplice(adjustIndex(newSplice(this.length - arguments.length, [], arguments.length), this));
    }
    return methodCallResult;
  };
  proto.reverse = function() {
    let oldArray;
    const o = this.$fastController;
    if (o !== void 0) {
      o.flush();
      oldArray = this.slice();
    }
    const methodCallResult = reverse.apply(this, arguments);
    if (o !== void 0) {
      o.reset(oldArray);
    }
    return methodCallResult;
  };
  proto.shift = function() {
    const notEmpty = this.length > 0;
    const methodCallResult = shift.apply(this, arguments);
    const o = this.$fastController;
    if (o !== void 0 && notEmpty) {
      o.addSplice(newSplice(0, [methodCallResult], 0));
    }
    return methodCallResult;
  };
  proto.sort = function() {
    let oldArray;
    const o = this.$fastController;
    if (o !== void 0) {
      o.flush();
      oldArray = this.slice();
    }
    const methodCallResult = sort.apply(this, arguments);
    if (o !== void 0) {
      o.reset(oldArray);
    }
    return methodCallResult;
  };
  proto.splice = function() {
    const methodCallResult = splice.apply(this, arguments);
    const o = this.$fastController;
    if (o !== void 0) {
      o.addSplice(adjustIndex(newSplice(+arguments[0], methodCallResult, arguments.length > 2 ? arguments.length - 2 : 0), this));
    }
    return methodCallResult;
  };
  proto.unshift = function() {
    const methodCallResult = unshift.apply(this, arguments);
    const o = this.$fastController;
    if (o !== void 0) {
      o.addSplice(adjustIndex(newSplice(0, [], arguments.length), this));
    }
    return methodCallResult;
  };
}
var arrayObservationEnabled, ArrayObserver;
var init_array_observer = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/observation/array-observer.js"() {
    init_dom();
    init_array_change_records();
    init_notifier();
    init_observable();
    arrayObservationEnabled = false;
    ArrayObserver = class extends SubscriberSet {
      constructor(source) {
        super(source);
        this.oldCollection = void 0;
        this.splices = void 0;
        this.needsQueue = true;
        this.call = this.flush;
        Reflect.defineProperty(source, "$fastController", {
          value: this,
          enumerable: false
        });
      }
      subscribe(subscriber) {
        this.flush();
        super.subscribe(subscriber);
      }
      addSplice(splice) {
        if (this.splices === void 0) {
          this.splices = [splice];
        } else {
          this.splices.push(splice);
        }
        if (this.needsQueue) {
          this.needsQueue = false;
          DOM.queueUpdate(this);
        }
      }
      reset(oldCollection) {
        this.oldCollection = oldCollection;
        if (this.needsQueue) {
          this.needsQueue = false;
          DOM.queueUpdate(this);
        }
      }
      flush() {
        const splices = this.splices;
        const oldCollection = this.oldCollection;
        if (splices === void 0 && oldCollection === void 0) {
          return;
        }
        this.needsQueue = true;
        this.splices = void 0;
        this.oldCollection = void 0;
        const finalSplices = oldCollection === void 0 ? projectArraySplices(this.source, splices) : calcSplices(this.source, 0, this.source.length, oldCollection, 0, oldCollection.length);
        this.notify(finalSplices);
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/templating/ref.js
function ref(propertyName) {
  return new AttachedBehaviorHTMLDirective("fast-ref", RefBehavior, propertyName);
}
var RefBehavior;
var init_ref = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/templating/ref.js"() {
    init_html_directive();
    RefBehavior = class {
      /**
       * Creates an instance of RefBehavior.
       * @param target - The element to reference.
       * @param propertyName - The name of the property to assign the reference to.
       */
      constructor(target2, propertyName) {
        this.target = target2;
        this.propertyName = propertyName;
      }
      /**
       * Bind this behavior to the source.
       * @param source - The source to bind to.
       * @param context - The execution context that the binding is operating within.
       */
      bind(source) {
        source[this.propertyName] = this.target;
      }
      /**
       * Unbinds this behavior from the source.
       * @param source - The source to unbind from.
       */
      /* eslint-disable-next-line @typescript-eslint/no-empty-function */
      unbind() {
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/interfaces.js
var isFunction;
var init_interfaces = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/interfaces.js"() {
    isFunction = (object) => typeof object === "function";
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/templating/when.js
function normalizeBinding(value) {
  return value === void 0 ? noTemplate : isFunction(value) ? value : () => value;
}
function when(binding, templateOrTemplateBinding, elseTemplateOrTemplateBinding) {
  const dataBinding = isFunction(binding) ? binding : () => binding;
  const templateBinding = normalizeBinding(templateOrTemplateBinding);
  const elseBinding = normalizeBinding(elseTemplateOrTemplateBinding);
  return (source, context) => dataBinding(source, context) ? templateBinding(source, context) : elseBinding(source, context);
}
var noTemplate;
var init_when = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/templating/when.js"() {
    init_interfaces();
    noTemplate = () => null;
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/templating/repeat.js
function bindWithoutPositioning(view, items, index, context) {
  view.bind(items[index], context);
}
function bindWithPositioning(view, items, index, context) {
  const childContext = Object.create(context);
  childContext.index = index;
  childContext.length = items.length;
  view.bind(items[index], childContext);
}
var defaultRepeatOptions, RepeatBehavior, RepeatDirective;
var init_repeat = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/templating/repeat.js"() {
    init_dom();
    init_observable();
    init_array_observer();
    init_platform();
    init_html_directive();
    init_view();
    defaultRepeatOptions = Object.freeze({
      positioning: false,
      recycle: true
    });
    RepeatBehavior = class {
      /**
       * Creates an instance of RepeatBehavior.
       * @param location - The location in the DOM to render the repeat.
       * @param itemsBinding - The array to render.
       * @param isItemsBindingVolatile - Indicates whether the items binding has volatile dependencies.
       * @param templateBinding - The template to render for each item.
       * @param isTemplateBindingVolatile - Indicates whether the template binding has volatile dependencies.
       * @param options - Options used to turn on special repeat features.
       */
      constructor(location2, itemsBinding, isItemsBindingVolatile, templateBinding, isTemplateBindingVolatile, options) {
        this.location = location2;
        this.itemsBinding = itemsBinding;
        this.templateBinding = templateBinding;
        this.options = options;
        this.source = null;
        this.views = [];
        this.items = null;
        this.itemsObserver = null;
        this.originalContext = void 0;
        this.childContext = void 0;
        this.bindView = bindWithoutPositioning;
        this.itemsBindingObserver = Observable.binding(itemsBinding, this, isItemsBindingVolatile);
        this.templateBindingObserver = Observable.binding(templateBinding, this, isTemplateBindingVolatile);
        if (options.positioning) {
          this.bindView = bindWithPositioning;
        }
      }
      /**
       * Bind this behavior to the source.
       * @param source - The source to bind to.
       * @param context - The execution context that the binding is operating within.
       */
      bind(source, context) {
        this.source = source;
        this.originalContext = context;
        this.childContext = Object.create(context);
        this.childContext.parent = source;
        this.childContext.parentContext = this.originalContext;
        this.items = this.itemsBindingObserver.observe(source, this.originalContext);
        this.template = this.templateBindingObserver.observe(source, this.originalContext);
        this.observeItems(true);
        this.refreshAllViews();
      }
      /**
       * Unbinds this behavior from the source.
       * @param source - The source to unbind from.
       */
      unbind() {
        this.source = null;
        this.items = null;
        if (this.itemsObserver !== null) {
          this.itemsObserver.unsubscribe(this);
        }
        this.unbindAllViews();
        this.itemsBindingObserver.disconnect();
        this.templateBindingObserver.disconnect();
      }
      /** @internal */
      handleChange(source, args) {
        if (source === this.itemsBinding) {
          this.items = this.itemsBindingObserver.observe(this.source, this.originalContext);
          this.observeItems();
          this.refreshAllViews();
        } else if (source === this.templateBinding) {
          this.template = this.templateBindingObserver.observe(this.source, this.originalContext);
          this.refreshAllViews(true);
        } else {
          this.updateViews(args);
        }
      }
      observeItems(force = false) {
        if (!this.items) {
          this.items = emptyArray;
          return;
        }
        const oldObserver = this.itemsObserver;
        const newObserver = this.itemsObserver = Observable.getNotifier(this.items);
        const hasNewObserver = oldObserver !== newObserver;
        if (hasNewObserver && oldObserver !== null) {
          oldObserver.unsubscribe(this);
        }
        if (hasNewObserver || force) {
          newObserver.subscribe(this);
        }
      }
      updateViews(splices) {
        const childContext = this.childContext;
        const views = this.views;
        const bindView = this.bindView;
        const items = this.items;
        const template = this.template;
        const recycle = this.options.recycle;
        const leftoverViews = [];
        let leftoverIndex = 0;
        let availableViews = 0;
        for (let i = 0, ii = splices.length; i < ii; ++i) {
          const splice = splices[i];
          const removed = splice.removed;
          let removeIndex = 0;
          let addIndex = splice.index;
          const end = addIndex + splice.addedCount;
          const removedViews = views.splice(splice.index, removed.length);
          const totalAvailableViews = availableViews = leftoverViews.length + removedViews.length;
          for (; addIndex < end; ++addIndex) {
            const neighbor = views[addIndex];
            const location2 = neighbor ? neighbor.firstChild : this.location;
            let view;
            if (recycle && availableViews > 0) {
              if (removeIndex <= totalAvailableViews && removedViews.length > 0) {
                view = removedViews[removeIndex];
                removeIndex++;
              } else {
                view = leftoverViews[leftoverIndex];
                leftoverIndex++;
              }
              availableViews--;
            } else {
              view = template.create();
            }
            views.splice(addIndex, 0, view);
            bindView(view, items, addIndex, childContext);
            view.insertBefore(location2);
          }
          if (removedViews[removeIndex]) {
            leftoverViews.push(...removedViews.slice(removeIndex));
          }
        }
        for (let i = leftoverIndex, ii = leftoverViews.length; i < ii; ++i) {
          leftoverViews[i].dispose();
        }
        if (this.options.positioning) {
          for (let i = 0, ii = views.length; i < ii; ++i) {
            const currentContext = views[i].context;
            currentContext.length = ii;
            currentContext.index = i;
          }
        }
      }
      refreshAllViews(templateChanged = false) {
        const items = this.items;
        const childContext = this.childContext;
        const template = this.template;
        const location2 = this.location;
        const bindView = this.bindView;
        let itemsLength = items.length;
        let views = this.views;
        let viewsLength = views.length;
        if (itemsLength === 0 || templateChanged || !this.options.recycle) {
          HTMLView.disposeContiguousBatch(views);
          viewsLength = 0;
        }
        if (viewsLength === 0) {
          this.views = views = new Array(itemsLength);
          for (let i = 0; i < itemsLength; ++i) {
            const view = template.create();
            bindView(view, items, i, childContext);
            views[i] = view;
            view.insertBefore(location2);
          }
        } else {
          let i = 0;
          for (; i < itemsLength; ++i) {
            if (i < viewsLength) {
              const view = views[i];
              bindView(view, items, i, childContext);
            } else {
              const view = template.create();
              bindView(view, items, i, childContext);
              views.push(view);
              view.insertBefore(location2);
            }
          }
          const removed = views.splice(i, viewsLength - i);
          for (i = 0, itemsLength = removed.length; i < itemsLength; ++i) {
            removed[i].dispose();
          }
        }
      }
      unbindAllViews() {
        const views = this.views;
        for (let i = 0, ii = views.length; i < ii; ++i) {
          views[i].unbind();
        }
      }
    };
    RepeatDirective = class extends HTMLDirective {
      /**
       * Creates an instance of RepeatDirective.
       * @param itemsBinding - The binding that provides the array to render.
       * @param templateBinding - The template binding used to obtain a template to render for each item in the array.
       * @param options - Options used to turn on special repeat features.
       */
      constructor(itemsBinding, templateBinding, options) {
        super();
        this.itemsBinding = itemsBinding;
        this.templateBinding = templateBinding;
        this.options = options;
        this.createPlaceholder = DOM.createBlockPlaceholder;
        enableArrayObservation();
        this.isItemsBindingVolatile = Observable.isVolatileBinding(itemsBinding);
        this.isTemplateBindingVolatile = Observable.isVolatileBinding(templateBinding);
      }
      /**
       * Creates a behavior for the provided target node.
       * @param target - The node instance to create the behavior for.
       */
      createBehavior(target2) {
        return new RepeatBehavior(target2, this.itemsBinding, this.isItemsBindingVolatile, this.templateBinding, this.isTemplateBindingVolatile, this.options);
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/templating/node-observation.js
function elements(selector) {
  if (selector) {
    return function(value, index, array) {
      return value.nodeType === 1 && value.matches(selector);
    };
  }
  return function(value, index, array) {
    return value.nodeType === 1;
  };
}
var NodeObservationBehavior;
var init_node_observation = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/templating/node-observation.js"() {
    init_observable();
    init_platform();
    NodeObservationBehavior = class {
      /**
       * Creates an instance of NodeObservationBehavior.
       * @param target - The target to assign the nodes property on.
       * @param options - The options to use in configuring node observation.
       */
      constructor(target2, options) {
        this.target = target2;
        this.options = options;
        this.source = null;
      }
      /**
       * Bind this behavior to the source.
       * @param source - The source to bind to.
       * @param context - The execution context that the binding is operating within.
       */
      bind(source) {
        const name2 = this.options.property;
        this.shouldUpdate = Observable.getAccessors(source).some((x) => x.name === name2);
        this.source = source;
        this.updateTarget(this.computeNodes());
        if (this.shouldUpdate) {
          this.observe();
        }
      }
      /**
       * Unbinds this behavior from the source.
       * @param source - The source to unbind from.
       */
      unbind() {
        this.updateTarget(emptyArray);
        this.source = null;
        if (this.shouldUpdate) {
          this.disconnect();
        }
      }
      /** @internal */
      handleEvent() {
        this.updateTarget(this.computeNodes());
      }
      computeNodes() {
        let nodes = this.getNodes();
        if (this.options.filter !== void 0) {
          nodes = nodes.filter(this.options.filter);
        }
        return nodes;
      }
      updateTarget(value) {
        this.source[this.options.property] = value;
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/templating/slotted.js
function slotted(propertyOrOptions) {
  if (typeof propertyOrOptions === "string") {
    propertyOrOptions = { property: propertyOrOptions };
  }
  return new AttachedBehaviorHTMLDirective("fast-slotted", SlottedBehavior, propertyOrOptions);
}
var SlottedBehavior;
var init_slotted = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/templating/slotted.js"() {
    init_html_directive();
    init_node_observation();
    SlottedBehavior = class extends NodeObservationBehavior {
      /**
       * Creates an instance of SlottedBehavior.
       * @param target - The slot element target to observe.
       * @param options - The options to use when observing the slot.
       */
      constructor(target2, options) {
        super(target2, options);
      }
      /**
       * Begins observation of the nodes.
       */
      observe() {
        this.target.addEventListener("slotchange", this);
      }
      /**
       * Disconnects observation of the nodes.
       */
      disconnect() {
        this.target.removeEventListener("slotchange", this);
      }
      /**
       * Retrieves the nodes that should be assigned to the target.
       */
      getNodes() {
        return this.target.assignedNodes(this.options);
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/templating/children.js
function children(propertyOrOptions) {
  if (typeof propertyOrOptions === "string") {
    propertyOrOptions = {
      property: propertyOrOptions
    };
  }
  return new AttachedBehaviorHTMLDirective("fast-children", ChildrenBehavior, propertyOrOptions);
}
var ChildrenBehavior;
var init_children = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/templating/children.js"() {
    init_html_directive();
    init_node_observation();
    ChildrenBehavior = class extends NodeObservationBehavior {
      /**
       * Creates an instance of ChildrenBehavior.
       * @param target - The element target to observe children on.
       * @param options - The options to use when observing the element children.
       */
      constructor(target2, options) {
        super(target2, options);
        this.observer = null;
        options.childList = true;
      }
      /**
       * Begins observation of the nodes.
       */
      observe() {
        if (this.observer === null) {
          this.observer = new MutationObserver(this.handleEvent.bind(this));
        }
        this.observer.observe(this.target, this.options);
      }
      /**
       * Disconnects observation of the nodes.
       */
      disconnect() {
        this.observer.disconnect();
      }
      /**
       * Retrieves the nodes that should be assigned to the target.
       */
      getNodes() {
        if ("subtree" in this.options) {
          return Array.from(this.target.querySelectorAll(this.options.selector));
        }
        return Array.from(this.target.childNodes);
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-element/dist/esm/index.js
var init_esm = __esm({
  "../../node_modules/@microsoft/fast-element/dist/esm/index.js"() {
    init_platform();
    init_template();
    init_fast_element();
    init_fast_definitions();
    init_attributes();
    init_controller();
    init_compiler();
    init_element_styles();
    init_css();
    init_css_directive();
    init_view();
    init_observable();
    init_notifier();
    init_dom();
    init_binding();
    init_html_directive();
    init_ref();
    init_when();
    init_repeat();
    init_slotted();
    init_children();
    init_node_observation();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/patterns/start-end.js
var StartEnd, endSlotTemplate, startSlotTemplate, endTemplate, startTemplate;
var init_start_end = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/patterns/start-end.js"() {
    init_esm();
    StartEnd = class {
      handleStartContentChange() {
        this.startContainer.classList.toggle("start", this.start.assignedNodes().length > 0);
      }
      handleEndContentChange() {
        this.endContainer.classList.toggle("end", this.end.assignedNodes().length > 0);
      }
    };
    endSlotTemplate = (context, definition) => html`
    <span
        part="end"
        ${ref("endContainer")}
        class=${(x) => definition.end ? "end" : void 0}
    >
        <slot name="end" ${ref("end")} @slotchange="${(x) => x.handleEndContentChange()}">
            ${definition.end || ""}
        </slot>
    </span>
`;
    startSlotTemplate = (context, definition) => html`
    <span
        part="start"
        ${ref("startContainer")}
        class="${(x) => definition.start ? "start" : void 0}"
    >
        <slot
            name="start"
            ${ref("start")}
            @slotchange="${(x) => x.handleStartContentChange()}"
        >
            ${definition.start || ""}
        </slot>
    </span>
`;
    endTemplate = html`
    <span part="end" ${ref("endContainer")}>
        <slot
            name="end"
            ${ref("end")}
            @slotchange="${(x) => x.handleEndContentChange()}"
        ></slot>
    </span>
`;
    startTemplate = html`
    <span part="start" ${ref("startContainer")}>
        <slot
            name="start"
            ${ref("start")}
            @slotchange="${(x) => x.handleStartContentChange()}"
        ></slot>
    </span>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/accordion-item/accordion-item.template.js
var accordionItemTemplate;
var init_accordion_item_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/accordion-item/accordion-item.template.js"() {
    init_esm();
    init_start_end();
    accordionItemTemplate = (context, definition) => html`
    <template class="${(x) => x.expanded ? "expanded" : ""}">
        <div
            class="heading"
            part="heading"
            role="heading"
            aria-level="${(x) => x.headinglevel}"
        >
            <button
                class="button"
                part="button"
                ${ref("expandbutton")}
                aria-expanded="${(x) => x.expanded}"
                aria-controls="${(x) => x.id}-panel"
                id="${(x) => x.id}"
                @click="${(x, c) => x.clickHandler(c.event)}"
            >
                <span class="heading-content" part="heading-content">
                    <slot name="heading"></slot>
                </span>
            </button>
            ${startSlotTemplate(context, definition)}
            ${endSlotTemplate(context, definition)}
            <span class="icon" part="icon" aria-hidden="true">
                <slot name="expanded-icon" part="expanded-icon">
                    ${definition.expandedIcon || ""}
                </slot>
                <slot name="collapsed-icon" part="collapsed-icon">
                    ${definition.collapsedIcon || ""}
                </slot>
            <span>
        </div>
        <div
            class="region"
            part="region"
            id="${(x) => x.id}-panel"
            role="region"
            aria-labelledby="${(x) => x.id}"
        >
            <slot></slot>
        </div>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/node_modules/tslib/tslib.es6.js
function __decorate(decorators, target2, key2, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key2) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key2, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key2, r) : d(target2, key2)) || r;
  return c > 3 && r && Object.defineProperty(target2, key2, r), r;
}
var init_tslib_es6 = __esm({
  "../../node_modules/@microsoft/fast-foundation/node_modules/tslib/tslib.es6.js"() {
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/di/di.js
function cloneArrayWithPossibleProps(source) {
  const clone = source.slice();
  const keys = Object.keys(source);
  const len = keys.length;
  let key2;
  for (let i = 0; i < len; ++i) {
    key2 = keys[i];
    if (!isArrayIndex(key2)) {
      clone[key2] = source[key2];
    }
  }
  return clone;
}
function getParamTypes(key2) {
  return (Type) => {
    return Reflect.getOwnMetadata(key2, Type);
  };
}
function createResolver(getter) {
  return function(key2) {
    const resolver = function(target2, property, descriptor) {
      DI.inject(resolver)(target2, property, descriptor);
    };
    resolver.$isResolver = true;
    resolver.resolve = function(handler, requestor) {
      return getter(key2, handler, requestor);
    };
    return resolver;
  };
}
function createAllResolver(getter) {
  return function(key2, searchAncestors) {
    searchAncestors = !!searchAncestors;
    const resolver = function(target2, property, descriptor) {
      DI.inject(resolver)(target2, property, descriptor);
    };
    resolver.$isResolver = true;
    resolver.resolve = function(handler, requestor) {
      return getter(key2, handler, requestor, searchAncestors);
    };
    return resolver;
  };
}
function ignore(target2, property, descriptor) {
  DI.inject(ignore)(target2, property, descriptor);
}
function createNewInstance(key2, handler) {
  return handler.getFactory(key2).construct(handler);
}
function containerGetKey(d) {
  return this.get(d);
}
function transformInstance(inst, transform2) {
  return transform2(inst);
}
function isRegistry(obj) {
  return typeof obj.register === "function";
}
function isSelfRegistry(obj) {
  return isRegistry(obj) && typeof obj.registerInRequestor === "boolean";
}
function isRegisterInRequester(obj) {
  return isSelfRegistry(obj) && obj.registerInRequestor;
}
function isClass(obj) {
  return obj.prototype !== void 0;
}
function cacheCallbackResult(fun) {
  return function(handler, requestor, resolver) {
    if (cache.has(resolver)) {
      return cache.get(resolver);
    }
    const t = fun(handler, requestor, resolver);
    cache.set(resolver, t);
    return t;
  };
}
function validateKey(key2) {
  if (key2 === null || key2 === void 0) {
    throw new Error("key/value cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?");
  }
}
function buildAllResponse(resolver, handler, requestor) {
  if (resolver instanceof ResolverImpl && resolver.strategy === 4) {
    const state = resolver.state;
    let i = state.length;
    const results = new Array(i);
    while (i--) {
      results[i] = state[i].resolve(handler, requestor);
    }
    return results;
  }
  return [resolver.resolve(handler, requestor)];
}
function isObject8(value) {
  return typeof value === "object" && value !== null || typeof value === "function";
}
function isArrayIndex(value) {
  switch (typeof value) {
    case "number":
      return value >= 0 && (value | 0) === value;
    case "string": {
      const result = isNumericLookup[value];
      if (result !== void 0) {
        return result;
      }
      const length = value.length;
      if (length === 0) {
        return isNumericLookup[value] = false;
      }
      let ch = 0;
      for (let i = 0; i < length; ++i) {
        ch = value.charCodeAt(i);
        if (i === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
          return isNumericLookup[value] = false;
        }
      }
      return isNumericLookup[value] = true;
    }
    default:
      return false;
  }
}
var metadataByTarget, ResolverBuilder, DefaultResolver, ContainerConfiguration, dependencyLookup, rootDOMContainer, DI, Container, inject, defaultSingletonOptions, all, lazy, optional, newInstanceForScope, newInstanceOf, ResolverImpl, FactoryImpl, containerResolver, InstrinsicTypeNames, DILocateParentEventType, factories, ContainerImpl, cache, Registration, defaultFriendlyName, isNativeFunction, isNumericLookup;
var init_di = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/di/di.js"() {
    init_esm();
    metadataByTarget = /* @__PURE__ */ new Map();
    if (!("metadata" in Reflect)) {
      Reflect.metadata = function(key2, value) {
        return function(target2) {
          Reflect.defineMetadata(key2, value, target2);
        };
      };
      Reflect.defineMetadata = function(key2, value, target2) {
        let metadata = metadataByTarget.get(target2);
        if (metadata === void 0) {
          metadataByTarget.set(target2, metadata = /* @__PURE__ */ new Map());
        }
        metadata.set(key2, value);
      };
      Reflect.getOwnMetadata = function(key2, target2) {
        const metadata = metadataByTarget.get(target2);
        if (metadata !== void 0) {
          return metadata.get(key2);
        }
        return void 0;
      };
    }
    ResolverBuilder = class {
      /**
       *
       * @param container - The container to create resolvers for.
       * @param key - The key to register resolvers under.
       */
      constructor(container, key2) {
        this.container = container;
        this.key = key2;
      }
      /**
       * Creates a resolver for an existing object instance.
       * @param value - The instance to resolve.
       * @returns The resolver.
       */
      instance(value) {
        return this.registerResolver(0, value);
      }
      /**
       * Creates a resolver that enforces a singleton lifetime.
       * @param value - The type to create and cache the singleton for.
       * @returns The resolver.
       */
      singleton(value) {
        return this.registerResolver(1, value);
      }
      /**
       * Creates a resolver that creates a new instance for every dependency request.
       * @param value - The type to create instances of.
       * @returns - The resolver.
       */
      transient(value) {
        return this.registerResolver(2, value);
      }
      /**
       * Creates a resolver that invokes a callback function for every dependency resolution
       * request, allowing custom logic to return the dependency.
       * @param value - The callback to call during resolution.
       * @returns The resolver.
       */
      callback(value) {
        return this.registerResolver(3, value);
      }
      /**
       * Creates a resolver that invokes a callback function the first time that a dependency
       * resolution is requested. The returned value is then cached and provided for all
       * subsequent requests.
       * @param value - The callback to call during the first resolution.
       * @returns The resolver.
       */
      cachedCallback(value) {
        return this.registerResolver(3, cacheCallbackResult(value));
      }
      /**
       * Aliases the current key to a different key.
       * @param destinationKey - The key to point the alias to.
       * @returns The resolver.
       */
      aliasTo(destinationKey) {
        return this.registerResolver(5, destinationKey);
      }
      registerResolver(strategy, state) {
        const { container, key: key2 } = this;
        this.container = this.key = void 0;
        return container.registerResolver(key2, new ResolverImpl(key2, strategy, state));
      }
    };
    DefaultResolver = Object.freeze({
      /**
       * Disables auto-registration and throws for all un-registered dependencies.
       * @param key - The key to create the resolver for.
       */
      none(key2) {
        throw Error(`${key2.toString()} not registered, did you forget to add @singleton()?`);
      },
      /**
       * Provides default singleton resolution behavior during auto-registration.
       * @param key - The key to create the resolver for.
       * @returns The resolver.
       */
      singleton(key2) {
        return new ResolverImpl(key2, 1, key2);
      },
      /**
       * Provides default transient resolution behavior during auto-registration.
       * @param key - The key to create the resolver for.
       * @returns The resolver.
       */
      transient(key2) {
        return new ResolverImpl(key2, 2, key2);
      }
    });
    ContainerConfiguration = Object.freeze({
      /**
       * The default configuration used when creating a DOM-disconnected container.
       * @remarks
       * The default creates a root container, with no parent container. It does not handle
       * owner requests and it uses singleton resolution behavior for auto-registration.
       */
      default: Object.freeze({
        parentLocator: () => null,
        responsibleForOwnerRequests: false,
        defaultResolver: DefaultResolver.singleton
      })
    });
    dependencyLookup = /* @__PURE__ */ new Map();
    rootDOMContainer = null;
    DI = Object.freeze({
      /**
       * Creates a new dependency injection container.
       * @param config - The configuration for the container.
       * @returns A newly created dependency injection container.
       */
      createContainer(config) {
        return new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config));
      },
      /**
       * Finds the dependency injection container responsible for providing dependencies
       * to the specified node.
       * @param node - The node to find the responsible container for.
       * @returns The container responsible for providing dependencies to the node.
       * @remarks
       * This will be the same as the parent container if the specified node
       * does not itself host a container configured with responsibleForOwnerRequests.
       */
      findResponsibleContainer(node) {
        const owned = node.$$container$$;
        if (owned && owned.responsibleForOwnerRequests) {
          return owned;
        }
        return DI.findParentContainer(node);
      },
      /**
       * Find the dependency injection container up the DOM tree from this node.
       * @param node - The node to find the parent container for.
       * @returns The parent container of this node.
       * @remarks
       * This will be the same as the responsible container if the specified node
       * does not itself host a container configured with responsibleForOwnerRequests.
       */
      findParentContainer(node) {
        const event = new CustomEvent(DILocateParentEventType, {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: { container: void 0 }
        });
        node.dispatchEvent(event);
        return event.detail.container || DI.getOrCreateDOMContainer();
      },
      /**
       * Returns a dependency injection container if one is explicitly owned by the specified
       * node. If one is not owned, then a new container is created and assigned to the node.
       * @param node - The node to find or create the container for.
       * @param config - The configuration for the container if one needs to be created.
       * @returns The located or created container.
       * @remarks
       * This API does not search for a responsible or parent container. It looks only for a container
       * directly defined on the specified node and creates one at that location if one does not
       * already exist.
       */
      getOrCreateDOMContainer(node, config) {
        if (!node) {
          return rootDOMContainer || (rootDOMContainer = new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config, {
            parentLocator: () => null
          })));
        }
        return node.$$container$$ || new ContainerImpl(node, Object.assign({}, ContainerConfiguration.default, config, {
          parentLocator: DI.findParentContainer
        }));
      },
      /**
       * Gets the "design:paramtypes" metadata for the specified type.
       * @param Type - The type to get the metadata for.
       * @returns The metadata array or undefined if no metadata is found.
       */
      getDesignParamtypes: getParamTypes("design:paramtypes"),
      /**
       * Gets the "di:paramtypes" metadata for the specified type.
       * @param Type - The type to get the metadata for.
       * @returns The metadata array or undefined if no metadata is found.
       */
      getAnnotationParamtypes: getParamTypes("di:paramtypes"),
      /**
       *
       * @param Type - Gets the "di:paramtypes" metadata for the specified type. If none is found,
       * an empty metadata array is created and added.
       * @returns The metadata array.
       */
      getOrCreateAnnotationParamTypes(Type) {
        let annotationParamtypes = this.getAnnotationParamtypes(Type);
        if (annotationParamtypes === void 0) {
          Reflect.defineMetadata("di:paramtypes", annotationParamtypes = [], Type);
        }
        return annotationParamtypes;
      },
      /**
       * Gets the dependency keys representing what is needed to instantiate the specified type.
       * @param Type - The type to get the dependencies for.
       * @returns An array of dependency keys.
       */
      getDependencies(Type) {
        let dependencies = dependencyLookup.get(Type);
        if (dependencies === void 0) {
          const inject2 = Type.inject;
          if (inject2 === void 0) {
            const designParamtypes = DI.getDesignParamtypes(Type);
            const annotationParamtypes = DI.getAnnotationParamtypes(Type);
            if (designParamtypes === void 0) {
              if (annotationParamtypes === void 0) {
                const Proto = Object.getPrototypeOf(Type);
                if (typeof Proto === "function" && Proto !== Function.prototype) {
                  dependencies = cloneArrayWithPossibleProps(DI.getDependencies(Proto));
                } else {
                  dependencies = [];
                }
              } else {
                dependencies = cloneArrayWithPossibleProps(annotationParamtypes);
              }
            } else if (annotationParamtypes === void 0) {
              dependencies = cloneArrayWithPossibleProps(designParamtypes);
            } else {
              dependencies = cloneArrayWithPossibleProps(designParamtypes);
              let len = annotationParamtypes.length;
              let auAnnotationParamtype;
              for (let i = 0; i < len; ++i) {
                auAnnotationParamtype = annotationParamtypes[i];
                if (auAnnotationParamtype !== void 0) {
                  dependencies[i] = auAnnotationParamtype;
                }
              }
              const keys = Object.keys(annotationParamtypes);
              len = keys.length;
              let key2;
              for (let i = 0; i < len; ++i) {
                key2 = keys[i];
                if (!isArrayIndex(key2)) {
                  dependencies[key2] = annotationParamtypes[key2];
                }
              }
            }
          } else {
            dependencies = cloneArrayWithPossibleProps(inject2);
          }
          dependencyLookup.set(Type, dependencies);
        }
        return dependencies;
      },
      /**
       * Defines a property on a web component class. The value of this property will
       * be resolved from the dependency injection container responsible for the element
       * instance, based on where it is connected in the DOM.
       * @param target - The target to define the property on.
       * @param propertyName - The name of the property to define.
       * @param key - The dependency injection key.
       * @param respectConnection - Indicates whether or not to update the property value if the
       * hosting component is disconnected and then re-connected at a different location in the DOM.
       * @remarks
       * The respectConnection option is only applicable to elements that descend from FASTElement.
       */
      defineProperty(target2, propertyName, key2, respectConnection = false) {
        const diPropertyKey = `$di_${propertyName}`;
        Reflect.defineProperty(target2, propertyName, {
          get: function() {
            let value = this[diPropertyKey];
            if (value === void 0) {
              const container = this instanceof HTMLElement ? DI.findResponsibleContainer(this) : DI.getOrCreateDOMContainer();
              value = container.get(key2);
              this[diPropertyKey] = value;
              if (respectConnection && this instanceof FASTElement) {
                const notifier = this.$fastController;
                const handleChange = () => {
                  const newContainer = DI.findResponsibleContainer(this);
                  const newValue = newContainer.get(key2);
                  const oldValue = this[diPropertyKey];
                  if (newValue !== oldValue) {
                    this[diPropertyKey] = value;
                    notifier.notify(propertyName);
                  }
                };
                notifier.subscribe({ handleChange }, "isConnected");
              }
            }
            return value;
          }
        });
      },
      /**
       * Creates a dependency injection key.
       * @param nameConfigOrCallback - A friendly name for the key or a lambda that configures a
       * default resolution for the dependency.
       * @param configuror - If a friendly name was provided for the first parameter, then an optional
       * lambda that configures a default resolution for the dependency can be provided second.
       * @returns The created key.
       * @remarks
       * The created key can be used as a property decorator or constructor parameter decorator,
       * in addition to its standard use in an inject array or through direct container APIs.
       */
      createInterface(nameConfigOrCallback, configuror) {
        const configure = typeof nameConfigOrCallback === "function" ? nameConfigOrCallback : configuror;
        const friendlyName = typeof nameConfigOrCallback === "string" ? nameConfigOrCallback : nameConfigOrCallback && "friendlyName" in nameConfigOrCallback ? nameConfigOrCallback.friendlyName || defaultFriendlyName : defaultFriendlyName;
        const respectConnection = typeof nameConfigOrCallback === "string" ? false : nameConfigOrCallback && "respectConnection" in nameConfigOrCallback ? nameConfigOrCallback.respectConnection || false : false;
        const Interface = function(target2, property, index) {
          if (target2 == null || new.target !== void 0) {
            throw new Error(`No registration for interface: '${Interface.friendlyName}'`);
          }
          if (property) {
            DI.defineProperty(target2, property, Interface, respectConnection);
          } else {
            const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target2);
            annotationParamtypes[index] = Interface;
          }
        };
        Interface.$isInterface = true;
        Interface.friendlyName = friendlyName == null ? "(anonymous)" : friendlyName;
        if (configure != null) {
          Interface.register = function(container, key2) {
            return configure(new ResolverBuilder(container, key2 !== null && key2 !== void 0 ? key2 : Interface));
          };
        }
        Interface.toString = function toString() {
          return `InterfaceSymbol<${Interface.friendlyName}>`;
        };
        return Interface;
      },
      /**
       * A decorator that specifies what to inject into its target.
       * @param dependencies - The dependencies to inject.
       * @returns The decorator to be applied to the target class.
       * @remarks
       * The decorator can be used to decorate a class, listing all of the classes dependencies.
       * Or it can be used to decorate a constructor paramter, indicating what to inject for that
       * parameter.
       * Or it can be used for a web component property, indicating what that property should resolve to.
       */
      inject(...dependencies) {
        return function(target2, key2, descriptor) {
          if (typeof descriptor === "number") {
            const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target2);
            const dep = dependencies[0];
            if (dep !== void 0) {
              annotationParamtypes[descriptor] = dep;
            }
          } else if (key2) {
            DI.defineProperty(target2, key2, dependencies[0]);
          } else {
            const annotationParamtypes = descriptor ? DI.getOrCreateAnnotationParamTypes(descriptor.value) : DI.getOrCreateAnnotationParamTypes(target2);
            let dep;
            for (let i = 0; i < dependencies.length; ++i) {
              dep = dependencies[i];
              if (dep !== void 0) {
                annotationParamtypes[i] = dep;
              }
            }
          }
        };
      },
      /**
       * Registers the `target` class as a transient dependency; each time the dependency is resolved
       * a new instance will be created.
       *
       * @param target - The class / constructor function to register as transient.
       * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
       *
       * @example
       * On an existing class
       * ```ts
       * class Foo { }
       * DI.transient(Foo);
       * ```
       *
       * @example
       * Inline declaration
       *
       * ```ts
       * const Foo = DI.transient(class { });
       * // Foo is now strongly typed with register
       * Foo.register(container);
       * ```
       *
       * @public
       */
      transient(target2) {
        target2.register = function register(container) {
          const registration = Registration.transient(target2, target2);
          return registration.register(container);
        };
        target2.registerInRequestor = false;
        return target2;
      },
      /**
       * Registers the `target` class as a singleton dependency; the class will only be created once. Each
       * consecutive time the dependency is resolved, the same instance will be returned.
       *
       * @param target - The class / constructor function to register as a singleton.
       * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
       * @example
       * On an existing class
       * ```ts
       * class Foo { }
       * DI.singleton(Foo);
       * ```
       *
       * @example
       * Inline declaration
       * ```ts
       * const Foo = DI.singleton(class { });
       * // Foo is now strongly typed with register
       * Foo.register(container);
       * ```
       *
       * @public
       */
      singleton(target2, options = defaultSingletonOptions) {
        target2.register = function register(container) {
          const registration = Registration.singleton(target2, target2);
          return registration.register(container);
        };
        target2.registerInRequestor = options.scoped;
        return target2;
      }
    });
    Container = DI.createInterface("Container");
    inject = DI.inject;
    defaultSingletonOptions = { scoped: false };
    all = createAllResolver((key2, handler, requestor, searchAncestors) => requestor.getAll(key2, searchAncestors));
    lazy = createResolver((key2, handler, requestor) => {
      return () => requestor.get(key2);
    });
    optional = createResolver((key2, handler, requestor) => {
      if (requestor.has(key2, true)) {
        return requestor.get(key2);
      } else {
        return void 0;
      }
    });
    ignore.$isResolver = true;
    ignore.resolve = () => void 0;
    newInstanceForScope = createResolver((key2, handler, requestor) => {
      const instance = createNewInstance(key2, handler);
      const resolver = new ResolverImpl(key2, 0, instance);
      requestor.registerResolver(key2, resolver);
      return instance;
    });
    newInstanceOf = createResolver((key2, handler, _requestor) => createNewInstance(key2, handler));
    ResolverImpl = class {
      constructor(key2, strategy, state) {
        this.key = key2;
        this.strategy = strategy;
        this.state = state;
        this.resolving = false;
      }
      get $isResolver() {
        return true;
      }
      register(container) {
        return container.registerResolver(this.key, this);
      }
      resolve(handler, requestor) {
        switch (this.strategy) {
          case 0:
            return this.state;
          case 1: {
            if (this.resolving) {
              throw new Error(`Cyclic dependency found: ${this.state.name}`);
            }
            this.resolving = true;
            this.state = handler.getFactory(this.state).construct(requestor);
            this.strategy = 0;
            this.resolving = false;
            return this.state;
          }
          case 2: {
            const factory = handler.getFactory(this.state);
            if (factory === null) {
              throw new Error(`Resolver for ${String(this.key)} returned a null factory`);
            }
            return factory.construct(requestor);
          }
          case 3:
            return this.state(handler, requestor, this);
          case 4:
            return this.state[0].resolve(handler, requestor);
          case 5:
            return requestor.get(this.state);
          default:
            throw new Error(`Invalid resolver strategy specified: ${this.strategy}.`);
        }
      }
      getFactory(container) {
        var _a, _b, _c;
        switch (this.strategy) {
          case 1:
          case 2:
            return container.getFactory(this.state);
          case 5:
            return (_c = (_b = (_a = container.getResolver(this.state)) === null || _a === void 0 ? void 0 : _a.getFactory) === null || _b === void 0 ? void 0 : _b.call(_a, container)) !== null && _c !== void 0 ? _c : null;
          default:
            return null;
        }
      }
    };
    FactoryImpl = class {
      constructor(Type, dependencies) {
        this.Type = Type;
        this.dependencies = dependencies;
        this.transformers = null;
      }
      construct(container, dynamicDependencies) {
        let instance;
        if (dynamicDependencies === void 0) {
          instance = new this.Type(...this.dependencies.map(containerGetKey, container));
        } else {
          instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies);
        }
        if (this.transformers == null) {
          return instance;
        }
        return this.transformers.reduce(transformInstance, instance);
      }
      registerTransformer(transformer) {
        (this.transformers || (this.transformers = [])).push(transformer);
      }
    };
    containerResolver = {
      $isResolver: true,
      resolve(handler, requestor) {
        return requestor;
      }
    };
    InstrinsicTypeNames = /* @__PURE__ */ new Set([
      "Array",
      "ArrayBuffer",
      "Boolean",
      "DataView",
      "Date",
      "Error",
      "EvalError",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Number",
      "Object",
      "Promise",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "Set",
      "SharedArrayBuffer",
      "String",
      "SyntaxError",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "URIError",
      "WeakMap",
      "WeakSet"
    ]);
    DILocateParentEventType = "__DI_LOCATE_PARENT__";
    factories = /* @__PURE__ */ new Map();
    ContainerImpl = class {
      constructor(owner, config) {
        this.owner = owner;
        this.config = config;
        this._parent = void 0;
        this.registerDepth = 0;
        this.context = null;
        if (owner !== null) {
          owner.$$container$$ = this;
        }
        this.resolvers = /* @__PURE__ */ new Map();
        this.resolvers.set(Container, containerResolver);
        if (owner instanceof Node) {
          owner.addEventListener(DILocateParentEventType, (e) => {
            if (e.composedPath()[0] !== this.owner) {
              e.detail.container = this;
              e.stopImmediatePropagation();
            }
          });
        }
      }
      get parent() {
        if (this._parent === void 0) {
          this._parent = this.config.parentLocator(this.owner);
        }
        return this._parent;
      }
      get depth() {
        return this.parent === null ? 0 : this.parent.depth + 1;
      }
      get responsibleForOwnerRequests() {
        return this.config.responsibleForOwnerRequests;
      }
      registerWithContext(context, ...params) {
        this.context = context;
        this.register(...params);
        this.context = null;
        return this;
      }
      register(...params) {
        if (++this.registerDepth === 100) {
          throw new Error("Unable to autoregister dependency");
        }
        let current;
        let keys;
        let value;
        let j;
        let jj;
        const context = this.context;
        for (let i = 0, ii = params.length; i < ii; ++i) {
          current = params[i];
          if (!isObject8(current)) {
            continue;
          }
          if (isRegistry(current)) {
            current.register(this, context);
          } else if (isClass(current)) {
            Registration.singleton(current, current).register(this);
          } else {
            keys = Object.keys(current);
            j = 0;
            jj = keys.length;
            for (; j < jj; ++j) {
              value = current[keys[j]];
              if (!isObject8(value)) {
                continue;
              }
              if (isRegistry(value)) {
                value.register(this, context);
              } else {
                this.register(value);
              }
            }
          }
        }
        --this.registerDepth;
        return this;
      }
      registerResolver(key2, resolver) {
        validateKey(key2);
        const resolvers = this.resolvers;
        const result = resolvers.get(key2);
        if (result == null) {
          resolvers.set(key2, resolver);
        } else if (result instanceof ResolverImpl && result.strategy === 4) {
          result.state.push(resolver);
        } else {
          resolvers.set(key2, new ResolverImpl(key2, 4, [result, resolver]));
        }
        return resolver;
      }
      registerTransformer(key2, transformer) {
        const resolver = this.getResolver(key2);
        if (resolver == null) {
          return false;
        }
        if (resolver.getFactory) {
          const factory = resolver.getFactory(this);
          if (factory == null) {
            return false;
          }
          factory.registerTransformer(transformer);
          return true;
        }
        return false;
      }
      getResolver(key2, autoRegister = true) {
        validateKey(key2);
        if (key2.resolve !== void 0) {
          return key2;
        }
        let current = this;
        let resolver;
        while (current != null) {
          resolver = current.resolvers.get(key2);
          if (resolver == null) {
            if (current.parent == null) {
              const handler = isRegisterInRequester(key2) ? this : current;
              return autoRegister ? this.jitRegister(key2, handler) : null;
            }
            current = current.parent;
          } else {
            return resolver;
          }
        }
        return null;
      }
      has(key2, searchAncestors = false) {
        return this.resolvers.has(key2) ? true : searchAncestors && this.parent != null ? this.parent.has(key2, true) : false;
      }
      get(key2) {
        validateKey(key2);
        if (key2.$isResolver) {
          return key2.resolve(this, this);
        }
        let current = this;
        let resolver;
        while (current != null) {
          resolver = current.resolvers.get(key2);
          if (resolver == null) {
            if (current.parent == null) {
              const handler = isRegisterInRequester(key2) ? this : current;
              resolver = this.jitRegister(key2, handler);
              return resolver.resolve(current, this);
            }
            current = current.parent;
          } else {
            return resolver.resolve(current, this);
          }
        }
        throw new Error(`Unable to resolve key: ${String(key2)}`);
      }
      getAll(key2, searchAncestors = false) {
        validateKey(key2);
        const requestor = this;
        let current = requestor;
        let resolver;
        if (searchAncestors) {
          let resolutions = emptyArray;
          while (current != null) {
            resolver = current.resolvers.get(key2);
            if (resolver != null) {
              resolutions = resolutions.concat(
                /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */
                buildAllResponse(resolver, current, requestor)
              );
            }
            current = current.parent;
          }
          return resolutions;
        } else {
          while (current != null) {
            resolver = current.resolvers.get(key2);
            if (resolver == null) {
              current = current.parent;
              if (current == null) {
                return emptyArray;
              }
            } else {
              return buildAllResponse(resolver, current, requestor);
            }
          }
        }
        return emptyArray;
      }
      getFactory(Type) {
        let factory = factories.get(Type);
        if (factory === void 0) {
          if (isNativeFunction(Type)) {
            throw new Error(`${Type.name} is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`);
          }
          factories.set(Type, factory = new FactoryImpl(Type, DI.getDependencies(Type)));
        }
        return factory;
      }
      registerFactory(key2, factory) {
        factories.set(key2, factory);
      }
      createChild(config) {
        return new ContainerImpl(null, Object.assign({}, this.config, config, { parentLocator: () => this }));
      }
      jitRegister(keyAsValue, handler) {
        if (typeof keyAsValue !== "function") {
          throw new Error(`Attempted to jitRegister something that is not a constructor: '${keyAsValue}'. Did you forget to register this dependency?`);
        }
        if (InstrinsicTypeNames.has(keyAsValue.name)) {
          throw new Error(`Attempted to jitRegister an intrinsic type: ${keyAsValue.name}. Did you forget to add @inject(Key)`);
        }
        if (isRegistry(keyAsValue)) {
          const registrationResolver = keyAsValue.register(handler);
          if (!(registrationResolver instanceof Object) || registrationResolver.resolve == null) {
            const newResolver = handler.resolvers.get(keyAsValue);
            if (newResolver != void 0) {
              return newResolver;
            }
            throw new Error("A valid resolver was not returned from the static register method");
          }
          return registrationResolver;
        } else if (keyAsValue.$isInterface) {
          throw new Error(`Attempted to jitRegister an interface: ${keyAsValue.friendlyName}`);
        } else {
          const resolver = this.config.defaultResolver(keyAsValue, handler);
          handler.resolvers.set(keyAsValue, resolver);
          return resolver;
        }
      }
    };
    cache = /* @__PURE__ */ new WeakMap();
    Registration = Object.freeze({
      /**
       * Allows you to pass an instance.
       * Every time you request this {@link Key} you will get this instance back.
       *
       * @example
       * ```
       * Registration.instance(Foo, new Foo()));
       * ```
       *
       * @param key - The key to register the instance under.
       * @param value - The instance to return when the key is requested.
       */
      instance(key2, value) {
        return new ResolverImpl(key2, 0, value);
      },
      /**
       * Creates an instance from the class.
       * Every time you request this {@link Key} you will get the same one back.
       *
       * @example
       * ```
       * Registration.singleton(Foo, Foo);
       * ```
       *
       * @param key - The key to register the singleton under.
       * @param value - The class to instantiate as a singleton when first requested.
       */
      singleton(key2, value) {
        return new ResolverImpl(key2, 1, value);
      },
      /**
       * Creates an instance from a class.
       * Every time you request this {@link Key} you will get a new instance.
       *
       * @example
       * ```
       * Registration.instance(Foo, Foo);
       * ```
       *
       * @param key - The key to register the instance type under.
       * @param value - The class to instantiate each time the key is requested.
       */
      transient(key2, value) {
        return new ResolverImpl(key2, 2, value);
      },
      /**
       * Delegates to a callback function to provide the dependency.
       * Every time you request this {@link Key} the callback will be invoked to provide
       * the dependency.
       *
       * @example
       * ```
       * Registration.callback(Foo, () => new Foo());
       * Registration.callback(Bar, (c: Container) => new Bar(c.get(Foo)));
       * ```
       *
       * @param key - The key to register the callback for.
       * @param callback - The function that is expected to return the dependency.
       */
      callback(key2, callback) {
        return new ResolverImpl(key2, 3, callback);
      },
      /**
       * Delegates to a callback function to provide the dependency and then caches the
       * dependency for future requests.
       *
       * @example
       * ```
       * Registration.cachedCallback(Foo, () => new Foo());
       * Registration.cachedCallback(Bar, (c: Container) => new Bar(c.get(Foo)));
       * ```
       *
       * @param key - The key to register the callback for.
       * @param callback - The function that is expected to return the dependency.
       * @remarks
       * If you pass the same Registration to another container, the same cached value will be used.
       * Should all references to the resolver returned be removed, the cache will expire.
       */
      cachedCallback(key2, callback) {
        return new ResolverImpl(key2, 3, cacheCallbackResult(callback));
      },
      /**
       * Creates an alternate {@link Key} to retrieve an instance by.
       *
       * @example
       * ```
       * Register.singleton(Foo, Foo)
       * Register.aliasTo(Foo, MyFoos);
       *
       * container.getAll(MyFoos) // contains an instance of Foo
       * ```
       *
       * @param originalKey - The original key that has been registered.
       * @param aliasKey - The alias to the original key.
       */
      aliasTo(originalKey, aliasKey) {
        return new ResolverImpl(aliasKey, 5, originalKey);
      }
    });
    defaultFriendlyName = "(anonymous)";
    isNativeFunction = function() {
      const lookup = /* @__PURE__ */ new WeakMap();
      let isNative = false;
      let sourceText = "";
      let i = 0;
      return function(fn) {
        isNative = lookup.get(fn);
        if (isNative === void 0) {
          sourceText = fn.toString();
          i = sourceText.length;
          isNative = // 29 is the length of 'function () { [native code] }' which is the smallest length of a native function string
          i >= 29 && // 100 seems to be a safe upper bound of the max length of a native function. In Chrome and FF it's 56, in Edge it's 61.
          i <= 100 && // This whole heuristic *could* be tricked by a comment. Do we need to care about that?
          sourceText.charCodeAt(i - 1) === 125 && // }
          // TODO: the spec is a little vague about the precise constraints, so we do need to test this across various browsers to make sure just one whitespace is a safe assumption.
          sourceText.charCodeAt(i - 2) <= 32 && // whitespace
          sourceText.charCodeAt(i - 3) === 93 && // ]
          sourceText.charCodeAt(i - 4) === 101 && // e
          sourceText.charCodeAt(i - 5) === 100 && // d
          sourceText.charCodeAt(i - 6) === 111 && // o
          sourceText.charCodeAt(i - 7) === 99 && // c
          sourceText.charCodeAt(i - 8) === 32 && //
          sourceText.charCodeAt(i - 9) === 101 && // e
          sourceText.charCodeAt(i - 10) === 118 && // v
          sourceText.charCodeAt(i - 11) === 105 && // i
          sourceText.charCodeAt(i - 12) === 116 && // t
          sourceText.charCodeAt(i - 13) === 97 && // a
          sourceText.charCodeAt(i - 14) === 110 && // n
          sourceText.charCodeAt(i - 15) === 88;
          lookup.set(fn, isNative);
        }
        return isNative;
      };
    }();
    isNumericLookup = {};
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/design-system/component-presentation.js
function presentationKeyFromTag(tagName) {
  return `${tagName.toLowerCase()}:presentation`;
}
var presentationRegistry, ComponentPresentation, DefaultComponentPresentation;
var init_component_presentation = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/design-system/component-presentation.js"() {
    init_esm();
    init_di();
    presentationRegistry = /* @__PURE__ */ new Map();
    ComponentPresentation = Object.freeze({
      /**
       * Defines a component presentation for an element.
       * @param tagName - The element name to define the presentation for.
       * @param presentation - The presentation that will be applied to matching elements.
       * @param container - The dependency injection container to register the configuration in.
       * @public
       */
      define(tagName, presentation, container) {
        const key2 = presentationKeyFromTag(tagName);
        const existing = presentationRegistry.get(key2);
        if (existing === void 0) {
          presentationRegistry.set(key2, presentation);
        } else {
          presentationRegistry.set(key2, false);
        }
        container.register(Registration.instance(key2, presentation));
      },
      /**
       * Finds a component presentation for the specified element name,
       * searching the DOM hierarchy starting from the provided element.
       * @param tagName - The name of the element to locate the presentation for.
       * @param element - The element to begin the search from.
       * @returns The component presentation or null if none is found.
       * @public
       */
      forTag(tagName, element) {
        const key2 = presentationKeyFromTag(tagName);
        const existing = presentationRegistry.get(key2);
        if (existing === false) {
          const container = DI.findResponsibleContainer(element);
          return container.get(key2);
        }
        return existing || null;
      }
    });
    DefaultComponentPresentation = class {
      /**
       * Creates an instance of DefaultComponentPresentation.
       * @param template - The template to apply to the element.
       * @param styles - The styles to apply to the element.
       * @public
       */
      constructor(template, styles) {
        this.template = template || null;
        this.styles = styles === void 0 ? null : Array.isArray(styles) ? ElementStyles.create(styles) : styles instanceof ElementStyles ? styles : ElementStyles.create([styles]);
      }
      /**
       * Applies the presentation details to the specified element.
       * @param element - The element to apply the presentation details to.
       * @public
       */
      applyTo(element) {
        const controller = element.$fastController;
        if (controller.template === null) {
          controller.template = this.template;
        }
        if (controller.styles === null) {
          controller.styles = this.styles;
        }
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/foundation-element/foundation-element.js
function resolveOption(option, context, definition) {
  if (typeof option === "function") {
    return option(context, definition);
  }
  return option;
}
var FoundationElement, FoundationElementRegistry;
var init_foundation_element = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/foundation-element/foundation-element.js"() {
    init_tslib_es6();
    init_esm();
    init_component_presentation();
    FoundationElement = class extends FASTElement {
      constructor() {
        super(...arguments);
        this._presentation = void 0;
      }
      /**
       * A property which resolves the ComponentPresentation instance
       * for the current component.
       * @public
       */
      get $presentation() {
        if (this._presentation === void 0) {
          this._presentation = ComponentPresentation.forTag(this.tagName, this);
        }
        return this._presentation;
      }
      templateChanged() {
        if (this.template !== void 0) {
          this.$fastController.template = this.template;
        }
      }
      stylesChanged() {
        if (this.styles !== void 0) {
          this.$fastController.styles = this.styles;
        }
      }
      /**
       * The connected callback for this FASTElement.
       * @remarks
       * This method is invoked by the platform whenever this FoundationElement
       * becomes connected to the document.
       * @public
       */
      connectedCallback() {
        if (this.$presentation !== null) {
          this.$presentation.applyTo(this);
        }
        super.connectedCallback();
      }
      /**
       * Defines an element registry function with a set of element definition defaults.
       * @param elementDefinition - The definition of the element to create the registry
       * function for.
       * @public
       */
      static compose(elementDefinition) {
        return (overrideDefinition = {}) => new FoundationElementRegistry(this === FoundationElement ? class extends FoundationElement {
        } : this, elementDefinition, overrideDefinition);
      }
    };
    __decorate([
      observable
    ], FoundationElement.prototype, "template", void 0);
    __decorate([
      observable
    ], FoundationElement.prototype, "styles", void 0);
    FoundationElementRegistry = class {
      constructor(type, elementDefinition, overrideDefinition) {
        this.type = type;
        this.elementDefinition = elementDefinition;
        this.overrideDefinition = overrideDefinition;
        this.definition = Object.assign(Object.assign({}, this.elementDefinition), this.overrideDefinition);
      }
      register(container, context) {
        const definition = this.definition;
        const overrideDefinition = this.overrideDefinition;
        const prefix = definition.prefix || context.elementPrefix;
        const name2 = `${prefix}-${definition.baseName}`;
        context.tryDefineElement({
          name: name2,
          type: this.type,
          baseClass: this.elementDefinition.baseClass,
          callback: (x) => {
            const presentation = new DefaultComponentPresentation(resolveOption(definition.template, x, definition), resolveOption(definition.styles, x, definition));
            x.definePresentation(presentation);
            let shadowOptions = resolveOption(definition.shadowOptions, x, definition);
            if (x.shadowRootMode) {
              if (shadowOptions) {
                if (!overrideDefinition.shadowOptions) {
                  shadowOptions.mode = x.shadowRootMode;
                }
              } else if (shadowOptions !== null) {
                shadowOptions = { mode: x.shadowRootMode };
              }
            }
            x.defineElement({
              elementOptions: resolveOption(definition.elementOptions, x, definition),
              shadowOptions,
              attributes: resolveOption(definition.attributes, x, definition)
            });
          }
        });
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/apply-mixins.js
function applyMixins(derivedCtor, ...baseCtors) {
  const derivedAttributes = AttributeConfiguration.locate(derivedCtor);
  baseCtors.forEach((baseCtor) => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name2) => {
      if (name2 !== "constructor") {
        Object.defineProperty(
          derivedCtor.prototype,
          name2,
          /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */
          Object.getOwnPropertyDescriptor(baseCtor.prototype, name2)
        );
      }
    });
    const baseAttributes = AttributeConfiguration.locate(baseCtor);
    baseAttributes.forEach((x) => derivedAttributes.push(x));
  });
}
var init_apply_mixins = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/apply-mixins.js"() {
    init_esm();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/accordion-item/accordion-item.js
var AccordionItem;
var init_accordion_item = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/accordion-item/accordion-item.js"() {
    init_tslib_es6();
    init_esm();
    init_foundation_element();
    init_start_end();
    init_apply_mixins();
    AccordionItem = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.headinglevel = 2;
        this.expanded = false;
        this.clickHandler = (e) => {
          this.expanded = !this.expanded;
          this.change();
        };
        this.change = () => {
          this.$emit("change");
        };
      }
    };
    __decorate([
      attr({
        attribute: "heading-level",
        mode: "fromView",
        converter: nullableNumberConverter
      })
    ], AccordionItem.prototype, "headinglevel", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], AccordionItem.prototype, "expanded", void 0);
    __decorate([
      attr
    ], AccordionItem.prototype, "id", void 0);
    applyMixins(AccordionItem, StartEnd);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/accordion-item/index.js
var init_accordion_item2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/accordion-item/index.js"() {
    init_accordion_item_template();
    init_accordion_item();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/accordion/accordion.template.js
var accordionTemplate;
var init_accordion_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/accordion/accordion.template.js"() {
    init_esm();
    accordionTemplate = (context, definition) => (
      /* TODO: deprecate slot name `item` to only support default slot https://github.com/microsoft/fast/issues/5515 */
      html`
    <template>
        <slot ${slotted({ property: "accordionItems", filter: elements() })}></slot>
        <slot name="item" part="item" ${slotted("accordionItems")}></slot>
    </template>
`
    );
  }
});

// ../../node_modules/@microsoft/fast-web-utilities/dist/aria.js
var Orientation;
var init_aria = __esm({
  "../../node_modules/@microsoft/fast-web-utilities/dist/aria.js"() {
    Orientation = {
      horizontal: "horizontal",
      vertical: "vertical"
    };
  }
});

// ../../node_modules/@microsoft/fast-web-utilities/dist/array.js
function findLastIndex(array, predicate) {
  let k = array.length;
  while (k--) {
    if (predicate(array[k], k, array)) {
      return k;
    }
  }
  return -1;
}
var init_array = __esm({
  "../../node_modules/@microsoft/fast-web-utilities/dist/array.js"() {
  }
});

// ../../node_modules/@microsoft/fast-web-utilities/dist/class-names.js
var init_class_names = __esm({
  "../../node_modules/@microsoft/fast-web-utilities/dist/class-names.js"() {
  }
});

// ../../node_modules/exenv-es6/dist/can-use-dom.js
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var init_can_use_dom = __esm({
  "../../node_modules/exenv-es6/dist/can-use-dom.js"() {
  }
});

// ../../node_modules/exenv-es6/dist/can-use-event-listeners.js
var init_can_use_event_listeners = __esm({
  "../../node_modules/exenv-es6/dist/can-use-event-listeners.js"() {
  }
});

// ../../node_modules/exenv-es6/dist/can-use-viewport.js
var init_can_use_viewport = __esm({
  "../../node_modules/exenv-es6/dist/can-use-viewport.js"() {
  }
});

// ../../node_modules/exenv-es6/dist/can-use-workers.js
var init_can_use_workers = __esm({
  "../../node_modules/exenv-es6/dist/can-use-workers.js"() {
  }
});

// ../../node_modules/exenv-es6/dist/index.js
var init_dist3 = __esm({
  "../../node_modules/exenv-es6/dist/index.js"() {
    init_can_use_dom();
    init_can_use_event_listeners();
    init_can_use_viewport();
    init_can_use_workers();
  }
});

// ../../node_modules/@microsoft/fast-web-utilities/dist/dom.js
function isHTMLElement(...args) {
  return args.every((arg) => arg instanceof HTMLElement);
}
function getDisplayedNodes(rootNode, selector) {
  if (!rootNode || !selector || !isHTMLElement(rootNode)) {
    return;
  }
  const nodes = Array.from(rootNode.querySelectorAll(selector));
  return nodes.filter((node) => node.offsetParent !== null);
}
function getNonce() {
  const node = document.querySelector('meta[property="csp-nonce"]');
  if (node) {
    return node.getAttribute("content");
  } else {
    return null;
  }
}
function canUseFocusVisible() {
  if (typeof _canUseFocusVisible === "boolean") {
    return _canUseFocusVisible;
  }
  if (!canUseDOM()) {
    _canUseFocusVisible = false;
    return _canUseFocusVisible;
  }
  const styleElement = document.createElement("style");
  const styleNonce = getNonce();
  if (styleNonce !== null) {
    styleElement.setAttribute("nonce", styleNonce);
  }
  document.head.appendChild(styleElement);
  try {
    styleElement.sheet.insertRule("foo:focus-visible {color:inherit}", 0);
    _canUseFocusVisible = true;
  } catch (e) {
    _canUseFocusVisible = false;
  } finally {
    document.head.removeChild(styleElement);
  }
  return _canUseFocusVisible;
}
var _canUseFocusVisible;
var init_dom2 = __esm({
  "../../node_modules/@microsoft/fast-web-utilities/dist/dom.js"() {
    init_dist3();
  }
});

// ../../node_modules/@microsoft/fast-web-utilities/dist/events.js
var eventFocus, eventFocusIn, eventFocusOut, eventKeyDown, eventResize, eventScroll;
var init_events = __esm({
  "../../node_modules/@microsoft/fast-web-utilities/dist/events.js"() {
    eventFocus = "focus";
    eventFocusIn = "focusin";
    eventFocusOut = "focusout";
    eventKeyDown = "keydown";
    eventResize = "resize";
    eventScroll = "scroll";
  }
});

// ../../node_modules/@microsoft/fast-web-utilities/dist/html.js
var init_html = __esm({
  "../../node_modules/@microsoft/fast-web-utilities/dist/html.js"() {
  }
});

// ../../node_modules/@microsoft/fast-web-utilities/dist/key-codes.js
var KeyCodes, keyArrowDown, keyArrowLeft, keyArrowRight, keyArrowUp, keyEnter, keyEscape, keyHome, keyEnd, keyFunction2, keyPageDown, keyPageUp, keySpace, keyTab, keyBackspace, keyDelete, ArrowKeys;
var init_key_codes = __esm({
  "../../node_modules/@microsoft/fast-web-utilities/dist/key-codes.js"() {
    (function(KeyCodes2) {
      KeyCodes2[KeyCodes2["alt"] = 18] = "alt";
      KeyCodes2[KeyCodes2["arrowDown"] = 40] = "arrowDown";
      KeyCodes2[KeyCodes2["arrowLeft"] = 37] = "arrowLeft";
      KeyCodes2[KeyCodes2["arrowRight"] = 39] = "arrowRight";
      KeyCodes2[KeyCodes2["arrowUp"] = 38] = "arrowUp";
      KeyCodes2[KeyCodes2["back"] = 8] = "back";
      KeyCodes2[KeyCodes2["backSlash"] = 220] = "backSlash";
      KeyCodes2[KeyCodes2["break"] = 19] = "break";
      KeyCodes2[KeyCodes2["capsLock"] = 20] = "capsLock";
      KeyCodes2[KeyCodes2["closeBracket"] = 221] = "closeBracket";
      KeyCodes2[KeyCodes2["colon"] = 186] = "colon";
      KeyCodes2[KeyCodes2["colon2"] = 59] = "colon2";
      KeyCodes2[KeyCodes2["comma"] = 188] = "comma";
      KeyCodes2[KeyCodes2["ctrl"] = 17] = "ctrl";
      KeyCodes2[KeyCodes2["delete"] = 46] = "delete";
      KeyCodes2[KeyCodes2["end"] = 35] = "end";
      KeyCodes2[KeyCodes2["enter"] = 13] = "enter";
      KeyCodes2[KeyCodes2["equals"] = 187] = "equals";
      KeyCodes2[KeyCodes2["equals2"] = 61] = "equals2";
      KeyCodes2[KeyCodes2["equals3"] = 107] = "equals3";
      KeyCodes2[KeyCodes2["escape"] = 27] = "escape";
      KeyCodes2[KeyCodes2["forwardSlash"] = 191] = "forwardSlash";
      KeyCodes2[KeyCodes2["function1"] = 112] = "function1";
      KeyCodes2[KeyCodes2["function10"] = 121] = "function10";
      KeyCodes2[KeyCodes2["function11"] = 122] = "function11";
      KeyCodes2[KeyCodes2["function12"] = 123] = "function12";
      KeyCodes2[KeyCodes2["function2"] = 113] = "function2";
      KeyCodes2[KeyCodes2["function3"] = 114] = "function3";
      KeyCodes2[KeyCodes2["function4"] = 115] = "function4";
      KeyCodes2[KeyCodes2["function5"] = 116] = "function5";
      KeyCodes2[KeyCodes2["function6"] = 117] = "function6";
      KeyCodes2[KeyCodes2["function7"] = 118] = "function7";
      KeyCodes2[KeyCodes2["function8"] = 119] = "function8";
      KeyCodes2[KeyCodes2["function9"] = 120] = "function9";
      KeyCodes2[KeyCodes2["home"] = 36] = "home";
      KeyCodes2[KeyCodes2["insert"] = 45] = "insert";
      KeyCodes2[KeyCodes2["menu"] = 93] = "menu";
      KeyCodes2[KeyCodes2["minus"] = 189] = "minus";
      KeyCodes2[KeyCodes2["minus2"] = 109] = "minus2";
      KeyCodes2[KeyCodes2["numLock"] = 144] = "numLock";
      KeyCodes2[KeyCodes2["numPad0"] = 96] = "numPad0";
      KeyCodes2[KeyCodes2["numPad1"] = 97] = "numPad1";
      KeyCodes2[KeyCodes2["numPad2"] = 98] = "numPad2";
      KeyCodes2[KeyCodes2["numPad3"] = 99] = "numPad3";
      KeyCodes2[KeyCodes2["numPad4"] = 100] = "numPad4";
      KeyCodes2[KeyCodes2["numPad5"] = 101] = "numPad5";
      KeyCodes2[KeyCodes2["numPad6"] = 102] = "numPad6";
      KeyCodes2[KeyCodes2["numPad7"] = 103] = "numPad7";
      KeyCodes2[KeyCodes2["numPad8"] = 104] = "numPad8";
      KeyCodes2[KeyCodes2["numPad9"] = 105] = "numPad9";
      KeyCodes2[KeyCodes2["numPadDivide"] = 111] = "numPadDivide";
      KeyCodes2[KeyCodes2["numPadDot"] = 110] = "numPadDot";
      KeyCodes2[KeyCodes2["numPadMinus"] = 109] = "numPadMinus";
      KeyCodes2[KeyCodes2["numPadMultiply"] = 106] = "numPadMultiply";
      KeyCodes2[KeyCodes2["numPadPlus"] = 107] = "numPadPlus";
      KeyCodes2[KeyCodes2["openBracket"] = 219] = "openBracket";
      KeyCodes2[KeyCodes2["pageDown"] = 34] = "pageDown";
      KeyCodes2[KeyCodes2["pageUp"] = 33] = "pageUp";
      KeyCodes2[KeyCodes2["period"] = 190] = "period";
      KeyCodes2[KeyCodes2["print"] = 44] = "print";
      KeyCodes2[KeyCodes2["quote"] = 222] = "quote";
      KeyCodes2[KeyCodes2["scrollLock"] = 145] = "scrollLock";
      KeyCodes2[KeyCodes2["shift"] = 16] = "shift";
      KeyCodes2[KeyCodes2["space"] = 32] = "space";
      KeyCodes2[KeyCodes2["tab"] = 9] = "tab";
      KeyCodes2[KeyCodes2["tilde"] = 192] = "tilde";
      KeyCodes2[KeyCodes2["windowsLeft"] = 91] = "windowsLeft";
      KeyCodes2[KeyCodes2["windowsOpera"] = 219] = "windowsOpera";
      KeyCodes2[KeyCodes2["windowsRight"] = 92] = "windowsRight";
    })(KeyCodes || (KeyCodes = {}));
    keyArrowDown = "ArrowDown";
    keyArrowLeft = "ArrowLeft";
    keyArrowRight = "ArrowRight";
    keyArrowUp = "ArrowUp";
    keyEnter = "Enter";
    keyEscape = "Escape";
    keyHome = "Home";
    keyEnd = "End";
    keyFunction2 = "F2";
    keyPageDown = "PageDown";
    keyPageUp = "PageUp";
    keySpace = " ";
    keyTab = "Tab";
    keyBackspace = "Backspace";
    keyDelete = "Delete";
    ArrowKeys = {
      ArrowDown: keyArrowDown,
      ArrowLeft: keyArrowLeft,
      ArrowRight: keyArrowRight,
      ArrowUp: keyArrowUp
    };
  }
});

// ../../node_modules/@microsoft/fast-web-utilities/dist/localization.js
var Direction;
var init_localization = __esm({
  "../../node_modules/@microsoft/fast-web-utilities/dist/localization.js"() {
    (function(Direction2) {
      Direction2["ltr"] = "ltr";
      Direction2["rtl"] = "rtl";
    })(Direction || (Direction = {}));
  }
});

// ../../node_modules/@microsoft/fast-web-utilities/dist/numbers.js
function wrapInBounds(min, max2, value) {
  if (value < min) {
    return max2;
  } else if (value > max2) {
    return min;
  }
  return value;
}
function limit(min, max2, value) {
  return Math.min(Math.max(value, min), max2);
}
function inRange(value, min, max2 = 0) {
  [min, max2] = [min, max2].sort((a, b) => a - b);
  return min <= value && value < max2;
}
var init_numbers = __esm({
  "../../node_modules/@microsoft/fast-web-utilities/dist/numbers.js"() {
  }
});

// ../../node_modules/@microsoft/fast-web-utilities/dist/strings.js
function uniqueId2(prefix = "") {
  return `${prefix}${uniqueIdCounter++}`;
}
var uniqueIdCounter;
var init_strings = __esm({
  "../../node_modules/@microsoft/fast-web-utilities/dist/strings.js"() {
    uniqueIdCounter = 0;
  }
});

// ../../node_modules/@microsoft/fast-web-utilities/dist/query.js
var init_query = __esm({
  "../../node_modules/@microsoft/fast-web-utilities/dist/query.js"() {
  }
});

// ../../node_modules/@microsoft/fast-web-utilities/dist/rtl-scroll-converter.js
var RtlScrollConverter;
var init_rtl_scroll_converter = __esm({
  "../../node_modules/@microsoft/fast-web-utilities/dist/rtl-scroll-converter.js"() {
    init_dist3();
    init_localization();
    RtlScrollConverter = class {
      /**
       *  Gets the scrollLeft value of the provided element
       */
      static getScrollLeft(scrolledElement, direction2) {
        if (direction2 === Direction.rtl) {
          return RtlScrollConverter.getRtlScrollLeftConverter(scrolledElement);
        }
        return scrolledElement.scrollLeft;
      }
      /**
       * Sets the scrollLeft value of the provided element
       */
      static setScrollLeft(scrolledElement, scrollValue, direction2) {
        if (direction2 === Direction.rtl) {
          RtlScrollConverter.setRtlScrollLeftConverter(scrolledElement, scrollValue);
          return;
        }
        scrolledElement.scrollLeft = scrollValue;
      }
      /**
       * The initial rtl scroll converter getter function, it calls the browser test to set the correct converter
       * functions and then invokes the getter
       */
      static initialGetRtlScrollConverter(scrolledElement) {
        RtlScrollConverter.initializeRtlScrollConverters();
        return RtlScrollConverter.getRtlScrollLeftConverter(scrolledElement);
      }
      /**
       * The "direct" rtl get scroll converter does not need to tamper with the scrollLeft
       * values as the browser is already doing the right thing.  Content start = 0 and
       * scrolling left goes negative.
       */
      static directGetRtlScrollConverter(scrolledElement) {
        return scrolledElement.scrollLeft;
      }
      /**
       * The "inverted" get scroll converter is used when the browser reports scroll left
       * as a positive maximum scroll value at content start and then goes to zero as content
       * is scrolled left
       */
      static invertedGetRtlScrollConverter(scrolledElement) {
        return -Math.abs(scrolledElement.scrollLeft);
      }
      /**
       * The "reverse" get scroll converter is used when the browser reports scroll left
       * as 0 at content start and then goes positive as content is scrolled left
       */
      static reverseGetRtlScrollConverter(scrolledElement) {
        return scrolledElement.scrollLeft - (scrolledElement.scrollWidth - scrolledElement.clientWidth);
      }
      /**
       * The initial rtl scroll converter setter function, it calls the browser test to set the correct converter
       * functions and then invokes the setter
       */
      static initialSetRtlScrollConverter(scrolledElement, newScrollValue) {
        RtlScrollConverter.initializeRtlScrollConverters();
        RtlScrollConverter.setRtlScrollLeftConverter(scrolledElement, newScrollValue);
      }
      /**
       * The "direct" rtl set scroll converter does not need to tamper with the scrollLeft
       * values as the browser is already doing the right thing.  Content start = 0 and
       * scrolling left goes negative.
       */
      static directSetRtlScrollConverter(scrolledElement, newScrollValue) {
        scrolledElement.scrollLeft = newScrollValue;
      }
      /**
       * The "inverted" set scroll converter is used when the browser reports scroll left
       * as a positive maximum scroll value at content start and then goes to zero as content
       * is scrolled left
       */
      static invertedSetRtlScrollConverter(scrolledElement, newScrollValue) {
        scrolledElement.scrollLeft = Math.abs(newScrollValue);
      }
      /**
       * The "reverse" set scroll converter is used when the browser reports scroll left
       * as 0 at content start and then goes positive as content is scrolled left
       */
      static reverseSetRtlScrollConverter(scrolledElement, newScrollValue) {
        const maxScroll = scrolledElement.scrollWidth - scrolledElement.clientWidth;
        scrolledElement.scrollLeft = maxScroll + newScrollValue;
      }
      /**
       * detects the appropriate rtl scroll converter functions and assigns them
       * should only run once
       */
      static initializeRtlScrollConverters() {
        if (!canUseDOM()) {
          RtlScrollConverter.applyDirectScrollConverters();
          return;
        }
        const testElement = RtlScrollConverter.getTestElement();
        document.body.appendChild(testElement);
        RtlScrollConverter.checkForScrollType(testElement);
        document.body.removeChild(testElement);
      }
      /**
       * checks the provided test element to determine scroll type
       * and apply appropriate converters
       */
      static checkForScrollType(testElement) {
        if (RtlScrollConverter.isReverse(testElement)) {
          RtlScrollConverter.applyReverseScrollConverters();
        } else {
          if (RtlScrollConverter.isDirect(testElement)) {
            RtlScrollConverter.applyDirectScrollConverters();
          } else {
            RtlScrollConverter.applyInvertedScrollConverters();
          }
        }
      }
      /**
       * checks test element initial state for rtl "reverse" mode
       */
      static isReverse(testElement) {
        return testElement.scrollLeft > 0;
      }
      /**
       * checks test element for rtl "direct" mode
       */
      static isDirect(testElement) {
        testElement.scrollLeft = -1;
        return testElement.scrollLeft < 0;
      }
      /**
       * apply direct scroll conververters
       */
      static applyDirectScrollConverters() {
        RtlScrollConverter.setRtlScrollLeftConverter = RtlScrollConverter.directSetRtlScrollConverter;
        RtlScrollConverter.getRtlScrollLeftConverter = RtlScrollConverter.directGetRtlScrollConverter;
      }
      /**
       * apply inverted scroll conververters
       */
      static applyInvertedScrollConverters() {
        RtlScrollConverter.setRtlScrollLeftConverter = RtlScrollConverter.invertedSetRtlScrollConverter;
        RtlScrollConverter.getRtlScrollLeftConverter = RtlScrollConverter.invertedGetRtlScrollConverter;
      }
      /**
       * apply reverse scroll conververters
       */
      static applyReverseScrollConverters() {
        RtlScrollConverter.setRtlScrollLeftConverter = RtlScrollConverter.reverseSetRtlScrollConverter;
        RtlScrollConverter.getRtlScrollLeftConverter = RtlScrollConverter.reverseGetRtlScrollConverter;
      }
      /**
       * generate a test element for rtl testing
       */
      static getTestElement() {
        const testElement = document.createElement("div");
        testElement.appendChild(document.createTextNode("ABCD"));
        testElement.dir = "rtl";
        testElement.style.fontSize = "14px";
        testElement.style.width = "4px";
        testElement.style.height = "1px";
        testElement.style.position = "absolute";
        testElement.style.top = "-1000px";
        testElement.style.overflow = "scroll";
        return testElement;
      }
    };
    RtlScrollConverter.getRtlScrollLeftConverter = RtlScrollConverter.initialGetRtlScrollConverter;
    RtlScrollConverter.setRtlScrollLeftConverter = RtlScrollConverter.initialSetRtlScrollConverter;
  }
});

// ../../node_modules/@microsoft/fast-web-utilities/dist/system-colors.js
var SystemColors;
var init_system_colors = __esm({
  "../../node_modules/@microsoft/fast-web-utilities/dist/system-colors.js"() {
    (function(SystemColors2) {
      SystemColors2["Canvas"] = "Canvas";
      SystemColors2["CanvasText"] = "CanvasText";
      SystemColors2["LinkText"] = "LinkText";
      SystemColors2["VisitedText"] = "VisitedText";
      SystemColors2["ActiveText"] = "ActiveText";
      SystemColors2["ButtonFace"] = "ButtonFace";
      SystemColors2["ButtonText"] = "ButtonText";
      SystemColors2["Field"] = "Field";
      SystemColors2["FieldText"] = "FieldText";
      SystemColors2["Highlight"] = "Highlight";
      SystemColors2["HighlightText"] = "HighlightText";
      SystemColors2["GrayText"] = "GrayText";
    })(SystemColors || (SystemColors = {}));
  }
});

// ../../node_modules/@microsoft/fast-web-utilities/dist/index.js
var init_dist4 = __esm({
  "../../node_modules/@microsoft/fast-web-utilities/dist/index.js"() {
    init_aria();
    init_array();
    init_class_names();
    init_dom2();
    init_events();
    init_html();
    init_key_codes();
    init_localization();
    init_numbers();
    init_strings();
    init_query();
    init_rtl_scroll_converter();
    init_system_colors();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/accordion/accordion.js
var AccordionExpandMode, Accordion;
var init_accordion = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/accordion/accordion.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_foundation_element();
    init_accordion_item();
    AccordionExpandMode = {
      /**
       * Designates only a single {@link @microsoft/fast-foundation#(AccordionItem:class) } can be open a time.
       */
      single: "single",
      /**
       * Designates multiple {@link @microsoft/fast-foundation#(AccordionItem:class) | AccordionItems} can be open simultaneously.
       */
      multi: "multi"
    };
    Accordion = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.expandmode = AccordionExpandMode.multi;
        this.activeItemIndex = 0;
        this.change = () => {
          this.$emit("change", this.activeid);
        };
        this.setItems = () => {
          var _a;
          if (this.accordionItems.length === 0) {
            return;
          }
          this.accordionIds = this.getItemIds();
          this.accordionItems.forEach((item, index) => {
            if (item instanceof AccordionItem) {
              item.addEventListener("change", this.activeItemChange);
              if (this.isSingleExpandMode()) {
                this.activeItemIndex !== index ? item.expanded = false : item.expanded = true;
              }
            }
            const itemId = this.accordionIds[index];
            item.setAttribute("id", typeof itemId !== "string" ? `accordion-${index + 1}` : itemId);
            this.activeid = this.accordionIds[this.activeItemIndex];
            item.addEventListener("keydown", this.handleItemKeyDown);
            item.addEventListener("focus", this.handleItemFocus);
          });
          if (this.isSingleExpandMode()) {
            const expandedItem = (_a = this.findExpandedItem()) !== null && _a !== void 0 ? _a : this.accordionItems[0];
            expandedItem.setAttribute("aria-disabled", "true");
          }
        };
        this.removeItemListeners = (oldValue) => {
          oldValue.forEach((item, index) => {
            item.removeEventListener("change", this.activeItemChange);
            item.removeEventListener("keydown", this.handleItemKeyDown);
            item.removeEventListener("focus", this.handleItemFocus);
          });
        };
        this.activeItemChange = (event) => {
          if (event.defaultPrevented || event.target !== event.currentTarget) {
            return;
          }
          event.preventDefault();
          const selectedItem = event.target;
          this.activeid = selectedItem.getAttribute("id");
          if (this.isSingleExpandMode()) {
            this.resetItems();
            selectedItem.expanded = true;
            selectedItem.setAttribute("aria-disabled", "true");
            this.accordionItems.forEach((item) => {
              if (!item.hasAttribute("disabled") && item.id !== this.activeid) {
                item.removeAttribute("aria-disabled");
              }
            });
          }
          this.activeItemIndex = Array.from(this.accordionItems).indexOf(selectedItem);
          this.change();
        };
        this.handleItemKeyDown = (event) => {
          if (event.target !== event.currentTarget) {
            return;
          }
          this.accordionIds = this.getItemIds();
          switch (event.key) {
            case keyArrowUp:
              event.preventDefault();
              this.adjust(-1);
              break;
            case keyArrowDown:
              event.preventDefault();
              this.adjust(1);
              break;
            case keyHome:
              this.activeItemIndex = 0;
              this.focusItem();
              break;
            case keyEnd:
              this.activeItemIndex = this.accordionItems.length - 1;
              this.focusItem();
              break;
          }
        };
        this.handleItemFocus = (event) => {
          if (event.target === event.currentTarget) {
            const focusedItem = event.target;
            const focusedIndex = this.activeItemIndex = Array.from(this.accordionItems).indexOf(focusedItem);
            if (this.activeItemIndex !== focusedIndex && focusedIndex !== -1) {
              this.activeItemIndex = focusedIndex;
              this.activeid = this.accordionIds[this.activeItemIndex];
            }
          }
        };
      }
      /**
       * @internal
       */
      accordionItemsChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
          this.removeItemListeners(oldValue);
          this.setItems();
        }
      }
      findExpandedItem() {
        for (let item = 0; item < this.accordionItems.length; item++) {
          if (this.accordionItems[item].getAttribute("expanded") === "true") {
            return this.accordionItems[item];
          }
        }
        return null;
      }
      resetItems() {
        this.accordionItems.forEach((item, index) => {
          item.expanded = false;
        });
      }
      getItemIds() {
        return this.accordionItems.map((accordionItem) => {
          return accordionItem.getAttribute("id");
        });
      }
      isSingleExpandMode() {
        return this.expandmode === AccordionExpandMode.single;
      }
      adjust(adjustment) {
        this.activeItemIndex = wrapInBounds(0, this.accordionItems.length - 1, this.activeItemIndex + adjustment);
        this.focusItem();
      }
      focusItem() {
        const element = this.accordionItems[this.activeItemIndex];
        if (element instanceof AccordionItem) {
          element.expandbutton.focus();
        }
      }
    };
    __decorate([
      attr({ attribute: "expand-mode" })
    ], Accordion.prototype, "expandmode", void 0);
    __decorate([
      observable
    ], Accordion.prototype, "accordionItems", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/accordion/index.js
var init_accordion2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/accordion/index.js"() {
    init_accordion_template();
    init_accordion();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/anchor/anchor.template.js
var anchorTemplate;
var init_anchor_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/anchor/anchor.template.js"() {
    init_esm();
    init_start_end();
    anchorTemplate = (context, definition) => html`
    <a
        class="control"
        part="control"
        download="${(x) => x.download}"
        href="${(x) => x.href}"
        hreflang="${(x) => x.hreflang}"
        ping="${(x) => x.ping}"
        referrerpolicy="${(x) => x.referrerpolicy}"
        rel="${(x) => x.rel}"
        target="${(x) => x.target}"
        type="${(x) => x.type}"
        aria-atomic="${(x) => x.ariaAtomic}"
        aria-busy="${(x) => x.ariaBusy}"
        aria-controls="${(x) => x.ariaControls}"
        aria-current="${(x) => x.ariaCurrent}"
        aria-describedby="${(x) => x.ariaDescribedby}"
        aria-details="${(x) => x.ariaDetails}"
        aria-disabled="${(x) => x.ariaDisabled}"
        aria-errormessage="${(x) => x.ariaErrormessage}"
        aria-expanded="${(x) => x.ariaExpanded}"
        aria-flowto="${(x) => x.ariaFlowto}"
        aria-haspopup="${(x) => x.ariaHaspopup}"
        aria-hidden="${(x) => x.ariaHidden}"
        aria-invalid="${(x) => x.ariaInvalid}"
        aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
        aria-label="${(x) => x.ariaLabel}"
        aria-labelledby="${(x) => x.ariaLabelledby}"
        aria-live="${(x) => x.ariaLive}"
        aria-owns="${(x) => x.ariaOwns}"
        aria-relevant="${(x) => x.ariaRelevant}"
        aria-roledescription="${(x) => x.ariaRoledescription}"
        ${ref("control")}
    >
        ${startSlotTemplate(context, definition)}
        <span class="content" part="content">
            <slot ${slotted("defaultSlottedContent")}></slot>
        </span>
        ${endSlotTemplate(context, definition)}
    </a>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/patterns/aria-global.js
var ARIAGlobalStatesAndProperties;
var init_aria_global = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/patterns/aria-global.js"() {
    init_tslib_es6();
    init_esm();
    ARIAGlobalStatesAndProperties = class {
    };
    __decorate([
      attr({ attribute: "aria-atomic" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaAtomic", void 0);
    __decorate([
      attr({ attribute: "aria-busy" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaBusy", void 0);
    __decorate([
      attr({ attribute: "aria-controls" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaControls", void 0);
    __decorate([
      attr({ attribute: "aria-current" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaCurrent", void 0);
    __decorate([
      attr({ attribute: "aria-describedby" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaDescribedby", void 0);
    __decorate([
      attr({ attribute: "aria-details" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaDetails", void 0);
    __decorate([
      attr({ attribute: "aria-disabled" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaDisabled", void 0);
    __decorate([
      attr({ attribute: "aria-errormessage" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaErrormessage", void 0);
    __decorate([
      attr({ attribute: "aria-flowto" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaFlowto", void 0);
    __decorate([
      attr({ attribute: "aria-haspopup" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaHaspopup", void 0);
    __decorate([
      attr({ attribute: "aria-hidden" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaHidden", void 0);
    __decorate([
      attr({ attribute: "aria-invalid" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaInvalid", void 0);
    __decorate([
      attr({ attribute: "aria-keyshortcuts" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaKeyshortcuts", void 0);
    __decorate([
      attr({ attribute: "aria-label" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaLabel", void 0);
    __decorate([
      attr({ attribute: "aria-labelledby" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaLabelledby", void 0);
    __decorate([
      attr({ attribute: "aria-live" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaLive", void 0);
    __decorate([
      attr({ attribute: "aria-owns" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaOwns", void 0);
    __decorate([
      attr({ attribute: "aria-relevant" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaRelevant", void 0);
    __decorate([
      attr({ attribute: "aria-roledescription" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaRoledescription", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/patterns/index.js
var init_patterns = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/patterns/index.js"() {
    init_aria_global();
    init_start_end();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/anchor/anchor.js
var Anchor, DelegatesARIALink;
var init_anchor = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/anchor/anchor.js"() {
    init_tslib_es6();
    init_esm();
    init_foundation_element();
    init_patterns();
    init_apply_mixins();
    Anchor = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.handleUnsupportedDelegatesFocus = () => {
          var _a;
          if (window.ShadowRoot && !window.ShadowRoot.prototype.hasOwnProperty("delegatesFocus") && ((_a = this.$fastController.definition.shadowOptions) === null || _a === void 0 ? void 0 : _a.delegatesFocus)) {
            this.focus = () => {
              var _a2;
              (_a2 = this.control) === null || _a2 === void 0 ? void 0 : _a2.focus();
            };
          }
        };
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.handleUnsupportedDelegatesFocus();
      }
    };
    __decorate([
      attr
    ], Anchor.prototype, "download", void 0);
    __decorate([
      attr
    ], Anchor.prototype, "href", void 0);
    __decorate([
      attr
    ], Anchor.prototype, "hreflang", void 0);
    __decorate([
      attr
    ], Anchor.prototype, "ping", void 0);
    __decorate([
      attr
    ], Anchor.prototype, "referrerpolicy", void 0);
    __decorate([
      attr
    ], Anchor.prototype, "rel", void 0);
    __decorate([
      attr
    ], Anchor.prototype, "target", void 0);
    __decorate([
      attr
    ], Anchor.prototype, "type", void 0);
    __decorate([
      observable
    ], Anchor.prototype, "defaultSlottedContent", void 0);
    DelegatesARIALink = class {
    };
    __decorate([
      attr({ attribute: "aria-expanded" })
    ], DelegatesARIALink.prototype, "ariaExpanded", void 0);
    applyMixins(DelegatesARIALink, ARIAGlobalStatesAndProperties);
    applyMixins(Anchor, StartEnd, DelegatesARIALink);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/anchor/index.js
var init_anchor2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/anchor/index.js"() {
    init_anchor_template();
    init_anchor();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region.template.js
var anchoredRegionTemplate;
var init_anchored_region_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region.template.js"() {
    init_esm();
    anchoredRegionTemplate = (context, definition) => html`
    <template class="${(x) => x.initialLayoutComplete ? "loaded" : ""}">
        ${when((x) => x.initialLayoutComplete, html`
                <slot></slot>
            `)}
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/direction.js
var getDirection;
var init_direction = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/direction.js"() {
    init_dist4();
    getDirection = (rootNode) => {
      const dirNode = rootNode.closest("[dir]");
      return dirNode !== null && dirNode.dir === "rtl" ? Direction.rtl : Direction.ltr;
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/intersection-service.js
var IntersectionService;
var init_intersection_service = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/intersection-service.js"() {
    init_esm();
    IntersectionService = class {
      constructor() {
        this.intersectionDetector = null;
        this.observedElements = /* @__PURE__ */ new Map();
        this.requestPosition = (target2, callback) => {
          var _a;
          if (this.intersectionDetector === null) {
            return;
          }
          if (this.observedElements.has(target2)) {
            (_a = this.observedElements.get(target2)) === null || _a === void 0 ? void 0 : _a.push(callback);
            return;
          }
          this.observedElements.set(target2, [callback]);
          this.intersectionDetector.observe(target2);
        };
        this.cancelRequestPosition = (target2, callback) => {
          const callbacks = this.observedElements.get(target2);
          if (callbacks !== void 0) {
            const callBackIndex = callbacks.indexOf(callback);
            if (callBackIndex !== -1) {
              callbacks.splice(callBackIndex, 1);
            }
          }
        };
        this.initializeIntersectionDetector = () => {
          if (!$global.IntersectionObserver) {
            return;
          }
          this.intersectionDetector = new IntersectionObserver(this.handleIntersection, {
            root: null,
            rootMargin: "0px",
            threshold: [0, 1]
          });
        };
        this.handleIntersection = (entries) => {
          if (this.intersectionDetector === null) {
            return;
          }
          const pendingCallbacks = [];
          const pendingCallbackParams = [];
          entries.forEach((entry) => {
            var _a;
            (_a = this.intersectionDetector) === null || _a === void 0 ? void 0 : _a.unobserve(entry.target);
            const thisElementCallbacks = this.observedElements.get(entry.target);
            if (thisElementCallbacks !== void 0) {
              thisElementCallbacks.forEach((callback) => {
                let targetCallbackIndex = pendingCallbacks.indexOf(callback);
                if (targetCallbackIndex === -1) {
                  targetCallbackIndex = pendingCallbacks.length;
                  pendingCallbacks.push(callback);
                  pendingCallbackParams.push([]);
                }
                pendingCallbackParams[targetCallbackIndex].push(entry);
              });
              this.observedElements.delete(entry.target);
            }
          });
          pendingCallbacks.forEach((callback, index) => {
            callback(pendingCallbackParams[index]);
          });
        };
        this.initializeIntersectionDetector();
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region.js
var AnchoredRegion;
var init_anchored_region = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_foundation_element();
    init_direction();
    init_intersection_service();
    AnchoredRegion = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.anchor = "";
        this.viewport = "";
        this.horizontalPositioningMode = "uncontrolled";
        this.horizontalDefaultPosition = "unset";
        this.horizontalViewportLock = false;
        this.horizontalInset = false;
        this.horizontalScaling = "content";
        this.verticalPositioningMode = "uncontrolled";
        this.verticalDefaultPosition = "unset";
        this.verticalViewportLock = false;
        this.verticalInset = false;
        this.verticalScaling = "content";
        this.fixedPlacement = false;
        this.autoUpdateMode = "anchor";
        this.anchorElement = null;
        this.viewportElement = null;
        this.initialLayoutComplete = false;
        this.resizeDetector = null;
        this.baseHorizontalOffset = 0;
        this.baseVerticalOffset = 0;
        this.pendingPositioningUpdate = false;
        this.pendingReset = false;
        this.currentDirection = Direction.ltr;
        this.regionVisible = false;
        this.forceUpdate = false;
        this.updateThreshold = 0.5;
        this.update = () => {
          if (!this.pendingPositioningUpdate) {
            this.requestPositionUpdates();
          }
        };
        this.startObservers = () => {
          this.stopObservers();
          if (this.anchorElement === null) {
            return;
          }
          this.requestPositionUpdates();
          if (this.resizeDetector !== null) {
            this.resizeDetector.observe(this.anchorElement);
            this.resizeDetector.observe(this);
          }
        };
        this.requestPositionUpdates = () => {
          if (this.anchorElement === null || this.pendingPositioningUpdate) {
            return;
          }
          AnchoredRegion.intersectionService.requestPosition(this, this.handleIntersection);
          AnchoredRegion.intersectionService.requestPosition(this.anchorElement, this.handleIntersection);
          if (this.viewportElement !== null) {
            AnchoredRegion.intersectionService.requestPosition(this.viewportElement, this.handleIntersection);
          }
          this.pendingPositioningUpdate = true;
        };
        this.stopObservers = () => {
          if (this.pendingPositioningUpdate) {
            this.pendingPositioningUpdate = false;
            AnchoredRegion.intersectionService.cancelRequestPosition(this, this.handleIntersection);
            if (this.anchorElement !== null) {
              AnchoredRegion.intersectionService.cancelRequestPosition(this.anchorElement, this.handleIntersection);
            }
            if (this.viewportElement !== null) {
              AnchoredRegion.intersectionService.cancelRequestPosition(this.viewportElement, this.handleIntersection);
            }
          }
          if (this.resizeDetector !== null) {
            this.resizeDetector.disconnect();
          }
        };
        this.getViewport = () => {
          if (typeof this.viewport !== "string" || this.viewport === "") {
            return document.documentElement;
          }
          return document.getElementById(this.viewport);
        };
        this.getAnchor = () => {
          return document.getElementById(this.anchor);
        };
        this.handleIntersection = (entries) => {
          if (!this.pendingPositioningUpdate) {
            return;
          }
          this.pendingPositioningUpdate = false;
          if (!this.applyIntersectionEntries(entries)) {
            return;
          }
          this.updateLayout();
        };
        this.applyIntersectionEntries = (entries) => {
          const regionEntry = entries.find((x) => x.target === this);
          const anchorEntry = entries.find((x) => x.target === this.anchorElement);
          const viewportEntry = entries.find((x) => x.target === this.viewportElement);
          if (regionEntry === void 0 || viewportEntry === void 0 || anchorEntry === void 0) {
            return false;
          }
          if (!this.regionVisible || this.forceUpdate || this.regionRect === void 0 || this.anchorRect === void 0 || this.viewportRect === void 0 || this.isRectDifferent(this.anchorRect, anchorEntry.boundingClientRect) || this.isRectDifferent(this.viewportRect, viewportEntry.boundingClientRect) || this.isRectDifferent(this.regionRect, regionEntry.boundingClientRect)) {
            this.regionRect = regionEntry.boundingClientRect;
            this.anchorRect = anchorEntry.boundingClientRect;
            if (this.viewportElement === document.documentElement) {
              this.viewportRect = new DOMRectReadOnly(viewportEntry.boundingClientRect.x + document.documentElement.scrollLeft, viewportEntry.boundingClientRect.y + document.documentElement.scrollTop, viewportEntry.boundingClientRect.width, viewportEntry.boundingClientRect.height);
            } else {
              this.viewportRect = viewportEntry.boundingClientRect;
            }
            this.updateRegionOffset();
            this.forceUpdate = false;
            return true;
          }
          return false;
        };
        this.updateRegionOffset = () => {
          if (this.anchorRect && this.regionRect) {
            this.baseHorizontalOffset = this.baseHorizontalOffset + (this.anchorRect.left - this.regionRect.left) + (this.translateX - this.baseHorizontalOffset);
            this.baseVerticalOffset = this.baseVerticalOffset + (this.anchorRect.top - this.regionRect.top) + (this.translateY - this.baseVerticalOffset);
          }
        };
        this.isRectDifferent = (rectA, rectB) => {
          if (Math.abs(rectA.top - rectB.top) > this.updateThreshold || Math.abs(rectA.right - rectB.right) > this.updateThreshold || Math.abs(rectA.bottom - rectB.bottom) > this.updateThreshold || Math.abs(rectA.left - rectB.left) > this.updateThreshold) {
            return true;
          }
          return false;
        };
        this.handleResize = (entries) => {
          this.update();
        };
        this.reset = () => {
          if (!this.pendingReset) {
            return;
          }
          this.pendingReset = false;
          if (this.anchorElement === null) {
            this.anchorElement = this.getAnchor();
          }
          if (this.viewportElement === null) {
            this.viewportElement = this.getViewport();
          }
          this.currentDirection = getDirection(this);
          this.startObservers();
        };
        this.updateLayout = () => {
          let desiredVerticalPosition = void 0;
          let desiredHorizontalPosition = void 0;
          if (this.horizontalPositioningMode !== "uncontrolled") {
            const horizontalOptions = this.getPositioningOptions(this.horizontalInset);
            if (this.horizontalDefaultPosition === "center") {
              desiredHorizontalPosition = "center";
            } else if (this.horizontalDefaultPosition !== "unset") {
              let dirCorrectedHorizontalDefaultPosition = this.horizontalDefaultPosition;
              if (dirCorrectedHorizontalDefaultPosition === "start" || dirCorrectedHorizontalDefaultPosition === "end") {
                const newDirection = getDirection(this);
                if (newDirection !== this.currentDirection) {
                  this.currentDirection = newDirection;
                  this.initialize();
                  return;
                }
                if (this.currentDirection === Direction.ltr) {
                  dirCorrectedHorizontalDefaultPosition = dirCorrectedHorizontalDefaultPosition === "start" ? "left" : "right";
                } else {
                  dirCorrectedHorizontalDefaultPosition = dirCorrectedHorizontalDefaultPosition === "start" ? "right" : "left";
                }
              }
              switch (dirCorrectedHorizontalDefaultPosition) {
                case "left":
                  desiredHorizontalPosition = this.horizontalInset ? "insetStart" : "start";
                  break;
                case "right":
                  desiredHorizontalPosition = this.horizontalInset ? "insetEnd" : "end";
                  break;
              }
            }
            const horizontalThreshold = this.horizontalThreshold !== void 0 ? this.horizontalThreshold : this.regionRect !== void 0 ? this.regionRect.width : 0;
            const anchorLeft = this.anchorRect !== void 0 ? this.anchorRect.left : 0;
            const anchorRight = this.anchorRect !== void 0 ? this.anchorRect.right : 0;
            const anchorWidth = this.anchorRect !== void 0 ? this.anchorRect.width : 0;
            const viewportLeft = this.viewportRect !== void 0 ? this.viewportRect.left : 0;
            const viewportRight = this.viewportRect !== void 0 ? this.viewportRect.right : 0;
            if (desiredHorizontalPosition === void 0 || !(this.horizontalPositioningMode === "locktodefault") && this.getAvailableSpace(desiredHorizontalPosition, anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) < horizontalThreshold) {
              desiredHorizontalPosition = this.getAvailableSpace(horizontalOptions[0], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) > this.getAvailableSpace(horizontalOptions[1], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) ? horizontalOptions[0] : horizontalOptions[1];
            }
          }
          if (this.verticalPositioningMode !== "uncontrolled") {
            const verticalOptions = this.getPositioningOptions(this.verticalInset);
            if (this.verticalDefaultPosition === "center") {
              desiredVerticalPosition = "center";
            } else if (this.verticalDefaultPosition !== "unset") {
              switch (this.verticalDefaultPosition) {
                case "top":
                  desiredVerticalPosition = this.verticalInset ? "insetStart" : "start";
                  break;
                case "bottom":
                  desiredVerticalPosition = this.verticalInset ? "insetEnd" : "end";
                  break;
              }
            }
            const verticalThreshold = this.verticalThreshold !== void 0 ? this.verticalThreshold : this.regionRect !== void 0 ? this.regionRect.height : 0;
            const anchorTop = this.anchorRect !== void 0 ? this.anchorRect.top : 0;
            const anchorBottom = this.anchorRect !== void 0 ? this.anchorRect.bottom : 0;
            const anchorHeight = this.anchorRect !== void 0 ? this.anchorRect.height : 0;
            const viewportTop = this.viewportRect !== void 0 ? this.viewportRect.top : 0;
            const viewportBottom = this.viewportRect !== void 0 ? this.viewportRect.bottom : 0;
            if (desiredVerticalPosition === void 0 || !(this.verticalPositioningMode === "locktodefault") && this.getAvailableSpace(desiredVerticalPosition, anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) < verticalThreshold) {
              desiredVerticalPosition = this.getAvailableSpace(verticalOptions[0], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) > this.getAvailableSpace(verticalOptions[1], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) ? verticalOptions[0] : verticalOptions[1];
            }
          }
          const nextPositionerDimension = this.getNextRegionDimension(desiredHorizontalPosition, desiredVerticalPosition);
          const positionChanged = this.horizontalPosition !== desiredHorizontalPosition || this.verticalPosition !== desiredVerticalPosition;
          this.setHorizontalPosition(desiredHorizontalPosition, nextPositionerDimension);
          this.setVerticalPosition(desiredVerticalPosition, nextPositionerDimension);
          this.updateRegionStyle();
          if (!this.initialLayoutComplete) {
            this.initialLayoutComplete = true;
            this.requestPositionUpdates();
            return;
          }
          if (!this.regionVisible) {
            this.regionVisible = true;
            this.style.removeProperty("pointer-events");
            this.style.removeProperty("opacity");
            this.classList.toggle("loaded", true);
            this.$emit("loaded", this, { bubbles: false });
          }
          this.updatePositionClasses();
          if (positionChanged) {
            this.$emit("positionchange", this, { bubbles: false });
          }
        };
        this.updateRegionStyle = () => {
          this.style.width = this.regionWidth;
          this.style.height = this.regionHeight;
          this.style.transform = `translate(${this.translateX}px, ${this.translateY}px)`;
        };
        this.updatePositionClasses = () => {
          this.classList.toggle("top", this.verticalPosition === "start");
          this.classList.toggle("bottom", this.verticalPosition === "end");
          this.classList.toggle("inset-top", this.verticalPosition === "insetStart");
          this.classList.toggle("inset-bottom", this.verticalPosition === "insetEnd");
          this.classList.toggle("vertical-center", this.verticalPosition === "center");
          this.classList.toggle("left", this.horizontalPosition === "start");
          this.classList.toggle("right", this.horizontalPosition === "end");
          this.classList.toggle("inset-left", this.horizontalPosition === "insetStart");
          this.classList.toggle("inset-right", this.horizontalPosition === "insetEnd");
          this.classList.toggle("horizontal-center", this.horizontalPosition === "center");
        };
        this.setHorizontalPosition = (desiredHorizontalPosition, nextPositionerDimension) => {
          if (desiredHorizontalPosition === void 0 || this.regionRect === void 0 || this.anchorRect === void 0 || this.viewportRect === void 0) {
            return;
          }
          let nextRegionWidth = 0;
          switch (this.horizontalScaling) {
            case "anchor":
            case "fill":
              nextRegionWidth = this.horizontalViewportLock ? this.viewportRect.width : nextPositionerDimension.width;
              this.regionWidth = `${nextRegionWidth}px`;
              break;
            case "content":
              nextRegionWidth = this.regionRect.width;
              this.regionWidth = "unset";
              break;
          }
          let sizeDelta = 0;
          switch (desiredHorizontalPosition) {
            case "start":
              this.translateX = this.baseHorizontalOffset - nextRegionWidth;
              if (this.horizontalViewportLock && this.anchorRect.left > this.viewportRect.right) {
                this.translateX = this.translateX - (this.anchorRect.left - this.viewportRect.right);
              }
              break;
            case "insetStart":
              this.translateX = this.baseHorizontalOffset - nextRegionWidth + this.anchorRect.width;
              if (this.horizontalViewportLock && this.anchorRect.right > this.viewportRect.right) {
                this.translateX = this.translateX - (this.anchorRect.right - this.viewportRect.right);
              }
              break;
            case "insetEnd":
              this.translateX = this.baseHorizontalOffset;
              if (this.horizontalViewportLock && this.anchorRect.left < this.viewportRect.left) {
                this.translateX = this.translateX - (this.anchorRect.left - this.viewportRect.left);
              }
              break;
            case "end":
              this.translateX = this.baseHorizontalOffset + this.anchorRect.width;
              if (this.horizontalViewportLock && this.anchorRect.right < this.viewportRect.left) {
                this.translateX = this.translateX - (this.anchorRect.right - this.viewportRect.left);
              }
              break;
            case "center":
              sizeDelta = (this.anchorRect.width - nextRegionWidth) / 2;
              this.translateX = this.baseHorizontalOffset + sizeDelta;
              if (this.horizontalViewportLock) {
                const regionLeft = this.anchorRect.left + sizeDelta;
                const regionRight = this.anchorRect.right - sizeDelta;
                if (regionLeft < this.viewportRect.left && !(regionRight > this.viewportRect.right)) {
                  this.translateX = this.translateX - (regionLeft - this.viewportRect.left);
                } else if (regionRight > this.viewportRect.right && !(regionLeft < this.viewportRect.left)) {
                  this.translateX = this.translateX - (regionRight - this.viewportRect.right);
                }
              }
              break;
          }
          this.horizontalPosition = desiredHorizontalPosition;
        };
        this.setVerticalPosition = (desiredVerticalPosition, nextPositionerDimension) => {
          if (desiredVerticalPosition === void 0 || this.regionRect === void 0 || this.anchorRect === void 0 || this.viewportRect === void 0) {
            return;
          }
          let nextRegionHeight = 0;
          switch (this.verticalScaling) {
            case "anchor":
            case "fill":
              nextRegionHeight = this.verticalViewportLock ? this.viewportRect.height : nextPositionerDimension.height;
              this.regionHeight = `${nextRegionHeight}px`;
              break;
            case "content":
              nextRegionHeight = this.regionRect.height;
              this.regionHeight = "unset";
              break;
          }
          let sizeDelta = 0;
          switch (desiredVerticalPosition) {
            case "start":
              this.translateY = this.baseVerticalOffset - nextRegionHeight;
              if (this.verticalViewportLock && this.anchorRect.top > this.viewportRect.bottom) {
                this.translateY = this.translateY - (this.anchorRect.top - this.viewportRect.bottom);
              }
              break;
            case "insetStart":
              this.translateY = this.baseVerticalOffset - nextRegionHeight + this.anchorRect.height;
              if (this.verticalViewportLock && this.anchorRect.bottom > this.viewportRect.bottom) {
                this.translateY = this.translateY - (this.anchorRect.bottom - this.viewportRect.bottom);
              }
              break;
            case "insetEnd":
              this.translateY = this.baseVerticalOffset;
              if (this.verticalViewportLock && this.anchorRect.top < this.viewportRect.top) {
                this.translateY = this.translateY - (this.anchorRect.top - this.viewportRect.top);
              }
              break;
            case "end":
              this.translateY = this.baseVerticalOffset + this.anchorRect.height;
              if (this.verticalViewportLock && this.anchorRect.bottom < this.viewportRect.top) {
                this.translateY = this.translateY - (this.anchorRect.bottom - this.viewportRect.top);
              }
              break;
            case "center":
              sizeDelta = (this.anchorRect.height - nextRegionHeight) / 2;
              this.translateY = this.baseVerticalOffset + sizeDelta;
              if (this.verticalViewportLock) {
                const regionTop = this.anchorRect.top + sizeDelta;
                const regionBottom = this.anchorRect.bottom - sizeDelta;
                if (regionTop < this.viewportRect.top && !(regionBottom > this.viewportRect.bottom)) {
                  this.translateY = this.translateY - (regionTop - this.viewportRect.top);
                } else if (regionBottom > this.viewportRect.bottom && !(regionTop < this.viewportRect.top)) {
                  this.translateY = this.translateY - (regionBottom - this.viewportRect.bottom);
                }
              }
          }
          this.verticalPosition = desiredVerticalPosition;
        };
        this.getPositioningOptions = (inset) => {
          if (inset) {
            return ["insetStart", "insetEnd"];
          }
          return ["start", "end"];
        };
        this.getAvailableSpace = (positionOption, anchorStart, anchorEnd, anchorSpan, viewportStart, viewportEnd) => {
          const spaceStart = anchorStart - viewportStart;
          const spaceEnd = viewportEnd - (anchorStart + anchorSpan);
          switch (positionOption) {
            case "start":
              return spaceStart;
            case "insetStart":
              return spaceStart + anchorSpan;
            case "insetEnd":
              return spaceEnd + anchorSpan;
            case "end":
              return spaceEnd;
            case "center":
              return Math.min(spaceStart, spaceEnd) * 2 + anchorSpan;
          }
        };
        this.getNextRegionDimension = (desiredHorizontalPosition, desiredVerticalPosition) => {
          const newRegionDimension = {
            height: this.regionRect !== void 0 ? this.regionRect.height : 0,
            width: this.regionRect !== void 0 ? this.regionRect.width : 0
          };
          if (desiredHorizontalPosition !== void 0 && this.horizontalScaling === "fill") {
            newRegionDimension.width = this.getAvailableSpace(desiredHorizontalPosition, this.anchorRect !== void 0 ? this.anchorRect.left : 0, this.anchorRect !== void 0 ? this.anchorRect.right : 0, this.anchorRect !== void 0 ? this.anchorRect.width : 0, this.viewportRect !== void 0 ? this.viewportRect.left : 0, this.viewportRect !== void 0 ? this.viewportRect.right : 0);
          } else if (this.horizontalScaling === "anchor") {
            newRegionDimension.width = this.anchorRect !== void 0 ? this.anchorRect.width : 0;
          }
          if (desiredVerticalPosition !== void 0 && this.verticalScaling === "fill") {
            newRegionDimension.height = this.getAvailableSpace(desiredVerticalPosition, this.anchorRect !== void 0 ? this.anchorRect.top : 0, this.anchorRect !== void 0 ? this.anchorRect.bottom : 0, this.anchorRect !== void 0 ? this.anchorRect.height : 0, this.viewportRect !== void 0 ? this.viewportRect.top : 0, this.viewportRect !== void 0 ? this.viewportRect.bottom : 0);
          } else if (this.verticalScaling === "anchor") {
            newRegionDimension.height = this.anchorRect !== void 0 ? this.anchorRect.height : 0;
          }
          return newRegionDimension;
        };
        this.startAutoUpdateEventListeners = () => {
          window.addEventListener(eventResize, this.update, { passive: true });
          window.addEventListener(eventScroll, this.update, {
            passive: true,
            capture: true
          });
          if (this.resizeDetector !== null && this.viewportElement !== null) {
            this.resizeDetector.observe(this.viewportElement);
          }
        };
        this.stopAutoUpdateEventListeners = () => {
          window.removeEventListener(eventResize, this.update);
          window.removeEventListener(eventScroll, this.update);
          if (this.resizeDetector !== null && this.viewportElement !== null) {
            this.resizeDetector.unobserve(this.viewportElement);
          }
        };
      }
      anchorChanged() {
        if (this.initialLayoutComplete) {
          this.anchorElement = this.getAnchor();
        }
      }
      viewportChanged() {
        if (this.initialLayoutComplete) {
          this.viewportElement = this.getViewport();
        }
      }
      horizontalPositioningModeChanged() {
        this.requestReset();
      }
      horizontalDefaultPositionChanged() {
        this.updateForAttributeChange();
      }
      horizontalViewportLockChanged() {
        this.updateForAttributeChange();
      }
      horizontalInsetChanged() {
        this.updateForAttributeChange();
      }
      horizontalThresholdChanged() {
        this.updateForAttributeChange();
      }
      horizontalScalingChanged() {
        this.updateForAttributeChange();
      }
      verticalPositioningModeChanged() {
        this.requestReset();
      }
      verticalDefaultPositionChanged() {
        this.updateForAttributeChange();
      }
      verticalViewportLockChanged() {
        this.updateForAttributeChange();
      }
      verticalInsetChanged() {
        this.updateForAttributeChange();
      }
      verticalThresholdChanged() {
        this.updateForAttributeChange();
      }
      verticalScalingChanged() {
        this.updateForAttributeChange();
      }
      fixedPlacementChanged() {
        if (this.$fastController.isConnected && this.initialLayoutComplete) {
          this.initialize();
        }
      }
      autoUpdateModeChanged(prevMode, newMode) {
        if (this.$fastController.isConnected && this.initialLayoutComplete) {
          if (prevMode === "auto") {
            this.stopAutoUpdateEventListeners();
          }
          if (newMode === "auto") {
            this.startAutoUpdateEventListeners();
          }
        }
      }
      anchorElementChanged() {
        this.requestReset();
      }
      viewportElementChanged() {
        if (this.$fastController.isConnected && this.initialLayoutComplete) {
          this.initialize();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (this.autoUpdateMode === "auto") {
          this.startAutoUpdateEventListeners();
        }
        this.initialize();
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        if (this.autoUpdateMode === "auto") {
          this.stopAutoUpdateEventListeners();
        }
        this.stopObservers();
        this.disconnectResizeDetector();
      }
      /**
       * @internal
       */
      adoptedCallback() {
        this.initialize();
      }
      /**
       * destroys the instance's resize observer
       */
      disconnectResizeDetector() {
        if (this.resizeDetector !== null) {
          this.resizeDetector.disconnect();
          this.resizeDetector = null;
        }
      }
      /**
       * initializes the instance's resize observer
       */
      initializeResizeDetector() {
        this.disconnectResizeDetector();
        this.resizeDetector = new window.ResizeObserver(this.handleResize);
      }
      /**
       * react to attribute changes that don't require a reset
       */
      updateForAttributeChange() {
        if (this.$fastController.isConnected && this.initialLayoutComplete) {
          this.forceUpdate = true;
          this.update();
        }
      }
      /**
       * fully initializes the component
       */
      initialize() {
        this.initializeResizeDetector();
        if (this.anchorElement === null) {
          this.anchorElement = this.getAnchor();
        }
        this.requestReset();
      }
      /**
       * Request a reset if there are currently no open requests
       */
      requestReset() {
        if (this.$fastController.isConnected && this.pendingReset === false) {
          this.setInitialState();
          DOM.queueUpdate(() => this.reset());
          this.pendingReset = true;
        }
      }
      /**
       * sets the starting configuration for component internal values
       */
      setInitialState() {
        this.initialLayoutComplete = false;
        this.regionVisible = false;
        this.translateX = 0;
        this.translateY = 0;
        this.baseHorizontalOffset = 0;
        this.baseVerticalOffset = 0;
        this.viewportRect = void 0;
        this.regionRect = void 0;
        this.anchorRect = void 0;
        this.verticalPosition = void 0;
        this.horizontalPosition = void 0;
        this.style.opacity = "0";
        this.style.pointerEvents = "none";
        this.forceUpdate = false;
        this.style.position = this.fixedPlacement ? "fixed" : "absolute";
        this.updatePositionClasses();
        this.updateRegionStyle();
      }
    };
    AnchoredRegion.intersectionService = new IntersectionService();
    __decorate([
      attr
    ], AnchoredRegion.prototype, "anchor", void 0);
    __decorate([
      attr
    ], AnchoredRegion.prototype, "viewport", void 0);
    __decorate([
      attr({ attribute: "horizontal-positioning-mode" })
    ], AnchoredRegion.prototype, "horizontalPositioningMode", void 0);
    __decorate([
      attr({ attribute: "horizontal-default-position" })
    ], AnchoredRegion.prototype, "horizontalDefaultPosition", void 0);
    __decorate([
      attr({ attribute: "horizontal-viewport-lock", mode: "boolean" })
    ], AnchoredRegion.prototype, "horizontalViewportLock", void 0);
    __decorate([
      attr({ attribute: "horizontal-inset", mode: "boolean" })
    ], AnchoredRegion.prototype, "horizontalInset", void 0);
    __decorate([
      attr({ attribute: "horizontal-threshold" })
    ], AnchoredRegion.prototype, "horizontalThreshold", void 0);
    __decorate([
      attr({ attribute: "horizontal-scaling" })
    ], AnchoredRegion.prototype, "horizontalScaling", void 0);
    __decorate([
      attr({ attribute: "vertical-positioning-mode" })
    ], AnchoredRegion.prototype, "verticalPositioningMode", void 0);
    __decorate([
      attr({ attribute: "vertical-default-position" })
    ], AnchoredRegion.prototype, "verticalDefaultPosition", void 0);
    __decorate([
      attr({ attribute: "vertical-viewport-lock", mode: "boolean" })
    ], AnchoredRegion.prototype, "verticalViewportLock", void 0);
    __decorate([
      attr({ attribute: "vertical-inset", mode: "boolean" })
    ], AnchoredRegion.prototype, "verticalInset", void 0);
    __decorate([
      attr({ attribute: "vertical-threshold" })
    ], AnchoredRegion.prototype, "verticalThreshold", void 0);
    __decorate([
      attr({ attribute: "vertical-scaling" })
    ], AnchoredRegion.prototype, "verticalScaling", void 0);
    __decorate([
      attr({ attribute: "fixed-placement", mode: "boolean" })
    ], AnchoredRegion.prototype, "fixedPlacement", void 0);
    __decorate([
      attr({ attribute: "auto-update-mode" })
    ], AnchoredRegion.prototype, "autoUpdateMode", void 0);
    __decorate([
      observable
    ], AnchoredRegion.prototype, "anchorElement", void 0);
    __decorate([
      observable
    ], AnchoredRegion.prototype, "viewportElement", void 0);
    __decorate([
      observable
    ], AnchoredRegion.prototype, "initialLayoutComplete", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region-config.js
var horizontalAnchorOverlay, FlyoutPosTop, FlyoutPosBottom, FlyoutPosTallest, FlyoutPosTopFill, FlyoutPosBottomFill, FlyoutPosTallestFill;
var init_anchored_region_config = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region-config.js"() {
    horizontalAnchorOverlay = {
      horizontalDefaultPosition: "center",
      horizontalPositioningMode: "locktodefault",
      horizontalInset: false,
      horizontalScaling: "anchor"
    };
    FlyoutPosTop = Object.assign(Object.assign({}, horizontalAnchorOverlay), { verticalDefaultPosition: "top", verticalPositioningMode: "locktodefault", verticalInset: false, verticalScaling: "content" });
    FlyoutPosBottom = Object.assign(Object.assign({}, horizontalAnchorOverlay), { verticalDefaultPosition: "bottom", verticalPositioningMode: "locktodefault", verticalInset: false, verticalScaling: "content" });
    FlyoutPosTallest = Object.assign(Object.assign({}, horizontalAnchorOverlay), { verticalPositioningMode: "dynamic", verticalInset: false, verticalScaling: "content" });
    FlyoutPosTopFill = Object.assign(Object.assign({}, FlyoutPosTop), { verticalScaling: "fill" });
    FlyoutPosBottomFill = Object.assign(Object.assign({}, FlyoutPosBottom), { verticalScaling: "fill" });
    FlyoutPosTallestFill = Object.assign(Object.assign({}, FlyoutPosTallest), { verticalScaling: "fill" });
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/index.js
var init_anchored_region2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/index.js"() {
    init_anchored_region_template();
    init_anchored_region();
    init_anchored_region_config();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/avatar/avatar.template.js
var avatarTemplate;
var init_avatar_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/avatar/avatar.template.js"() {
    init_esm();
    avatarTemplate = (context, definition) => html`
    <div
        class="backplate ${(x) => x.shape}"
        part="backplate"
        style="${(x) => x.fill ? `background-color: var(--avatar-fill-${x.fill});` : void 0}"
    >
        <a
            class="link"
            part="link"
            href="${(x) => x.link ? x.link : void 0}"
            style="${(x) => x.color ? `color: var(--avatar-color-${x.color});` : void 0}"
        >
            <slot name="media" part="media">${definition.media || ""}</slot>
            <slot class="content" part="content"><slot>
        </a>
    </div>
    <slot name="badge" part="badge"></slot>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/avatar/avatar.js
var Avatar;
var init_avatar = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/avatar/avatar.js"() {
    init_tslib_es6();
    init_esm();
    init_foundation_element();
    Avatar = class extends FoundationElement {
      /**
       * Internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (!this.shape) {
          this.shape = "circle";
        }
      }
    };
    __decorate([
      attr
    ], Avatar.prototype, "fill", void 0);
    __decorate([
      attr
    ], Avatar.prototype, "color", void 0);
    __decorate([
      attr
    ], Avatar.prototype, "link", void 0);
    __decorate([
      attr
    ], Avatar.prototype, "shape", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/avatar/index.js
var init_avatar2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/avatar/index.js"() {
    init_avatar_template();
    init_avatar();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/badge/badge.template.js
var badgeTemplate;
var init_badge_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/badge/badge.template.js"() {
    init_esm();
    badgeTemplate = (context, definition) => html`
    <template class="${(x) => x.circular ? "circular" : ""}">
        <div class="control" part="control" style="${(x) => x.generateBadgeStyle()}">
            <slot></slot>
        </div>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/badge/badge.js
var Badge;
var init_badge = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/badge/badge.js"() {
    init_tslib_es6();
    init_esm();
    init_foundation_element();
    Badge = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.generateBadgeStyle = () => {
          if (!this.fill && !this.color) {
            return;
          }
          const fill = `background-color: var(--badge-fill-${this.fill});`;
          const color = `color: var(--badge-color-${this.color});`;
          if (this.fill && !this.color) {
            return fill;
          } else if (this.color && !this.fill) {
            return color;
          } else {
            return `${color} ${fill}`;
          }
        };
      }
    };
    __decorate([
      attr({ attribute: "fill" })
    ], Badge.prototype, "fill", void 0);
    __decorate([
      attr({ attribute: "color" })
    ], Badge.prototype, "color", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], Badge.prototype, "circular", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/badge/index.js
var init_badge2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/badge/index.js"() {
    init_badge_template();
    init_badge();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb-item/breadcrumb-item.template.js
var breadcrumbItemTemplate;
var init_breadcrumb_item_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb-item/breadcrumb-item.template.js"() {
    init_esm();
    init_anchor_template();
    init_start_end();
    breadcrumbItemTemplate = (context, definition) => html`
    <div role="listitem" class="listitem" part="listitem">
        ${when((x) => x.href && x.href.length > 0, html`
                ${anchorTemplate(context, definition)}
            `)}
        ${when((x) => !x.href, html`
                ${startSlotTemplate(context, definition)}
                <slot></slot>
                ${endSlotTemplate(context, definition)}
            `)}
        ${when((x) => x.separator, html`
                <span class="separator" part="separator" aria-hidden="true">
                    <slot name="separator">${definition.separator || ""}</slot>
                </span>
            `)}
    </div>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb-item/breadcrumb-item.js
var BreadcrumbItem;
var init_breadcrumb_item = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb-item/breadcrumb-item.js"() {
    init_tslib_es6();
    init_esm();
    init_anchor();
    init_patterns();
    init_apply_mixins();
    BreadcrumbItem = class extends Anchor {
      constructor() {
        super(...arguments);
        this.separator = true;
      }
    };
    __decorate([
      observable
    ], BreadcrumbItem.prototype, "separator", void 0);
    applyMixins(BreadcrumbItem, StartEnd, DelegatesARIALink);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb-item/index.js
var init_breadcrumb_item2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb-item/index.js"() {
    init_breadcrumb_item_template();
    init_breadcrumb_item();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb/breadcrumb.template.js
var breadcrumbTemplate;
var init_breadcrumb_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb/breadcrumb.template.js"() {
    init_esm();
    breadcrumbTemplate = (context, definition) => html`
    <template role="navigation">
        <div role="list" class="list" part="list">
            <slot
                ${slotted({ property: "slottedBreadcrumbItems", filter: elements() })}
            ></slot>
        </div>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb/breadcrumb.js
var Breadcrumb;
var init_breadcrumb = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb/breadcrumb.js"() {
    init_tslib_es6();
    init_esm();
    init_breadcrumb_item();
    init_foundation_element();
    Breadcrumb = class extends FoundationElement {
      slottedBreadcrumbItemsChanged() {
        if (this.$fastController.isConnected) {
          if (this.slottedBreadcrumbItems === void 0 || this.slottedBreadcrumbItems.length === 0) {
            return;
          }
          const lastNode = this.slottedBreadcrumbItems[this.slottedBreadcrumbItems.length - 1];
          this.slottedBreadcrumbItems.forEach((item) => {
            const itemIsLastNode = item === lastNode;
            this.setItemSeparator(item, itemIsLastNode);
            this.setAriaCurrent(item, itemIsLastNode);
          });
        }
      }
      setItemSeparator(item, isLastNode) {
        if (item instanceof BreadcrumbItem) {
          item.separator = !isLastNode;
        }
      }
      /**
       * Finds href on childnodes in the light DOM or shadow DOM.
       * We look in the shadow DOM because we insert an anchor when breadcrumb-item has an href.
       */
      findChildWithHref(node) {
        var _a, _b;
        if (node.childElementCount > 0) {
          return node.querySelector("a[href]");
        } else if ((_a = node.shadowRoot) === null || _a === void 0 ? void 0 : _a.childElementCount) {
          return (_b = node.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector("a[href]");
        } else
          return null;
      }
      /**
       *  Sets ARIA Current for the current node
       * If child node with an anchor tag and with href is found then set aria-current to correct value for the child node,
       * otherwise apply aria-current to the host element, with an href
       */
      setAriaCurrent(item, isLastNode) {
        const childNodeWithHref = this.findChildWithHref(item);
        if (childNodeWithHref === null && item.hasAttribute("href") && item instanceof BreadcrumbItem) {
          isLastNode ? item.setAttribute("aria-current", "page") : item.removeAttribute("aria-current");
        } else if (childNodeWithHref !== null) {
          isLastNode ? childNodeWithHref.setAttribute("aria-current", "page") : childNodeWithHref.removeAttribute("aria-current");
        }
      }
    };
    __decorate([
      observable
    ], Breadcrumb.prototype, "slottedBreadcrumbItems", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb/index.js
var init_breadcrumb2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb/index.js"() {
    init_breadcrumb_template();
    init_breadcrumb();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/button/button.template.js
var buttonTemplate;
var init_button_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/button/button.template.js"() {
    init_esm();
    init_start_end();
    buttonTemplate = (context, definition) => html`
    <button
        class="control"
        part="control"
        ?autofocus="${(x) => x.autofocus}"
        ?disabled="${(x) => x.disabled}"
        form="${(x) => x.formId}"
        formaction="${(x) => x.formaction}"
        formenctype="${(x) => x.formenctype}"
        formmethod="${(x) => x.formmethod}"
        formnovalidate="${(x) => x.formnovalidate}"
        formtarget="${(x) => x.formtarget}"
        name="${(x) => x.name}"
        type="${(x) => x.type}"
        value="${(x) => x.value}"
        aria-atomic="${(x) => x.ariaAtomic}"
        aria-busy="${(x) => x.ariaBusy}"
        aria-controls="${(x) => x.ariaControls}"
        aria-current="${(x) => x.ariaCurrent}"
        aria-describedby="${(x) => x.ariaDescribedby}"
        aria-details="${(x) => x.ariaDetails}"
        aria-disabled="${(x) => x.ariaDisabled}"
        aria-errormessage="${(x) => x.ariaErrormessage}"
        aria-expanded="${(x) => x.ariaExpanded}"
        aria-flowto="${(x) => x.ariaFlowto}"
        aria-haspopup="${(x) => x.ariaHaspopup}"
        aria-hidden="${(x) => x.ariaHidden}"
        aria-invalid="${(x) => x.ariaInvalid}"
        aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
        aria-label="${(x) => x.ariaLabel}"
        aria-labelledby="${(x) => x.ariaLabelledby}"
        aria-live="${(x) => x.ariaLive}"
        aria-owns="${(x) => x.ariaOwns}"
        aria-pressed="${(x) => x.ariaPressed}"
        aria-relevant="${(x) => x.ariaRelevant}"
        aria-roledescription="${(x) => x.ariaRoledescription}"
        ${ref("control")}
    >
        ${startSlotTemplate(context, definition)}
        <span class="content" part="content">
            <slot ${slotted("defaultSlottedContent")}></slot>
        </span>
        ${endSlotTemplate(context, definition)}
    </button>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/form-associated/form-associated.js
function FormAssociated(BaseCtor) {
  const C = class extends BaseCtor {
    constructor(...args) {
      super(...args);
      this.dirtyValue = false;
      this.disabled = false;
      this.proxyEventsToBlock = ["change", "click"];
      this.proxyInitialized = false;
      this.required = false;
      this.initialValue = this.initialValue || "";
      if (!this.elementInternals) {
        this.formResetCallback = this.formResetCallback.bind(this);
      }
    }
    /**
     * Must evaluate to true to enable elementInternals.
     * Feature detects API support and resolve respectively
     *
     * @internal
     */
    static get formAssociated() {
      return supportsElementInternals;
    }
    /**
     * Returns the validity state of the element
     *
     * @alpha
     */
    get validity() {
      return this.elementInternals ? this.elementInternals.validity : this.proxy.validity;
    }
    /**
     * Retrieve a reference to the associated form.
     * Returns null if not associated to any form.
     *
     * @alpha
     */
    get form() {
      return this.elementInternals ? this.elementInternals.form : this.proxy.form;
    }
    /**
     * Retrieve the localized validation message,
     * or custom validation message if set.
     *
     * @alpha
     */
    get validationMessage() {
      return this.elementInternals ? this.elementInternals.validationMessage : this.proxy.validationMessage;
    }
    /**
     * Whether the element will be validated when the
     * form is submitted
     */
    get willValidate() {
      return this.elementInternals ? this.elementInternals.willValidate : this.proxy.willValidate;
    }
    /**
     * A reference to all associated label elements
     */
    get labels() {
      if (this.elementInternals) {
        return Object.freeze(Array.from(this.elementInternals.labels));
      } else if (this.proxy instanceof HTMLElement && this.proxy.ownerDocument && this.id) {
        const parentLabels = this.proxy.labels;
        const forLabels = Array.from(this.proxy.getRootNode().querySelectorAll(`[for='${this.id}']`));
        const labels = parentLabels ? forLabels.concat(Array.from(parentLabels)) : forLabels;
        return Object.freeze(labels);
      } else {
        return emptyArray;
      }
    }
    /**
     * Invoked when the `value` property changes
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `valueChanged` method
     * They must be sure to invoke `super.valueChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    valueChanged(previous, next) {
      this.dirtyValue = true;
      if (this.proxy instanceof HTMLElement) {
        this.proxy.value = this.value;
      }
      this.currentValue = this.value;
      this.setFormValue(this.value);
      this.validate();
    }
    currentValueChanged() {
      this.value = this.currentValue;
    }
    /**
     * Invoked when the `initialValue` property changes
     *
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `initialValueChanged` method
     * They must be sure to invoke `super.initialValueChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    initialValueChanged(previous, next) {
      if (!this.dirtyValue) {
        this.value = this.initialValue;
        this.dirtyValue = false;
      }
    }
    /**
     * Invoked when the `disabled` property changes
     *
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `disabledChanged` method
     * They must be sure to invoke `super.disabledChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    disabledChanged(previous, next) {
      if (this.proxy instanceof HTMLElement) {
        this.proxy.disabled = this.disabled;
      }
      DOM.queueUpdate(() => this.classList.toggle("disabled", this.disabled));
    }
    /**
     * Invoked when the `name` property changes
     *
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `nameChanged` method
     * They must be sure to invoke `super.nameChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    nameChanged(previous, next) {
      if (this.proxy instanceof HTMLElement) {
        this.proxy.name = this.name;
      }
    }
    /**
     * Invoked when the `required` property changes
     *
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `requiredChanged` method
     * They must be sure to invoke `super.requiredChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    requiredChanged(prev, next) {
      if (this.proxy instanceof HTMLElement) {
        this.proxy.required = this.required;
      }
      DOM.queueUpdate(() => this.classList.toggle("required", this.required));
      this.validate();
    }
    /**
     * The element internals object. Will only exist
     * in browsers supporting the attachInternals API
     */
    get elementInternals() {
      if (!supportsElementInternals) {
        return null;
      }
      let internals = InternalsMap.get(this);
      if (!internals) {
        internals = this.attachInternals();
        InternalsMap.set(this, internals);
      }
      return internals;
    }
    /**
     * @internal
     */
    connectedCallback() {
      super.connectedCallback();
      this.addEventListener("keypress", this._keypressHandler);
      if (!this.value) {
        this.value = this.initialValue;
        this.dirtyValue = false;
      }
      if (!this.elementInternals) {
        this.attachProxy();
        if (this.form) {
          this.form.addEventListener("reset", this.formResetCallback);
        }
      }
    }
    /**
     * @internal
     */
    disconnectedCallback() {
      super.disconnectedCallback();
      this.proxyEventsToBlock.forEach((name2) => this.proxy.removeEventListener(name2, this.stopPropagation));
      if (!this.elementInternals && this.form) {
        this.form.removeEventListener("reset", this.formResetCallback);
      }
    }
    /**
     * Return the current validity of the element.
     */
    checkValidity() {
      return this.elementInternals ? this.elementInternals.checkValidity() : this.proxy.checkValidity();
    }
    /**
     * Return the current validity of the element.
     * If false, fires an invalid event at the element.
     */
    reportValidity() {
      return this.elementInternals ? this.elementInternals.reportValidity() : this.proxy.reportValidity();
    }
    /**
     * Set the validity of the control. In cases when the elementInternals object is not
     * available (and the proxy element is used to report validity), this function will
     * do nothing unless a message is provided, at which point the setCustomValidity method
     * of the proxy element will be invoked with the provided message.
     * @param flags - Validity flags
     * @param message - Optional message to supply
     * @param anchor - Optional element used by UA to display an interactive validation UI
     */
    setValidity(flags, message, anchor) {
      if (this.elementInternals) {
        this.elementInternals.setValidity(flags, message, anchor);
      } else if (typeof message === "string") {
        this.proxy.setCustomValidity(message);
      }
    }
    /**
     * Invoked when a connected component's form or fieldset has its disabled
     * state changed.
     * @param disabled - the disabled value of the form / fieldset
     */
    formDisabledCallback(disabled) {
      this.disabled = disabled;
    }
    formResetCallback() {
      this.value = this.initialValue;
      this.dirtyValue = false;
    }
    /**
     * Attach the proxy element to the DOM
     */
    attachProxy() {
      var _a;
      if (!this.proxyInitialized) {
        this.proxyInitialized = true;
        this.proxy.style.display = "none";
        this.proxyEventsToBlock.forEach((name2) => this.proxy.addEventListener(name2, this.stopPropagation));
        this.proxy.disabled = this.disabled;
        this.proxy.required = this.required;
        if (typeof this.name === "string") {
          this.proxy.name = this.name;
        }
        if (typeof this.value === "string") {
          this.proxy.value = this.value;
        }
        this.proxy.setAttribute("slot", proxySlotName);
        this.proxySlot = document.createElement("slot");
        this.proxySlot.setAttribute("name", proxySlotName);
      }
      (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.appendChild(this.proxySlot);
      this.appendChild(this.proxy);
    }
    /**
     * Detach the proxy element from the DOM
     */
    detachProxy() {
      var _a;
      this.removeChild(this.proxy);
      (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.removeChild(this.proxySlot);
    }
    /** {@inheritDoc (FormAssociated:interface).validate} */
    validate(anchor) {
      if (this.proxy instanceof HTMLElement) {
        this.setValidity(this.proxy.validity, this.proxy.validationMessage, anchor);
      }
    }
    /**
     * Associates the provided value (and optional state) with the parent form.
     * @param value - The value to set
     * @param state - The state object provided to during session restores and when autofilling.
     */
    setFormValue(value, state) {
      if (this.elementInternals) {
        this.elementInternals.setFormValue(value, state || value);
      }
    }
    _keypressHandler(e) {
      switch (e.key) {
        case keyEnter:
          if (this.form instanceof HTMLFormElement) {
            const defaultButton = this.form.querySelector("[type=submit]");
            defaultButton === null || defaultButton === void 0 ? void 0 : defaultButton.click();
          }
          break;
      }
    }
    /**
     * Used to stop propagation of proxy element events
     * @param e - Event object
     */
    stopPropagation(e) {
      e.stopPropagation();
    }
  };
  attr({ mode: "boolean" })(C.prototype, "disabled");
  attr({ mode: "fromView", attribute: "value" })(C.prototype, "initialValue");
  attr({ attribute: "current-value" })(C.prototype, "currentValue");
  attr(C.prototype, "name");
  attr({ mode: "boolean" })(C.prototype, "required");
  observable(C.prototype, "value");
  return C;
}
function CheckableFormAssociated(BaseCtor) {
  class C extends FormAssociated(BaseCtor) {
  }
  class D extends C {
    constructor(...args) {
      super(args);
      this.dirtyChecked = false;
      this.checkedAttribute = false;
      this.checked = false;
      this.dirtyChecked = false;
    }
    checkedAttributeChanged() {
      this.defaultChecked = this.checkedAttribute;
    }
    /**
     * @internal
     */
    defaultCheckedChanged() {
      if (!this.dirtyChecked) {
        this.checked = this.defaultChecked;
        this.dirtyChecked = false;
      }
    }
    checkedChanged(prev, next) {
      if (!this.dirtyChecked) {
        this.dirtyChecked = true;
      }
      this.currentChecked = this.checked;
      this.updateForm();
      if (this.proxy instanceof HTMLInputElement) {
        this.proxy.checked = this.checked;
      }
      if (prev !== void 0) {
        this.$emit("change");
      }
      this.validate();
    }
    currentCheckedChanged(prev, next) {
      this.checked = this.currentChecked;
    }
    updateForm() {
      const value = this.checked ? this.value : null;
      this.setFormValue(value, value);
    }
    connectedCallback() {
      super.connectedCallback();
      this.updateForm();
    }
    formResetCallback() {
      super.formResetCallback();
      this.checked = !!this.checkedAttribute;
      this.dirtyChecked = false;
    }
  }
  attr({ attribute: "checked", mode: "boolean" })(D.prototype, "checkedAttribute");
  attr({ attribute: "current-checked", converter: booleanConverter })(D.prototype, "currentChecked");
  observable(D.prototype, "defaultChecked");
  observable(D.prototype, "checked");
  return D;
}
var proxySlotName, ElementInternalsKey, supportsElementInternals, InternalsMap;
var init_form_associated = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/form-associated/form-associated.js"() {
    init_esm();
    init_dist4();
    proxySlotName = "form-associated-proxy";
    ElementInternalsKey = "ElementInternals";
    supportsElementInternals = ElementInternalsKey in window && "setFormValue" in window[ElementInternalsKey].prototype;
    InternalsMap = /* @__PURE__ */ new WeakMap();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/button/button.form-associated.js
var _Button, FormAssociatedButton;
var init_button_form_associated = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/button/button.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _Button = class extends FoundationElement {
    };
    FormAssociatedButton = class extends FormAssociated(_Button) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/button/button.js
var Button2, DelegatesARIAButton;
var init_button2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/button/button.js"() {
    init_tslib_es6();
    init_esm();
    init_patterns();
    init_apply_mixins();
    init_button_form_associated();
    Button2 = class extends FormAssociatedButton {
      constructor() {
        super(...arguments);
        this.handleClick = (e) => {
          var _a;
          if (this.disabled && ((_a = this.defaultSlottedContent) === null || _a === void 0 ? void 0 : _a.length) <= 1) {
            e.stopPropagation();
          }
        };
        this.handleSubmission = () => {
          if (!this.form) {
            return;
          }
          const attached = this.proxy.isConnected;
          if (!attached) {
            this.attachProxy();
          }
          typeof this.form.requestSubmit === "function" ? this.form.requestSubmit(this.proxy) : this.proxy.click();
          if (!attached) {
            this.detachProxy();
          }
        };
        this.handleFormReset = () => {
          var _a;
          (_a = this.form) === null || _a === void 0 ? void 0 : _a.reset();
        };
        this.handleUnsupportedDelegatesFocus = () => {
          var _a;
          if (window.ShadowRoot && !window.ShadowRoot.prototype.hasOwnProperty("delegatesFocus") && ((_a = this.$fastController.definition.shadowOptions) === null || _a === void 0 ? void 0 : _a.delegatesFocus)) {
            this.focus = () => {
              this.control.focus();
            };
          }
        };
      }
      formactionChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.formAction = this.formaction;
        }
      }
      formenctypeChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.formEnctype = this.formenctype;
        }
      }
      formmethodChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.formMethod = this.formmethod;
        }
      }
      formnovalidateChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.formNoValidate = this.formnovalidate;
        }
      }
      formtargetChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.formTarget = this.formtarget;
        }
      }
      typeChanged(previous, next) {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.type = this.type;
        }
        next === "submit" && this.addEventListener("click", this.handleSubmission);
        previous === "submit" && this.removeEventListener("click", this.handleSubmission);
        next === "reset" && this.addEventListener("click", this.handleFormReset);
        previous === "reset" && this.removeEventListener("click", this.handleFormReset);
      }
      /** {@inheritDoc (FormAssociated:interface).validate} */
      validate() {
        super.validate(this.control);
      }
      /**
       * @internal
       */
      connectedCallback() {
        var _a;
        super.connectedCallback();
        this.proxy.setAttribute("type", this.type);
        this.handleUnsupportedDelegatesFocus();
        const elements2 = Array.from((_a = this.control) === null || _a === void 0 ? void 0 : _a.children);
        if (elements2) {
          elements2.forEach((span) => {
            span.addEventListener("click", this.handleClick);
          });
        }
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        var _a;
        super.disconnectedCallback();
        const elements2 = Array.from((_a = this.control) === null || _a === void 0 ? void 0 : _a.children);
        if (elements2) {
          elements2.forEach((span) => {
            span.removeEventListener("click", this.handleClick);
          });
        }
      }
    };
    __decorate([
      attr({ mode: "boolean" })
    ], Button2.prototype, "autofocus", void 0);
    __decorate([
      attr({ attribute: "form" })
    ], Button2.prototype, "formId", void 0);
    __decorate([
      attr
    ], Button2.prototype, "formaction", void 0);
    __decorate([
      attr
    ], Button2.prototype, "formenctype", void 0);
    __decorate([
      attr
    ], Button2.prototype, "formmethod", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], Button2.prototype, "formnovalidate", void 0);
    __decorate([
      attr
    ], Button2.prototype, "formtarget", void 0);
    __decorate([
      attr
    ], Button2.prototype, "type", void 0);
    __decorate([
      observable
    ], Button2.prototype, "defaultSlottedContent", void 0);
    DelegatesARIAButton = class {
    };
    __decorate([
      attr({ attribute: "aria-expanded" })
    ], DelegatesARIAButton.prototype, "ariaExpanded", void 0);
    __decorate([
      attr({ attribute: "aria-pressed" })
    ], DelegatesARIAButton.prototype, "ariaPressed", void 0);
    applyMixins(DelegatesARIAButton, ARIAGlobalStatesAndProperties);
    applyMixins(Button2, StartEnd, DelegatesARIAButton);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/button/index.js
var init_button3 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/button/index.js"() {
    init_button_template();
    init_button2();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/calendar/date-formatter.js
var DateFormatter;
var init_date_formatter = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/calendar/date-formatter.js"() {
    DateFormatter = class {
      constructor(config) {
        this.dayFormat = "numeric";
        this.weekdayFormat = "long";
        this.monthFormat = "long";
        this.yearFormat = "numeric";
        this.date = /* @__PURE__ */ new Date();
        if (config) {
          for (const key2 in config) {
            const value = config[key2];
            if (key2 === "date") {
              this.date = this.getDateObject(value);
            } else {
              this[key2] = value;
            }
          }
        }
      }
      /**
       * Helper function to make sure that the DateFormatter is working with an instance of Date
       * @param date - The date as an object, string or Date insance
       * @returns - A Date instance
       * @public
       */
      getDateObject(date) {
        if (typeof date === "string") {
          const dates = date.split(/[/-]/);
          if (dates.length < 3) {
            return /* @__PURE__ */ new Date();
          }
          return new Date(parseInt(dates[2], 10), parseInt(dates[0], 10) - 1, parseInt(dates[1], 10));
        } else if ("day" in date && "month" in date && "year" in date) {
          const { day, month, year } = date;
          return new Date(year, month - 1, day);
        }
        return date;
      }
      /**
       *
       * @param date - a valide date as either a Date, string, objec or a DateFormatter
       * @param format - The formatting for the string
       * @param locale - locale data used for formatting
       * @returns A localized string of the date provided
       * @public
       */
      getDate(date = this.date, format = {
        weekday: this.weekdayFormat,
        month: this.monthFormat,
        day: this.dayFormat,
        year: this.yearFormat
      }, locale = this.locale) {
        const dateObj = this.getDateObject(date);
        if (!dateObj.getTime()) {
          return "";
        }
        const optionsWithTimeZone = Object.assign({ timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone }, format);
        return new Intl.DateTimeFormat(locale, optionsWithTimeZone).format(dateObj);
      }
      /**
       *
       * @param day - Day to localize
       * @param format - The formatting for the day
       * @param locale - The locale data used for formatting
       * @returns - A localized number for the day
       * @public
       */
      getDay(day = this.date.getDate(), format = this.dayFormat, locale = this.locale) {
        return this.getDate({ month: 1, day, year: 2020 }, { day: format }, locale);
      }
      /**
       *
       * @param month - The month to localize
       * @param format - The formatting for the month
       * @param locale - The locale data used for formatting
       * @returns - A localized name of the month
       * @public
       */
      getMonth(month = this.date.getMonth() + 1, format = this.monthFormat, locale = this.locale) {
        return this.getDate({ month, day: 2, year: 2020 }, { month: format }, locale);
      }
      /**
       *
       * @param year - The year to localize
       * @param format - The formatting for the year
       * @param locale - The locale data used for formatting
       * @returns - A localized string for the year
       * @public
       */
      getYear(year = this.date.getFullYear(), format = this.yearFormat, locale = this.locale) {
        return this.getDate({ month: 2, day: 2, year }, { year: format }, locale);
      }
      /**
       *
       * @param weekday - The number of the weekday, defaults to Sunday
       * @param format - The formatting for the weekday label
       * @param locale - The locale data used for formatting
       * @returns - A formatted weekday label
       * @public
       */
      getWeekday(weekday = 0, format = this.weekdayFormat, locale = this.locale) {
        const date = `1-${weekday + 1}-2017`;
        return this.getDate(date, { weekday: format }, locale);
      }
      /**
       *
       * @param format - The formatting for the weekdays
       * @param locale - The locale data used for formatting
       * @returns - An array of the weekday labels
       * @public
       */
      getWeekdays(format = this.weekdayFormat, locale = this.locale) {
        return Array(7).fill(null).map((_, day) => this.getWeekday(day, format, locale));
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/calendar/calendar.js
var Calendar;
var init_calendar = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/calendar/calendar.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_foundation_element();
    init_date_formatter();
    Calendar = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.dateFormatter = new DateFormatter();
        this.readonly = false;
        this.locale = "en-US";
        this.month = (/* @__PURE__ */ new Date()).getMonth() + 1;
        this.year = (/* @__PURE__ */ new Date()).getFullYear();
        this.dayFormat = "numeric";
        this.weekdayFormat = "short";
        this.monthFormat = "long";
        this.yearFormat = "numeric";
        this.minWeeks = 0;
        this.disabledDates = "";
        this.selectedDates = "";
        this.oneDayInMs = 864e5;
      }
      localeChanged() {
        this.dateFormatter.locale = this.locale;
      }
      dayFormatChanged() {
        this.dateFormatter.dayFormat = this.dayFormat;
      }
      weekdayFormatChanged() {
        this.dateFormatter.weekdayFormat = this.weekdayFormat;
      }
      monthFormatChanged() {
        this.dateFormatter.monthFormat = this.monthFormat;
      }
      yearFormatChanged() {
        this.dateFormatter.yearFormat = this.yearFormat;
      }
      /**
       * Gets data needed to render about a calendar month as well as the previous and next months
       * @param year - year of the calendar
       * @param month - month of the calendar
       * @returns - an object with data about the current and 2 surrounding months
       * @public
       */
      getMonthInfo(month = this.month, year = this.year) {
        const getFirstDay = (date) => new Date(date.getFullYear(), date.getMonth(), 1).getDay();
        const getLength = (date) => {
          const nextMonth2 = new Date(date.getFullYear(), date.getMonth() + 1, 1);
          return new Date(nextMonth2.getTime() - this.oneDayInMs).getDate();
        };
        const thisMonth = new Date(year, month - 1);
        const nextMonth = new Date(year, month);
        const previousMonth = new Date(year, month - 2);
        return {
          length: getLength(thisMonth),
          month,
          start: getFirstDay(thisMonth),
          year,
          previous: {
            length: getLength(previousMonth),
            month: previousMonth.getMonth() + 1,
            start: getFirstDay(previousMonth),
            year: previousMonth.getFullYear()
          },
          next: {
            length: getLength(nextMonth),
            month: nextMonth.getMonth() + 1,
            start: getFirstDay(nextMonth),
            year: nextMonth.getFullYear()
          }
        };
      }
      /**
       * A list of calendar days
       * @param info - an object containing the information needed to render a calendar month
       * @param minWeeks - minimum number of weeks to show
       * @returns a list of days in a calendar month
       * @public
       */
      getDays(info = this.getMonthInfo(), minWeeks = this.minWeeks) {
        minWeeks = minWeeks > 10 ? 10 : minWeeks;
        const { start, length, previous, next } = info;
        const days = [];
        let dayCount = 1 - start;
        while (dayCount < length + 1 || days.length < minWeeks || days[days.length - 1].length % 7 !== 0) {
          const { month, year } = dayCount < 1 ? previous : dayCount > length ? next : info;
          const day = dayCount < 1 ? previous.length + dayCount : dayCount > length ? dayCount - length : dayCount;
          const dateString = `${month}-${day}-${year}`;
          const disabled = this.dateInString(dateString, this.disabledDates);
          const selected = this.dateInString(dateString, this.selectedDates);
          const date = {
            day,
            month,
            year,
            disabled,
            selected
          };
          const target2 = days[days.length - 1];
          if (days.length === 0 || target2.length % 7 === 0) {
            days.push([date]);
          } else {
            target2.push(date);
          }
          dayCount++;
        }
        return days;
      }
      /**
       * A helper function that checks if a date exists in a list of dates
       * @param date - A date objec that includes the day, month and year
       * @param datesString - a comma separated list of dates
       * @returns - Returns true if it found the date in the list of dates
       * @public
       */
      dateInString(date, datesString) {
        const dates = datesString.split(",").map((str) => str.trim());
        date = typeof date === "string" ? date : `${date.getMonth() + 1}-${date.getDate()}-${date.getFullYear()}`;
        return dates.some((d) => d === date);
      }
      /**
       * Creates a class string for the day container
       * @param date - date of the calendar cell
       * @returns - string of class names
       * @public
       */
      getDayClassNames(date, todayString) {
        const { day, month, year, disabled, selected } = date;
        const today = todayString === `${month}-${day}-${year}`;
        const inactive = this.month !== month;
        return [
          "day",
          today && "today",
          inactive && "inactive",
          disabled && "disabled",
          selected && "selected"
        ].filter(Boolean).join(" ");
      }
      /**
       * Returns a list of weekday labels
       * @returns An array of weekday text and full text if abbreviated
       * @public
       */
      getWeekdayText() {
        const weekdayText = this.dateFormatter.getWeekdays().map((text) => ({ text }));
        if (this.weekdayFormat !== "long") {
          const longText = this.dateFormatter.getWeekdays("long");
          weekdayText.forEach((weekday, index) => {
            weekday.abbr = longText[index];
          });
        }
        return weekdayText;
      }
      /**
       * Emits the "date-select" event with the day, month and year.
       * @param date - Date cell
       * @public
       */
      handleDateSelect(event, day) {
        event.preventDefault;
        this.$emit("dateselected", day);
      }
      /**
       * Handles keyboard events on a cell
       * @param event - Keyboard event
       * @param date - Date of the cell selected
       */
      handleKeydown(event, date) {
        if (event.key === keyEnter) {
          this.handleDateSelect(event, date);
        }
        return true;
      }
    };
    __decorate([
      attr({ mode: "boolean" })
    ], Calendar.prototype, "readonly", void 0);
    __decorate([
      attr
    ], Calendar.prototype, "locale", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], Calendar.prototype, "month", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], Calendar.prototype, "year", void 0);
    __decorate([
      attr({ attribute: "day-format", mode: "fromView" })
    ], Calendar.prototype, "dayFormat", void 0);
    __decorate([
      attr({ attribute: "weekday-format", mode: "fromView" })
    ], Calendar.prototype, "weekdayFormat", void 0);
    __decorate([
      attr({ attribute: "month-format", mode: "fromView" })
    ], Calendar.prototype, "monthFormat", void 0);
    __decorate([
      attr({ attribute: "year-format", mode: "fromView" })
    ], Calendar.prototype, "yearFormat", void 0);
    __decorate([
      attr({ attribute: "min-weeks", converter: nullableNumberConverter })
    ], Calendar.prototype, "minWeeks", void 0);
    __decorate([
      attr({ attribute: "disabled-dates" })
    ], Calendar.prototype, "disabledDates", void 0);
    __decorate([
      attr({ attribute: "selected-dates" })
    ], Calendar.prototype, "selectedDates", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid.options.js
var GenerateHeaderOptions, DataGridCellTypes, DataGridRowTypes;
var init_data_grid_options = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid.options.js"() {
    GenerateHeaderOptions = {
      none: "none",
      default: "default",
      sticky: "sticky"
    };
    DataGridCellTypes = {
      default: "default",
      columnHeader: "columnheader",
      rowHeader: "rowheader"
    };
    DataGridRowTypes = {
      default: "default",
      header: "header",
      stickyHeader: "sticky-header"
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-row.js
var DataGridRow;
var init_data_grid_row = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-row.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_foundation_element();
    init_data_grid_options();
    DataGridRow = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.rowType = DataGridRowTypes.default;
        this.rowData = null;
        this.columnDefinitions = null;
        this.isActiveRow = false;
        this.cellsRepeatBehavior = null;
        this.cellsPlaceholder = null;
        this.focusColumnIndex = 0;
        this.refocusOnLoad = false;
        this.updateRowStyle = () => {
          this.style.gridTemplateColumns = this.gridTemplateColumns;
        };
      }
      gridTemplateColumnsChanged() {
        if (this.$fastController.isConnected) {
          this.updateRowStyle();
        }
      }
      rowTypeChanged() {
        if (this.$fastController.isConnected) {
          this.updateItemTemplate();
        }
      }
      rowDataChanged() {
        if (this.rowData !== null && this.isActiveRow) {
          this.refocusOnLoad = true;
          return;
        }
      }
      cellItemTemplateChanged() {
        this.updateItemTemplate();
      }
      headerCellItemTemplateChanged() {
        this.updateItemTemplate();
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (this.cellsRepeatBehavior === null) {
          this.cellsPlaceholder = document.createComment("");
          this.appendChild(this.cellsPlaceholder);
          this.updateItemTemplate();
          this.cellsRepeatBehavior = new RepeatDirective((x) => x.columnDefinitions, (x) => x.activeCellItemTemplate, { positioning: true }).createBehavior(this.cellsPlaceholder);
          this.$fastController.addBehaviors([this.cellsRepeatBehavior]);
        }
        this.addEventListener("cell-focused", this.handleCellFocus);
        this.addEventListener(eventFocusOut, this.handleFocusout);
        this.addEventListener(eventKeyDown, this.handleKeydown);
        this.updateRowStyle();
        if (this.refocusOnLoad) {
          this.refocusOnLoad = false;
          if (this.cellElements.length > this.focusColumnIndex) {
            this.cellElements[this.focusColumnIndex].focus();
          }
        }
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener("cell-focused", this.handleCellFocus);
        this.removeEventListener(eventFocusOut, this.handleFocusout);
        this.removeEventListener(eventKeyDown, this.handleKeydown);
      }
      handleFocusout(e) {
        if (!this.contains(e.target)) {
          this.isActiveRow = false;
          this.focusColumnIndex = 0;
        }
      }
      handleCellFocus(e) {
        this.isActiveRow = true;
        this.focusColumnIndex = this.cellElements.indexOf(e.target);
        this.$emit("row-focused", this);
      }
      handleKeydown(e) {
        if (e.defaultPrevented) {
          return;
        }
        let newFocusColumnIndex = 0;
        switch (e.key) {
          case keyArrowLeft:
            newFocusColumnIndex = Math.max(0, this.focusColumnIndex - 1);
            this.cellElements[newFocusColumnIndex].focus();
            e.preventDefault();
            break;
          case keyArrowRight:
            newFocusColumnIndex = Math.min(this.cellElements.length - 1, this.focusColumnIndex + 1);
            this.cellElements[newFocusColumnIndex].focus();
            e.preventDefault();
            break;
          case keyHome:
            if (!e.ctrlKey) {
              this.cellElements[0].focus();
              e.preventDefault();
            }
            break;
          case keyEnd:
            if (!e.ctrlKey) {
              this.cellElements[this.cellElements.length - 1].focus();
              e.preventDefault();
            }
            break;
        }
      }
      updateItemTemplate() {
        this.activeCellItemTemplate = this.rowType === DataGridRowTypes.default && this.cellItemTemplate !== void 0 ? this.cellItemTemplate : this.rowType === DataGridRowTypes.default && this.cellItemTemplate === void 0 ? this.defaultCellItemTemplate : this.headerCellItemTemplate !== void 0 ? this.headerCellItemTemplate : this.defaultHeaderCellItemTemplate;
      }
    };
    __decorate([
      attr({ attribute: "grid-template-columns" })
    ], DataGridRow.prototype, "gridTemplateColumns", void 0);
    __decorate([
      attr({ attribute: "row-type" })
    ], DataGridRow.prototype, "rowType", void 0);
    __decorate([
      observable
    ], DataGridRow.prototype, "rowData", void 0);
    __decorate([
      observable
    ], DataGridRow.prototype, "columnDefinitions", void 0);
    __decorate([
      observable
    ], DataGridRow.prototype, "cellItemTemplate", void 0);
    __decorate([
      observable
    ], DataGridRow.prototype, "headerCellItemTemplate", void 0);
    __decorate([
      observable
    ], DataGridRow.prototype, "rowIndex", void 0);
    __decorate([
      observable
    ], DataGridRow.prototype, "isActiveRow", void 0);
    __decorate([
      observable
    ], DataGridRow.prototype, "activeCellItemTemplate", void 0);
    __decorate([
      observable
    ], DataGridRow.prototype, "defaultCellItemTemplate", void 0);
    __decorate([
      observable
    ], DataGridRow.prototype, "defaultHeaderCellItemTemplate", void 0);
    __decorate([
      observable
    ], DataGridRow.prototype, "cellElements", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid.template.js
function createRowItemTemplate(context) {
  const rowTag = context.tagFor(DataGridRow);
  return html`
    <${rowTag}
        :rowData="${(x) => x}"
        :cellItemTemplate="${(x, c) => c.parent.cellItemTemplate}"
        :headerCellItemTemplate="${(x, c) => c.parent.headerCellItemTemplate}"
    ></${rowTag}>
`;
}
var dataGridTemplate;
var init_data_grid_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid.template.js"() {
    init_esm();
    init_data_grid_row();
    dataGridTemplate = (context, definition) => {
      const rowItemTemplate = createRowItemTemplate(context);
      const rowTag = context.tagFor(DataGridRow);
      return html`
        <template
            role="grid"
            tabindex="0"
            :rowElementTag="${() => rowTag}"
            :defaultRowItemTemplate="${rowItemTemplate}"
            ${children({
        property: "rowElements",
        filter: elements("[role=row]")
      })}
        >
            <slot></slot>
        </template>
    `;
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid.js
var DataGrid;
var init_data_grid = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_foundation_element();
    init_data_grid_options();
    DataGrid = class extends FoundationElement {
      constructor() {
        super();
        this.noTabbing = false;
        this.generateHeader = GenerateHeaderOptions.default;
        this.rowsData = [];
        this.columnDefinitions = null;
        this.focusRowIndex = 0;
        this.focusColumnIndex = 0;
        this.rowsPlaceholder = null;
        this.generatedHeader = null;
        this.isUpdatingFocus = false;
        this.pendingFocusUpdate = false;
        this.rowindexUpdateQueued = false;
        this.columnDefinitionsStale = true;
        this.generatedGridTemplateColumns = "";
        this.focusOnCell = (rowIndex, columnIndex, scrollIntoView) => {
          if (this.rowElements.length === 0) {
            this.focusRowIndex = 0;
            this.focusColumnIndex = 0;
            return;
          }
          const focusRowIndex = Math.max(0, Math.min(this.rowElements.length - 1, rowIndex));
          const focusRow = this.rowElements[focusRowIndex];
          const cells = focusRow.querySelectorAll('[role="cell"], [role="gridcell"], [role="columnheader"], [role="rowheader"]');
          const focusColumnIndex = Math.max(0, Math.min(cells.length - 1, columnIndex));
          const focusTarget = cells[focusColumnIndex];
          if (scrollIntoView && this.scrollHeight !== this.clientHeight && (focusRowIndex < this.focusRowIndex && this.scrollTop > 0 || focusRowIndex > this.focusRowIndex && this.scrollTop < this.scrollHeight - this.clientHeight)) {
            focusTarget.scrollIntoView({ block: "center", inline: "center" });
          }
          focusTarget.focus();
        };
        this.onChildListChange = (mutations, observer) => {
          if (mutations && mutations.length) {
            mutations.forEach((mutation) => {
              mutation.addedNodes.forEach((newNode) => {
                if (newNode.nodeType === 1 && newNode.getAttribute("role") === "row") {
                  newNode.columnDefinitions = this.columnDefinitions;
                }
              });
            });
            this.queueRowIndexUpdate();
          }
        };
        this.queueRowIndexUpdate = () => {
          if (!this.rowindexUpdateQueued) {
            this.rowindexUpdateQueued = true;
            DOM.queueUpdate(this.updateRowIndexes);
          }
        };
        this.updateRowIndexes = () => {
          let newGridTemplateColumns = this.gridTemplateColumns;
          if (newGridTemplateColumns === void 0) {
            if (this.generatedGridTemplateColumns === "" && this.rowElements.length > 0) {
              const firstRow = this.rowElements[0];
              this.generatedGridTemplateColumns = new Array(firstRow.cellElements.length).fill("1fr").join(" ");
            }
            newGridTemplateColumns = this.generatedGridTemplateColumns;
          }
          this.rowElements.forEach((element, index) => {
            const thisRow = element;
            thisRow.rowIndex = index;
            thisRow.gridTemplateColumns = newGridTemplateColumns;
            if (this.columnDefinitionsStale) {
              thisRow.columnDefinitions = this.columnDefinitions;
            }
          });
          this.rowindexUpdateQueued = false;
          this.columnDefinitionsStale = false;
        };
      }
      /**
       *  generates a gridTemplateColumns based on columndata array
       */
      static generateTemplateColumns(columnDefinitions) {
        let templateColumns = "";
        columnDefinitions.forEach((column) => {
          templateColumns = `${templateColumns}${templateColumns === "" ? "" : " "}${"1fr"}`;
        });
        return templateColumns;
      }
      noTabbingChanged() {
        if (this.$fastController.isConnected) {
          if (this.noTabbing) {
            this.setAttribute("tabIndex", "-1");
          } else {
            this.setAttribute("tabIndex", this.contains(document.activeElement) || this === document.activeElement ? "-1" : "0");
          }
        }
      }
      generateHeaderChanged() {
        if (this.$fastController.isConnected) {
          this.toggleGeneratedHeader();
        }
      }
      gridTemplateColumnsChanged() {
        if (this.$fastController.isConnected) {
          this.updateRowIndexes();
        }
      }
      rowsDataChanged() {
        if (this.columnDefinitions === null && this.rowsData.length > 0) {
          this.columnDefinitions = DataGrid.generateColumns(this.rowsData[0]);
        }
        if (this.$fastController.isConnected) {
          this.toggleGeneratedHeader();
        }
      }
      columnDefinitionsChanged() {
        if (this.columnDefinitions === null) {
          this.generatedGridTemplateColumns = "";
          return;
        }
        this.generatedGridTemplateColumns = DataGrid.generateTemplateColumns(this.columnDefinitions);
        if (this.$fastController.isConnected) {
          this.columnDefinitionsStale = true;
          this.queueRowIndexUpdate();
        }
      }
      headerCellItemTemplateChanged() {
        if (this.$fastController.isConnected) {
          if (this.generatedHeader !== null) {
            this.generatedHeader.headerCellItemTemplate = this.headerCellItemTemplate;
          }
        }
      }
      focusRowIndexChanged() {
        if (this.$fastController.isConnected) {
          this.queueFocusUpdate();
        }
      }
      focusColumnIndexChanged() {
        if (this.$fastController.isConnected) {
          this.queueFocusUpdate();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (this.rowItemTemplate === void 0) {
          this.rowItemTemplate = this.defaultRowItemTemplate;
        }
        this.rowsPlaceholder = document.createComment("");
        this.appendChild(this.rowsPlaceholder);
        this.toggleGeneratedHeader();
        this.rowsRepeatBehavior = new RepeatDirective((x) => x.rowsData, (x) => x.rowItemTemplate, { positioning: true }).createBehavior(this.rowsPlaceholder);
        this.$fastController.addBehaviors([this.rowsRepeatBehavior]);
        this.addEventListener("row-focused", this.handleRowFocus);
        this.addEventListener(eventFocus, this.handleFocus);
        this.addEventListener(eventKeyDown, this.handleKeydown);
        this.addEventListener(eventFocusOut, this.handleFocusOut);
        this.observer = new MutationObserver(this.onChildListChange);
        this.observer.observe(this, { childList: true });
        if (this.noTabbing) {
          this.setAttribute("tabindex", "-1");
        }
        DOM.queueUpdate(this.queueRowIndexUpdate);
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener("row-focused", this.handleRowFocus);
        this.removeEventListener(eventFocus, this.handleFocus);
        this.removeEventListener(eventKeyDown, this.handleKeydown);
        this.removeEventListener(eventFocusOut, this.handleFocusOut);
        this.observer.disconnect();
        this.rowsPlaceholder = null;
        this.generatedHeader = null;
      }
      /**
       * @internal
       */
      handleRowFocus(e) {
        this.isUpdatingFocus = true;
        const focusRow = e.target;
        this.focusRowIndex = this.rowElements.indexOf(focusRow);
        this.focusColumnIndex = focusRow.focusColumnIndex;
        this.setAttribute("tabIndex", "-1");
        this.isUpdatingFocus = false;
      }
      /**
       * @internal
       */
      handleFocus(e) {
        this.focusOnCell(this.focusRowIndex, this.focusColumnIndex, true);
      }
      /**
       * @internal
       */
      handleFocusOut(e) {
        if (e.relatedTarget === null || !this.contains(e.relatedTarget)) {
          this.setAttribute("tabIndex", this.noTabbing ? "-1" : "0");
        }
      }
      /**
       * @internal
       */
      handleKeydown(e) {
        if (e.defaultPrevented) {
          return;
        }
        let newFocusRowIndex;
        const maxIndex = this.rowElements.length - 1;
        const currentGridBottom = this.offsetHeight + this.scrollTop;
        const lastRow = this.rowElements[maxIndex];
        switch (e.key) {
          case keyArrowUp:
            e.preventDefault();
            this.focusOnCell(this.focusRowIndex - 1, this.focusColumnIndex, true);
            break;
          case keyArrowDown:
            e.preventDefault();
            this.focusOnCell(this.focusRowIndex + 1, this.focusColumnIndex, true);
            break;
          case keyPageUp:
            e.preventDefault();
            if (this.rowElements.length === 0) {
              this.focusOnCell(0, 0, false);
              break;
            }
            if (this.focusRowIndex === 0) {
              this.focusOnCell(0, this.focusColumnIndex, false);
              return;
            }
            newFocusRowIndex = this.focusRowIndex - 1;
            for (newFocusRowIndex; newFocusRowIndex >= 0; newFocusRowIndex--) {
              const thisRow = this.rowElements[newFocusRowIndex];
              if (thisRow.offsetTop < this.scrollTop) {
                this.scrollTop = thisRow.offsetTop + thisRow.clientHeight - this.clientHeight;
                break;
              }
            }
            this.focusOnCell(newFocusRowIndex, this.focusColumnIndex, false);
            break;
          case keyPageDown:
            e.preventDefault();
            if (this.rowElements.length === 0) {
              this.focusOnCell(0, 0, false);
              break;
            }
            if (this.focusRowIndex >= maxIndex || lastRow.offsetTop + lastRow.offsetHeight <= currentGridBottom) {
              this.focusOnCell(maxIndex, this.focusColumnIndex, false);
              return;
            }
            newFocusRowIndex = this.focusRowIndex + 1;
            for (newFocusRowIndex; newFocusRowIndex <= maxIndex; newFocusRowIndex++) {
              const thisRow = this.rowElements[newFocusRowIndex];
              if (thisRow.offsetTop + thisRow.offsetHeight > currentGridBottom) {
                let stickyHeaderOffset = 0;
                if (this.generateHeader === GenerateHeaderOptions.sticky && this.generatedHeader !== null) {
                  stickyHeaderOffset = this.generatedHeader.clientHeight;
                }
                this.scrollTop = thisRow.offsetTop - stickyHeaderOffset;
                break;
              }
            }
            this.focusOnCell(newFocusRowIndex, this.focusColumnIndex, false);
            break;
          case keyHome:
            if (e.ctrlKey) {
              e.preventDefault();
              this.focusOnCell(0, 0, true);
            }
            break;
          case keyEnd:
            if (e.ctrlKey && this.columnDefinitions !== null) {
              e.preventDefault();
              this.focusOnCell(this.rowElements.length - 1, this.columnDefinitions.length - 1, true);
            }
            break;
        }
      }
      queueFocusUpdate() {
        if (this.isUpdatingFocus && (this.contains(document.activeElement) || this === document.activeElement)) {
          return;
        }
        if (this.pendingFocusUpdate === false) {
          this.pendingFocusUpdate = true;
          DOM.queueUpdate(() => this.updateFocus());
        }
      }
      updateFocus() {
        this.pendingFocusUpdate = false;
        this.focusOnCell(this.focusRowIndex, this.focusColumnIndex, true);
      }
      toggleGeneratedHeader() {
        if (this.generatedHeader !== null) {
          this.removeChild(this.generatedHeader);
          this.generatedHeader = null;
        }
        if (this.generateHeader !== GenerateHeaderOptions.none && this.rowsData.length > 0) {
          const generatedHeaderElement = document.createElement(this.rowElementTag);
          this.generatedHeader = generatedHeaderElement;
          this.generatedHeader.columnDefinitions = this.columnDefinitions;
          this.generatedHeader.gridTemplateColumns = this.gridTemplateColumns;
          this.generatedHeader.rowType = this.generateHeader === GenerateHeaderOptions.sticky ? DataGridRowTypes.stickyHeader : DataGridRowTypes.header;
          if (this.firstChild !== null || this.rowsPlaceholder !== null) {
            this.insertBefore(generatedHeaderElement, this.firstChild !== null ? this.firstChild : this.rowsPlaceholder);
          }
          return;
        }
      }
    };
    DataGrid.generateColumns = (row) => {
      return Object.getOwnPropertyNames(row).map((property, index) => {
        return {
          columnDataKey: property,
          gridColumn: `${index}`
        };
      });
    };
    __decorate([
      attr({ attribute: "no-tabbing", mode: "boolean" })
    ], DataGrid.prototype, "noTabbing", void 0);
    __decorate([
      attr({ attribute: "generate-header" })
    ], DataGrid.prototype, "generateHeader", void 0);
    __decorate([
      attr({ attribute: "grid-template-columns" })
    ], DataGrid.prototype, "gridTemplateColumns", void 0);
    __decorate([
      observable
    ], DataGrid.prototype, "rowsData", void 0);
    __decorate([
      observable
    ], DataGrid.prototype, "columnDefinitions", void 0);
    __decorate([
      observable
    ], DataGrid.prototype, "rowItemTemplate", void 0);
    __decorate([
      observable
    ], DataGrid.prototype, "cellItemTemplate", void 0);
    __decorate([
      observable
    ], DataGrid.prototype, "headerCellItemTemplate", void 0);
    __decorate([
      observable
    ], DataGrid.prototype, "focusRowIndex", void 0);
    __decorate([
      observable
    ], DataGrid.prototype, "focusColumnIndex", void 0);
    __decorate([
      observable
    ], DataGrid.prototype, "defaultRowItemTemplate", void 0);
    __decorate([
      observable
    ], DataGrid.prototype, "rowElementTag", void 0);
    __decorate([
      observable
    ], DataGrid.prototype, "rowElements", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-cell.js
var defaultCellContentsTemplate, defaultHeaderCellContentsTemplate, DataGridCell;
var init_data_grid_cell = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-cell.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_foundation_element();
    init_data_grid_options();
    defaultCellContentsTemplate = html`
    <template>
        ${(x) => x.rowData === null || x.columnDefinition === null || x.columnDefinition.columnDataKey === null ? null : x.rowData[x.columnDefinition.columnDataKey]}
    </template>
`;
    defaultHeaderCellContentsTemplate = html`
    <template>
        ${(x) => x.columnDefinition === null ? null : x.columnDefinition.title === void 0 ? x.columnDefinition.columnDataKey : x.columnDefinition.title}
    </template>
`;
    DataGridCell = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.cellType = DataGridCellTypes.default;
        this.rowData = null;
        this.columnDefinition = null;
        this.isActiveCell = false;
        this.customCellView = null;
        this.updateCellStyle = () => {
          this.style.gridColumn = this.gridColumn;
        };
      }
      cellTypeChanged() {
        if (this.$fastController.isConnected) {
          this.updateCellView();
        }
      }
      gridColumnChanged() {
        if (this.$fastController.isConnected) {
          this.updateCellStyle();
        }
      }
      columnDefinitionChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
          this.updateCellView();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        var _a;
        super.connectedCallback();
        this.addEventListener(eventFocusIn, this.handleFocusin);
        this.addEventListener(eventFocusOut, this.handleFocusout);
        this.addEventListener(eventKeyDown, this.handleKeydown);
        this.style.gridColumn = `${((_a = this.columnDefinition) === null || _a === void 0 ? void 0 : _a.gridColumn) === void 0 ? 0 : this.columnDefinition.gridColumn}`;
        this.updateCellView();
        this.updateCellStyle();
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener(eventFocusIn, this.handleFocusin);
        this.removeEventListener(eventFocusOut, this.handleFocusout);
        this.removeEventListener(eventKeyDown, this.handleKeydown);
        this.disconnectCellView();
      }
      handleFocusin(e) {
        if (this.isActiveCell) {
          return;
        }
        this.isActiveCell = true;
        switch (this.cellType) {
          case DataGridCellTypes.columnHeader:
            if (this.columnDefinition !== null && this.columnDefinition.headerCellInternalFocusQueue !== true && typeof this.columnDefinition.headerCellFocusTargetCallback === "function") {
              const focusTarget = this.columnDefinition.headerCellFocusTargetCallback(this);
              if (focusTarget !== null) {
                focusTarget.focus();
              }
            }
            break;
          default:
            if (this.columnDefinition !== null && this.columnDefinition.cellInternalFocusQueue !== true && typeof this.columnDefinition.cellFocusTargetCallback === "function") {
              const focusTarget = this.columnDefinition.cellFocusTargetCallback(this);
              if (focusTarget !== null) {
                focusTarget.focus();
              }
            }
            break;
        }
        this.$emit("cell-focused", this);
      }
      handleFocusout(e) {
        if (this !== document.activeElement && !this.contains(document.activeElement)) {
          this.isActiveCell = false;
        }
      }
      handleKeydown(e) {
        if (e.defaultPrevented || this.columnDefinition === null || this.cellType === DataGridCellTypes.default && this.columnDefinition.cellInternalFocusQueue !== true || this.cellType === DataGridCellTypes.columnHeader && this.columnDefinition.headerCellInternalFocusQueue !== true) {
          return;
        }
        switch (e.key) {
          case keyEnter:
          case keyFunction2:
            if (this.contains(document.activeElement) && document.activeElement !== this) {
              return;
            }
            switch (this.cellType) {
              case DataGridCellTypes.columnHeader:
                if (this.columnDefinition.headerCellFocusTargetCallback !== void 0) {
                  const focusTarget = this.columnDefinition.headerCellFocusTargetCallback(this);
                  if (focusTarget !== null) {
                    focusTarget.focus();
                  }
                  e.preventDefault();
                }
                break;
              default:
                if (this.columnDefinition.cellFocusTargetCallback !== void 0) {
                  const focusTarget = this.columnDefinition.cellFocusTargetCallback(this);
                  if (focusTarget !== null) {
                    focusTarget.focus();
                  }
                  e.preventDefault();
                }
                break;
            }
            break;
          case keyEscape:
            if (this.contains(document.activeElement) && document.activeElement !== this) {
              this.focus();
              e.preventDefault();
            }
            break;
        }
      }
      updateCellView() {
        this.disconnectCellView();
        if (this.columnDefinition === null) {
          return;
        }
        switch (this.cellType) {
          case DataGridCellTypes.columnHeader:
            if (this.columnDefinition.headerCellTemplate !== void 0) {
              this.customCellView = this.columnDefinition.headerCellTemplate.render(this, this);
            } else {
              this.customCellView = defaultHeaderCellContentsTemplate.render(this, this);
            }
            break;
          case void 0:
          case DataGridCellTypes.rowHeader:
          case DataGridCellTypes.default:
            if (this.columnDefinition.cellTemplate !== void 0) {
              this.customCellView = this.columnDefinition.cellTemplate.render(this, this);
            } else {
              this.customCellView = defaultCellContentsTemplate.render(this, this);
            }
            break;
        }
      }
      disconnectCellView() {
        if (this.customCellView !== null) {
          this.customCellView.dispose();
          this.customCellView = null;
        }
      }
    };
    __decorate([
      attr({ attribute: "cell-type" })
    ], DataGridCell.prototype, "cellType", void 0);
    __decorate([
      attr({ attribute: "grid-column" })
    ], DataGridCell.prototype, "gridColumn", void 0);
    __decorate([
      observable
    ], DataGridCell.prototype, "rowData", void 0);
    __decorate([
      observable
    ], DataGridCell.prototype, "columnDefinition", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-row.template.js
function createCellItemTemplate(context) {
  const cellTag = context.tagFor(DataGridCell);
  return html`
    <${cellTag}
        cell-type="${(x) => x.isRowHeader ? "rowheader" : void 0}"
        grid-column="${(x, c) => c.index + 1}"
        :rowData="${(x, c) => c.parent.rowData}"
        :columnDefinition="${(x) => x}"
    ></${cellTag}>
`;
}
function createHeaderCellItemTemplate(context) {
  const cellTag = context.tagFor(DataGridCell);
  return html`
    <${cellTag}
        cell-type="columnheader"
        grid-column="${(x, c) => c.index + 1}"
        :columnDefinition="${(x) => x}"
    ></${cellTag}>
`;
}
var dataGridRowTemplate;
var init_data_grid_row_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-row.template.js"() {
    init_esm();
    init_data_grid_cell();
    dataGridRowTemplate = (context, definition) => {
      const cellItemTemplate = createCellItemTemplate(context);
      const headerCellItemTemplate = createHeaderCellItemTemplate(context);
      return html`
        <template
            role="row"
            class="${(x) => x.rowType !== "default" ? x.rowType : ""}"
            :defaultCellItemTemplate="${cellItemTemplate}"
            :defaultHeaderCellItemTemplate="${headerCellItemTemplate}"
            ${children({
        property: "cellElements",
        filter: elements('[role="cell"],[role="gridcell"],[role="columnheader"],[role="rowheader"]')
      })}
        >
            <slot ${slotted("slottedCellElements")}></slot>
        </template>
    `;
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-cell.template.js
var dataGridCellTemplate;
var init_data_grid_cell_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-cell.template.js"() {
    init_esm();
    dataGridCellTemplate = (context, definition) => {
      return html`
        <template
            tabindex="-1"
            role="${(x) => !x.cellType || x.cellType === "default" ? "gridcell" : x.cellType}"
            class="
            ${(x) => x.cellType === "columnheader" ? "column-header" : x.cellType === "rowheader" ? "row-header" : ""}
            "
        >
            <slot></slot>
        </template>
    `;
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/index.js
var init_data_grid2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/data-grid/index.js"() {
    init_data_grid_template();
    init_data_grid();
    init_data_grid_row_template();
    init_data_grid_row();
    init_data_grid_cell_template();
    init_data_grid_cell();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/calendar/calendar.template.js
var CalendarTitleTemplate;
var init_calendar_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/calendar/calendar.template.js"() {
    init_esm();
    CalendarTitleTemplate = html`
    <div
        class="title"
        part="title"
        aria-label="${(x) => x.dateFormatter.getDate(`${x.month}-2-${x.year}`, {
      month: "long",
      year: "numeric"
    })}"
    >
        <span part="month">
            ${(x) => x.dateFormatter.getMonth(x.month)}
        </span>
        <span part="year">${(x) => x.dateFormatter.getYear(x.year)}</span>
    </div>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/calendar/index.js
var init_calendar2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/calendar/index.js"() {
    init_calendar();
    init_calendar_template();
    init_date_formatter();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/card/card.template.js
var cardTemplate;
var init_card_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/card/card.template.js"() {
    init_esm();
    cardTemplate = (context, definition) => html`
    <slot></slot>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/card/card.js
var Card;
var init_card = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/card/card.js"() {
    init_foundation_element();
    Card = class extends FoundationElement {
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/card/index.js
var init_card2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/card/index.js"() {
    init_card_template();
    init_card();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.template.js
var init_checkbox_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.template.js"() {
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.form-associated.js
var _Checkbox, FormAssociatedCheckbox;
var init_checkbox_form_associated = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _Checkbox = class extends FoundationElement {
    };
    FormAssociatedCheckbox = class extends CheckableFormAssociated(_Checkbox) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.js
var Checkbox;
var init_checkbox = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_checkbox_form_associated();
    Checkbox = class extends FormAssociatedCheckbox {
      constructor() {
        super();
        this.initialValue = "on";
        this.indeterminate = false;
        this.keypressHandler = (e) => {
          if (this.readOnly) {
            return;
          }
          switch (e.key) {
            case keySpace:
              if (this.indeterminate) {
                this.indeterminate = false;
              }
              this.checked = !this.checked;
              break;
          }
        };
        this.clickHandler = (e) => {
          if (!this.disabled && !this.readOnly) {
            if (this.indeterminate) {
              this.indeterminate = false;
            }
            this.checked = !this.checked;
          }
        };
        this.proxy.setAttribute("type", "checkbox");
      }
      readOnlyChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.readOnly = this.readOnly;
        }
      }
    };
    __decorate([
      attr({ attribute: "readonly", mode: "boolean" })
    ], Checkbox.prototype, "readOnly", void 0);
    __decorate([
      observable
    ], Checkbox.prototype, "defaultSlottedNodes", void 0);
    __decorate([
      observable
    ], Checkbox.prototype, "indeterminate", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/checkbox/index.js
var init_checkbox2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/checkbox/index.js"() {
    init_checkbox_template();
    init_checkbox();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/listbox-option/listbox-option.js
function isListboxOption(el) {
  return isHTMLElement(el) && (el.getAttribute("role") === "option" || el instanceof HTMLOptionElement);
}
var ListboxOption, DelegatesARIAListboxOption;
var init_listbox_option = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/listbox-option/listbox-option.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_foundation_element();
    init_aria_global();
    init_start_end();
    init_apply_mixins();
    ListboxOption = class extends FoundationElement {
      constructor(text, value, defaultSelected, selected) {
        super();
        this.defaultSelected = false;
        this.dirtySelected = false;
        this.selected = this.defaultSelected;
        this.dirtyValue = false;
        if (text) {
          this.textContent = text;
        }
        if (value) {
          this.initialValue = value;
        }
        if (defaultSelected) {
          this.defaultSelected = defaultSelected;
        }
        if (selected) {
          this.selected = selected;
        }
        this.proxy = new Option(`${this.textContent}`, this.initialValue, this.defaultSelected, this.selected);
        this.proxy.disabled = this.disabled;
      }
      /**
       * Updates the ariaChecked property when the checked property changes.
       *
       * @param prev - the previous checked value
       * @param next - the current checked value
       *
       * @public
       */
      checkedChanged(prev, next) {
        if (typeof next === "boolean") {
          this.ariaChecked = next ? "true" : "false";
          return;
        }
        this.ariaChecked = null;
      }
      /**
       * Updates the proxy's text content when the default slot changes.
       * @param prev - the previous content value
       * @param next - the current content value
       *
       * @internal
       */
      contentChanged(prev, next) {
        if (this.proxy instanceof HTMLOptionElement) {
          this.proxy.textContent = this.textContent;
        }
        this.$emit("contentchange", null, { bubbles: true });
      }
      defaultSelectedChanged() {
        if (!this.dirtySelected) {
          this.selected = this.defaultSelected;
          if (this.proxy instanceof HTMLOptionElement) {
            this.proxy.selected = this.defaultSelected;
          }
        }
      }
      disabledChanged(prev, next) {
        this.ariaDisabled = this.disabled ? "true" : "false";
        if (this.proxy instanceof HTMLOptionElement) {
          this.proxy.disabled = this.disabled;
        }
      }
      selectedAttributeChanged() {
        this.defaultSelected = this.selectedAttribute;
        if (this.proxy instanceof HTMLOptionElement) {
          this.proxy.defaultSelected = this.defaultSelected;
        }
      }
      selectedChanged() {
        this.ariaSelected = this.selected ? "true" : "false";
        if (!this.dirtySelected) {
          this.dirtySelected = true;
        }
        if (this.proxy instanceof HTMLOptionElement) {
          this.proxy.selected = this.selected;
        }
      }
      initialValueChanged(previous, next) {
        if (!this.dirtyValue) {
          this.value = this.initialValue;
          this.dirtyValue = false;
        }
      }
      get label() {
        var _a;
        return (_a = this.value) !== null && _a !== void 0 ? _a : this.text;
      }
      get text() {
        var _a, _b;
        return (_b = (_a = this.textContent) === null || _a === void 0 ? void 0 : _a.replace(/\s+/g, " ").trim()) !== null && _b !== void 0 ? _b : "";
      }
      set value(next) {
        const newValue = `${next !== null && next !== void 0 ? next : ""}`;
        this._value = newValue;
        this.dirtyValue = true;
        if (this.proxy instanceof HTMLOptionElement) {
          this.proxy.value = newValue;
        }
        Observable.notify(this, "value");
      }
      get value() {
        var _a;
        Observable.track(this, "value");
        return (_a = this._value) !== null && _a !== void 0 ? _a : this.text;
      }
      get form() {
        return this.proxy ? this.proxy.form : null;
      }
    };
    __decorate([
      observable
    ], ListboxOption.prototype, "checked", void 0);
    __decorate([
      observable
    ], ListboxOption.prototype, "content", void 0);
    __decorate([
      observable
    ], ListboxOption.prototype, "defaultSelected", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], ListboxOption.prototype, "disabled", void 0);
    __decorate([
      attr({ attribute: "selected", mode: "boolean" })
    ], ListboxOption.prototype, "selectedAttribute", void 0);
    __decorate([
      observable
    ], ListboxOption.prototype, "selected", void 0);
    __decorate([
      attr({ attribute: "value", mode: "fromView" })
    ], ListboxOption.prototype, "initialValue", void 0);
    DelegatesARIAListboxOption = class {
    };
    __decorate([
      observable
    ], DelegatesARIAListboxOption.prototype, "ariaChecked", void 0);
    __decorate([
      observable
    ], DelegatesARIAListboxOption.prototype, "ariaPosInSet", void 0);
    __decorate([
      observable
    ], DelegatesARIAListboxOption.prototype, "ariaSelected", void 0);
    __decorate([
      observable
    ], DelegatesARIAListboxOption.prototype, "ariaSetSize", void 0);
    applyMixins(DelegatesARIAListboxOption, ARIAGlobalStatesAndProperties);
    applyMixins(ListboxOption, StartEnd, DelegatesARIAListboxOption);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/listbox/listbox.js
var Listbox, DelegatesARIAListbox;
var init_listbox = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/listbox/listbox.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_foundation_element();
    init_listbox_option();
    init_aria_global();
    init_apply_mixins();
    Listbox = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this._options = [];
        this.selectedIndex = -1;
        this.selectedOptions = [];
        this.shouldSkipFocus = false;
        this.typeaheadBuffer = "";
        this.typeaheadExpired = true;
        this.typeaheadTimeout = -1;
      }
      /**
       * The first selected option.
       *
       * @internal
       */
      get firstSelectedOption() {
        var _a;
        return (_a = this.selectedOptions[0]) !== null && _a !== void 0 ? _a : null;
      }
      /**
       * Returns true if there is one or more selectable option.
       *
       * @internal
       */
      get hasSelectableOptions() {
        return this.options.length > 0 && !this.options.every((o) => o.disabled);
      }
      /**
       * The number of options.
       *
       * @public
       */
      get length() {
        var _a, _b;
        return (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      }
      /**
       * The list of options.
       *
       * @public
       */
      get options() {
        Observable.track(this, "options");
        return this._options;
      }
      set options(value) {
        this._options = value;
        Observable.notify(this, "options");
      }
      /**
       * Flag for the typeahead timeout expiration.
       *
       * @deprecated use `Listbox.typeaheadExpired`
       * @internal
       */
      get typeAheadExpired() {
        return this.typeaheadExpired;
      }
      set typeAheadExpired(value) {
        this.typeaheadExpired = value;
      }
      /**
       * Handle click events for listbox options.
       *
       * @internal
       */
      clickHandler(e) {
        const captured = e.target.closest(`option,[role=option]`);
        if (captured && !captured.disabled) {
          this.selectedIndex = this.options.indexOf(captured);
          return true;
        }
      }
      /**
       * Ensures that the provided option is focused and scrolled into view.
       *
       * @param optionToFocus - The option to focus
       * @internal
       */
      focusAndScrollOptionIntoView(optionToFocus = this.firstSelectedOption) {
        if (this.contains(document.activeElement) && optionToFocus !== null) {
          optionToFocus.focus();
          requestAnimationFrame(() => {
            optionToFocus.scrollIntoView({ block: "nearest" });
          });
        }
      }
      /**
       * Handles `focusin` actions for the component. When the component receives focus,
       * the list of selected options is refreshed and the first selected option is scrolled
       * into view.
       *
       * @internal
       */
      focusinHandler(e) {
        if (!this.shouldSkipFocus && e.target === e.currentTarget) {
          this.setSelectedOptions();
          this.focusAndScrollOptionIntoView();
        }
        this.shouldSkipFocus = false;
      }
      /**
       * Returns the options which match the current typeahead buffer.
       *
       * @internal
       */
      getTypeaheadMatches() {
        const pattern = this.typeaheadBuffer.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
        const re = new RegExp(`^${pattern}`, "gi");
        return this.options.filter((o) => o.text.trim().match(re));
      }
      /**
       * Determines the index of the next option which is selectable, if any.
       *
       * @param prev - the previous selected index
       * @param next - the next index to select
       *
       * @internal
       */
      getSelectableIndex(prev = this.selectedIndex, next) {
        const direction2 = prev > next ? -1 : prev < next ? 1 : 0;
        const potentialDirection = prev + direction2;
        let nextSelectableOption = null;
        switch (direction2) {
          case -1: {
            nextSelectableOption = this.options.reduceRight((nextSelectableOption2, thisOption, index) => !nextSelectableOption2 && !thisOption.disabled && index < potentialDirection ? thisOption : nextSelectableOption2, nextSelectableOption);
            break;
          }
          case 1: {
            nextSelectableOption = this.options.reduce((nextSelectableOption2, thisOption, index) => !nextSelectableOption2 && !thisOption.disabled && index > potentialDirection ? thisOption : nextSelectableOption2, nextSelectableOption);
            break;
          }
        }
        return this.options.indexOf(nextSelectableOption);
      }
      /**
       * Handles external changes to child options.
       *
       * @param source - the source object
       * @param propertyName - the property
       *
       * @internal
       */
      handleChange(source, propertyName) {
        switch (propertyName) {
          case "selected": {
            if (Listbox.slottedOptionFilter(source)) {
              this.selectedIndex = this.options.indexOf(source);
            }
            this.setSelectedOptions();
            break;
          }
        }
      }
      /**
       * Moves focus to an option whose label matches characters typed by the user.
       * Consecutive keystrokes are batched into a buffer of search text used
       * to match against the set of options.  If `TYPE_AHEAD_TIMEOUT_MS` passes
       * between consecutive keystrokes, the search restarts.
       *
       * @param key - the key to be evaluated
       *
       * @internal
       */
      handleTypeAhead(key2) {
        if (this.typeaheadTimeout) {
          window.clearTimeout(this.typeaheadTimeout);
        }
        this.typeaheadTimeout = window.setTimeout(() => this.typeaheadExpired = true, Listbox.TYPE_AHEAD_TIMEOUT_MS);
        if (key2.length > 1) {
          return;
        }
        this.typeaheadBuffer = `${this.typeaheadExpired ? "" : this.typeaheadBuffer}${key2}`;
      }
      /**
       * Handles `keydown` actions for listbox navigation and typeahead.
       *
       * @internal
       */
      keydownHandler(e) {
        if (this.disabled) {
          return true;
        }
        this.shouldSkipFocus = false;
        const key2 = e.key;
        switch (key2) {
          case keyHome: {
            if (!e.shiftKey) {
              e.preventDefault();
              this.selectFirstOption();
            }
            break;
          }
          case keyArrowDown: {
            if (!e.shiftKey) {
              e.preventDefault();
              this.selectNextOption();
            }
            break;
          }
          case keyArrowUp: {
            if (!e.shiftKey) {
              e.preventDefault();
              this.selectPreviousOption();
            }
            break;
          }
          case keyEnd: {
            e.preventDefault();
            this.selectLastOption();
            break;
          }
          case keyTab: {
            this.focusAndScrollOptionIntoView();
            return true;
          }
          case keyEnter:
          case keyEscape: {
            return true;
          }
          case keySpace: {
            if (this.typeaheadExpired) {
              return true;
            }
          }
          default: {
            if (key2.length === 1) {
              this.handleTypeAhead(`${key2}`);
            }
            return true;
          }
        }
      }
      /**
       * Prevents `focusin` events from firing before `click` events when the
       * element is unfocused.
       *
       * @internal
       */
      mousedownHandler(e) {
        this.shouldSkipFocus = !this.contains(document.activeElement);
        return true;
      }
      /**
       * Switches between single-selection and multi-selection mode.
       *
       * @param prev - the previous value of the `multiple` attribute
       * @param next - the next value of the `multiple` attribute
       *
       * @internal
       */
      multipleChanged(prev, next) {
        this.ariaMultiSelectable = next ? "true" : null;
      }
      /**
       * Updates the list of selected options when the `selectedIndex` changes.
       *
       * @param prev - the previous selected index value
       * @param next - the current selected index value
       *
       * @internal
       */
      selectedIndexChanged(prev, next) {
        var _a;
        if (!this.hasSelectableOptions) {
          this.selectedIndex = -1;
          return;
        }
        if (((_a = this.options[this.selectedIndex]) === null || _a === void 0 ? void 0 : _a.disabled) && typeof prev === "number") {
          const selectableIndex = this.getSelectableIndex(prev, next);
          const newNext = selectableIndex > -1 ? selectableIndex : prev;
          this.selectedIndex = newNext;
          if (next === newNext) {
            this.selectedIndexChanged(next, newNext);
          }
          return;
        }
        this.setSelectedOptions();
      }
      /**
       * Updates the selectedness of each option when the list of selected options changes.
       *
       * @param prev - the previous list of selected options
       * @param next - the current list of selected options
       *
       * @internal
       */
      selectedOptionsChanged(prev, next) {
        var _a;
        const filteredNext = next.filter(Listbox.slottedOptionFilter);
        (_a = this.options) === null || _a === void 0 ? void 0 : _a.forEach((o) => {
          const notifier = Observable.getNotifier(o);
          notifier.unsubscribe(this, "selected");
          o.selected = filteredNext.includes(o);
          notifier.subscribe(this, "selected");
        });
      }
      /**
       * Moves focus to the first selectable option.
       *
       * @public
       */
      selectFirstOption() {
        var _a, _b;
        if (!this.disabled) {
          this.selectedIndex = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.findIndex((o) => !o.disabled)) !== null && _b !== void 0 ? _b : -1;
        }
      }
      /**
       * Moves focus to the last selectable option.
       *
       * @internal
       */
      selectLastOption() {
        if (!this.disabled) {
          this.selectedIndex = findLastIndex(this.options, (o) => !o.disabled);
        }
      }
      /**
       * Moves focus to the next selectable option.
       *
       * @internal
       */
      selectNextOption() {
        if (!this.disabled && this.selectedIndex < this.options.length - 1) {
          this.selectedIndex += 1;
        }
      }
      /**
       * Moves focus to the previous selectable option.
       *
       * @internal
       */
      selectPreviousOption() {
        if (!this.disabled && this.selectedIndex > 0) {
          this.selectedIndex = this.selectedIndex - 1;
        }
      }
      /**
       * Updates the selected index to match the first selected option.
       *
       * @internal
       */
      setDefaultSelectedOption() {
        var _a, _b;
        this.selectedIndex = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.findIndex((el) => el.defaultSelected)) !== null && _b !== void 0 ? _b : -1;
      }
      /**
       * Sets an option as selected and gives it focus.
       *
       * @public
       */
      setSelectedOptions() {
        var _a, _b, _c;
        if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.length) {
          this.selectedOptions = [this.options[this.selectedIndex]];
          this.ariaActiveDescendant = (_c = (_b = this.firstSelectedOption) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : "";
          this.focusAndScrollOptionIntoView();
        }
      }
      /**
       * Updates the list of options and resets the selected option when the slotted option content changes.
       *
       * @param prev - the previous list of slotted options
       * @param next - the current list of slotted options
       *
       * @internal
       */
      slottedOptionsChanged(prev, next) {
        this.options = next.reduce((options, item) => {
          if (isListboxOption(item)) {
            options.push(item);
          }
          return options;
        }, []);
        const setSize = `${this.options.length}`;
        this.options.forEach((option, index) => {
          if (!option.id) {
            option.id = uniqueId2("option-");
          }
          option.ariaPosInSet = `${index + 1}`;
          option.ariaSetSize = setSize;
        });
        if (this.$fastController.isConnected) {
          this.setSelectedOptions();
          this.setDefaultSelectedOption();
        }
      }
      /**
       * Updates the filtered list of options when the typeahead buffer changes.
       *
       * @param prev - the previous typeahead buffer value
       * @param next - the current typeahead buffer value
       *
       * @internal
       */
      typeaheadBufferChanged(prev, next) {
        if (this.$fastController.isConnected) {
          const typeaheadMatches = this.getTypeaheadMatches();
          if (typeaheadMatches.length) {
            const selectedIndex = this.options.indexOf(typeaheadMatches[0]);
            if (selectedIndex > -1) {
              this.selectedIndex = selectedIndex;
            }
          }
          this.typeaheadExpired = false;
        }
      }
    };
    Listbox.slottedOptionFilter = (n) => isListboxOption(n) && !n.hidden;
    Listbox.TYPE_AHEAD_TIMEOUT_MS = 1e3;
    __decorate([
      attr({ mode: "boolean" })
    ], Listbox.prototype, "disabled", void 0);
    __decorate([
      observable
    ], Listbox.prototype, "selectedIndex", void 0);
    __decorate([
      observable
    ], Listbox.prototype, "selectedOptions", void 0);
    __decorate([
      observable
    ], Listbox.prototype, "slottedOptions", void 0);
    __decorate([
      observable
    ], Listbox.prototype, "typeaheadBuffer", void 0);
    DelegatesARIAListbox = class {
    };
    __decorate([
      observable
    ], DelegatesARIAListbox.prototype, "ariaActiveDescendant", void 0);
    __decorate([
      observable
    ], DelegatesARIAListbox.prototype, "ariaDisabled", void 0);
    __decorate([
      observable
    ], DelegatesARIAListbox.prototype, "ariaExpanded", void 0);
    __decorate([
      observable
    ], DelegatesARIAListbox.prototype, "ariaMultiSelectable", void 0);
    applyMixins(DelegatesARIAListbox, ARIAGlobalStatesAndProperties);
    applyMixins(Listbox, DelegatesARIAListbox);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/select/select.options.js
var SelectPosition;
var init_select_options = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/select/select.options.js"() {
    SelectPosition = {
      above: "above",
      below: "below"
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.form-associated.js
var _Combobox, FormAssociatedCombobox;
var init_combobox_form_associated = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.form-associated.js"() {
    init_form_associated();
    init_listbox();
    _Combobox = class extends Listbox {
    };
    FormAssociatedCombobox = class extends FormAssociated(_Combobox) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.options.js
var ComboboxAutocomplete;
var init_combobox_options = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.options.js"() {
    ComboboxAutocomplete = {
      inline: "inline",
      list: "list",
      both: "both",
      none: "none"
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.js
var Combobox, DelegatesARIACombobox;
var init_combobox = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_listbox();
    init_start_end();
    init_select_options();
    init_apply_mixins();
    init_combobox_form_associated();
    init_combobox_options();
    Combobox = class extends FormAssociatedCombobox {
      constructor() {
        super(...arguments);
        this._value = "";
        this.filteredOptions = [];
        this.filter = "";
        this.forcedPosition = false;
        this.listboxId = uniqueId2("listbox-");
        this.maxHeight = 0;
        this.open = false;
      }
      /**
       * Reset the element to its first selectable option when its parent form is reset.
       *
       * @internal
       */
      formResetCallback() {
        super.formResetCallback();
        this.setDefaultSelectedOption();
        this.updateValue();
      }
      /** {@inheritDoc (FormAssociated:interface).validate} */
      validate() {
        super.validate(this.control);
      }
      get isAutocompleteInline() {
        return this.autocomplete === ComboboxAutocomplete.inline || this.isAutocompleteBoth;
      }
      get isAutocompleteList() {
        return this.autocomplete === ComboboxAutocomplete.list || this.isAutocompleteBoth;
      }
      get isAutocompleteBoth() {
        return this.autocomplete === ComboboxAutocomplete.both;
      }
      /**
       * Sets focus and synchronize ARIA attributes when the open property changes.
       *
       * @param prev - the previous open value
       * @param next - the current open value
       *
       * @internal
       */
      openChanged() {
        if (this.open) {
          this.ariaControls = this.listboxId;
          this.ariaExpanded = "true";
          this.setPositioning();
          this.focusAndScrollOptionIntoView();
          DOM.queueUpdate(() => this.focus());
          return;
        }
        this.ariaControls = "";
        this.ariaExpanded = "false";
      }
      /**
       * The list of options.
       *
       * @public
       * @remarks
       * Overrides `Listbox.options`.
       */
      get options() {
        Observable.track(this, "options");
        return this.filteredOptions.length ? this.filteredOptions : this._options;
      }
      set options(value) {
        this._options = value;
        Observable.notify(this, "options");
      }
      /**
       * Updates the placeholder on the proxy element.
       * @internal
       */
      placeholderChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.placeholder = this.placeholder;
        }
      }
      positionChanged(prev, next) {
        this.positionAttribute = next;
        this.setPositioning();
      }
      /**
       * The value property.
       *
       * @public
       */
      get value() {
        Observable.track(this, "value");
        return this._value;
      }
      set value(next) {
        var _a, _b, _c;
        const prev = `${this._value}`;
        if (this.$fastController.isConnected && this.options) {
          const selectedIndex = this.options.findIndex((el) => el.text.toLowerCase() === next.toLowerCase());
          const prevSelectedValue = (_a = this.options[this.selectedIndex]) === null || _a === void 0 ? void 0 : _a.text;
          const nextSelectedValue = (_b = this.options[selectedIndex]) === null || _b === void 0 ? void 0 : _b.text;
          this.selectedIndex = prevSelectedValue !== nextSelectedValue ? selectedIndex : this.selectedIndex;
          next = ((_c = this.firstSelectedOption) === null || _c === void 0 ? void 0 : _c.text) || next;
        }
        if (prev !== next) {
          this._value = next;
          super.valueChanged(prev, next);
          Observable.notify(this, "value");
        }
      }
      /**
       * Handle opening and closing the listbox when the combobox is clicked.
       *
       * @param e - the mouse event
       * @internal
       */
      clickHandler(e) {
        if (this.disabled) {
          return;
        }
        if (this.open) {
          const captured = e.target.closest(`option,[role=option]`);
          if (!captured || captured.disabled) {
            return;
          }
          this.selectedOptions = [captured];
          this.control.value = captured.text;
          this.clearSelectionRange();
          this.updateValue(true);
        }
        this.open = !this.open;
        if (this.open) {
          this.control.focus();
        }
        return true;
      }
      connectedCallback() {
        super.connectedCallback();
        this.forcedPosition = !!this.positionAttribute;
        if (this.value) {
          this.initialValue = this.value;
        }
      }
      /**
       * Synchronize the `aria-disabled` property when the `disabled` property changes.
       *
       * @param prev - The previous disabled value
       * @param next - The next disabled value
       *
       * @internal
       */
      disabledChanged(prev, next) {
        if (super.disabledChanged) {
          super.disabledChanged(prev, next);
        }
        this.ariaDisabled = this.disabled ? "true" : "false";
      }
      /**
       * Filter available options by text value.
       *
       * @public
       */
      filterOptions() {
        if (!this.autocomplete || this.autocomplete === ComboboxAutocomplete.none) {
          this.filter = "";
        }
        const filter = this.filter.toLowerCase();
        this.filteredOptions = this._options.filter((o) => o.text.toLowerCase().startsWith(this.filter.toLowerCase()));
        if (this.isAutocompleteList) {
          if (!this.filteredOptions.length && !filter) {
            this.filteredOptions = this._options;
          }
          this._options.forEach((o) => {
            o.hidden = !this.filteredOptions.includes(o);
          });
        }
      }
      /**
       * Focus the control and scroll the first selected option into view.
       *
       * @internal
       * @remarks
       * Overrides: `Listbox.focusAndScrollOptionIntoView`
       */
      focusAndScrollOptionIntoView() {
        if (this.contains(document.activeElement)) {
          this.control.focus();
          if (this.firstSelectedOption) {
            requestAnimationFrame(() => {
              var _a;
              (_a = this.firstSelectedOption) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ block: "nearest" });
            });
          }
        }
      }
      /**
       * Handle focus state when the element or its children lose focus.
       *
       * @param e - The focus event
       * @internal
       */
      focusoutHandler(e) {
        this.syncValue();
        if (!this.open) {
          return true;
        }
        const focusTarget = e.relatedTarget;
        if (this.isSameNode(focusTarget)) {
          this.focus();
          return;
        }
        if (!this.options || !this.options.includes(focusTarget)) {
          this.open = false;
        }
      }
      /**
       * Handle content changes on the control input.
       *
       * @param e - the input event
       * @internal
       */
      inputHandler(e) {
        this.filter = this.control.value;
        this.filterOptions();
        if (!this.isAutocompleteInline) {
          this.selectedIndex = this.options.map((option) => option.text).indexOf(this.control.value);
        }
        if (e.inputType.includes("deleteContent") || !this.filter.length) {
          return true;
        }
        if (this.isAutocompleteList && !this.open) {
          this.open = true;
        }
        if (this.isAutocompleteInline) {
          if (this.filteredOptions.length) {
            this.selectedOptions = [this.filteredOptions[0]];
            this.selectedIndex = this.options.indexOf(this.firstSelectedOption);
            this.setInlineSelection();
          } else {
            this.selectedIndex = -1;
          }
        }
        return;
      }
      /**
       * Handle keydown actions for listbox navigation.
       *
       * @param e - the keyboard event
       * @internal
       */
      keydownHandler(e) {
        const key2 = e.key;
        if (e.ctrlKey || e.shiftKey) {
          return true;
        }
        switch (key2) {
          case "Enter": {
            this.syncValue();
            if (this.isAutocompleteInline) {
              this.filter = this.value;
            }
            this.open = false;
            this.clearSelectionRange();
            break;
          }
          case "Escape": {
            if (!this.isAutocompleteInline) {
              this.selectedIndex = -1;
            }
            if (this.open) {
              this.open = false;
              break;
            }
            this.value = "";
            this.control.value = "";
            this.filter = "";
            this.filterOptions();
            break;
          }
          case "Tab": {
            this.setInputToSelection();
            if (!this.open) {
              return true;
            }
            e.preventDefault();
            this.open = false;
            break;
          }
          case "ArrowUp":
          case "ArrowDown": {
            this.filterOptions();
            if (!this.open) {
              this.open = true;
              break;
            }
            if (this.filteredOptions.length > 0) {
              super.keydownHandler(e);
            }
            if (this.isAutocompleteInline) {
              this.setInlineSelection();
            }
            break;
          }
          default: {
            return true;
          }
        }
      }
      /**
       * Handle keyup actions for value input and text field manipulations.
       *
       * @param e - the keyboard event
       * @internal
       */
      keyupHandler(e) {
        const key2 = e.key;
        switch (key2) {
          case "ArrowLeft":
          case "ArrowRight":
          case "Backspace":
          case "Delete":
          case "Home":
          case "End": {
            this.filter = this.control.value;
            this.selectedIndex = -1;
            this.filterOptions();
            break;
          }
        }
      }
      /**
       * Ensure that the selectedIndex is within the current allowable filtered range.
       *
       * @param prev - the previous selected index value
       * @param next - the current selected index value
       *
       * @internal
       */
      selectedIndexChanged(prev, next) {
        if (this.$fastController.isConnected) {
          next = limit(-1, this.options.length - 1, next);
          if (next !== this.selectedIndex) {
            this.selectedIndex = next;
            return;
          }
          super.selectedIndexChanged(prev, next);
        }
      }
      /**
       * Move focus to the previous selectable option.
       *
       * @internal
       * @remarks
       * Overrides `Listbox.selectPreviousOption`
       */
      selectPreviousOption() {
        if (!this.disabled && this.selectedIndex >= 0) {
          this.selectedIndex = this.selectedIndex - 1;
        }
      }
      /**
       * Set the default selected options at initialization or reset.
       *
       * @internal
       * @remarks
       * Overrides `Listbox.setDefaultSelectedOption`
       */
      setDefaultSelectedOption() {
        if (this.$fastController.isConnected && this.options) {
          const selectedIndex = this.options.findIndex((el) => el.getAttribute("selected") !== null || el.selected);
          this.selectedIndex = selectedIndex;
          if (!this.dirtyValue && this.firstSelectedOption) {
            this.value = this.firstSelectedOption.text;
          }
          this.setSelectedOptions();
        }
      }
      /**
       * Focus and set the content of the control based on the first selected option.
       *
       * @internal
       */
      setInputToSelection() {
        if (this.firstSelectedOption) {
          this.control.value = this.firstSelectedOption.text;
          this.control.focus();
        }
      }
      /**
       * Focus, set and select the content of the control based on the first selected option.
       *
       * @internal
       */
      setInlineSelection() {
        if (this.firstSelectedOption) {
          this.setInputToSelection();
          this.control.setSelectionRange(this.filter.length, this.control.value.length, "backward");
        }
      }
      /**
       * Determines if a value update should involve emitting a change event, then updates the value.
       *
       * @internal
       */
      syncValue() {
        var _a;
        const newValue = this.selectedIndex > -1 ? (_a = this.firstSelectedOption) === null || _a === void 0 ? void 0 : _a.text : this.control.value;
        this.updateValue(this.value !== newValue);
      }
      /**
       * Calculate and apply listbox positioning based on available viewport space.
       *
       * @param force - direction to force the listbox to display
       * @public
       */
      setPositioning() {
        const currentBox = this.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const availableBottom = viewportHeight - currentBox.bottom;
        this.position = this.forcedPosition ? this.positionAttribute : currentBox.top > availableBottom ? SelectPosition.above : SelectPosition.below;
        this.positionAttribute = this.forcedPosition ? this.positionAttribute : this.position;
        this.maxHeight = this.position === SelectPosition.above ? ~~currentBox.top : ~~availableBottom;
      }
      /**
       * Ensure that the entire list of options is used when setting the selected property.
       *
       * @param prev - the previous list of selected options
       * @param next - the current list of selected options
       *
       * @internal
       * @remarks
       * Overrides: `Listbox.selectedOptionsChanged`
       */
      selectedOptionsChanged(prev, next) {
        if (this.$fastController.isConnected) {
          this._options.forEach((o) => {
            o.selected = next.includes(o);
          });
        }
      }
      /**
       * Synchronize the form-associated proxy and update the value property of the element.
       *
       * @param prev - the previous collection of slotted option elements
       * @param next - the next collection of slotted option elements
       *
       * @internal
       */
      slottedOptionsChanged(prev, next) {
        super.slottedOptionsChanged(prev, next);
        this.updateValue();
      }
      /**
       * Sets the value and to match the first selected option.
       *
       * @param shouldEmit - if true, the change event will be emitted
       *
       * @internal
       */
      updateValue(shouldEmit) {
        var _a;
        if (this.$fastController.isConnected) {
          this.value = ((_a = this.firstSelectedOption) === null || _a === void 0 ? void 0 : _a.text) || this.control.value;
          this.control.value = this.value;
        }
        if (shouldEmit) {
          this.$emit("change");
        }
      }
      /**
       * @internal
       */
      clearSelectionRange() {
        const controlValueLength = this.control.value.length;
        this.control.setSelectionRange(controlValueLength, controlValueLength);
      }
    };
    __decorate([
      attr({ attribute: "autocomplete", mode: "fromView" })
    ], Combobox.prototype, "autocomplete", void 0);
    __decorate([
      observable
    ], Combobox.prototype, "maxHeight", void 0);
    __decorate([
      attr({ attribute: "open", mode: "boolean" })
    ], Combobox.prototype, "open", void 0);
    __decorate([
      attr
    ], Combobox.prototype, "placeholder", void 0);
    __decorate([
      attr({ attribute: "position" })
    ], Combobox.prototype, "positionAttribute", void 0);
    __decorate([
      observable
    ], Combobox.prototype, "position", void 0);
    DelegatesARIACombobox = class {
    };
    __decorate([
      observable
    ], DelegatesARIACombobox.prototype, "ariaAutoComplete", void 0);
    __decorate([
      observable
    ], DelegatesARIACombobox.prototype, "ariaControls", void 0);
    applyMixins(DelegatesARIACombobox, DelegatesARIAListbox);
    applyMixins(Combobox, StartEnd, DelegatesARIACombobox);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.template.js
var comboboxTemplate;
var init_combobox_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.template.js"() {
    init_esm();
    init_listbox();
    init_start_end();
    comboboxTemplate = (context, definition) => html`
    <template
        aria-disabled="${(x) => x.ariaDisabled}"
        autocomplete="${(x) => x.autocomplete}"
        class="${(x) => x.open ? "open" : ""} ${(x) => x.disabled ? "disabled" : ""} ${(x) => x.position}"
        ?open="${(x) => x.open}"
        tabindex="${(x) => !x.disabled ? "0" : null}"
        @click="${(x, c) => x.clickHandler(c.event)}"
        @focusout="${(x, c) => x.focusoutHandler(c.event)}"
        @keydown="${(x, c) => x.keydownHandler(c.event)}"
    >
        <div class="control" part="control">
            ${startSlotTemplate(context, definition)}
            <slot name="control">
                <input
                    aria-activedescendant="${(x) => x.open ? x.ariaActiveDescendant : null}"
                    aria-autocomplete="${(x) => x.ariaAutoComplete}"
                    aria-controls="${(x) => x.ariaControls}"
                    aria-disabled="${(x) => x.ariaDisabled}"
                    aria-expanded="${(x) => x.ariaExpanded}"
                    aria-haspopup="listbox"
                    class="selected-value"
                    part="selected-value"
                    placeholder="${(x) => x.placeholder}"
                    role="combobox"
                    type="text"
                    ?disabled="${(x) => x.disabled}"
                    :value="${(x) => x.value}"
                    @input="${(x, c) => x.inputHandler(c.event)}"
                    @keyup="${(x, c) => x.keyupHandler(c.event)}"
                    ${ref("control")}
                />
                <div class="indicator" part="indicator" aria-hidden="true">
                    <slot name="indicator">
                        ${definition.indicator || ""}
                    </slot>
                </div>
            </slot>
            ${endSlotTemplate(context, definition)}
        </div>
        <div
            class="listbox"
            id="${(x) => x.listboxId}"
            part="listbox"
            role="listbox"
            ?disabled="${(x) => x.disabled}"
            ?hidden="${(x) => !x.open}"
            ${ref("listbox")}
        >
            <slot
                ${slotted({
      filter: Listbox.slottedOptionFilter,
      flatten: true,
      property: "slottedOptions"
    })}
            ></slot>
        </div>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/combobox/index.js
var init_combobox2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/combobox/index.js"() {
    init_combobox();
    init_combobox_options();
    init_combobox_template();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/composed-parent.js
function composedParent(element) {
  const parentNode = element.parentElement;
  if (parentNode) {
    return parentNode;
  } else {
    const rootNode = element.getRootNode();
    if (rootNode.host instanceof HTMLElement) {
      return rootNode.host;
    }
  }
  return null;
}
var init_composed_parent = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/composed-parent.js"() {
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/composed-contains.js
function composedContains(reference, test) {
  let current = test;
  while (current !== null) {
    if (current === reference) {
      return true;
    }
    current = composedParent(current);
  }
  return false;
}
var init_composed_contains = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/composed-contains.js"() {
    init_composed_parent();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/design-token/custom-property-manager.js
function isFastElement(element) {
  return element instanceof FASTElement;
}
var defaultElement, QueuedStyleSheetTarget, ConstructableStyleSheetTarget, DocumentStyleSheetTarget, HeadStyleElementStyleSheetTarget, StyleElementStyleSheetTarget, ElementStyleSheetTarget, RootStyleSheetTarget, propertyTargetCache, propertyTargetCtor, PropertyTargetManager;
var init_custom_property_manager = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/design-token/custom-property-manager.js"() {
    init_tslib_es6();
    init_esm();
    defaultElement = document.createElement("div");
    QueuedStyleSheetTarget = class {
      setProperty(name2, value) {
        DOM.queueUpdate(() => this.target.setProperty(name2, value));
      }
      removeProperty(name2) {
        DOM.queueUpdate(() => this.target.removeProperty(name2));
      }
    };
    ConstructableStyleSheetTarget = class extends QueuedStyleSheetTarget {
      constructor(source) {
        super();
        const sheet = new CSSStyleSheet();
        this.target = sheet.cssRules[sheet.insertRule(":host{}")].style;
        source.$fastController.addStyles(ElementStyles.create([sheet]));
      }
    };
    DocumentStyleSheetTarget = class extends QueuedStyleSheetTarget {
      constructor() {
        super();
        const sheet = new CSSStyleSheet();
        this.target = sheet.cssRules[sheet.insertRule(":root{}")].style;
        document.adoptedStyleSheets = [
          ...document.adoptedStyleSheets,
          sheet
        ];
      }
    };
    HeadStyleElementStyleSheetTarget = class extends QueuedStyleSheetTarget {
      constructor() {
        super();
        this.style = document.createElement("style");
        document.head.appendChild(this.style);
        const { sheet } = this.style;
        if (sheet) {
          const index = sheet.insertRule(":root{}", sheet.cssRules.length);
          this.target = sheet.cssRules[index].style;
        }
      }
    };
    StyleElementStyleSheetTarget = class {
      constructor(target2) {
        this.store = /* @__PURE__ */ new Map();
        this.target = null;
        const controller = target2.$fastController;
        this.style = document.createElement("style");
        controller.addStyles(this.style);
        Observable.getNotifier(controller).subscribe(this, "isConnected");
        this.handleChange(controller, "isConnected");
      }
      targetChanged() {
        if (this.target !== null) {
          for (const [key2, value] of this.store.entries()) {
            this.target.setProperty(key2, value);
          }
        }
      }
      setProperty(name2, value) {
        this.store.set(name2, value);
        DOM.queueUpdate(() => {
          if (this.target !== null) {
            this.target.setProperty(name2, value);
          }
        });
      }
      removeProperty(name2) {
        this.store.delete(name2);
        DOM.queueUpdate(() => {
          if (this.target !== null) {
            this.target.removeProperty(name2);
          }
        });
      }
      handleChange(source, key2) {
        const { sheet } = this.style;
        if (sheet) {
          const index = sheet.insertRule(":host{}", sheet.cssRules.length);
          this.target = sheet.cssRules[index].style;
        } else {
          this.target = null;
        }
      }
    };
    __decorate(
      [
        observable
      ],
      StyleElementStyleSheetTarget.prototype,
      "target",
      void 0
    );
    ElementStyleSheetTarget = class {
      constructor(source) {
        this.target = source.style;
      }
      setProperty(name2, value) {
        DOM.queueUpdate(() => this.target.setProperty(name2, value));
      }
      removeProperty(name2) {
        DOM.queueUpdate(() => this.target.removeProperty(name2));
      }
    };
    RootStyleSheetTarget = class {
      setProperty(name2, value) {
        RootStyleSheetTarget.properties[name2] = value;
        for (const target2 of RootStyleSheetTarget.roots.values()) {
          PropertyTargetManager.getOrCreate(RootStyleSheetTarget.normalizeRoot(target2)).setProperty(name2, value);
        }
      }
      removeProperty(name2) {
        delete RootStyleSheetTarget.properties[name2];
        for (const target2 of RootStyleSheetTarget.roots.values()) {
          PropertyTargetManager.getOrCreate(RootStyleSheetTarget.normalizeRoot(target2)).removeProperty(name2);
        }
      }
      static registerRoot(root) {
        const { roots } = RootStyleSheetTarget;
        if (!roots.has(root)) {
          roots.add(root);
          const target2 = PropertyTargetManager.getOrCreate(this.normalizeRoot(root));
          for (const key2 in RootStyleSheetTarget.properties) {
            target2.setProperty(key2, RootStyleSheetTarget.properties[key2]);
          }
        }
      }
      static unregisterRoot(root) {
        const { roots } = RootStyleSheetTarget;
        if (roots.has(root)) {
          roots.delete(root);
          const target2 = PropertyTargetManager.getOrCreate(RootStyleSheetTarget.normalizeRoot(root));
          for (const key2 in RootStyleSheetTarget.properties) {
            target2.removeProperty(key2);
          }
        }
      }
      /**
       * Returns the document when provided the default element,
       * otherwise is a no-op
       * @param root - the root to normalize
       */
      static normalizeRoot(root) {
        return root === defaultElement ? document : root;
      }
    };
    RootStyleSheetTarget.roots = /* @__PURE__ */ new Set();
    RootStyleSheetTarget.properties = {};
    propertyTargetCache = /* @__PURE__ */ new WeakMap();
    propertyTargetCtor = DOM.supportsAdoptedStyleSheets ? ConstructableStyleSheetTarget : StyleElementStyleSheetTarget;
    PropertyTargetManager = Object.freeze({
      getOrCreate(source) {
        if (propertyTargetCache.has(source)) {
          return propertyTargetCache.get(source);
        }
        let target2;
        if (source === defaultElement) {
          target2 = new RootStyleSheetTarget();
        } else if (source instanceof Document) {
          target2 = DOM.supportsAdoptedStyleSheets ? new DocumentStyleSheetTarget() : new HeadStyleElementStyleSheetTarget();
        } else if (isFastElement(source)) {
          target2 = new propertyTargetCtor(source);
        } else {
          target2 = new ElementStyleSheetTarget(source);
        }
        propertyTargetCache.set(source, target2);
        return target2;
      }
    });
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/design-token/design-token.js
function create2(nameOrConfig) {
  return DesignTokenImpl.from(nameOrConfig);
}
var DesignTokenImpl, CustomPropertyReflector, DesignTokenBindingObserver, Store, nodeCache, childToParent, DesignTokenNode, DesignToken;
var init_design_token = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/design-token/design-token.js"() {
    init_tslib_es6();
    init_esm();
    init_composed_parent();
    init_composed_contains();
    init_custom_property_manager();
    init_custom_property_manager();
    DesignTokenImpl = class extends CSSDirective {
      constructor(configuration) {
        super();
        this.subscribers = /* @__PURE__ */ new WeakMap();
        this._appliedTo = /* @__PURE__ */ new Set();
        this.name = configuration.name;
        if (configuration.cssCustomPropertyName !== null) {
          this.cssCustomProperty = `--${configuration.cssCustomPropertyName}`;
          this.cssVar = `var(${this.cssCustomProperty})`;
        }
        this.id = DesignTokenImpl.uniqueId();
        DesignTokenImpl.tokensById.set(this.id, this);
      }
      get appliedTo() {
        return [...this._appliedTo];
      }
      static from(nameOrConfig) {
        return new DesignTokenImpl({
          name: typeof nameOrConfig === "string" ? nameOrConfig : nameOrConfig.name,
          cssCustomPropertyName: typeof nameOrConfig === "string" ? nameOrConfig : nameOrConfig.cssCustomPropertyName === void 0 ? nameOrConfig.name : nameOrConfig.cssCustomPropertyName
        });
      }
      static isCSSDesignToken(token) {
        return typeof token.cssCustomProperty === "string";
      }
      static isDerivedDesignTokenValue(value) {
        return typeof value === "function";
      }
      /**
       * Gets a token by ID. Returns undefined if the token was not found.
       * @param id - The ID of the token
       * @returns
       */
      static getTokenById(id) {
        return DesignTokenImpl.tokensById.get(id);
      }
      getOrCreateSubscriberSet(target2 = this) {
        return this.subscribers.get(target2) || this.subscribers.set(target2, /* @__PURE__ */ new Set()) && this.subscribers.get(target2);
      }
      createCSS() {
        return this.cssVar || "";
      }
      getValueFor(element) {
        const value = DesignTokenNode.getOrCreate(element).get(this);
        if (value !== void 0) {
          return value;
        }
        throw new Error(`Value could not be retrieved for token named "${this.name}". Ensure the value is set for ${element} or an ancestor of ${element}.`);
      }
      setValueFor(element, value) {
        this._appliedTo.add(element);
        if (value instanceof DesignTokenImpl) {
          value = this.alias(value);
        }
        DesignTokenNode.getOrCreate(element).set(this, value);
        return this;
      }
      deleteValueFor(element) {
        this._appliedTo.delete(element);
        if (DesignTokenNode.existsFor(element)) {
          DesignTokenNode.getOrCreate(element).delete(this);
        }
        return this;
      }
      withDefault(value) {
        this.setValueFor(defaultElement, value);
        return this;
      }
      subscribe(subscriber, target2) {
        const subscriberSet = this.getOrCreateSubscriberSet(target2);
        if (target2 && !DesignTokenNode.existsFor(target2)) {
          DesignTokenNode.getOrCreate(target2);
        }
        if (!subscriberSet.has(subscriber)) {
          subscriberSet.add(subscriber);
        }
      }
      unsubscribe(subscriber, target2) {
        const list = this.subscribers.get(target2 || this);
        if (list && list.has(subscriber)) {
          list.delete(subscriber);
        }
      }
      /**
       * Notifies subscribers that the value for an element has changed.
       * @param element - The element to emit a notification for
       */
      notify(element) {
        const record = Object.freeze({ token: this, target: element });
        if (this.subscribers.has(this)) {
          this.subscribers.get(this).forEach((sub) => sub.handleChange(record));
        }
        if (this.subscribers.has(element)) {
          this.subscribers.get(element).forEach((sub) => sub.handleChange(record));
        }
      }
      /**
       * Alias the token to the provided token.
       * @param token - the token to alias to
       */
      alias(token) {
        return (target2) => token.getValueFor(target2);
      }
    };
    DesignTokenImpl.uniqueId = (() => {
      let id = 0;
      return () => {
        id++;
        return id.toString(16);
      };
    })();
    DesignTokenImpl.tokensById = /* @__PURE__ */ new Map();
    CustomPropertyReflector = class {
      startReflection(token, target2) {
        token.subscribe(this, target2);
        this.handleChange({ token, target: target2 });
      }
      stopReflection(token, target2) {
        token.unsubscribe(this, target2);
        this.remove(token, target2);
      }
      handleChange(record) {
        const { token, target: target2 } = record;
        this.add(token, target2);
      }
      add(token, target2) {
        PropertyTargetManager.getOrCreate(target2).setProperty(token.cssCustomProperty, this.resolveCSSValue(DesignTokenNode.getOrCreate(target2).get(token)));
      }
      remove(token, target2) {
        PropertyTargetManager.getOrCreate(target2).removeProperty(token.cssCustomProperty);
      }
      resolveCSSValue(value) {
        return value && typeof value.createCSS === "function" ? value.createCSS() : value;
      }
    };
    DesignTokenBindingObserver = class {
      constructor(source, token, node) {
        this.source = source;
        this.token = token;
        this.node = node;
        this.dependencies = /* @__PURE__ */ new Set();
        this.observer = Observable.binding(source, this, false);
        this.observer.handleChange = this.observer.call;
        this.handleChange();
      }
      disconnect() {
        this.observer.disconnect();
      }
      /**
       * @internal
       */
      handleChange() {
        this.node.store.set(this.token, this.observer.observe(this.node.target, defaultExecutionContext));
      }
    };
    Store = class {
      constructor() {
        this.values = /* @__PURE__ */ new Map();
      }
      set(token, value) {
        if (this.values.get(token) !== value) {
          this.values.set(token, value);
          Observable.getNotifier(this).notify(token.id);
        }
      }
      get(token) {
        Observable.track(this, token.id);
        return this.values.get(token);
      }
      delete(token) {
        this.values.delete(token);
      }
      all() {
        return this.values.entries();
      }
    };
    nodeCache = /* @__PURE__ */ new WeakMap();
    childToParent = /* @__PURE__ */ new WeakMap();
    DesignTokenNode = class {
      constructor(target2) {
        this.target = target2;
        this.store = new Store();
        this.children = [];
        this.assignedValues = /* @__PURE__ */ new Map();
        this.reflecting = /* @__PURE__ */ new Set();
        this.bindingObservers = /* @__PURE__ */ new Map();
        this.tokenValueChangeHandler = {
          handleChange: (source, arg) => {
            const token = DesignTokenImpl.getTokenById(arg);
            if (token) {
              token.notify(this.target);
              this.updateCSSTokenReflection(source, token);
            }
          }
        };
        nodeCache.set(target2, this);
        Observable.getNotifier(this.store).subscribe(this.tokenValueChangeHandler);
        if (target2 instanceof FASTElement) {
          target2.$fastController.addBehaviors([this]);
        } else if (target2.isConnected) {
          this.bind();
        }
      }
      /**
       * Returns a DesignTokenNode for an element.
       * Creates a new instance if one does not already exist for a node,
       * otherwise returns the cached instance
       *
       * @param target - The HTML element to retrieve a DesignTokenNode for
       */
      static getOrCreate(target2) {
        return nodeCache.get(target2) || new DesignTokenNode(target2);
      }
      /**
       * Determines if a DesignTokenNode has been created for a target
       * @param target - The element to test
       */
      static existsFor(target2) {
        return nodeCache.has(target2);
      }
      /**
       * Searches for and return the nearest parent DesignTokenNode.
       * Null is returned if no node is found or the node provided is for a default element.
       */
      static findParent(node) {
        if (!(defaultElement === node.target)) {
          let parent = composedParent(node.target);
          while (parent !== null) {
            if (nodeCache.has(parent)) {
              return nodeCache.get(parent);
            }
            parent = composedParent(parent);
          }
          return DesignTokenNode.getOrCreate(defaultElement);
        }
        return null;
      }
      /**
       * Finds the closest node with a value explicitly assigned for a token, otherwise null.
       * @param token - The token to look for
       * @param start - The node to start looking for value assignment
       * @returns
       */
      static findClosestAssignedNode(token, start) {
        let current = start;
        do {
          if (current.has(token)) {
            return current;
          }
          current = current.parent ? current.parent : current.target !== defaultElement ? DesignTokenNode.getOrCreate(defaultElement) : null;
        } while (current !== null);
        return null;
      }
      /**
       * The parent DesignTokenNode, or null.
       */
      get parent() {
        return childToParent.get(this) || null;
      }
      updateCSSTokenReflection(source, token) {
        if (DesignTokenImpl.isCSSDesignToken(token)) {
          const parent = this.parent;
          const reflecting = this.isReflecting(token);
          if (parent) {
            const parentValue = parent.get(token);
            const sourceValue = source.get(token);
            if (parentValue !== sourceValue && !reflecting) {
              this.reflectToCSS(token);
            } else if (parentValue === sourceValue && reflecting) {
              this.stopReflectToCSS(token);
            }
          } else if (!reflecting) {
            this.reflectToCSS(token);
          }
        }
      }
      /**
       * Checks if a token has been assigned an explicit value the node.
       * @param token - the token to check.
       */
      has(token) {
        return this.assignedValues.has(token);
      }
      /**
       * Gets the value of a token for a node
       * @param token - The token to retrieve the value for
       * @returns
       */
      get(token) {
        const value = this.store.get(token);
        if (value !== void 0) {
          return value;
        }
        const raw = this.getRaw(token);
        if (raw !== void 0) {
          this.hydrate(token, raw);
          return this.get(token);
        }
      }
      /**
       * Retrieves the raw assigned value of a token from the nearest assigned node.
       * @param token - The token to retrieve a raw value for
       * @returns
       */
      getRaw(token) {
        var _a;
        if (this.assignedValues.has(token)) {
          return this.assignedValues.get(token);
        }
        return (_a = DesignTokenNode.findClosestAssignedNode(token, this)) === null || _a === void 0 ? void 0 : _a.getRaw(token);
      }
      /**
       * Sets a token to a value for a node
       * @param token - The token to set
       * @param value - The value to set the token to
       */
      set(token, value) {
        if (DesignTokenImpl.isDerivedDesignTokenValue(this.assignedValues.get(token))) {
          this.tearDownBindingObserver(token);
        }
        this.assignedValues.set(token, value);
        if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {
          this.setupBindingObserver(token, value);
        } else {
          this.store.set(token, value);
        }
      }
      /**
       * Deletes a token value for the node.
       * @param token - The token to delete the value for
       */
      delete(token) {
        this.assignedValues.delete(token);
        this.tearDownBindingObserver(token);
        const upstream = this.getRaw(token);
        if (upstream) {
          this.hydrate(token, upstream);
        } else {
          this.store.delete(token);
        }
      }
      /**
       * Invoked when the DesignTokenNode.target is attached to the document
       */
      bind() {
        const parent = DesignTokenNode.findParent(this);
        if (parent) {
          parent.appendChild(this);
        }
        for (const key2 of this.assignedValues.keys()) {
          key2.notify(this.target);
        }
      }
      /**
       * Invoked when the DesignTokenNode.target is detached from the document
       */
      unbind() {
        if (this.parent) {
          const parent = childToParent.get(this);
          parent.removeChild(this);
        }
      }
      /**
       * Appends a child to a parent DesignTokenNode.
       * @param child - The child to append to the node
       */
      appendChild(child) {
        if (child.parent) {
          childToParent.get(child).removeChild(child);
        }
        const reParent = this.children.filter((x) => child.contains(x));
        childToParent.set(child, this);
        this.children.push(child);
        reParent.forEach((x) => child.appendChild(x));
        Observable.getNotifier(this.store).subscribe(child);
        for (const [token, value] of this.store.all()) {
          child.hydrate(token, this.bindingObservers.has(token) ? this.getRaw(token) : value);
        }
      }
      /**
       * Removes a child from a node.
       * @param child - The child to remove.
       */
      removeChild(child) {
        const childIndex = this.children.indexOf(child);
        if (childIndex !== -1) {
          this.children.splice(childIndex, 1);
        }
        Observable.getNotifier(this.store).unsubscribe(child);
        return child.parent === this ? childToParent.delete(child) : false;
      }
      /**
       * Tests whether a provided node is contained by
       * the calling node.
       * @param test - The node to test
       */
      contains(test) {
        return composedContains(this.target, test.target);
      }
      /**
       * Instructs the node to reflect a design token for the provided token.
       * @param token - The design token to reflect
       */
      reflectToCSS(token) {
        if (!this.isReflecting(token)) {
          this.reflecting.add(token);
          DesignTokenNode.cssCustomPropertyReflector.startReflection(token, this.target);
        }
      }
      /**
       * Stops reflecting a DesignToken to CSS
       * @param token - The design token to stop reflecting
       */
      stopReflectToCSS(token) {
        if (this.isReflecting(token)) {
          this.reflecting.delete(token);
          DesignTokenNode.cssCustomPropertyReflector.stopReflection(token, this.target);
        }
      }
      /**
       * Determines if a token is being reflected to CSS for a node.
       * @param token - The token to check for reflection
       * @returns
       */
      isReflecting(token) {
        return this.reflecting.has(token);
      }
      /**
       * Handle changes to upstream tokens
       * @param source - The parent DesignTokenNode
       * @param property - The token ID that changed
       */
      handleChange(source, property) {
        const token = DesignTokenImpl.getTokenById(property);
        if (!token) {
          return;
        }
        this.hydrate(token, this.getRaw(token));
        this.updateCSSTokenReflection(this.store, token);
      }
      /**
       * Hydrates a token with a DesignTokenValue, making retrieval available.
       * @param token - The token to hydrate
       * @param value - The value to hydrate
       */
      hydrate(token, value) {
        if (!this.has(token)) {
          const observer = this.bindingObservers.get(token);
          if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {
            if (observer) {
              if (observer.source !== value) {
                this.tearDownBindingObserver(token);
                this.setupBindingObserver(token, value);
              }
            } else {
              this.setupBindingObserver(token, value);
            }
          } else {
            if (observer) {
              this.tearDownBindingObserver(token);
            }
            this.store.set(token, value);
          }
        }
      }
      /**
       * Sets up a binding observer for a derived token value that notifies token
       * subscribers on change.
       *
       * @param token - The token to notify when the binding updates
       * @param source - The binding source
       */
      setupBindingObserver(token, source) {
        const binding = new DesignTokenBindingObserver(source, token, this);
        this.bindingObservers.set(token, binding);
        return binding;
      }
      /**
       * Tear down a binding observer for a token.
       */
      tearDownBindingObserver(token) {
        if (this.bindingObservers.has(token)) {
          this.bindingObservers.get(token).disconnect();
          this.bindingObservers.delete(token);
          return true;
        }
        return false;
      }
    };
    DesignTokenNode.cssCustomPropertyReflector = new CustomPropertyReflector();
    __decorate(
      [
        observable
      ],
      DesignTokenNode.prototype,
      "children",
      void 0
    );
    DesignToken = Object.freeze({
      create: create2,
      /**
       * Informs DesignToken that an HTMLElement for which tokens have
       * been set has been connected to the document.
       *
       * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness
       * in all scenarios, so invoking this method manually is necessary when:
       *
       * 1. Token values are set for an HTMLElement.
       * 2. The HTMLElement does not inherit from FASTElement.
       * 3. The HTMLElement is not connected to the document when token values are set.
       *
       * @param element - The element to notify
       * @returns - true if notification was successful, otherwise false.
       */
      notifyConnection(element) {
        if (!element.isConnected || !DesignTokenNode.existsFor(element)) {
          return false;
        }
        DesignTokenNode.getOrCreate(element).bind();
        return true;
      },
      /**
       * Informs DesignToken that an HTMLElement for which tokens have
       * been set has been disconnected to the document.
       *
       * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness
       * in all scenarios, so invoking this method manually is necessary when:
       *
       * 1. Token values are set for an HTMLElement.
       * 2. The HTMLElement does not inherit from FASTElement.
       *
       * @param element - The element to notify
       * @returns - true if notification was successful, otherwise false.
       */
      notifyDisconnection(element) {
        if (element.isConnected || !DesignTokenNode.existsFor(element)) {
          return false;
        }
        DesignTokenNode.getOrCreate(element).unbind();
        return true;
      },
      /**
       * Registers and element or document as a DesignToken root.
       * {@link CSSDesignToken | CSSDesignTokens} with default values assigned via
       * {@link (DesignToken:interface).withDefault} will emit CSS custom properties to all
       * registered roots.
       * @param target - The root to register
       */
      registerRoot(target2 = defaultElement) {
        RootStyleSheetTarget.registerRoot(target2);
      },
      /**
       * Unregister an element or document as a DesignToken root.
       * @param target - The root to deregister
       */
      unregisterRoot(target2 = defaultElement) {
        RootStyleSheetTarget.unregisterRoot(target2);
      }
    });
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/design-system/design-system.js
function extractTryDefineElementParams(params, elementDefinitionType, elementDefinitionCallback) {
  if (typeof params === "string") {
    return {
      name: params,
      type: elementDefinitionType,
      callback: elementDefinitionCallback
    };
  } else {
    return params;
  }
}
var ElementDisambiguation, elementTypesByTag, elementTagsByType, rootDesignSystem, designSystemKey, DesignSystem, DefaultDesignSystem, ElementDefinitionEntry;
var init_design_system = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/design-system/design-system.js"() {
    init_esm();
    init_foundation_element();
    init_di();
    init_design_token();
    init_component_presentation();
    ElementDisambiguation = Object.freeze({
      /**
       * Skip defining the element but still call the provided callback passed
       * to DesignSystemRegistrationContext.tryDefineElement
       */
      definitionCallbackOnly: null,
      /**
       * Ignore the duplicate element entirely.
       */
      ignoreDuplicate: Symbol()
    });
    elementTypesByTag = /* @__PURE__ */ new Map();
    elementTagsByType = /* @__PURE__ */ new Map();
    rootDesignSystem = null;
    designSystemKey = DI.createInterface((x) => x.cachedCallback((handler) => {
      if (rootDesignSystem === null) {
        rootDesignSystem = new DefaultDesignSystem(null, handler);
      }
      return rootDesignSystem;
    }));
    DesignSystem = Object.freeze({
      /**
       * Returns the HTML element name that the type is defined as.
       * @param type - The type to lookup.
       * @public
       */
      tagFor(type) {
        return elementTagsByType.get(type);
      },
      /**
       * Searches the DOM hierarchy for the design system that is responsible
       * for the provided element.
       * @param element - The element to locate the design system for.
       * @returns The located design system.
       * @public
       */
      responsibleFor(element) {
        const owned = element.$$designSystem$$;
        if (owned) {
          return owned;
        }
        const container = DI.findResponsibleContainer(element);
        return container.get(designSystemKey);
      },
      /**
       * Gets the DesignSystem if one is explicitly defined on the provided element;
       * otherwise creates a design system defined directly on the element.
       * @param element - The element to get or create a design system for.
       * @returns The design system.
       * @public
       */
      getOrCreate(node) {
        if (!node) {
          if (rootDesignSystem === null) {
            rootDesignSystem = DI.getOrCreateDOMContainer().get(designSystemKey);
          }
          return rootDesignSystem;
        }
        const owned = node.$$designSystem$$;
        if (owned) {
          return owned;
        }
        const container = DI.getOrCreateDOMContainer(node);
        if (container.has(designSystemKey, false)) {
          return container.get(designSystemKey);
        } else {
          const system = new DefaultDesignSystem(node, container);
          container.register(Registration.instance(designSystemKey, system));
          return system;
        }
      }
    });
    DefaultDesignSystem = class {
      constructor(owner, container) {
        this.owner = owner;
        this.container = container;
        this.designTokensInitialized = false;
        this.prefix = "fast";
        this.shadowRootMode = void 0;
        this.disambiguate = () => ElementDisambiguation.definitionCallbackOnly;
        if (owner !== null) {
          owner.$$designSystem$$ = this;
        }
      }
      withPrefix(prefix) {
        this.prefix = prefix;
        return this;
      }
      withShadowRootMode(mode) {
        this.shadowRootMode = mode;
        return this;
      }
      withElementDisambiguation(callback) {
        this.disambiguate = callback;
        return this;
      }
      withDesignTokenRoot(root) {
        this.designTokenRoot = root;
        return this;
      }
      register(...registrations) {
        const container = this.container;
        const elementDefinitionEntries = [];
        const disambiguate = this.disambiguate;
        const shadowRootMode = this.shadowRootMode;
        const context = {
          elementPrefix: this.prefix,
          tryDefineElement(params, elementDefinitionType, elementDefinitionCallback) {
            const extractedParams = extractTryDefineElementParams(params, elementDefinitionType, elementDefinitionCallback);
            const { name: name2, callback, baseClass } = extractedParams;
            let { type } = extractedParams;
            let elementName = name2;
            let typeFoundByName = elementTypesByTag.get(elementName);
            let needsDefine = true;
            while (typeFoundByName) {
              const result = disambiguate(elementName, type, typeFoundByName);
              switch (result) {
                case ElementDisambiguation.ignoreDuplicate:
                  return;
                case ElementDisambiguation.definitionCallbackOnly:
                  needsDefine = false;
                  typeFoundByName = void 0;
                  break;
                default:
                  elementName = result;
                  typeFoundByName = elementTypesByTag.get(elementName);
                  break;
              }
            }
            if (needsDefine) {
              if (elementTagsByType.has(type) || type === FoundationElement) {
                type = class extends type {
                };
              }
              elementTypesByTag.set(elementName, type);
              elementTagsByType.set(type, elementName);
              if (baseClass) {
                elementTagsByType.set(baseClass, elementName);
              }
            }
            elementDefinitionEntries.push(new ElementDefinitionEntry(container, elementName, type, shadowRootMode, callback, needsDefine));
          }
        };
        if (!this.designTokensInitialized) {
          this.designTokensInitialized = true;
          if (this.designTokenRoot !== null) {
            DesignToken.registerRoot(this.designTokenRoot);
          }
        }
        container.registerWithContext(context, ...registrations);
        for (const entry of elementDefinitionEntries) {
          entry.callback(entry);
          if (entry.willDefine && entry.definition !== null) {
            entry.definition.define();
          }
        }
        return this;
      }
    };
    ElementDefinitionEntry = class {
      constructor(container, name2, type, shadowRootMode, callback, willDefine) {
        this.container = container;
        this.name = name2;
        this.type = type;
        this.shadowRootMode = shadowRootMode;
        this.callback = callback;
        this.willDefine = willDefine;
        this.definition = null;
      }
      definePresentation(presentation) {
        ComponentPresentation.define(this.name, presentation, this.container);
      }
      defineElement(definition) {
        this.definition = new FASTElementDefinition(this.type, Object.assign(Object.assign({}, definition), { name: this.name }));
      }
      tagFor(type) {
        return DesignSystem.tagFor(type);
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/design-system/registration-context.js
var init_registration_context = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/design-system/registration-context.js"() {
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/design-system/index.js
var init_design_system2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/design-system/index.js"() {
    init_design_system();
    init_component_presentation();
    init_registration_context();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/di/index.js
var init_di2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/di/index.js"() {
    init_di();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/dialog/dialog.template.js
var dialogTemplate;
var init_dialog_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/dialog/dialog.template.js"() {
    init_esm();
    dialogTemplate = (context, definition) => html`
    <div class="positioning-region" part="positioning-region">
        ${when((x) => x.modal, html`
                <div
                    class="overlay"
                    part="overlay"
                    role="presentation"
                    @click="${(x) => x.dismiss()}"
                ></div>
            `)}
        <div
            role="dialog"
            tabindex="-1"
            class="control"
            part="control"
            aria-modal="${(x) => x.modal}"
            aria-describedby="${(x) => x.ariaDescribedby}"
            aria-labelledby="${(x) => x.ariaLabelledby}"
            aria-label="${(x) => x.ariaLabel}"
            ${ref("dialog")}
        >
            <slot></slot>
        </div>
    </div>
`;
  }
});

// ../../node_modules/tabbable/dist/index.esm.js
var candidateSelectors, candidateSelector, NoElement, matches, getRootNode, getTabindex, isInput, isHiddenInput, isDetailsWithSummary, getCheckedRadio, isTabbableRadio, isRadio, isNonTabbableRadio, isZeroArea, isHidden, isDisabledFromFieldset, isNodeMatchingSelectorFocusable, isNodeMatchingSelectorTabbable, isTabbable, focusableCandidateSelector, isFocusable;
var init_index_esm = __esm({
  "../../node_modules/tabbable/dist/index.esm.js"() {
    candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
    candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
    NoElement = typeof Element === "undefined";
    matches = NoElement ? function() {
    } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
      return element.getRootNode();
    } : function(element) {
      return element.ownerDocument;
    };
    getTabindex = function getTabindex2(node, isScope) {
      if (node.tabIndex < 0) {
        if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
          return 0;
        }
      }
      return node.tabIndex;
    };
    isInput = function isInput2(node) {
      return node.tagName === "INPUT";
    };
    isHiddenInput = function isHiddenInput2(node) {
      return isInput(node) && node.type === "hidden";
    };
    isDetailsWithSummary = function isDetailsWithSummary2(node) {
      var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
        return child.tagName === "SUMMARY";
      });
      return r;
    };
    getCheckedRadio = function getCheckedRadio2(nodes, form) {
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].checked && nodes[i].form === form) {
          return nodes[i];
        }
      }
    };
    isTabbableRadio = function isTabbableRadio2(node) {
      if (!node.name) {
        return true;
      }
      var radioScope = node.form || getRootNode(node);
      var queryRadios = function queryRadios2(name2) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name2 + '"]');
      };
      var radioSet;
      if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
        radioSet = queryRadios(window.CSS.escape(node.name));
      } else {
        try {
          radioSet = queryRadios(node.name);
        } catch (err) {
          console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
          return false;
        }
      }
      var checked = getCheckedRadio(radioSet, node.form);
      return !checked || checked === node;
    };
    isRadio = function isRadio2(node) {
      return isInput(node) && node.type === "radio";
    };
    isNonTabbableRadio = function isNonTabbableRadio2(node) {
      return isRadio(node) && !isTabbableRadio(node);
    };
    isZeroArea = function isZeroArea2(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
      return width === 0 && height === 0;
    };
    isHidden = function isHidden2(node, _ref) {
      var displayCheck = _ref.displayCheck, getShadowRoot2 = _ref.getShadowRoot;
      if (getComputedStyle(node).visibility === "hidden") {
        return true;
      }
      var isDirectSummary = matches.call(node, "details>summary:first-of-type");
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
      if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
        return true;
      }
      var nodeRootHost = getRootNode(node).host;
      var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
      if (!displayCheck || displayCheck === "full") {
        if (typeof getShadowRoot2 === "function") {
          var originalNode = node;
          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);
            if (parentElement && !parentElement.shadowRoot && getShadowRoot2(parentElement) === true) {
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              node = rootNode.host;
            } else {
              node = parentElement;
            }
          }
          node = originalNode;
        }
        if (nodeIsAttached) {
          return !node.getClientRects().length;
        }
      } else if (displayCheck === "non-zero-area") {
        return isZeroArea(node);
      }
      return false;
    };
    isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement;
        while (parentNode) {
          if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i);
              if (child.tagName === "LEGEND") {
                return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
              }
            }
            return true;
          }
          parentNode = parentNode.parentElement;
        }
      }
      return false;
    };
    isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }
      return true;
    };
    isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
      if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
        return false;
      }
      return true;
    };
    isTabbable = function isTabbable2(node, options) {
      options = options || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, candidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorTabbable(options, node);
    };
    focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
    isFocusable = function isFocusable2(node, options) {
      options = options || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorFocusable(options, node);
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/dialog/dialog.js
var Dialog;
var init_dialog = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/dialog/dialog.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_index_esm();
    init_foundation_element();
    Dialog = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.modal = true;
        this.hidden = false;
        this.trapFocus = true;
        this.trapFocusChanged = () => {
          if (this.$fastController.isConnected) {
            this.updateTrapFocus();
          }
        };
        this.isTrappingFocus = false;
        this.handleDocumentKeydown = (e) => {
          if (!e.defaultPrevented && !this.hidden) {
            switch (e.key) {
              case keyEscape:
                this.dismiss();
                e.preventDefault();
                break;
              case keyTab:
                this.handleTabKeyDown(e);
                break;
            }
          }
        };
        this.handleDocumentFocus = (e) => {
          if (!e.defaultPrevented && this.shouldForceFocus(e.target)) {
            this.focusFirstElement();
            e.preventDefault();
          }
        };
        this.handleTabKeyDown = (e) => {
          if (!this.trapFocus || this.hidden) {
            return;
          }
          const bounds = this.getTabQueueBounds();
          if (bounds.length === 0) {
            return;
          }
          if (bounds.length === 1) {
            bounds[0].focus();
            e.preventDefault();
            return;
          }
          if (e.shiftKey && e.target === bounds[0]) {
            bounds[bounds.length - 1].focus();
            e.preventDefault();
          } else if (!e.shiftKey && e.target === bounds[bounds.length - 1]) {
            bounds[0].focus();
            e.preventDefault();
          }
          return;
        };
        this.getTabQueueBounds = () => {
          const bounds = [];
          return Dialog.reduceTabbableItems(bounds, this);
        };
        this.focusFirstElement = () => {
          const bounds = this.getTabQueueBounds();
          if (bounds.length > 0) {
            bounds[0].focus();
          } else {
            if (this.dialog instanceof HTMLElement) {
              this.dialog.focus();
            }
          }
        };
        this.shouldForceFocus = (currentFocusElement) => {
          return this.isTrappingFocus && !this.contains(currentFocusElement);
        };
        this.shouldTrapFocus = () => {
          return this.trapFocus && !this.hidden;
        };
        this.updateTrapFocus = (shouldTrapFocusOverride) => {
          const shouldTrapFocus = shouldTrapFocusOverride === void 0 ? this.shouldTrapFocus() : shouldTrapFocusOverride;
          if (shouldTrapFocus && !this.isTrappingFocus) {
            this.isTrappingFocus = true;
            document.addEventListener("focusin", this.handleDocumentFocus);
            DOM.queueUpdate(() => {
              if (this.shouldForceFocus(document.activeElement)) {
                this.focusFirstElement();
              }
            });
          } else if (!shouldTrapFocus && this.isTrappingFocus) {
            this.isTrappingFocus = false;
            document.removeEventListener("focusin", this.handleDocumentFocus);
          }
        };
      }
      /**
       * @internal
       */
      dismiss() {
        this.$emit("dismiss");
        this.$emit("cancel");
      }
      /**
       * The method to show the dialog.
       *
       * @public
       */
      show() {
        this.hidden = false;
      }
      /**
       * The method to hide the dialog.
       *
       * @public
       */
      hide() {
        this.hidden = true;
        this.$emit("close");
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        document.addEventListener("keydown", this.handleDocumentKeydown);
        this.notifier = Observable.getNotifier(this);
        this.notifier.subscribe(this, "hidden");
        this.updateTrapFocus();
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        document.removeEventListener("keydown", this.handleDocumentKeydown);
        this.updateTrapFocus(false);
        this.notifier.unsubscribe(this, "hidden");
      }
      /**
       * @internal
       */
      handleChange(source, propertyName) {
        switch (propertyName) {
          case "hidden":
            this.updateTrapFocus();
            break;
          default:
            break;
        }
      }
      /**
       * Reduce a collection to only its focusable elements.
       *
       * @param elements - Collection of elements to reduce
       * @param element - The current element
       *
       * @internal
       */
      static reduceTabbableItems(elements2, element) {
        if (element.getAttribute("tabindex") === "-1") {
          return elements2;
        }
        if (isTabbable(element) || Dialog.isFocusableFastElement(element) && Dialog.hasTabbableShadow(element)) {
          elements2.push(element);
          return elements2;
        }
        if (element.childElementCount) {
          return elements2.concat(Array.from(element.children).reduce(Dialog.reduceTabbableItems, []));
        }
        return elements2;
      }
      /**
       * Test if element is focusable fast element
       *
       * @param element - The element to check
       *
       * @internal
       */
      static isFocusableFastElement(element) {
        var _a, _b;
        return !!((_b = (_a = element.$fastController) === null || _a === void 0 ? void 0 : _a.definition.shadowOptions) === null || _b === void 0 ? void 0 : _b.delegatesFocus);
      }
      /**
       * Test if the element has a focusable shadow
       *
       * @param element - The element to check
       *
       * @internal
       */
      static hasTabbableShadow(element) {
        var _a, _b;
        return Array.from((_b = (_a = element.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll("*")) !== null && _b !== void 0 ? _b : []).some((x) => {
          return isTabbable(x);
        });
      }
    };
    __decorate([
      attr({ mode: "boolean" })
    ], Dialog.prototype, "modal", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], Dialog.prototype, "hidden", void 0);
    __decorate([
      attr({ attribute: "trap-focus", mode: "boolean" })
    ], Dialog.prototype, "trapFocus", void 0);
    __decorate([
      attr({ attribute: "aria-describedby" })
    ], Dialog.prototype, "ariaDescribedby", void 0);
    __decorate([
      attr({ attribute: "aria-labelledby" })
    ], Dialog.prototype, "ariaLabelledby", void 0);
    __decorate([
      attr({ attribute: "aria-label" })
    ], Dialog.prototype, "ariaLabel", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/dialog/index.js
var init_dialog2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/dialog/index.js"() {
    init_dialog_template();
    init_dialog();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/disclosure/disclosure.template.js
var disclosureTemplate;
var init_disclosure_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/disclosure/disclosure.template.js"() {
    init_esm();
    disclosureTemplate = (context, definition) => html`
    <details class="disclosure" ${ref("details")}>
        <summary
            class="invoker"
            role="button"
            aria-controls="disclosure-content"
            aria-expanded="${(x) => x.expanded}"
        >
            <slot name="start"></slot>
            <slot name="title">${(x) => x.title}</slot>
            <slot name="end"></slot>
        </summary>
        <div id="disclosure-content"><slot></slot></div>
    </details>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/disclosure/disclosure.js
var Disclosure;
var init_disclosure = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/disclosure/disclosure.js"() {
    init_tslib_es6();
    init_esm();
    init_foundation_element();
    Disclosure = class extends FoundationElement {
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.setup();
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.details.removeEventListener("toggle", this.onToggle);
      }
      /**
       * Show extra content.
       */
      show() {
        this.details.open = true;
      }
      /**
       * Hide extra content.
       */
      hide() {
        this.details.open = false;
      }
      /**
       * Toggle the current(expanded/collapsed) state.
       */
      toggle() {
        this.details.open = !this.details.open;
      }
      /**
       * Register listener and set default disclosure mode
       */
      setup() {
        this.onToggle = this.onToggle.bind(this);
        this.details.addEventListener("toggle", this.onToggle);
        if (this.expanded) {
          this.show();
        }
      }
      /**
       * Update the aria attr and fire `toggle` event
       */
      onToggle() {
        this.expanded = this.details.open;
        this.$emit("toggle");
      }
    };
    __decorate([
      attr({ mode: "boolean" })
    ], Disclosure.prototype, "expanded", void 0);
    __decorate([
      attr
    ], Disclosure.prototype, "title", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/disclosure/index.js
var init_disclosure2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/disclosure/index.js"() {
    init_disclosure_template();
    init_disclosure();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/divider/divider.template.js
var dividerTemplate;
var init_divider_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/divider/divider.template.js"() {
    init_esm();
    dividerTemplate = (context, definition) => html`
    <template role="${(x) => x.role}" aria-orientation="${(x) => x.orientation}"></template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/divider/divider.options.js
var DividerRole;
var init_divider_options = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/divider/divider.options.js"() {
    DividerRole = {
      /**
       * The divider semantically separates content
       */
      separator: "separator",
      /**
       * The divider has no semantic value and is for visual presentation only.
       */
      presentation: "presentation"
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/divider/divider.js
var Divider;
var init_divider = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/divider/divider.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_foundation_element();
    init_divider_options();
    Divider = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.role = DividerRole.separator;
        this.orientation = Orientation.horizontal;
      }
    };
    __decorate([
      attr
    ], Divider.prototype, "role", void 0);
    __decorate([
      attr
    ], Divider.prototype, "orientation", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/divider/index.js
var init_divider2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/divider/index.js"() {
    init_divider_template();
    init_divider();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/flipper/flipper.options.js
var FlipperDirection;
var init_flipper_options = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/flipper/flipper.options.js"() {
    FlipperDirection = {
      next: "next",
      previous: "previous"
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/flipper/flipper.template.js
var init_flipper_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/flipper/flipper.template.js"() {
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/flipper/flipper.js
var Flipper;
var init_flipper = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/flipper/flipper.js"() {
    init_tslib_es6();
    init_esm();
    init_foundation_element();
    init_flipper_options();
    Flipper = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.hiddenFromAT = true;
        this.direction = FlipperDirection.next;
      }
      /**
       * Simulate a click event when the flipper has focus and the user hits enter or space keys
       * Blur focus if the user hits escape key
       * @param e - Keyboard event
       * @public
       */
      keyupHandler(e) {
        if (!this.hiddenFromAT) {
          const key2 = e.key;
          if (key2 === "Enter" || key2 === "Space") {
            this.$emit("click", e);
          }
          if (key2 === "Escape") {
            this.blur();
          }
        }
      }
    };
    __decorate([
      attr({ mode: "boolean" })
    ], Flipper.prototype, "disabled", void 0);
    __decorate([
      attr({ attribute: "aria-hidden", converter: booleanConverter })
    ], Flipper.prototype, "hiddenFromAT", void 0);
    __decorate([
      attr
    ], Flipper.prototype, "direction", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/flipper/index.js
var init_flipper2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/flipper/index.js"() {
    init_flipper_template();
    init_flipper();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/form-associated/index.js
var init_form_associated2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/form-associated/index.js"() {
    init_form_associated();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/foundation-element/index.js
var init_foundation_element2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/foundation-element/index.js"() {
    init_foundation_element();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/listbox-option/listbox-option.template.js
var listboxOptionTemplate;
var init_listbox_option_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/listbox-option/listbox-option.template.js"() {
    init_esm();
    init_start_end();
    listboxOptionTemplate = (context, definition) => html`
    <template
        aria-checked="${(x) => x.ariaChecked}"
        aria-disabled="${(x) => x.ariaDisabled}"
        aria-posinset="${(x) => x.ariaPosInSet}"
        aria-selected="${(x) => x.ariaSelected}"
        aria-setsize="${(x) => x.ariaSetSize}"
        class="${(x) => [x.checked && "checked", x.selected && "selected", x.disabled && "disabled"].filter(Boolean).join(" ")}"
        role="option"
    >
        ${startSlotTemplate(context, definition)}
        <span class="content" part="content">
            <slot ${slotted("content")}></slot>
        </span>
        ${endSlotTemplate(context, definition)}
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/listbox-option/index.js
var init_listbox_option2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/listbox-option/index.js"() {
    init_listbox_option();
    init_listbox_option_template();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/listbox/listbox.element.js
var ListboxElement;
var init_listbox_element = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/listbox/listbox.element.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_listbox();
    ListboxElement = class extends Listbox {
      constructor() {
        super(...arguments);
        this.activeIndex = -1;
        this.rangeStartIndex = -1;
      }
      /**
       * Returns the last checked option.
       *
       * @internal
       */
      get activeOption() {
        return this.options[this.activeIndex];
      }
      /**
       * Returns the list of checked options.
       *
       * @internal
       */
      get checkedOptions() {
        var _a;
        return (_a = this.options) === null || _a === void 0 ? void 0 : _a.filter((o) => o.checked);
      }
      /**
       * Returns the index of the first selected option.
       *
       * @internal
       */
      get firstSelectedOptionIndex() {
        return this.options.indexOf(this.firstSelectedOption);
      }
      /**
       * Updates the `ariaActiveDescendant` property when the active index changes.
       *
       * @param prev - the previous active index
       * @param next - the next active index
       *
       * @internal
       */
      activeIndexChanged(prev, next) {
        var _a, _b;
        this.ariaActiveDescendant = (_b = (_a = this.options[next]) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : "";
        this.focusAndScrollOptionIntoView();
      }
      /**
       * Toggles the checked state for the currently active option.
       *
       * @remarks
       * Multiple-selection mode only.
       *
       * @internal
       */
      checkActiveIndex() {
        if (!this.multiple) {
          return;
        }
        const activeItem = this.activeOption;
        if (activeItem) {
          activeItem.checked = true;
        }
      }
      /**
       * Sets the active index to the first option and marks it as checked.
       *
       * @remarks
       * Multi-selection mode only.
       *
       * @param preserveChecked - mark all options unchecked before changing the active index
       *
       * @internal
       */
      checkFirstOption(preserveChecked = false) {
        if (preserveChecked) {
          if (this.rangeStartIndex === -1) {
            this.rangeStartIndex = this.activeIndex + 1;
          }
          this.options.forEach((o, i) => {
            o.checked = inRange(i, this.rangeStartIndex);
          });
        } else {
          this.uncheckAllOptions();
        }
        this.activeIndex = 0;
        this.checkActiveIndex();
      }
      /**
       * Decrements the active index and sets the matching option as checked.
       *
       * @remarks
       * Multi-selection mode only.
       *
       * @param preserveChecked - mark all options unchecked before changing the active index
       *
       * @internal
       */
      checkLastOption(preserveChecked = false) {
        if (preserveChecked) {
          if (this.rangeStartIndex === -1) {
            this.rangeStartIndex = this.activeIndex;
          }
          this.options.forEach((o, i) => {
            o.checked = inRange(i, this.rangeStartIndex, this.options.length);
          });
        } else {
          this.uncheckAllOptions();
        }
        this.activeIndex = this.options.length - 1;
        this.checkActiveIndex();
      }
      /**
       * @override
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.addEventListener("focusout", this.focusoutHandler);
      }
      /**
       * @override
       * @internal
       */
      disconnectedCallback() {
        this.removeEventListener("focusout", this.focusoutHandler);
        super.disconnectedCallback();
      }
      /**
       * Increments the active index and marks the matching option as checked.
       *
       * @remarks
       * Multiple-selection mode only.
       *
       * @param preserveChecked - mark all options unchecked before changing the active index
       *
       * @internal
       */
      checkNextOption(preserveChecked = false) {
        if (preserveChecked) {
          if (this.rangeStartIndex === -1) {
            this.rangeStartIndex = this.activeIndex;
          }
          this.options.forEach((o, i) => {
            o.checked = inRange(i, this.rangeStartIndex, this.activeIndex + 1);
          });
        } else {
          this.uncheckAllOptions();
        }
        this.activeIndex += this.activeIndex < this.options.length - 1 ? 1 : 0;
        this.checkActiveIndex();
      }
      /**
       * Decrements the active index and marks the matching option as checked.
       *
       * @remarks
       * Multiple-selection mode only.
       *
       * @param preserveChecked - mark all options unchecked before changing the active index
       *
       * @internal
       */
      checkPreviousOption(preserveChecked = false) {
        if (preserveChecked) {
          if (this.rangeStartIndex === -1) {
            this.rangeStartIndex = this.activeIndex;
          }
          if (this.checkedOptions.length === 1) {
            this.rangeStartIndex += 1;
          }
          this.options.forEach((o, i) => {
            o.checked = inRange(i, this.activeIndex, this.rangeStartIndex);
          });
        } else {
          this.uncheckAllOptions();
        }
        this.activeIndex -= this.activeIndex > 0 ? 1 : 0;
        this.checkActiveIndex();
      }
      /**
       * Handles click events for listbox options.
       *
       * @param e - the event object
       *
       * @override
       * @internal
       */
      clickHandler(e) {
        var _a;
        if (!this.multiple) {
          return super.clickHandler(e);
        }
        const captured = (_a = e.target) === null || _a === void 0 ? void 0 : _a.closest(`[role=option]`);
        if (!captured || captured.disabled) {
          return;
        }
        this.uncheckAllOptions();
        this.activeIndex = this.options.indexOf(captured);
        this.checkActiveIndex();
        this.toggleSelectedForAllCheckedOptions();
        return true;
      }
      /**
       * @override
       * @internal
       */
      focusAndScrollOptionIntoView() {
        super.focusAndScrollOptionIntoView(this.activeOption);
      }
      /**
       * In multiple-selection mode:
       * If any options are selected, the first selected option is checked when
       * the listbox receives focus. If no options are selected, the first
       * selectable option is checked.
       *
       * @override
       * @internal
       */
      focusinHandler(e) {
        if (!this.multiple) {
          return super.focusinHandler(e);
        }
        if (!this.shouldSkipFocus && e.target === e.currentTarget) {
          this.uncheckAllOptions();
          if (this.activeIndex === -1) {
            this.activeIndex = this.firstSelectedOptionIndex !== -1 ? this.firstSelectedOptionIndex : 0;
          }
          this.checkActiveIndex();
          this.setSelectedOptions();
          this.focusAndScrollOptionIntoView();
        }
        this.shouldSkipFocus = false;
      }
      /**
       * Unchecks all options when the listbox loses focus.
       *
       * @internal
       */
      focusoutHandler(e) {
        if (this.multiple) {
          this.uncheckAllOptions();
        }
      }
      /**
       * Handles keydown actions for listbox navigation and typeahead
       *
       * @override
       * @internal
       */
      keydownHandler(e) {
        if (!this.multiple) {
          return super.keydownHandler(e);
        }
        if (this.disabled) {
          return true;
        }
        const { key: key2, shiftKey } = e;
        this.shouldSkipFocus = false;
        switch (key2) {
          case keyHome: {
            this.checkFirstOption(shiftKey);
            return;
          }
          case keyArrowDown: {
            this.checkNextOption(shiftKey);
            return;
          }
          case keyArrowUp: {
            this.checkPreviousOption(shiftKey);
            return;
          }
          case keyEnd: {
            this.checkLastOption(shiftKey);
            return;
          }
          case keyTab: {
            this.focusAndScrollOptionIntoView();
            return true;
          }
          case keyEscape: {
            this.uncheckAllOptions();
            this.checkActiveIndex();
            return true;
          }
          case keySpace: {
            e.preventDefault();
            if (this.typeAheadExpired) {
              this.toggleSelectedForAllCheckedOptions();
              return;
            }
          }
          default: {
            if (key2.length === 1) {
              this.handleTypeAhead(`${key2}`);
            }
            return true;
          }
        }
      }
      /**
       * Prevents `focusin` events from firing before `click` events when the
       * element is unfocused.
       *
       * @override
       * @internal
       */
      mousedownHandler(e) {
        if (e.offsetX >= 0 && e.offsetX <= this.scrollWidth) {
          return super.mousedownHandler(e);
        }
      }
      /**
       * Switches between single-selection and multi-selection mode.
       *
       * @internal
       */
      multipleChanged(prev, next) {
        var _a;
        this.ariaMultiSelectable = next ? "true" : null;
        (_a = this.options) === null || _a === void 0 ? void 0 : _a.forEach((o) => {
          o.checked = next ? false : void 0;
        });
        this.setSelectedOptions();
      }
      /**
       * Sets an option as selected and gives it focus.
       *
       * @override
       * @public
       */
      setSelectedOptions() {
        if (!this.multiple) {
          super.setSelectedOptions();
          return;
        }
        if (this.$fastController.isConnected && this.options) {
          this.selectedOptions = this.options.filter((o) => o.selected);
          this.focusAndScrollOptionIntoView();
        }
      }
      /**
       * Ensures the size is a positive integer when the property is updated.
       *
       * @param prev - the previous size value
       * @param next - the current size value
       *
       * @internal
       */
      sizeChanged(prev, next) {
        var _a;
        const size = Math.max(0, parseInt((_a = next === null || next === void 0 ? void 0 : next.toFixed()) !== null && _a !== void 0 ? _a : "", 10));
        if (size !== next) {
          DOM.queueUpdate(() => {
            this.size = size;
          });
        }
      }
      /**
       * Toggles the selected state of the provided options. If any provided items
       * are in an unselected state, all items are set to selected. If every
       * provided item is selected, they are all unselected.
       *
       * @internal
       */
      toggleSelectedForAllCheckedOptions() {
        const enabledCheckedOptions = this.checkedOptions.filter((o) => !o.disabled);
        const force = !enabledCheckedOptions.every((o) => o.selected);
        enabledCheckedOptions.forEach((o) => o.selected = force);
        this.selectedIndex = this.options.indexOf(enabledCheckedOptions[enabledCheckedOptions.length - 1]);
        this.setSelectedOptions();
      }
      /**
       * @override
       * @internal
       */
      typeaheadBufferChanged(prev, next) {
        if (!this.multiple) {
          super.typeaheadBufferChanged(prev, next);
          return;
        }
        if (this.$fastController.isConnected) {
          const typeaheadMatches = this.getTypeaheadMatches();
          const activeIndex = this.options.indexOf(typeaheadMatches[0]);
          if (activeIndex > -1) {
            this.activeIndex = activeIndex;
            this.uncheckAllOptions();
            this.checkActiveIndex();
          }
          this.typeAheadExpired = false;
        }
      }
      /**
       * Unchecks all options.
       *
       * @remarks
       * Multiple-selection mode only.
       *
       * @param preserveChecked - reset the rangeStartIndex
       *
       * @internal
       */
      uncheckAllOptions(preserveChecked = false) {
        this.options.forEach((o) => o.checked = this.multiple ? false : void 0);
        if (!preserveChecked) {
          this.rangeStartIndex = -1;
        }
      }
    };
    __decorate([
      observable
    ], ListboxElement.prototype, "activeIndex", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], ListboxElement.prototype, "multiple", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], ListboxElement.prototype, "size", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/listbox/listbox.template.js
var listboxTemplate;
var init_listbox_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/listbox/listbox.template.js"() {
    init_esm();
    init_listbox_element();
    listboxTemplate = (context, definition) => html`
    <template
        aria-activedescendant="${(x) => x.ariaActiveDescendant}"
        aria-multiselectable="${(x) => x.ariaMultiSelectable}"
        class="listbox"
        role="listbox"
        tabindex="${(x) => !x.disabled ? "0" : null}"
        @click="${(x, c) => x.clickHandler(c.event)}"
        @focusin="${(x, c) => x.focusinHandler(c.event)}"
        @keydown="${(x, c) => x.keydownHandler(c.event)}"
        @mousedown="${(x, c) => x.mousedownHandler(c.event)}"
    >
        <slot
            ${slotted({
      filter: ListboxElement.slottedOptionFilter,
      flatten: true,
      property: "slottedOptions"
    })}
        ></slot>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/listbox/index.js
var init_listbox2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/listbox/index.js"() {
    init_listbox();
    init_listbox_element();
    init_listbox_template();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu.js
var PickerMenu;
var init_picker_menu = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu.js"() {
    init_tslib_es6();
    init_dist4();
    init_esm();
    init_foundation_element();
    PickerMenu = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.optionElements = [];
      }
      menuElementsChanged() {
        this.updateOptions();
      }
      headerElementsChanged() {
        this.updateOptions();
      }
      footerElementsChanged() {
        this.updateOptions();
      }
      updateOptions() {
        this.optionElements.splice(0, this.optionElements.length);
        this.addSlottedListItems(this.headerElements);
        this.addSlottedListItems(this.menuElements);
        this.addSlottedListItems(this.footerElements);
        this.$emit("optionsupdated", { bubbles: false });
      }
      addSlottedListItems(slotChildren) {
        if (slotChildren === void 0) {
          return;
        }
        slotChildren.forEach((child) => {
          if (child.nodeType === 1 && child.getAttribute("role") === "listitem") {
            child.id = child.id || uniqueId2("option-");
            this.optionElements.push(child);
          }
        });
      }
    };
    __decorate([
      observable
    ], PickerMenu.prototype, "menuElements", void 0);
    __decorate([
      observable
    ], PickerMenu.prototype, "headerElements", void 0);
    __decorate([
      observable
    ], PickerMenu.prototype, "footerElements", void 0);
    __decorate([
      observable
    ], PickerMenu.prototype, "suggestionsAvailableText", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu-option.js
var defaultContentsTemplate, PickerMenuOption;
var init_picker_menu_option = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu-option.js"() {
    init_tslib_es6();
    init_esm();
    init_foundation_element();
    defaultContentsTemplate = html`
    <template>
        ${(x) => x.value}
    </template>
`;
    PickerMenuOption = class extends FoundationElement {
      contentsTemplateChanged() {
        if (this.$fastController.isConnected) {
          this.updateView();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.updateView();
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.disconnectView();
      }
      handleClick(e) {
        if (e.defaultPrevented) {
          return false;
        }
        this.handleInvoked();
        return false;
      }
      handleInvoked() {
        this.$emit("pickeroptioninvoked");
      }
      updateView() {
        var _a, _b;
        this.disconnectView();
        this.customView = (_b = (_a = this.contentsTemplate) === null || _a === void 0 ? void 0 : _a.render(this, this)) !== null && _b !== void 0 ? _b : defaultContentsTemplate.render(this, this);
      }
      disconnectView() {
        var _a;
        (_a = this.customView) === null || _a === void 0 ? void 0 : _a.dispose();
        this.customView = void 0;
      }
    };
    __decorate([
      attr({ attribute: "value" })
    ], PickerMenuOption.prototype, "value", void 0);
    __decorate([
      observable
    ], PickerMenuOption.prototype, "contentsTemplate", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list.js
var PickerList;
var init_picker_list = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list.js"() {
    init_foundation_element();
    PickerList = class extends FoundationElement {
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list-item.js
var defaultContentsTemplate2, PickerListItem;
var init_picker_list_item = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list-item.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_foundation_element();
    defaultContentsTemplate2 = html`
    <template>
        ${(x) => x.value}
    </template>
`;
    PickerListItem = class extends FoundationElement {
      contentsTemplateChanged() {
        if (this.$fastController.isConnected) {
          this.updateView();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.updateView();
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        this.disconnectView();
        super.disconnectedCallback();
      }
      handleKeyDown(e) {
        if (e.defaultPrevented) {
          return false;
        }
        if (e.key === keyEnter) {
          this.handleInvoke();
          return false;
        }
        return true;
      }
      handleClick(e) {
        if (!e.defaultPrevented) {
          this.handleInvoke();
        }
        return false;
      }
      handleInvoke() {
        this.$emit("pickeriteminvoked");
      }
      updateView() {
        var _a, _b;
        this.disconnectView();
        this.customView = (_b = (_a = this.contentsTemplate) === null || _a === void 0 ? void 0 : _a.render(this, this)) !== null && _b !== void 0 ? _b : defaultContentsTemplate2.render(this, this);
      }
      disconnectView() {
        var _a;
        (_a = this.customView) === null || _a === void 0 ? void 0 : _a.dispose();
        this.customView = void 0;
      }
    };
    __decorate([
      attr({ attribute: "value" })
    ], PickerListItem.prototype, "value", void 0);
    __decorate([
      observable
    ], PickerListItem.prototype, "contentsTemplate", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker.template.js
function createDefaultListItemTemplate(context) {
  const pickerListItemTag = context.tagFor(PickerListItem);
  return html`
    <${pickerListItemTag}
        value="${(x) => x}"
        :contentsTemplate="${(x, c) => c.parent.listItemContentsTemplate}"
    >
    </${pickerListItemTag}>
    `;
}
function createDefaultMenuOptionTemplate(context) {
  const pickerMenuOptionTag = context.tagFor(PickerMenuOption);
  return html`
    <${pickerMenuOptionTag}
        value="${(x) => x}"
        :contentsTemplate="${(x, c) => c.parent.menuOptionContentsTemplate}"
    >
    </${pickerMenuOptionTag}>
    `;
}
var pickerTemplate;
var init_picker_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker.template.js"() {
    init_esm();
    init_anchored_region();
    init_picker_menu();
    init_picker_menu_option();
    init_picker_list();
    init_picker_list_item();
    pickerTemplate = (context, definition) => {
      const anchoredRegionTag = context.tagFor(AnchoredRegion);
      const pickerMenuTag = context.tagFor(PickerMenu);
      const pickerListTag = context.tagFor(PickerList);
      const progressRingTag = context.tagFor(PickerList);
      const defaultListItemTemplate = createDefaultListItemTemplate(context);
      const defaultMenuOptionTemplate = createDefaultMenuOptionTemplate(context);
      return html`
        <template
            :selectedListTag="${() => pickerListTag}"
            :menuTag="${() => pickerMenuTag}"
            :defaultListItemTemplate="${defaultListItemTemplate}"
            :defaultMenuOptionTemplate="${defaultMenuOptionTemplate}"
            @focusin="${(x, c) => x.handleFocusIn(c.event)}"
            @focusout="${(x, c) => x.handleFocusOut(c.event)}"
            @keydown="${(x, c) => x.handleKeyDown(c.event)}"
            @pickeriteminvoked="${(x, c) => x.handleItemInvoke(c.event)}"
            @pickeroptioninvoked="${(x, c) => x.handleOptionInvoke(c.event)}"
        >
            <slot name="list-region"></slot>

            ${when((x) => x.flyoutOpen, html`
                <${anchoredRegionTag}
                    class="region"
                    part="region"
                    auto-update-mode="${(x) => x.menuConfig.autoUpdateMode}"
                    fixed-placement="${(x) => x.menuConfig.fixedPlacement}"
                    vertical-positioning-mode="${(x) => x.menuConfig.verticalPositioningMode}"
                    vertical-default-position="${(x) => x.menuConfig.verticalDefaultPosition}"
                    vertical-scaling="${(x) => x.menuConfig.verticalScaling}"
                    vertical-inset="${(x) => x.menuConfig.verticalInset}"
                    vertical-viewport-lock="${(x) => x.menuConfig.verticalViewportLock}"
                    horizontal-positioning-mode="${(x) => x.menuConfig.horizontalPositioningMode}"
                    horizontal-default-position="${(x) => x.menuConfig.horizontalDefaultPosition}"
                    horizontal-scaling="${(x) => x.menuConfig.horizontalScaling}"
                    horizontal-inset="${(x) => x.menuConfig.horizontalInset}"
                    horizontal-viewport-lock="${(x) => x.menuConfig.horizontalViewportLock}"
                    @loaded="${(x, c) => x.handleRegionLoaded(c.event)}"
                    ${ref("region")}
                >
                    ${when((x) => !x.showNoOptions && !x.showLoading, html`
                            <slot name="menu-region"></slot>
                        `)}
                    ${when((x) => x.showNoOptions && !x.showLoading, html`
                            <div class="no-options-display" part="no-options-display">
                                <slot name="no-options-region">
                                    ${(x) => x.noSuggestionsText}
                                </slot>
                            </div>
                        `)}
                    ${when((x) => x.showLoading, html`
                            <div class="loading-display" part="loading-display">
                                <slot name="loading-region">
                                    <${progressRingTag}
                                        part="loading-progress"
                                        class="loading-progress
                                        slot="loading-region"
                                    ></${progressRingTag}>
                                        ${(x) => x.loadingText}
                                </slot>
                            </div>
                        `)}
                </${anchoredRegionTag}>
            `)}
        </template>
    `;
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker.form-associated.js
var _Picker, FormAssociatedPicker;
var init_picker_form_associated = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _Picker = class extends FoundationElement {
    };
    FormAssociatedPicker = class extends FormAssociated(_Picker) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker.js
var pickerInputTemplate, Picker;
var init_picker = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_anchored_region2();
    init_picker_menu_option();
    init_picker_list_item();
    init_picker_form_associated();
    pickerInputTemplate = html`
    <input
        slot="input-region"
        role="combobox"
        type="text"
        autocapitalize="off"
        autocomplete="off"
        haspopup="list"
        aria-label="${(x) => x.label}"
        aria-labelledby="${(x) => x.labelledBy}"
        placeholder="${(x) => x.placeholder}"
        ${ref("inputElement")}
    ></input>
`;
    Picker = class extends FormAssociatedPicker {
      constructor() {
        super(...arguments);
        this.selection = "";
        this.filterSelected = true;
        this.filterQuery = true;
        this.noSuggestionsText = "No suggestions available";
        this.suggestionsAvailableText = "Suggestions available";
        this.loadingText = "Loading suggestions";
        this.menuPlacement = "bottom-fill";
        this.showLoading = false;
        this.optionsList = [];
        this.filteredOptionsList = [];
        this.flyoutOpen = false;
        this.menuFocusIndex = -1;
        this.showNoOptions = false;
        this.selectedItems = [];
        this.inputElementView = null;
        this.handleTextInput = (e) => {
          this.query = this.inputElement.value;
        };
        this.handleInputClick = (e) => {
          e.preventDefault();
          this.toggleFlyout(true);
        };
        this.setRegionProps = () => {
          if (!this.flyoutOpen) {
            return;
          }
          if (this.region === null || this.region === void 0) {
            DOM.queueUpdate(this.setRegionProps);
            return;
          }
          this.region.anchorElement = this.inputElement;
        };
        this.configLookup = {
          top: FlyoutPosTop,
          bottom: FlyoutPosBottom,
          tallest: FlyoutPosTallest,
          "top-fill": FlyoutPosTopFill,
          "bottom-fill": FlyoutPosBottomFill,
          "tallest-fill": FlyoutPosTallestFill
        };
      }
      selectionChanged() {
        if (this.$fastController.isConnected) {
          this.handleSelectionChange();
          if (this.proxy instanceof HTMLInputElement) {
            this.proxy.value = this.selection;
            this.validate();
          }
        }
      }
      optionsChanged() {
        this.optionsList = this.options.split(",").map((opt) => opt.trim()).filter((opt) => opt !== "");
      }
      menuPlacementChanged() {
        if (this.$fastController.isConnected) {
          this.updateMenuConfig();
        }
      }
      showLoadingChanged() {
        if (this.$fastController.isConnected) {
          DOM.queueUpdate(() => {
            this.setFocusedOption(0);
          });
        }
      }
      listItemTemplateChanged() {
        this.updateListItemTemplate();
      }
      defaultListItemTemplateChanged() {
        this.updateListItemTemplate();
      }
      menuOptionTemplateChanged() {
        this.updateOptionTemplate();
      }
      defaultMenuOptionTemplateChanged() {
        this.updateOptionTemplate();
      }
      optionsListChanged() {
        this.updateFilteredOptions();
      }
      queryChanged() {
        if (this.$fastController.isConnected) {
          if (this.inputElement.value !== this.query) {
            this.inputElement.value = this.query;
          }
          this.updateFilteredOptions();
          this.$emit("querychange", { bubbles: false });
        }
      }
      filteredOptionsListChanged() {
        if (this.$fastController.isConnected) {
          this.showNoOptions = this.filteredOptionsList.length === 0 && this.menuElement.querySelectorAll('[role="listitem"]').length === 0;
          this.setFocusedOption(this.showNoOptions ? -1 : 0);
        }
      }
      flyoutOpenChanged() {
        if (this.flyoutOpen) {
          DOM.queueUpdate(this.setRegionProps);
          this.$emit("menuopening", { bubbles: false });
        } else {
          this.$emit("menuclosing", { bubbles: false });
        }
      }
      showNoOptionsChanged() {
        if (this.$fastController.isConnected) {
          DOM.queueUpdate(() => {
            this.setFocusedOption(0);
          });
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.listElement = document.createElement(this.selectedListTag);
        this.appendChild(this.listElement);
        this.itemsPlaceholderElement = document.createComment("");
        this.listElement.append(this.itemsPlaceholderElement);
        this.inputElementView = pickerInputTemplate.render(this, this.listElement);
        const match = this.menuTag.toUpperCase();
        this.menuElement = Array.from(this.children).find((element) => {
          return element.tagName === match;
        });
        if (this.menuElement === void 0) {
          this.menuElement = document.createElement(this.menuTag);
          this.appendChild(this.menuElement);
        }
        if (this.menuElement.id === "") {
          this.menuElement.id = uniqueId2("listbox-");
        }
        this.menuId = this.menuElement.id;
        this.optionsPlaceholder = document.createComment("");
        this.menuElement.append(this.optionsPlaceholder);
        this.updateMenuConfig();
        DOM.queueUpdate(() => this.initialize());
      }
      disconnectedCallback() {
        super.disconnectedCallback();
        this.toggleFlyout(false);
        this.inputElement.removeEventListener("input", this.handleTextInput);
        this.inputElement.removeEventListener("click", this.handleInputClick);
        if (this.inputElementView !== null) {
          this.inputElementView.dispose();
          this.inputElementView = null;
        }
      }
      /**
       * Move focus to the input element
       * @public
       */
      focus() {
        this.inputElement.focus();
      }
      /**
       * Initialize the component.  This is delayed a frame to ensure children are connected as well.
       */
      initialize() {
        this.updateListItemTemplate();
        this.updateOptionTemplate();
        this.itemsRepeatBehavior = new RepeatDirective((x) => x.selectedItems, (x) => x.activeListItemTemplate, { positioning: true }).createBehavior(this.itemsPlaceholderElement);
        this.inputElement.addEventListener("input", this.handleTextInput);
        this.inputElement.addEventListener("click", this.handleInputClick);
        this.$fastController.addBehaviors([this.itemsRepeatBehavior]);
        this.menuElement.suggestionsAvailableText = this.suggestionsAvailableText;
        this.menuElement.addEventListener("optionsupdated", this.handleMenuOptionsUpdated);
        this.optionsRepeatBehavior = new RepeatDirective((x) => x.filteredOptionsList, (x) => x.activeMenuOptionTemplate, { positioning: true }).createBehavior(this.optionsPlaceholder);
        this.$fastController.addBehaviors([this.optionsRepeatBehavior]);
        this.handleSelectionChange();
      }
      /**
       * Toggles the menu flyout
       */
      toggleFlyout(open) {
        if (this.flyoutOpen === open) {
          return;
        }
        if (open && document.activeElement === this.inputElement) {
          this.flyoutOpen = open;
          DOM.queueUpdate(() => {
            if (this.menuElement !== void 0) {
              this.setFocusedOption(0);
            } else {
              this.disableMenu();
            }
          });
          return;
        }
        this.flyoutOpen = false;
        this.disableMenu();
        return;
      }
      /**
       * Handle the menu options updated event from the child menu
       */
      handleMenuOptionsUpdated(e) {
        e.preventDefault();
        if (this.flyoutOpen) {
          this.setFocusedOption(0);
        }
      }
      /**
       * Handle key down events.
       */
      handleKeyDown(e) {
        if (e.defaultPrevented) {
          return false;
        }
        switch (e.key) {
          case keyArrowDown: {
            if (!this.flyoutOpen) {
              this.toggleFlyout(true);
            } else {
              const nextFocusOptionIndex = this.flyoutOpen ? Math.min(this.menuFocusIndex + 1, this.menuElement.optionElements.length - 1) : 0;
              this.setFocusedOption(nextFocusOptionIndex);
            }
            return false;
          }
          case keyArrowUp: {
            if (!this.flyoutOpen) {
              this.toggleFlyout(true);
            } else {
              const previousFocusOptionIndex = this.flyoutOpen ? Math.max(this.menuFocusIndex - 1, 0) : 0;
              this.setFocusedOption(previousFocusOptionIndex);
            }
            return false;
          }
          case keyEscape: {
            this.toggleFlyout(false);
            return false;
          }
          case keyEnter: {
            if (this.menuFocusIndex !== -1 && this.menuElement.optionElements.length > this.menuFocusIndex) {
              this.menuElement.optionElements[this.menuFocusIndex].click();
            }
            return false;
          }
          case keyArrowRight: {
            if (document.activeElement !== this.inputElement) {
              this.incrementFocusedItem(1);
              return false;
            }
            return true;
          }
          case keyArrowLeft: {
            if (this.inputElement.selectionStart === 0) {
              this.incrementFocusedItem(-1);
              return false;
            }
            return true;
          }
          case keyDelete:
          case keyBackspace: {
            if (document.activeElement === null) {
              return true;
            }
            if (document.activeElement === this.inputElement) {
              if (this.inputElement.selectionStart === 0) {
                this.selection = this.selectedItems.slice(0, this.selectedItems.length - 1).toString();
                this.toggleFlyout(false);
                return false;
              }
              return true;
            }
            const selectedItems = Array.from(this.listElement.children);
            const currentFocusedItemIndex = selectedItems.indexOf(document.activeElement);
            if (currentFocusedItemIndex > -1) {
              this.selection = this.selectedItems.splice(currentFocusedItemIndex, 1).toString();
              DOM.queueUpdate(() => {
                selectedItems[Math.min(selectedItems.length, currentFocusedItemIndex)].focus();
              });
              return false;
            }
            return true;
          }
        }
        this.toggleFlyout(true);
        return true;
      }
      /**
       * Handle focus in events.
       */
      handleFocusIn(e) {
        return false;
      }
      /**
       * Handle focus out events.
       */
      handleFocusOut(e) {
        if (this.menuElement === void 0 || !this.menuElement.contains(e.relatedTarget)) {
          this.toggleFlyout(false);
        }
        return false;
      }
      /**
       * The list of selected items has changed
       */
      handleSelectionChange() {
        if (this.selectedItems.toString() === this.selection) {
          return;
        }
        this.selectedItems = this.selection === "" ? [] : this.selection.split(",");
        this.updateFilteredOptions();
        DOM.queueUpdate(() => {
          this.checkMaxItems();
        });
        this.$emit("selectionchange", { bubbles: false });
      }
      /**
       * Anchored region is loaded, menu and options exist in the DOM.
       */
      handleRegionLoaded(e) {
        DOM.queueUpdate(() => {
          this.setFocusedOption(0);
          this.$emit("menuloaded", { bubbles: false });
        });
      }
      /**
       * Checks if the maximum number of items has been chosen and updates the ui.
       */
      checkMaxItems() {
        if (this.inputElement === void 0) {
          return;
        }
        if (this.maxSelected !== void 0 && this.selectedItems.length >= this.maxSelected) {
          if (document.activeElement === this.inputElement) {
            const selectedItemInstances = Array.from(this.listElement.querySelectorAll("[role='listitem']"));
            selectedItemInstances[selectedItemInstances.length - 1].focus();
          }
          this.inputElement.hidden = true;
        } else {
          this.inputElement.hidden = false;
        }
      }
      /**
       * A list item has been invoked.
       */
      handleItemInvoke(e) {
        if (e.defaultPrevented) {
          return false;
        }
        if (e.target instanceof PickerListItem) {
          const listItems = Array.from(this.listElement.querySelectorAll("[role='listitem']"));
          const itemIndex = listItems.indexOf(e.target);
          if (itemIndex !== -1) {
            const newSelection = this.selectedItems.slice();
            newSelection.splice(itemIndex, 1);
            this.selection = newSelection.toString();
            DOM.queueUpdate(() => this.incrementFocusedItem(0));
          }
          return false;
        }
        return true;
      }
      /**
       * A menu option has been invoked.
       */
      handleOptionInvoke(e) {
        if (e.defaultPrevented) {
          return false;
        }
        if (e.target instanceof PickerMenuOption) {
          if (e.target.value !== void 0) {
            this.selection = `${this.selection}${this.selection === "" ? "" : ","}${e.target.value}`;
          }
          this.inputElement.value = "";
          this.query = "";
          this.inputElement.focus();
          this.toggleFlyout(false);
          return false;
        }
        return true;
      }
      /**
       * Increments the focused list item by the specified amount
       */
      incrementFocusedItem(increment) {
        if (this.selectedItems.length === 0) {
          this.inputElement.focus();
          return;
        }
        const selectedItemsAsElements = Array.from(this.listElement.querySelectorAll("[role='listitem']"));
        if (document.activeElement !== null) {
          let currentFocusedItemIndex = selectedItemsAsElements.indexOf(document.activeElement);
          if (currentFocusedItemIndex === -1) {
            currentFocusedItemIndex = selectedItemsAsElements.length;
          }
          const newFocusedItemIndex = Math.min(selectedItemsAsElements.length, Math.max(0, currentFocusedItemIndex + increment));
          if (newFocusedItemIndex === selectedItemsAsElements.length) {
            if (this.maxSelected !== void 0 && this.selectedItems.length >= this.maxSelected) {
              selectedItemsAsElements[newFocusedItemIndex - 1].focus();
            } else {
              this.inputElement.focus();
            }
          } else {
            selectedItemsAsElements[newFocusedItemIndex].focus();
          }
        }
      }
      /**
       * Disables the menu. Note that the menu can be open, just doens't have any valid options on display.
       */
      disableMenu() {
        var _a, _b, _c;
        this.menuFocusIndex = -1;
        this.menuFocusOptionId = void 0;
        (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.removeAttribute("aria-activedescendant");
        (_b = this.inputElement) === null || _b === void 0 ? void 0 : _b.removeAttribute("aria-owns");
        (_c = this.inputElement) === null || _c === void 0 ? void 0 : _c.removeAttribute("aria-expanded");
      }
      /**
       * Sets the currently focused menu option by index
       */
      setFocusedOption(optionIndex) {
        if (!this.flyoutOpen || optionIndex === -1 || this.showNoOptions || this.showLoading) {
          this.disableMenu();
          return;
        }
        if (this.menuElement.optionElements.length === 0) {
          return;
        }
        this.menuElement.optionElements.forEach((element) => {
          element.setAttribute("aria-selected", "false");
        });
        this.menuFocusIndex = optionIndex;
        if (this.menuFocusIndex > this.menuElement.optionElements.length - 1) {
          this.menuFocusIndex = this.menuElement.optionElements.length - 1;
        }
        this.menuFocusOptionId = this.menuElement.optionElements[this.menuFocusIndex].id;
        this.inputElement.setAttribute("aria-owns", this.menuId);
        this.inputElement.setAttribute("aria-expanded", "true");
        this.inputElement.setAttribute("aria-activedescendant", this.menuFocusOptionId);
        const focusedOption = this.menuElement.optionElements[this.menuFocusIndex];
        focusedOption.setAttribute("aria-selected", "true");
        this.menuElement.scrollTo(0, focusedOption.offsetTop);
      }
      /**
       * Updates the template used for the list item repeat behavior
       */
      updateListItemTemplate() {
        var _a;
        this.activeListItemTemplate = (_a = this.listItemTemplate) !== null && _a !== void 0 ? _a : this.defaultListItemTemplate;
      }
      /**
       * Updates the template used for the menu option repeat behavior
       */
      updateOptionTemplate() {
        var _a;
        this.activeMenuOptionTemplate = (_a = this.menuOptionTemplate) !== null && _a !== void 0 ? _a : this.defaultMenuOptionTemplate;
      }
      /**
       * Updates the filtered options array
       */
      updateFilteredOptions() {
        this.filteredOptionsList = this.optionsList.slice(0);
        if (this.filterSelected) {
          this.filteredOptionsList = this.filteredOptionsList.filter((el) => this.selectedItems.indexOf(el) === -1);
        }
        if (this.filterQuery && this.query !== "" && this.query !== void 0) {
          this.filteredOptionsList = this.filteredOptionsList.filter((el) => el.indexOf(this.query) !== -1);
        }
      }
      /**
       * Updates the menu configuration
       */
      updateMenuConfig() {
        let newConfig = this.configLookup[this.menuPlacement];
        if (newConfig === null) {
          newConfig = FlyoutPosBottomFill;
        }
        this.menuConfig = Object.assign(Object.assign({}, newConfig), { autoUpdateMode: "auto", fixedPlacement: true, horizontalViewportLock: false, verticalViewportLock: false });
      }
    };
    __decorate([
      attr({ attribute: "selection" })
    ], Picker.prototype, "selection", void 0);
    __decorate([
      attr({ attribute: "options" })
    ], Picker.prototype, "options", void 0);
    __decorate([
      attr({ attribute: "filter-selected", mode: "boolean" })
    ], Picker.prototype, "filterSelected", void 0);
    __decorate([
      attr({ attribute: "filter-query", mode: "boolean" })
    ], Picker.prototype, "filterQuery", void 0);
    __decorate([
      attr({ attribute: "max-selected" })
    ], Picker.prototype, "maxSelected", void 0);
    __decorate([
      attr({ attribute: "no-suggestions-text" })
    ], Picker.prototype, "noSuggestionsText", void 0);
    __decorate([
      attr({ attribute: "suggestions-available-text" })
    ], Picker.prototype, "suggestionsAvailableText", void 0);
    __decorate([
      attr({ attribute: "loading-text" })
    ], Picker.prototype, "loadingText", void 0);
    __decorate([
      attr({ attribute: "label" })
    ], Picker.prototype, "label", void 0);
    __decorate([
      attr({ attribute: "labelledby" })
    ], Picker.prototype, "labelledBy", void 0);
    __decorate([
      attr({ attribute: "placeholder" })
    ], Picker.prototype, "placeholder", void 0);
    __decorate([
      attr({ attribute: "menu-placement" })
    ], Picker.prototype, "menuPlacement", void 0);
    __decorate([
      observable
    ], Picker.prototype, "showLoading", void 0);
    __decorate([
      observable
    ], Picker.prototype, "listItemTemplate", void 0);
    __decorate([
      observable
    ], Picker.prototype, "defaultListItemTemplate", void 0);
    __decorate([
      observable
    ], Picker.prototype, "activeListItemTemplate", void 0);
    __decorate([
      observable
    ], Picker.prototype, "menuOptionTemplate", void 0);
    __decorate([
      observable
    ], Picker.prototype, "defaultMenuOptionTemplate", void 0);
    __decorate([
      observable
    ], Picker.prototype, "activeMenuOptionTemplate", void 0);
    __decorate([
      observable
    ], Picker.prototype, "listItemContentsTemplate", void 0);
    __decorate([
      observable
    ], Picker.prototype, "menuOptionContentsTemplate", void 0);
    __decorate([
      observable
    ], Picker.prototype, "optionsList", void 0);
    __decorate([
      observable
    ], Picker.prototype, "query", void 0);
    __decorate([
      observable
    ], Picker.prototype, "filteredOptionsList", void 0);
    __decorate([
      observable
    ], Picker.prototype, "flyoutOpen", void 0);
    __decorate([
      observable
    ], Picker.prototype, "menuId", void 0);
    __decorate([
      observable
    ], Picker.prototype, "selectedListTag", void 0);
    __decorate([
      observable
    ], Picker.prototype, "menuTag", void 0);
    __decorate([
      observable
    ], Picker.prototype, "menuFocusIndex", void 0);
    __decorate([
      observable
    ], Picker.prototype, "menuFocusOptionId", void 0);
    __decorate([
      observable
    ], Picker.prototype, "showNoOptions", void 0);
    __decorate([
      observable
    ], Picker.prototype, "menuConfig", void 0);
    __decorate([
      observable
    ], Picker.prototype, "selectedItems", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu.template.js
var pickerMenuTemplate;
var init_picker_menu_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu.template.js"() {
    init_esm();
    pickerMenuTemplate = (context, definition) => {
      return html`
        <template role="list" slot="menu-region">
            <div class="options-display" part="options-display">
                <div class="header-region" part="header-region">
                    <slot name="header-region" ${slotted("headerElements")}></slot>
                </div>

                <slot ${slotted("menuElements")}></slot>
                <div class="footer-region" part="footer-region">
                    <slot name="footer-region" ${slotted("footerElements")}></slot>
                </div>
                <div
                    role="alert"
                    aria-live="polite"
                    part="suggestions-available-alert"
                    class="suggestions-available-alert"
                >
                    ${(x) => x.suggestionsAvailableText}
                </div>
            </div>
        </template>
    `;
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu-option.template.js
var pickerMenuOptionTemplate;
var init_picker_menu_option_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu-option.template.js"() {
    init_esm();
    pickerMenuOptionTemplate = (context, definition) => {
      return html`
        <template
            role="listitem"
            tabindex="-1"
            @click="${(x, c) => x.handleClick(c.event)}"
        >
            <slot></slot>
        </template>
    `;
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list.template.js
var pickerListTemplate;
var init_picker_list_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list.template.js"() {
    init_esm();
    pickerListTemplate = (context, definition) => {
      return html`
        <template slot="list-region" role="list" class="picker-list">
            <slot></slot>
            <slot name="input-region"></slot>
        </template>
    `;
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list-item.template.js
var pickerListItemTemplate;
var init_picker_list_item_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list-item.template.js"() {
    init_esm();
    pickerListItemTemplate = (context, definition) => {
      return html`
        <template
            role="listitem"
            tabindex="0"
            @click="${(x, c) => x.handleClick(c.event)}"
            @keydown="${(x, c) => x.handleKeyDown(c.event)}"
        >
            <slot></slot>
        </template>
    `;
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/picker/index.js
var init_picker2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/picker/index.js"() {
    init_picker_template();
    init_picker();
    init_picker_menu_template();
    init_picker_menu();
    init_picker_menu_option_template();
    init_picker_menu_option();
    init_picker_list_template();
    init_picker_list();
    init_picker_list_item_template();
    init_picker_list_item();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/menu-item/menu-item.options.js
var MenuItemRole, roleForMenuItem;
var init_menu_item_options = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/menu-item/menu-item.options.js"() {
    MenuItemRole = {
      /**
       * The menu item has a "menuitem" role
       */
      menuitem: "menuitem",
      /**
       * The menu item has a "menuitemcheckbox" role
       */
      menuitemcheckbox: "menuitemcheckbox",
      /**
       * The menu item has a "menuitemradio" role
       */
      menuitemradio: "menuitemradio"
    };
    roleForMenuItem = {
      [MenuItemRole.menuitem]: "menuitem",
      [MenuItemRole.menuitemcheckbox]: "menuitemcheckbox",
      [MenuItemRole.menuitemradio]: "menuitemradio"
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/menu-item/menu-item.js
var MenuItem;
var init_menu_item = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/menu-item/menu-item.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_foundation_element();
    init_start_end();
    init_direction();
    init_apply_mixins();
    init_menu_item_options();
    MenuItem = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.role = MenuItemRole.menuitem;
        this.hasSubmenu = false;
        this.currentDirection = Direction.ltr;
        this.focusSubmenuOnLoad = false;
        this.handleMenuItemKeyDown = (e) => {
          if (e.defaultPrevented) {
            return false;
          }
          switch (e.key) {
            case keyEnter:
            case keySpace:
              this.invoke();
              return false;
            case keyArrowRight:
              this.expandAndFocus();
              return false;
            case keyArrowLeft:
              if (this.expanded) {
                this.expanded = false;
                this.focus();
                return false;
              }
          }
          return true;
        };
        this.handleMenuItemClick = (e) => {
          if (e.defaultPrevented || this.disabled) {
            return false;
          }
          this.invoke();
          return false;
        };
        this.submenuLoaded = () => {
          if (!this.focusSubmenuOnLoad) {
            return;
          }
          this.focusSubmenuOnLoad = false;
          if (this.hasSubmenu) {
            this.submenu.focus();
            this.setAttribute("tabindex", "-1");
          }
        };
        this.handleMouseOver = (e) => {
          if (this.disabled || !this.hasSubmenu || this.expanded) {
            return false;
          }
          this.expanded = true;
          return false;
        };
        this.handleMouseOut = (e) => {
          if (!this.expanded || this.contains(document.activeElement)) {
            return false;
          }
          this.expanded = false;
          return false;
        };
        this.expandAndFocus = () => {
          if (!this.hasSubmenu) {
            return;
          }
          this.focusSubmenuOnLoad = true;
          this.expanded = true;
        };
        this.invoke = () => {
          if (this.disabled) {
            return;
          }
          switch (this.role) {
            case MenuItemRole.menuitemcheckbox:
              this.checked = !this.checked;
              break;
            case MenuItemRole.menuitem:
              this.updateSubmenu();
              if (this.hasSubmenu) {
                this.expandAndFocus();
              } else {
                this.$emit("change");
              }
              break;
            case MenuItemRole.menuitemradio:
              if (!this.checked) {
                this.checked = true;
              }
              break;
          }
        };
        this.updateSubmenu = () => {
          this.submenu = this.domChildren().find((element) => {
            return element.getAttribute("role") === "menu";
          });
          this.hasSubmenu = this.submenu === void 0 ? false : true;
        };
      }
      expandedChanged(oldValue) {
        if (this.$fastController.isConnected) {
          if (this.submenu === void 0) {
            return;
          }
          if (this.expanded === false) {
            this.submenu.collapseExpandedItem();
          } else {
            this.currentDirection = getDirection(this);
          }
          this.$emit("expanded-change", this, { bubbles: false });
        }
      }
      checkedChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
          this.$emit("change");
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        DOM.queueUpdate(() => {
          this.updateSubmenu();
        });
        if (!this.startColumnCount) {
          this.startColumnCount = 1;
        }
        this.observer = new MutationObserver(this.updateSubmenu);
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.submenu = void 0;
        if (this.observer !== void 0) {
          this.observer.disconnect();
          this.observer = void 0;
        }
      }
      /**
       * get an array of valid DOM children
       */
      domChildren() {
        return Array.from(this.children).filter((child) => !child.hasAttribute("hidden"));
      }
    };
    __decorate([
      attr({ mode: "boolean" })
    ], MenuItem.prototype, "disabled", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], MenuItem.prototype, "expanded", void 0);
    __decorate([
      observable
    ], MenuItem.prototype, "startColumnCount", void 0);
    __decorate([
      attr
    ], MenuItem.prototype, "role", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], MenuItem.prototype, "checked", void 0);
    __decorate([
      observable
    ], MenuItem.prototype, "submenuRegion", void 0);
    __decorate([
      observable
    ], MenuItem.prototype, "hasSubmenu", void 0);
    __decorate([
      observable
    ], MenuItem.prototype, "currentDirection", void 0);
    __decorate([
      observable
    ], MenuItem.prototype, "submenu", void 0);
    applyMixins(MenuItem, StartEnd);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/menu-item/menu-item.template.js
var menuItemTemplate;
var init_menu_item_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/menu-item/menu-item.template.js"() {
    init_esm();
    init_anchored_region();
    init_start_end();
    init_menu_item();
    menuItemTemplate = (context, definition) => html`
    <template
        role="${(x) => x.role}"
        aria-haspopup="${(x) => x.hasSubmenu ? "menu" : void 0}"
        aria-checked="${(x) => x.role !== MenuItemRole.menuitem ? x.checked : void 0}"
        aria-disabled="${(x) => x.disabled}"
        aria-expanded="${(x) => x.expanded}"
        @keydown="${(x, c) => x.handleMenuItemKeyDown(c.event)}"
        @click="${(x, c) => x.handleMenuItemClick(c.event)}"
        @mouseover="${(x, c) => x.handleMouseOver(c.event)}"
        @mouseout="${(x, c) => x.handleMouseOut(c.event)}"
        class="${(x) => x.disabled ? "disabled" : ""} ${(x) => x.expanded ? "expanded" : ""} ${(x) => `indent-${x.startColumnCount}`}"
    >
            ${when((x) => x.role === MenuItemRole.menuitemcheckbox, html`
                    <div part="input-container" class="input-container">
                        <span part="checkbox" class="checkbox">
                            <slot name="checkbox-indicator">
                                ${definition.checkboxIndicator || ""}
                            </slot>
                        </span>
                    </div>
                `)}
            ${when((x) => x.role === MenuItemRole.menuitemradio, html`
                    <div part="input-container" class="input-container">
                        <span part="radio" class="radio">
                            <slot name="radio-indicator">
                                ${definition.radioIndicator || ""}
                            </slot>
                        </span>
                    </div>
                `)}
        </div>
        ${startSlotTemplate(context, definition)}
        <span class="content" part="content">
            <slot></slot>
        </span>
        ${endSlotTemplate(context, definition)}
        ${when((x) => x.hasSubmenu, html`
                <div
                    part="expand-collapse-glyph-container"
                    class="expand-collapse-glyph-container"
                >
                    <span part="expand-collapse" class="expand-collapse">
                        <slot name="expand-collapse-indicator">
                            ${definition.expandCollapseGlyph || ""}
                        </slot>
                    </span>
                </div>
            `)}
        ${when((x) => x.expanded, html`
                <${context.tagFor(AnchoredRegion)}
                    :anchorElement="${(x) => x}"
                    vertical-positioning-mode="dynamic"
                    vertical-default-position="bottom"
                    vertical-inset="true"
                    horizontal-positioning-mode="dynamic"
                    horizontal-default-position="end"
                    class="submenu-region"
                    dir="${(x) => x.currentDirection}"
                    @loaded="${(x) => x.submenuLoaded()}"
                    ${ref("submenuRegion")}
                    part="submenu-region"
                >
                    <slot name="submenu"></slot>
                </${context.tagFor(AnchoredRegion)}>
            `)}
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/menu-item/index.js
var init_menu_item2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/menu-item/index.js"() {
    init_menu_item_template();
    init_menu_item();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/menu/menu.template.js
var menuTemplate;
var init_menu_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/menu/menu.template.js"() {
    init_esm();
    menuTemplate = (context, definition) => html`
    <template
        slot="${(x) => x.slot ? x.slot : x.isNestedMenu() ? "submenu" : void 0}"
        role="menu"
        @keydown="${(x, c) => x.handleMenuKeyDown(c.event)}"
        @focusout="${(x, c) => x.handleFocusOut(c.event)}"
    >
        <slot ${slotted("items")}></slot>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/menu/menu.js
var Menu2;
var init_menu2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/menu/menu.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_menu_item2();
    init_foundation_element();
    Menu2 = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.expandedItem = null;
        this.focusIndex = -1;
        this.isNestedMenu = () => {
          return this.parentElement !== null && isHTMLElement(this.parentElement) && this.parentElement.getAttribute("role") === "menuitem";
        };
        this.handleFocusOut = (e) => {
          if (!this.contains(e.relatedTarget) && this.menuItems !== void 0) {
            this.collapseExpandedItem();
            const focusIndex = this.menuItems.findIndex(this.isFocusableElement);
            this.menuItems[this.focusIndex].setAttribute("tabindex", "-1");
            this.menuItems[focusIndex].setAttribute("tabindex", "0");
            this.focusIndex = focusIndex;
          }
        };
        this.handleItemFocus = (e) => {
          const targetItem = e.target;
          if (this.menuItems !== void 0 && targetItem !== this.menuItems[this.focusIndex]) {
            this.menuItems[this.focusIndex].setAttribute("tabindex", "-1");
            this.focusIndex = this.menuItems.indexOf(targetItem);
            targetItem.setAttribute("tabindex", "0");
          }
        };
        this.handleExpandedChanged = (e) => {
          if (e.defaultPrevented || e.target === null || this.menuItems === void 0 || this.menuItems.indexOf(e.target) < 0) {
            return;
          }
          e.preventDefault();
          const changedItem = e.target;
          if (this.expandedItem !== null && changedItem === this.expandedItem && changedItem.expanded === false) {
            this.expandedItem = null;
            return;
          }
          if (changedItem.expanded) {
            if (this.expandedItem !== null && this.expandedItem !== changedItem) {
              this.expandedItem.expanded = false;
            }
            this.menuItems[this.focusIndex].setAttribute("tabindex", "-1");
            this.expandedItem = changedItem;
            this.focusIndex = this.menuItems.indexOf(changedItem);
            changedItem.setAttribute("tabindex", "0");
          }
        };
        this.removeItemListeners = () => {
          if (this.menuItems !== void 0) {
            this.menuItems.forEach((item) => {
              item.removeEventListener("expanded-change", this.handleExpandedChanged);
              item.removeEventListener("focus", this.handleItemFocus);
            });
          }
        };
        this.setItems = () => {
          const newItems = this.domChildren();
          this.removeItemListeners();
          this.menuItems = newItems;
          const menuItems = this.menuItems.filter(this.isMenuItemElement);
          if (menuItems.length) {
            this.focusIndex = 0;
          }
          function elementIndent(el) {
            const role = el.getAttribute("role");
            const startSlot = el.querySelector("[slot=start]");
            if (role !== MenuItemRole.menuitem && startSlot === null) {
              return 1;
            } else if (role === MenuItemRole.menuitem && startSlot !== null) {
              return 1;
            } else if (role !== MenuItemRole.menuitem && startSlot !== null) {
              return 2;
            } else {
              return 0;
            }
          }
          const indent = menuItems.reduce((accum, current) => {
            const elementValue = elementIndent(current);
            return accum > elementValue ? accum : elementValue;
          }, 0);
          menuItems.forEach((item, index) => {
            item.setAttribute("tabindex", index === 0 ? "0" : "-1");
            item.addEventListener("expanded-change", this.handleExpandedChanged);
            item.addEventListener("focus", this.handleItemFocus);
            if (item instanceof MenuItem || "startColumnCount" in item) {
              item.startColumnCount = indent;
            }
          });
        };
        this.changeHandler = (e) => {
          if (this.menuItems === void 0) {
            return;
          }
          const changedMenuItem = e.target;
          const changeItemIndex = this.menuItems.indexOf(changedMenuItem);
          if (changeItemIndex === -1) {
            return;
          }
          if (changedMenuItem.role === "menuitemradio" && changedMenuItem.checked === true) {
            for (let i = changeItemIndex - 1; i >= 0; --i) {
              const item = this.menuItems[i];
              const role = item.getAttribute("role");
              if (role === MenuItemRole.menuitemradio) {
                item.checked = false;
              }
              if (role === "separator") {
                break;
              }
            }
            const maxIndex = this.menuItems.length - 1;
            for (let i = changeItemIndex + 1; i <= maxIndex; ++i) {
              const item = this.menuItems[i];
              const role = item.getAttribute("role");
              if (role === MenuItemRole.menuitemradio) {
                item.checked = false;
              }
              if (role === "separator") {
                break;
              }
            }
          }
        };
        this.isMenuItemElement = (el) => {
          return isHTMLElement(el) && Menu2.focusableElementRoles.hasOwnProperty(el.getAttribute("role"));
        };
        this.isFocusableElement = (el) => {
          return this.isMenuItemElement(el);
        };
      }
      itemsChanged(oldValue, newValue) {
        if (this.$fastController.isConnected && this.menuItems !== void 0) {
          this.setItems();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        DOM.queueUpdate(() => {
          this.setItems();
        });
        this.addEventListener("change", this.changeHandler);
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeItemListeners();
        this.menuItems = void 0;
        this.removeEventListener("change", this.changeHandler);
      }
      /**
       * Focuses the first item in the menu.
       *
       * @public
       */
      focus() {
        this.setFocus(0, 1);
      }
      /**
       * Collapses any expanded menu items.
       *
       * @public
       */
      collapseExpandedItem() {
        if (this.expandedItem !== null) {
          this.expandedItem.expanded = false;
          this.expandedItem = null;
        }
      }
      /**
       * @internal
       */
      handleMenuKeyDown(e) {
        if (e.defaultPrevented || this.menuItems === void 0) {
          return;
        }
        switch (e.key) {
          case keyArrowDown:
            this.setFocus(this.focusIndex + 1, 1);
            return;
          case keyArrowUp:
            this.setFocus(this.focusIndex - 1, -1);
            return;
          case keyEnd:
            this.setFocus(this.menuItems.length - 1, -1);
            return;
          case keyHome:
            this.setFocus(0, 1);
            return;
          default:
            return true;
        }
      }
      /**
       * get an array of valid DOM children
       */
      domChildren() {
        return Array.from(this.children).filter((child) => !child.hasAttribute("hidden"));
      }
      setFocus(focusIndex, adjustment) {
        if (this.menuItems === void 0) {
          return;
        }
        while (focusIndex >= 0 && focusIndex < this.menuItems.length) {
          const child = this.menuItems[focusIndex];
          if (this.isFocusableElement(child)) {
            if (this.focusIndex > -1 && this.menuItems.length >= this.focusIndex - 1) {
              this.menuItems[this.focusIndex].setAttribute("tabindex", "-1");
            }
            this.focusIndex = focusIndex;
            child.setAttribute("tabindex", "0");
            child.focus();
            break;
          }
          focusIndex += adjustment;
        }
      }
    };
    Menu2.focusableElementRoles = roleForMenuItem;
    __decorate([
      observable
    ], Menu2.prototype, "items", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/menu/index.js
var init_menu3 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/menu/index.js"() {
    init_menu_template();
    init_menu2();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/number-field/number-field.template.js
var numberFieldTemplate;
var init_number_field_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/number-field/number-field.template.js"() {
    init_esm();
    init_start_end();
    numberFieldTemplate = (context, definition) => html`
    <template class="${(x) => x.readOnly ? "readonly" : ""}">
        <label
            part="label"
            for="control"
            class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot ${slotted("defaultSlottedNodes")}></slot>
        </label>
        <div class="root" part="root">
            ${startSlotTemplate(context, definition)}
            <input
                class="control"
                part="control"
                id="control"
                @input="${(x) => x.handleTextInput()}"
                @change="${(x) => x.handleChange()}"
                @keydown="${(x, c) => x.handleKeyDown(c.event)}"
                @blur="${(x, c) => x.handleBlur()}"
                ?autofocus="${(x) => x.autofocus}"
                ?disabled="${(x) => x.disabled}"
                list="${(x) => x.list}"
                maxlength="${(x) => x.maxlength}"
                minlength="${(x) => x.minlength}"
                placeholder="${(x) => x.placeholder}"
                ?readonly="${(x) => x.readOnly}"
                ?required="${(x) => x.required}"
                size="${(x) => x.size}"
                type="text"
                inputmode="numeric"
                min="${(x) => x.min}"
                max="${(x) => x.max}"
                step="${(x) => x.step}"
                aria-atomic="${(x) => x.ariaAtomic}"
                aria-busy="${(x) => x.ariaBusy}"
                aria-controls="${(x) => x.ariaControls}"
                aria-current="${(x) => x.ariaCurrent}"
                aria-describedby="${(x) => x.ariaDescribedby}"
                aria-details="${(x) => x.ariaDetails}"
                aria-disabled="${(x) => x.ariaDisabled}"
                aria-errormessage="${(x) => x.ariaErrormessage}"
                aria-flowto="${(x) => x.ariaFlowto}"
                aria-haspopup="${(x) => x.ariaHaspopup}"
                aria-hidden="${(x) => x.ariaHidden}"
                aria-invalid="${(x) => x.ariaInvalid}"
                aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
                aria-label="${(x) => x.ariaLabel}"
                aria-labelledby="${(x) => x.ariaLabelledby}"
                aria-live="${(x) => x.ariaLive}"
                aria-owns="${(x) => x.ariaOwns}"
                aria-relevant="${(x) => x.ariaRelevant}"
                aria-roledescription="${(x) => x.ariaRoledescription}"
                ${ref("control")}
            />
            ${when((x) => !x.hideStep && !x.readOnly && !x.disabled, html`
                    <div class="controls" part="controls">
                        <div class="step-up" part="step-up" @click="${(x) => x.stepUp()}">
                            <slot name="step-up-glyph">
                                ${definition.stepUpGlyph || ""}
                            </slot>
                        </div>
                        <div
                            class="step-down"
                            part="step-down"
                            @click="${(x) => x.stepDown()}"
                        >
                            <slot name="step-down-glyph">
                                ${definition.stepDownGlyph || ""}
                            </slot>
                        </div>
                    </div>
                `)}
            ${endSlotTemplate(context, definition)}
        </div>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.form-associated.js
var _TextField, FormAssociatedTextField;
var init_text_field_form_associated = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _TextField = class extends FoundationElement {
    };
    FormAssociatedTextField = class extends FormAssociated(_TextField) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.options.js
var TextFieldType;
var init_text_field_options = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.options.js"() {
    TextFieldType = {
      /**
       * An email TextField
       */
      email: "email",
      /**
       * A password TextField
       */
      password: "password",
      /**
       * A telephone TextField
       */
      tel: "tel",
      /**
       * A text TextField
       */
      text: "text",
      /**
       * A URL TextField
       */
      url: "url"
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.js
var TextField, DelegatesARIATextbox;
var init_text_field = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.js"() {
    init_tslib_es6();
    init_esm();
    init_patterns();
    init_apply_mixins();
    init_text_field_form_associated();
    init_text_field_options();
    TextField = class extends FormAssociatedTextField {
      constructor() {
        super(...arguments);
        this.type = TextFieldType.text;
      }
      readOnlyChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.readOnly = this.readOnly;
          this.validate();
        }
      }
      autofocusChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.autofocus = this.autofocus;
          this.validate();
        }
      }
      placeholderChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.placeholder = this.placeholder;
        }
      }
      typeChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.type = this.type;
          this.validate();
        }
      }
      listChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.setAttribute("list", this.list);
          this.validate();
        }
      }
      maxlengthChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.maxLength = this.maxlength;
          this.validate();
        }
      }
      minlengthChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.minLength = this.minlength;
          this.validate();
        }
      }
      patternChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.pattern = this.pattern;
          this.validate();
        }
      }
      sizeChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.size = this.size;
        }
      }
      spellcheckChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.spellcheck = this.spellcheck;
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.proxy.setAttribute("type", this.type);
        this.validate();
        if (this.autofocus) {
          DOM.queueUpdate(() => {
            this.focus();
          });
        }
      }
      /**
       * Selects all the text in the text field
       *
       * @public
       */
      select() {
        this.control.select();
        this.$emit("select");
      }
      /**
       * Handles the internal control's `input` event
       * @internal
       */
      handleTextInput() {
        this.value = this.control.value;
      }
      /**
       * Change event handler for inner control.
       * @remarks
       * "Change" events are not `composable` so they will not
       * permeate the shadow DOM boundary. This fn effectively proxies
       * the change event, emitting a `change` event whenever the internal
       * control emits a `change` event
       * @internal
       */
      handleChange() {
        this.$emit("change");
      }
      /** {@inheritDoc (FormAssociated:interface).validate} */
      validate() {
        super.validate(this.control);
      }
    };
    __decorate([
      attr({ attribute: "readonly", mode: "boolean" })
    ], TextField.prototype, "readOnly", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], TextField.prototype, "autofocus", void 0);
    __decorate([
      attr
    ], TextField.prototype, "placeholder", void 0);
    __decorate([
      attr
    ], TextField.prototype, "type", void 0);
    __decorate([
      attr
    ], TextField.prototype, "list", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], TextField.prototype, "maxlength", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], TextField.prototype, "minlength", void 0);
    __decorate([
      attr
    ], TextField.prototype, "pattern", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], TextField.prototype, "size", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], TextField.prototype, "spellcheck", void 0);
    __decorate([
      observable
    ], TextField.prototype, "defaultSlottedNodes", void 0);
    DelegatesARIATextbox = class {
    };
    applyMixins(DelegatesARIATextbox, ARIAGlobalStatesAndProperties);
    applyMixins(TextField, StartEnd, DelegatesARIATextbox);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/number-field/number-field.form-associated.js
var _NumberField, FormAssociatedNumberField;
var init_number_field_form_associated = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/number-field/number-field.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _NumberField = class extends FoundationElement {
    };
    FormAssociatedNumberField = class extends FormAssociated(_NumberField) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/number-field/number-field.js
var NumberField;
var init_number_field = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/number-field/number-field.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_start_end();
    init_apply_mixins();
    init_text_field();
    init_number_field_form_associated();
    NumberField = class extends FormAssociatedNumberField {
      constructor() {
        super(...arguments);
        this.hideStep = false;
        this.step = 1;
        this.isUserInput = false;
      }
      /**
       * Ensures that the max is greater than the min and that the value
       *  is less than the max
       * @param previous - the previous max value
       * @param next - updated max value
       *
       * @internal
       */
      maxChanged(previous, next) {
        var _a;
        this.max = Math.max(next, (_a = this.min) !== null && _a !== void 0 ? _a : next);
        const min = Math.min(this.min, this.max);
        if (this.min !== void 0 && this.min !== min) {
          this.min = min;
        }
        this.value = this.getValidValue(this.value);
      }
      /**
       * Ensures that the min is less than the max and that the value
       *  is greater than the min
       * @param previous - previous min value
       * @param next - updated min value
       *
       * @internal
       */
      minChanged(previous, next) {
        var _a;
        this.min = Math.min(next, (_a = this.max) !== null && _a !== void 0 ? _a : next);
        const max2 = Math.max(this.min, this.max);
        if (this.max !== void 0 && this.max !== max2) {
          this.max = max2;
        }
        this.value = this.getValidValue(this.value);
      }
      /**
       * The value property, typed as a number.
       *
       * @public
       */
      get valueAsNumber() {
        return parseFloat(super.value);
      }
      set valueAsNumber(next) {
        this.value = next.toString();
      }
      /**
       * Validates that the value is a number between the min and max
       * @param previous - previous stored value
       * @param next - value being updated
       * @param updateControl - should the text field be updated with value, defaults to true
       * @internal
       */
      valueChanged(previous, next) {
        this.value = this.getValidValue(next);
        if (next !== this.value) {
          return;
        }
        if (this.control && !this.isUserInput) {
          this.control.value = this.value;
        }
        super.valueChanged(previous, this.value);
        if (previous !== void 0 && !this.isUserInput) {
          this.$emit("input");
          this.$emit("change");
        }
        this.isUserInput = false;
      }
      /** {@inheritDoc (FormAssociated:interface).validate} */
      validate() {
        super.validate(this.control);
      }
      /**
       * Sets the internal value to a valid number between the min and max properties
       * @param value - user input
       *
       * @internal
       */
      getValidValue(value) {
        var _a, _b;
        let validValue = parseFloat(parseFloat(value).toPrecision(12));
        if (isNaN(validValue)) {
          validValue = "";
        } else {
          validValue = Math.min(validValue, (_a = this.max) !== null && _a !== void 0 ? _a : validValue);
          validValue = Math.max(validValue, (_b = this.min) !== null && _b !== void 0 ? _b : validValue).toString();
        }
        return validValue;
      }
      /**
       * Increments the value using the step value
       *
       * @public
       */
      stepUp() {
        const value = parseFloat(this.value);
        const stepUpValue = !isNaN(value) ? value + this.step : this.min > 0 ? this.min : this.max < 0 ? this.max : !this.min ? this.step : 0;
        this.value = stepUpValue.toString();
      }
      /**
       * Decrements the value using the step value
       *
       * @public
       */
      stepDown() {
        const value = parseFloat(this.value);
        const stepDownValue = !isNaN(value) ? value - this.step : this.min > 0 ? this.min : this.max < 0 ? this.max : !this.min ? 0 - this.step : 0;
        this.value = stepDownValue.toString();
      }
      /**
       * Sets up the initial state of the number field
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.proxy.setAttribute("type", "number");
        this.validate();
        this.control.value = this.value;
        if (this.autofocus) {
          DOM.queueUpdate(() => {
            this.focus();
          });
        }
      }
      /**
       * Selects all the text in the number field
       *
       * @public
       */
      select() {
        this.control.select();
        this.$emit("select");
      }
      /**
       * Handles the internal control's `input` event
       * @internal
       */
      handleTextInput() {
        this.control.value = this.control.value.replace(/[^0-9\-+e.]/g, "");
        this.isUserInput = true;
        this.value = this.control.value;
      }
      /**
       * Change event handler for inner control.
       * @remarks
       * "Change" events are not `composable` so they will not
       * permeate the shadow DOM boundary. This fn effectively proxies
       * the change event, emitting a `change` event whenever the internal
       * control emits a `change` event
       * @internal
       */
      handleChange() {
        this.$emit("change");
      }
      /**
       * Handles the internal control's `keydown` event
       * @internal
       */
      handleKeyDown(e) {
        const key2 = e.key;
        switch (key2) {
          case keyArrowUp:
            this.stepUp();
            return false;
          case keyArrowDown:
            this.stepDown();
            return false;
        }
        return true;
      }
      /**
       * Handles populating the input field with a validated value when
       *  leaving the input field.
       * @internal
       */
      handleBlur() {
        this.control.value = this.value;
      }
    };
    __decorate([
      attr({ attribute: "readonly", mode: "boolean" })
    ], NumberField.prototype, "readOnly", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], NumberField.prototype, "autofocus", void 0);
    __decorate([
      attr({ attribute: "hide-step", mode: "boolean" })
    ], NumberField.prototype, "hideStep", void 0);
    __decorate([
      attr
    ], NumberField.prototype, "placeholder", void 0);
    __decorate([
      attr
    ], NumberField.prototype, "list", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], NumberField.prototype, "maxlength", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], NumberField.prototype, "minlength", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], NumberField.prototype, "size", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], NumberField.prototype, "step", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], NumberField.prototype, "max", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], NumberField.prototype, "min", void 0);
    __decorate([
      observable
    ], NumberField.prototype, "defaultSlottedNodes", void 0);
    applyMixins(NumberField, StartEnd, DelegatesARIATextbox);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/number-field/index.js
var init_number_field2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/number-field/index.js"() {
    init_number_field_template();
    init_number_field();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/progress-ring/progress-ring.template.js
var progressSegments, progressRingTemplate;
var init_progress_ring_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/progress-ring/progress-ring.template.js"() {
    init_esm();
    progressSegments = 44;
    progressRingTemplate = (context, definition) => html`
    <template
        role="progressbar"
        aria-valuenow="${(x) => x.value}"
        aria-valuemin="${(x) => x.min}"
        aria-valuemax="${(x) => x.max}"
        class="${(x) => x.paused ? "paused" : ""}"
    >
        ${when((x) => typeof x.value === "number", html`
                <svg
                    class="progress"
                    part="progress"
                    viewBox="0 0 16 16"
                    slot="determinate"
                >
                    <circle
                        class="background"
                        part="background"
                        cx="8px"
                        cy="8px"
                        r="7px"
                    ></circle>
                    <circle
                        class="determinate"
                        part="determinate"
                        style="stroke-dasharray: ${(x) => progressSegments * x.percentComplete / 100}px ${progressSegments}px"
                        cx="8px"
                        cy="8px"
                        r="7px"
                    ></circle>
                </svg>
            `, html`
                <slot name="indeterminate" slot="indeterminate">
                    ${definition.indeterminateIndicator || ""}
                </slot>
            `)}
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/progress-ring/index.js
var init_progress_ring = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/progress-ring/index.js"() {
    init_progress_ring_template();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/progress/base-progress.js
var BaseProgress;
var init_base_progress = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/progress/base-progress.js"() {
    init_tslib_es6();
    init_esm();
    init_foundation_element();
    BaseProgress = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.percentComplete = 0;
      }
      valueChanged() {
        if (this.$fastController.isConnected) {
          this.updatePercentComplete();
        }
      }
      minChanged() {
        if (this.$fastController.isConnected) {
          this.updatePercentComplete();
        }
      }
      maxChanged() {
        if (this.$fastController.isConnected) {
          this.updatePercentComplete();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.updatePercentComplete();
      }
      updatePercentComplete() {
        const min = typeof this.min === "number" ? this.min : 0;
        const max2 = typeof this.max === "number" ? this.max : 100;
        const value = typeof this.value === "number" ? this.value : 0;
        const range2 = max2 - min;
        this.percentComplete = range2 === 0 ? 0 : Math.fround((value - min) / range2 * 100);
      }
    };
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], BaseProgress.prototype, "value", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], BaseProgress.prototype, "min", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], BaseProgress.prototype, "max", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], BaseProgress.prototype, "paused", void 0);
    __decorate([
      observable
    ], BaseProgress.prototype, "percentComplete", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/progress/progress.template.js
var progressTemplate;
var init_progress_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/progress/progress.template.js"() {
    init_esm();
    progressTemplate = (context, defintion) => html`
    <template
        role="progressbar"
        aria-valuenow="${(x) => x.value}"
        aria-valuemin="${(x) => x.min}"
        aria-valuemax="${(x) => x.max}"
        class="${(x) => x.paused ? "paused" : ""}"
    >
        ${when((x) => typeof x.value === "number", html`
                <div class="progress" part="progress" slot="determinate">
                    <div
                        class="determinate"
                        part="determinate"
                        style="width: ${(x) => x.percentComplete}%"
                    ></div>
                </div>
            `, html`
                <div class="progress" part="progress" slot="indeterminate">
                    <slot class="indeterminate" name="indeterminate">
                        ${defintion.indeterminateIndicator1 || ""}
                        ${defintion.indeterminateIndicator2 || ""}
                    </slot>
                </div>
            `)}
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/progress/index.js
var init_progress = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/progress/index.js"() {
    init_base_progress();
    init_progress_template();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/radio-group/radio-group.template.js
var radioGroupTemplate;
var init_radio_group_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/radio-group/radio-group.template.js"() {
    init_esm();
    init_dist4();
    radioGroupTemplate = (context, definition) => html`
    <template
        role="radiogroup"
        aria-disabled="${(x) => x.disabled}"
        aria-readonly="${(x) => x.readOnly}"
        @click="${(x, c) => x.clickHandler(c.event)}"
        @keydown="${(x, c) => x.keydownHandler(c.event)}"
        @focusout="${(x, c) => x.focusOutHandler(c.event)}"
    >
        <slot name="label"></slot>
        <div
            class="positioning-region ${(x) => x.orientation === Orientation.horizontal ? "horizontal" : "vertical"}"
            part="positioning-region"
        >
            <slot
                ${slotted({
      property: "slottedRadioButtons",
      filter: elements("[role=radio]")
    })}
            ></slot>
        </div>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/radio-group/radio-group.js
var RadioGroup;
var init_radio_group = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/radio-group/radio-group.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_direction();
    init_foundation_element();
    RadioGroup = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.orientation = Orientation.horizontal;
        this.radioChangeHandler = (e) => {
          const changedRadio = e.target;
          if (changedRadio.checked) {
            this.slottedRadioButtons.forEach((radio) => {
              if (radio !== changedRadio) {
                radio.checked = false;
                if (!this.isInsideFoundationToolbar) {
                  radio.setAttribute("tabindex", "-1");
                }
              }
            });
            this.selectedRadio = changedRadio;
            this.value = changedRadio.value;
            changedRadio.setAttribute("tabindex", "0");
            this.focusedRadio = changedRadio;
          }
          e.stopPropagation();
        };
        this.moveToRadioByIndex = (group, index) => {
          const radio = group[index];
          if (!this.isInsideToolbar) {
            radio.setAttribute("tabindex", "0");
            if (radio.readOnly) {
              this.slottedRadioButtons.forEach((nextRadio) => {
                if (nextRadio !== radio) {
                  nextRadio.setAttribute("tabindex", "-1");
                }
              });
            } else {
              radio.checked = true;
              this.selectedRadio = radio;
            }
          }
          this.focusedRadio = radio;
          radio.focus();
        };
        this.moveRightOffGroup = () => {
          var _a;
          (_a = this.nextElementSibling) === null || _a === void 0 ? void 0 : _a.focus();
        };
        this.moveLeftOffGroup = () => {
          var _a;
          (_a = this.previousElementSibling) === null || _a === void 0 ? void 0 : _a.focus();
        };
        this.focusOutHandler = (e) => {
          const group = this.slottedRadioButtons;
          const radio = e.target;
          const index = radio !== null ? group.indexOf(radio) : 0;
          const focusedIndex = this.focusedRadio ? group.indexOf(this.focusedRadio) : -1;
          if (focusedIndex === 0 && index === focusedIndex || focusedIndex === group.length - 1 && focusedIndex === index) {
            if (!this.selectedRadio) {
              this.focusedRadio = group[0];
              this.focusedRadio.setAttribute("tabindex", "0");
              group.forEach((nextRadio) => {
                if (nextRadio !== this.focusedRadio) {
                  nextRadio.setAttribute("tabindex", "-1");
                }
              });
            } else {
              this.focusedRadio = this.selectedRadio;
              if (!this.isInsideFoundationToolbar) {
                this.selectedRadio.setAttribute("tabindex", "0");
                group.forEach((nextRadio) => {
                  if (nextRadio !== this.selectedRadio) {
                    nextRadio.setAttribute("tabindex", "-1");
                  }
                });
              }
            }
          }
          return true;
        };
        this.clickHandler = (e) => {
          const radio = e.target;
          if (radio) {
            const group = this.slottedRadioButtons;
            if (radio.checked || group.indexOf(radio) === 0) {
              radio.setAttribute("tabindex", "0");
              this.selectedRadio = radio;
            } else {
              radio.setAttribute("tabindex", "-1");
              this.selectedRadio = null;
            }
            this.focusedRadio = radio;
          }
          e.preventDefault();
        };
        this.shouldMoveOffGroupToTheRight = (index, group, key2) => {
          return index === group.length && this.isInsideToolbar && key2 === keyArrowRight;
        };
        this.shouldMoveOffGroupToTheLeft = (group, key2) => {
          const index = this.focusedRadio ? group.indexOf(this.focusedRadio) - 1 : 0;
          return index < 0 && this.isInsideToolbar && key2 === keyArrowLeft;
        };
        this.checkFocusedRadio = () => {
          if (this.focusedRadio !== null && !this.focusedRadio.readOnly && !this.focusedRadio.checked) {
            this.focusedRadio.checked = true;
            this.focusedRadio.setAttribute("tabindex", "0");
            this.focusedRadio.focus();
            this.selectedRadio = this.focusedRadio;
          }
        };
        this.moveRight = (e) => {
          const group = this.slottedRadioButtons;
          let index = 0;
          index = this.focusedRadio ? group.indexOf(this.focusedRadio) + 1 : 1;
          if (this.shouldMoveOffGroupToTheRight(index, group, e.key)) {
            this.moveRightOffGroup();
            return;
          } else if (index === group.length) {
            index = 0;
          }
          while (index < group.length && group.length > 1) {
            if (!group[index].disabled) {
              this.moveToRadioByIndex(group, index);
              break;
            } else if (this.focusedRadio && index === group.indexOf(this.focusedRadio)) {
              break;
            } else if (index + 1 >= group.length) {
              if (this.isInsideToolbar) {
                break;
              } else {
                index = 0;
              }
            } else {
              index += 1;
            }
          }
        };
        this.moveLeft = (e) => {
          const group = this.slottedRadioButtons;
          let index = 0;
          index = this.focusedRadio ? group.indexOf(this.focusedRadio) - 1 : 0;
          index = index < 0 ? group.length - 1 : index;
          if (this.shouldMoveOffGroupToTheLeft(group, e.key)) {
            this.moveLeftOffGroup();
            return;
          }
          while (index >= 0 && group.length > 1) {
            if (!group[index].disabled) {
              this.moveToRadioByIndex(group, index);
              break;
            } else if (this.focusedRadio && index === group.indexOf(this.focusedRadio)) {
              break;
            } else if (index - 1 < 0) {
              index = group.length - 1;
            } else {
              index -= 1;
            }
          }
        };
        this.keydownHandler = (e) => {
          const key2 = e.key;
          if (key2 in ArrowKeys && this.isInsideFoundationToolbar) {
            return true;
          }
          switch (key2) {
            case keyEnter: {
              this.checkFocusedRadio();
              break;
            }
            case keyArrowRight:
            case keyArrowDown: {
              if (this.direction === Direction.ltr) {
                this.moveRight(e);
              } else {
                this.moveLeft(e);
              }
              break;
            }
            case keyArrowLeft:
            case keyArrowUp: {
              if (this.direction === Direction.ltr) {
                this.moveLeft(e);
              } else {
                this.moveRight(e);
              }
              break;
            }
            default: {
              return true;
            }
          }
        };
      }
      readOnlyChanged() {
        if (this.slottedRadioButtons !== void 0) {
          this.slottedRadioButtons.forEach((radio) => {
            if (this.readOnly) {
              radio.readOnly = true;
            } else {
              radio.readOnly = false;
            }
          });
        }
      }
      disabledChanged() {
        if (this.slottedRadioButtons !== void 0) {
          this.slottedRadioButtons.forEach((radio) => {
            if (this.disabled) {
              radio.disabled = true;
            } else {
              radio.disabled = false;
            }
          });
        }
      }
      nameChanged() {
        if (this.slottedRadioButtons) {
          this.slottedRadioButtons.forEach((radio) => {
            radio.setAttribute("name", this.name);
          });
        }
      }
      valueChanged() {
        if (this.slottedRadioButtons) {
          this.slottedRadioButtons.forEach((radio) => {
            if (radio.value === this.value) {
              radio.checked = true;
              this.selectedRadio = radio;
            }
          });
        }
        this.$emit("change");
      }
      slottedRadioButtonsChanged(oldValue, newValue) {
        if (this.slottedRadioButtons && this.slottedRadioButtons.length > 0) {
          this.setupRadioButtons();
        }
      }
      get parentToolbar() {
        return this.closest('[role="toolbar"]');
      }
      get isInsideToolbar() {
        var _a;
        return (_a = this.parentToolbar) !== null && _a !== void 0 ? _a : false;
      }
      get isInsideFoundationToolbar() {
        var _a;
        return !!((_a = this.parentToolbar) === null || _a === void 0 ? void 0 : _a["$fastController"]);
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.direction = getDirection(this);
        this.setupRadioButtons();
      }
      disconnectedCallback() {
        this.slottedRadioButtons.forEach((radio) => {
          radio.removeEventListener("change", this.radioChangeHandler);
        });
      }
      setupRadioButtons() {
        const checkedRadios = this.slottedRadioButtons.filter((radio) => {
          return radio.hasAttribute("checked");
        });
        const numberOfCheckedRadios = checkedRadios ? checkedRadios.length : 0;
        if (numberOfCheckedRadios > 1) {
          const lastCheckedRadio = checkedRadios[numberOfCheckedRadios - 1];
          lastCheckedRadio.checked = true;
        }
        let foundMatchingVal = false;
        this.slottedRadioButtons.forEach((radio) => {
          if (this.name !== void 0) {
            radio.setAttribute("name", this.name);
          }
          if (this.disabled) {
            radio.disabled = true;
          }
          if (this.readOnly) {
            radio.readOnly = true;
          }
          if (this.value && this.value === radio.value) {
            this.selectedRadio = radio;
            this.focusedRadio = radio;
            radio.checked = true;
            radio.setAttribute("tabindex", "0");
            foundMatchingVal = true;
          } else {
            if (!this.isInsideFoundationToolbar) {
              radio.setAttribute("tabindex", "-1");
            }
            radio.checked = false;
          }
          radio.addEventListener("change", this.radioChangeHandler);
        });
        if (this.value === void 0 && this.slottedRadioButtons.length > 0) {
          const checkedRadios2 = this.slottedRadioButtons.filter((radio) => {
            return radio.hasAttribute("checked");
          });
          const numberOfCheckedRadios2 = checkedRadios2 !== null ? checkedRadios2.length : 0;
          if (numberOfCheckedRadios2 > 0 && !foundMatchingVal) {
            const lastCheckedRadio = checkedRadios2[numberOfCheckedRadios2 - 1];
            lastCheckedRadio.checked = true;
            this.focusedRadio = lastCheckedRadio;
            lastCheckedRadio.setAttribute("tabindex", "0");
          } else {
            this.slottedRadioButtons[0].setAttribute("tabindex", "0");
            this.focusedRadio = this.slottedRadioButtons[0];
          }
        }
      }
    };
    __decorate([
      attr({ attribute: "readonly", mode: "boolean" })
    ], RadioGroup.prototype, "readOnly", void 0);
    __decorate([
      attr({ attribute: "disabled", mode: "boolean" })
    ], RadioGroup.prototype, "disabled", void 0);
    __decorate([
      attr
    ], RadioGroup.prototype, "name", void 0);
    __decorate([
      attr
    ], RadioGroup.prototype, "value", void 0);
    __decorate([
      attr
    ], RadioGroup.prototype, "orientation", void 0);
    __decorate([
      observable
    ], RadioGroup.prototype, "childItems", void 0);
    __decorate([
      observable
    ], RadioGroup.prototype, "slottedRadioButtons", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/radio-group/index.js
var init_radio_group2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/radio-group/index.js"() {
    init_radio_group_template();
    init_radio_group();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/radio/radio.template.js
var init_radio_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/radio/radio.template.js"() {
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/radio/radio.form-associated.js
var _Radio, FormAssociatedRadio;
var init_radio_form_associated = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/radio/radio.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _Radio = class extends FoundationElement {
    };
    FormAssociatedRadio = class extends CheckableFormAssociated(_Radio) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/radio/radio.js
var Radio;
var init_radio = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/radio/radio.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_radio_form_associated();
    Radio = class extends FormAssociatedRadio {
      constructor() {
        super();
        this.initialValue = "on";
        this.keypressHandler = (e) => {
          switch (e.key) {
            case keySpace:
              if (!this.checked && !this.readOnly) {
                this.checked = true;
              }
              return;
          }
          return true;
        };
        this.proxy.setAttribute("type", "radio");
      }
      readOnlyChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.readOnly = this.readOnly;
        }
      }
      /**
       * @internal
       */
      defaultCheckedChanged() {
        var _a;
        if (this.$fastController.isConnected && !this.dirtyChecked) {
          if (!this.isInsideRadioGroup()) {
            this.checked = (_a = this.defaultChecked) !== null && _a !== void 0 ? _a : false;
            this.dirtyChecked = false;
          }
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        var _a, _b;
        super.connectedCallback();
        this.validate();
        if (((_a = this.parentElement) === null || _a === void 0 ? void 0 : _a.getAttribute("role")) !== "radiogroup" && this.getAttribute("tabindex") === null) {
          if (!this.disabled) {
            this.setAttribute("tabindex", "0");
          }
        }
        if (this.checkedAttribute) {
          if (!this.dirtyChecked) {
            if (!this.isInsideRadioGroup()) {
              this.checked = (_b = this.defaultChecked) !== null && _b !== void 0 ? _b : false;
              this.dirtyChecked = false;
            }
          }
        }
      }
      isInsideRadioGroup() {
        const parent = this.closest("[role=radiogroup]");
        return parent !== null;
      }
      /**
       * @internal
       */
      clickHandler(e) {
        if (!this.disabled && !this.readOnly && !this.checked) {
          this.checked = true;
        }
      }
    };
    __decorate([
      attr({ attribute: "readonly", mode: "boolean" })
    ], Radio.prototype, "readOnly", void 0);
    __decorate([
      observable
    ], Radio.prototype, "name", void 0);
    __decorate([
      observable
    ], Radio.prototype, "defaultSlottedNodes", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/radio/index.js
var init_radio2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/radio/index.js"() {
    init_radio_template();
    init_radio();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/horizontal-scroll/horizontal-scroll.js
var HorizontalScroll;
var init_horizontal_scroll = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/horizontal-scroll/horizontal-scroll.js"() {
    init_tslib_es6();
    init_esm();
    init_foundation_element();
    HorizontalScroll = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.framesPerSecond = 60;
        this.updatingItems = false;
        this.speed = 600;
        this.easing = "ease-in-out";
        this.flippersHiddenFromAT = false;
        this.scrolling = false;
        this.resizeDetector = null;
      }
      /**
       * The calculated duration for a frame.
       *
       * @internal
       */
      get frameTime() {
        return 1e3 / this.framesPerSecond;
      }
      /**
       * Firing scrollstart and scrollend events
       * @internal
       */
      scrollingChanged(prev, next) {
        if (this.scrollContainer) {
          const event = this.scrolling == true ? "scrollstart" : "scrollend";
          this.$emit(event, this.scrollContainer.scrollLeft);
        }
      }
      /**
       * In RTL mode
       * @internal
       */
      get isRtl() {
        return this.scrollItems.length > 1 && this.scrollItems[0].offsetLeft > this.scrollItems[1].offsetLeft;
      }
      connectedCallback() {
        super.connectedCallback();
        this.initializeResizeDetector();
      }
      disconnectedCallback() {
        this.disconnectResizeDetector();
        super.disconnectedCallback();
      }
      /**
       * Updates scroll stops and flippers when scroll items change
       * @param previous - current scroll items
       * @param next - new updated scroll items
       * @public
       */
      scrollItemsChanged(previous, next) {
        if (next && !this.updatingItems) {
          DOM.queueUpdate(() => this.setStops());
        }
      }
      /**
       * destroys the instance's resize observer
       * @internal
       */
      disconnectResizeDetector() {
        if (this.resizeDetector) {
          this.resizeDetector.disconnect();
          this.resizeDetector = null;
        }
      }
      /**
       * initializes the instance's resize observer
       * @internal
       */
      initializeResizeDetector() {
        this.disconnectResizeDetector();
        this.resizeDetector = new window.ResizeObserver(this.resized.bind(this));
        this.resizeDetector.observe(this);
      }
      /**
       * Looks for slots and uses child nodes instead
       * @internal
       */
      updateScrollStops() {
        this.updatingItems = true;
        const updatedItems = this.scrollItems.reduce((scrollItems, scrollItem) => {
          if (scrollItem instanceof HTMLSlotElement) {
            return scrollItems.concat(scrollItem.assignedElements());
          }
          scrollItems.push(scrollItem);
          return scrollItems;
        }, []);
        this.scrollItems = updatedItems;
        this.updatingItems = false;
      }
      /**
       * Finds all of the scroll stops between elements
       * @internal
       */
      setStops() {
        this.updateScrollStops();
        const { scrollContainer: container } = this;
        const { scrollLeft } = container;
        const { width: containerWidth, left: containerLeft } = container.getBoundingClientRect();
        this.width = containerWidth;
        let lastStop = 0;
        let stops = this.scrollItems.map((item, index) => {
          const { left, width } = item.getBoundingClientRect();
          const leftPosition = Math.round(left + scrollLeft - containerLeft);
          const right = Math.round(leftPosition + width);
          if (this.isRtl) {
            return -right;
          }
          lastStop = right;
          return index === 0 ? 0 : leftPosition;
        }).concat(lastStop);
        stops = this.fixScrollMisalign(stops);
        stops.sort((a, b) => Math.abs(a) - Math.abs(b));
        this.scrollStops = stops;
        this.setFlippers();
      }
      /**
       * Checks to see if the stops are returning values
       *  otherwise it will try to reinitialize them
       *
       * @returns boolean indicating that current scrollStops are valid non-zero values
       * @internal
       */
      validateStops(reinit = true) {
        const hasStops = () => !!this.scrollStops.find((stop) => stop > 0);
        if (!hasStops() && reinit) {
          this.setStops();
        }
        return hasStops();
      }
      /**
       *
       */
      fixScrollMisalign(stops) {
        if (this.isRtl && stops.some((stop) => stop > 0)) {
          stops.sort((a, b) => b - a);
          const offset = stops[0];
          stops = stops.map((stop) => stop - offset);
        }
        return stops;
      }
      /**
       * Sets the controls view if enabled
       * @internal
       */
      setFlippers() {
        var _a, _b;
        const position = this.scrollContainer.scrollLeft;
        (_a = this.previousFlipperContainer) === null || _a === void 0 ? void 0 : _a.classList.toggle("disabled", position === 0);
        if (this.scrollStops) {
          const lastStop = Math.abs(this.scrollStops[this.scrollStops.length - 1]);
          (_b = this.nextFlipperContainer) === null || _b === void 0 ? void 0 : _b.classList.toggle("disabled", this.validateStops(false) && Math.abs(position) + this.width >= lastStop);
        }
      }
      /**
       * Function that can scroll an item into view.
       * @param item - An item index, a scroll item or a child of one of the scroll items
       * @param padding - Padding of the viewport where the active item shouldn't be
       * @param rightPadding - Optional right padding. Uses the padding if not defined
       *
       * @public
       */
      scrollInView(item, padding = 0, rightPadding) {
        var _a;
        if (typeof item !== "number" && item) {
          item = this.scrollItems.findIndex((scrollItem) => scrollItem === item || scrollItem.contains(item));
        }
        if (item !== void 0) {
          rightPadding = rightPadding !== null && rightPadding !== void 0 ? rightPadding : padding;
          const { scrollContainer: container, scrollStops, scrollItems: items } = this;
          const { scrollLeft } = this.scrollContainer;
          const { width: containerWidth } = container.getBoundingClientRect();
          const itemStart = scrollStops[item];
          const { width } = items[item].getBoundingClientRect();
          const itemEnd = itemStart + width;
          const isBefore = scrollLeft + padding > itemStart;
          if (isBefore || scrollLeft + containerWidth - rightPadding < itemEnd) {
            const stops = [...scrollStops].sort((a, b) => isBefore ? b - a : a - b);
            const scrollTo = (_a = stops.find((position) => isBefore ? position + padding < itemStart : position + containerWidth - (rightPadding !== null && rightPadding !== void 0 ? rightPadding : 0) > itemEnd)) !== null && _a !== void 0 ? _a : 0;
            this.scrollToPosition(scrollTo);
          }
        }
      }
      /**
       * Lets the user arrow left and right through the horizontal scroll
       * @param e - Keyboard event
       * @public
       */
      keyupHandler(e) {
        const key2 = e.key;
        switch (key2) {
          case "ArrowLeft":
            this.scrollToPrevious();
            break;
          case "ArrowRight":
            this.scrollToNext();
            break;
        }
      }
      /**
       * Scrolls items to the left
       * @public
       */
      scrollToPrevious() {
        this.validateStops();
        const scrollPosition = this.scrollContainer.scrollLeft;
        const current = this.scrollStops.findIndex((stop, index) => stop >= scrollPosition && (this.isRtl || index === this.scrollStops.length - 1 || this.scrollStops[index + 1] > scrollPosition));
        const right = Math.abs(this.scrollStops[current + 1]);
        let nextIndex = this.scrollStops.findIndex((stop) => Math.abs(stop) + this.width > right);
        if (nextIndex >= current || nextIndex === -1) {
          nextIndex = current > 0 ? current - 1 : 0;
        }
        this.scrollToPosition(this.scrollStops[nextIndex], scrollPosition);
      }
      /**
       * Scrolls items to the right
       * @public
       */
      scrollToNext() {
        this.validateStops();
        const scrollPosition = this.scrollContainer.scrollLeft;
        const current = this.scrollStops.findIndex((stop) => Math.abs(stop) >= Math.abs(scrollPosition));
        const outOfView = this.scrollStops.findIndex((stop) => Math.abs(scrollPosition) + this.width <= Math.abs(stop));
        let nextIndex = current;
        if (outOfView > current + 2) {
          nextIndex = outOfView - 2;
        } else if (current < this.scrollStops.length - 2) {
          nextIndex = current + 1;
        }
        this.scrollToPosition(this.scrollStops[nextIndex], scrollPosition);
      }
      /**
       * Handles scrolling with easing
       * @param position - starting position
       * @param newPosition - position to scroll to
       * @public
       */
      scrollToPosition(newPosition, position = this.scrollContainer.scrollLeft) {
        var _a;
        if (this.scrolling) {
          return;
        }
        this.scrolling = true;
        const seconds = (_a = this.duration) !== null && _a !== void 0 ? _a : `${Math.abs(newPosition - position) / this.speed}s`;
        this.content.style.setProperty("transition-duration", seconds);
        const computedDuration = parseFloat(getComputedStyle(this.content).getPropertyValue("transition-duration"));
        const transitionendHandler = (e) => {
          if (e && e.target !== e.currentTarget) {
            return;
          }
          this.content.style.setProperty("transition-duration", "0s");
          this.content.style.removeProperty("transform");
          this.scrollContainer.style.setProperty("scroll-behavior", "auto");
          this.scrollContainer.scrollLeft = newPosition;
          this.setFlippers();
          this.content.removeEventListener("transitionend", transitionendHandler);
          this.scrolling = false;
        };
        if (computedDuration === 0) {
          transitionendHandler();
          return;
        }
        this.content.addEventListener("transitionend", transitionendHandler);
        const maxScrollValue = this.scrollContainer.scrollWidth - this.scrollContainer.clientWidth;
        let transitionStop = this.scrollContainer.scrollLeft - Math.min(newPosition, maxScrollValue);
        if (this.isRtl) {
          transitionStop = this.scrollContainer.scrollLeft + Math.min(Math.abs(newPosition), maxScrollValue);
        }
        this.content.style.setProperty("transition-property", "transform");
        this.content.style.setProperty("transition-timing-function", this.easing);
        this.content.style.setProperty("transform", `translateX(${transitionStop}px)`);
      }
      /**
       * Monitors resize event on the horizontal-scroll element
       * @public
       */
      resized() {
        if (this.resizeTimeout) {
          this.resizeTimeout = clearTimeout(this.resizeTimeout);
        }
        this.resizeTimeout = setTimeout(() => {
          this.width = this.scrollContainer.offsetWidth;
          this.setFlippers();
        }, this.frameTime);
      }
      /**
       * Monitors scrolled event on the content container
       * @public
       */
      scrolled() {
        if (this.scrollTimeout) {
          this.scrollTimeout = clearTimeout(this.scrollTimeout);
        }
        this.scrollTimeout = setTimeout(() => {
          this.setFlippers();
        }, this.frameTime);
      }
    };
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], HorizontalScroll.prototype, "speed", void 0);
    __decorate([
      attr
    ], HorizontalScroll.prototype, "duration", void 0);
    __decorate([
      attr
    ], HorizontalScroll.prototype, "easing", void 0);
    __decorate([
      attr({ attribute: "flippers-hidden-from-at", converter: booleanConverter })
    ], HorizontalScroll.prototype, "flippersHiddenFromAT", void 0);
    __decorate([
      observable
    ], HorizontalScroll.prototype, "scrolling", void 0);
    __decorate([
      observable
    ], HorizontalScroll.prototype, "scrollItems", void 0);
    __decorate([
      attr({ attribute: "view" })
    ], HorizontalScroll.prototype, "view", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/horizontal-scroll/horizontal-scroll.template.js
var init_horizontal_scroll_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/horizontal-scroll/horizontal-scroll.template.js"() {
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/horizontal-scroll/index.js
var init_horizontal_scroll2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/horizontal-scroll/index.js"() {
    init_horizontal_scroll();
    init_horizontal_scroll_template();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/whitespace-filter.js
function whitespaceFilter(value, index, array) {
  return value.nodeType !== Node.TEXT_NODE ? true : typeof value.nodeValue === "string" && !!value.nodeValue.trim().length;
}
var init_whitespace_filter = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/whitespace-filter.js"() {
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/search/search.template.js
var searchTemplate;
var init_search_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/search/search.template.js"() {
    init_esm();
    init_start_end();
    init_whitespace_filter();
    searchTemplate = (context, definition) => html`
    <template
        class="
            ${(x) => x.readOnly ? "readonly" : ""}
        "
    >
        <label
            part="label"
            for="control"
            class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot
                ${slotted({ property: "defaultSlottedNodes", filter: whitespaceFilter })}
            ></slot>
        </label>
        <div class="root" part="root" ${ref("root")}>
            ${startSlotTemplate(context, definition)}
            <div class="input-wrapper" part="input-wrapper">
                <input
                    class="control"
                    part="control"
                    id="control"
                    @input="${(x) => x.handleTextInput()}"
                    @change="${(x) => x.handleChange()}"
                    ?autofocus="${(x) => x.autofocus}"
                    ?disabled="${(x) => x.disabled}"
                    list="${(x) => x.list}"
                    maxlength="${(x) => x.maxlength}"
                    minlength="${(x) => x.minlength}"
                    pattern="${(x) => x.pattern}"
                    placeholder="${(x) => x.placeholder}"
                    ?readonly="${(x) => x.readOnly}"
                    ?required="${(x) => x.required}"
                    size="${(x) => x.size}"
                    ?spellcheck="${(x) => x.spellcheck}"
                    :value="${(x) => x.value}"
                    type="search"
                    aria-atomic="${(x) => x.ariaAtomic}"
                    aria-busy="${(x) => x.ariaBusy}"
                    aria-controls="${(x) => x.ariaControls}"
                    aria-current="${(x) => x.ariaCurrent}"
                    aria-describedby="${(x) => x.ariaDescribedby}"
                    aria-details="${(x) => x.ariaDetails}"
                    aria-disabled="${(x) => x.ariaDisabled}"
                    aria-errormessage="${(x) => x.ariaErrormessage}"
                    aria-flowto="${(x) => x.ariaFlowto}"
                    aria-haspopup="${(x) => x.ariaHaspopup}"
                    aria-hidden="${(x) => x.ariaHidden}"
                    aria-invalid="${(x) => x.ariaInvalid}"
                    aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
                    aria-label="${(x) => x.ariaLabel}"
                    aria-labelledby="${(x) => x.ariaLabelledby}"
                    aria-live="${(x) => x.ariaLive}"
                    aria-owns="${(x) => x.ariaOwns}"
                    aria-relevant="${(x) => x.ariaRelevant}"
                    aria-roledescription="${(x) => x.ariaRoledescription}"
                    ${ref("control")}
                />
                <slot name="close-button">
                    <button
                        class="clear-button ${(x) => x.value ? "" : "clear-button__hidden"}"
                        part="clear-button"
                        tabindex="-1"
                        @click=${(x) => x.handleClearInput()}
                    >
                        <slot name="close-glyph">
                            <svg
                                width="9"
                                height="9"
                                viewBox="0 0 9 9"
                                xmlns="http://www.w3.org/2000/svg"
                            >
                                <path
                                    d="M0.146447 0.146447C0.338683 -0.0478972 0.645911 -0.0270359 0.853553 0.146447L4.5 3.793L8.14645 0.146447C8.34171 -0.0488155 8.65829 -0.0488155 8.85355 0.146447C9.04882 0.341709 9.04882 0.658291 8.85355 0.853553L5.207 4.5L8.85355 8.14645C9.05934 8.35223 9.03129 8.67582 8.85355 8.85355C8.67582 9.03129 8.35409 9.02703 8.14645 8.85355L4.5 5.207L0.853553 8.85355C0.658291 9.04882 0.341709 9.04882 0.146447 8.85355C-0.0488155 8.65829 -0.0488155 8.34171 0.146447 8.14645L3.793 4.5L0.146447 0.853553C-0.0268697 0.680237 -0.0457894 0.34079 0.146447 0.146447Z"
                                />
                            </svg>
                        </slot>
                    </button>
                </slot>
            </div>
            ${endSlotTemplate(context, definition)}
        </div>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/search/search.form-associated.js
var _Search, FormAssociatedSearch;
var init_search_form_associated = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/search/search.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _Search = class extends FoundationElement {
    };
    FormAssociatedSearch = class extends FormAssociated(_Search) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/search/search.js
var Search, DelegatesARIASearch;
var init_search2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/search/search.js"() {
    init_tslib_es6();
    init_esm();
    init_patterns();
    init_apply_mixins();
    init_search_form_associated();
    Search = class extends FormAssociatedSearch {
      readOnlyChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.readOnly = this.readOnly;
          this.validate();
        }
      }
      autofocusChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.autofocus = this.autofocus;
          this.validate();
        }
      }
      placeholderChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.placeholder = this.placeholder;
        }
      }
      listChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.setAttribute("list", this.list);
          this.validate();
        }
      }
      maxlengthChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.maxLength = this.maxlength;
          this.validate();
        }
      }
      minlengthChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.minLength = this.minlength;
          this.validate();
        }
      }
      patternChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.pattern = this.pattern;
          this.validate();
        }
      }
      sizeChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.size = this.size;
        }
      }
      spellcheckChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.spellcheck = this.spellcheck;
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.validate();
        if (this.autofocus) {
          DOM.queueUpdate(() => {
            this.focus();
          });
        }
      }
      /** {@inheritDoc (FormAssociated:interface).validate} */
      validate() {
        super.validate(this.control);
      }
      /**
       * Handles the internal control's `input` event
       * @internal
       */
      handleTextInput() {
        this.value = this.control.value;
      }
      /**
       * Handles the control's clear value event
       * @public
       */
      handleClearInput() {
        this.value = "";
        this.control.focus();
        this.handleChange();
      }
      /**
       * Change event handler for inner control.
       * @remarks
       * "Change" events are not `composable` so they will not
       * permeate the shadow DOM boundary. This fn effectively proxies
       * the change event, emitting a `change` event whenever the internal
       * control emits a `change` event
       * @internal
       */
      handleChange() {
        this.$emit("change");
      }
    };
    __decorate([
      attr({ attribute: "readonly", mode: "boolean" })
    ], Search.prototype, "readOnly", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], Search.prototype, "autofocus", void 0);
    __decorate([
      attr
    ], Search.prototype, "placeholder", void 0);
    __decorate([
      attr
    ], Search.prototype, "list", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], Search.prototype, "maxlength", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], Search.prototype, "minlength", void 0);
    __decorate([
      attr
    ], Search.prototype, "pattern", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], Search.prototype, "size", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], Search.prototype, "spellcheck", void 0);
    __decorate([
      observable
    ], Search.prototype, "defaultSlottedNodes", void 0);
    DelegatesARIASearch = class {
    };
    applyMixins(DelegatesARIASearch, ARIAGlobalStatesAndProperties);
    applyMixins(Search, StartEnd, DelegatesARIASearch);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/search/index.js
var init_search3 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/search/index.js"() {
    init_search_template();
    init_search2();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/select/select.form-associated.js
var _Select, FormAssociatedSelect;
var init_select_form_associated = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/select/select.form-associated.js"() {
    init_listbox_element();
    init_form_associated();
    _Select = class extends ListboxElement {
    };
    FormAssociatedSelect = class extends FormAssociated(_Select) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("select");
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/select/select.js
var Select, DelegatesARIASelect;
var init_select = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/select/select.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_listbox();
    init_start_end();
    init_apply_mixins();
    init_select_form_associated();
    init_select_options();
    Select = class extends FormAssociatedSelect {
      constructor() {
        super(...arguments);
        this.open = false;
        this.forcedPosition = false;
        this.listboxId = uniqueId2("listbox-");
        this.maxHeight = 0;
      }
      /**
       * Sets focus and synchronizes ARIA attributes when the open property changes.
       *
       * @param prev - the previous open value
       * @param next - the current open value
       *
       * @internal
       */
      openChanged(prev, next) {
        if (!this.collapsible) {
          return;
        }
        if (this.open) {
          this.ariaControls = this.listboxId;
          this.ariaExpanded = "true";
          this.setPositioning();
          this.focusAndScrollOptionIntoView();
          this.indexWhenOpened = this.selectedIndex;
          DOM.queueUpdate(() => this.focus());
          return;
        }
        this.ariaControls = "";
        this.ariaExpanded = "false";
      }
      /**
       * The component is collapsible when in single-selection mode with no size attribute.
       *
       * @internal
       */
      get collapsible() {
        return !(this.multiple || typeof this.size === "number");
      }
      /**
       * The value property.
       *
       * @public
       */
      get value() {
        Observable.track(this, "value");
        return this._value;
      }
      set value(next) {
        var _a, _b, _c, _d, _e, _f, _g;
        const prev = `${this._value}`;
        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.length) {
          const selectedIndex = this._options.findIndex((el) => el.value === next);
          const prevSelectedValue = (_c = (_b = this._options[this.selectedIndex]) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : null;
          const nextSelectedValue = (_e = (_d = this._options[selectedIndex]) === null || _d === void 0 ? void 0 : _d.value) !== null && _e !== void 0 ? _e : null;
          if (selectedIndex === -1 || prevSelectedValue !== nextSelectedValue) {
            next = "";
            this.selectedIndex = selectedIndex;
          }
          next = (_g = (_f = this.firstSelectedOption) === null || _f === void 0 ? void 0 : _f.value) !== null && _g !== void 0 ? _g : next;
        }
        if (prev !== next) {
          this._value = next;
          super.valueChanged(prev, next);
          Observable.notify(this, "value");
          this.updateDisplayValue();
        }
      }
      /**
       * Sets the value and display value to match the first selected option.
       *
       * @param shouldEmit - if true, the input and change events will be emitted
       *
       * @internal
       */
      updateValue(shouldEmit) {
        var _a, _b;
        if (this.$fastController.isConnected) {
          this.value = (_b = (_a = this.firstSelectedOption) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : "";
        }
        if (shouldEmit) {
          this.$emit("input");
          this.$emit("change", this, {
            bubbles: true,
            composed: void 0
          });
        }
      }
      /**
       * Updates the proxy value when the selected index changes.
       *
       * @param prev - the previous selected index
       * @param next - the next selected index
       *
       * @internal
       */
      selectedIndexChanged(prev, next) {
        super.selectedIndexChanged(prev, next);
        this.updateValue();
      }
      positionChanged(prev, next) {
        this.positionAttribute = next;
        this.setPositioning();
      }
      /**
       * Calculate and apply listbox positioning based on available viewport space.
       *
       * @public
       */
      setPositioning() {
        const currentBox = this.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const availableBottom = viewportHeight - currentBox.bottom;
        this.position = this.forcedPosition ? this.positionAttribute : currentBox.top > availableBottom ? SelectPosition.above : SelectPosition.below;
        this.positionAttribute = this.forcedPosition ? this.positionAttribute : this.position;
        this.maxHeight = this.position === SelectPosition.above ? ~~currentBox.top : ~~availableBottom;
      }
      /**
       * The value displayed on the button.
       *
       * @public
       */
      get displayValue() {
        var _a, _b;
        Observable.track(this, "displayValue");
        return (_b = (_a = this.firstSelectedOption) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "";
      }
      /**
       * Synchronize the `aria-disabled` property when the `disabled` property changes.
       *
       * @param prev - The previous disabled value
       * @param next - The next disabled value
       *
       * @internal
       */
      disabledChanged(prev, next) {
        if (super.disabledChanged) {
          super.disabledChanged(prev, next);
        }
        this.ariaDisabled = this.disabled ? "true" : "false";
      }
      /**
       * Reset the element to its first selectable option when its parent form is reset.
       *
       * @internal
       */
      formResetCallback() {
        this.setProxyOptions();
        super.setDefaultSelectedOption();
        if (this.selectedIndex === -1) {
          this.selectedIndex = 0;
        }
      }
      /**
       * Handle opening and closing the listbox when the select is clicked.
       *
       * @param e - the mouse event
       * @internal
       */
      clickHandler(e) {
        if (this.disabled) {
          return;
        }
        if (this.open) {
          const captured = e.target.closest(`option,[role=option]`);
          if (captured && captured.disabled) {
            return;
          }
        }
        super.clickHandler(e);
        this.open = this.collapsible && !this.open;
        if (!this.open && this.indexWhenOpened !== this.selectedIndex) {
          this.updateValue(true);
        }
        return true;
      }
      /**
       * Handles focus state when the element or its children lose focus.
       *
       * @param e - The focus event
       * @internal
       */
      focusoutHandler(e) {
        var _a;
        super.focusoutHandler(e);
        if (!this.open) {
          return true;
        }
        const focusTarget = e.relatedTarget;
        if (this.isSameNode(focusTarget)) {
          this.focus();
          return;
        }
        if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.includes(focusTarget))) {
          this.open = false;
          if (this.indexWhenOpened !== this.selectedIndex) {
            this.updateValue(true);
          }
        }
      }
      /**
       * Updates the value when an option's value changes.
       *
       * @param source - the source object
       * @param propertyName - the property to evaluate
       *
       * @internal
       * @override
       */
      handleChange(source, propertyName) {
        super.handleChange(source, propertyName);
        if (propertyName === "value") {
          this.updateValue();
        }
      }
      /**
       * Synchronize the form-associated proxy and updates the value property of the element.
       *
       * @param prev - the previous collection of slotted option elements
       * @param next - the next collection of slotted option elements
       *
       * @internal
       */
      slottedOptionsChanged(prev, next) {
        this.options.forEach((o) => {
          const notifier = Observable.getNotifier(o);
          notifier.unsubscribe(this, "value");
        });
        super.slottedOptionsChanged(prev, next);
        this.options.forEach((o) => {
          const notifier = Observable.getNotifier(o);
          notifier.subscribe(this, "value");
        });
        this.setProxyOptions();
        this.updateValue();
      }
      /**
       * Prevents focus when size is set and a scrollbar is clicked.
       *
       * @param e - the mouse event object
       *
       * @override
       * @internal
       */
      mousedownHandler(e) {
        var _a;
        if (e.offsetX >= 0 && e.offsetX <= ((_a = this.listbox) === null || _a === void 0 ? void 0 : _a.scrollWidth)) {
          return super.mousedownHandler(e);
        }
        return this.collapsible;
      }
      /**
       * Sets the multiple property on the proxy element.
       *
       * @param prev - the previous multiple value
       * @param next - the current multiple value
       */
      multipleChanged(prev, next) {
        super.multipleChanged(prev, next);
        if (this.proxy) {
          this.proxy.multiple = next;
        }
      }
      /**
       * Updates the selectedness of each option when the list of selected options changes.
       *
       * @param prev - the previous list of selected options
       * @param next - the current list of selected options
       *
       * @override
       * @internal
       */
      selectedOptionsChanged(prev, next) {
        var _a;
        super.selectedOptionsChanged(prev, next);
        (_a = this.options) === null || _a === void 0 ? void 0 : _a.forEach((o, i) => {
          var _a2;
          const proxyOption = (_a2 = this.proxy) === null || _a2 === void 0 ? void 0 : _a2.options.item(i);
          if (proxyOption) {
            proxyOption.selected = o.selected;
          }
        });
      }
      /**
       * Sets the selected index to match the first option with the selected attribute, or
       * the first selectable option.
       *
       * @override
       * @internal
       */
      setDefaultSelectedOption() {
        var _a;
        const options = (_a = this.options) !== null && _a !== void 0 ? _a : Array.from(this.children).filter(Listbox.slottedOptionFilter);
        const selectedIndex = options === null || options === void 0 ? void 0 : options.findIndex((el) => el.hasAttribute("selected") || el.selected || el.value === this.value);
        if (selectedIndex !== -1) {
          this.selectedIndex = selectedIndex;
          return;
        }
        this.selectedIndex = 0;
      }
      /**
       * Resets and fills the proxy to match the component's options.
       *
       * @internal
       */
      setProxyOptions() {
        if (this.proxy instanceof HTMLSelectElement && this.options) {
          this.proxy.options.length = 0;
          this.options.forEach((option) => {
            const proxyOption = option.proxy || (option instanceof HTMLOptionElement ? option.cloneNode() : null);
            if (proxyOption) {
              this.proxy.options.add(proxyOption);
            }
          });
        }
      }
      /**
       * Handle keyboard interaction for the select.
       *
       * @param e - the keyboard event
       * @internal
       */
      keydownHandler(e) {
        super.keydownHandler(e);
        const key2 = e.key || e.key.charCodeAt(0);
        switch (key2) {
          case keySpace: {
            e.preventDefault();
            if (this.collapsible && this.typeAheadExpired) {
              this.open = !this.open;
            }
            break;
          }
          case keyHome:
          case keyEnd: {
            e.preventDefault();
            break;
          }
          case keyEnter: {
            e.preventDefault();
            this.open = !this.open;
            break;
          }
          case keyEscape: {
            if (this.collapsible && this.open) {
              e.preventDefault();
              this.open = false;
            }
            break;
          }
          case keyTab: {
            if (this.collapsible && this.open) {
              e.preventDefault();
              this.open = false;
            }
            return true;
          }
        }
        if (!this.open && this.indexWhenOpened !== this.selectedIndex) {
          this.updateValue(true);
          this.indexWhenOpened = this.selectedIndex;
        }
        return !(key2 === keyArrowDown || key2 === keyArrowUp);
      }
      connectedCallback() {
        super.connectedCallback();
        this.forcedPosition = !!this.positionAttribute;
        this.addEventListener("contentchange", this.updateDisplayValue);
      }
      disconnectedCallback() {
        this.removeEventListener("contentchange", this.updateDisplayValue);
        super.disconnectedCallback();
      }
      /**
       * Updates the proxy's size property when the size attribute changes.
       *
       * @param prev - the previous size
       * @param next - the current size
       *
       * @override
       * @internal
       */
      sizeChanged(prev, next) {
        super.sizeChanged(prev, next);
        if (this.proxy) {
          this.proxy.size = next;
        }
      }
      /**
       *
       * @internal
       */
      updateDisplayValue() {
        if (this.collapsible) {
          Observable.notify(this, "displayValue");
        }
      }
    };
    __decorate([
      attr({ attribute: "open", mode: "boolean" })
    ], Select.prototype, "open", void 0);
    __decorate([
      volatile
    ], Select.prototype, "collapsible", null);
    __decorate([
      observable
    ], Select.prototype, "control", void 0);
    __decorate([
      attr({ attribute: "position" })
    ], Select.prototype, "positionAttribute", void 0);
    __decorate([
      observable
    ], Select.prototype, "position", void 0);
    __decorate([
      observable
    ], Select.prototype, "maxHeight", void 0);
    DelegatesARIASelect = class {
    };
    __decorate([
      observable
    ], DelegatesARIASelect.prototype, "ariaControls", void 0);
    applyMixins(DelegatesARIASelect, DelegatesARIAListbox);
    applyMixins(Select, StartEnd, DelegatesARIASelect);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/select/select.template.js
var selectTemplate;
var init_select_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/select/select.template.js"() {
    init_esm();
    init_listbox();
    init_start_end();
    selectTemplate = (context, definition) => html`
    <template
        class="${(x) => [
      x.collapsible && "collapsible",
      x.collapsible && x.open && "open",
      x.disabled && "disabled",
      x.collapsible && x.position
    ].filter(Boolean).join(" ")}"
        aria-activedescendant="${(x) => x.ariaActiveDescendant}"
        aria-controls="${(x) => x.ariaControls}"
        aria-disabled="${(x) => x.ariaDisabled}"
        aria-expanded="${(x) => x.ariaExpanded}"
        aria-haspopup="${(x) => x.collapsible ? "listbox" : null}"
        aria-multiselectable="${(x) => x.ariaMultiSelectable}"
        ?open="${(x) => x.open}"
        role="combobox"
        tabindex="${(x) => !x.disabled ? "0" : null}"
        @click="${(x, c) => x.clickHandler(c.event)}"
        @focusin="${(x, c) => x.focusinHandler(c.event)}"
        @focusout="${(x, c) => x.focusoutHandler(c.event)}"
        @keydown="${(x, c) => x.keydownHandler(c.event)}"
        @mousedown="${(x, c) => x.mousedownHandler(c.event)}"
    >
        ${when((x) => x.collapsible, html`
                <div
                    class="control"
                    part="control"
                    ?disabled="${(x) => x.disabled}"
                    ${ref("control")}
                >
                    ${startSlotTemplate(context, definition)}
                    <slot name="button-container">
                        <div class="selected-value" part="selected-value">
                            <slot name="selected-value">${(x) => x.displayValue}</slot>
                        </div>
                        <div aria-hidden="true" class="indicator" part="indicator">
                            <slot name="indicator">
                                ${definition.indicator || ""}
                            </slot>
                        </div>
                    </slot>
                    ${endSlotTemplate(context, definition)}
                </div>
            `)}
        <div
            class="listbox"
            id="${(x) => x.listboxId}"
            part="listbox"
            role="listbox"
            ?disabled="${(x) => x.disabled}"
            ?hidden="${(x) => x.collapsible ? !x.open : false}"
            ${ref("listbox")}
        >
            <slot
                ${slotted({
      filter: Listbox.slottedOptionFilter,
      flatten: true,
      property: "slottedOptions"
    })}
            ></slot>
        </div>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/select/index.js
var init_select2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/select/index.js"() {
    init_select();
    init_select_options();
    init_select_template();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/skeleton/skeleton.template.js
var skeletonTemplate;
var init_skeleton_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/skeleton/skeleton.template.js"() {
    init_esm();
    skeletonTemplate = (context, definition) => html`
    <template
        class="${(x) => x.shape === "circle" ? "circle" : "rect"}"
        pattern="${(x) => x.pattern}"
        ?shimmer="${(x) => x.shimmer}"
    >
        ${when((x) => x.shimmer === true, html`
                <span class="shimmer"></span>
            `)}
        <object type="image/svg+xml" data="${(x) => x.pattern}" role="presentation">
            <img class="pattern" src="${(x) => x.pattern}" />
        </object>
        <slot></slot>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/skeleton/skeleton.js
var Skeleton;
var init_skeleton = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/skeleton/skeleton.js"() {
    init_tslib_es6();
    init_esm();
    init_foundation_element();
    Skeleton = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.shape = "rect";
      }
    };
    __decorate([
      attr
    ], Skeleton.prototype, "fill", void 0);
    __decorate([
      attr
    ], Skeleton.prototype, "shape", void 0);
    __decorate([
      attr
    ], Skeleton.prototype, "pattern", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], Skeleton.prototype, "shimmer", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/skeleton/index.js
var init_skeleton2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/skeleton/index.js"() {
    init_skeleton_template();
    init_skeleton();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/slider-label/slider-label.template.js
var sliderLabelTemplate;
var init_slider_label_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/slider-label/slider-label.template.js"() {
    init_esm();
    init_dist4();
    sliderLabelTemplate = (context, definition) => html`
    <template
        aria-disabled="${(x) => x.disabled}"
        class="${(x) => x.sliderOrientation || Orientation.horizontal}
            ${(x) => x.disabled ? "disabled" : ""}"
    >
        <div ${ref("root")} part="root" class="root" style="${(x) => x.positionStyle}">
            <div class="container">
                ${when((x) => !x.hideMark, html`
                        <div class="mark"></div>
                    `)}
                <div class="label">
                    <slot></slot>
                </div>
            </div>
        </div>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/slider/slider-utilities.js
function convertPixelToPercent(pixelPos, minPosition, maxPosition, direction2) {
  let pct = limit(0, 1, (pixelPos - minPosition) / (maxPosition - minPosition));
  if (direction2 === Direction.rtl) {
    pct = 1 - pct;
  }
  return pct;
}
var init_slider_utilities = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/slider/slider-utilities.js"() {
    init_dist4();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/slider-label/slider-label.js
var defaultConfig, SliderLabel;
var init_slider_label = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/slider-label/slider-label.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_slider_utilities();
    init_foundation_element();
    defaultConfig = {
      min: 0,
      max: 0,
      direction: Direction.ltr,
      orientation: Orientation.horizontal,
      disabled: false
    };
    SliderLabel = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.hideMark = false;
        this.sliderDirection = Direction.ltr;
        this.getSliderConfiguration = () => {
          if (!this.isSliderConfig(this.parentNode)) {
            this.sliderDirection = defaultConfig.direction || Direction.ltr;
            this.sliderOrientation = defaultConfig.orientation || Orientation.horizontal;
            this.sliderMaxPosition = defaultConfig.max;
            this.sliderMinPosition = defaultConfig.min;
          } else {
            const parentSlider = this.parentNode;
            const { min, max: max2, direction: direction2, orientation, disabled } = parentSlider;
            if (disabled !== void 0) {
              this.disabled = disabled;
            }
            this.sliderDirection = direction2 || Direction.ltr;
            this.sliderOrientation = orientation || Orientation.horizontal;
            this.sliderMaxPosition = max2;
            this.sliderMinPosition = min;
          }
        };
        this.positionAsStyle = () => {
          const direction2 = this.sliderDirection ? this.sliderDirection : Direction.ltr;
          const pct = convertPixelToPercent(Number(this.position), Number(this.sliderMinPosition), Number(this.sliderMaxPosition));
          let rightNum = Math.round((1 - pct) * 100);
          let leftNum = Math.round(pct * 100);
          if (Number.isNaN(leftNum) && Number.isNaN(rightNum)) {
            rightNum = 50;
            leftNum = 50;
          }
          if (this.sliderOrientation === Orientation.horizontal) {
            return direction2 === Direction.rtl ? `right: ${leftNum}%; left: ${rightNum}%;` : `left: ${leftNum}%; right: ${rightNum}%;`;
          } else {
            return `top: ${leftNum}%; bottom: ${rightNum}%;`;
          }
        };
      }
      positionChanged() {
        this.positionStyle = this.positionAsStyle();
      }
      /**
       * @internal
       */
      sliderOrientationChanged() {
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.getSliderConfiguration();
        this.positionStyle = this.positionAsStyle();
        this.notifier = Observable.getNotifier(this.parentNode);
        this.notifier.subscribe(this, "orientation");
        this.notifier.subscribe(this, "direction");
        this.notifier.subscribe(this, "max");
        this.notifier.subscribe(this, "min");
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.notifier.unsubscribe(this, "orientation");
        this.notifier.unsubscribe(this, "direction");
        this.notifier.unsubscribe(this, "max");
        this.notifier.unsubscribe(this, "min");
      }
      /**
       * @internal
       */
      handleChange(source, propertyName) {
        switch (propertyName) {
          case "direction":
            this.sliderDirection = source.direction;
            break;
          case "orientation":
            this.sliderOrientation = source.orientation;
            break;
          case "max":
            this.sliderMaxPosition = source.max;
            break;
          case "min":
            this.sliderMinPosition = source.min;
            break;
          default:
            break;
        }
        this.positionStyle = this.positionAsStyle();
      }
      isSliderConfig(node) {
        return node.max !== void 0 && node.min !== void 0;
      }
    };
    __decorate([
      observable
    ], SliderLabel.prototype, "positionStyle", void 0);
    __decorate([
      attr
    ], SliderLabel.prototype, "position", void 0);
    __decorate([
      attr({ attribute: "hide-mark", mode: "boolean" })
    ], SliderLabel.prototype, "hideMark", void 0);
    __decorate([
      attr({ attribute: "disabled", mode: "boolean" })
    ], SliderLabel.prototype, "disabled", void 0);
    __decorate([
      observable
    ], SliderLabel.prototype, "sliderOrientation", void 0);
    __decorate([
      observable
    ], SliderLabel.prototype, "sliderMinPosition", void 0);
    __decorate([
      observable
    ], SliderLabel.prototype, "sliderMaxPosition", void 0);
    __decorate([
      observable
    ], SliderLabel.prototype, "sliderDirection", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/slider-label/index.js
var init_slider_label2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/slider-label/index.js"() {
    init_slider_label_template();
    init_slider_label();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/slider/slider.template.js
var sliderTemplate;
var init_slider_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/slider/slider.template.js"() {
    init_esm();
    init_dist4();
    sliderTemplate = (context, definition) => html`
    <template
        role="slider"
        class="${(x) => x.readOnly ? "readonly" : ""}
        ${(x) => x.orientation || Orientation.horizontal}"
        tabindex="${(x) => x.disabled ? null : 0}"
        aria-valuetext="${(x) => x.valueTextFormatter(x.value)}"
        aria-valuenow="${(x) => x.value}"
        aria-valuemin="${(x) => x.min}"
        aria-valuemax="${(x) => x.max}"
        aria-disabled="${(x) => x.disabled ? true : void 0}"
        aria-readonly="${(x) => x.readOnly ? true : void 0}"
        aria-orientation="${(x) => x.orientation}"
        class="${(x) => x.orientation}"
    >
        <div part="positioning-region" class="positioning-region">
            <div ${ref("track")} part="track-container" class="track">
                <slot name="track"></slot>
                <div part="track-start" class="track-start" style="${(x) => x.position}">
                    <slot name="track-start"></slot>
                </div>
            </div>
            <slot></slot>
            <div
                ${ref("thumb")}
                part="thumb-container"
                class="thumb-container"
                style="${(x) => x.position}"
            >
                <slot name="thumb">${definition.thumb || ""}</slot>
            </div>
        </div>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/slider/slider.form-associated.js
var _Slider, FormAssociatedSlider;
var init_slider_form_associated = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/slider/slider.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _Slider = class extends FoundationElement {
    };
    FormAssociatedSlider = class extends FormAssociated(_Slider) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/slider/slider.js
var SliderMode, Slider;
var init_slider = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/slider/slider.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_direction();
    init_slider_utilities();
    init_slider_form_associated();
    SliderMode = {
      singleValue: "single-value"
    };
    Slider = class extends FormAssociatedSlider {
      constructor() {
        super(...arguments);
        this.direction = Direction.ltr;
        this.isDragging = false;
        this.trackWidth = 0;
        this.trackMinWidth = 0;
        this.trackHeight = 0;
        this.trackLeft = 0;
        this.trackMinHeight = 0;
        this.valueTextFormatter = () => null;
        this.min = 0;
        this.max = 10;
        this.step = 1;
        this.orientation = Orientation.horizontal;
        this.mode = SliderMode.singleValue;
        this.keypressHandler = (e) => {
          if (this.readOnly) {
            return;
          }
          if (e.key === keyHome) {
            e.preventDefault();
            this.value = `${this.min}`;
          } else if (e.key === keyEnd) {
            e.preventDefault();
            this.value = `${this.max}`;
          } else if (!e.shiftKey) {
            switch (e.key) {
              case keyArrowRight:
              case keyArrowUp:
                e.preventDefault();
                this.increment();
                break;
              case keyArrowLeft:
              case keyArrowDown:
                e.preventDefault();
                this.decrement();
                break;
            }
          }
        };
        this.setupTrackConstraints = () => {
          const clientRect = this.track.getBoundingClientRect();
          this.trackWidth = this.track.clientWidth;
          this.trackMinWidth = this.track.clientLeft;
          this.trackHeight = clientRect.bottom;
          this.trackMinHeight = clientRect.top;
          this.trackLeft = this.getBoundingClientRect().left;
          if (this.trackWidth === 0) {
            this.trackWidth = 1;
          }
        };
        this.setupListeners = (remove = false) => {
          const eventAction = `${remove ? "remove" : "add"}EventListener`;
          this[eventAction]("keydown", this.keypressHandler);
          this[eventAction]("mousedown", this.handleMouseDown);
          this.thumb[eventAction]("mousedown", this.handleThumbMouseDown, {
            passive: true
          });
          this.thumb[eventAction]("touchstart", this.handleThumbMouseDown, {
            passive: true
          });
          if (remove) {
            this.handleMouseDown(null);
            this.handleThumbMouseDown(null);
          }
        };
        this.initialValue = "";
        this.handleThumbMouseDown = (event) => {
          if (event) {
            if (this.readOnly || this.disabled || event.defaultPrevented) {
              return;
            }
            event.target.focus();
          }
          const eventAction = `${event !== null ? "add" : "remove"}EventListener`;
          window[eventAction]("mouseup", this.handleWindowMouseUp);
          window[eventAction]("mousemove", this.handleMouseMove, { passive: true });
          window[eventAction]("touchmove", this.handleMouseMove, { passive: true });
          window[eventAction]("touchend", this.handleWindowMouseUp);
          this.isDragging = event !== null;
        };
        this.handleMouseMove = (e) => {
          if (this.readOnly || this.disabled || e.defaultPrevented) {
            return;
          }
          const sourceEvent = window.TouchEvent && e instanceof TouchEvent ? e.touches[0] : e;
          const eventValue = this.orientation === Orientation.horizontal ? sourceEvent.pageX - document.documentElement.scrollLeft - this.trackLeft : sourceEvent.pageY - document.documentElement.scrollTop;
          this.value = `${this.calculateNewValue(eventValue)}`;
        };
        this.calculateNewValue = (rawValue) => {
          const newPosition = convertPixelToPercent(rawValue, this.orientation === Orientation.horizontal ? this.trackMinWidth : this.trackMinHeight, this.orientation === Orientation.horizontal ? this.trackWidth : this.trackHeight, this.direction);
          const newValue = (this.max - this.min) * newPosition + this.min;
          return this.convertToConstrainedValue(newValue);
        };
        this.handleWindowMouseUp = (event) => {
          this.stopDragging();
        };
        this.stopDragging = () => {
          this.isDragging = false;
          this.handleMouseDown(null);
          this.handleThumbMouseDown(null);
        };
        this.handleMouseDown = (e) => {
          const eventAction = `${e !== null ? "add" : "remove"}EventListener`;
          if (e === null || !this.disabled && !this.readOnly) {
            window[eventAction]("mouseup", this.handleWindowMouseUp);
            window.document[eventAction]("mouseleave", this.handleWindowMouseUp);
            window[eventAction]("mousemove", this.handleMouseMove);
            if (e) {
              e.preventDefault();
              this.setupTrackConstraints();
              e.target.focus();
              const controlValue = this.orientation === Orientation.horizontal ? e.pageX - document.documentElement.scrollLeft - this.trackLeft : e.pageY - document.documentElement.scrollTop;
              this.value = `${this.calculateNewValue(controlValue)}`;
            }
          }
        };
        this.convertToConstrainedValue = (value) => {
          if (isNaN(value)) {
            value = this.min;
          }
          let constrainedValue = value - this.min;
          const roundedConstrainedValue = Math.round(constrainedValue / this.step);
          const remainderValue = constrainedValue - roundedConstrainedValue * (this.stepMultiplier * this.step) / this.stepMultiplier;
          constrainedValue = remainderValue >= Number(this.step) / 2 ? constrainedValue - remainderValue + Number(this.step) : constrainedValue - remainderValue;
          return constrainedValue + this.min;
        };
      }
      readOnlyChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.readOnly = this.readOnly;
        }
      }
      /**
       * The value property, typed as a number.
       *
       * @public
       */
      get valueAsNumber() {
        return parseFloat(super.value);
      }
      set valueAsNumber(next) {
        this.value = next.toString();
      }
      /**
       * @internal
       */
      valueChanged(previous, next) {
        super.valueChanged(previous, next);
        if (this.$fastController.isConnected) {
          this.setThumbPositionForOrientation(this.direction);
        }
        this.$emit("change");
      }
      minChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.min = `${this.min}`;
        }
        this.validate();
      }
      maxChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.max = `${this.max}`;
        }
        this.validate();
      }
      stepChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.step = `${this.step}`;
        }
        this.updateStepMultiplier();
        this.validate();
      }
      orientationChanged() {
        if (this.$fastController.isConnected) {
          this.setThumbPositionForOrientation(this.direction);
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.proxy.setAttribute("type", "range");
        this.direction = getDirection(this);
        this.updateStepMultiplier();
        this.setupTrackConstraints();
        this.setupListeners();
        this.setupDefaultValue();
        this.setThumbPositionForOrientation(this.direction);
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        this.setupListeners(true);
      }
      /**
       * Increment the value by the step
       *
       * @public
       */
      increment() {
        const newVal = this.direction !== Direction.rtl && this.orientation !== Orientation.vertical ? Number(this.value) + Number(this.step) : Number(this.value) - Number(this.step);
        const incrementedVal = this.convertToConstrainedValue(newVal);
        const incrementedValString = incrementedVal < Number(this.max) ? `${incrementedVal}` : `${this.max}`;
        this.value = incrementedValString;
      }
      /**
       * Decrement the value by the step
       *
       * @public
       */
      decrement() {
        const newVal = this.direction !== Direction.rtl && this.orientation !== Orientation.vertical ? Number(this.value) - Number(this.step) : Number(this.value) + Number(this.step);
        const decrementedVal = this.convertToConstrainedValue(newVal);
        const decrementedValString = decrementedVal > Number(this.min) ? `${decrementedVal}` : `${this.min}`;
        this.value = decrementedValString;
      }
      /**
       * Places the thumb based on the current value
       *
       * @public
       * @param direction - writing mode
       */
      setThumbPositionForOrientation(direction2) {
        const newPct = convertPixelToPercent(Number(this.value), Number(this.min), Number(this.max), direction2);
        const percentage = (1 - newPct) * 100;
        if (this.orientation === Orientation.horizontal) {
          this.position = this.isDragging ? `right: ${percentage}%; transition: none;` : `right: ${percentage}%; transition: all 0.2s ease;`;
        } else {
          this.position = this.isDragging ? `bottom: ${percentage}%; transition: none;` : `bottom: ${percentage}%; transition: all 0.2s ease;`;
        }
      }
      /**
       * Update the step multiplier used to ensure rounding errors from steps that
       * are not whole numbers
       */
      updateStepMultiplier() {
        const stepString = this.step + "";
        const decimalPlacesOfStep = !!(this.step % 1) ? stepString.length - stepString.indexOf(".") - 1 : 0;
        this.stepMultiplier = Math.pow(10, decimalPlacesOfStep);
      }
      get midpoint() {
        return `${this.convertToConstrainedValue((this.max + this.min) / 2)}`;
      }
      setupDefaultValue() {
        if (typeof this.value === "string") {
          if (this.value.length === 0) {
            this.initialValue = this.midpoint;
          } else {
            const value = parseFloat(this.value);
            if (!Number.isNaN(value) && (value < this.min || value > this.max)) {
              this.value = this.midpoint;
            }
          }
        }
      }
    };
    __decorate([
      attr({ attribute: "readonly", mode: "boolean" })
    ], Slider.prototype, "readOnly", void 0);
    __decorate([
      observable
    ], Slider.prototype, "direction", void 0);
    __decorate([
      observable
    ], Slider.prototype, "isDragging", void 0);
    __decorate([
      observable
    ], Slider.prototype, "position", void 0);
    __decorate([
      observable
    ], Slider.prototype, "trackWidth", void 0);
    __decorate([
      observable
    ], Slider.prototype, "trackMinWidth", void 0);
    __decorate([
      observable
    ], Slider.prototype, "trackHeight", void 0);
    __decorate([
      observable
    ], Slider.prototype, "trackLeft", void 0);
    __decorate([
      observable
    ], Slider.prototype, "trackMinHeight", void 0);
    __decorate([
      observable
    ], Slider.prototype, "valueTextFormatter", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], Slider.prototype, "min", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], Slider.prototype, "max", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], Slider.prototype, "step", void 0);
    __decorate([
      attr
    ], Slider.prototype, "orientation", void 0);
    __decorate([
      attr
    ], Slider.prototype, "mode", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/slider/index.js
var init_slider2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/slider/index.js"() {
    init_slider_template();
    init_slider();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/switch/switch.template.js
var switchTemplate;
var init_switch_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/switch/switch.template.js"() {
    init_esm();
    switchTemplate = (context, definition) => html`
    <template
        role="switch"
        aria-checked="${(x) => x.checked}"
        aria-disabled="${(x) => x.disabled}"
        aria-readonly="${(x) => x.readOnly}"
        tabindex="${(x) => x.disabled ? null : 0}"
        @keypress="${(x, c) => x.keypressHandler(c.event)}"
        @click="${(x, c) => x.clickHandler(c.event)}"
        class="${(x) => x.checked ? "checked" : ""}"
    >
        <label
            part="label"
            class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot ${slotted("defaultSlottedNodes")}></slot>
        </label>
        <div part="switch" class="switch">
            <slot name="switch">${definition.switch || ""}</slot>
        </div>
        <span class="status-message" part="status-message">
            <span class="checked-message" part="checked-message">
                <slot name="checked-message"></slot>
            </span>
            <span class="unchecked-message" part="unchecked-message">
                <slot name="unchecked-message"></slot>
            </span>
        </span>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/switch/switch.form-associated.js
var _Switch, FormAssociatedSwitch;
var init_switch_form_associated = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/switch/switch.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _Switch = class extends FoundationElement {
    };
    FormAssociatedSwitch = class extends CheckableFormAssociated(_Switch) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/switch/switch.js
var Switch;
var init_switch = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/switch/switch.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_switch_form_associated();
    Switch = class extends FormAssociatedSwitch {
      constructor() {
        super();
        this.initialValue = "on";
        this.keypressHandler = (e) => {
          if (this.readOnly) {
            return;
          }
          switch (e.key) {
            case keyEnter:
            case keySpace:
              this.checked = !this.checked;
              break;
          }
        };
        this.clickHandler = (e) => {
          if (!this.disabled && !this.readOnly) {
            this.checked = !this.checked;
          }
        };
        this.proxy.setAttribute("type", "checkbox");
      }
      readOnlyChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.readOnly = this.readOnly;
        }
        this.readOnly ? this.classList.add("readonly") : this.classList.remove("readonly");
      }
      /**
       * @internal
       */
      checkedChanged(prev, next) {
        super.checkedChanged(prev, next);
        this.checked ? this.classList.add("checked") : this.classList.remove("checked");
      }
    };
    __decorate([
      attr({ attribute: "readonly", mode: "boolean" })
    ], Switch.prototype, "readOnly", void 0);
    __decorate([
      observable
    ], Switch.prototype, "defaultSlottedNodes", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/switch/index.js
var init_switch2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/switch/index.js"() {
    init_switch_template();
    init_switch();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tab-panel/tab-panel.template.js
var tabPanelTemplate;
var init_tab_panel_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tab-panel/tab-panel.template.js"() {
    init_esm();
    tabPanelTemplate = (context, definition) => html`
    <template slot="tabpanel" role="tabpanel">
        <slot></slot>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tab-panel/tab-panel.js
var TabPanel2;
var init_tab_panel = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tab-panel/tab-panel.js"() {
    init_foundation_element();
    TabPanel2 = class extends FoundationElement {
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tab-panel/index.js
var init_tab_panel2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tab-panel/index.js"() {
    init_tab_panel_template();
    init_tab_panel();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tab/tab.template.js
var tabTemplate;
var init_tab_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tab/tab.template.js"() {
    init_esm();
    tabTemplate = (context, definition) => html`
    <template slot="tab" role="tab" aria-disabled="${(x) => x.disabled}">
        <slot></slot>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tab/tab.js
var Tab;
var init_tab2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tab/tab.js"() {
    init_tslib_es6();
    init_esm();
    init_foundation_element();
    Tab = class extends FoundationElement {
    };
    __decorate([
      attr({ mode: "boolean" })
    ], Tab.prototype, "disabled", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tab/index.js
var init_tab3 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tab/index.js"() {
    init_tab_template();
    init_tab2();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tabs/tabs.template.js
var tabsTemplate;
var init_tabs_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tabs/tabs.template.js"() {
    init_esm();
    init_start_end();
    tabsTemplate = (context, definition) => html`
    <template class="${(x) => x.orientation}">
        ${startSlotTemplate(context, definition)}
        <div class="tablist" part="tablist" role="tablist">
            <slot class="tab" name="tab" part="tab" ${slotted("tabs")}></slot>

            ${when((x) => x.showActiveIndicator, html`
                    <div
                        ${ref("activeIndicatorRef")}
                        class="activeIndicator"
                        part="activeIndicator"
                    ></div>
                `)}
        </div>
        ${endSlotTemplate(context, definition)}
        <div class="tabpanel" part="tabpanel">
            <slot name="tabpanel" ${slotted("tabpanels")}></slot>
        </div>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tabs/tabs.js
var TabsOrientation, Tabs;
var init_tabs = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tabs/tabs.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_start_end();
    init_apply_mixins();
    init_foundation_element();
    TabsOrientation = {
      vertical: "vertical",
      horizontal: "horizontal"
    };
    Tabs = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.orientation = TabsOrientation.horizontal;
        this.activeindicator = true;
        this.showActiveIndicator = true;
        this.prevActiveTabIndex = 0;
        this.activeTabIndex = 0;
        this.ticking = false;
        this.change = () => {
          this.$emit("change", this.activetab);
        };
        this.isDisabledElement = (el) => {
          return el.getAttribute("aria-disabled") === "true";
        };
        this.isHiddenElement = (el) => {
          return el.hasAttribute("hidden");
        };
        this.isFocusableElement = (el) => {
          return !this.isDisabledElement(el) && !this.isHiddenElement(el);
        };
        this.setTabs = () => {
          const gridHorizontalProperty = "gridColumn";
          const gridVerticalProperty = "gridRow";
          const gridProperty = this.isHorizontal() ? gridHorizontalProperty : gridVerticalProperty;
          this.activeTabIndex = this.getActiveIndex();
          this.showActiveIndicator = false;
          this.tabs.forEach((tab, index) => {
            if (tab.slot === "tab") {
              const isActiveTab = this.activeTabIndex === index && this.isFocusableElement(tab);
              if (this.activeindicator && this.isFocusableElement(tab)) {
                this.showActiveIndicator = true;
              }
              const tabId = this.tabIds[index];
              const tabpanelId = this.tabpanelIds[index];
              tab.setAttribute("id", tabId);
              tab.setAttribute("aria-selected", isActiveTab ? "true" : "false");
              tab.setAttribute("aria-controls", tabpanelId);
              tab.addEventListener("click", this.handleTabClick);
              tab.addEventListener("keydown", this.handleTabKeyDown);
              tab.setAttribute("tabindex", isActiveTab ? "0" : "-1");
              if (isActiveTab) {
                this.activetab = tab;
                this.activeid = tabId;
              }
            }
            tab.style[gridHorizontalProperty] = "";
            tab.style[gridVerticalProperty] = "";
            tab.style[gridProperty] = `${index + 1}`;
            !this.isHorizontal() ? tab.classList.add("vertical") : tab.classList.remove("vertical");
          });
        };
        this.setTabPanels = () => {
          this.tabpanels.forEach((tabpanel, index) => {
            const tabId = this.tabIds[index];
            const tabpanelId = this.tabpanelIds[index];
            tabpanel.setAttribute("id", tabpanelId);
            tabpanel.setAttribute("aria-labelledby", tabId);
            this.activeTabIndex !== index ? tabpanel.setAttribute("hidden", "") : tabpanel.removeAttribute("hidden");
          });
        };
        this.handleTabClick = (event) => {
          const selectedTab = event.currentTarget;
          if (selectedTab.nodeType === 1 && this.isFocusableElement(selectedTab)) {
            this.prevActiveTabIndex = this.activeTabIndex;
            this.activeTabIndex = this.tabs.indexOf(selectedTab);
            this.setComponent();
          }
        };
        this.handleTabKeyDown = (event) => {
          if (this.isHorizontal()) {
            switch (event.key) {
              case keyArrowLeft:
                event.preventDefault();
                this.adjustBackward(event);
                break;
              case keyArrowRight:
                event.preventDefault();
                this.adjustForward(event);
                break;
            }
          } else {
            switch (event.key) {
              case keyArrowUp:
                event.preventDefault();
                this.adjustBackward(event);
                break;
              case keyArrowDown:
                event.preventDefault();
                this.adjustForward(event);
                break;
            }
          }
          switch (event.key) {
            case keyHome:
              event.preventDefault();
              this.adjust(-this.activeTabIndex);
              break;
            case keyEnd:
              event.preventDefault();
              this.adjust(this.tabs.length - this.activeTabIndex - 1);
              break;
          }
        };
        this.adjustForward = (e) => {
          const group = this.tabs;
          let index = 0;
          index = this.activetab ? group.indexOf(this.activetab) + 1 : 1;
          if (index === group.length) {
            index = 0;
          }
          while (index < group.length && group.length > 1) {
            if (this.isFocusableElement(group[index])) {
              this.moveToTabByIndex(group, index);
              break;
            } else if (this.activetab && index === group.indexOf(this.activetab)) {
              break;
            } else if (index + 1 >= group.length) {
              index = 0;
            } else {
              index += 1;
            }
          }
        };
        this.adjustBackward = (e) => {
          const group = this.tabs;
          let index = 0;
          index = this.activetab ? group.indexOf(this.activetab) - 1 : 0;
          index = index < 0 ? group.length - 1 : index;
          while (index >= 0 && group.length > 1) {
            if (this.isFocusableElement(group[index])) {
              this.moveToTabByIndex(group, index);
              break;
            } else if (index - 1 < 0) {
              index = group.length - 1;
            } else {
              index -= 1;
            }
          }
        };
        this.moveToTabByIndex = (group, index) => {
          const tab = group[index];
          this.activetab = tab;
          this.prevActiveTabIndex = this.activeTabIndex;
          this.activeTabIndex = index;
          tab.focus();
          this.setComponent();
        };
      }
      /**
       * @internal
       */
      orientationChanged() {
        if (this.$fastController.isConnected) {
          this.setTabs();
          this.setTabPanels();
          this.handleActiveIndicatorPosition();
        }
      }
      /**
       * @internal
       */
      activeidChanged(oldValue, newValue) {
        if (this.$fastController.isConnected && this.tabs.length <= this.tabpanels.length) {
          this.prevActiveTabIndex = this.tabs.findIndex((item) => item.id === oldValue);
          this.setTabs();
          this.setTabPanels();
          this.handleActiveIndicatorPosition();
        }
      }
      /**
       * @internal
       */
      tabsChanged() {
        if (this.$fastController.isConnected && this.tabs.length <= this.tabpanels.length) {
          this.tabIds = this.getTabIds();
          this.tabpanelIds = this.getTabPanelIds();
          this.setTabs();
          this.setTabPanels();
          this.handleActiveIndicatorPosition();
        }
      }
      /**
       * @internal
       */
      tabpanelsChanged() {
        if (this.$fastController.isConnected && this.tabpanels.length <= this.tabs.length) {
          this.tabIds = this.getTabIds();
          this.tabpanelIds = this.getTabPanelIds();
          this.setTabs();
          this.setTabPanels();
          this.handleActiveIndicatorPosition();
        }
      }
      getActiveIndex() {
        const id = this.activeid;
        if (id !== void 0) {
          return this.tabIds.indexOf(this.activeid) === -1 ? 0 : this.tabIds.indexOf(this.activeid);
        } else {
          return 0;
        }
      }
      getTabIds() {
        return this.tabs.map((tab) => {
          var _a;
          return (_a = tab.getAttribute("id")) !== null && _a !== void 0 ? _a : `tab-${uniqueId2()}`;
        });
      }
      getTabPanelIds() {
        return this.tabpanels.map((tabPanel) => {
          var _a;
          return (_a = tabPanel.getAttribute("id")) !== null && _a !== void 0 ? _a : `panel-${uniqueId2()}`;
        });
      }
      setComponent() {
        if (this.activeTabIndex !== this.prevActiveTabIndex) {
          this.activeid = this.tabIds[this.activeTabIndex];
          this.focusTab();
          this.change();
        }
      }
      isHorizontal() {
        return this.orientation === TabsOrientation.horizontal;
      }
      handleActiveIndicatorPosition() {
        if (this.showActiveIndicator && this.activeindicator && this.activeTabIndex !== this.prevActiveTabIndex) {
          if (this.ticking) {
            this.ticking = false;
          } else {
            this.ticking = true;
            this.animateActiveIndicator();
          }
        }
      }
      animateActiveIndicator() {
        this.ticking = true;
        const gridProperty = this.isHorizontal() ? "gridColumn" : "gridRow";
        const translateProperty = this.isHorizontal() ? "translateX" : "translateY";
        const offsetProperty = this.isHorizontal() ? "offsetLeft" : "offsetTop";
        const prev = this.activeIndicatorRef[offsetProperty];
        this.activeIndicatorRef.style[gridProperty] = `${this.activeTabIndex + 1}`;
        const next = this.activeIndicatorRef[offsetProperty];
        this.activeIndicatorRef.style[gridProperty] = `${this.prevActiveTabIndex + 1}`;
        const dif = next - prev;
        this.activeIndicatorRef.style.transform = `${translateProperty}(${dif}px)`;
        this.activeIndicatorRef.classList.add("activeIndicatorTransition");
        this.activeIndicatorRef.addEventListener("transitionend", () => {
          this.ticking = false;
          this.activeIndicatorRef.style[gridProperty] = `${this.activeTabIndex + 1}`;
          this.activeIndicatorRef.style.transform = `${translateProperty}(0px)`;
          this.activeIndicatorRef.classList.remove("activeIndicatorTransition");
        });
      }
      /**
       * The adjust method for FASTTabs
       * @public
       * @remarks
       * This method allows the active index to be adjusted by numerical increments
       */
      adjust(adjustment) {
        const focusableTabs = this.tabs.filter((t) => this.isFocusableElement(t));
        const currentActiveTabIndex = focusableTabs.indexOf(this.activetab);
        const nextTabIndex = limit(0, focusableTabs.length - 1, currentActiveTabIndex + adjustment);
        const nextIndex = this.tabs.indexOf(focusableTabs[nextTabIndex]);
        if (nextIndex > -1) {
          this.moveToTabByIndex(this.tabs, nextIndex);
        }
      }
      focusTab() {
        this.tabs[this.activeTabIndex].focus();
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.tabIds = this.getTabIds();
        this.tabpanelIds = this.getTabPanelIds();
        this.activeTabIndex = this.getActiveIndex();
      }
    };
    __decorate([
      attr
    ], Tabs.prototype, "orientation", void 0);
    __decorate([
      attr
    ], Tabs.prototype, "activeid", void 0);
    __decorate([
      observable
    ], Tabs.prototype, "tabs", void 0);
    __decorate([
      observable
    ], Tabs.prototype, "tabpanels", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], Tabs.prototype, "activeindicator", void 0);
    __decorate([
      observable
    ], Tabs.prototype, "activeIndicatorRef", void 0);
    __decorate([
      observable
    ], Tabs.prototype, "showActiveIndicator", void 0);
    applyMixins(Tabs, StartEnd);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tabs/index.js
var init_tabs2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tabs/index.js"() {
    init_tabs_template();
    init_tabs();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.form-associated.js
var _TextArea, FormAssociatedTextArea;
var init_text_area_form_associated = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _TextArea = class extends FoundationElement {
    };
    FormAssociatedTextArea = class extends FormAssociated(_TextArea) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("textarea");
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.options.js
var TextAreaResize;
var init_text_area_options = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.options.js"() {
    TextAreaResize = {
      /**
       * No resize.
       */
      none: "none",
      /**
       * Resize vertically and horizontally.
       */
      both: "both",
      /**
       * Resize horizontally.
       */
      horizontal: "horizontal",
      /**
       * Resize vertically.
       */
      vertical: "vertical"
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.js
var TextArea;
var init_text_area = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.js"() {
    init_tslib_es6();
    init_esm();
    init_text_field();
    init_apply_mixins();
    init_text_area_form_associated();
    init_text_area_options();
    TextArea = class extends FormAssociatedTextArea {
      constructor() {
        super(...arguments);
        this.resize = TextAreaResize.none;
        this.cols = 20;
        this.handleTextInput = () => {
          this.value = this.control.value;
        };
      }
      readOnlyChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
          this.proxy.readOnly = this.readOnly;
        }
      }
      autofocusChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
          this.proxy.autofocus = this.autofocus;
        }
      }
      listChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
          this.proxy.setAttribute("list", this.list);
        }
      }
      maxlengthChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
          this.proxy.maxLength = this.maxlength;
        }
      }
      minlengthChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
          this.proxy.minLength = this.minlength;
        }
      }
      spellcheckChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
          this.proxy.spellcheck = this.spellcheck;
        }
      }
      /**
       * Selects all the text in the text area
       *
       * @public
       */
      select() {
        this.control.select();
        this.$emit("select");
      }
      /**
       * Change event handler for inner control.
       * @remarks
       * "Change" events are not `composable` so they will not
       * permeate the shadow DOM boundary. This fn effectively proxies
       * the change event, emitting a `change` event whenever the internal
       * control emits a `change` event
       * @internal
       */
      handleChange() {
        this.$emit("change");
      }
      /** {@inheritDoc (FormAssociated:interface).validate} */
      validate() {
        super.validate(this.control);
      }
    };
    __decorate([
      attr({ mode: "boolean" })
    ], TextArea.prototype, "readOnly", void 0);
    __decorate([
      attr
    ], TextArea.prototype, "resize", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], TextArea.prototype, "autofocus", void 0);
    __decorate([
      attr({ attribute: "form" })
    ], TextArea.prototype, "formId", void 0);
    __decorate([
      attr
    ], TextArea.prototype, "list", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], TextArea.prototype, "maxlength", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter })
    ], TextArea.prototype, "minlength", void 0);
    __decorate([
      attr
    ], TextArea.prototype, "name", void 0);
    __decorate([
      attr
    ], TextArea.prototype, "placeholder", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter, mode: "fromView" })
    ], TextArea.prototype, "cols", void 0);
    __decorate([
      attr({ converter: nullableNumberConverter, mode: "fromView" })
    ], TextArea.prototype, "rows", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], TextArea.prototype, "spellcheck", void 0);
    __decorate([
      observable
    ], TextArea.prototype, "defaultSlottedNodes", void 0);
    applyMixins(TextArea, DelegatesARIATextbox);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.template.js
var textAreaTemplate;
var init_text_area_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.template.js"() {
    init_esm();
    init_text_area();
    textAreaTemplate = (context, definition) => html`
    <template
        class="
            ${(x) => x.readOnly ? "readonly" : ""}
            ${(x) => x.resize !== TextAreaResize.none ? `resize-${x.resize}` : ""}"
    >
        <label
            part="label"
            for="control"
            class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot ${slotted("defaultSlottedNodes")}></slot>
        </label>
        <textarea
            part="control"
            class="control"
            id="control"
            ?autofocus="${(x) => x.autofocus}"
            cols="${(x) => x.cols}"
            ?disabled="${(x) => x.disabled}"
            form="${(x) => x.form}"
            list="${(x) => x.list}"
            maxlength="${(x) => x.maxlength}"
            minlength="${(x) => x.minlength}"
            name="${(x) => x.name}"
            placeholder="${(x) => x.placeholder}"
            ?readonly="${(x) => x.readOnly}"
            ?required="${(x) => x.required}"
            rows="${(x) => x.rows}"
            ?spellcheck="${(x) => x.spellcheck}"
            :value="${(x) => x.value}"
            aria-atomic="${(x) => x.ariaAtomic}"
            aria-busy="${(x) => x.ariaBusy}"
            aria-controls="${(x) => x.ariaControls}"
            aria-current="${(x) => x.ariaCurrent}"
            aria-describedby="${(x) => x.ariaDescribedby}"
            aria-details="${(x) => x.ariaDetails}"
            aria-disabled="${(x) => x.ariaDisabled}"
            aria-errormessage="${(x) => x.ariaErrormessage}"
            aria-flowto="${(x) => x.ariaFlowto}"
            aria-haspopup="${(x) => x.ariaHaspopup}"
            aria-hidden="${(x) => x.ariaHidden}"
            aria-invalid="${(x) => x.ariaInvalid}"
            aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
            aria-label="${(x) => x.ariaLabel}"
            aria-labelledby="${(x) => x.ariaLabelledby}"
            aria-live="${(x) => x.ariaLive}"
            aria-owns="${(x) => x.ariaOwns}"
            aria-relevant="${(x) => x.ariaRelevant}"
            aria-roledescription="${(x) => x.ariaRoledescription}"
            @input="${(x, c) => x.handleTextInput()}"
            @change="${(x) => x.handleChange()}"
            ${ref("control")}
        ></textarea>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/text-area/index.js
var init_text_area2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/text-area/index.js"() {
    init_text_area_template();
    init_text_area();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.template.js
var textFieldTemplate;
var init_text_field_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.template.js"() {
    init_esm();
    init_start_end();
    init_whitespace_filter();
    textFieldTemplate = (context, definition) => html`
    <template
        class="
            ${(x) => x.readOnly ? "readonly" : ""}
        "
    >
        <label
            part="label"
            for="control"
            class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot
                ${slotted({ property: "defaultSlottedNodes", filter: whitespaceFilter })}
            ></slot>
        </label>
        <div class="root" part="root">
            ${startSlotTemplate(context, definition)}
            <input
                class="control"
                part="control"
                id="control"
                @input="${(x) => x.handleTextInput()}"
                @change="${(x) => x.handleChange()}"
                ?autofocus="${(x) => x.autofocus}"
                ?disabled="${(x) => x.disabled}"
                list="${(x) => x.list}"
                maxlength="${(x) => x.maxlength}"
                minlength="${(x) => x.minlength}"
                pattern="${(x) => x.pattern}"
                placeholder="${(x) => x.placeholder}"
                ?readonly="${(x) => x.readOnly}"
                ?required="${(x) => x.required}"
                size="${(x) => x.size}"
                ?spellcheck="${(x) => x.spellcheck}"
                :value="${(x) => x.value}"
                type="${(x) => x.type}"
                aria-atomic="${(x) => x.ariaAtomic}"
                aria-busy="${(x) => x.ariaBusy}"
                aria-controls="${(x) => x.ariaControls}"
                aria-current="${(x) => x.ariaCurrent}"
                aria-describedby="${(x) => x.ariaDescribedby}"
                aria-details="${(x) => x.ariaDetails}"
                aria-disabled="${(x) => x.ariaDisabled}"
                aria-errormessage="${(x) => x.ariaErrormessage}"
                aria-flowto="${(x) => x.ariaFlowto}"
                aria-haspopup="${(x) => x.ariaHaspopup}"
                aria-hidden="${(x) => x.ariaHidden}"
                aria-invalid="${(x) => x.ariaInvalid}"
                aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
                aria-label="${(x) => x.ariaLabel}"
                aria-labelledby="${(x) => x.ariaLabelledby}"
                aria-live="${(x) => x.ariaLive}"
                aria-owns="${(x) => x.ariaOwns}"
                aria-relevant="${(x) => x.ariaRelevant}"
                aria-roledescription="${(x) => x.ariaRoledescription}"
                ${ref("control")}
            />
            ${endSlotTemplate(context, definition)}
        </div>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/text-field/index.js
var init_text_field2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/text-field/index.js"() {
    init_text_field_template();
    init_text_field();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/toolbar/toolbar.template.js
var toolbarTemplate;
var init_toolbar_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/toolbar/toolbar.template.js"() {
    init_esm();
    init_start_end();
    toolbarTemplate = (context, definition) => html`
    <template
        aria-label="${(x) => x.ariaLabel}"
        aria-labelledby="${(x) => x.ariaLabelledby}"
        aria-orientation="${(x) => x.orientation}"
        orientation="${(x) => x.orientation}"
        role="toolbar"
        @mousedown="${(x, c) => x.mouseDownHandler(c.event)}"
        @focusin="${(x, c) => x.focusinHandler(c.event)}"
        @keydown="${(x, c) => x.keydownHandler(c.event)}"
        ${children({
      property: "childItems",
      attributeFilter: ["disabled", "hidden"],
      filter: elements(),
      subtree: true
    })}
    >
        <slot name="label"></slot>
        <div class="positioning-region" part="positioning-region">
            ${startSlotTemplate(context, definition)}
            <slot
                ${slotted({
      filter: elements(),
      property: "slottedItems"
    })}
            ></slot>
            ${endSlotTemplate(context, definition)}
        </div>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/toolbar/toolbar.js
var ToolbarArrowKeyMap, Toolbar, DelegatesARIAToolbar;
var init_toolbar = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/toolbar/toolbar.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_index_esm();
    init_foundation_element();
    init_aria_global();
    init_start_end();
    init_apply_mixins();
    init_direction();
    ToolbarArrowKeyMap = Object.freeze({
      [ArrowKeys.ArrowUp]: {
        [Orientation.vertical]: -1
      },
      [ArrowKeys.ArrowDown]: {
        [Orientation.vertical]: 1
      },
      [ArrowKeys.ArrowLeft]: {
        [Orientation.horizontal]: {
          [Direction.ltr]: -1,
          [Direction.rtl]: 1
        }
      },
      [ArrowKeys.ArrowRight]: {
        [Orientation.horizontal]: {
          [Direction.ltr]: 1,
          [Direction.rtl]: -1
        }
      }
    });
    Toolbar = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this._activeIndex = 0;
        this.direction = Direction.ltr;
        this.orientation = Orientation.horizontal;
      }
      /**
       * The index of the currently focused element, clamped between 0 and the last element.
       *
       * @internal
       */
      get activeIndex() {
        Observable.track(this, "activeIndex");
        return this._activeIndex;
      }
      set activeIndex(value) {
        if (this.$fastController.isConnected) {
          this._activeIndex = limit(0, this.focusableElements.length - 1, value);
          Observable.notify(this, "activeIndex");
        }
      }
      slottedItemsChanged() {
        if (this.$fastController.isConnected) {
          this.reduceFocusableElements();
        }
      }
      /**
       * Set the activeIndex when a focusable element in the toolbar is clicked.
       *
       * @internal
       */
      mouseDownHandler(e) {
        var _a;
        const activeIndex = (_a = this.focusableElements) === null || _a === void 0 ? void 0 : _a.findIndex((x) => x.contains(e.target));
        if (activeIndex > -1 && this.activeIndex !== activeIndex) {
          this.setFocusedElement(activeIndex);
        }
        return true;
      }
      childItemsChanged(prev, next) {
        if (this.$fastController.isConnected) {
          this.reduceFocusableElements();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.direction = getDirection(this);
      }
      /**
       * When the toolbar receives focus, set the currently active element as focused.
       *
       * @internal
       */
      focusinHandler(e) {
        const relatedTarget = e.relatedTarget;
        if (!relatedTarget || this.contains(relatedTarget)) {
          return;
        }
        this.setFocusedElement();
      }
      /**
       * Determines a value that can be used to iterate a list with the arrow keys.
       *
       * @param this - An element with an orientation and direction
       * @param key - The event key value
       * @internal
       */
      getDirectionalIncrementer(key2) {
        var _a, _b, _c, _d, _e;
        return (_e = (_c = (_b = (_a = ToolbarArrowKeyMap[key2]) === null || _a === void 0 ? void 0 : _a[this.orientation]) === null || _b === void 0 ? void 0 : _b[this.direction]) !== null && _c !== void 0 ? _c : (_d = ToolbarArrowKeyMap[key2]) === null || _d === void 0 ? void 0 : _d[this.orientation]) !== null && _e !== void 0 ? _e : 0;
      }
      /**
       * Handle keyboard events for the toolbar.
       *
       * @internal
       */
      keydownHandler(e) {
        const key2 = e.key;
        if (!(key2 in ArrowKeys) || e.defaultPrevented || e.shiftKey) {
          return true;
        }
        const incrementer = this.getDirectionalIncrementer(key2);
        if (!incrementer) {
          return !e.target.closest("[role=radiogroup]");
        }
        const nextIndex = this.activeIndex + incrementer;
        if (this.focusableElements[nextIndex]) {
          e.preventDefault();
        }
        this.setFocusedElement(nextIndex);
        return true;
      }
      /**
       * get all the slotted elements
       * @internal
       */
      get allSlottedItems() {
        return [
          ...this.start.assignedElements(),
          ...this.slottedItems,
          ...this.end.assignedElements()
        ];
      }
      /**
       * Prepare the slotted elements which can be focusable.
       *
       * @internal
       */
      reduceFocusableElements() {
        var _a;
        const previousFocusedElement = (_a = this.focusableElements) === null || _a === void 0 ? void 0 : _a[this.activeIndex];
        this.focusableElements = this.allSlottedItems.reduce(Toolbar.reduceFocusableItems, []);
        const adjustedActiveIndex = this.focusableElements.indexOf(previousFocusedElement);
        this.activeIndex = Math.max(0, adjustedActiveIndex);
        this.setFocusableElements();
      }
      /**
       * Set the activeIndex and focus the corresponding control.
       *
       * @param activeIndex - The new index to set
       * @internal
       */
      setFocusedElement(activeIndex = this.activeIndex) {
        var _a;
        this.activeIndex = activeIndex;
        this.setFocusableElements();
        (_a = this.focusableElements[this.activeIndex]) === null || _a === void 0 ? void 0 : _a.focus();
      }
      /**
       * Reduce a collection to only its focusable elements.
       *
       * @param elements - Collection of elements to reduce
       * @param element - The current element
       *
       * @internal
       */
      static reduceFocusableItems(elements2, element) {
        var _a, _b, _c, _d;
        const isRoleRadio = element.getAttribute("role") === "radio";
        const isFocusableFastElement = (_b = (_a = element.$fastController) === null || _a === void 0 ? void 0 : _a.definition.shadowOptions) === null || _b === void 0 ? void 0 : _b.delegatesFocus;
        const hasFocusableShadow = Array.from((_d = (_c = element.shadowRoot) === null || _c === void 0 ? void 0 : _c.querySelectorAll("*")) !== null && _d !== void 0 ? _d : []).some((x) => isFocusable(x));
        if (!element.hasAttribute("disabled") && !element.hasAttribute("hidden") && (isFocusable(element) || isRoleRadio || isFocusableFastElement || hasFocusableShadow)) {
          elements2.push(element);
          return elements2;
        }
        if (element.childElementCount) {
          return elements2.concat(Array.from(element.children).reduce(Toolbar.reduceFocusableItems, []));
        }
        return elements2;
      }
      /**
       * @internal
       */
      setFocusableElements() {
        if (this.$fastController.isConnected && this.focusableElements.length > 0) {
          this.focusableElements.forEach((element, index) => {
            element.tabIndex = this.activeIndex === index ? 0 : -1;
          });
        }
      }
    };
    __decorate([
      observable
    ], Toolbar.prototype, "direction", void 0);
    __decorate([
      attr
    ], Toolbar.prototype, "orientation", void 0);
    __decorate([
      observable
    ], Toolbar.prototype, "slottedItems", void 0);
    __decorate([
      observable
    ], Toolbar.prototype, "slottedLabel", void 0);
    __decorate([
      observable
    ], Toolbar.prototype, "childItems", void 0);
    DelegatesARIAToolbar = class {
    };
    __decorate([
      attr({ attribute: "aria-labelledby" })
    ], DelegatesARIAToolbar.prototype, "ariaLabelledby", void 0);
    __decorate([
      attr({ attribute: "aria-label" })
    ], DelegatesARIAToolbar.prototype, "ariaLabel", void 0);
    applyMixins(DelegatesARIAToolbar, ARIAGlobalStatesAndProperties);
    applyMixins(Toolbar, StartEnd, DelegatesARIAToolbar);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/toolbar/index.js
var init_toolbar2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/toolbar/index.js"() {
    init_toolbar_template();
    init_toolbar();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tooltip/tooltip.template.js
var tooltipTemplate;
var init_tooltip_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tooltip/tooltip.template.js"() {
    init_esm();
    init_anchored_region();
    tooltipTemplate = (context, definition) => {
      return html`
        ${when((x) => x.tooltipVisible, html`
            <${context.tagFor(AnchoredRegion)}
                fixed-placement="true"
                auto-update-mode="${(x) => x.autoUpdateMode}"
                vertical-positioning-mode="${(x) => x.verticalPositioningMode}"
                vertical-default-position="${(x) => x.verticalDefaultPosition}"
                vertical-inset="${(x) => x.verticalInset}"
                vertical-scaling="${(x) => x.verticalScaling}"
                horizontal-positioning-mode="${(x) => x.horizontalPositioningMode}"
                horizontal-default-position="${(x) => x.horizontalDefaultPosition}"
                horizontal-scaling="${(x) => x.horizontalScaling}"
                horizontal-inset="${(x) => x.horizontalInset}"
                vertical-viewport-lock="${(x) => x.horizontalViewportLock}"
                horizontal-viewport-lock="${(x) => x.verticalViewportLock}"
                dir="${(x) => x.currentDirection}"
                ${ref("region")}
            >
                <div class="tooltip" part="tooltip" role="tooltip">
                    <slot></slot>
                </div>
            </${context.tagFor(AnchoredRegion)}>
        `)}
    `;
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tooltip/tooltip.options.js
var TooltipPosition;
var init_tooltip_options = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tooltip/tooltip.options.js"() {
    TooltipPosition = {
      /**
       * The tooltip is positioned above the element
       */
      top: "top",
      /**
       * The tooltip is positioned to the right of the element
       */
      right: "right",
      /**
       * The tooltip is positioned below the element
       */
      bottom: "bottom",
      /**
       * The tooltip is positioned to the left of the element
       */
      left: "left",
      /**
       * The tooltip is positioned before the element
       */
      start: "start",
      /**
       * The tooltip is positioned after the element
       */
      end: "end",
      /**
       * The tooltip is positioned above the element and to the left
       */
      topLeft: "top-left",
      /**
       * The tooltip is positioned above the element and to the right
       */
      topRight: "top-right",
      /**
       * The tooltip is positioned below the element and to the left
       */
      bottomLeft: "bottom-left",
      /**
       * The tooltip is positioned below the element and to the right
       */
      bottomRight: "bottom-right",
      /**
       * The tooltip is positioned above the element and to the left
       */
      topStart: "top-start",
      /**
       * The tooltip is positioned above the element and to the right
       */
      topEnd: "top-end",
      /**
       * The tooltip is positioned below the element and to the left
       */
      bottomStart: "bottom-start",
      /**
       * The tooltip is positioned below the element and to the right
       */
      bottomEnd: "bottom-end"
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tooltip/tooltip.js
var Tooltip;
var init_tooltip = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tooltip/tooltip.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_direction();
    init_foundation_element();
    init_tooltip_options();
    Tooltip = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.anchor = "";
        this.delay = 300;
        this.autoUpdateMode = "anchor";
        this.anchorElement = null;
        this.viewportElement = null;
        this.verticalPositioningMode = "dynamic";
        this.horizontalPositioningMode = "dynamic";
        this.horizontalInset = "false";
        this.verticalInset = "false";
        this.horizontalScaling = "content";
        this.verticalScaling = "content";
        this.verticalDefaultPosition = void 0;
        this.horizontalDefaultPosition = void 0;
        this.tooltipVisible = false;
        this.currentDirection = Direction.ltr;
        this.showDelayTimer = null;
        this.hideDelayTimer = null;
        this.isAnchorHoveredFocused = false;
        this.isRegionHovered = false;
        this.handlePositionChange = (ev) => {
          this.classList.toggle("top", this.region.verticalPosition === "start");
          this.classList.toggle("bottom", this.region.verticalPosition === "end");
          this.classList.toggle("inset-top", this.region.verticalPosition === "insetStart");
          this.classList.toggle("inset-bottom", this.region.verticalPosition === "insetEnd");
          this.classList.toggle("center-vertical", this.region.verticalPosition === "center");
          this.classList.toggle("left", this.region.horizontalPosition === "start");
          this.classList.toggle("right", this.region.horizontalPosition === "end");
          this.classList.toggle("inset-left", this.region.horizontalPosition === "insetStart");
          this.classList.toggle("inset-right", this.region.horizontalPosition === "insetEnd");
          this.classList.toggle("center-horizontal", this.region.horizontalPosition === "center");
        };
        this.handleRegionMouseOver = (ev) => {
          this.isRegionHovered = true;
        };
        this.handleRegionMouseOut = (ev) => {
          this.isRegionHovered = false;
          this.startHideDelayTimer();
        };
        this.handleAnchorMouseOver = (ev) => {
          if (this.tooltipVisible) {
            this.isAnchorHoveredFocused = true;
            return;
          }
          this.startShowDelayTimer();
        };
        this.handleAnchorMouseOut = (ev) => {
          this.isAnchorHoveredFocused = false;
          this.clearShowDelayTimer();
          this.startHideDelayTimer();
        };
        this.handleAnchorFocusIn = (ev) => {
          this.startShowDelayTimer();
        };
        this.handleAnchorFocusOut = (ev) => {
          this.isAnchorHoveredFocused = false;
          this.clearShowDelayTimer();
          this.startHideDelayTimer();
        };
        this.startHideDelayTimer = () => {
          this.clearHideDelayTimer();
          if (!this.tooltipVisible) {
            return;
          }
          this.hideDelayTimer = window.setTimeout(() => {
            this.updateTooltipVisibility();
          }, 60);
        };
        this.clearHideDelayTimer = () => {
          if (this.hideDelayTimer !== null) {
            clearTimeout(this.hideDelayTimer);
            this.hideDelayTimer = null;
          }
        };
        this.startShowDelayTimer = () => {
          if (this.isAnchorHoveredFocused) {
            return;
          }
          if (this.delay > 1) {
            if (this.showDelayTimer === null)
              this.showDelayTimer = window.setTimeout(() => {
                this.startHover();
              }, this.delay);
            return;
          }
          this.startHover();
        };
        this.startHover = () => {
          this.isAnchorHoveredFocused = true;
          this.updateTooltipVisibility();
        };
        this.clearShowDelayTimer = () => {
          if (this.showDelayTimer !== null) {
            clearTimeout(this.showDelayTimer);
            this.showDelayTimer = null;
          }
        };
        this.getAnchor = () => {
          const rootNode = this.getRootNode();
          if (rootNode instanceof ShadowRoot) {
            return rootNode.getElementById(this.anchor);
          }
          return document.getElementById(this.anchor);
        };
        this.handleDocumentKeydown = (e) => {
          if (!e.defaultPrevented && this.tooltipVisible) {
            switch (e.key) {
              case keyEscape:
                this.isAnchorHoveredFocused = false;
                this.updateTooltipVisibility();
                this.$emit("dismiss");
                break;
            }
          }
        };
        this.updateTooltipVisibility = () => {
          if (this.visible === false) {
            this.hideTooltip();
          } else if (this.visible === true) {
            this.showTooltip();
            return;
          } else {
            if (this.isAnchorHoveredFocused || this.isRegionHovered) {
              this.showTooltip();
              return;
            }
            this.hideTooltip();
          }
        };
        this.showTooltip = () => {
          if (this.tooltipVisible) {
            return;
          }
          this.currentDirection = getDirection(this);
          this.tooltipVisible = true;
          document.addEventListener("keydown", this.handleDocumentKeydown);
          DOM.queueUpdate(this.setRegionProps);
        };
        this.hideTooltip = () => {
          if (!this.tooltipVisible) {
            return;
          }
          this.clearHideDelayTimer();
          if (this.region !== null && this.region !== void 0) {
            this.region.removeEventListener("positionchange", this.handlePositionChange);
            this.region.viewportElement = null;
            this.region.anchorElement = null;
            this.region.removeEventListener("mouseover", this.handleRegionMouseOver);
            this.region.removeEventListener("mouseout", this.handleRegionMouseOut);
          }
          document.removeEventListener("keydown", this.handleDocumentKeydown);
          this.tooltipVisible = false;
        };
        this.setRegionProps = () => {
          if (!this.tooltipVisible) {
            return;
          }
          this.region.viewportElement = this.viewportElement;
          this.region.anchorElement = this.anchorElement;
          this.region.addEventListener("positionchange", this.handlePositionChange);
          this.region.addEventListener("mouseover", this.handleRegionMouseOver, {
            passive: true
          });
          this.region.addEventListener("mouseout", this.handleRegionMouseOut, {
            passive: true
          });
        };
      }
      visibleChanged() {
        if (this.$fastController.isConnected) {
          this.updateTooltipVisibility();
          this.updateLayout();
        }
      }
      anchorChanged() {
        if (this.$fastController.isConnected) {
          this.anchorElement = this.getAnchor();
        }
      }
      positionChanged() {
        if (this.$fastController.isConnected) {
          this.updateLayout();
        }
      }
      anchorElementChanged(oldValue) {
        if (this.$fastController.isConnected) {
          if (oldValue !== null && oldValue !== void 0) {
            oldValue.removeEventListener("mouseover", this.handleAnchorMouseOver);
            oldValue.removeEventListener("mouseout", this.handleAnchorMouseOut);
            oldValue.removeEventListener("focusin", this.handleAnchorFocusIn);
            oldValue.removeEventListener("focusout", this.handleAnchorFocusOut);
          }
          if (this.anchorElement !== null && this.anchorElement !== void 0) {
            this.anchorElement.addEventListener("mouseover", this.handleAnchorMouseOver, { passive: true });
            this.anchorElement.addEventListener("mouseout", this.handleAnchorMouseOut, { passive: true });
            this.anchorElement.addEventListener("focusin", this.handleAnchorFocusIn, {
              passive: true
            });
            this.anchorElement.addEventListener("focusout", this.handleAnchorFocusOut, { passive: true });
            const anchorId = this.anchorElement.id;
            if (this.anchorElement.parentElement !== null) {
              this.anchorElement.parentElement.querySelectorAll(":hover").forEach((element) => {
                if (element.id === anchorId) {
                  this.startShowDelayTimer();
                }
              });
            }
          }
          if (this.region !== null && this.region !== void 0 && this.tooltipVisible) {
            this.region.anchorElement = this.anchorElement;
          }
          this.updateLayout();
        }
      }
      viewportElementChanged() {
        if (this.region !== null && this.region !== void 0) {
          this.region.viewportElement = this.viewportElement;
        }
        this.updateLayout();
      }
      connectedCallback() {
        super.connectedCallback();
        this.anchorElement = this.getAnchor();
        this.updateTooltipVisibility();
      }
      disconnectedCallback() {
        this.hideTooltip();
        this.clearShowDelayTimer();
        this.clearHideDelayTimer();
        super.disconnectedCallback();
      }
      /**
       * updated the properties being passed to the anchored region
       */
      updateLayout() {
        this.verticalPositioningMode = "locktodefault";
        this.horizontalPositioningMode = "locktodefault";
        switch (this.position) {
          case TooltipPosition.top:
          case TooltipPosition.bottom:
            this.verticalDefaultPosition = this.position;
            this.horizontalDefaultPosition = "center";
            break;
          case TooltipPosition.right:
          case TooltipPosition.left:
          case TooltipPosition.start:
          case TooltipPosition.end:
            this.verticalDefaultPosition = "center";
            this.horizontalDefaultPosition = this.position;
            break;
          case TooltipPosition.topLeft:
            this.verticalDefaultPosition = "top";
            this.horizontalDefaultPosition = "left";
            break;
          case TooltipPosition.topRight:
            this.verticalDefaultPosition = "top";
            this.horizontalDefaultPosition = "right";
            break;
          case TooltipPosition.bottomLeft:
            this.verticalDefaultPosition = "bottom";
            this.horizontalDefaultPosition = "left";
            break;
          case TooltipPosition.bottomRight:
            this.verticalDefaultPosition = "bottom";
            this.horizontalDefaultPosition = "right";
            break;
          case TooltipPosition.topStart:
            this.verticalDefaultPosition = "top";
            this.horizontalDefaultPosition = "start";
            break;
          case TooltipPosition.topEnd:
            this.verticalDefaultPosition = "top";
            this.horizontalDefaultPosition = "end";
            break;
          case TooltipPosition.bottomStart:
            this.verticalDefaultPosition = "bottom";
            this.horizontalDefaultPosition = "start";
            break;
          case TooltipPosition.bottomEnd:
            this.verticalDefaultPosition = "bottom";
            this.horizontalDefaultPosition = "end";
            break;
          default:
            this.verticalPositioningMode = "dynamic";
            this.horizontalPositioningMode = "dynamic";
            this.verticalDefaultPosition = void 0;
            this.horizontalDefaultPosition = "center";
            break;
        }
      }
    };
    __decorate([
      attr({ mode: "boolean" })
    ], Tooltip.prototype, "visible", void 0);
    __decorate([
      attr
    ], Tooltip.prototype, "anchor", void 0);
    __decorate([
      attr
    ], Tooltip.prototype, "delay", void 0);
    __decorate([
      attr
    ], Tooltip.prototype, "position", void 0);
    __decorate([
      attr({ attribute: "auto-update-mode" })
    ], Tooltip.prototype, "autoUpdateMode", void 0);
    __decorate([
      attr({ attribute: "horizontal-viewport-lock" })
    ], Tooltip.prototype, "horizontalViewportLock", void 0);
    __decorate([
      attr({ attribute: "vertical-viewport-lock" })
    ], Tooltip.prototype, "verticalViewportLock", void 0);
    __decorate([
      observable
    ], Tooltip.prototype, "anchorElement", void 0);
    __decorate([
      observable
    ], Tooltip.prototype, "viewportElement", void 0);
    __decorate([
      observable
    ], Tooltip.prototype, "verticalPositioningMode", void 0);
    __decorate([
      observable
    ], Tooltip.prototype, "horizontalPositioningMode", void 0);
    __decorate([
      observable
    ], Tooltip.prototype, "horizontalInset", void 0);
    __decorate([
      observable
    ], Tooltip.prototype, "verticalInset", void 0);
    __decorate([
      observable
    ], Tooltip.prototype, "horizontalScaling", void 0);
    __decorate([
      observable
    ], Tooltip.prototype, "verticalScaling", void 0);
    __decorate([
      observable
    ], Tooltip.prototype, "verticalDefaultPosition", void 0);
    __decorate([
      observable
    ], Tooltip.prototype, "horizontalDefaultPosition", void 0);
    __decorate([
      observable
    ], Tooltip.prototype, "tooltipVisible", void 0);
    __decorate([
      observable
    ], Tooltip.prototype, "currentDirection", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tooltip/index.js
var init_tooltip2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tooltip/index.js"() {
    init_tooltip_template();
    init_tooltip();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tree-item/tree-item.template.js
var treeItemTemplate;
var init_tree_item_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tree-item/tree-item.template.js"() {
    init_esm();
    init_start_end();
    treeItemTemplate = (context, definition) => html`
    <template
        role="treeitem"
        slot="${(x) => x.isNestedItem() ? "item" : void 0}"
        tabindex="-1"
        class="${(x) => x.expanded ? "expanded" : ""} ${(x) => x.selected ? "selected" : ""} ${(x) => x.nested ? "nested" : ""}
            ${(x) => x.disabled ? "disabled" : ""}"
        aria-expanded="${(x) => x.childItems && x.childItemLength() > 0 ? x.expanded : void 0}"
        aria-selected="${(x) => x.selected}"
        aria-disabled="${(x) => x.disabled}"
        @focusin="${(x, c) => x.handleFocus(c.event)}"
        @focusout="${(x, c) => x.handleBlur(c.event)}"
        ${children({
      property: "childItems",
      filter: elements()
    })}
    >
        <div class="positioning-region" part="positioning-region">
            <div class="content-region" part="content-region">
                ${when((x) => x.childItems && x.childItemLength() > 0, html`
                        <div
                            aria-hidden="true"
                            class="expand-collapse-button"
                            part="expand-collapse-button"
                            @click="${(x, c) => x.handleExpandCollapseButtonClick(c.event)}"
                            ${ref("expandCollapseButton")}
                        >
                            <slot name="expand-collapse-glyph">
                                ${definition.expandCollapseGlyph || ""}
                            </slot>
                        </div>
                    `)}
                ${startSlotTemplate(context, definition)}
                <slot></slot>
                ${endSlotTemplate(context, definition)}
            </div>
        </div>
        ${when((x) => x.childItems && x.childItemLength() > 0 && (x.expanded || x.renderCollapsedChildren), html`
                <div role="group" class="items" part="items">
                    <slot name="item" ${slotted("items")}></slot>
                </div>
            `)}
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tree-item/tree-item.js
function isTreeItemElement(el) {
  return isHTMLElement(el) && el.getAttribute("role") === "treeitem";
}
var TreeItem;
var init_tree_item = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tree-item/tree-item.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_start_end();
    init_apply_mixins();
    init_foundation_element();
    TreeItem = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.expanded = false;
        this.focusable = false;
        this.isNestedItem = () => {
          return isTreeItemElement(this.parentElement);
        };
        this.handleExpandCollapseButtonClick = (e) => {
          if (!this.disabled && !e.defaultPrevented) {
            this.expanded = !this.expanded;
          }
        };
        this.handleFocus = (e) => {
          this.setAttribute("tabindex", "0");
        };
        this.handleBlur = (e) => {
          this.setAttribute("tabindex", "-1");
        };
      }
      expandedChanged() {
        if (this.$fastController.isConnected) {
          this.$emit("expanded-change", this);
        }
      }
      selectedChanged() {
        if (this.$fastController.isConnected) {
          this.$emit("selected-change", this);
        }
      }
      itemsChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
          this.items.forEach((node) => {
            if (isTreeItemElement(node)) {
              node.nested = true;
            }
          });
        }
      }
      /**
       * Places document focus on a tree item
       *
       * @public
       * @param el - the element to focus
       */
      static focusItem(el) {
        el.focusable = true;
        el.focus();
      }
      /**
       * Gets number of children
       *
       * @internal
       */
      childItemLength() {
        const treeChildren = this.childItems.filter((item) => {
          return isTreeItemElement(item);
        });
        return treeChildren ? treeChildren.length : 0;
      }
    };
    __decorate([
      attr({ mode: "boolean" })
    ], TreeItem.prototype, "expanded", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], TreeItem.prototype, "selected", void 0);
    __decorate([
      attr({ mode: "boolean" })
    ], TreeItem.prototype, "disabled", void 0);
    __decorate([
      observable
    ], TreeItem.prototype, "focusable", void 0);
    __decorate([
      observable
    ], TreeItem.prototype, "childItems", void 0);
    __decorate([
      observable
    ], TreeItem.prototype, "items", void 0);
    __decorate([
      observable
    ], TreeItem.prototype, "nested", void 0);
    __decorate([
      observable
    ], TreeItem.prototype, "renderCollapsedChildren", void 0);
    applyMixins(TreeItem, StartEnd);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tree-item/index.js
var init_tree_item2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tree-item/index.js"() {
    init_tree_item_template();
    init_tree_item();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tree-view/tree-view.template.js
var treeViewTemplate;
var init_tree_view_template = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tree-view/tree-view.template.js"() {
    init_esm();
    treeViewTemplate = (context, definition) => html`
    <template
        role="tree"
        ${ref("treeView")}
        @keydown="${(x, c) => x.handleKeyDown(c.event)}"
        @focusin="${(x, c) => x.handleFocus(c.event)}"
        @focusout="${(x, c) => x.handleBlur(c.event)}"
        @click="${(x, c) => x.handleClick(c.event)}"
        @selected-change="${(x, c) => x.handleSelectedChange(c.event)}"
    >
        <slot ${slotted("slottedTreeItems")}></slot>
    </template>
`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tree-view/tree-view.js
var TreeView;
var init_tree_view2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tree-view/tree-view.js"() {
    init_tslib_es6();
    init_esm();
    init_dist4();
    init_tree_item();
    init_foundation_element();
    TreeView = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.currentFocused = null;
        this.handleFocus = (e) => {
          if (this.slottedTreeItems.length < 1) {
            return;
          }
          if (e.target === this) {
            if (this.currentFocused === null) {
              this.currentFocused = this.getValidFocusableItem();
            }
            if (this.currentFocused !== null) {
              TreeItem.focusItem(this.currentFocused);
            }
            return;
          }
          if (this.contains(e.target)) {
            this.setAttribute("tabindex", "-1");
            this.currentFocused = e.target;
          }
        };
        this.handleBlur = (e) => {
          if (e.target instanceof HTMLElement && (e.relatedTarget === null || !this.contains(e.relatedTarget))) {
            this.setAttribute("tabindex", "0");
          }
        };
        this.handleKeyDown = (e) => {
          if (e.defaultPrevented) {
            return;
          }
          if (this.slottedTreeItems.length < 1) {
            return true;
          }
          const treeItems = this.getVisibleNodes();
          switch (e.key) {
            case keyHome:
              if (treeItems.length) {
                TreeItem.focusItem(treeItems[0]);
              }
              return;
            case keyEnd:
              if (treeItems.length) {
                TreeItem.focusItem(treeItems[treeItems.length - 1]);
              }
              return;
            case keyArrowLeft:
              if (e.target && this.isFocusableElement(e.target)) {
                const item = e.target;
                if (item instanceof TreeItem && item.childItemLength() > 0 && item.expanded) {
                  item.expanded = false;
                } else if (item instanceof TreeItem && item.parentElement instanceof TreeItem) {
                  TreeItem.focusItem(item.parentElement);
                }
              }
              return false;
            case keyArrowRight:
              if (e.target && this.isFocusableElement(e.target)) {
                const item = e.target;
                if (item instanceof TreeItem && item.childItemLength() > 0 && !item.expanded) {
                  item.expanded = true;
                } else if (item instanceof TreeItem && item.childItemLength() > 0) {
                  this.focusNextNode(1, e.target);
                }
              }
              return;
            case keyArrowDown:
              if (e.target && this.isFocusableElement(e.target)) {
                this.focusNextNode(1, e.target);
              }
              return;
            case keyArrowUp:
              if (e.target && this.isFocusableElement(e.target)) {
                this.focusNextNode(-1, e.target);
              }
              return;
            case keyEnter:
              this.handleClick(e);
              return;
          }
          return true;
        };
        this.handleSelectedChange = (e) => {
          if (e.defaultPrevented) {
            return;
          }
          if (!(e.target instanceof Element) || !isTreeItemElement(e.target)) {
            return true;
          }
          const item = e.target;
          if (item.selected) {
            if (this.currentSelected && this.currentSelected !== item) {
              this.currentSelected.selected = false;
            }
            this.currentSelected = item;
          } else if (!item.selected && this.currentSelected === item) {
            this.currentSelected = null;
          }
          return;
        };
        this.setItems = () => {
          const selectedItem = this.treeView.querySelector("[aria-selected='true']");
          this.currentSelected = selectedItem;
          if (this.currentFocused === null || !this.contains(this.currentFocused)) {
            this.currentFocused = this.getValidFocusableItem();
          }
          this.nested = this.checkForNestedItems();
          const treeItems = this.getVisibleNodes();
          treeItems.forEach((node) => {
            if (isTreeItemElement(node)) {
              node.nested = this.nested;
            }
          });
        };
        this.isFocusableElement = (el) => {
          return isTreeItemElement(el);
        };
        this.isSelectedElement = (el) => {
          return el.selected;
        };
      }
      slottedTreeItemsChanged() {
        if (this.$fastController.isConnected) {
          this.setItems();
        }
      }
      connectedCallback() {
        super.connectedCallback();
        this.setAttribute("tabindex", "0");
        DOM.queueUpdate(() => {
          this.setItems();
        });
      }
      /**
       * Handles click events bubbling up
       *
       *  @internal
       */
      handleClick(e) {
        if (e.defaultPrevented) {
          return;
        }
        if (!(e.target instanceof Element) || !isTreeItemElement(e.target)) {
          return true;
        }
        const item = e.target;
        if (!item.disabled) {
          item.selected = !item.selected;
        }
        return;
      }
      /**
       * Move focus to a tree item based on its offset from the provided item
       */
      focusNextNode(delta, item) {
        const visibleNodes = this.getVisibleNodes();
        if (!visibleNodes) {
          return;
        }
        const focusItem = visibleNodes[visibleNodes.indexOf(item) + delta];
        if (isHTMLElement(focusItem)) {
          TreeItem.focusItem(focusItem);
        }
      }
      /**
       * checks if there are any nested tree items
       */
      getValidFocusableItem() {
        const treeItems = this.getVisibleNodes();
        let focusIndex = treeItems.findIndex(this.isSelectedElement);
        if (focusIndex === -1) {
          focusIndex = treeItems.findIndex(this.isFocusableElement);
        }
        if (focusIndex !== -1) {
          return treeItems[focusIndex];
        }
        return null;
      }
      /**
       * checks if there are any nested tree items
       */
      checkForNestedItems() {
        return this.slottedTreeItems.some((node) => {
          return isTreeItemElement(node) && node.querySelector("[role='treeitem']");
        });
      }
      getVisibleNodes() {
        return getDisplayedNodes(this, "[role='treeitem']") || [];
      }
    };
    __decorate([
      attr({ attribute: "render-collapsed-nodes" })
    ], TreeView.prototype, "renderCollapsedNodes", void 0);
    __decorate([
      observable
    ], TreeView.prototype, "currentSelected", void 0);
    __decorate([
      observable
    ], TreeView.prototype, "slottedTreeItems", void 0);
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/tree-view/index.js
var init_tree_view3 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/tree-view/index.js"() {
    init_tree_view_template();
    init_tree_view2();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/match-media-stylesheet-behavior.js
var MatchMediaBehavior, MatchMediaStyleSheetBehavior, forcedColorsStylesheetBehavior, darkModeStylesheetBehavior, lightModeStylesheetBehavior;
var init_match_media_stylesheet_behavior = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/match-media-stylesheet-behavior.js"() {
    MatchMediaBehavior = class {
      /**
       *
       * @param query - The media query to operate from.
       */
      constructor(query) {
        this.listenerCache = /* @__PURE__ */ new WeakMap();
        this.query = query;
      }
      /**
       * Binds the behavior to the element.
       * @param source - The element for which the behavior is bound.
       */
      bind(source) {
        const { query } = this;
        const listener = this.constructListener(source);
        listener.bind(query)();
        query.addListener(listener);
        this.listenerCache.set(source, listener);
      }
      /**
       * Unbinds the behavior from the element.
       * @param source - The element for which the behavior is unbinding.
       */
      unbind(source) {
        const listener = this.listenerCache.get(source);
        if (listener) {
          this.query.removeListener(listener);
          this.listenerCache.delete(source);
        }
      }
    };
    MatchMediaStyleSheetBehavior = class extends MatchMediaBehavior {
      /**
       * Constructs a {@link MatchMediaStyleSheetBehavior} instance.
       * @param query - The media query to operate from.
       * @param styles - The styles to coordinate with the query.
       */
      constructor(query, styles) {
        super(query);
        this.styles = styles;
      }
      /**
       * Defines a function to construct {@link MatchMediaStyleSheetBehavior | MatchMediaStyleSheetBehaviors} for
       * a provided query.
       * @param query - The media query to operate from.
       *
       * @public
       * @example
       *
       * ```ts
       * import { css } from "@microsoft/fast-element";
       * import { MatchMediaStyleSheetBehavior } from "@microsoft/fast-foundation";
       *
       * const landscapeBehavior = MatchMediaStyleSheetBehavior.with(
       *   window.matchMedia("(orientation: landscape)")
       * );
       * const styles = css`
       *   :host {
       *     width: 200px;
       *     height: 400px;
       *   }
       * `
       * .withBehaviors(landscapeBehavior(css`
       *   :host {
       *     width: 400px;
       *     height: 200px;
       *   }
       * `))
       * ```
       */
      static with(query) {
        return (styles) => {
          return new MatchMediaStyleSheetBehavior(query, styles);
        };
      }
      /**
       * Constructs a match-media listener for a provided element.
       * @param source - the element for which to attach or detach styles.
       * @internal
       */
      constructListener(source) {
        let attached = false;
        const styles = this.styles;
        return function listener() {
          const { matches: matches2 } = this;
          if (matches2 && !attached) {
            source.$fastController.addStyles(styles);
            attached = matches2;
          } else if (!matches2 && attached) {
            source.$fastController.removeStyles(styles);
            attached = matches2;
          }
        };
      }
      /**
       * Unbinds the behavior from the element.
       * @param source - The element for which the behavior is unbinding.
       * @internal
       */
      unbind(source) {
        super.unbind(source);
        source.$fastController.removeStyles(this.styles);
      }
    };
    forcedColorsStylesheetBehavior = MatchMediaStyleSheetBehavior.with(window.matchMedia("(forced-colors)"));
    darkModeStylesheetBehavior = MatchMediaStyleSheetBehavior.with(window.matchMedia("(prefers-color-scheme: dark)"));
    lightModeStylesheetBehavior = MatchMediaStyleSheetBehavior.with(window.matchMedia("(prefers-color-scheme: light)"));
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/property-stylesheet-behavior.js
var PropertyStyleSheetBehavior;
var init_property_stylesheet_behavior = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/property-stylesheet-behavior.js"() {
    init_esm();
    PropertyStyleSheetBehavior = class {
      /**
       * Constructs a {@link PropertyStyleSheetBehavior} instance.
       * @param propertyName - The property name to operate from.
       * @param value - The property value to operate from.
       * @param styles - The styles to coordinate with the property.
       */
      constructor(propertyName, value, styles) {
        this.propertyName = propertyName;
        this.value = value;
        this.styles = styles;
      }
      /**
       * Binds the behavior to the element.
       * @param elementInstance - The element for which the property is applied.
       */
      bind(elementInstance) {
        Observable.getNotifier(elementInstance).subscribe(this, this.propertyName);
        this.handleChange(elementInstance, this.propertyName);
      }
      /**
       * Unbinds the behavior from the element.
       * @param source - The element for which the behavior is unbinding.
       * @internal
       */
      unbind(source) {
        Observable.getNotifier(source).unsubscribe(this, this.propertyName);
        source.$fastController.removeStyles(this.styles);
      }
      /**
       * Change event for the provided element.
       * @param source - the element for which to attach or detach styles.
       * @param key - the key to lookup to know if the element already has the styles
       * @internal
       */
      handleChange(source, key2) {
        if (source[key2] === this.value) {
          source.$fastController.addStyles(this.styles);
        } else {
          source.$fastController.removeStyles(this.styles);
        }
      }
    };
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/disabled.js
var disabledCursor;
var init_disabled = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/disabled.js"() {
    disabledCursor = "not-allowed";
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/display.js
function display(displayValue) {
  return `${hidden}:host{display:${displayValue}}`;
}
var hidden;
var init_display = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/display.js"() {
    hidden = `:host([hidden]){display:none}`;
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/focus.js
var focusVisible;
var init_focus = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/focus.js"() {
    init_dist4();
    focusVisible = canUseFocusVisible() ? "focus-visible" : "focus";
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/index.js
var init_style2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/index.js"() {
    init_disabled();
    init_display();
    init_focus();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/index.js
var init_utilities = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/utilities/index.js"() {
    init_apply_mixins();
    init_composed_parent();
    init_match_media_stylesheet_behavior();
    init_property_stylesheet_behavior();
    init_style2();
    init_direction();
    init_whitespace_filter();
  }
});

// ../../node_modules/@microsoft/fast-foundation/dist/esm/index.js
var init_esm2 = __esm({
  "../../node_modules/@microsoft/fast-foundation/dist/esm/index.js"() {
    init_accordion_item2();
    init_accordion2();
    init_anchor2();
    init_anchored_region2();
    init_avatar2();
    init_badge2();
    init_breadcrumb_item2();
    init_breadcrumb2();
    init_button3();
    init_calendar2();
    init_card2();
    init_checkbox2();
    init_combobox2();
    init_data_grid2();
    init_design_system2();
    init_design_token();
    init_di2();
    init_dialog2();
    init_disclosure2();
    init_divider2();
    init_flipper2();
    init_form_associated2();
    init_foundation_element2();
    init_listbox_option2();
    init_listbox2();
    init_picker2();
    init_menu_item2();
    init_menu3();
    init_number_field2();
    init_patterns();
    init_progress_ring();
    init_progress();
    init_radio_group2();
    init_radio2();
    init_horizontal_scroll2();
    init_search3();
    init_select2();
    init_skeleton2();
    init_slider_label2();
    init_slider2();
    init_switch2();
    init_tab_panel2();
    init_tab3();
    init_tabs2();
    init_text_area2();
    init_text_field2();
    init_toolbar2();
    init_tooltip2();
    init_tree_item2();
    init_tree_view3();
    init_utilities();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/utilities/binary-search.js
function binarySearch(valuesToSearch, searchCondition, startIndex = 0, endIndex = valuesToSearch.length - 1) {
  if (endIndex === startIndex) {
    return valuesToSearch[startIndex];
  }
  const middleIndex = Math.floor((endIndex - startIndex) / 2) + startIndex;
  return searchCondition(valuesToSearch[middleIndex]) ? binarySearch(
    valuesToSearch,
    searchCondition,
    startIndex,
    middleIndex
    // include this index because it passed the search condition
  ) : binarySearch(
    valuesToSearch,
    searchCondition,
    middleIndex + 1,
    // exclude this index because it failed the search condition
    endIndex
  );
}
var init_binary_search = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/utilities/binary-search.js"() {
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/utilities/direction-by-is-dark.js
function directionByIsDark(color) {
  return isDark(color) ? -1 : 1;
}
var init_direction_by_is_dark = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/utilities/direction-by-is-dark.js"() {
    init_is_dark();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/palette.js
function create3(rOrSource, g, b) {
  if (typeof rOrSource === "number") {
    return PaletteRGB.from(SwatchRGB.create(rOrSource, g, b));
  } else {
    return PaletteRGB.from(rOrSource);
  }
}
function from(source) {
  return isSwatchRGB(source) ? PaletteRGBImpl.from(source) : PaletteRGBImpl.from(SwatchRGB.create(source.r, source.g, source.b));
}
var PaletteRGB, PaletteRGBImpl;
var init_palette2 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/palette.js"() {
    init_dist2();
    init_swatch();
    init_binary_search();
    init_direction_by_is_dark();
    init_relative_luminance();
    PaletteRGB = Object.freeze({
      create: create3,
      from
    });
    PaletteRGBImpl = class {
      /**
       *
       * @param source - The source color for the palette
       * @param swatches - All swatches in the palette
       */
      constructor(source, swatches) {
        this.closestIndexCache = /* @__PURE__ */ new Map();
        this.source = source;
        this.swatches = swatches;
        this.reversedSwatches = Object.freeze([...this.swatches].reverse());
        this.lastIndex = this.swatches.length - 1;
      }
      /**
       * {@inheritdoc Palette.colorContrast}
       */
      colorContrast(reference, contrastTarget, initialSearchIndex, direction2) {
        if (initialSearchIndex === void 0) {
          initialSearchIndex = this.closestIndexOf(reference);
        }
        let source = this.swatches;
        const endSearchIndex = this.lastIndex;
        let startSearchIndex = initialSearchIndex;
        if (direction2 === void 0) {
          direction2 = directionByIsDark(reference);
        }
        const condition = (value) => contrast(reference, value) >= contrastTarget;
        if (direction2 === -1) {
          source = this.reversedSwatches;
          startSearchIndex = endSearchIndex - startSearchIndex;
        }
        return binarySearch(source, condition, startSearchIndex, endSearchIndex);
      }
      /**
       * {@inheritdoc Palette.get}
       */
      get(index) {
        return this.swatches[index] || this.swatches[clamp(index, 0, this.lastIndex)];
      }
      /**
       * {@inheritdoc Palette.closestIndexOf}
       */
      closestIndexOf(reference) {
        if (this.closestIndexCache.has(reference.relativeLuminance)) {
          return this.closestIndexCache.get(reference.relativeLuminance);
        }
        let index = this.swatches.indexOf(reference);
        if (index !== -1) {
          this.closestIndexCache.set(reference.relativeLuminance, index);
          return index;
        }
        const closest = this.swatches.reduce((previous, next) => Math.abs(next.relativeLuminance - reference.relativeLuminance) < Math.abs(previous.relativeLuminance - reference.relativeLuminance) ? next : previous);
        index = this.swatches.indexOf(closest);
        this.closestIndexCache.set(reference.relativeLuminance, index);
        return index;
      }
      /**
       * Create a color palette from a provided swatch
       * @param source - The source swatch to create a palette from
       * @returns
       */
      static from(source) {
        return new PaletteRGBImpl(source, Object.freeze(new ComponentStateColorPalette({
          /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */
          baseColor: ColorRGBA64.fromObject(source)
        }).palette.map((x) => {
          const _x = parseColorHexRGB(x.toStringHexRGB());
          return SwatchRGB.create(_x.r, _x.g, _x.b);
        })));
      }
    };
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/accent-fill.js
function accentFill(palette, neutralPalette2, reference, hoverDelta, activeDelta, focusDelta, neutralFillRestDelta2, neutralFillHoverDelta2, neutralFillActiveDelta2) {
  const accent = palette.source;
  const referenceIndex = neutralPalette2.closestIndexOf(reference);
  const swapThreshold = Math.max(neutralFillRestDelta2, neutralFillHoverDelta2, neutralFillActiveDelta2);
  const direction2 = referenceIndex >= swapThreshold ? -1 : 1;
  const accentIndex = palette.closestIndexOf(accent);
  const hoverIndex = accentIndex;
  const restIndex = hoverIndex + direction2 * -1 * hoverDelta;
  const activeIndex = restIndex + direction2 * activeDelta;
  const focusIndex = restIndex + direction2 * focusDelta;
  return {
    rest: palette.get(restIndex),
    hover: palette.get(hoverIndex),
    active: palette.get(activeIndex),
    focus: palette.get(focusIndex)
  };
}
var init_accent_fill = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/accent-fill.js"() {
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/accent-foreground.js
function accentForeground(palette, reference, contrastTarget, restDelta, hoverDelta, activeDelta, focusDelta) {
  const accent = palette.source;
  const accentIndex = palette.closestIndexOf(accent);
  const direction2 = directionByIsDark(reference);
  const startIndex = accentIndex + (direction2 === 1 ? Math.min(restDelta, hoverDelta) : Math.max(direction2 * restDelta, direction2 * hoverDelta));
  const accessibleSwatch = palette.colorContrast(reference, contrastTarget, startIndex, direction2);
  const accessibleIndex1 = palette.closestIndexOf(accessibleSwatch);
  const accessibleIndex2 = accessibleIndex1 + direction2 * Math.abs(restDelta - hoverDelta);
  const indexOneIsRestState = direction2 === 1 ? restDelta < hoverDelta : direction2 * restDelta > direction2 * hoverDelta;
  let restIndex;
  let hoverIndex;
  if (indexOneIsRestState) {
    restIndex = accessibleIndex1;
    hoverIndex = accessibleIndex2;
  } else {
    restIndex = accessibleIndex2;
    hoverIndex = accessibleIndex1;
  }
  return {
    rest: palette.get(restIndex),
    hover: palette.get(hoverIndex),
    active: palette.get(restIndex + direction2 * activeDelta),
    focus: palette.get(restIndex + direction2 * focusDelta)
  };
}
var init_accent_foreground = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/accent-foreground.js"() {
    init_direction_by_is_dark();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/utilities/color-constants.js
var white, black, middleGrey, accentBase, errorBase;
var init_color_constants = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/utilities/color-constants.js"() {
    init_dist2();
    init_swatch();
    white = SwatchRGB.create(1, 1, 1);
    black = SwatchRGB.create(0, 0, 0);
    middleGrey = SwatchRGB.from(parseColorHexRGB("#808080"));
    accentBase = SwatchRGB.from(parseColorHexRGB("#DA1A5F"));
    errorBase = SwatchRGB.from(parseColorHexRGB("#D32F2F"));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/foreground-on-accent.js
function foregroundOnAccent(reference, contrastTarget) {
  return reference.contrast(white) >= contrastTarget ? white : black;
}
var init_foreground_on_accent = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/foreground-on-accent.js"() {
    init_color_constants();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-fill.js
function neutralFill(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta) {
  const referenceIndex = palette.closestIndexOf(reference);
  const threshold = Math.max(restDelta, hoverDelta, activeDelta, focusDelta);
  const direction2 = referenceIndex >= threshold ? -1 : 1;
  return {
    rest: palette.get(referenceIndex + direction2 * restDelta),
    hover: palette.get(referenceIndex + direction2 * hoverDelta),
    active: palette.get(referenceIndex + direction2 * activeDelta),
    focus: palette.get(referenceIndex + direction2 * focusDelta)
  };
}
var init_neutral_fill = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-fill.js"() {
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-fill-input.js
function neutralFillInput(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta) {
  const direction2 = directionByIsDark(reference);
  const referenceIndex = palette.closestIndexOf(reference);
  return {
    rest: palette.get(referenceIndex - direction2 * restDelta),
    hover: palette.get(referenceIndex - direction2 * hoverDelta),
    active: palette.get(referenceIndex - direction2 * activeDelta),
    focus: palette.get(referenceIndex - direction2 * focusDelta)
  };
}
var init_neutral_fill_input = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-fill-input.js"() {
    init_direction_by_is_dark();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-fill-layer.js
function neutralFillLayer(palette, reference, delta) {
  const referenceIndex = palette.closestIndexOf(reference);
  return palette.get(referenceIndex - (referenceIndex < delta ? delta * -1 : delta));
}
var init_neutral_fill_layer = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-fill-layer.js"() {
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-fill-stealth.js
function neutralFillStealth(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta, fillRestDelta, fillHoverDelta, fillActiveDelta, fillFocusDelta) {
  const swapThreshold = Math.max(restDelta, hoverDelta, activeDelta, focusDelta, fillRestDelta, fillHoverDelta, fillActiveDelta, fillFocusDelta);
  const referenceIndex = palette.closestIndexOf(reference);
  const direction2 = referenceIndex >= swapThreshold ? -1 : 1;
  return {
    rest: palette.get(referenceIndex + direction2 * restDelta),
    hover: palette.get(referenceIndex + direction2 * hoverDelta),
    active: palette.get(referenceIndex + direction2 * activeDelta),
    focus: palette.get(referenceIndex + direction2 * focusDelta)
  };
}
var init_neutral_fill_stealth = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-fill-stealth.js"() {
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-fill-contrast.js
function neutralFillContrast(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta) {
  const direction2 = directionByIsDark(reference);
  const accessibleIndex = palette.closestIndexOf(palette.colorContrast(reference, 4.5));
  const accessibleIndex2 = accessibleIndex + direction2 * Math.abs(restDelta - hoverDelta);
  const indexOneIsRest = direction2 === 1 ? restDelta < hoverDelta : direction2 * restDelta > direction2 * hoverDelta;
  let restIndex;
  let hoverIndex;
  if (indexOneIsRest) {
    restIndex = accessibleIndex;
    hoverIndex = accessibleIndex2;
  } else {
    restIndex = accessibleIndex2;
    hoverIndex = accessibleIndex;
  }
  return {
    rest: palette.get(restIndex),
    hover: palette.get(hoverIndex),
    active: palette.get(restIndex + direction2 * activeDelta),
    focus: palette.get(restIndex + direction2 * focusDelta)
  };
}
var init_neutral_fill_contrast = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-fill-contrast.js"() {
    init_direction_by_is_dark();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/focus-stroke.js
function focusStrokeOuter(palette, reference) {
  return palette.colorContrast(reference, 3.5);
}
function focusStrokeInner(palette, reference, focusColor) {
  return palette.colorContrast(focusColor, 3.5, palette.closestIndexOf(palette.source), directionByIsDark(reference) * -1);
}
var init_focus_stroke = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/focus-stroke.js"() {
    init_direction_by_is_dark();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-foreground.js
function neutralForeground(palette, reference) {
  return palette.colorContrast(reference, 14);
}
var init_neutral_foreground = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-foreground.js"() {
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-foreground-hint.js
function neutralForegroundHint(palette, reference) {
  return palette.colorContrast(reference, 4.5);
}
var init_neutral_foreground_hint = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-foreground-hint.js"() {
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-layer-card-container.js
function neutralLayerCardContainer(palette, relativeLuminance, layerDelta) {
  return palette.get(palette.closestIndexOf(baseLayerLuminanceSwatch(relativeLuminance)) + layerDelta);
}
var init_neutral_layer_card_container = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-layer-card-container.js"() {
    init_base_layer_luminance();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-layer-floating.js
function neutralLayerFloating(palette, relativeLuminance, layerDelta) {
  const cardIndex = palette.closestIndexOf(baseLayerLuminanceSwatch(relativeLuminance)) - layerDelta;
  return palette.get(cardIndex - layerDelta);
}
var init_neutral_layer_floating = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-layer-floating.js"() {
    init_base_layer_luminance();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-layer-1.js
function neutralLayer1(palette, baseLayerLuminance2) {
  return palette.get(palette.closestIndexOf(baseLayerLuminanceSwatch(baseLayerLuminance2)));
}
var init_neutral_layer_1 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-layer-1.js"() {
    init_base_layer_luminance();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-layer-2.js
function neutralLayer2Index(palette, luminance, layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta) {
  return Math.max(palette.closestIndexOf(baseLayerLuminanceSwatch(luminance)) + layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta);
}
function neutralLayer2(palette, luminance, layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta) {
  return palette.get(neutralLayer2Index(palette, luminance, layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta));
}
var init_neutral_layer_2 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-layer-2.js"() {
    init_base_layer_luminance();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-layer-3.js
function neutralLayer3(palette, luminance, layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta) {
  return palette.get(neutralLayer2Index(palette, luminance, layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta) + layerDelta);
}
var init_neutral_layer_3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-layer-3.js"() {
    init_neutral_layer_2();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-layer-4.js
function neutralLayer4(palette, luminance, layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta) {
  return palette.get(neutralLayer2Index(palette, luminance, layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta) + layerDelta * 2);
}
var init_neutral_layer_4 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-layer-4.js"() {
    init_neutral_layer_2();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-stroke.js
function neutralStroke(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta) {
  const referenceIndex = palette.closestIndexOf(reference);
  const direction2 = directionByIsDark(reference);
  const restIndex = referenceIndex + direction2 * restDelta;
  const hoverIndex = restIndex + direction2 * (hoverDelta - restDelta);
  const activeIndex = restIndex + direction2 * (activeDelta - restDelta);
  const focusIndex = restIndex + direction2 * (focusDelta - restDelta);
  return {
    rest: palette.get(restIndex),
    hover: palette.get(hoverIndex),
    active: palette.get(activeIndex),
    focus: palette.get(focusIndex)
  };
}
var init_neutral_stroke = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-stroke.js"() {
    init_direction_by_is_dark();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-stroke-divider.js
function neutralStrokeDivider(palette, reference, delta) {
  return palette.get(palette.closestIndexOf(reference) + directionByIsDark(reference) * delta);
}
var init_neutral_stroke_divider = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/neutral-stroke-divider.js"() {
    init_direction_by_is_dark();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/error-fill.js
function errorFillAlgorithm(palette, neutralPalette2, reference, hoverDelta, activeDelta, focusDelta, neutralFillRestDelta2, neutralFillHoverDelta2, neutralFillActiveDelta2) {
  const error = palette.source;
  const referenceIndex = neutralPalette2.closestIndexOf(reference);
  const swapThreshold = Math.max(neutralFillRestDelta2, neutralFillHoverDelta2, neutralFillActiveDelta2);
  const direction2 = referenceIndex >= swapThreshold ? -1 : 1;
  const errorIndex = palette.closestIndexOf(error);
  const hoverIndex = errorIndex;
  const restIndex = hoverIndex + direction2 * -1 * hoverDelta;
  const activeIndex = restIndex + direction2 * activeDelta;
  const focusIndex = restIndex + direction2 * focusDelta;
  return {
    rest: palette.get(restIndex),
    hover: palette.get(hoverIndex),
    active: palette.get(activeIndex),
    focus: palette.get(focusIndex)
  };
}
function errorForegroundAlgorithm(palette, reference, contrastTarget, restDelta, hoverDelta, activeDelta, focusDelta) {
  const error = palette.source;
  const errorIndex = palette.closestIndexOf(error);
  const direction2 = isDark(reference) ? -1 : 1;
  const startIndex = errorIndex + (direction2 === 1 ? Math.min(restDelta, hoverDelta) : Math.max(direction2 * restDelta, direction2 * hoverDelta));
  const accessibleSwatch = palette.colorContrast(reference, contrastTarget, startIndex, direction2);
  const accessibleIndex1 = palette.closestIndexOf(accessibleSwatch);
  const accessibleIndex2 = accessibleIndex1 + direction2 * Math.abs(restDelta - hoverDelta);
  const indexOneIsRestState = direction2 === 1 ? restDelta < hoverDelta : direction2 * restDelta > direction2 * hoverDelta;
  let restIndex;
  let hoverIndex;
  if (indexOneIsRestState) {
    restIndex = accessibleIndex1;
    hoverIndex = accessibleIndex2;
  } else {
    restIndex = accessibleIndex2;
    hoverIndex = accessibleIndex1;
  }
  return {
    rest: palette.get(restIndex),
    hover: palette.get(hoverIndex),
    active: palette.get(restIndex + direction2 * activeDelta),
    focus: palette.get(restIndex + direction2 * focusDelta)
  };
}
var init_error_fill = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/error-fill.js"() {
    init_is_dark();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/color/recipes/foreground-on-error.js
function foregroundOnErrorAlgorithm(reference, contrastTarget) {
  return reference.contrast(white) >= contrastTarget ? white : black;
}
var init_foreground_on_error = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/color/recipes/foreground-on-error.js"() {
    init_color_constants();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/design-tokens.js
function createNonCss(name2) {
  return DesignToken.create({ name: name2, cssCustomPropertyName: null });
}
var create4, bodyFont, baseHeightMultiplier, baseHorizontalSpacingMultiplier, baseLayerLuminance, controlCornerRadius, density, designUnit, direction, disabledOpacity, strokeWidth, focusStrokeWidth, typeRampBaseFontSize, typeRampBaseLineHeight, typeRampMinus1FontSize, typeRampMinus1LineHeight, typeRampMinus2FontSize, typeRampMinus2LineHeight, typeRampPlus1FontSize, typeRampPlus1LineHeight, typeRampPlus2FontSize, typeRampPlus2LineHeight, typeRampPlus3FontSize, typeRampPlus3LineHeight, typeRampPlus4FontSize, typeRampPlus4LineHeight, typeRampPlus5FontSize, typeRampPlus5LineHeight, typeRampPlus6FontSize, typeRampPlus6LineHeight, accentFillRestDelta, accentFillHoverDelta, accentFillActiveDelta, accentFillFocusDelta, accentForegroundRestDelta, accentForegroundHoverDelta, accentForegroundActiveDelta, accentForegroundFocusDelta, neutralFillRestDelta, neutralFillHoverDelta, neutralFillActiveDelta, neutralFillFocusDelta, neutralFillInputRestDelta, neutralFillInputHoverDelta, neutralFillInputActiveDelta, neutralFillInputFocusDelta, neutralFillStealthRestDelta, neutralFillStealthHoverDelta, neutralFillStealthActiveDelta, neutralFillStealthFocusDelta, neutralFillStrongRestDelta, neutralFillStrongHoverDelta, neutralFillStrongActiveDelta, neutralFillStrongFocusDelta, neutralFillLayerRestDelta, neutralStrokeRestDelta, neutralStrokeHoverDelta, neutralStrokeActiveDelta, neutralStrokeFocusDelta, neutralStrokeDividerRestDelta, neutralColor, neutralPalette, accentColor, accentPalette, neutralLayerCardContainerRecipe, neutralLayerCardContainer2, neutralLayerFloatingRecipe, neutralLayerFloating2, neutralLayer1Recipe, neutralLayer12, neutralLayer2Recipe, neutralLayer22, neutralLayer3Recipe, neutralLayer32, neutralLayer4Recipe, neutralLayer42, fillColor, ContrastTarget, accentFillRecipe, accentFillRest, accentFillHover, accentFillActive, accentFillFocus, foregroundOnAccentByContrast, foregroundOnAccentRecipe, foregroundOnAccentRest, foregroundOnAccentHover, foregroundOnAccentActive, foregroundOnAccentFocus, foregroundOnAccentLargeRecipe, foregroundOnAccentRestLarge, foregroundOnAccentHoverLarge, foregroundOnAccentActiveLarge, foregroundOnAccentFocusLarge, accentForegroundByContrast, accentForegroundRecipe, accentForegroundRest, accentForegroundHover, accentForegroundActive, accentForegroundFocus, neutralFillRecipe, neutralFillRest, neutralFillHover, neutralFillActive, neutralFillFocus, neutralFillInputRecipe, neutralFillInputRest, neutralFillInputHover, neutralFillInputActive, neutralFillInputFocus, neutralFillStealthRecipe, neutralFillStealthRest, neutralFillStealthHover, neutralFillStealthActive, neutralFillStealthFocus, neutralFillStrongRecipe, neutralFillStrongRest, neutralFillStrongHover, neutralFillStrongActive, neutralFillStrongFocus, neutralFillLayerRecipe, neutralFillLayerRest, focusStrokeOuterRecipe, focusStrokeOuter2, focusStrokeInnerRecipe, focusStrokeInner2, neutralForegroundHintRecipe, neutralForegroundHint2, neutralForegroundRecipe, neutralForegroundRest, neutralStrokeRecipe, neutralStrokeRest, neutralStrokeHover, neutralStrokeActive, neutralStrokeFocus, neutralStrokeDividerRecipe, neutralStrokeDividerRest, heightNumberAsToken, errorColor, errorPalette, errorFillRecipe, errorFillRest, errorFillHover, errorFillActive, errorFillFocus, foregroundOnErrorByContrast, foregroundOnErrorRecipe, foregroundOnErrorRest, foregroundOnErrorHover, foregroundOnErrorActive, foregroundOnErrorFocus, foregroundOnErrorLargeRecipe, foregroundOnErrorRestLarge, foregroundOnErrorHoverLarge, foregroundOnErrorActiveLarge, foregroundOnErrorFocusLarge, errorForegroundByContrast, errorForegroundRecipe, errorForegroundRest, errorForegroundHover, errorForegroundActive, errorForegroundFocus;
var init_design_tokens = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/design-tokens.js"() {
    init_esm2();
    init_dist4();
    init_palette2();
    init_accent_fill();
    init_accent_foreground();
    init_foreground_on_accent();
    init_neutral_fill();
    init_neutral_fill_input();
    init_neutral_fill_layer();
    init_neutral_fill_stealth();
    init_neutral_fill_contrast();
    init_focus_stroke();
    init_neutral_foreground();
    init_neutral_foreground_hint();
    init_neutral_layer_card_container();
    init_neutral_layer_floating();
    init_neutral_layer_1();
    init_neutral_layer_2();
    init_neutral_layer_3();
    init_neutral_layer_4();
    init_neutral_stroke();
    init_neutral_stroke_divider();
    init_base_layer_luminance();
    init_color_constants();
    init_error_fill();
    init_foreground_on_error();
    ({ create: create4 } = DesignToken);
    bodyFont = create4("body-font").withDefault('aktiv-grotesk, "Segoe UI", Arial, Helvetica, sans-serif');
    baseHeightMultiplier = create4("base-height-multiplier").withDefault(10);
    baseHorizontalSpacingMultiplier = create4("base-horizontal-spacing-multiplier").withDefault(3);
    baseLayerLuminance = create4("base-layer-luminance").withDefault(StandardLuminance.DarkMode);
    controlCornerRadius = create4("control-corner-radius").withDefault(4);
    density = create4("density").withDefault(0);
    designUnit = create4("design-unit").withDefault(4);
    direction = create4("direction").withDefault(Direction.ltr);
    disabledOpacity = create4("disabled-opacity").withDefault(0.4);
    strokeWidth = create4("stroke-width").withDefault(1);
    focusStrokeWidth = create4("focus-stroke-width").withDefault(2);
    typeRampBaseFontSize = create4("type-ramp-base-font-size").withDefault("14px");
    typeRampBaseLineHeight = create4("type-ramp-base-line-height").withDefault("20px");
    typeRampMinus1FontSize = create4("type-ramp-minus-1-font-size").withDefault("12px");
    typeRampMinus1LineHeight = create4("type-ramp-minus-1-line-height").withDefault("16px");
    typeRampMinus2FontSize = create4("type-ramp-minus-2-font-size").withDefault("10px");
    typeRampMinus2LineHeight = create4("type-ramp-minus-2-line-height").withDefault("16px");
    typeRampPlus1FontSize = create4("type-ramp-plus-1-font-size").withDefault("16px");
    typeRampPlus1LineHeight = create4("type-ramp-plus-1-line-height").withDefault("24px");
    typeRampPlus2FontSize = create4("type-ramp-plus-2-font-size").withDefault("20px");
    typeRampPlus2LineHeight = create4("type-ramp-plus-2-line-height").withDefault("28px");
    typeRampPlus3FontSize = create4("type-ramp-plus-3-font-size").withDefault("28px");
    typeRampPlus3LineHeight = create4("type-ramp-plus-3-line-height").withDefault("36px");
    typeRampPlus4FontSize = create4("type-ramp-plus-4-font-size").withDefault("34px");
    typeRampPlus4LineHeight = create4("type-ramp-plus-4-line-height").withDefault("44px");
    typeRampPlus5FontSize = create4("type-ramp-plus-5-font-size").withDefault("46px");
    typeRampPlus5LineHeight = create4("type-ramp-plus-5-line-height").withDefault("56px");
    typeRampPlus6FontSize = create4("type-ramp-plus-6-font-size").withDefault("60px");
    typeRampPlus6LineHeight = create4("type-ramp-plus-6-line-height").withDefault("72px");
    accentFillRestDelta = createNonCss("accent-fill-rest-delta").withDefault(0);
    accentFillHoverDelta = createNonCss("accent-fill-hover-delta").withDefault(4);
    accentFillActiveDelta = createNonCss("accent-fill-active-delta").withDefault(-5);
    accentFillFocusDelta = createNonCss("accent-fill-focus-delta").withDefault(0);
    accentForegroundRestDelta = createNonCss("accent-foreground-rest-delta").withDefault(0);
    accentForegroundHoverDelta = createNonCss("accent-foreground-hover-delta").withDefault(6);
    accentForegroundActiveDelta = createNonCss("accent-foreground-active-delta").withDefault(-4);
    accentForegroundFocusDelta = createNonCss("accent-foreground-focus-delta").withDefault(0);
    neutralFillRestDelta = createNonCss("neutral-fill-rest-delta").withDefault(7);
    neutralFillHoverDelta = createNonCss("neutral-fill-hover-delta").withDefault(10);
    neutralFillActiveDelta = createNonCss("neutral-fill-active-delta").withDefault(5);
    neutralFillFocusDelta = createNonCss("neutral-fill-focus-delta").withDefault(0);
    neutralFillInputRestDelta = createNonCss("neutral-fill-input-rest-delta").withDefault(0);
    neutralFillInputHoverDelta = createNonCss("neutral-fill-input-hover-delta").withDefault(0);
    neutralFillInputActiveDelta = createNonCss("neutral-fill-input-active-delta").withDefault(0);
    neutralFillInputFocusDelta = createNonCss("neutral-fill-input-focus-delta").withDefault(0);
    neutralFillStealthRestDelta = createNonCss("neutral-fill-stealth-rest-delta").withDefault(0);
    neutralFillStealthHoverDelta = createNonCss("neutral-fill-stealth-hover-delta").withDefault(5);
    neutralFillStealthActiveDelta = createNonCss("neutral-fill-stealth-active-delta").withDefault(3);
    neutralFillStealthFocusDelta = createNonCss("neutral-fill-stealth-focus-delta").withDefault(0);
    neutralFillStrongRestDelta = createNonCss("neutral-fill-strong-rest-delta").withDefault(0);
    neutralFillStrongHoverDelta = createNonCss("neutral-fill-strong-hover-delta").withDefault(8);
    neutralFillStrongActiveDelta = createNonCss("neutral-fill-strong-active-delta").withDefault(-5);
    neutralFillStrongFocusDelta = createNonCss("neutral-fill-strong-focus-delta").withDefault(0);
    neutralFillLayerRestDelta = createNonCss("neutral-fill-layer-rest-delta").withDefault(3);
    neutralStrokeRestDelta = createNonCss("neutral-stroke-rest-delta").withDefault(25);
    neutralStrokeHoverDelta = createNonCss("neutral-stroke-hover-delta").withDefault(40);
    neutralStrokeActiveDelta = createNonCss("neutral-stroke-active-delta").withDefault(16);
    neutralStrokeFocusDelta = createNonCss("neutral-stroke-focus-delta").withDefault(25);
    neutralStrokeDividerRestDelta = createNonCss("neutral-stroke-divider-rest-delta").withDefault(8);
    neutralColor = create4("neutral-color").withDefault(middleGrey);
    neutralPalette = createNonCss("neutral-palette").withDefault((element) => PaletteRGB.from(neutralColor.getValueFor(element)));
    accentColor = create4("accent-color").withDefault(accentBase);
    accentPalette = createNonCss("accent-palette").withDefault((element) => PaletteRGB.from(accentColor.getValueFor(element)));
    neutralLayerCardContainerRecipe = createNonCss("neutral-layer-card-container-recipe").withDefault({
      evaluate: (element) => neutralLayerCardContainer(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element))
    });
    neutralLayerCardContainer2 = create4("neutral-layer-card-container").withDefault((element) => neutralLayerCardContainerRecipe.getValueFor(element).evaluate(element));
    neutralLayerFloatingRecipe = createNonCss("neutral-layer-floating-recipe").withDefault({
      evaluate: (element) => neutralLayerFloating(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element))
    });
    neutralLayerFloating2 = create4("neutral-layer-floating").withDefault((element) => neutralLayerFloatingRecipe.getValueFor(element).evaluate(element));
    neutralLayer1Recipe = createNonCss("neutral-layer-1-recipe").withDefault({
      evaluate: (element) => neutralLayer1(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element))
    });
    neutralLayer12 = create4("neutral-layer-1").withDefault((element) => neutralLayer1Recipe.getValueFor(element).evaluate(element));
    neutralLayer2Recipe = createNonCss("neutral-layer-2-recipe").withDefault({
      evaluate: (element) => neutralLayer2(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element))
    });
    neutralLayer22 = create4("neutral-layer-2").withDefault((element) => neutralLayer2Recipe.getValueFor(element).evaluate(element));
    neutralLayer3Recipe = createNonCss("neutral-layer-3-recipe").withDefault({
      evaluate: (element) => neutralLayer3(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element))
    });
    neutralLayer32 = create4("neutral-layer-3").withDefault((element) => neutralLayer3Recipe.getValueFor(element).evaluate(element));
    neutralLayer4Recipe = createNonCss("neutral-layer-4-recipe").withDefault({
      evaluate: (element) => neutralLayer4(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element))
    });
    neutralLayer42 = create4("neutral-layer-4").withDefault((element) => neutralLayer4Recipe.getValueFor(element).evaluate(element));
    fillColor = create4("fill-color").withDefault((element) => neutralLayer12.getValueFor(element));
    (function(ContrastTarget2) {
      ContrastTarget2[ContrastTarget2["normal"] = 4.5] = "normal";
      ContrastTarget2[ContrastTarget2["large"] = 7] = "large";
    })(ContrastTarget || (ContrastTarget = {}));
    accentFillRecipe = create4({
      name: "accent-fill-recipe",
      cssCustomPropertyName: null
    }).withDefault({
      evaluate: (element, reference) => accentFill(accentPalette.getValueFor(element), neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), accentFillHoverDelta.getValueFor(element), accentFillActiveDelta.getValueFor(element), accentFillFocusDelta.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element))
    });
    accentFillRest = create4("accent-fill-rest").withDefault((element) => {
      return accentFillRecipe.getValueFor(element).evaluate(element).rest;
    });
    accentFillHover = create4("accent-fill-hover").withDefault((element) => {
      return accentFillRecipe.getValueFor(element).evaluate(element).hover;
    });
    accentFillActive = create4("accent-fill-active").withDefault((element) => {
      return accentFillRecipe.getValueFor(element).evaluate(element).active;
    });
    accentFillFocus = create4("accent-fill-focus").withDefault((element) => {
      return accentFillRecipe.getValueFor(element).evaluate(element).focus;
    });
    foregroundOnAccentByContrast = (contrast2) => (element, reference) => {
      return foregroundOnAccent(reference || accentFillRest.getValueFor(element), contrast2);
    };
    foregroundOnAccentRecipe = createNonCss("foreground-on-accent-recipe").withDefault({
      evaluate: (element, reference) => foregroundOnAccentByContrast(ContrastTarget.normal)(element, reference)
    });
    foregroundOnAccentRest = create4("foreground-on-accent-rest").withDefault((element) => foregroundOnAccentRecipe.getValueFor(element).evaluate(element, accentFillRest.getValueFor(element)));
    foregroundOnAccentHover = create4("foreground-on-accent-hover").withDefault((element) => foregroundOnAccentRecipe.getValueFor(element).evaluate(element, accentFillHover.getValueFor(element)));
    foregroundOnAccentActive = create4("foreground-on-accent-active").withDefault((element) => foregroundOnAccentRecipe.getValueFor(element).evaluate(element, accentFillActive.getValueFor(element)));
    foregroundOnAccentFocus = create4("foreground-on-accent-focus").withDefault((element) => foregroundOnAccentRecipe.getValueFor(element).evaluate(element, accentFillFocus.getValueFor(element)));
    foregroundOnAccentLargeRecipe = createNonCss("foreground-on-accent-large-recipe").withDefault({
      evaluate: (element, reference) => foregroundOnAccentByContrast(ContrastTarget.large)(element, reference)
    });
    foregroundOnAccentRestLarge = create4("foreground-on-accent-rest-large").withDefault((element) => foregroundOnAccentLargeRecipe.getValueFor(element).evaluate(element, accentFillRest.getValueFor(element)));
    foregroundOnAccentHoverLarge = create4("foreground-on-accent-hover-large").withDefault((element) => foregroundOnAccentLargeRecipe.getValueFor(element).evaluate(element, accentFillHover.getValueFor(element)));
    foregroundOnAccentActiveLarge = create4("foreground-on-accent-active-large").withDefault((element) => foregroundOnAccentLargeRecipe.getValueFor(element).evaluate(element, accentFillActive.getValueFor(element)));
    foregroundOnAccentFocusLarge = create4("foreground-on-accent-focus-large").withDefault((element) => foregroundOnAccentLargeRecipe.getValueFor(element).evaluate(element, accentFillFocus.getValueFor(element)));
    accentForegroundByContrast = (contrast2) => (element, reference) => accentForeground(accentPalette.getValueFor(element), reference || fillColor.getValueFor(element), contrast2, accentForegroundRestDelta.getValueFor(element), accentForegroundHoverDelta.getValueFor(element), accentForegroundActiveDelta.getValueFor(element), accentForegroundFocusDelta.getValueFor(element));
    accentForegroundRecipe = create4({
      name: "accent-foreground-recipe",
      cssCustomPropertyName: null
    }).withDefault({
      evaluate: (element, reference) => accentForegroundByContrast(ContrastTarget.normal)(element, reference)
    });
    accentForegroundRest = create4("accent-foreground-rest").withDefault((element) => accentForegroundRecipe.getValueFor(element).evaluate(element).rest);
    accentForegroundHover = create4("accent-foreground-hover").withDefault((element) => accentForegroundRecipe.getValueFor(element).evaluate(element).hover);
    accentForegroundActive = create4("accent-foreground-active").withDefault((element) => accentForegroundRecipe.getValueFor(element).evaluate(element).active);
    accentForegroundFocus = create4("accent-foreground-focus").withDefault((element) => accentForegroundRecipe.getValueFor(element).evaluate(element).focus);
    neutralFillRecipe = create4({
      name: "neutral-fill-recipe",
      cssCustomPropertyName: null
    }).withDefault({
      evaluate: (element, reference) => neutralFill(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element), neutralFillFocusDelta.getValueFor(element))
    });
    neutralFillRest = create4("neutral-fill-rest").withDefault((element) => neutralFillRecipe.getValueFor(element).evaluate(element).rest);
    neutralFillHover = create4("neutral-fill-hover").withDefault((element) => neutralFillRecipe.getValueFor(element).evaluate(element).hover);
    neutralFillActive = create4("neutral-fill-active").withDefault((element) => neutralFillRecipe.getValueFor(element).evaluate(element).active);
    neutralFillFocus = create4("neutral-fill-focus").withDefault((element) => neutralFillRecipe.getValueFor(element).evaluate(element).focus);
    neutralFillInputRecipe = create4({
      name: "neutral-fill-input-recipe",
      cssCustomPropertyName: null
    }).withDefault({
      evaluate: (element, reference) => neutralFillInput(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillInputRestDelta.getValueFor(element), neutralFillInputHoverDelta.getValueFor(element), neutralFillInputActiveDelta.getValueFor(element), neutralFillInputFocusDelta.getValueFor(element))
    });
    neutralFillInputRest = create4("neutral-fill-input-rest").withDefault((element) => neutralFillInputRecipe.getValueFor(element).evaluate(element).rest);
    neutralFillInputHover = create4("neutral-fill-input-hover").withDefault((element) => neutralFillInputRecipe.getValueFor(element).evaluate(element).hover);
    neutralFillInputActive = create4("neutral-fill-input-active").withDefault((element) => neutralFillInputRecipe.getValueFor(element).evaluate(element).active);
    neutralFillInputFocus = create4("neutral-fill-input-focus").withDefault((element) => neutralFillInputRecipe.getValueFor(element).evaluate(element).focus);
    neutralFillStealthRecipe = create4({
      name: "neutral-fill-stealth-recipe",
      cssCustomPropertyName: null
    }).withDefault({
      evaluate: (element, reference) => neutralFillStealth(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillStealthRestDelta.getValueFor(element), neutralFillStealthHoverDelta.getValueFor(element), neutralFillStealthActiveDelta.getValueFor(element), neutralFillStealthFocusDelta.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element), neutralFillFocusDelta.getValueFor(element))
    });
    neutralFillStealthRest = create4("neutral-fill-stealth-rest").withDefault((element) => neutralFillStealthRecipe.getValueFor(element).evaluate(element).rest);
    neutralFillStealthHover = create4("neutral-fill-stealth-hover").withDefault((element) => neutralFillStealthRecipe.getValueFor(element).evaluate(element).hover);
    neutralFillStealthActive = create4("neutral-fill-stealth-active").withDefault((element) => neutralFillStealthRecipe.getValueFor(element).evaluate(element).active);
    neutralFillStealthFocus = create4("neutral-fill-stealth-focus").withDefault((element) => neutralFillStealthRecipe.getValueFor(element).evaluate(element).focus);
    neutralFillStrongRecipe = create4({
      name: "neutral-fill-strong-recipe",
      cssCustomPropertyName: null
    }).withDefault({
      evaluate: (element, reference) => neutralFillContrast(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillStrongRestDelta.getValueFor(element), neutralFillStrongHoverDelta.getValueFor(element), neutralFillStrongActiveDelta.getValueFor(element), neutralFillStrongFocusDelta.getValueFor(element))
    });
    neutralFillStrongRest = create4("neutral-fill-strong-rest").withDefault((element) => neutralFillStrongRecipe.getValueFor(element).evaluate(element).rest);
    neutralFillStrongHover = create4("neutral-fill-strong-hover").withDefault((element) => neutralFillStrongRecipe.getValueFor(element).evaluate(element).hover);
    neutralFillStrongActive = create4("neutral-fill-strong-active").withDefault((element) => neutralFillStrongRecipe.getValueFor(element).evaluate(element).active);
    neutralFillStrongFocus = create4("neutral-fill-strong-focus").withDefault((element) => neutralFillStrongRecipe.getValueFor(element).evaluate(element).focus);
    neutralFillLayerRecipe = createNonCss("neutral-fill-layer-recipe").withDefault({
      evaluate: (element, reference) => neutralFillLayer(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element))
    });
    neutralFillLayerRest = create4("neutral-fill-layer-rest").withDefault((element) => neutralFillLayerRecipe.getValueFor(element).evaluate(element));
    focusStrokeOuterRecipe = createNonCss("focus-stroke-outer-recipe").withDefault({
      evaluate: (element) => focusStrokeOuter(neutralPalette.getValueFor(element), fillColor.getValueFor(element))
    });
    focusStrokeOuter2 = create4("focus-stroke-outer").withDefault((element) => focusStrokeOuterRecipe.getValueFor(element).evaluate(element));
    focusStrokeInnerRecipe = createNonCss("focus-stroke-inner-recipe").withDefault({
      evaluate: (element) => focusStrokeInner(accentPalette.getValueFor(element), fillColor.getValueFor(element), focusStrokeOuter2.getValueFor(element))
    });
    focusStrokeInner2 = create4("focus-stroke-inner").withDefault((element) => focusStrokeInnerRecipe.getValueFor(element).evaluate(element));
    neutralForegroundHintRecipe = createNonCss("neutral-foreground-hint-recipe").withDefault({
      evaluate: (element) => neutralForegroundHint(neutralPalette.getValueFor(element), fillColor.getValueFor(element))
    });
    neutralForegroundHint2 = create4("neutral-foreground-hint").withDefault((element) => neutralForegroundHintRecipe.getValueFor(element).evaluate(element));
    neutralForegroundRecipe = createNonCss("neutral-foreground-recipe").withDefault({
      evaluate: (element) => neutralForeground(neutralPalette.getValueFor(element), fillColor.getValueFor(element))
    });
    neutralForegroundRest = create4("neutral-foreground-rest").withDefault((element) => neutralForegroundRecipe.getValueFor(element).evaluate(element));
    neutralStrokeRecipe = create4({
      name: "neutral-stroke-recipe",
      cssCustomPropertyName: null
    }).withDefault({
      evaluate: (element) => {
        return neutralStroke(neutralPalette.getValueFor(element), fillColor.getValueFor(element), neutralStrokeRestDelta.getValueFor(element), neutralStrokeHoverDelta.getValueFor(element), neutralStrokeActiveDelta.getValueFor(element), neutralStrokeFocusDelta.getValueFor(element));
      }
    });
    neutralStrokeRest = create4("neutral-stroke-rest").withDefault((element) => neutralStrokeRecipe.getValueFor(element).evaluate(element).rest);
    neutralStrokeHover = create4("neutral-stroke-hover").withDefault((element) => neutralStrokeRecipe.getValueFor(element).evaluate(element).hover);
    neutralStrokeActive = create4("neutral-stroke-active").withDefault((element) => neutralStrokeRecipe.getValueFor(element).evaluate(element).active);
    neutralStrokeFocus = create4("neutral-stroke-focus").withDefault((element) => neutralStrokeRecipe.getValueFor(element).evaluate(element).focus);
    neutralStrokeDividerRecipe = createNonCss("neutral-stroke-divider-recipe").withDefault({
      evaluate: (element, reference) => neutralStrokeDivider(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralStrokeDividerRestDelta.getValueFor(element))
    });
    neutralStrokeDividerRest = create4("neutral-stroke-divider-rest").withDefault((element) => neutralStrokeDividerRecipe.getValueFor(element).evaluate(element));
    heightNumberAsToken = DesignToken.create({
      name: "height-number",
      cssCustomPropertyName: null
    }).withDefault((target2) => (baseHeightMultiplier.getValueFor(target2) + density.getValueFor(target2)) * designUnit.getValueFor(target2));
    errorColor = create4("error-color").withDefault(errorBase);
    errorPalette = createNonCss("error-palette").withDefault((element) => PaletteRGB.from(errorColor.getValueFor(element)));
    errorFillRecipe = create4({
      name: "error-fill-recipe",
      cssCustomPropertyName: null
    }).withDefault({
      evaluate: (element, reference) => errorFillAlgorithm(errorPalette.getValueFor(element), neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), accentFillHoverDelta.getValueFor(element), accentFillActiveDelta.getValueFor(element), accentFillFocusDelta.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element))
    });
    errorFillRest = create4("error-fill-rest").withDefault((element) => {
      return errorFillRecipe.getValueFor(element).evaluate(element).rest;
    });
    errorFillHover = create4("error-fill-hover").withDefault((element) => {
      return errorFillRecipe.getValueFor(element).evaluate(element).hover;
    });
    errorFillActive = create4("error-fill-active").withDefault((element) => {
      return errorFillRecipe.getValueFor(element).evaluate(element).active;
    });
    errorFillFocus = create4("error-fill-focus").withDefault((element) => {
      return errorFillRecipe.getValueFor(element).evaluate(element).focus;
    });
    foregroundOnErrorByContrast = (contrast2) => (element, reference) => {
      return foregroundOnErrorAlgorithm(reference || errorFillRest.getValueFor(element), contrast2);
    };
    foregroundOnErrorRecipe = create4({
      name: "foreground-on-error-recipe",
      cssCustomPropertyName: null
    }).withDefault({
      evaluate: (element, reference) => foregroundOnErrorByContrast(ContrastTarget.normal)(element, reference)
    });
    foregroundOnErrorRest = create4("foreground-on-error-rest").withDefault((element) => foregroundOnErrorRecipe.getValueFor(element).evaluate(element, errorFillRest.getValueFor(element)));
    foregroundOnErrorHover = create4("foreground-on-error-hover").withDefault((element) => foregroundOnErrorRecipe.getValueFor(element).evaluate(element, errorFillHover.getValueFor(element)));
    foregroundOnErrorActive = create4("foreground-on-error-active").withDefault((element) => foregroundOnErrorRecipe.getValueFor(element).evaluate(element, errorFillActive.getValueFor(element)));
    foregroundOnErrorFocus = create4("foreground-on-error-focus").withDefault((element) => foregroundOnErrorRecipe.getValueFor(element).evaluate(element, errorFillFocus.getValueFor(element)));
    foregroundOnErrorLargeRecipe = create4({
      name: "foreground-on-error-large-recipe",
      cssCustomPropertyName: null
    }).withDefault({
      evaluate: (element, reference) => foregroundOnErrorByContrast(ContrastTarget.large)(element, reference)
    });
    foregroundOnErrorRestLarge = create4("foreground-on-error-rest-large").withDefault((element) => foregroundOnErrorLargeRecipe.getValueFor(element).evaluate(element, errorFillRest.getValueFor(element)));
    foregroundOnErrorHoverLarge = create4("foreground-on-error-hover-large").withDefault((element) => foregroundOnErrorLargeRecipe.getValueFor(element).evaluate(element, errorFillHover.getValueFor(element)));
    foregroundOnErrorActiveLarge = create4("foreground-on-error-active-large").withDefault((element) => foregroundOnErrorLargeRecipe.getValueFor(element).evaluate(element, errorFillActive.getValueFor(element)));
    foregroundOnErrorFocusLarge = create4("foreground-on-error-focus-large").withDefault((element) => foregroundOnErrorLargeRecipe.getValueFor(element).evaluate(element, errorFillFocus.getValueFor(element)));
    errorForegroundByContrast = (contrast2) => (element, reference) => errorForegroundAlgorithm(errorPalette.getValueFor(element), reference || fillColor.getValueFor(element), contrast2, accentForegroundRestDelta.getValueFor(element), accentForegroundHoverDelta.getValueFor(element), accentForegroundActiveDelta.getValueFor(element), accentForegroundFocusDelta.getValueFor(element));
    errorForegroundRecipe = create4({
      name: "error-foreground-recipe",
      cssCustomPropertyName: null
    }).withDefault({
      evaluate: (element, reference) => errorForegroundByContrast(ContrastTarget.normal)(element, reference)
    });
    errorForegroundRest = create4("error-foreground-rest").withDefault((element) => errorForegroundRecipe.getValueFor(element).evaluate(element).rest);
    errorForegroundHover = create4("error-foreground-hover").withDefault((element) => errorForegroundRecipe.getValueFor(element).evaluate(element).hover);
    errorForegroundActive = create4("error-foreground-active").withDefault((element) => errorForegroundRecipe.getValueFor(element).evaluate(element).active);
    errorForegroundFocus = create4("error-foreground-focus").withDefault((element) => errorForegroundRecipe.getValueFor(element).evaluate(element).focus);
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/utilities/theme/applyTheme.js
function addJupyterLabThemeChangeListener() {
  if (!isThemeChangeInitialized) {
    isThemeChangeInitialized = true;
    initThemeChangeListener();
  }
}
function initThemeChangeListener() {
  const addObserver = () => {
    const observer = new MutationObserver(() => {
      applyJupyterTheme();
    });
    observer.observe(document.body, {
      attributes: true,
      attributeFilter: [THEME_NAME_BODY_ATTRIBUTE],
      childList: false,
      characterData: false
    });
    applyJupyterTheme();
  };
  if (document.readyState === "complete") {
    addObserver();
  } else {
    window.addEventListener("load", addObserver);
  }
}
function applyJupyterTheme() {
  var _a;
  const styles = getComputedStyle(document.body);
  const themeMode = document.body.getAttribute(THEME_MODE_BODY_ATTRIBUTE);
  let isDark_ = false;
  if (themeMode) {
    isDark_ = themeMode === "false";
  } else {
    const layoutColor = styles.getPropertyValue(BASE_LAYOUT_COLOR).toString();
    if (layoutColor) {
      const parsedColor = parseColor(layoutColor);
      if (parsedColor) {
        isDark_ = isDark(SwatchRGB.create(parsedColor.r, parsedColor.g, parsedColor.b));
        console.debug(`Theme is ${isDark_ ? "dark" : "light"} based on '${BASE_LAYOUT_COLOR}' value: ${layoutColor}.`);
      }
    }
  }
  baseLayerLuminance.setValueFor(document.body, isDark_ ? StandardLuminance.DarkMode : StandardLuminance.LightMode);
  for (const jpTokenName in tokenMappings) {
    const toolkitTokenName = tokenMappings[jpTokenName];
    const value = styles.getPropertyValue(jpTokenName).toString();
    if (document.body && value !== "") {
      const parsedValue = ((_a = toolkitTokenName.converter) !== null && _a !== void 0 ? _a : (v) => v)(value.trim(), isDark_);
      if (parsedValue !== null) {
        toolkitTokenName.token.setValueFor(document.body, parsedValue);
      } else {
        console.error(`Fail to parse value '${value}' for '${jpTokenName}' as FAST design token.`);
      }
    }
  }
}
var THEME_NAME_BODY_ATTRIBUTE, THEME_MODE_BODY_ATTRIBUTE, BASE_LAYOUT_COLOR, isThemeChangeInitialized, intConverter, tokenMappings;
var init_applyTheme = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/utilities/theme/applyTheme.js"() {
    init_dist2();
    init_swatch();
    init_base_layer_luminance();
    init_is_dark();
    init_design_tokens();
    THEME_NAME_BODY_ATTRIBUTE = "data-jp-theme-name";
    THEME_MODE_BODY_ATTRIBUTE = "data-jp-theme-light";
    BASE_LAYOUT_COLOR = "--jp-layout-color1";
    isThemeChangeInitialized = false;
    intConverter = (value) => {
      const parsedValue = parseInt(value, 10);
      return isNaN(parsedValue) ? null : parsedValue;
    };
    tokenMappings = {
      "--jp-border-width": {
        converter: intConverter,
        token: strokeWidth
      },
      "--jp-border-radius": {
        converter: intConverter,
        token: controlCornerRadius
      },
      [BASE_LAYOUT_COLOR]: {
        converter: (value, isDark2) => {
          const parsedColor = parseColor(value);
          if (parsedColor) {
            const hsl = rgbToHSL(parsedColor);
            const correctedHSL = ColorHSL.fromObject({
              h: hsl.h,
              s: hsl.s,
              l: 0.5
            });
            const correctedRGB = hslToRGB(correctedHSL);
            return SwatchRGB.create(correctedRGB.r, correctedRGB.g, correctedRGB.b);
          } else {
            return null;
          }
        },
        token: neutralColor
      },
      "--jp-brand-color1": {
        converter: (value, isDark2) => {
          const parsedColor = parseColor(value);
          if (parsedColor) {
            const hsl = rgbToHSL(parsedColor);
            const direction2 = isDark2 ? 1 : -1;
            const correctedHSL = ColorHSL.fromObject({
              h: hsl.h,
              s: hsl.s,
              l: hsl.l + direction2 * accentFillHoverDelta.getValueFor(document.body) / 94
            });
            const correctedRGB = hslToRGB(correctedHSL);
            return SwatchRGB.create(correctedRGB.r, correctedRGB.g, correctedRGB.b);
          } else {
            return null;
          }
        },
        token: accentColor
      },
      "--jp-error-color1": {
        converter: (value, isDark2) => {
          const parsedColor = parseColor(value);
          if (parsedColor) {
            const hsl = rgbToHSL(parsedColor);
            const direction2 = isDark2 ? 1 : -1;
            const correctedHSL = ColorHSL.fromObject({
              h: hsl.h,
              s: hsl.s,
              l: hsl.l + direction2 * accentFillHoverDelta.getValueFor(document.body) / 94
            });
            const correctedRGB = hslToRGB(correctedHSL);
            return SwatchRGB.create(correctedRGB.r, correctedRGB.g, correctedRGB.b);
          } else {
            return null;
          }
        },
        token: errorColor
      },
      "--jp-ui-font-family": {
        token: bodyFont
      },
      "--jp-ui-font-size1": {
        token: typeRampBaseFontSize
      }
    };
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/accordion/accordion.styles.js
var accordionStyles;
var init_accordion_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/accordion/accordion.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    accordionStyles = (context, definition) => css`
  ${display("flex")} :host {
    box-sizing: border-box;
    flex-direction: column;
    font-family: ${bodyFont};
    font-size: ${typeRampMinus1FontSize};
    line-height: ${typeRampMinus1LineHeight};
    color: ${neutralForegroundRest};
    border-top: calc(${strokeWidth} * 1px) solid ${neutralStrokeDividerRest};
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/styles/size.js
var heightNumber;
var init_size = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/styles/size.js"() {
    init_esm();
    init_design_tokens();
    heightNumber = cssPartial`(${baseHeightMultiplier} + ${density}) * ${designUnit}`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/accordion-item/accordion-item.styles.js
var accordionItemStyles;
var init_accordion_item_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/accordion-item/accordion-item.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_size();
    accordionItemStyles = (context, definition) => css`
    ${display("flex")} :host {
      box-sizing: border-box;
      font-family: ${bodyFont};
      flex-direction: column;
      font-size: ${typeRampMinus1FontSize};
      line-height: ${typeRampMinus1LineHeight};
      border-bottom: calc(${strokeWidth} * 1px) solid
        ${neutralStrokeDividerRest};
    }

    .region {
      display: none;
      padding: calc((6 + (${designUnit} * 2 * ${density})) * 1px);
    }

    div.heading {
      display: grid;
      position: relative;
      grid-template-columns: calc(${heightNumber} * 1px) auto 1fr auto;
      color: ${neutralForegroundRest};
    }

    .button {
      appearance: none;
      border: none;
      background: none;
      grid-column: 3;
      outline: none;
      padding: 0 calc((6 + (${designUnit} * 2 * ${density})) * 1px);
      text-align: left;
      height: calc(${heightNumber} * 1px);
      color: currentcolor;
      cursor: pointer;
      font-family: inherit;
    }

    .button:hover {
      color: currentcolor;
    }

    .button:active {
      color: currentcolor;
    }

    .button::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      cursor: pointer;
    }

    /* prettier-ignore */
    .button:${focusVisible}::before {
      outline: none;
      border: calc(${focusStrokeWidth} * 1px) solid ${accentFillFocus};
      border-radius: calc(${controlCornerRadius} * 1px);
    }

    :host([expanded]) .region {
      display: block;
    }

    .icon {
      display: flex;
      align-items: center;
      justify-content: center;
      grid-column: 1;
      grid-row: 1;
      pointer-events: none;
      position: relative;
    }

    slot[name='expanded-icon'],
    slot[name='collapsed-icon'] {
      fill: currentcolor;
    }

    slot[name='collapsed-icon'] {
      display: flex;
    }

    :host([expanded]) slot[name='collapsed-icon'] {
      display: none;
    }

    slot[name='expanded-icon'] {
      display: none;
    }

    :host([expanded]) slot[name='expanded-icon'] {
      display: flex;
    }

    .start {
      display: flex;
      align-items: center;
      padding-inline-start: calc(${designUnit} * 1px);
      justify-content: center;
      grid-column: 2;
      position: relative;
    }

    .end {
      display: flex;
      align-items: center;
      justify-content: center;
      grid-column: 4;
      position: relative;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      /* prettier-ignore */
      .button:${focusVisible}::before {
          border-color: ${SystemColors.Highlight};
        }
      :host slot[name='collapsed-icon'],
      :host([expanded]) slot[name='expanded-icon'] {
        fill: ${SystemColors.ButtonText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/accordion-item/index.js
var jpAccordionItem;
var init_accordion_item3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/accordion-item/index.js"() {
    init_esm2();
    init_accordion_item_styles();
    jpAccordionItem = AccordionItem.compose({
      baseName: "accordion-item",
      template: accordionItemTemplate,
      styles: accordionItemStyles,
      collapsedIcon: (
        /* html */
        `
        <svg
            width="20"
            height="20"
            viewBox="0 0 16 16"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M5.00001 12.3263C5.00124 12.5147 5.05566 12.699 5.15699 12.8578C5.25831 13.0167 5.40243 13.1437 5.57273 13.2242C5.74304 13.3047 5.9326 13.3354 6.11959 13.3128C6.30659 13.2902 6.4834 13.2152 6.62967 13.0965L10.8988 8.83532C11.0739 8.69473 11.2153 8.51658 11.3124 8.31402C11.4096 8.11146 11.46 7.88966 11.46 7.66499C11.46 7.44033 11.4096 7.21853 11.3124 7.01597C11.2153 6.81341 11.0739 6.63526 10.8988 6.49467L6.62967 2.22347C6.48274 2.10422 6.30501 2.02912 6.11712 2.00691C5.92923 1.9847 5.73889 2.01628 5.56823 2.09799C5.39757 2.17969 5.25358 2.30817 5.153 2.46849C5.05241 2.62882 4.99936 2.8144 5.00001 3.00369V12.3263Z"
            />
        </svg>
    `
      ),
      expandedIcon: (
        /* html */
        `
        <svg
            width="20"
            height="20"
            viewBox="0 0 16 16"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                transform="rotate(90,8,8)"
          d="M5.00001 12.3263C5.00124 12.5147 5.05566 12.699 5.15699 12.8578C5.25831 13.0167 5.40243 13.1437 5.57273 13.2242C5.74304 13.3047 5.9326 13.3354 6.11959 13.3128C6.30659 13.2902 6.4834 13.2152 6.62967 13.0965L10.8988 8.83532C11.0739 8.69473 11.2153 8.51658 11.3124 8.31402C11.4096 8.11146 11.46 7.88966 11.46 7.66499C11.46 7.44033 11.4096 7.21853 11.3124 7.01597C11.2153 6.81341 11.0739 6.63526 10.8988 6.49467L6.62967 2.22347C6.48274 2.10422 6.30501 2.02912 6.11712 2.00691C5.92923 1.9847 5.73889 2.01628 5.56823 2.09799C5.39757 2.17969 5.25358 2.30817 5.153 2.46849C5.05241 2.62882 4.99936 2.8144 5.00001 3.00369V12.3263Z"
            />
        </svg>
    `
      )
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/accordion/index.js
var jpAccordion;
var init_accordion3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/accordion/index.js"() {
    init_esm2();
    init_accordion_styles();
    init_accordion_item3();
    jpAccordion = Accordion.compose({
      baseName: "accordion",
      template: accordionTemplate,
      styles: accordionStyles
    });
  }
});

// ../../node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate2,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault2,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate2(decorators, target2, key2, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key2) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key2, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key2, r) : d(target2, key2)) || r;
  return c > 3 && r && Object.defineProperty(target2, key2, r), r;
}
function __param(paramIndex, decorator) {
  return function(target2, key2) {
    decorator(target2, key2, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key2 = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target2 = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target2 ? Object.getOwnPropertyDescriptor(target2, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key2], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key2] = _;
    }
  }
  if (target2)
    Object.defineProperty(target2, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name2, prefix) {
  if (typeof name2 === "symbol")
    name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m)
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
      __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault2(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async)
          return Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
      } catch (e) {
        fail(e);
      }
    }
    if (env.hasError)
      throw env.error;
  }
  return next();
}
var extendStatics, __assign, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
var init_tslib_es62 = __esm({
  "../../node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate: __decorate2,
      __param,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault: __importDefault2,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources
    };
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/styles/elevation.js
var ambientShadow, directionalShadow, elevation;
var init_elevation = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/styles/elevation.js"() {
    ambientShadow = "0 0 calc((var(--elevation) * 0.225px) + 2px) rgba(0, 0, 0, calc(.11 * (2 - var(--background-luminance, 1))))";
    directionalShadow = "0 calc(var(--elevation) * 0.4px) calc((var(--elevation) * 0.9px)) rgba(0, 0, 0, calc(.13 * (2 - var(--background-luminance, 1))))";
    elevation = `box-shadow: ${ambientShadow}, ${directionalShadow};`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/styles/patterns/button.js
var BaseButtonStyles, AccentButtonStyles, ErrorButtonStyles, HypertextStyles, LightweightButtonStyles, OutlineButtonStyles, StealthButtonStyles;
var init_button4 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/styles/patterns/button.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_size();
    BaseButtonStyles = css`
  ${display("inline-flex")} :host {
    font-family: ${bodyFont};
    outline: none;
    font-size: ${typeRampBaseFontSize};
    line-height: ${typeRampBaseLineHeight};
    height: calc(${heightNumber} * 1px);
    min-width: calc(${heightNumber} * 1px);
    background-color: ${neutralFillRest};
    color: ${neutralForegroundRest};
    border-radius: calc(${controlCornerRadius} * 1px);
    fill: currentcolor;
    cursor: pointer;
    margin: calc((${focusStrokeWidth} + 2) * 1px);
  }

  .control {
    background: transparent;
    height: inherit;
    flex-grow: 1;
    box-sizing: border-box;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    padding: 0 calc((10 + (${designUnit} * 2 * ${density})) * 1px);
    white-space: nowrap;
    outline: none;
    text-decoration: none;
    border: calc(${strokeWidth} * 1px) solid transparent;
    color: inherit;
    border-radius: inherit;
    fill: inherit;
    cursor: inherit;
    font-family: inherit;
    font-size: inherit;
    line-height: inherit;
  }

  :host(:hover) {
    background-color: ${neutralFillHover};
  }

  :host(:active) {
    background-color: ${neutralFillActive};
  }

  :host([aria-pressed='true']) {
    box-shadow: inset 0px 0px 2px 2px ${neutralFillStrongActive};
  }

  :host([minimal]) {
    --density: -4;
  }

  :host([minimal]) .control {
    padding: 1px;
  }

  /* prettier-ignore */
  .control:${focusVisible} {
      outline: calc(${focusStrokeWidth} * 1px) solid ${neutralFillStrongFocus};
      outline-offset: 2px;
      -moz-outline-radius: 0px;
    }

  .control::-moz-focus-inner {
    border: 0;
  }

  .start,
  .end {
    display: flex;
  }

  .control.icon-only {
    padding: 0;
    line-height: 0;
  }

  ::slotted(svg) {
    ${/* Glyph size and margin-left is temporary -
         replace when adaptive typography is figured out */
    ""} width: 16px;
    height: 16px;
    pointer-events: none;
  }

  .start {
    margin-inline-end: 11px;
  }

  .end {
    margin-inline-start: 11px;
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host .control {
      background-color: ${SystemColors.ButtonFace};
      border-color: ${SystemColors.ButtonText};
      color: ${SystemColors.ButtonText};
      fill: currentColor;
    }

    :host(:hover) .control {
      forced-color-adjust: none;
      background-color: ${SystemColors.Highlight};
      color: ${SystemColors.HighlightText};
    }

    /* prettier-ignore */
    .control:${focusVisible} {
          forced-color-adjust: none;
          background-color: ${SystemColors.Highlight};
          outline-color: ${SystemColors.ButtonText};
          color: ${SystemColors.HighlightText};
        }

    .control:hover,
    :host([appearance='outline']) .control:hover {
      border-color: ${SystemColors.ButtonText};
    }

    :host([href]) .control {
      border-color: ${SystemColors.LinkText};
      color: ${SystemColors.LinkText};
    }

    :host([href]) .control:hover,
        :host([href]) .control:${focusVisible} {
      forced-color-adjust: none;
      background: ${SystemColors.ButtonFace};
      outline-color: ${SystemColors.LinkText};
      color: ${SystemColors.LinkText};
      fill: currentColor;
    }
  `));
    AccentButtonStyles = css`
  :host([appearance='accent']) {
    background: ${accentFillRest};
    color: ${foregroundOnAccentRest};
  }

  :host([appearance='accent']:hover) {
    background: ${accentFillHover};
    color: ${foregroundOnAccentHover};
  }

  :host([appearance='accent'][aria-pressed='true']) {
    box-shadow: inset 0px 0px 2px 2px ${accentForegroundActive};
  }

  :host([appearance='accent']:active) .control:active {
    background: ${accentFillActive};
    color: ${foregroundOnAccentActive};
  }

  :host([appearance="accent"]) .control:${focusVisible} {
    outline-color: ${accentFillFocus};
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host([appearance='accent']) .control {
      forced-color-adjust: none;
      background: ${SystemColors.Highlight};
      color: ${SystemColors.HighlightText};
    }

    :host([appearance='accent']) .control:hover,
    :host([appearance='accent']:active) .control:active {
      background: ${SystemColors.HighlightText};
      border-color: ${SystemColors.Highlight};
      color: ${SystemColors.Highlight};
    }

    :host([appearance="accent"]) .control:${focusVisible} {
      outline-color: ${SystemColors.Highlight};
    }

    :host([appearance='accent'][href]) .control {
      background: ${SystemColors.LinkText};
      color: ${SystemColors.HighlightText};
    }

    :host([appearance='accent'][href]) .control:hover {
      background: ${SystemColors.ButtonFace};
      border-color: ${SystemColors.LinkText};
      box-shadow: none;
      color: ${SystemColors.LinkText};
      fill: currentColor;
    }

    :host([appearance="accent"][href]) .control:${focusVisible} {
      outline-color: ${SystemColors.HighlightText};
    }
  `));
    ErrorButtonStyles = css`
  :host([appearance='error']) {
    background: ${errorFillRest};
    color: ${foregroundOnAccentRest};
  }

  :host([appearance='error']:hover) {
    background: ${errorFillHover};
    color: ${foregroundOnAccentHover};
  }

  :host([appearance='error'][aria-pressed='true']) {
    box-shadow: inset 0px 0px 2px 2px ${errorForegroundActive};
  }

  :host([appearance='error']:active) .control:active {
    background: ${errorFillActive};
    color: ${foregroundOnAccentActive};
  }

  :host([appearance="error"]) .control:${focusVisible} {
    outline-color: ${errorFillFocus};
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host([appearance='error']) .control {
      forced-color-adjust: none;
      background: ${SystemColors.Highlight};
      color: ${SystemColors.HighlightText};
    }

    :host([appearance='error']) .control:hover,
    :host([appearance='error']:active) .control:active {
      background: ${SystemColors.HighlightText};
      border-color: ${SystemColors.Highlight};
      color: ${SystemColors.Highlight};
    }

    :host([appearance="error"]) .control:${focusVisible} {
      outline-color: ${SystemColors.Highlight};
    }

    :host([appearance='error'][href]) .control {
      background: ${SystemColors.LinkText};
      color: ${SystemColors.HighlightText};
    }

    :host([appearance='error'][href]) .control:hover {
      background: ${SystemColors.ButtonFace};
      border-color: ${SystemColors.LinkText};
      box-shadow: none;
      color: ${SystemColors.LinkText};
      fill: currentColor;
    }

    :host([appearance="error"][href]) .control:${focusVisible} {
      outline-color: ${SystemColors.HighlightText};
    }
  `));
    HypertextStyles = css`
  :host([appearance='hypertext']) {
    font-size: inherit;
    line-height: inherit;
    height: auto;
    min-width: 0;
    background: transparent;
  }

  :host([appearance='hypertext']) .control {
    display: inline;
    padding: 0;
    border: none;
    box-shadow: none;
    border-radius: 0;
    line-height: 1;
  }

  :host a.control:not(:link) {
    background-color: transparent;
    cursor: default;
  }
  :host([appearance='hypertext']) .control:link,
  :host([appearance='hypertext']) .control:visited {
    background: transparent;
    color: ${accentForegroundRest};
    border-bottom: calc(${strokeWidth} * 1px) solid ${accentForegroundRest};
  }

  :host([appearance='hypertext']:hover),
  :host([appearance='hypertext']) .control:hover {
    background: transparent;
    border-bottom-color: ${accentForegroundHover};
  }

  :host([appearance='hypertext']:active),
  :host([appearance='hypertext']) .control:active {
    background: transparent;
    border-bottom-color: ${accentForegroundActive};
  }

  :host([appearance="hypertext"]) .control:${focusVisible} {
    outline-color: transparent;
    border-bottom: calc(${focusStrokeWidth} * 1px) solid ${focusStrokeOuter2};
    margin-bottom: calc(calc(${strokeWidth} - ${focusStrokeWidth}) * 1px);
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host([appearance='hypertext']:hover) {
      background-color: ${SystemColors.ButtonFace};
      color: ${SystemColors.ButtonText};
    }
    :host([appearance="hypertext"][href]) .control:hover,
        :host([appearance="hypertext"][href]) .control:active,
        :host([appearance="hypertext"][href]) .control:${focusVisible} {
      color: ${SystemColors.LinkText};
      border-bottom-color: ${SystemColors.LinkText};
      box-shadow: none;
    }
  `));
    LightweightButtonStyles = css`
  :host([appearance='lightweight']) {
    background: transparent;
    color: ${accentForegroundRest};
  }

  :host([appearance='lightweight']) .control {
    padding: 0;
    height: initial;
    border: none;
    box-shadow: none;
    border-radius: 0;
  }

  :host([appearance='lightweight']:hover) {
    background: transparent;
    color: ${accentForegroundHover};
  }

  :host([appearance='lightweight']:active) {
    background: transparent;
    color: ${accentForegroundActive};
  }

  :host([appearance='lightweight']) .content {
    position: relative;
  }

  :host([appearance='lightweight']) .content::before {
    content: '';
    display: block;
    height: calc(${strokeWidth} * 1px);
    position: absolute;
    top: calc(1em + 4px);
    width: 100%;
  }

  :host([appearance='lightweight']:hover) .content::before {
    background: ${accentForegroundHover};
  }

  :host([appearance='lightweight']:active) .content::before {
    background: ${accentForegroundActive};
  }

  :host([appearance="lightweight"]) .control:${focusVisible} {
    outline-color: transparent;
  }

  :host([appearance="lightweight"]) .control:${focusVisible} .content::before {
    background: ${neutralForegroundRest};
    height: calc(${focusStrokeWidth} * 1px);
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host([appearance="lightweight"]) .control:hover,
        :host([appearance="lightweight"]) .control:${focusVisible} {
      forced-color-adjust: none;
      background: ${SystemColors.ButtonFace};
      color: ${SystemColors.Highlight};
    }
    :host([appearance="lightweight"]) .control:hover .content::before,
        :host([appearance="lightweight"]) .control:${focusVisible} .content::before {
      background: ${SystemColors.Highlight};
    }

    :host([appearance="lightweight"][href]) .control:hover,
        :host([appearance="lightweight"][href]) .control:${focusVisible} {
      background: ${SystemColors.ButtonFace};
      box-shadow: none;
      color: ${SystemColors.LinkText};
    }

    :host([appearance="lightweight"][href]) .control:hover .content::before,
        :host([appearance="lightweight"][href]) .control:${focusVisible} .content::before {
      background: ${SystemColors.LinkText};
    }
  `));
    OutlineButtonStyles = css`
  :host([appearance='outline']) {
    background: transparent;
    border-color: ${accentFillRest};
  }

  :host([appearance='outline']:hover) {
    border-color: ${accentFillHover};
  }

  :host([appearance='outline']:active) {
    border-color: ${accentFillActive};
  }

  :host([appearance='outline']) .control {
    border-color: inherit;
  }

  :host([appearance="outline"]) .control:${focusVisible} {
    outline-color: ${accentFillFocus};
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host([appearance='outline']) .control {
      border-color: ${SystemColors.ButtonText};
    }
    :host([appearance="outline"]) .control:${focusVisible} {
      forced-color-adjust: none;
      background-color: ${SystemColors.Highlight};
      outline-color: ${SystemColors.ButtonText};
      color: ${SystemColors.HighlightText};
      fill: currentColor;
    }
    :host([appearance='outline'][href]) .control {
      background: ${SystemColors.ButtonFace};
      border-color: ${SystemColors.LinkText};
      color: ${SystemColors.LinkText};
      fill: currentColor;
    }
    :host([appearance="outline"][href]) .control:hover,
        :host([appearance="outline"][href]) .control:${focusVisible} {
      forced-color-adjust: none;
      outline-color: ${SystemColors.LinkText};
    }
  `));
    StealthButtonStyles = css`
  :host([appearance='stealth']) {
    background: transparent;
  }

  :host([appearance='stealth']:hover) {
    background: ${neutralFillStealthHover};
  }

  :host([appearance='stealth']:active) {
    background: ${neutralFillStealthActive};
  }

  :host([appearance='stealth']) .control:${focusVisible} {
    outline-color: ${accentFillFocus};
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host([appearance='stealth']),
    :host([appearance='stealth']) .control {
      forced-color-adjust: none;
      background: ${SystemColors.ButtonFace};
      border-color: transparent;
      color: ${SystemColors.ButtonText};
      fill: currentColor;
    }

    :host([appearance='stealth']:hover) .control {
      background: ${SystemColors.Highlight};
      border-color: ${SystemColors.Highlight};
      color: ${SystemColors.HighlightText};
      fill: currentColor;
    }

    :host([appearance="stealth"]:${focusVisible}) .control {
      outline-color: ${SystemColors.Highlight};
      color: ${SystemColors.HighlightText};
      fill: currentColor;
    }

    :host([appearance='stealth'][href]) .control {
      color: ${SystemColors.LinkText};
    }

    :host([appearance="stealth"][href]:hover) .control,
        :host([appearance="stealth"][href]:${focusVisible}) .control {
      background: ${SystemColors.LinkText};
      border-color: ${SystemColors.LinkText};
      color: ${SystemColors.HighlightText};
      fill: currentColor;
    }

    :host([appearance="stealth"][href]:${focusVisible}) .control {
      forced-color-adjust: none;
      box-shadow: 0 0 0 1px ${SystemColors.LinkText};
    }
  `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/styles/patterns/field.js
var BaseFieldStyles;
var init_field = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/styles/patterns/field.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_size();
    BaseFieldStyles = css`
  ${display("inline-block")} :host {
    font-family: ${bodyFont};
    outline: none;
    user-select: none;
  }

  .root {
    box-sizing: border-box;
    position: relative;
    display: flex;
    flex-direction: row;
    color: ${neutralForegroundRest};
    background: ${neutralFillInputRest};
    border-radius: calc(${controlCornerRadius} * 1px);
    border: calc(${strokeWidth} * 1px) solid ${neutralFillStrongRest};
    height: calc(${heightNumber} * 1px);
  }

  :host([aria-invalid='true']) .root {
    border-color: ${errorFillRest};
  }

  .control {
    -webkit-appearance: none;
    font: inherit;
    background: transparent;
    border: 0;
    color: inherit;
    height: calc(100% - 4px);
    width: 100%;
    margin-top: auto;
    margin-bottom: auto;
    border: none;
    padding: 0 calc(${designUnit} * 2px + 1px);
    font-size: ${typeRampBaseFontSize};
    line-height: ${typeRampBaseLineHeight};
  }

  .control:hover,
  .control:${focusVisible},
  .control:disabled,
  .control:active {
    outline: none;
  }

  .label {
    display: block;
    color: ${neutralForegroundRest};
    cursor: pointer;
    font-size: ${typeRampBaseFontSize};
    line-height: ${typeRampBaseLineHeight};
    margin-bottom: 4px;
  }

  .label__hidden {
    display: none;
    visibility: hidden;
  }

  .start,
  .end {
    margin: auto;
    fill: currentcolor;
  }

  ::slotted(svg) {
    /* TODO: adaptive typography https://github.com/microsoft/fast/issues/2432 */
    width: 16px;
    height: 16px;
  }

  .start {
    margin-inline-start: 11px;
  }

  .end {
    margin-inline-end: 11px;
  }

  :host(:hover:not([disabled])) .root {
    background: ${neutralFillInputHover};
    border-color: ${neutralFillStrongHover};
  }

  :host([aria-invalid='true']:hover:not([disabled])) .root {
    border-color: ${errorFillHover};
  }

  :host(:active:not([disabled])) .root {
    background: ${neutralFillInputHover};
    border-color: ${neutralFillStrongActive};
  }

  :host([aria-invalid='true']:active:not([disabled])) .root {
    border-color: ${errorFillActive};
  }

  :host(:focus-within:not([disabled])) .root {
    border-color: ${accentFillFocus};
    box-shadow: 0 0 0 calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
      ${accentFillFocus};
  }

  :host([aria-invalid='true']:focus-within:not([disabled])) .root {
    border-color: ${errorFillFocus};
    box-shadow: 0 0 0 calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
      ${errorFillFocus};
  }

  :host([appearance='filled']) .root {
    background: ${neutralFillRest};
  }

  :host([appearance='filled']:hover:not([disabled])) .root {
    background: ${neutralFillHover};
  }

  :host([disabled]) .label,
  :host([readonly]) .label,
  :host([readonly]) .control,
  :host([disabled]) .control {
    cursor: ${disabledCursor};
  }

  :host([disabled]) {
    opacity: ${disabledOpacity};
  }

  :host([disabled]) .control {
    border-color: ${neutralStrokeRest};
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    .root,
    :host([appearance='filled']) .root {
      forced-color-adjust: none;
      background: ${SystemColors.Field};
      border-color: ${SystemColors.FieldText};
    }
    :host([aria-invalid='true']) .root {
      border-style: dashed;
    }
    :host(:hover:not([disabled])) .root,
    :host([appearance='filled']:hover:not([disabled])) .root,
    :host([appearance='filled']:hover) .root {
      background: ${SystemColors.Field};
      border-color: ${SystemColors.Highlight};
    }
    .start,
    .end {
      fill: currentcolor;
    }
    :host([disabled]) {
      opacity: 1;
    }
    :host([disabled]) .root,
    :host([appearance='filled']:hover[disabled]) .root {
      border-color: ${SystemColors.GrayText};
      background: ${SystemColors.Field};
    }
    :host(:focus-within:enabled) .root {
      border-color: ${SystemColors.Highlight};
      box-shadow: 0 0 0 calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
        ${SystemColors.Highlight};
    }
    input::placeholder {
      color: ${SystemColors.GrayText};
    }
  `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/styles/patterns/index.js
var init_patterns2 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/styles/patterns/index.js"() {
    init_button4();
    init_field();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/styles/direction.js
var DirectionalStyleSheetBehavior, DirectionalStyleSheetBehaviorSubscription;
var init_direction2 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/styles/direction.js"() {
    init_design_tokens();
    DirectionalStyleSheetBehavior = class {
      constructor(ltr4, rtl4) {
        this.cache = /* @__PURE__ */ new WeakMap();
        this.ltr = ltr4;
        this.rtl = rtl4;
      }
      /**
       * @internal
       */
      bind(source) {
        this.attach(source);
      }
      /**
       * @internal
       */
      unbind(source) {
        const cache2 = this.cache.get(source);
        if (cache2) {
          direction.unsubscribe(cache2);
        }
      }
      attach(source) {
        const subscriber = this.cache.get(source) || new DirectionalStyleSheetBehaviorSubscription(this.ltr, this.rtl, source);
        const value = direction.getValueFor(source);
        direction.subscribe(subscriber);
        subscriber.attach(value);
        this.cache.set(source, subscriber);
      }
    };
    DirectionalStyleSheetBehaviorSubscription = class {
      constructor(ltr4, rtl4, source) {
        this.ltr = ltr4;
        this.rtl = rtl4;
        this.source = source;
        this.attached = null;
      }
      handleChange({ target: target2, token }) {
        this.attach(token.getValueFor(target2));
      }
      attach(direction2) {
        if (this.attached !== this[direction2]) {
          if (this.attached !== null) {
            this.source.$fastController.removeStyles(this.attached);
          }
          this.attached = this[direction2];
          if (this.attached !== null) {
            this.source.$fastController.addStyles(this.attached);
          }
        }
      }
    };
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/styles/index.js
var init_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/styles/index.js"() {
    init_elevation();
    init_patterns2();
    init_size();
    init_direction2();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/utilities/behaviors.js
function appearanceBehavior(value, styles) {
  return new PropertyStyleSheetBehavior("appearance", value, styles);
}
var init_behaviors = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/utilities/behaviors.js"() {
    init_esm2();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/anchor/anchor.styles.js
var anchorStyles;
var init_anchor_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/anchor/anchor.styles.js"() {
    init_esm();
    init_styles();
    init_behaviors();
    anchorStyles = (context, definition) => css`
    ${BaseButtonStyles}
  `.withBehaviors(appearanceBehavior("accent", AccentButtonStyles), appearanceBehavior("hypertext", HypertextStyles), appearanceBehavior("lightweight", LightweightButtonStyles), appearanceBehavior("outline", OutlineButtonStyles), appearanceBehavior("stealth", StealthButtonStyles));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/anchor/index.js
var Anchor2, jpAnchor;
var init_anchor3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/anchor/index.js"() {
    init_tslib_es62();
    init_esm();
    init_esm2();
    init_anchor_styles();
    Anchor2 = class extends Anchor {
      appearanceChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
          this.classList.remove(oldValue);
          this.classList.add(newValue);
        }
      }
      connectedCallback() {
        super.connectedCallback();
        if (!this.appearance) {
          this.appearance = "neutral";
        }
      }
      /**
       * Applies 'icon-only' class when there is only an SVG in the default slot
       *
       * @internal
       *
       */
      defaultSlottedContentChanged(oldValue, newValue) {
        const slottedElements = this.defaultSlottedContent.filter((x) => x.nodeType === Node.ELEMENT_NODE);
        if (slottedElements.length === 1 && slottedElements[0] instanceof SVGElement) {
          this.control.classList.add("icon-only");
        } else {
          this.control.classList.remove("icon-only");
        }
      }
    };
    __decorate2([
      attr
    ], Anchor2.prototype, "appearance", void 0);
    jpAnchor = Anchor2.compose({
      baseName: "anchor",
      baseClass: Anchor,
      template: anchorTemplate,
      styles: anchorStyles,
      shadowOptions: {
        delegatesFocus: true
      }
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/anchored-region/anchored-region.styles.js
var anchoredRegionStyles;
var init_anchored_region_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/anchored-region/anchored-region.styles.js"() {
    init_esm();
    anchoredRegionStyles = (context, definition) => css`
  :host {
    contain: layout;
    display: block;
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/anchored-region/index.js
var jpAnchoredRegion;
var init_anchored_region3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/anchored-region/index.js"() {
    init_esm2();
    init_anchored_region_styles();
    jpAnchoredRegion = AnchoredRegion.compose({
      baseName: "anchored-region",
      template: anchoredRegionTemplate,
      styles: anchoredRegionStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/avatar/avatar.styles.js
var rtl, ltr, avatarStyles;
var init_avatar_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/avatar/avatar.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    init_direction2();
    rtl = (context, definition) => css`
  ::slotted(${context.tagFor(Badge)}) {
    left: 0;
  }
`;
    ltr = (context, definition) => css`
  ::slotted(${context.tagFor(Badge)}) {
    right: 0;
  }
`;
    avatarStyles = (context, definition) => css`
    ${display("flex")} :host {
      position: relative;
      height: var(--avatar-size, var(--avatar-size-default));
      width: var(--avatar-size, var(--avatar-size-default));
      --avatar-size-default: calc(
        (
            (${baseHeightMultiplier} + ${density}) * ${designUnit} +
              ((${designUnit} * 8) - 40)
          ) * 1px
      );
      --avatar-text-size: ${typeRampBaseFontSize};
      --avatar-text-ratio: ${designUnit};
    }

    .link {
      text-decoration: none;
      color: ${neutralForegroundRest};
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      min-width: 100%;
    }

    .square {
      border-radius: calc(${controlCornerRadius} * 1px);
      min-width: 100%;
      overflow: hidden;
    }

    .circle {
      border-radius: 100%;
      min-width: 100%;
      overflow: hidden;
    }

    .backplate {
      position: relative;
      display: flex;
      background-color: ${accentFillRest};
    }

    .media,
    ::slotted(img) {
      max-width: 100%;
      position: absolute;
      display: block;
    }

    .content {
      font-size: calc(
        (
            var(--avatar-text-size) +
              var(--avatar-size, var(--avatar-size-default))
          ) / var(--avatar-text-ratio)
      );
      line-height: var(--avatar-size, var(--avatar-size-default));
      display: block;
      min-height: var(--avatar-size, var(--avatar-size-default));
    }

    ::slotted(${context.tagFor(Badge)}) {
      position: absolute;
      display: block;
    }
  `.withBehaviors(new DirectionalStyleSheetBehavior(ltr(context, definition), rtl(context, definition)));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/avatar/index.js
var Avatar2, imgTemplate, jpAvatar;
var init_avatar3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/avatar/index.js"() {
    init_tslib_es62();
    init_esm();
    init_esm2();
    init_avatar_styles();
    Avatar2 = class extends Avatar {
    };
    __decorate2([
      attr({ attribute: "src" })
    ], Avatar2.prototype, "imgSrc", void 0);
    __decorate2([
      attr
    ], Avatar2.prototype, "alt", void 0);
    imgTemplate = html`
  ${when((x) => x.imgSrc, html`
      <img
        src="${(x) => x.imgSrc}"
        alt="${(x) => x.alt}"
        slot="media"
        class="media"
        part="media"
      />
    `)}
`;
    jpAvatar = Avatar2.compose({
      baseName: "avatar",
      baseClass: Avatar,
      template: avatarTemplate,
      styles: avatarStyles,
      media: imgTemplate,
      shadowOptions: {
        delegatesFocus: true
      }
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/badge/badge.styles.js
var badgeStyles;
var init_badge_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/badge/badge.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    init_styles();
    badgeStyles = (context, definition) => css`
  ${display("inline-block")} :host {
    box-sizing: border-box;
    font-family: ${bodyFont};
    font-size: ${typeRampMinus1FontSize};
    line-height: ${typeRampMinus1LineHeight};
  }

  .control {
    border-radius: calc(${controlCornerRadius} * 1px);
    padding: calc(((${designUnit} * 0.5) - ${strokeWidth}) * 1px)
      calc((${designUnit} - ${strokeWidth}) * 1px);
    color: ${neutralForegroundRest};
    font-weight: 600;
    border: calc(${strokeWidth} * 1px) solid transparent;
    background-color: ${neutralFillRest};
  }

  .control[style] {
    font-weight: 400;
  }

  :host([circular]) .control {
    border-radius: 100px;
    padding: 0 calc(${designUnit} * 1px);
    height: calc((${heightNumber} - (${designUnit} * 3)) * 1px);
    min-width: calc((${heightNumber} - (${designUnit} * 3)) * 1px);
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/badge/index.js
var jpBadge;
var init_badge3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/badge/index.js"() {
    init_esm2();
    init_badge_styles();
    jpBadge = Badge.compose({
      baseName: "badge",
      template: badgeTemplate,
      styles: badgeStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/breadcrumb/breadcrumb.styles.js
var breadcrumbStyles;
var init_breadcrumb_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/breadcrumb/breadcrumb.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    breadcrumbStyles = (context, definition) => css`
  ${display("inline-block")} :host {
    box-sizing: border-box;
    font-family: ${bodyFont};
    font-size: ${typeRampBaseFontSize};
    line-height: ${typeRampBaseLineHeight};
  }

  .list {
    display: flex;
    flex-wrap: wrap;
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/breadcrumb/index.js
var jpBreadcrumb;
var init_breadcrumb3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/breadcrumb/index.js"() {
    init_esm2();
    init_breadcrumb_styles();
    jpBreadcrumb = Breadcrumb.compose({
      baseName: "breadcrumb",
      template: breadcrumbTemplate,
      styles: breadcrumbStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/breadcrumb-item/breadcrumb-item.styles.js
var breadcrumbItemStyles;
var init_breadcrumb_item_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/breadcrumb-item/breadcrumb-item.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    breadcrumbItemStyles = (context, definition) => css`
    ${display("inline-flex")} :host {
        background: transparent;
        box-sizing: border-box;
        font-family: ${bodyFont};
        font-size: ${typeRampBaseFontSize};
        fill: currentColor;
        line-height: ${typeRampBaseLineHeight};
        min-width: calc(${heightNumber} * 1px);
        outline: none;
        color: ${neutralForegroundRest}
    }

    .listitem {
        display: flex;
        align-items: center;
        width: max-content;
    }

    .separator {
        margin: 0 6px;
        display: flex;
    }

    .control {
        align-items: center;
        box-sizing: border-box;
        color: ${accentForegroundRest};
        cursor: pointer;
        display: flex;
        fill: inherit;
        outline: none;
        text-decoration: none;
        white-space: nowrap;
    }

    .control:hover {
        color: ${accentForegroundHover};
    }

    .control:active {
        color: ${accentForegroundActive};
    }

    .control .content {
        position: relative;
    }

    .control .content::before {
        content: "";
        display: block;
        height: calc(${strokeWidth} * 1px);
        left: 0;
        position: absolute;
        right: 0;
        top: calc(1em + 4px);
        width: 100%;
    }

    .control:hover .content::before {
        background: ${accentForegroundHover};
    }

    .control:active .content::before {
        background: ${accentForegroundActive};
    }

    .control:${focusVisible} .content::before {
        background: ${accentForegroundFocus};
        height: calc(${focusStrokeWidth} * 1px);
    }

    .control:not([href]) {
        color: ${neutralForegroundRest};
        cursor: default;
    }

    .control:not([href]) .content::before {
        background: none;
    }

    .start,
    .end {
        display: flex;
    }

    ::slotted(svg) {
        /* TODO: adaptive typography https://github.com/microsoft/fast/issues/2432 */
        width: 16px;
        height: 16px;
    }

    .start {
        margin-inline-end: 6px;
    }

    .end {
        margin-inline-start: 6px;
    }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
      .control:hover .content::before,
                .control:${focusVisible} .content::before {
        background: ${SystemColors.LinkText};
      }
      .start,
      .end {
        fill: ${SystemColors.ButtonText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/breadcrumb-item/index.js
var jpBreadcrumbItem;
var init_breadcrumb_item3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/breadcrumb-item/index.js"() {
    init_esm2();
    init_breadcrumb_item_styles();
    jpBreadcrumbItem = BreadcrumbItem.compose({
      baseName: "breadcrumb-item",
      template: breadcrumbItemTemplate,
      styles: breadcrumbItemStyles,
      separator: "/",
      shadowOptions: {
        delegatesFocus: true
      }
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/button/button.styles.js
var buttonStyles;
var init_button_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/button/button.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_button4();
    init_behaviors();
    buttonStyles = (context, definition) => css`
    :host([disabled]),
    :host([disabled]:hover),
    :host([disabled]:active) {
      opacity: ${disabledOpacity};
      background-color: ${neutralFillRest};
      cursor: ${disabledCursor};
    }

    ${BaseButtonStyles}
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host([disabled]),
      :host([disabled]) .control,
      :host([disabled]:hover),
      :host([disabled]:active) {
        forced-color-adjust: none;
        background-color: ${SystemColors.ButtonFace};
        outline-color: ${SystemColors.GrayText};
        color: ${SystemColors.GrayText};
        cursor: ${disabledCursor};
        opacity: 1;
      }
    `), appearanceBehavior("accent", css`
        :host([appearance='accent'][disabled]),
        :host([appearance='accent'][disabled]:hover),
        :host([appearance='accent'][disabled]:active) {
          background: ${accentFillRest};
        }

        ${AccentButtonStyles}
      `.withBehaviors(forcedColorsStylesheetBehavior(css`
          :host([appearance='accent'][disabled]) .control,
          :host([appearance='accent'][disabled]) .control:hover {
            background: ${SystemColors.ButtonFace};
            border-color: ${SystemColors.GrayText};
            color: ${SystemColors.GrayText};
          }
        `))), appearanceBehavior("error", css`
        :host([appearance='error'][disabled]),
        :host([appearance='error'][disabled]:hover),
        :host([appearance='error'][disabled]:active) {
          background: ${errorFillRest};
        }

        ${ErrorButtonStyles}
      `.withBehaviors(forcedColorsStylesheetBehavior(css`
          :host([appearance='error'][disabled]) .control,
          :host([appearance='error'][disabled]) .control:hover {
            background: ${SystemColors.ButtonFace};
            border-color: ${SystemColors.GrayText};
            color: ${SystemColors.GrayText};
          }
        `))), appearanceBehavior("lightweight", css`
        :host([appearance='lightweight'][disabled]:hover),
        :host([appearance='lightweight'][disabled]:active) {
          background-color: transparent;
          color: ${accentForegroundRest};
        }

        :host([appearance='lightweight'][disabled]) .content::before,
        :host([appearance='lightweight'][disabled]:hover) .content::before,
        :host([appearance='lightweight'][disabled]:active) .content::before {
          background: transparent;
        }

        ${LightweightButtonStyles}
      `.withBehaviors(forcedColorsStylesheetBehavior(css`
          :host([appearance='lightweight'].disabled) .control {
            forced-color-adjust: none;
            color: ${SystemColors.GrayText};
          }

          :host([appearance='lightweight'].disabled)
            .control:hover
            .content::before {
            background: none;
          }
        `))), appearanceBehavior("outline", css`
        :host([appearance='outline'][disabled]),
        :host([appearance='outline'][disabled]:hover),
        :host([appearance='outline'][disabled]:active) {
          background: transparent;
          border-color: ${accentFillRest};
        }

        ${OutlineButtonStyles}
      `.withBehaviors(forcedColorsStylesheetBehavior(css`
          :host([appearance='outline'][disabled]) .control {
            border-color: ${SystemColors.GrayText};
          }
        `))), appearanceBehavior("stealth", css`
        ${StealthButtonStyles}
      `.withBehaviors(forcedColorsStylesheetBehavior(css`
          :host([appearance='stealth'][disabled]) {
            background: ${SystemColors.ButtonFace};
          }

          :host([appearance='stealth'][disabled]) .control {
            background: ${SystemColors.ButtonFace};
            border-color: transparent;
            color: ${SystemColors.GrayText};
          }
        `))));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/button/index.js
var Button3, jpButton;
var init_button5 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/button/index.js"() {
    init_tslib_es62();
    init_esm();
    init_esm2();
    init_button_styles();
    Button3 = class extends Button2 {
      constructor() {
        super(...arguments);
        this.appearance = "neutral";
      }
      /**
       * Applies 'icon-only' class when there is only an SVG in the default slot
       *
       * @public
       * @remarks
       */
      defaultSlottedContentChanged(oldValue, newValue) {
        const slottedElements = this.defaultSlottedContent.filter((x) => x.nodeType === Node.ELEMENT_NODE);
        if (slottedElements.length === 1 && (slottedElements[0] instanceof SVGElement || slottedElements[0].classList.contains("fa") || slottedElements[0].classList.contains("fas"))) {
          this.control.classList.add("icon-only");
        } else {
          this.control.classList.remove("icon-only");
        }
      }
    };
    __decorate2([
      attr
    ], Button3.prototype, "appearance", void 0);
    __decorate2([
      attr({ attribute: "minimal", mode: "boolean" })
    ], Button3.prototype, "minimal", void 0);
    jpButton = Button3.compose({
      baseName: "button",
      baseClass: Button2,
      template: buttonTemplate,
      styles: buttonStyles,
      shadowOptions: {
        delegatesFocus: true
      }
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/card/card.styles.js
var cardStyles;
var init_card_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/card/card.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    cardStyles = (context, definition) => css`
    ${display("block")} :host {
      --elevation: 4;
      display: block;
      contain: content;
      height: var(--card-height, 100%);
      width: var(--card-width, 100%);
      box-sizing: border-box;
      background: ${fillColor};
      border-radius: calc(${controlCornerRadius} * 1px);
      ${elevation}
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host {
        forced-color-adjust: none;
        background: ${SystemColors.Canvas};
        box-shadow: 0 0 0 1px ${SystemColors.CanvasText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/card/index.js
var Card2, jpCard;
var init_card3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/card/index.js"() {
    init_esm2();
    init_design_tokens();
    init_card_styles();
    Card2 = class extends Card {
      connectedCallback() {
        super.connectedCallback();
        const parent = composedParent(this);
        if (parent) {
          fillColor.setValueFor(this, (target2) => neutralFillLayerRecipe.getValueFor(target2).evaluate(target2, fillColor.getValueFor(parent)));
        }
      }
    };
    jpCard = Card2.compose({
      baseName: "card",
      baseClass: Card,
      template: cardTemplate,
      styles: cardStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/checkbox/checkbox.styles.js
var checkboxStyles;
var init_checkbox_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/checkbox/checkbox.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    checkboxStyles = (context, definition) => css`
    ${display("inline-flex")} :host {
      align-items: center;
      outline: none;
      margin: calc(${designUnit} * 1px) 0;
      /* Chromium likes to select label text or the default slot when the checkbox is
            clicked. Maybe there is a better solution here? */
      user-select: none;
    }

    .control {
      position: relative;
      width: calc((${heightNumber} / 2 + ${designUnit}) * 1px);
      height: calc((${heightNumber} / 2 + ${designUnit}) * 1px);
      box-sizing: border-box;
      border-radius: calc(${controlCornerRadius} * 1px);
      border: calc(${strokeWidth} * 1px) solid ${neutralStrokeRest};
      background: ${neutralFillInputRest};
      outline: none;
      cursor: pointer;
    }

    :host([aria-invalid='true']) .control {
      border-color: ${errorFillRest};
    }

    .label {
      font-family: ${bodyFont};
      color: ${neutralForegroundRest};
      /* Need to discuss with Brian how HorizontalSpacingNumber can work.
            https://github.com/microsoft/fast/issues/2766 */
      padding-inline-start: calc(${designUnit} * 2px + 2px);
      margin-inline-end: calc(${designUnit} * 2px + 2px);
      cursor: pointer;
      font-size: ${typeRampBaseFontSize};
      line-height: ${typeRampBaseLineHeight};
    }

    .label__hidden {
      display: none;
      visibility: hidden;
    }

    .checked-indicator {
      width: 100%;
      height: 100%;
      display: block;
      fill: ${foregroundOnAccentRest};
      opacity: 0;
      pointer-events: none;
    }

    .indeterminate-indicator {
      border-radius: calc(${controlCornerRadius} * 1px);
      background: ${foregroundOnAccentRest};
      position: absolute;
      top: 50%;
      left: 50%;
      width: 50%;
      height: 50%;
      transform: translate(-50%, -50%);
      opacity: 0;
    }

    :host(:not([disabled])) .control:hover {
      background: ${neutralFillInputHover};
      border-color: ${neutralStrokeHover};
    }

    :host(:not([disabled])) .control:active {
      background: ${neutralFillInputActive};
      border-color: ${neutralStrokeActive};
    }

    :host([aria-invalid='true']:not([disabled])) .control:hover {
      border-color: ${errorFillHover};
    }

    :host([aria-invalid='true']:not([disabled])) .control:active {
      border-color: ${errorFillActive};
    }

    :host(:${focusVisible}) .control {
      outline: calc(${focusStrokeWidth} * 1px) solid ${accentFillFocus};
      outline-offset: 2px;
    }

    :host([aria-invalid='true']:${focusVisible}) .control {
      outline-color: ${errorFillFocus};
    }

    :host([aria-checked='true']) .control {
      background: ${accentFillRest};
      border: calc(${strokeWidth} * 1px) solid ${accentFillRest};
    }

    :host([aria-checked='true']:not([disabled])) .control:hover {
      background: ${accentFillHover};
      border: calc(${strokeWidth} * 1px) solid ${accentFillHover};
    }

    :host([aria-invalid='true'][aria-checked='true']) .control {
      background-color: ${errorFillRest};
      border-color: ${errorFillRest};
    }

    :host([aria-invalid='true'][aria-checked='true']:not([disabled]))
      .control:hover {
      background-color: ${errorFillHover};
      border-color: ${errorFillHover};
    }

    :host([aria-checked='true']:not([disabled]))
      .control:hover
      .checked-indicator {
      fill: ${foregroundOnAccentHover};
    }

    :host([aria-checked='true']:not([disabled]))
      .control:hover
      .indeterminate-indicator {
      background: ${foregroundOnAccentHover};
    }

    :host([aria-checked='true']:not([disabled])) .control:active {
      background: ${accentFillActive};
      border: calc(${strokeWidth} * 1px) solid ${accentFillActive};
    }

    :host([aria-invalid='true'][aria-checked='true']:not([disabled]))
      .control:active {
      background-color: ${errorFillActive};
      border-color: ${errorFillActive};
    }

    :host([aria-checked='true']:not([disabled]))
      .control:active
      .checked-indicator {
      fill: ${foregroundOnAccentActive};
    }

    :host([aria-checked='true']:not([disabled]))
      .control:active
      .indeterminate-indicator {
      background: ${foregroundOnAccentActive};
    }

    :host([aria-checked="true"]:${focusVisible}:not([disabled])) .control {
      outline: calc(${focusStrokeWidth} * 1px) solid ${accentFillFocus};
      outline-offset: 2px;
    }

    :host([aria-invalid='true'][aria-checked="true"]:${focusVisible}:not([disabled])) .control {
      outline-color: ${errorFillFocus};
    }

    :host([disabled]) .label,
    :host([readonly]) .label,
    :host([readonly]) .control,
    :host([disabled]) .control {
      cursor: ${disabledCursor};
    }

    :host([aria-checked='true']:not(.indeterminate)) .checked-indicator,
    :host(.indeterminate) .indeterminate-indicator {
      opacity: 1;
    }

    :host([disabled]) {
      opacity: ${disabledOpacity};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      .control {
        forced-color-adjust: none;
        border-color: ${SystemColors.FieldText};
        background: ${SystemColors.Field};
      }
      :host([aria-invalid='true']) .control {
        border-style: dashed;
      }
      .checked-indicator {
        fill: ${SystemColors.FieldText};
      }
      .indeterminate-indicator {
        background: ${SystemColors.FieldText};
      }
      :host(:not([disabled])) .control:hover,
      .control:active {
        border-color: ${SystemColors.Highlight};
        background: ${SystemColors.Field};
      }
      :host(:${focusVisible}) .control {
        outline: calc(${focusStrokeWidth} * 1px) solid ${SystemColors.FieldText};
        outline-offset: 2px;
      }
      :host([aria-checked="true"]:${focusVisible}:not([disabled])) .control {
        outline: calc(${focusStrokeWidth} * 1px) solid ${SystemColors.FieldText};
        outline-offset: 2px;
      }
      :host([aria-checked='true']) .control {
        background: ${SystemColors.Highlight};
        border-color: ${SystemColors.Highlight};
      }
      :host([aria-checked='true']:not([disabled])) .control:hover,
      .control:active {
        border-color: ${SystemColors.Highlight};
        background: ${SystemColors.HighlightText};
      }
      :host([aria-checked='true']) .checked-indicator {
        fill: ${SystemColors.HighlightText};
      }
      :host([aria-checked='true']:not([disabled]))
        .control:hover
        .checked-indicator {
        fill: ${SystemColors.Highlight};
      }
      :host([aria-checked='true']) .indeterminate-indicator {
        background: ${SystemColors.HighlightText};
      }
      :host([aria-checked='true']) .control:hover .indeterminate-indicator {
        background: ${SystemColors.Highlight};
      }
      :host([disabled]) {
        opacity: 1;
      }
      :host([disabled]) .control {
        forced-color-adjust: none;
        border-color: ${SystemColors.GrayText};
        background: ${SystemColors.Field};
      }
      :host([disabled]) .indeterminate-indicator,
      :host([aria-checked='true'][disabled])
        .control:hover
        .indeterminate-indicator {
        forced-color-adjust: none;
        background: ${SystemColors.GrayText};
      }
      :host([disabled]) .checked-indicator,
      :host([aria-checked='true'][disabled]) .control:hover .checked-indicator {
        forced-color-adjust: none;
        fill: ${SystemColors.GrayText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/checkbox/index.js
var checkboxTemplate, Checkbox2, jpCheckbox;
var init_checkbox3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/checkbox/index.js"() {
    init_esm2();
    init_checkbox_styles();
    init_esm();
    checkboxTemplate = (context, definition) => html`
  <template
    role="checkbox"
    aria-checked="${(x) => x.checked}"
    aria-required="${(x) => x.required}"
    aria-disabled="${(x) => x.disabled}"
    aria-readonly="${(x) => x.readOnly}"
    tabindex="${(x) => x.disabled ? null : 0}"
    @keypress="${(x, c) => x.keypressHandler(c.event)}"
    @click="${(x, c) => x.clickHandler(c.event)}"
  >
    <div part="control" class="control">
      <slot name="checked-indicator">
        ${definition.checkedIndicator || ""}
      </slot>
      <slot name="indeterminate-indicator">
        ${definition.indeterminateIndicator || ""}
      </slot>
    </div>
    <label
      part="label"
      class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
    >
      <slot ${slotted("defaultSlottedNodes")}></slot>
    </label>
  </template>
`;
    Checkbox2 = class extends Checkbox {
      indeterminateChanged(prev, next) {
        if (this.indeterminate) {
          this.classList.add("indeterminate");
        } else {
          this.classList.remove("indeterminate");
        }
      }
    };
    jpCheckbox = Checkbox2.compose({
      baseName: "checkbox",
      baseClass: Checkbox,
      template: checkboxTemplate,
      styles: checkboxStyles,
      checkedIndicator: (
        /* html */
        `
        <svg
            part="checked-indicator"
            class="checked-indicator"
            viewBox="0 0 20 20"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M8.143 12.6697L15.235 4.5L16.8 5.90363L8.23812 15.7667L3.80005 11.2556L5.27591 9.7555L8.143 12.6697Z"
            />
        </svg>
    `
      ),
      indeterminateIndicator: (
        /* html */
        `
        <div part="indeterminate-indicator" class="indeterminate-indicator"></div>
    `
      )
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/listbox/listbox.styles.js
var listboxStyles;
var init_listbox_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/listbox/listbox.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_size();
    listboxStyles = (context, definition) => {
      const ListboxOptionTag = context.tagFor(ListboxOption);
      const hostContext = context.name === context.tagFor(ListboxElement) ? "" : ".listbox";
      return css`
        ${!hostContext ? display("inline-flex") : ""}

        :host ${hostContext} {
            background: ${fillColor};
            border: calc(${strokeWidth} * 1px) solid ${neutralStrokeRest};
            border-radius: calc(${controlCornerRadius} * 1px);
            box-sizing: border-box;
            flex-direction: column;
            padding: calc(${designUnit} * 1px) 0;
        }

        ${!hostContext ? css`
:host(:${focusVisible}:not([disabled])) {
                outline: none;
            }

            :host(:focus-within:not([disabled])) {
                border-color: ${focusStrokeOuter2};
                box-shadow: 0 0 0
                    calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
                    ${focusStrokeOuter2} inset;
            }

            :host([disabled]) ::slotted(*) {
                cursor: ${disabledCursor};
                opacity: ${disabledOpacity};
                pointer-events: none;
            }
        ` : ""}

        ${hostContext || ":host([size])"} {
            max-height: calc(
                (var(--size) * ${heightNumber} + (${designUnit} * ${strokeWidth} * 2)) * 1px
            );
            overflow-y: auto;
        }

        :host([size="0"]) ${hostContext} {
            max-height: none;
        }
    `.withBehaviors(forcedColorsStylesheetBehavior(css`
                :host(:not([multiple]):${focusVisible}) ::slotted(${ListboxOptionTag}[aria-selected="true"]),
                :host([multiple]:${focusVisible}) ::slotted(${ListboxOptionTag}[aria-checked="true"]) {
                    border-color: ${SystemColors.ButtonText};
                    box-shadow: 0 0 0 calc(${focusStrokeWidth} * 1px) inset ${SystemColors.HighlightText};
                }

                :host(:not([multiple]):${focusVisible}) ::slotted(${ListboxOptionTag}[aria-selected="true"]) {
                    background: ${SystemColors.Highlight};
                    color: ${SystemColors.HighlightText};
                    fill: currentcolor;
                }

                ::slotted(${ListboxOptionTag}[aria-selected="true"]:not([aria-checked="true"])) {
                    background: ${SystemColors.Highlight};
                    border-color: ${SystemColors.HighlightText};
                    color: ${SystemColors.HighlightText};
                }
            `));
    };
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/select/select.styles.js
var selectStyles;
var init_select_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/select/select.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_listbox_styles();
    init_elevation();
    init_size();
    selectStyles = (context, definition) => {
      const selectContext = context.name === context.tagFor(Select);
      return css`
  ${display("inline-flex")}
  
  :host {
    --elevation: 14;
    background: ${neutralFillInputRest};
    border-radius: calc(${controlCornerRadius} * 1px);
    border: calc(${strokeWidth} * 1px) solid ${neutralFillStrongRest};
    box-sizing: border-box;
    color: ${neutralForegroundRest};
    font-family: ${bodyFont};
    height: calc(${heightNumber} * 1px);
    position: relative;
    user-select: none;
    min-width: 250px;
    outline: none;
    vertical-align: top;
  }

  :host([aria-invalid='true']) {
    border-color: ${errorFillRest};
  }
  
  :host(:not([autowidth])) {
    min-width: 250px;
  }
  
  ${selectContext ? css`
  :host(:not([aria-haspopup])) {
    --elevation: 0;
    border: 0;
    height: auto;
    min-width: 0;
  }
  ` : ""}
  
  ${listboxStyles(context, definition)}
  
  :host .listbox {
    ${elevation}
    border: none;
    display: flex;
    left: 0;
    position: absolute;
    width: 100%;
    z-index: 1;
  }
  
  .control + .listbox {
    --stroke-size: calc(${designUnit} * ${strokeWidth} * 2);
    max-height: calc(
      (var(--listbox-max-height) * ${heightNumber} + var(--stroke-size)) * 1px
      );
  }
  
  ${selectContext ? css`
  :host(:not([aria-haspopup])) .listbox {
    left: auto;
    position: static;
    z-index: auto;
  }
  ` : ""}
  
  :host(:not([autowidth])) .listbox {
    width: 100%;
  }
  
  :host([autowidth]) ::slotted([role='option']),
  :host([autowidth]) ::slotted(option) {
    padding: 0 calc(1em + ${designUnit} * 1.25px + 1px);
  }
  
  .listbox[hidden] {
    display: none;
  }
  
  .control {
    align-items: center;
    box-sizing: border-box;
    cursor: pointer;
    display: flex;
    font-size: ${typeRampBaseFontSize};
    font-family: inherit;
    line-height: ${typeRampBaseLineHeight};
    min-height: 100%;
    padding: 0 calc(${designUnit} * 2.25px);
    width: 100%;
  }
  
  :host([minimal]) {
    --density: -4;
  }
  
  :host(:not([disabled]):hover) {
    background: ${neutralFillInputHover};
    border-color: ${neutralFillStrongHover};
  }
  
  :host([aria-invalid='true']:not([disabled]):hover) {
    border-color: ${errorFillHover};
  }
  
  :host(:${focusVisible}) {
    border-color: ${accentFillFocus};
    box-shadow: 0 0 0 calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
    ${accentFillFocus};
  }
  
  :host([aria-invalid='true']:${focusVisible}) {
    border-color: ${errorFillFocus};
    box-shadow: 0 0 0 calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
    ${errorFillFocus};
  }
  
  :host(:not([size]):not([multiple]):not([open]):${focusVisible}),
  :host([multiple]:${focusVisible}),
  :host([size]:${focusVisible}) {
    box-shadow: 0 0 0 calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
    ${accentFillFocus};
  }
  
  :host([aria-invalid='true']:not([size]):not([multiple]):not([open]):${focusVisible}),
  :host([aria-invalid='true'][multiple]:${focusVisible}),
  :host([aria-invalid='true'][size]:${focusVisible}) {
    box-shadow: 0 0 0 calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
    ${errorFillFocus};
  }
  
  :host(:not([multiple]):not([size]):${focusVisible}) ::slotted(${context.tagFor(ListboxOption)}[aria-selected="true"]:not([disabled])) {
    box-shadow: 0 0 0 calc(${focusStrokeWidth} * 1px) inset ${accentFillFocus};
    border-color: ${accentFillFocus};
    background: ${accentFillFocus};
    color: ${foregroundOnAccentFocus};
  }
    
  :host([disabled]) {
    cursor: ${disabledCursor};
    opacity: ${disabledOpacity};
  }
  
  :host([disabled]) .control {
    cursor: ${disabledCursor};
    user-select: none;
  }
  
  :host([disabled]:hover) {
    background: ${neutralFillStealthRest};
    color: ${neutralForegroundRest};
    fill: currentcolor;
  }
  
  :host(:not([disabled])) .control:active {
    background: ${neutralFillInputActive};
    border-color: ${accentFillActive};
    border-radius: calc(${controlCornerRadius} * 1px);
  }
  
  :host([open][position="above"]) .listbox {
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
    border-bottom: 0;
    bottom: calc(${heightNumber} * 1px);
  }
  
  :host([open][position="below"]) .listbox {
    border-top-left-radius: 0;
    border-top-right-radius: 0;
    border-top: 0;
    top: calc(${heightNumber} * 1px);
  }
  
  .selected-value {
    flex: 1 1 auto;
    font-family: inherit;
    overflow: hidden;
    text-align: start;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  
  .indicator {
    flex: 0 0 auto;
    margin-inline-start: 1em;
  }
  
  slot[name="listbox"] {
    display: none;
    width: 100%;
  }
  
  :host([open]) slot[name="listbox"] {
    display: flex;
    position: absolute;
    ${elevation}
  }
  
  .end {
    margin-inline-start: auto;
  }
  
  .start,
  .end,
  .indicator,
  .select-indicator,
  ::slotted(svg) {
    /* TODO: adaptive typography https://github.com/microsoft/fast/issues/2432 */
    fill: currentcolor;
    height: 1em;
    min-height: calc(${designUnit} * 4px);
    min-width: calc(${designUnit} * 4px);
    width: 1em;
  }
  
  ::slotted([role="option"]),
  ::slotted(option) {
    flex: 0 0 auto;
  }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host(:not([disabled]):hover),
      :host(:not([disabled]):active) {
        border-color: ${SystemColors.Highlight};
      }

      :host([aria-invalid='true']) {
        border-style: dashed;
      }
      
      :host(:not([disabled]):${focusVisible}) {
        background-color: ${SystemColors.ButtonFace};
        box-shadow: 0 0 0 calc(${focusStrokeWidth} * 1px) ${SystemColors.Highlight};
        color: ${SystemColors.ButtonText};
        fill: currentcolor;
        forced-color-adjust: none;
      }
      
      :host(:not([disabled]):${focusVisible}) .listbox {
        background: ${SystemColors.ButtonFace};
      }
      
      :host([disabled]) {
        border-color: ${SystemColors.GrayText};
        background-color: ${SystemColors.ButtonFace};
        color: ${SystemColors.GrayText};
        fill: currentcolor;
        opacity: 1;
        forced-color-adjust: none;
      }
      
      :host([disabled]:hover) {
        background: ${SystemColors.ButtonFace};
      }
      
      :host([disabled]) .control {
        color: ${SystemColors.GrayText};
        border-color: ${SystemColors.GrayText};
      }
      
      :host([disabled]) .control .select-indicator {
        fill: ${SystemColors.GrayText};
      }
      
      :host(:${focusVisible}) ::slotted([aria-selected="true"][role="option"]),
      :host(:${focusVisible}) ::slotted(option[aria-selected="true"]),
      :host(:${focusVisible}) ::slotted([aria-selected="true"][role="option"]:not([disabled])) {
        background: ${SystemColors.Highlight};
        border-color: ${SystemColors.ButtonText};
        box-shadow: 0 0 0 calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
        ${SystemColors.HighlightText};
        color: ${SystemColors.HighlightText};
        fill: currentcolor;
      }
      
      .start,
      .end,
      .indicator,
      .select-indicator,
      ::slotted(svg) {
        color: ${SystemColors.ButtonText};
        fill: currentcolor;
      }
      `));
    };
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/combobox/combobox.styles.js
var comboboxStyles;
var init_combobox_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/combobox/combobox.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    init_select_styles();
    comboboxStyles = (context, definition) => css`
  ${selectStyles(context, definition)}

  :host(:empty) .listbox {
    display: none;
  }

  :host([disabled]) *,
  :host([disabled]) {
    cursor: ${disabledCursor};
    user-select: none;
  }

  :host(:focus-within:not([disabled])) {
    border-color: ${accentFillFocus};
    box-shadow: 0 0 0 calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
      ${accentFillFocus};
  }

  :host([aria-invalid='true']:focus-within:not([disabled])) {
    border-color: ${errorFillFocus};
    box-shadow: 0 0 0 calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
      ${errorFillFocus};
  }

  .selected-value {
    -webkit-appearance: none;
    background: transparent;
    border: none;
    color: inherit;
    font-size: ${typeRampBaseFontSize};
    line-height: ${typeRampBaseLineHeight};
    height: calc(100% - (${strokeWidth} * 1px));
    margin: auto 0;
    width: 100%;
  }

  .selected-value:hover,
    .selected-value:${focusVisible},
    .selected-value:disabled,
    .selected-value:active {
    outline: none;
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/combobox/index.js
var Combobox2, jpCombobox;
var init_combobox3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/combobox/index.js"() {
    init_tslib_es62();
    init_esm();
    init_esm2();
    init_design_tokens();
    init_combobox_styles();
    Combobox2 = class extends Combobox {
      /**
       * The connected callback for this FASTElement.
       *
       * @override
       *
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.setAutoWidth();
      }
      /**
       * Synchronize the form-associated proxy and updates the value property of the element.
       *
       * @param prev - the previous collection of slotted option elements
       * @param next - the next collection of slotted option elements
       *
       * @internal
       */
      slottedOptionsChanged(prev, next) {
        super.slottedOptionsChanged(prev, next);
        this.setAutoWidth();
      }
      /**
       * (Un-)set the width when the autoWidth property changes.
       *
       * @param prev - the previous autoWidth value
       * @param next - the current autoWidth value
       */
      autoWidthChanged(prev, next) {
        if (next) {
          this.setAutoWidth();
        } else {
          this.style.removeProperty("width");
        }
      }
      /**
       * Compute the listbox width to set the one of the input.
       */
      setAutoWidth() {
        if (!this.autoWidth || !this.isConnected) {
          return;
        }
        let listWidth = this.listbox.getBoundingClientRect().width;
        if (listWidth === 0 && this.listbox.hidden) {
          Object.assign(this.listbox.style, { visibility: "hidden" });
          this.listbox.removeAttribute("hidden");
          listWidth = this.listbox.getBoundingClientRect().width;
          this.listbox.setAttribute("hidden", "");
          this.listbox.style.removeProperty("visibility");
        }
        if (listWidth > 0) {
          Object.assign(this.style, { width: `${listWidth}px` });
        }
      }
      /**
       * @internal
       */
      maxHeightChanged(prev, next) {
        this.updateComputedStylesheet();
      }
      /**
       * Updates an internal stylesheet with calculated CSS custom properties.
       *
       * @internal
       */
      updateComputedStylesheet() {
        if (this.computedStylesheet) {
          this.$fastController.removeStyles(this.computedStylesheet);
        }
        const popupMaxHeight = Math.floor(this.maxHeight / heightNumberAsToken.getValueFor(this)).toString();
        this.computedStylesheet = css`
      :host {
        --listbox-max-height: ${popupMaxHeight};
      }
    `;
        this.$fastController.addStyles(this.computedStylesheet);
      }
    };
    __decorate2([
      attr({ attribute: "autowidth", mode: "boolean" })
    ], Combobox2.prototype, "autoWidth", void 0);
    __decorate2([
      attr({ attribute: "minimal", mode: "boolean" })
    ], Combobox2.prototype, "minimal", void 0);
    jpCombobox = Combobox2.compose({
      baseName: "combobox",
      baseClass: Combobox,
      template: comboboxTemplate,
      styles: comboboxStyles,
      shadowOptions: {
        delegatesFocus: true
      },
      indicator: (
        /* html */
        `
        <svg
            class="select-indicator"
            part="select-indicator"
            viewBox="0 0 12 7"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                d="M11.85.65c.2.2.2.5 0 .7L6.4 6.84a.55.55 0 01-.78 0L.14 1.35a.5.5 0 11.71-.7L6 5.8 11.15.65c.2-.2.5-.2.7 0z"
            />
        </svg>
    `
      )
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/data-grid/data-grid.styles.js
var dataGridStyles;
var init_data_grid_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/data-grid/data-grid.styles.js"() {
    init_esm();
    dataGridStyles = (context, definition) => css`
  :host {
    display: flex;
    position: relative;
    flex-direction: column;
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/data-grid/data-grid-row.styles.js
var dataGridRowStyles;
var init_data_grid_row_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/data-grid/data-grid-row.styles.js"() {
    init_esm();
    init_design_tokens();
    dataGridRowStyles = (context, definition) => css`
  :host {
    display: grid;
    padding: 1px 0;
    box-sizing: border-box;
    width: 100%;
    border-bottom: calc(${strokeWidth} * 1px) solid ${neutralStrokeDividerRest};
  }

  :host(.header) {
  }

  :host(.sticky-header) {
    background: ${neutralFillRest};
    position: sticky;
    top: 0;
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/data-grid/data-grid-cell.styles.js
var dataGridCellStyles;
var init_data_grid_cell_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/data-grid/data-grid-cell.styles.js"() {
    init_esm();
    init_dist4();
    init_esm2();
    init_design_tokens();
    dataGridCellStyles = (context, definition) => css`
    :host {
      padding: calc(${designUnit} * 1px) calc(${designUnit} * 3px);
      color: ${neutralForegroundRest};
      box-sizing: border-box;
      font-family: ${bodyFont};
      font-size: ${typeRampBaseFontSize};
      line-height: ${typeRampBaseLineHeight};
      font-weight: 400;
      border: transparent calc(${focusStrokeWidth} * 1px) solid;
      overflow: hidden;
      white-space: nowrap;
      border-radius: calc(${controlCornerRadius} * 1px);
    }

    :host(.column-header) {
      font-weight: 600;
    }

    :host(:${focusVisible}) {
      outline: calc(${focusStrokeWidth} * 1px) solid ${accentFillFocus};
      color: ${neutralForegroundRest};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host {
        forced-color-adjust: none;
        border-color: transparent;
        background: ${SystemColors.Field};
        color: ${SystemColors.FieldText};
      }

      :host(:${focusVisible}) {
        border-color: ${SystemColors.FieldText};
        box-shadow: 0 0 0 2px inset ${SystemColors.Field};
        color: ${SystemColors.FieldText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/data-grid/index.js
var jpDataGridCell, jpDataGridRow, jpDataGrid;
var init_data_grid3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/data-grid/index.js"() {
    init_esm2();
    init_data_grid_styles();
    init_data_grid_row_styles();
    init_data_grid_cell_styles();
    jpDataGridCell = DataGridCell.compose({
      baseName: "data-grid-cell",
      template: dataGridCellTemplate,
      styles: dataGridCellStyles
    });
    jpDataGridRow = DataGridRow.compose({
      baseName: "data-grid-row",
      template: dataGridRowTemplate,
      styles: dataGridRowStyles
    });
    jpDataGrid = DataGrid.compose({
      baseName: "data-grid",
      template: dataGridTemplate,
      styles: dataGridStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/date-field/date-field.form-associated.js
var _DateField, FormAssociatedDateField;
var init_date_field_form_associated = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/date-field/date-field.form-associated.js"() {
    init_esm2();
    _DateField = class extends FoundationElement {
    };
    FormAssociatedDateField = class extends FormAssociated(_DateField) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/converters.js
var nullableDateConverter;
var init_converters = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/converters.js"() {
    nullableDateConverter = {
      toView(value) {
        if (value === null || value === void 0) {
          return null;
        }
        const date = new Date(value);
        return date.toString() === "Invalid Date" ? null : `${date.getFullYear().toString().padStart(4, "0")}-${(date.getMonth() + 1).toString().padStart(2, "0")}-${date.getDate().toString().padStart(2, "0")}`;
      },
      fromView(value) {
        if (value === null || value === void 0) {
          return null;
        }
        const date = new Date(value);
        return date.toString() === "Invalid Date" ? null : date;
      }
    };
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/date-field/date-field.js
var INVALID_DATE, DateField;
var init_date_field = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/date-field/date-field.js"() {
    init_tslib_es62();
    init_esm();
    init_dist4();
    init_esm2();
    init_date_field_form_associated();
    init_converters();
    INVALID_DATE = "Invalid Date";
    DateField = class extends FormAssociatedDateField {
      constructor() {
        super(...arguments);
        this.step = 1;
        this.isUserInput = false;
      }
      readOnlyChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.readOnly = this.readOnly;
          this.validate();
        }
      }
      autofocusChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.autofocus = this.autofocus;
          this.validate();
        }
      }
      listChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.setAttribute("list", this.list);
          this.validate();
        }
      }
      /**
       * Ensures that the max is greater than the min and that the value
       *  is less than the max
       * @param previous - the previous max value
       * @param next - updated max value
       *
       * @internal
       */
      maxChanged(previous, next) {
        var _a;
        this.max = next < ((_a = this.min) !== null && _a !== void 0 ? _a : next) ? this.min : next;
        this.value = this.getValidValue(this.value);
      }
      /**
       * Ensures that the min is less than the max and that the value
       *  is greater than the min
       * @param previous - previous min value
       * @param next - updated min value
       *
       * @internal
       */
      minChanged(previous, next) {
        var _a;
        this.min = next > ((_a = this.max) !== null && _a !== void 0 ? _a : next) ? this.max : next;
        this.value = this.getValidValue(this.value);
      }
      /**
       * The value property, typed as a number.
       *
       * @public
       */
      get valueAsNumber() {
        return new Date(super.value).valueOf();
      }
      set valueAsNumber(next) {
        this.value = new Date(next).toString();
      }
      /**
       * The value property, typed as a date.
       *
       * @public
       */
      get valueAsDate() {
        return new Date(super.value);
      }
      set valueAsDate(next) {
        this.value = next.toString();
      }
      /**
       * Validates that the value is a number between the min and max
       * @param previous - previous stored value
       * @param next - value being updated
       * @param updateControl - should the text field be updated with value, defaults to true
       * @internal
       */
      valueChanged(previous, next) {
        this.value = this.getValidValue(next);
        if (next !== this.value) {
          return;
        }
        if (this.control && !this.isUserInput) {
          this.control.value = this.value;
        }
        super.valueChanged(previous, this.value);
        if (previous !== void 0 && !this.isUserInput) {
          this.$emit("change");
        }
        this.isUserInput = false;
      }
      /**
       * Sets the internal value to a valid number between the min and max properties
       * @param value - user input
       *
       * @internal
       */
      getValidValue(value) {
        var _a, _b;
        let validValue = new Date(value);
        if (validValue.toString() === INVALID_DATE) {
          validValue = "";
        } else {
          validValue = validValue > ((_a = this.max) !== null && _a !== void 0 ? _a : validValue) ? this.max : validValue;
          validValue = validValue < ((_b = this.min) !== null && _b !== void 0 ? _b : validValue) ? this.min : validValue;
          validValue = `${validValue.getFullYear().toString().padStart(4, "0")}-${(validValue.getMonth() + 1).toString().padStart(2, "0")}-${validValue.getDate().toString().padStart(2, "0")}`;
        }
        return validValue;
      }
      /**
       * Increments the value using the step value
       *
       * @public
       */
      stepUp() {
        const step = 864e5 * this.step;
        const value = new Date(this.value);
        this.value = new Date(value.toString() !== INVALID_DATE ? value.valueOf() + step : 0).toString();
      }
      /**
       * Decrements the value using the step value
       *
       * @public
       */
      stepDown() {
        const step = 864e5 * this.step;
        const value = new Date(this.value);
        this.value = new Date(value.toString() !== INVALID_DATE ? Math.max(value.valueOf() - step, 0) : 0).toString();
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.validate();
        this.control.value = this.value;
        if (this.autofocus) {
          DOM.queueUpdate(() => {
            this.focus();
          });
        }
        if (!this.appearance) {
          this.appearance = "outline";
        }
      }
      /**
       * Handles the internal control's `input` event
       * @internal
       */
      handleTextInput() {
        this.isUserInput = true;
        this.value = this.control.value;
      }
      /**
       * Change event handler for inner control.
       * @remarks
       * "Change" events are not `composable` so they will not
       * permeate the shadow DOM boundary. This fn effectively proxies
       * the change event, emitting a `change` event whenever the internal
       * control emits a `change` event
       * @internal
       */
      handleChange() {
        this.$emit("change");
      }
      /**
       * Handles the internal control's `keydown` event
       * @internal
       */
      handleKeyDown(e) {
        const key2 = e.key;
        switch (key2) {
          case keyArrowUp:
            this.stepUp();
            return false;
          case keyArrowDown:
            this.stepDown();
            return false;
        }
        return true;
      }
      /**
       * Handles populating the input field with a validated value when
       *  leaving the input field.
       * @internal
       */
      handleBlur() {
        this.control.value = this.value;
      }
    };
    __decorate2([
      attr
    ], DateField.prototype, "appearance", void 0);
    __decorate2([
      attr({ attribute: "readonly", mode: "boolean" })
    ], DateField.prototype, "readOnly", void 0);
    __decorate2([
      attr({ mode: "boolean" })
    ], DateField.prototype, "autofocus", void 0);
    __decorate2([
      attr
    ], DateField.prototype, "list", void 0);
    __decorate2([
      attr({ converter: nullableNumberConverter })
    ], DateField.prototype, "step", void 0);
    __decorate2([
      attr({ converter: nullableDateConverter })
    ], DateField.prototype, "max", void 0);
    __decorate2([
      attr({ converter: nullableDateConverter })
    ], DateField.prototype, "min", void 0);
    __decorate2([
      observable
    ], DateField.prototype, "defaultSlottedNodes", void 0);
    applyMixins(DateField, StartEnd, DelegatesARIATextbox);
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/date-field/date-field.styles.js
var dateFieldStyles;
var init_date_field_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/date-field/date-field.styles.js"() {
    init_esm();
    init_styles();
    dateFieldStyles = (context, definition) => css`
  ${BaseFieldStyles}
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/date-field/date-field.template.js
var dateFieldTemplate;
var init_date_field_template = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/date-field/date-field.template.js"() {
    init_esm();
    init_esm2();
    dateFieldTemplate = (context, definition) => html`
  <template class="${(x) => x.readOnly ? "readonly" : ""}">
    <label
      part="label"
      for="control"
      class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
    >
      <slot
        ${slotted({
      property: "defaultSlottedNodes",
      filter: whitespaceFilter
    })}
      ></slot>
    </label>
    <div class="root" part="root">
      ${startSlotTemplate(context, definition)}
      <input
        class="control"
        part="control"
        id="control"
        @input="${(x) => x.handleTextInput()}"
        @change="${(x) => x.handleChange()}"
        ?autofocus="${(x) => x.autofocus}"
        ?disabled="${(x) => x.disabled}"
        list="${(x) => x.list}"
        ?readonly="${(x) => x.readOnly}"
        ?required="${(x) => x.required}"
        :value="${(x) => x.value}"
        type="date"
        aria-atomic="${(x) => x.ariaAtomic}"
        aria-busy="${(x) => x.ariaBusy}"
        aria-controls="${(x) => x.ariaControls}"
        aria-current="${(x) => x.ariaCurrent}"
        aria-describedby="${(x) => x.ariaDescribedby}"
        aria-details="${(x) => x.ariaDetails}"
        aria-disabled="${(x) => x.ariaDisabled}"
        aria-errormessage="${(x) => x.ariaErrormessage}"
        aria-flowto="${(x) => x.ariaFlowto}"
        aria-haspopup="${(x) => x.ariaHaspopup}"
        aria-hidden="${(x) => x.ariaHidden}"
        aria-invalid="${(x) => x.ariaInvalid}"
        aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
        aria-label="${(x) => x.ariaLabel}"
        aria-labelledby="${(x) => x.ariaLabelledby}"
        aria-live="${(x) => x.ariaLive}"
        aria-owns="${(x) => x.ariaOwns}"
        aria-relevant="${(x) => x.ariaRelevant}"
        aria-roledescription="${(x) => x.ariaRoledescription}"
        ${ref("control")}
      />
      ${endSlotTemplate(context, definition)}
    </div>
  </template>
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/date-field/index.js
var jpDateField;
var init_date_field2 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/date-field/index.js"() {
    init_date_field();
    init_date_field_styles();
    init_date_field_template();
    init_date_field();
    init_date_field_template();
    jpDateField = DateField.compose({
      baseName: "date-field",
      styles: dateFieldStyles,
      template: dateFieldTemplate,
      shadowOptions: {
        delegatesFocus: true
      }
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/design-system-provider/index.js
function designToken(token) {
  return (source, key2) => {
    source[key2 + "Changed"] = function(prev, next) {
      if (next !== void 0 && next !== null) {
        token.setValueFor(this, next);
      } else {
        token.deleteValueFor(this);
      }
    };
  };
}
var swatchConverter, backgroundStyles, DesignSystemProvider, designSystemProviderTemplate, designSystemProviderStyles, jpDesignSystemProvider;
var init_design_system_provider = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/design-system-provider/index.js"() {
    init_tslib_es62();
    init_dist2();
    init_esm();
    init_esm2();
    init_dist4();
    init_swatch();
    init_design_tokens();
    swatchConverter = {
      toView(value) {
        if (value === null || value === void 0) {
          return null;
        }
        return value === null || value === void 0 ? void 0 : value.toColorString();
      },
      fromView(value) {
        if (value === null || value === void 0) {
          return null;
        }
        const color = parseColorHexRGB(value);
        return color ? SwatchRGB.create(color.r, color.g, color.b) : null;
      }
    };
    backgroundStyles = css`
  :host {
    background-color: ${fillColor};
    color: ${neutralForegroundRest};
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host {
      background-color: ${SystemColors.ButtonFace};
      box-shadow: 0 0 0 1px ${SystemColors.CanvasText};
      color: ${SystemColors.ButtonText};
    }
  `));
    DesignSystemProvider = class extends FoundationElement {
      constructor() {
        super();
        this.noPaint = false;
        const subscriber = {
          handleChange: this.noPaintChanged.bind(this)
        };
        Observable.getNotifier(this).subscribe(subscriber, "fillColor");
        Observable.getNotifier(this).subscribe(subscriber, "baseLayerLuminance");
      }
      noPaintChanged() {
        if (!this.noPaint && (this.fillColor !== void 0 || this.baseLayerLuminance)) {
          this.$fastController.addStyles(backgroundStyles);
        } else {
          this.$fastController.removeStyles(backgroundStyles);
        }
      }
    };
    __decorate2([
      attr({ attribute: "no-paint", mode: "boolean" })
    ], DesignSystemProvider.prototype, "noPaint", void 0);
    __decorate2([
      attr({
        attribute: "fill-color",
        converter: swatchConverter
      }),
      designToken(fillColor)
    ], DesignSystemProvider.prototype, "fillColor", void 0);
    __decorate2([
      attr({
        attribute: "accent-color",
        converter: swatchConverter,
        mode: "fromView"
      }),
      designToken(accentColor)
    ], DesignSystemProvider.prototype, "accentColor", void 0);
    __decorate2([
      attr({
        attribute: "neutral-color",
        converter: swatchConverter,
        mode: "fromView"
      }),
      designToken(neutralColor)
    ], DesignSystemProvider.prototype, "neutralColor", void 0);
    __decorate2([
      attr({
        attribute: "error-color",
        converter: swatchConverter,
        mode: "fromView"
      }),
      designToken(errorColor)
    ], DesignSystemProvider.prototype, "errorColor", void 0);
    __decorate2([
      attr({
        converter: nullableNumberConverter
      }),
      designToken(density)
    ], DesignSystemProvider.prototype, "density", void 0);
    __decorate2([
      attr({
        attribute: "design-unit",
        converter: nullableNumberConverter
      }),
      designToken(designUnit)
    ], DesignSystemProvider.prototype, "designUnit", void 0);
    __decorate2([
      attr({
        attribute: "direction"
      }),
      designToken(direction)
    ], DesignSystemProvider.prototype, "direction", void 0);
    __decorate2([
      attr({
        attribute: "base-height-multiplier",
        converter: nullableNumberConverter
      }),
      designToken(baseHeightMultiplier)
    ], DesignSystemProvider.prototype, "baseHeightMultiplier", void 0);
    __decorate2([
      attr({
        attribute: "base-horizontal-spacing-multiplier",
        converter: nullableNumberConverter
      }),
      designToken(baseHorizontalSpacingMultiplier)
    ], DesignSystemProvider.prototype, "baseHorizontalSpacingMultiplier", void 0);
    __decorate2([
      attr({
        attribute: "control-corner-radius",
        converter: nullableNumberConverter
      }),
      designToken(controlCornerRadius)
    ], DesignSystemProvider.prototype, "controlCornerRadius", void 0);
    __decorate2([
      attr({
        attribute: "stroke-width",
        converter: nullableNumberConverter
      }),
      designToken(strokeWidth)
    ], DesignSystemProvider.prototype, "strokeWidth", void 0);
    __decorate2([
      attr({
        attribute: "focus-stroke-width",
        converter: nullableNumberConverter
      }),
      designToken(focusStrokeWidth)
    ], DesignSystemProvider.prototype, "focusStrokeWidth", void 0);
    __decorate2([
      attr({
        attribute: "disabled-opacity",
        converter: nullableNumberConverter
      }),
      designToken(disabledOpacity)
    ], DesignSystemProvider.prototype, "disabledOpacity", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-minus-2-font-size"
      }),
      designToken(typeRampMinus2FontSize)
    ], DesignSystemProvider.prototype, "typeRampMinus2FontSize", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-minus-2-line-height"
      }),
      designToken(typeRampMinus2LineHeight)
    ], DesignSystemProvider.prototype, "typeRampMinus2LineHeight", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-minus-1-font-size"
      }),
      designToken(typeRampMinus1FontSize)
    ], DesignSystemProvider.prototype, "typeRampMinus1FontSize", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-minus-1-line-height"
      }),
      designToken(typeRampMinus1LineHeight)
    ], DesignSystemProvider.prototype, "typeRampMinus1LineHeight", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-base-font-size"
      }),
      designToken(typeRampBaseFontSize)
    ], DesignSystemProvider.prototype, "typeRampBaseFontSize", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-base-line-height"
      }),
      designToken(typeRampBaseLineHeight)
    ], DesignSystemProvider.prototype, "typeRampBaseLineHeight", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-plus-1-font-size"
      }),
      designToken(typeRampPlus1FontSize)
    ], DesignSystemProvider.prototype, "typeRampPlus1FontSize", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-plus-1-line-height"
      }),
      designToken(typeRampPlus1LineHeight)
    ], DesignSystemProvider.prototype, "typeRampPlus1LineHeight", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-plus-2-font-size"
      }),
      designToken(typeRampPlus2FontSize)
    ], DesignSystemProvider.prototype, "typeRampPlus2FontSize", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-plus-2-line-height"
      }),
      designToken(typeRampPlus2LineHeight)
    ], DesignSystemProvider.prototype, "typeRampPlus2LineHeight", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-plus-3-font-size"
      }),
      designToken(typeRampPlus3FontSize)
    ], DesignSystemProvider.prototype, "typeRampPlus3FontSize", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-plus-3-line-height"
      }),
      designToken(typeRampPlus3LineHeight)
    ], DesignSystemProvider.prototype, "typeRampPlus3LineHeight", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-plus-4-font-size"
      }),
      designToken(typeRampPlus4FontSize)
    ], DesignSystemProvider.prototype, "typeRampPlus4FontSize", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-plus-4-line-height"
      }),
      designToken(typeRampPlus4LineHeight)
    ], DesignSystemProvider.prototype, "typeRampPlus4LineHeight", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-plus-5-font-size"
      }),
      designToken(typeRampPlus5FontSize)
    ], DesignSystemProvider.prototype, "typeRampPlus5FontSize", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-plus-5-line-height"
      }),
      designToken(typeRampPlus5LineHeight)
    ], DesignSystemProvider.prototype, "typeRampPlus5LineHeight", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-plus-6-font-size"
      }),
      designToken(typeRampPlus6FontSize)
    ], DesignSystemProvider.prototype, "typeRampPlus6FontSize", void 0);
    __decorate2([
      attr({
        attribute: "type-ramp-plus-6-line-height"
      }),
      designToken(typeRampPlus6LineHeight)
    ], DesignSystemProvider.prototype, "typeRampPlus6LineHeight", void 0);
    __decorate2([
      attr({
        attribute: "accent-fill-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentFillRestDelta)
    ], DesignSystemProvider.prototype, "accentFillRestDelta", void 0);
    __decorate2([
      attr({
        attribute: "accent-fill-hover-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentFillHoverDelta)
    ], DesignSystemProvider.prototype, "accentFillHoverDelta", void 0);
    __decorate2([
      attr({
        attribute: "accent-fill-active-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentFillActiveDelta)
    ], DesignSystemProvider.prototype, "accentFillActiveDelta", void 0);
    __decorate2([
      attr({
        attribute: "accent-fill-focus-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentFillFocusDelta)
    ], DesignSystemProvider.prototype, "accentFillFocusDelta", void 0);
    __decorate2([
      attr({
        attribute: "accent-foreground-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentForegroundRestDelta)
    ], DesignSystemProvider.prototype, "accentForegroundRestDelta", void 0);
    __decorate2([
      attr({
        attribute: "accent-foreground-hover-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentForegroundHoverDelta)
    ], DesignSystemProvider.prototype, "accentForegroundHoverDelta", void 0);
    __decorate2([
      attr({
        attribute: "accent-foreground-active-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentForegroundActiveDelta)
    ], DesignSystemProvider.prototype, "accentForegroundActiveDelta", void 0);
    __decorate2([
      attr({
        attribute: "accent-foreground-focus-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentForegroundFocusDelta)
    ], DesignSystemProvider.prototype, "accentForegroundFocusDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillRestDelta)
    ], DesignSystemProvider.prototype, "neutralFillRestDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-hover-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillHoverDelta)
    ], DesignSystemProvider.prototype, "neutralFillHoverDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-active-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillActiveDelta)
    ], DesignSystemProvider.prototype, "neutralFillActiveDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-focus-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillFocusDelta)
    ], DesignSystemProvider.prototype, "neutralFillFocusDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-input-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillInputRestDelta)
    ], DesignSystemProvider.prototype, "neutralFillInputRestDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-input-hover-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillInputHoverDelta)
    ], DesignSystemProvider.prototype, "neutralFillInputHoverDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-input-active-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillInputActiveDelta)
    ], DesignSystemProvider.prototype, "neutralFillInputActiveDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-input-focus-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillInputFocusDelta)
    ], DesignSystemProvider.prototype, "neutralFillInputFocusDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-stealth-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillStealthRestDelta)
    ], DesignSystemProvider.prototype, "neutralFillStealthRestDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-stealth-hover-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillStealthHoverDelta)
    ], DesignSystemProvider.prototype, "neutralFillStealthHoverDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-stealth-active-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillStealthActiveDelta)
    ], DesignSystemProvider.prototype, "neutralFillStealthActiveDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-stealth-focus-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillStealthFocusDelta)
    ], DesignSystemProvider.prototype, "neutralFillStealthFocusDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-strong-hover-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillStrongHoverDelta)
    ], DesignSystemProvider.prototype, "neutralFillStrongHoverDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-strong-active-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillStrongActiveDelta)
    ], DesignSystemProvider.prototype, "neutralFillStrongActiveDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-strong-focus-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillStrongFocusDelta)
    ], DesignSystemProvider.prototype, "neutralFillStrongFocusDelta", void 0);
    __decorate2([
      attr({
        attribute: "base-layer-luminance",
        converter: nullableNumberConverter
      }),
      designToken(baseLayerLuminance)
    ], DesignSystemProvider.prototype, "baseLayerLuminance", void 0);
    __decorate2([
      attr({
        attribute: "neutral-fill-layer-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillLayerRestDelta)
    ], DesignSystemProvider.prototype, "neutralFillLayerRestDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-stroke-divider-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralStrokeDividerRestDelta)
    ], DesignSystemProvider.prototype, "neutralStrokeDividerRestDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-stroke-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralStrokeRestDelta)
    ], DesignSystemProvider.prototype, "neutralStrokeRestDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-stroke-hover-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralStrokeHoverDelta)
    ], DesignSystemProvider.prototype, "neutralStrokeHoverDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-stroke-active-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralStrokeActiveDelta)
    ], DesignSystemProvider.prototype, "neutralStrokeActiveDelta", void 0);
    __decorate2([
      attr({
        attribute: "neutral-stroke-focus-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralStrokeFocusDelta)
    ], DesignSystemProvider.prototype, "neutralStrokeFocusDelta", void 0);
    designSystemProviderTemplate = (context, definition) => html` <slot></slot> `;
    designSystemProviderStyles = (context, definition) => css`
  ${display("block")}
`;
    jpDesignSystemProvider = DesignSystemProvider.compose({
      baseName: "design-system-provider",
      template: designSystemProviderTemplate,
      styles: designSystemProviderStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/dialog/dialog.styles.js
var dialogStyles;
var init_dialog_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/dialog/dialog.styles.js"() {
    init_esm();
    init_design_tokens();
    init_elevation();
    dialogStyles = (context, definition) => css`
  :host([hidden]) {
    display: none;
  }

  :host {
    --elevation: 14;
    --dialog-height: 480px;
    --dialog-width: 640px;
    display: block;
  }

  .overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.3);
    touch-action: none;
  }

  .positioning-region {
    display: flex;
    justify-content: center;
    position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    overflow: auto;
  }

  .control {
    ${elevation}
    margin-top: auto;
    margin-bottom: auto;
    width: var(--dialog-width);
    height: var(--dialog-height);
    background-color: ${fillColor};
    z-index: 1;
    border-radius: calc(${controlCornerRadius} * 1px);
    border: calc(${strokeWidth} * 1px) solid transparent;
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/dialog/index.js
var jpDialog;
var init_dialog3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/dialog/index.js"() {
    init_esm2();
    init_dialog_styles();
    jpDialog = Dialog.compose({
      baseName: "dialog",
      template: dialogTemplate,
      styles: dialogStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/disclosure/disclosure.styles.js
var disclosureStyles;
var init_disclosure_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/disclosure/disclosure.styles.js"() {
    init_esm();
    init_design_tokens();
    disclosureStyles = (context, definition) => css`
  .disclosure {
    transition: height 0.35s;
  }

  .disclosure .invoker::-webkit-details-marker {
    display: none;
  }

  .disclosure .invoker {
    list-style-type: none;
  }

  :host([appearance='accent']) .invoker {
    background: ${accentFillRest};
    color: ${foregroundOnAccentRest};
    font-family: ${bodyFont};
    font-size: ${typeRampBaseFontSize};
    border-radius: calc(${controlCornerRadius} * 1px);
    outline: none;
    cursor: pointer;
    margin: 16px 0;
    padding: 12px;
    max-width: max-content;
  }

  :host([appearance='accent']) .invoker:active {
    background: ${accentFillActive};
    color: ${foregroundOnAccentActive};
  }

  :host([appearance='accent']) .invoker:hover {
    background: ${accentFillHover};
    color: ${foregroundOnAccentHover};
  }

  :host([appearance='lightweight']) .invoker {
    background: transparent;
    color: ${accentForegroundRest};
    border-bottom: calc(${strokeWidth} * 1px) solid ${accentForegroundRest};
    cursor: pointer;
    width: max-content;
    margin: 16px 0;
  }

  :host([appearance='lightweight']) .invoker:active {
    border-bottom-color: ${accentForegroundActive};
  }

  :host([appearance='lightweight']) .invoker:hover {
    border-bottom-color: ${accentForegroundHover};
  }

  .disclosure[open] .invoker ~ * {
    animation: fadeIn 0.5s ease-in-out;
  }

  @keyframes fadeIn {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/disclosure/index.js
var Disclosure2, jpDisclosure;
var init_disclosure3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/disclosure/index.js"() {
    init_tslib_es62();
    init_esm();
    init_esm2();
    init_disclosure_styles();
    Disclosure2 = class extends Disclosure {
      constructor() {
        super(...arguments);
        this.height = 0;
        this.totalHeight = 0;
      }
      connectedCallback() {
        super.connectedCallback();
        if (!this.appearance) {
          this.appearance = "accent";
        }
      }
      appearanceChanged(oldValue, newValue) {
        if (oldValue !== newValue) {
          this.classList.add(newValue);
          this.classList.remove(oldValue);
        }
      }
      /**
       * Set disclosure height while transitioning
       * @override
       */
      onToggle() {
        super.onToggle();
        this.details.style.setProperty("height", `${this.disclosureHeight}px`);
      }
      /**
       * Calculate disclosure height before and after expanded
       * @override
       */
      setup() {
        super.setup();
        const getCurrentHeight = () => this.details.getBoundingClientRect().height;
        this.show();
        this.totalHeight = getCurrentHeight();
        this.hide();
        this.height = getCurrentHeight();
        if (this.expanded) {
          this.show();
        }
      }
      get disclosureHeight() {
        return this.expanded ? this.totalHeight : this.height;
      }
    };
    __decorate2([
      attr
    ], Disclosure2.prototype, "appearance", void 0);
    jpDisclosure = Disclosure2.compose({
      baseName: "disclosure",
      baseClass: Disclosure,
      template: disclosureTemplate,
      styles: disclosureStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/divider/divider.styles.js
var dividerStyles;
var init_divider_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/divider/divider.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    dividerStyles = (context, definition) => css`
  ${display("block")} :host {
    box-sizing: content-box;
    height: 0;
    margin: calc(${designUnit} * 1px) 0;
    border-top: calc(${strokeWidth} * 1px) solid ${neutralStrokeDividerRest};
    border-left: none;
  }

  :host([orientation='vertical']) {
    height: 100%;
    margin: 0 calc(${designUnit} * 1px);
    border-top: none;
    border-left: calc(${strokeWidth} * 1px) solid ${neutralStrokeDividerRest};
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/divider/index.js
var jpDivider;
var init_divider3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/divider/index.js"() {
    init_esm2();
    init_divider_styles();
    jpDivider = Divider.compose({
      baseName: "divider",
      template: dividerTemplate,
      styles: dividerStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/listbox/index.js
var Listbox2, jpListbox;
var init_listbox3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/listbox/index.js"() {
    init_esm();
    init_esm2();
    init_listbox_styles();
    Listbox2 = class extends ListboxElement {
      /**
       * Updates the component dimensions when the size property is changed.
       *
       * @param prev - the previous size value
       * @param next - the current size value
       *
       * @internal
       */
      sizeChanged(prev, next) {
        super.sizeChanged(prev, next);
        this.updateComputedStylesheet();
      }
      /**
       * Updates an internal stylesheet with calculated CSS custom properties.
       *
       * @internal
       */
      updateComputedStylesheet() {
        if (this.computedStylesheet) {
          this.$fastController.removeStyles(this.computedStylesheet);
        }
        const listboxSize = `${this.size}`;
        this.computedStylesheet = css`
      :host {
        --size: ${listboxSize};
      }
    `;
        this.$fastController.addStyles(this.computedStylesheet);
      }
    };
    jpListbox = Listbox2.compose({
      baseName: "listbox",
      baseClass: ListboxElement,
      template: listboxTemplate,
      styles: listboxStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/menu/menu.styles.js
var menuStyles;
var init_menu_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/menu/menu.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    menuStyles = (context, definition) => css`
    ${display("block")} :host {
      --elevation: 11;
      background: ${fillColor};
      border: calc(${strokeWidth} * 1px) solid transparent;
      ${elevation}
      margin: 0;
      border-radius: calc(${controlCornerRadius} * 1px);
      padding: calc(${designUnit} * 1px) 0;
      max-width: 368px;
      min-width: 64px;
    }

    :host([slot='submenu']) {
      width: max-content;
      margin: 0 calc(${designUnit} * 1px);
    }

    ::slotted(hr) {
      box-sizing: content-box;
      height: 0;
      margin: 0;
      border: none;
      border-top: calc(${strokeWidth} * 1px) solid ${neutralStrokeDividerRest};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host {
        background: ${SystemColors.Canvas};
        border-color: ${SystemColors.CanvasText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/menu/index.js
var Menu3, jpMenu;
var init_menu4 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/menu/index.js"() {
    init_esm2();
    init_design_tokens();
    init_menu_styles();
    Menu3 = class extends Menu2 {
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        fillColor.setValueFor(this, neutralLayerFloating2);
      }
    };
    jpMenu = Menu3.compose({
      baseName: "menu",
      template: menuTemplate,
      styles: menuStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/menu-item/menu-item.styles.js
var menuItemStyles;
var init_menu_item_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/menu-item/menu-item.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    menuItemStyles = (context, definition) => css`
    ${display("grid")} :host {
      contain: layout;
      overflow: visible;
      font-family: ${bodyFont};
      outline: none;
      box-sizing: border-box;
      height: calc(${heightNumber} * 1px);
      grid-template-columns: minmax(42px, auto) 1fr minmax(42px, auto);
      grid-template-rows: auto;
      justify-items: center;
      align-items: center;
      padding: 0;
      margin: 0 calc(${designUnit} * 1px);
      white-space: nowrap;
      background: ${neutralFillStealthRest};
      color: ${neutralForegroundRest};
      fill: currentcolor;
      cursor: pointer;
      font-size: ${typeRampBaseFontSize};
      line-height: ${typeRampBaseLineHeight};
      border-radius: calc(${controlCornerRadius} * 1px);
      border: calc(${focusStrokeWidth} * 1px) solid transparent;
    }

    :host(:hover) {
      position: relative;
      z-index: 1;
    }

    :host(.indent-0) {
      grid-template-columns: auto 1fr minmax(42px, auto);
    }
    :host(.indent-0) .content {
      grid-column: 1;
      grid-row: 1;
      margin-inline-start: 10px;
    }
    :host(.indent-0) .expand-collapse-glyph-container {
      grid-column: 5;
      grid-row: 1;
    }
    :host(.indent-2) {
      grid-template-columns:
        minmax(42px, auto) minmax(42px, auto) 1fr minmax(42px, auto)
        minmax(42px, auto);
    }
    :host(.indent-2) .content {
      grid-column: 3;
      grid-row: 1;
      margin-inline-start: 10px;
    }
    :host(.indent-2) .expand-collapse-glyph-container {
      grid-column: 5;
      grid-row: 1;
    }
    :host(.indent-2) .start {
      grid-column: 2;
    }
    :host(.indent-2) .end {
      grid-column: 4;
    }

    :host(:${focusVisible}) {
      border-color: ${accentFillFocus};
      background: ${neutralFillStealthFocus};
      color: ${neutralForegroundRest};
    }

    :host(:hover) {
      background: ${neutralFillStealthHover};
      color: ${neutralForegroundRest};
    }

    :host(:active) {
      background: ${neutralFillStealthActive};
    }

    :host([aria-checked='true']),
    :host(.expanded) {
      background: ${neutralFillRest};
      color: ${neutralForegroundRest};
    }

    :host([disabled]) {
      cursor: ${disabledCursor};
      opacity: ${disabledOpacity};
    }

    :host([disabled]:hover) {
      color: ${neutralForegroundRest};
      fill: currentcolor;
      background: ${neutralFillStealthRest};
    }

    :host([disabled]:hover) .start,
    :host([disabled]:hover) .end,
    :host([disabled]:hover)::slotted(svg) {
      fill: ${neutralForegroundRest};
    }

    .expand-collapse-glyph {
      /* TODO: adaptive typography https://github.com/microsoft/fast/issues/2432 */
      width: 16px;
      height: 16px;
      fill: currentcolor;
    }

    .content {
      grid-column-start: 2;
      justify-self: start;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .start,
    .end {
      display: flex;
      justify-content: center;
    }

    ::slotted(svg) {
      /* TODO: adaptive typography https://github.com/microsoft/fast/issues/2432 */
      width: 16px;
      height: 16px;
    }

    :host(:hover) .start,
    :host(:hover) .end,
    :host(:hover)::slotted(svg),
    :host(:active) .start,
    :host(:active) .end,
    :host(:active)::slotted(svg) {
      fill: ${neutralForegroundRest};
    }

    :host(.indent-0[aria-haspopup='menu']) {
      display: grid;
      grid-template-columns: minmax(42px, auto) auto 1fr minmax(42px, auto) minmax(
          42px,
          auto
        );
      align-items: center;
      min-height: 32px;
    }

    :host(.indent-1[aria-haspopup='menu']),
    :host(.indent-1[role='menuitemcheckbox']),
    :host(.indent-1[role='menuitemradio']) {
      display: grid;
      grid-template-columns: minmax(42px, auto) auto 1fr minmax(42px, auto) minmax(
          42px,
          auto
        );
      align-items: center;
      min-height: 32px;
    }

    :host(.indent-2:not([aria-haspopup='menu'])) .end {
      grid-column: 5;
    }

    :host .input-container,
    :host .expand-collapse-glyph-container {
      display: none;
    }

    :host([aria-haspopup='menu']) .expand-collapse-glyph-container,
    :host([role='menuitemcheckbox']) .input-container,
    :host([role='menuitemradio']) .input-container {
      display: grid;
      margin-inline-end: 10px;
    }

    :host([aria-haspopup='menu']) .content,
    :host([role='menuitemcheckbox']) .content,
    :host([role='menuitemradio']) .content {
      grid-column-start: 3;
    }

    :host([aria-haspopup='menu'].indent-0) .content {
      grid-column-start: 1;
    }

    :host([aria-haspopup='menu']) .end,
    :host([role='menuitemcheckbox']) .end,
    :host([role='menuitemradio']) .end {
      grid-column-start: 4;
    }

    :host .expand-collapse,
    :host .checkbox,
    :host .radio {
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      width: 20px;
      height: 20px;
      box-sizing: border-box;
      outline: none;
      margin-inline-start: 10px;
    }

    :host .checkbox,
    :host .radio {
      border: calc(${strokeWidth} * 1px) solid ${neutralForegroundRest};
    }

    :host([aria-checked='true']) .checkbox,
    :host([aria-checked='true']) .radio {
      background: ${accentFillRest};
      border-color: ${accentFillRest};
    }

    :host .checkbox {
      border-radius: calc(${controlCornerRadius} * 1px);
    }

    :host .radio {
      border-radius: 999px;
    }

    :host .checkbox-indicator,
    :host .radio-indicator,
    :host .expand-collapse-indicator,
    ::slotted([slot='checkbox-indicator']),
    ::slotted([slot='radio-indicator']),
    ::slotted([slot='expand-collapse-indicator']) {
      display: none;
    }

    ::slotted([slot='end']:not(svg)) {
      margin-inline-end: 10px;
      color: ${neutralForegroundHint2};
    }

    :host([aria-checked='true']) .checkbox-indicator,
    :host([aria-checked='true']) ::slotted([slot='checkbox-indicator']) {
      width: 100%;
      height: 100%;
      display: block;
      fill: ${foregroundOnAccentRest};
      pointer-events: none;
    }

    :host([aria-checked='true']) .radio-indicator {
      position: absolute;
      top: 4px;
      left: 4px;
      right: 4px;
      bottom: 4px;
      border-radius: 999px;
      display: block;
      background: ${foregroundOnAccentRest};
      pointer-events: none;
    }

    :host([aria-checked='true']) ::slotted([slot='radio-indicator']) {
      display: block;
      pointer-events: none;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host {
        border-color: transparent;
        color: ${SystemColors.ButtonText};
        forced-color-adjust: none;
      }

      :host(:hover) {
        background: ${SystemColors.Highlight};
        color: ${SystemColors.HighlightText};
      }

      :host(:hover) .start,
      :host(:hover) .end,
      :host(:hover)::slotted(svg),
      :host(:active) .start,
      :host(:active) .end,
      :host(:active)::slotted(svg) {
        fill: ${SystemColors.HighlightText};
      }

      :host(.expanded) {
        background: ${SystemColors.Highlight};
        border-color: ${SystemColors.Highlight};
        color: ${SystemColors.HighlightText};
      }

      :host(:${focusVisible}) {
        background: ${SystemColors.Highlight};
        border-color: ${SystemColors.ButtonText};
        box-shadow: 0 0 0 calc(${focusStrokeWidth} * 1px) inset
          ${SystemColors.HighlightText};
        color: ${SystemColors.HighlightText};
        fill: currentcolor;
      }

      :host([disabled]),
      :host([disabled]:hover),
      :host([disabled]:hover) .start,
      :host([disabled]:hover) .end,
      :host([disabled]:hover)::slotted(svg) {
        background: ${SystemColors.Canvas};
        color: ${SystemColors.GrayText};
        fill: currentcolor;
        opacity: 1;
      }

      :host .expanded-toggle,
      :host .checkbox,
      :host .radio {
        border-color: ${SystemColors.ButtonText};
        background: ${SystemColors.HighlightText};
      }

      :host([checked='true']) .checkbox,
      :host([checked='true']) .radio {
        background: ${SystemColors.HighlightText};
        border-color: ${SystemColors.HighlightText};
      }

      :host(:hover) .expanded-toggle,
            :host(:hover) .checkbox,
            :host(:hover) .radio,
            :host(:${focusVisible}) .expanded-toggle,
            :host(:${focusVisible}) .checkbox,
            :host(:${focusVisible}) .radio,
            :host([checked="true"]:hover) .checkbox,
            :host([checked="true"]:hover) .radio,
            :host([checked="true"]:${focusVisible}) .checkbox,
            :host([checked="true"]:${focusVisible}) .radio {
        border-color: ${SystemColors.HighlightText};
      }

      :host([aria-checked='true']) {
        background: ${SystemColors.Highlight};
        color: ${SystemColors.HighlightText};
      }

      :host([aria-checked='true']) .checkbox-indicator,
      :host([aria-checked='true']) ::slotted([slot='checkbox-indicator']),
      :host([aria-checked='true']) ::slotted([slot='radio-indicator']) {
        fill: ${SystemColors.Highlight};
      }

      :host([aria-checked='true']) .radio-indicator {
        background: ${SystemColors.Highlight};
      }

      ::slotted([slot='end']:not(svg)) {
        color: ${SystemColors.ButtonText};
      }

      :host(:hover) ::slotted([slot="end"]:not(svg)),
            :host(:${focusVisible}) ::slotted([slot="end"]:not(svg)) {
        color: ${SystemColors.HighlightText};
      }
    `), new DirectionalStyleSheetBehavior(css`
        .expand-collapse-glyph {
          transform: rotate(0deg);
        }
      `, css`
        .expand-collapse-glyph {
          transform: rotate(180deg);
        }
      `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/menu-item/index.js
var jpMenuItem;
var init_menu_item3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/menu-item/index.js"() {
    init_esm2();
    init_menu_item_styles();
    jpMenuItem = MenuItem.compose({
      baseName: "menu-item",
      template: menuItemTemplate,
      styles: menuItemStyles,
      checkboxIndicator: (
        /* html */
        `
        <svg
            part="checkbox-indicator"
            class="checkbox-indicator"
            viewBox="0 0 20 20"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M8.143 12.6697L15.235 4.5L16.8 5.90363L8.23812 15.7667L3.80005 11.2556L5.27591 9.7555L8.143 12.6697Z"
            />
        </svg>
    `
      ),
      expandCollapseGlyph: (
        /* html */
        `
        <svg
            viewBox="0 0 16 16"
            xmlns="http://www.w3.org/2000/svg"
            class="expand-collapse-glyph"
            part="expand-collapse-glyph"
        >
            <path
                d="M5.00001 12.3263C5.00124 12.5147 5.05566 12.699 5.15699 12.8578C5.25831 13.0167 5.40243 13.1437 5.57273 13.2242C5.74304 13.3047 5.9326 13.3354 6.11959 13.3128C6.30659 13.2902 6.4834 13.2152 6.62967 13.0965L10.8988 8.83532C11.0739 8.69473 11.2153 8.51658 11.3124 8.31402C11.4096 8.11146 11.46 7.88966 11.46 7.66499C11.46 7.44033 11.4096 7.21853 11.3124 7.01597C11.2153 6.81341 11.0739 6.63526 10.8988 6.49467L6.62967 2.22347C6.48274 2.10422 6.30501 2.02912 6.11712 2.00691C5.92923 1.9847 5.73889 2.01628 5.56823 2.09799C5.39757 2.17969 5.25358 2.30817 5.153 2.46849C5.05241 2.62882 4.99936 2.8144 5.00001 3.00369V12.3263Z"
            />
        </svg>
    `
      ),
      radioIndicator: (
        /* html */
        `
        <span part="radio-indicator" class="radio-indicator"></span>
    `
      )
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/number-field/number-field.styles.js
var numberFieldStyles;
var init_number_field_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/number-field/number-field.styles.js"() {
    init_esm();
    init_design_tokens();
    init_styles();
    numberFieldStyles = (context, definition) => css`
  ${BaseFieldStyles}

  .controls {
    opacity: 0;
  }

  .step-up-glyph,
  .step-down-glyph {
    display: block;
    padding: 4px 10px;
    cursor: pointer;
  }

  .step-up-glyph:before,
  .step-down-glyph:before {
    content: '';
    display: block;
    border: solid transparent 6px;
  }

  .step-up-glyph:before {
    border-bottom-color: ${neutralForegroundRest};
  }

  .step-down-glyph:before {
    border-top-color: ${neutralForegroundRest};
  }

  :host(:hover:not([disabled])) .controls,
  :host(:focus-within:not([disabled])) .controls {
    opacity: 1;
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/number-field/index.js
var NumberField2, jpNumberField;
var init_number_field3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/number-field/index.js"() {
    init_tslib_es62();
    init_esm();
    init_esm2();
    init_number_field_styles();
    NumberField2 = class extends NumberField {
      constructor() {
        super(...arguments);
        this.appearance = "outline";
      }
    };
    __decorate2([
      attr
    ], NumberField2.prototype, "appearance", void 0);
    jpNumberField = NumberField2.compose({
      baseName: "number-field",
      baseClass: NumberField,
      styles: numberFieldStyles,
      template: numberFieldTemplate,
      shadowOptions: {
        delegatesFocus: true
      },
      stepDownGlyph: (
        /* html */
        `
        <span class="step-down-glyph" part="step-down-glyph"></span>
    `
      ),
      stepUpGlyph: (
        /* html */
        `
        <span class="step-up-glyph" part="step-up-glyph"></span>
    `
      )
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/option/option.styles.js
var optionStyles;
var init_option_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/option/option.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_size();
    optionStyles = (context, definition) => css`
    ${display("inline-flex")} :host {
      align-items: center;
      font-family: ${bodyFont};
      border-radius: calc(${controlCornerRadius} * 1px);
      border: calc(${focusStrokeWidth} * 1px) solid transparent;
      box-sizing: border-box;
      background: ${neutralFillStealthRest};
      color: ${neutralForegroundRest};
      cursor: pointer;
      flex: 0 0 auto;
      fill: currentcolor;
      font-size: ${typeRampBaseFontSize};
      height: calc(${heightNumber} * 1px);
      line-height: ${typeRampBaseLineHeight};
      margin: 0 calc((${designUnit} - ${focusStrokeWidth}) * 1px);
      outline: none;
      overflow: hidden;
      padding: 0 1ch;
      user-select: none;
      white-space: nowrap;
    }

    :host(:not([disabled]):not([aria-selected='true']):hover) {
      background: ${neutralFillStealthHover};
    }

    :host(:not([disabled]):not([aria-selected='true']):active) {
      background: ${neutralFillStealthActive};
    }

    :host([aria-selected='true']) {
      background: ${accentFillRest};
      color: ${foregroundOnAccentRest};
    }

    :host(:not([disabled])[aria-selected='true']:hover) {
      background: ${accentFillHover};
      color: ${foregroundOnAccentHover};
    }

    :host(:not([disabled])[aria-selected='true']:active) {
      background: ${accentFillActive};
      color: ${foregroundOnAccentActive};
    }

    :host([disabled]) {
      cursor: ${disabledCursor};
      opacity: ${disabledOpacity};
    }

    .content {
      grid-column-start: 2;
      justify-self: start;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .start,
    .end,
    ::slotted(svg) {
      display: flex;
    }

    ::slotted(svg) {
      /* TODO: adaptive typography https://github.com/microsoft/fast/issues/2432 */
      height: calc(${designUnit} * 4px);
      width: calc(${designUnit} * 4px);
    }

    ::slotted([slot='end']) {
      margin-inline-start: 1ch;
    }

    ::slotted([slot='start']) {
      margin-inline-end: 1ch;
    }

    :host([aria-checked='true'][aria-selected='false']) {
      border-color: ${focusStrokeOuter2};
    }

    :host([aria-checked='true'][aria-selected='true']) {
      border-color: ${focusStrokeOuter2};
      box-shadow: 0 0 0 calc(${focusStrokeWidth} * 2 * 1px) inset
        ${focusStrokeInner2};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host {
        border-color: transparent;
        forced-color-adjust: none;
        color: ${SystemColors.ButtonText};
        fill: currentcolor;
      }

      :host(:not([aria-selected='true']):hover),
      :host([aria-selected='true']) {
        background: ${SystemColors.Highlight};
        color: ${SystemColors.HighlightText};
      }

      :host([disabled]),
      :host([disabled][aria-selected='false']:hover) {
        background: ${SystemColors.Canvas};
        color: ${SystemColors.GrayText};
        fill: currentcolor;
        opacity: 1;
      }

      :host([aria-checked='true'][aria-selected='false']) {
        background: ${SystemColors.ButtonFace};
        color: ${SystemColors.ButtonText};
        border-color: ${SystemColors.ButtonText};
      }

      :host([aria-checked='true'][aria-selected='true']),
      :host([aria-checked='true'][aria-selected='true']:hover) {
        background: ${SystemColors.Highlight};
        color: ${SystemColors.HighlightText};
        border-color: ${SystemColors.ButtonText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/option/index.js
var jpOption;
var init_option = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/option/index.js"() {
    init_esm2();
    init_option_styles();
    jpOption = ListboxOption.compose({
      baseName: "option",
      template: listboxOptionTemplate,
      styles: optionStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/progress/progress.styles.js
var progressStyles;
var init_progress_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/progress/progress.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    progressStyles = (context, definition) => css`
    ${display("flex")} :host {
      align-items: center;
      outline: none;
      height: calc(${designUnit} * 1px);
      margin: calc(${designUnit} * 1px) 0;
    }

    .progress {
      background-color: ${neutralFillRest};
      border-radius: calc(${designUnit} * 1px);
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      position: relative;
    }

    .determinate {
      background-color: ${accentForegroundRest};
      border-radius: calc(${designUnit} * 1px);
      height: 100%;
      transition: all 0.2s ease-in-out;
      display: flex;
    }

    .indeterminate {
      height: 100%;
      border-radius: calc(${designUnit} * 1px);
      display: flex;
      width: 100%;
      position: relative;
      overflow: hidden;
    }

    .indeterminate-indicator-1 {
      position: absolute;
      opacity: 0;
      height: 100%;
      background-color: ${accentForegroundRest};
      border-radius: calc(${designUnit} * 1px);
      animation-timing-function: cubic-bezier(0.4, 0, 0.6, 1);
      width: 40%;
      animation: indeterminate-1 2s infinite;
    }

    .indeterminate-indicator-2 {
      position: absolute;
      opacity: 0;
      height: 100%;
      background-color: ${accentForegroundRest};
      border-radius: calc(${designUnit} * 1px);
      animation-timing-function: cubic-bezier(0.4, 0, 0.6, 1);
      width: 60%;
      animation: indeterminate-2 2s infinite;
    }

    :host([paused]) .indeterminate-indicator-1,
    :host([paused]) .indeterminate-indicator-2 {
      animation-play-state: paused;
      background-color: ${neutralFillRest};
    }

    :host([paused]) .determinate {
      background-color: ${neutralForegroundHint2};
    }

    @keyframes indeterminate-1 {
      0% {
        opacity: 1;
        transform: translateX(-100%);
      }
      70% {
        opacity: 1;
        transform: translateX(300%);
      }
      70.01% {
        opacity: 0;
      }
      100% {
        opacity: 0;
        transform: translateX(300%);
      }
    }

    @keyframes indeterminate-2 {
      0% {
        opacity: 0;
        transform: translateX(-150%);
      }
      29.99% {
        opacity: 0;
      }
      30% {
        opacity: 1;
        transform: translateX(-150%);
      }
      100% {
        transform: translateX(166.66%);
        opacity: 1;
      }
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      .progress {
        forced-color-adjust: none;
        background-color: ${SystemColors.Field};
        box-shadow: 0 0 0 1px inset ${SystemColors.FieldText};
      }
      .determinate,
      .indeterminate-indicator-1,
      .indeterminate-indicator-2 {
        forced-color-adjust: none;
        background-color: ${SystemColors.FieldText};
      }
      :host([paused]) .determinate,
      :host([paused]) .indeterminate-indicator-1,
      :host([paused]) .indeterminate-indicator-2 {
        background-color: ${SystemColors.GrayText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/progress/index.js
var jpProgress;
var init_progress2 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/progress/index.js"() {
    init_esm2();
    init_progress_styles();
    jpProgress = BaseProgress.compose({
      baseName: "progress",
      template: progressTemplate,
      styles: progressStyles,
      indeterminateIndicator1: (
        /* html */
        `
        <span class="indeterminate-indicator-1" part="indeterminate-indicator-1"></span>
    `
      ),
      indeterminateIndicator2: (
        /* html */
        `
        <span class="indeterminate-indicator-2" part="indeterminate-indicator-2"></span>
    `
      )
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/progress-ring/progress-ring.styles.js
var progressRingStyles;
var init_progress_ring_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/progress-ring/progress-ring.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_size();
    progressRingStyles = (context, definition) => css`
    ${display("flex")} :host {
      align-items: center;
      outline: none;
      height: calc(${heightNumber} * 1px);
      width: calc(${heightNumber} * 1px);
      margin: calc(${heightNumber} * 1px) 0;
    }

    .progress {
      height: 100%;
      width: 100%;
    }

    .background {
      stroke: ${neutralFillRest};
      fill: none;
      stroke-width: 2px;
    }

    .determinate {
      stroke: ${accentForegroundRest};
      fill: none;
      stroke-width: 2px;
      stroke-linecap: round;
      transform-origin: 50% 50%;
      transform: rotate(-90deg);
      transition: all 0.2s ease-in-out;
    }

    .indeterminate-indicator-1 {
      stroke: ${accentForegroundRest};
      fill: none;
      stroke-width: 2px;
      stroke-linecap: round;
      transform-origin: 50% 50%;
      transform: rotate(-90deg);
      transition: all 0.2s ease-in-out;
      animation: spin-infinite 2s linear infinite;
    }

    :host([paused]) .indeterminate-indicator-1 {
      animation-play-state: paused;
      stroke: ${neutralFillRest};
    }

    :host([paused]) .determinate {
      stroke: ${neutralForegroundHint2};
    }

    @keyframes spin-infinite {
      0% {
        stroke-dasharray: 0.01px 43.97px;
        transform: rotate(0deg);
      }
      50% {
        stroke-dasharray: 21.99px 21.99px;
        transform: rotate(450deg);
      }
      100% {
        stroke-dasharray: 0.01px 43.97px;
        transform: rotate(1080deg);
      }
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      .indeterminate-indicator-1,
      .determinate {
        stroke: ${SystemColors.FieldText};
      }
      .background {
        stroke: ${SystemColors.Field};
      }
      :host([paused]) .indeterminate-indicator-1 {
        stroke: ${SystemColors.Field};
      }
      :host([paused]) .determinate {
        stroke: ${SystemColors.GrayText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/progress-ring/index.js
var jpProgressRing;
var init_progress_ring2 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/progress-ring/index.js"() {
    init_esm2();
    init_progress_ring_styles();
    jpProgressRing = BaseProgress.compose({
      baseName: "progress-ring",
      template: progressRingTemplate,
      styles: progressRingStyles,
      indeterminateIndicator: (
        /* html */
        `
        <svg class="progress" part="progress" viewBox="0 0 16 16">
            <circle
                class="background"
                part="background"
                cx="8px"
                cy="8px"
                r="7px"
            ></circle>
            <circle
                class="indeterminate-indicator-1"
                part="indeterminate-indicator-1"
                cx="8px"
                cy="8px"
                r="7px"
            ></circle>
        </svg>
    `
      )
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/radio/radio.styles.js
var radioStyles;
var init_radio_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/radio/radio.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    radioStyles = (context, definition) => css`
    ${display("inline-flex")} :host {
      --input-size: calc((${heightNumber} / 2) + ${designUnit});
      align-items: center;
      outline: none;
      margin: calc(${designUnit} * 1px) 0;
      /* Chromium likes to select label text or the default slot when
                the radio is clicked. Maybe there is a better solution here? */
      user-select: none;
      position: relative;
      flex-direction: row;
      transition: all 0.2s ease-in-out;
    }

    .control {
      position: relative;
      width: calc((${heightNumber} / 2 + ${designUnit}) * 1px);
      height: calc((${heightNumber} / 2 + ${designUnit}) * 1px);
      box-sizing: border-box;
      border-radius: 999px;
      border: calc(${strokeWidth} * 1px) solid ${neutralStrokeRest};
      background: ${neutralFillInputRest};
      outline: none;
      cursor: pointer;
    }

    :host([aria-invalid='true']) .control {
      border-color: ${errorFillRest};
    }

    .label {
      font-family: ${bodyFont};
      color: ${neutralForegroundRest};
      padding-inline-start: calc(${designUnit} * 2px + 2px);
      margin-inline-end: calc(${designUnit} * 2px + 2px);
      cursor: pointer;
      font-size: ${typeRampBaseFontSize};
      line-height: ${typeRampBaseLineHeight};
    }

    .label__hidden {
      display: none;
      visibility: hidden;
    }

    .control,
    .checked-indicator {
      flex-shrink: 0;
    }

    .checked-indicator {
      position: absolute;
      top: 5px;
      left: 5px;
      right: 5px;
      bottom: 5px;
      border-radius: 999px;
      display: inline-block;
      background: ${foregroundOnAccentRest};
      fill: ${foregroundOnAccentRest};
      opacity: 0;
      pointer-events: none;
    }

    :host(:not([disabled])) .control:hover {
      background: ${neutralFillInputHover};
      border-color: ${neutralStrokeHover};
    }

    :host([aria-invalid='true']:not([disabled])) .control:hover {
      border-color: ${errorFillHover};
    }

    :host(:not([disabled])) .control:active {
      background: ${neutralFillInputActive};
      border-color: ${neutralStrokeActive};
    }

    :host([aria-invalid='true']:not([disabled])) .control:active {
      border-color: ${errorFillActive};
    }

    :host(:${focusVisible}) .control {
      outline: solid calc(${focusStrokeWidth} * 1px) ${accentFillFocus};
    }

    :host([aria-invalid='true']:${focusVisible}) .control {
      outline-color: ${errorFillFocus};
    }

    :host([aria-checked='true']) .control {
      background: ${accentFillRest};
      border: calc(${strokeWidth} * 1px) solid ${accentFillRest};
    }

    :host([aria-invalid='true'][aria-checked='true']) .control {
      background-color: ${errorFillRest};
      border-color: ${errorFillRest};
    }

    :host([aria-checked='true']:not([disabled])) .control:hover {
      background: ${accentFillHover};
      border: calc(${strokeWidth} * 1px) solid ${accentFillHover};
    }

    :host([aria-invalid='true'][aria-checked='true']:not([disabled]))
      .control:hover {
      background-color: ${errorFillHover};
      border-color: ${errorFillHover};
    }

    :host([aria-checked='true']:not([disabled]))
      .control:hover
      .checked-indicator {
      background: ${foregroundOnAccentHover};
      fill: ${foregroundOnAccentHover};
    }

    :host([aria-checked='true']:not([disabled])) .control:active {
      background: ${accentFillActive};
      border: calc(${strokeWidth} * 1px) solid ${accentFillActive};
    }

    :host([aria-invalid='true'][aria-checked='true']:not([disabled]))
      .control:active {
      background-color: ${errorFillActive};
      border-color: ${errorFillActive};
    }

    :host([aria-checked='true']:not([disabled]))
      .control:active
      .checked-indicator {
      background: ${foregroundOnAccentActive};
      fill: ${foregroundOnAccentActive};
    }

    :host([aria-checked="true"]:${focusVisible}:not([disabled])) .control {
      outline-offset: 2px;
      outline: solid calc(${focusStrokeWidth} * 1px) ${accentFillFocus};
    }

    :host([aria-invalid='true'][aria-checked="true"]:${focusVisible}:not([disabled])) .control {
      outline-color: ${errorFillFocus};
    }

    :host([disabled]) .label,
    :host([readonly]) .label,
    :host([readonly]) .control,
    :host([disabled]) .control {
      cursor: ${disabledCursor};
    }

    :host([aria-checked='true']) .checked-indicator {
      opacity: 1;
    }

    :host([disabled]) {
      opacity: ${disabledOpacity};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      .control,
      :host([aria-checked='true']:not([disabled])) .control {
        forced-color-adjust: none;
        border-color: ${SystemColors.FieldText};
        background: ${SystemColors.Field};
      }
      :host([aria-invalid='true']) {
        border-style: dashed;
      }
      :host(:not([disabled])) .control:hover {
        border-color: ${SystemColors.Highlight};
        background: ${SystemColors.Field};
      }
      :host([aria-checked='true']:not([disabled])) .control:hover,
      :host([aria-checked='true']:not([disabled])) .control:active {
        border-color: ${SystemColors.Highlight};
        background: ${SystemColors.Highlight};
      }
      :host([aria-checked='true']) .checked-indicator {
        background: ${SystemColors.Highlight};
        fill: ${SystemColors.Highlight};
      }
      :host([aria-checked='true']:not([disabled]))
        .control:hover
        .checked-indicator,
      :host([aria-checked='true']:not([disabled]))
        .control:active
        .checked-indicator {
        background: ${SystemColors.HighlightText};
        fill: ${SystemColors.HighlightText};
      }
      :host(:${focusVisible}) .control {
        border-color: ${SystemColors.Highlight};
        outline-offset: 2px;
        outline: solid calc(${focusStrokeWidth} * 1px) ${SystemColors.FieldText};
      }
      :host([aria-checked="true"]:${focusVisible}:not([disabled])) .control {
        border-color: ${SystemColors.Highlight};
        outline: solid calc(${focusStrokeWidth} * 1px) ${SystemColors.FieldText};
      }
      :host([disabled]) {
        forced-color-adjust: none;
        opacity: 1;
      }
      :host([disabled]) .label {
        color: ${SystemColors.GrayText};
      }
      :host([disabled]) .control,
      :host([aria-checked='true'][disabled]) .control:hover,
      .control:active {
        background: ${SystemColors.Field};
        border-color: ${SystemColors.GrayText};
      }
      :host([disabled]) .checked-indicator,
      :host([aria-checked='true'][disabled]) .control:hover .checked-indicator {
        fill: ${SystemColors.GrayText};
        background: ${SystemColors.GrayText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/radio/index.js
var radioTemplate, Radio2, jpRadio;
var init_radio3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/radio/index.js"() {
    init_esm2();
    init_radio_styles();
    init_esm();
    radioTemplate = (context, definition) => html`
  <template
    role="radio"
    aria-checked="${(x) => x.checked}"
    aria-required="${(x) => x.required}"
    aria-disabled="${(x) => x.disabled}"
    aria-readonly="${(x) => x.readOnly}"
    @keypress="${(x, c) => x.keypressHandler(c.event)}"
    @click="${(x, c) => x.clickHandler(c.event)}"
  >
    <div part="control" class="control">
      <slot name="checked-indicator">
        ${definition.checkedIndicator || ""}
      </slot>
    </div>
    <label
      part="label"
      class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
    >
      <slot ${slotted("defaultSlottedNodes")}></slot>
    </label>
  </template>
`;
    Radio2 = class extends Radio {
    };
    jpRadio = Radio2.compose({
      baseName: "radio",
      baseClass: Radio,
      template: radioTemplate,
      styles: radioStyles,
      checkedIndicator: (
        /* html */
        `
        <div part="checked-indicator" class="checked-indicator"></div>
    `
      )
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/radio-group/radio-group.styles.js
var radioGroupStyles;
var init_radio_group_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/radio-group/radio-group.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    radioGroupStyles = (context, definition) => css`
  ${display("flex")} :host {
    align-items: flex-start;
    margin: calc(${designUnit} * 1px) 0;
    flex-direction: column;
  }
  .positioning-region {
    display: flex;
    flex-wrap: wrap;
  }
  :host([orientation='vertical']) .positioning-region {
    flex-direction: column;
  }
  :host([orientation='horizontal']) .positioning-region {
    flex-direction: row;
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/radio-group/index.js
var RadioGroup2, jpRadioGroup;
var init_radio_group3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/radio-group/index.js"() {
    init_esm2();
    init_radio_group_styles();
    init_esm();
    RadioGroup2 = class extends RadioGroup {
      constructor() {
        super();
        const notifier = Observable.getNotifier(this);
        const handler = {
          handleChange(source, propertyName) {
            if (propertyName === "slottedRadioButtons") {
              source.ariaInvalidChanged();
            }
          }
        };
        notifier.subscribe(handler, "slottedRadioButtons");
      }
      ariaInvalidChanged() {
        if (this.slottedRadioButtons) {
          this.slottedRadioButtons.forEach((radio) => {
            var _a;
            radio.setAttribute("aria-invalid", (_a = this.getAttribute("aria-invalid")) !== null && _a !== void 0 ? _a : "false");
          });
        }
      }
    };
    jpRadioGroup = RadioGroup2.compose({
      baseName: "radio-group",
      baseClass: RadioGroup,
      template: radioGroupTemplate,
      styles: radioGroupStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/search/search.styles.js
var clearButtonHover, clearButtonActive, searchStyles;
var init_search_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/search/search.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    init_styles();
    clearButtonHover = DesignToken.create("clear-button-hover").withDefault((target2) => {
      const buttonRecipe = neutralFillStealthRecipe.getValueFor(target2);
      const inputRecipe = neutralFillRecipe.getValueFor(target2);
      return buttonRecipe.evaluate(target2, inputRecipe.evaluate(target2).hover).hover;
    });
    clearButtonActive = DesignToken.create("clear-button-active").withDefault((target2) => {
      const buttonRecipe = neutralFillStealthRecipe.getValueFor(target2);
      const inputRecipe = neutralFillRecipe.getValueFor(target2);
      return buttonRecipe.evaluate(target2, inputRecipe.evaluate(target2).hover).active;
    });
    searchStyles = (context, definition) => css`
  ${BaseFieldStyles}

  .control::-webkit-search-cancel-button {
    -webkit-appearance: none;
  }

  .control:hover,
    .control:${focusVisible},
    .control:disabled,
    .control:active {
    outline: none;
  }

  .clear-button {
    height: calc(100% - 2px);
    opacity: 0;
    margin: 1px;
    background: transparent;
    color: ${neutralForegroundRest};
    fill: currentcolor;
    border: none;
    border-radius: calc(${controlCornerRadius} * 1px);
    min-width: calc(${heightNumber} * 1px);
    font-size: ${typeRampBaseFontSize};
    line-height: ${typeRampBaseLineHeight};
    outline: none;
    font-family: ${bodyFont};
    padding: 0 calc((10 + (${designUnit} * 2 * ${density})) * 1px);
  }

  .clear-button:hover {
    background: ${neutralFillStealthHover};
  }

  .clear-button:active {
    background: ${neutralFillStealthActive};
  }

  :host([appearance='filled']) .clear-button:hover {
    background: ${clearButtonHover};
  }

  :host([appearance='filled']) .clear-button:active {
    background: ${clearButtonActive};
  }

  .input-wrapper {
    display: flex;
    position: relative;
    width: 100%;
  }

  .start,
  .end {
    display: flex;
    margin: 1px;
    fill: currentcolor;
  }

  ::slotted([slot='end']) {
    height: 100%;
  }

  .end {
    margin-inline-end: 1px;
    height: calc(100% - 2px);
  }

  ::slotted(svg) {
    /* TODO: adaptive typography https://github.com/microsoft/fast/issues/2432 */
    width: 16px;
    height: 16px;
    margin-inline-end: 11px;
    margin-inline-start: 11px;
    margin-top: auto;
    margin-bottom: auto;
  }

  .clear-button__hidden {
    opacity: 0;
  }

  :host(:hover:not([disabled], [readOnly])) .clear-button,
  :host(:active:not([disabled], [readOnly])) .clear-button,
  :host(:focus-within:not([disabled], [readOnly])) .clear-button {
    opacity: 1;
  }

  :host(:hover:not([disabled], [readOnly])) .clear-button__hidden,
  :host(:active:not([disabled], [readOnly])) .clear-button__hidden,
  :host(:focus-within:not([disabled], [readOnly])) .clear-button__hidden {
    opacity: 0;
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/search/index.js
var Search2, jpSearch;
var init_search4 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/search/index.js"() {
    init_tslib_es62();
    init_esm();
    init_esm2();
    init_search_styles();
    Search2 = class extends Search {
      constructor() {
        super(...arguments);
        this.appearance = "outline";
      }
    };
    __decorate2([
      attr
    ], Search2.prototype, "appearance", void 0);
    jpSearch = Search2.compose({
      baseName: "search",
      baseClass: Search,
      template: searchTemplate,
      styles: searchStyles,
      shadowOptions: {
        delegatesFocus: true
      }
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/select/index.js
var Select2, jpSelect;
var init_select3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/select/index.js"() {
    init_tslib_es62();
    init_esm();
    init_esm2();
    init_design_tokens();
    init_select_styles();
    Select2 = class extends Select {
      constructor() {
        super(...arguments);
        this.listboxScrollWidth = "";
      }
      /**
       * (Un-)set the width when the autoWidth property changes.
       *
       * @param prev - the previous autoWidth value
       * @param next - the current autoWidth value
       */
      autoWidthChanged(prev, next) {
        if (next) {
          this.setAutoWidth();
        } else {
          this.style.removeProperty("width");
        }
      }
      /**
       * Compute the listbox width to set the one of the input.
       */
      setAutoWidth() {
        if (!this.autoWidth || !this.isConnected) {
          return;
        }
        let listWidth = this.listbox.getBoundingClientRect().width;
        if (listWidth === 0 && this.listbox.hidden) {
          Object.assign(this.listbox.style, { visibility: "hidden" });
          this.listbox.removeAttribute("hidden");
          listWidth = this.listbox.getBoundingClientRect().width;
          this.listbox.setAttribute("hidden", "");
          this.listbox.style.removeProperty("visibility");
        }
        if (listWidth > 0) {
          Object.assign(this.style, { width: `${listWidth}px` });
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.setAutoWidth();
        if (this.listbox) {
          fillColor.setValueFor(this.listbox, neutralLayerFloating2);
        }
      }
      /**
       * Synchronize the form-associated proxy and updates the value property of the element.
       *
       * @param prev - the previous collection of slotted option elements
       * @param next - the next collection of slotted option elements
       *
       * @internal
       */
      slottedOptionsChanged(prev, next) {
        super.slottedOptionsChanged(prev, next);
        this.setAutoWidth();
      }
      /**
       * Returns the calculated max height for the listbox.
       *
       * @internal
       * @remarks
       * Used to generate the `--listbox-max-height` CSS custom property.
       *
       */
      get listboxMaxHeight() {
        return Math.floor(this.maxHeight / heightNumberAsToken.getValueFor(this)).toString();
      }
      /**
       * @internal
       */
      listboxScrollWidthChanged() {
        this.updateComputedStylesheet();
      }
      /**
       * Returns the size value, if any. Otherwise, returns 4 if in
       * multi-selection mode, or 0 if in single-selection mode.
       *
       * @internal
       * @remarks
       * Used to generate the `--size` CSS custom property.
       *
       */
      get selectSize() {
        var _a;
        return `${(_a = this.size) !== null && _a !== void 0 ? _a : this.multiple ? 4 : 0}`;
      }
      /**
       * Updates the computed stylesheet when the multiple property changes.
       *
       * @param prev - the previous multiple value
       * @param next - the current multiple value
       *
       * @override
       * @internal
       */
      multipleChanged(prev, next) {
        super.multipleChanged(prev, next);
        this.updateComputedStylesheet();
      }
      /**
       * Sets the selectMaxSize design token when the maxHeight property changes.
       *
       * @param prev - the previous maxHeight value
       * @param next - the current maxHeight value
       *
       * @internal
       */
      maxHeightChanged(prev, next) {
        if (this.collapsible) {
          this.updateComputedStylesheet();
        }
      }
      setPositioning() {
        super.setPositioning();
        this.updateComputedStylesheet();
      }
      /**
       * Updates the component dimensions when the size property is changed.
       *
       * @param prev - the previous size value
       * @param next - the current size value
       *
       * @override
       * @internal
       */
      sizeChanged(prev, next) {
        super.sizeChanged(prev, next);
        this.updateComputedStylesheet();
        if (this.collapsible) {
          requestAnimationFrame(() => {
            this.listbox.style.setProperty("display", "flex");
            this.listbox.style.setProperty("overflow", "visible");
            this.listbox.style.setProperty("visibility", "hidden");
            this.listbox.style.setProperty("width", "auto");
            this.listbox.hidden = false;
            this.listboxScrollWidth = `${this.listbox.scrollWidth}`;
            this.listbox.hidden = true;
            this.listbox.style.removeProperty("display");
            this.listbox.style.removeProperty("overflow");
            this.listbox.style.removeProperty("visibility");
            this.listbox.style.removeProperty("width");
          });
          return;
        }
        this.listboxScrollWidth = "";
      }
      /**
       * Updates an internal stylesheet with calculated CSS custom properties.
       *
       * @internal
       */
      updateComputedStylesheet() {
        if (this.computedStylesheet) {
          this.$fastController.removeStyles(this.computedStylesheet);
        }
        this.computedStylesheet = css`
      :host {
        --listbox-max-height: ${this.listboxMaxHeight};
        --listbox-scroll-width: ${this.listboxScrollWidth};
        --size: ${this.selectSize};
      }
    `;
        this.$fastController.addStyles(this.computedStylesheet);
      }
    };
    __decorate2([
      attr({ attribute: "autowidth", mode: "boolean" })
    ], Select2.prototype, "autoWidth", void 0);
    __decorate2([
      attr({ attribute: "minimal", mode: "boolean" })
    ], Select2.prototype, "minimal", void 0);
    __decorate2([
      observable
    ], Select2.prototype, "listboxScrollWidth", void 0);
    jpSelect = Select2.compose({
      baseName: "select",
      baseClass: Select,
      template: selectTemplate,
      styles: selectStyles,
      indicator: (
        /* html */
        `
        <svg
            class="select-indicator"
            part="select-indicator"
            viewBox="0 0 12 7"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                d="M11.85.65c.2.2.2.5 0 .7L6.4 6.84a.55.55 0 01-.78 0L.14 1.35a.5.5 0 11.71-.7L6 5.8 11.15.65c.2-.2.5-.2.7 0z"
            />
        </svg>
    `
      )
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/skeleton/skeleton.styles.js
var skeletonStyles;
var init_skeleton_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/skeleton/skeleton.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_esm2();
    init_design_tokens();
    skeletonStyles = (context, definition) => css`
    ${display("block")} :host {
      --skeleton-fill-default: #e1dfdd;
      overflow: hidden;
      width: 100%;
      position: relative;
      background-color: var(--skeleton-fill, var(--skeleton-fill-default));
      --skeleton-animation-gradient-default: linear-gradient(
        270deg,
        var(--skeleton-fill, var(--skeleton-fill-default)) 0%,
        #f3f2f1 51.13%,
        var(--skeleton-fill, var(--skeleton-fill-default)) 100%
      );
      --skeleton-animation-timing-default: ease-in-out;
    }

    :host([shape='rect']) {
      border-radius: calc(${controlCornerRadius} * 1px);
    }

    :host([shape='circle']) {
      border-radius: 100%;
      overflow: hidden;
    }

    object {
      position: absolute;
      width: 100%;
      height: auto;
      z-index: 2;
    }

    object img {
      width: 100%;
      height: auto;
    }

    ${display("block")} span.shimmer {
      position: absolute;
      width: 100%;
      height: 100%;
      background-image: var(
        --skeleton-animation-gradient,
        var(--skeleton-animation-gradient-default)
      );
      background-size: 0px 0px / 90% 100%;
      background-repeat: no-repeat;
      background-color: var(--skeleton-animation-fill, ${neutralFillRest});
      animation: shimmer 2s infinite;
      animation-timing-function: var(
        --skeleton-animation-timing,
        var(--skeleton-timing-default)
      );
      animation-direction: normal;
      z-index: 1;
    }

    ::slotted(svg) {
      z-index: 2;
    }

    ::slotted(.pattern) {
      width: 100%;
      height: 100%;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }
      100% {
        transform: translateX(100%);
      }
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host {
        forced-color-adjust: none;
        background-color: ${SystemColors.ButtonFace};
        box-shadow: 0 0 0 1px ${SystemColors.ButtonText};
      }

      ${display("block")} span.shimmer {
        display: none;
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/skeleton/index.js
var jpSkeleton;
var init_skeleton3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/skeleton/index.js"() {
    init_esm2();
    init_skeleton_styles();
    jpSkeleton = Skeleton.compose({
      baseName: "skeleton",
      template: skeletonTemplate,
      styles: skeletonStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/slider/slider.styles.js
var ltr2, rtl2, sliderStyles;
var init_slider_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/slider/slider.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    ltr2 = css`
  .track-start {
    left: 0;
  }
`;
    rtl2 = css`
  .track-start {
    right: 0;
  }
`;
    sliderStyles = (context, definition) => css`
    :host([hidden]) {
      display: none;
    }

    ${display("inline-grid")} :host {
      --thumb-size: calc(${heightNumber} * 0.5 - ${designUnit});
      --thumb-translate: calc(
        var(--thumb-size) * -0.5 + var(--track-width) / 2
      );
      --track-overhang: calc((${designUnit} / 2) * -1);
      --track-width: ${designUnit};
      --jp-slider-height: calc(var(--thumb-size) * 10);
      align-items: center;
      width: 100%;
      margin: calc(${designUnit} * 1px) 0;
      user-select: none;
      box-sizing: border-box;
      border-radius: calc(${controlCornerRadius} * 1px);
      outline: none;
      cursor: pointer;
    }
    :host([orientation='horizontal']) .positioning-region {
      position: relative;
      margin: 0 8px;
      display: grid;
      grid-template-rows: calc(var(--thumb-size) * 1px) 1fr;
    }
    :host([orientation='vertical']) .positioning-region {
      position: relative;
      margin: 0 8px;
      display: grid;
      height: 100%;
      grid-template-columns: calc(var(--thumb-size) * 1px) 1fr;
    }

    :host(:${focusVisible}) .thumb-cursor {
      box-shadow:
        0 0 0 2px ${fillColor},
        0 0 0 calc((2 + ${focusStrokeWidth}) * 1px) ${accentFillFocus};
    }

    :host([aria-invalid='true']:${focusVisible}) .thumb-cursor {
      box-shadow:
        0 0 0 2px ${fillColor},
        0 0 0 calc((2 + ${focusStrokeWidth}) * 1px) ${errorFillFocus};
    }

    .thumb-container {
      position: absolute;
      height: calc(var(--thumb-size) * 1px);
      width: calc(var(--thumb-size) * 1px);
      transition: all 0.2s ease;
      color: ${neutralForegroundRest};
      fill: currentcolor;
    }
    .thumb-cursor {
      border: none;
      width: calc(var(--thumb-size) * 1px);
      height: calc(var(--thumb-size) * 1px);
      background: ${neutralForegroundRest};
      border-radius: calc(${controlCornerRadius} * 1px);
    }
    .thumb-cursor:hover {
      background: ${neutralForegroundRest};
      border-color: ${neutralStrokeHover};
    }
    .thumb-cursor:active {
      background: ${neutralForegroundRest};
    }
    .track-start {
      background: ${accentForegroundRest};
      position: absolute;
      height: 100%;
      left: 0;
      border-radius: calc(${controlCornerRadius} * 1px);
    }
    :host([aria-invalid='true']) .track-start {
      background-color: ${errorFillRest};
    }
    :host([orientation='horizontal']) .thumb-container {
      transform: translateX(calc(var(--thumb-size) * 0.5px))
        translateY(calc(var(--thumb-translate) * 1px));
    }
    :host([orientation='vertical']) .thumb-container {
      transform: translateX(calc(var(--thumb-translate) * 1px))
        translateY(calc(var(--thumb-size) * 0.5px));
    }
    :host([orientation='horizontal']) {
      min-width: calc(var(--thumb-size) * 1px);
    }
    :host([orientation='horizontal']) .track {
      right: calc(var(--track-overhang) * 1px);
      left: calc(var(--track-overhang) * 1px);
      align-self: start;
      height: calc(var(--track-width) * 1px);
    }
    :host([orientation='vertical']) .track {
      top: calc(var(--track-overhang) * 1px);
      bottom: calc(var(--track-overhang) * 1px);
      width: calc(var(--track-width) * 1px);
      height: 100%;
    }
    .track {
      background: ${neutralStrokeRest};
      position: absolute;
      border-radius: calc(${controlCornerRadius} * 1px);
    }
    :host([orientation='vertical']) {
      height: calc(var(--fast-slider-height) * 1px);
      min-height: calc(var(--thumb-size) * 1px);
      min-width: calc(${designUnit} * 20px);
    }
    :host([orientation='vertical']) .track-start {
      height: auto;
      width: 100%;
      top: 0;
    }
    :host([disabled]),
    :host([readonly]) {
      cursor: ${disabledCursor};
    }
    :host([disabled]) {
      opacity: ${disabledOpacity};
    }
  `.withBehaviors(new DirectionalStyleSheetBehavior(ltr2, rtl2), forcedColorsStylesheetBehavior(css`
      .thumb-cursor {
        forced-color-adjust: none;
        border-color: ${SystemColors.FieldText};
        background: ${SystemColors.FieldText};
      }
      .thumb-cursor:hover,
      .thumb-cursor:active {
        background: ${SystemColors.Highlight};
      }
      .track {
        forced-color-adjust: none;
        background: ${SystemColors.FieldText};
      }
      :host(:${focusVisible}) .thumb-cursor {
        border-color: ${SystemColors.Highlight};
      }
      :host([disabled]) {
        opacity: 1;
      }
      :host([disabled]) .track,
      :host([disabled]) .thumb-cursor {
        forced-color-adjust: none;
        background: ${SystemColors.GrayText};
      }

      :host(:${focusVisible}) .thumb-cursor {
        background: ${SystemColors.Highlight};
        border-color: ${SystemColors.Highlight};
        box-shadow:
          0 0 0 2px ${SystemColors.Field},
          0 0 0 4px ${SystemColors.FieldText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/slider/index.js
var Slider2, jpSlider;
var init_slider3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/slider/index.js"() {
    init_esm2();
    init_slider_styles();
    Slider2 = class extends Slider {
    };
    jpSlider = Slider2.compose({
      baseName: "slider",
      baseClass: Slider,
      template: sliderTemplate,
      styles: sliderStyles,
      thumb: (
        /* html */
        `
        <div class="thumb-cursor"></div>
    `
      )
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/slider-label/slider-label.styles.js
var horizontalSliderLabelStyles, verticalSliderLabelStyles, sliderLabelStyles;
var init_slider_label_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/slider-label/slider-label.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    horizontalSliderLabelStyles = css`
  :host {
    align-self: start;
    grid-row: 2;
    margin-top: -2px;
    height: calc((${heightNumber} / 2 + ${designUnit}) * 1px);
    width: auto;
  }
  .container {
    grid-template-rows: auto auto;
    grid-template-columns: 0;
  }
  .label {
    margin: 2px 0;
  }
`;
    verticalSliderLabelStyles = css`
  :host {
    justify-self: start;
    grid-column: 2;
    margin-left: 2px;
    height: auto;
    width: calc((${heightNumber} / 2 + ${designUnit}) * 1px);
  }
  .container {
    grid-template-columns: auto auto;
    grid-template-rows: 0;
    min-width: calc(var(--thumb-size) * 1px);
    height: calc(var(--thumb-size) * 1px);
  }
  .mark {
    transform: rotate(90deg);
    align-self: center;
  }
  .label {
    margin-left: calc((${designUnit} / 2) * 3px);
    align-self: center;
  }
`;
    sliderLabelStyles = (context, definition) => css`
    ${display("block")} :host {
      font-family: ${bodyFont};
      color: ${neutralForegroundRest};
      fill: currentcolor;
    }
    .root {
      position: absolute;
      display: grid;
    }
    .container {
      display: grid;
      justify-self: center;
    }
    .label {
      justify-self: center;
      align-self: center;
      white-space: nowrap;
      max-width: 30px;
    }
    .mark {
      width: calc((${designUnit} / 4) * 1px);
      height: calc(${heightNumber} * 0.25 * 1px);
      background: ${neutralStrokeRest};
      justify-self: center;
    }
    :host(.disabled) {
      opacity: ${disabledOpacity};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      .mark {
        forced-color-adjust: none;
        background: ${SystemColors.FieldText};
      }
      :host(.disabled) {
        forced-color-adjust: none;
        opacity: 1;
      }
      :host(.disabled) .label {
        color: ${SystemColors.GrayText};
      }
      :host(.disabled) .mark {
        background: ${SystemColors.GrayText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/slider-label/index.js
var SliderLabel2, jpSliderLabel;
var init_slider_label3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/slider-label/index.js"() {
    init_esm2();
    init_dist4();
    init_slider_label_styles();
    SliderLabel2 = class extends SliderLabel {
      sliderOrientationChanged() {
        if (this.sliderOrientation === Orientation.horizontal) {
          this.$fastController.addStyles(horizontalSliderLabelStyles);
          this.$fastController.removeStyles(verticalSliderLabelStyles);
        } else {
          this.$fastController.addStyles(verticalSliderLabelStyles);
          this.$fastController.removeStyles(horizontalSliderLabelStyles);
        }
      }
    };
    jpSliderLabel = SliderLabel2.compose({
      baseName: "slider-label",
      baseClass: SliderLabel,
      template: sliderLabelTemplate,
      styles: sliderLabelStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/switch/switch.styles.js
var switchStyles;
var init_switch_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/switch/switch.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    switchStyles = (context, definition) => css`
    :host([hidden]) {
      display: none;
    }

    ${display("inline-flex")} :host {
      align-items: center;
      outline: none;
      font-family: ${bodyFont};
      margin: calc(${designUnit} * 1px) 0;
      ${/*
     * Chromium likes to select label text or the default slot when
     * the checkbox is clicked. Maybe there is a better solution here?
     */
    ""} user-select: none;
    }

    :host([disabled]) {
      opacity: ${disabledOpacity};
    }

    :host([disabled]) .label,
    :host([readonly]) .label,
    :host([readonly]) .switch,
    :host([disabled]) .switch {
      cursor: ${disabledCursor};
    }

    .switch {
      position: relative;
      outline: none;
      box-sizing: border-box;
      width: calc(${heightNumber} * 1px);
      height: calc((${heightNumber} / 2 + ${designUnit}) * 1px);
      background: ${neutralFillInputRest};
      border-radius: calc(${controlCornerRadius} * 1px);
      border: calc(${strokeWidth} * 1px) solid ${neutralStrokeRest};
    }

    :host([aria-invalid='true']) .switch {
      border-color: ${errorFillRest};
    }

    .switch:hover {
      background: ${neutralFillInputHover};
      border-color: ${neutralStrokeHover};
      cursor: pointer;
    }

    :host([disabled]) .switch:hover,
    :host([readonly]) .switch:hover {
      background: ${neutralFillInputHover};
      border-color: ${neutralStrokeHover};
      cursor: ${disabledCursor};
    }

    :host([aria-invalid='true'][disabled]) .switch:hover,
    :host([aria-invalid='true'][readonly]) .switch:hover {
      border-color: ${errorFillHover};
    }

    :host(:not([disabled])) .switch:active {
      background: ${neutralFillInputActive};
      border-color: ${neutralStrokeActive};
    }

    :host([aria-invalid='true']:not([disabled])) .switch:active {
      border-color: ${errorFillActive};
    }

    :host(:${focusVisible}) .switch {
      outline-offset: 2px;
      outline: solid calc(${focusStrokeWidth} * 1px) ${accentFillFocus};
    }

    :host([aria-invalid='true']:${focusVisible}) .switch {
      outline-color: ${errorFillFocus};
    }

    .checked-indicator {
      position: absolute;
      top: 5px;
      bottom: 5px;
      background: ${neutralForegroundRest};
      border-radius: calc(${controlCornerRadius} * 1px);
      transition: all 0.2s ease-in-out;
    }

    .status-message {
      color: ${neutralForegroundRest};
      cursor: pointer;
      font-size: ${typeRampBaseFontSize};
      line-height: ${typeRampBaseLineHeight};
    }

    :host([disabled]) .status-message,
    :host([readonly]) .status-message {
      cursor: ${disabledCursor};
    }

    .label {
      color: ${neutralForegroundRest};
      margin-inline-end: calc(${designUnit} * 2px + 2px);
      font-size: ${typeRampBaseFontSize};
      line-height: ${typeRampBaseLineHeight};
      cursor: pointer;
    }

    .label__hidden {
      display: none;
      visibility: hidden;
    }

    ::slotted([slot='checked-message']),
    ::slotted([slot='unchecked-message']) {
      margin-inline-start: calc(${designUnit} * 2px + 2px);
    }

    :host([aria-checked='true']) .checked-indicator {
      background: ${foregroundOnAccentRest};
    }

    :host([aria-checked='true']) .switch {
      background: ${accentFillRest};
      border-color: ${accentFillRest};
    }

    :host([aria-checked='true']:not([disabled])) .switch:hover {
      background: ${accentFillHover};
      border-color: ${accentFillHover};
    }

    :host([aria-invalid='true'][aria-checked='true']) .switch {
      background-color: ${errorFillRest};
      border-color: ${errorFillRest};
    }

    :host([aria-invalid='true'][aria-checked='true']:not([disabled]))
      .switch:hover {
      background-color: ${errorFillHover};
      border-color: ${errorFillHover};
    }

    :host([aria-checked='true']:not([disabled]))
      .switch:hover
      .checked-indicator {
      background: ${foregroundOnAccentHover};
    }

    :host([aria-checked='true']:not([disabled])) .switch:active {
      background: ${accentFillActive};
      border-color: ${accentFillActive};
    }

    :host([aria-invalid='true'][aria-checked='true']:not([disabled]))
      .switch:active {
      background-color: ${errorFillActive};
      border-color: ${errorFillActive};
    }

    :host([aria-checked='true']:not([disabled]))
      .switch:active
      .checked-indicator {
      background: ${foregroundOnAccentActive};
    }

    :host([aria-checked="true"]:${focusVisible}:not([disabled])) .switch {
      outline: solid calc(${focusStrokeWidth} * 1px) ${accentFillFocus};
    }

    :host([aria-invalid='true'][aria-checked="true"]:${focusVisible}:not([disabled])) .switch {
      outline-color: ${errorFillFocus};
    }

    .unchecked-message {
      display: block;
    }

    .checked-message {
      display: none;
    }

    :host([aria-checked='true']) .unchecked-message {
      display: none;
    }

    :host([aria-checked='true']) .checked-message {
      display: block;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      .checked-indicator,
      :host(:not([disabled])) .switch:active .checked-indicator {
        forced-color-adjust: none;
        background: ${SystemColors.FieldText};
      }
      .switch {
        forced-color-adjust: none;
        background: ${SystemColors.Field};
        border-color: ${SystemColors.FieldText};
      }
      :host([aria-invalid='true']) .switch {
        border-style: dashed;
      }
      :host(:not([disabled])) .switch:hover {
        background: ${SystemColors.HighlightText};
        border-color: ${SystemColors.Highlight};
      }
      :host([aria-checked='true']) .switch {
        background: ${SystemColors.Highlight};
        border-color: ${SystemColors.Highlight};
      }
      :host([aria-checked='true']:not([disabled])) .switch:hover,
      :host(:not([disabled])) .switch:active {
        background: ${SystemColors.HighlightText};
        border-color: ${SystemColors.Highlight};
      }
      :host([aria-checked='true']) .checked-indicator {
        background: ${SystemColors.HighlightText};
      }
      :host([aria-checked='true']:not([disabled]))
        .switch:hover
        .checked-indicator {
        background: ${SystemColors.Highlight};
      }
      :host([disabled]) {
        opacity: 1;
      }
      :host(:${focusVisible}) .switch {
        border-color: ${SystemColors.Highlight};
        outline-offset: 2px;
        outline: solid calc(${focusStrokeWidth} * 1px) ${SystemColors.FieldText};
      }
      :host([aria-checked="true"]:${focusVisible}:not([disabled])) .switch {
        outline: solid calc(${focusStrokeWidth} * 1px) ${SystemColors.FieldText};
      }
      :host([disabled]) .checked-indicator {
        background: ${SystemColors.GrayText};
      }
      :host([disabled]) .switch {
        background: ${SystemColors.Field};
        border-color: ${SystemColors.GrayText};
      }
    `), new DirectionalStyleSheetBehavior(css`
        .checked-indicator {
          left: 5px;
          right: calc(((${heightNumber} / 2) + 1) * 1px);
        }

        :host([aria-checked='true']) .checked-indicator {
          left: calc(((${heightNumber} / 2) + 1) * 1px);
          right: 5px;
        }
      `, css`
        .checked-indicator {
          right: 5px;
          left: calc(((${heightNumber} / 2) + 1) * 1px);
        }

        :host([aria-checked='true']) .checked-indicator {
          right: calc(((${heightNumber} / 2) + 1) * 1px);
          left: 5px;
        }
      `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/switch/index.js
var Switch2, jpSwitch;
var init_switch3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/switch/index.js"() {
    init_esm2();
    init_switch_styles();
    Switch2 = class extends Switch {
    };
    jpSwitch = Switch2.compose({
      baseName: "switch",
      baseClass: Switch,
      template: switchTemplate,
      styles: switchStyles,
      switch: (
        /* html */
        `
        <span class="checked-indicator" part="checked-indicator"></span>
    `
      )
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/tab-panel/tab-panel.styles.js
var tabPanelStyles;
var init_tab_panel_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/tab-panel/tab-panel.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    tabPanelStyles = (context, definition) => css`
  ${display("block")} :host {
    box-sizing: border-box;
    font-size: ${typeRampBaseFontSize};
    line-height: ${typeRampBaseLineHeight};
    padding: 0 calc((6 + (${designUnit} * 2 * ${density})) * 1px);
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/tab-panel/index.js
var jpTabPanel;
var init_tab_panel3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/tab-panel/index.js"() {
    init_esm2();
    init_tab_panel_styles();
    jpTabPanel = TabPanel2.compose({
      baseName: "tab-panel",
      template: tabPanelTemplate,
      styles: tabPanelStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/tab/tab.styles.js
var tabStyles;
var init_tab_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/tab/tab.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_size();
    tabStyles = (context, definition) => css`
    ${display("inline-flex")} :host {
      box-sizing: border-box;
      font-family: ${bodyFont};
      font-size: ${typeRampBaseFontSize};
      line-height: ${typeRampBaseLineHeight};
      height: calc(${heightNumber} * 1px);
      padding: calc(${designUnit} * 5px) calc(${designUnit} * 4px);
      color: ${neutralForegroundHint2};
      fill: currentcolor;
      border-radius: 0 0 calc(${controlCornerRadius} * 1px)
        calc(${controlCornerRadius} * 1px);
      border: calc(${strokeWidth} * 1px) solid transparent;
      align-items: center;
      justify-content: center;
      grid-row: 2;
      cursor: pointer;
    }

    :host(:hover) {
      color: ${neutralForegroundRest};
      fill: currentcolor;
    }

    :host(:active) {
      color: ${neutralForegroundRest};
      fill: currentcolor;
    }

    :host([disabled]) {
      cursor: ${disabledCursor};
      opacity: ${disabledOpacity};
    }

    :host([disabled]:hover) {
      color: ${neutralForegroundHint2};
      background: ${neutralFillStealthRest};
    }

    :host([aria-selected='true']) {
      background: ${neutralFillRest};
      color: ${neutralForegroundRest};
      fill: currentcolor;
    }

    :host([aria-selected='true']:hover) {
      background: ${neutralFillHover};
      color: ${neutralForegroundRest};
      fill: currentcolor;
    }

    :host([aria-selected='true']:active) {
      background: ${neutralFillActive};
      color: ${neutralForegroundRest};
      fill: currentcolor;
    }

    :host(:${focusVisible}) {
      outline: none;
      border-color: ${accentFillFocus};
      box-shadow: 0 0 0 calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
        ${accentFillFocus};
    }

    :host(:focus) {
      outline: none;
    }

    :host(.vertical) {
      justify-content: end;
      grid-column: 2;
      border-bottom-left-radius: 0;
      border-top-right-radius: calc(${controlCornerRadius} * 1px);
    }

    :host(.vertical[aria-selected='true']) {
      z-index: 2;
    }

    :host(.vertical:hover) {
      color: ${neutralForegroundRest};
    }

    :host(.vertical:active) {
      color: ${neutralForegroundRest};
    }

    :host(.vertical:hover[aria-selected='true']) {
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host {
        forced-color-adjust: none;
        border-color: transparent;
        color: ${SystemColors.ButtonText};
        fill: currentcolor;
      }
      :host(:hover),
      :host(.vertical:hover),
      :host([aria-selected='true']:hover) {
        background: ${SystemColors.Highlight};
        color: ${SystemColors.HighlightText};
        fill: currentcolor;
      }
      :host([aria-selected='true']) {
        background: ${SystemColors.HighlightText};
        color: ${SystemColors.Highlight};
        fill: currentcolor;
      }
      :host(:${focusVisible}) {
        border-color: ${SystemColors.ButtonText};
        box-shadow: none;
      }
      :host([disabled]),
      :host([disabled]:hover) {
        opacity: 1;
        color: ${SystemColors.GrayText};
        background: ${SystemColors.ButtonFace};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/tab/index.js
var jpTab;
var init_tab4 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/tab/index.js"() {
    init_esm2();
    init_tab_styles();
    jpTab = Tab.compose({
      baseName: "tab",
      template: tabTemplate,
      styles: tabStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/tabs/tabs.styles.js
var tabsStyles;
var init_tabs_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/tabs/tabs.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    tabsStyles = (context, definition) => css`
    ${display("grid")} :host {
      box-sizing: border-box;
      font-family: ${bodyFont};
      font-size: ${typeRampBaseFontSize};
      line-height: ${typeRampBaseLineHeight};
      color: ${neutralForegroundRest};
      grid-template-columns: auto 1fr auto;
      grid-template-rows: auto 1fr;
    }

    .tablist {
      display: grid;
      grid-template-rows: auto auto;
      grid-template-columns: auto;
      position: relative;
      width: max-content;
      align-self: end;
      padding: calc(${designUnit} * 4px) calc(${designUnit} * 4px) 0;
      box-sizing: border-box;
    }

    .start,
    .end {
      align-self: center;
    }

    .activeIndicator {
      grid-row: 1;
      grid-column: 1;
      width: 100%;
      height: 4px;
      justify-self: center;
      background: ${accentFillRest};
      margin-top: 0;
      border-radius: calc(${controlCornerRadius} * 1px)
        calc(${controlCornerRadius} * 1px) 0 0;
    }

    .activeIndicatorTransition {
      transition: transform 0.01s ease-in-out;
    }

    .tabpanel {
      grid-row: 2;
      grid-column-start: 1;
      grid-column-end: 4;
      position: relative;
    }

    :host([orientation='vertical']) {
      grid-template-rows: auto 1fr auto;
      grid-template-columns: auto 1fr;
    }

    :host([orientation='vertical']) .tablist {
      grid-row-start: 2;
      grid-row-end: 2;
      display: grid;
      grid-template-rows: auto;
      grid-template-columns: auto 1fr;
      position: relative;
      width: max-content;
      justify-self: end;
      align-self: flex-start;
      width: 100%;
      padding: 0 calc(${designUnit} * 4px)
        calc((${heightNumber} - ${designUnit}) * 1px) 0;
    }

    :host([orientation='vertical']) .tabpanel {
      grid-column: 2;
      grid-row-start: 1;
      grid-row-end: 4;
    }

    :host([orientation='vertical']) .end {
      grid-row: 3;
    }

    :host([orientation='vertical']) .activeIndicator {
      grid-column: 1;
      grid-row: 1;
      width: 4px;
      height: 100%;
      margin-inline-end: 0px;
      align-self: center;
      background: ${accentFillRest};
      border-radius: calc(${controlCornerRadius} * 1px) 0 0
        calc(${controlCornerRadius} * 1px);
    }

    :host([orientation='vertical']) .activeIndicatorTransition {
      transition: transform 0.01s ease-in-out;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      .activeIndicator,
      :host([orientation='vertical']) .activeIndicator {
        forced-color-adjust: none;
        background: ${SystemColors.Highlight};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/tabs/index.js
var jpTabs;
var init_tabs3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/tabs/index.js"() {
    init_esm2();
    init_tabs_styles();
    init_tab4();
    init_tab_panel3();
    jpTabs = Tabs.compose({
      baseName: "tabs",
      template: tabsTemplate,
      styles: tabsStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/text-area/text-area.styles.js
var textAreaStyles;
var init_text_area_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/text-area/text-area.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    init_styles();
    textAreaStyles = (context, definition) => css`
    ${display("inline-block")} :host {
      font-family: ${bodyFont};
      outline: none;
      user-select: none;
    }

    .control {
      box-sizing: border-box;
      position: relative;
      color: ${neutralForegroundRest};
      background: ${neutralFillInputRest};
      border-radius: calc(${controlCornerRadius} * 1px);
      border: calc(${strokeWidth} * 1px) solid ${neutralFillStrongRest};
      height: calc(${heightNumber} * 2px);
      font: inherit;
      font-size: ${typeRampBaseFontSize};
      line-height: ${typeRampBaseLineHeight};
      padding: calc(${designUnit} * 2px + 1px);
      width: 100%;
      resize: none;
    }

    :host([aria-invalid='true']) .control {
      border-color: ${errorFillRest};
    }

    .control:hover:enabled {
      background: ${neutralFillInputHover};
      border-color: ${neutralFillStrongHover};
    }

    :host([aria-invalid='true']) .control:hover:enabled {
      border-color: ${errorFillHover};
    }

    .control:active:enabled {
      background: ${neutralFillInputActive};
      border-color: ${neutralFillStrongActive};
    }

    :host([aria-invalid='true']) .control:active:enabled {
      border-color: ${errorFillActive};
    }

    .control:hover,
    .control:${focusVisible},
    .control:disabled,
    .control:active {
      outline: none;
    }

    :host(:focus-within) .control {
      border-color: ${accentFillFocus};
      box-shadow: 0 0 0 calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
        ${accentFillFocus};
    }

    :host([aria-invalid='true']:focus-within) .control {
      border-color: ${errorFillFocus};
      box-shadow: 0 0 0 calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
        ${errorFillFocus};
    }

    :host([appearance='filled']) .control {
      background: ${neutralFillRest};
    }

    :host([appearance='filled']:hover:not([disabled])) .control {
      background: ${neutralFillHover};
    }

    :host([resize='both']) .control {
      resize: both;
    }

    :host([resize='horizontal']) .control {
      resize: horizontal;
    }

    :host([resize='vertical']) .control {
      resize: vertical;
    }

    .label {
      display: block;
      color: ${neutralForegroundRest};
      cursor: pointer;
      font-size: ${typeRampBaseFontSize};
      line-height: ${typeRampBaseLineHeight};
      margin-bottom: 4px;
    }

    .label__hidden {
      display: none;
      visibility: hidden;
    }

    :host([disabled]) .label,
    :host([readonly]) .label,
    :host([readonly]) .control,
    :host([disabled]) .control {
      cursor: ${disabledCursor};
    }
    :host([disabled]) {
      opacity: ${disabledOpacity};
    }
    :host([disabled]) .control {
      border-color: ${neutralStrokeRest};
    }

    :host([cols]) {
      width: initial;
    }

    :host([rows]) .control {
      height: initial;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host([disabled]) {
        opacity: 1;
      }

      :host([aria-invalid='true']) .control {
        border-style: dashed;
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/text-area/index.js
var TextArea2, jpTextArea;
var init_text_area3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/text-area/index.js"() {
    init_tslib_es62();
    init_esm();
    init_esm2();
    init_text_area_styles();
    TextArea2 = class extends TextArea {
      constructor() {
        super(...arguments);
        this.appearance = "outline";
      }
    };
    __decorate2([
      attr
    ], TextArea2.prototype, "appearance", void 0);
    jpTextArea = TextArea2.compose({
      baseName: "text-area",
      baseClass: TextArea,
      template: textAreaTemplate,
      styles: textAreaStyles,
      shadowOptions: {
        delegatesFocus: true
      }
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/text-field/text-field.styles.js
var textFieldStyles;
var init_text_field_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/text-field/text-field.styles.js"() {
    init_esm();
    init_styles();
    textFieldStyles = (context, definition) => css`
  ${BaseFieldStyles}

  .start,
    .end {
    display: flex;
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/text-field/index.js
var TextField2, jpTextField;
var init_text_field3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/text-field/index.js"() {
    init_tslib_es62();
    init_esm();
    init_esm2();
    init_text_field_styles();
    TextField2 = class extends TextField {
      constructor() {
        super(...arguments);
        this.appearance = "outline";
      }
    };
    __decorate2([
      attr
    ], TextField2.prototype, "appearance", void 0);
    jpTextField = TextField2.compose({
      baseName: "text-field",
      baseClass: TextField,
      template: textFieldTemplate,
      styles: textFieldStyles,
      shadowOptions: {
        delegatesFocus: true
      }
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/toolbar/toolbar.styles.js
var toolbarStyles;
var init_toolbar_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/toolbar/toolbar.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    toolbarStyles = (context, definition) => css`
    ${display("inline-flex")} :host {
      --toolbar-item-gap: calc(
        (var(--design-unit) + calc(var(--density) + 2)) * 1px
      );
      background-color: ${fillColor};
      border-radius: calc(${controlCornerRadius} * 1px);
      fill: currentcolor;
      padding: var(--toolbar-item-gap);
    }

    :host(${focusVisible}) {
      outline: calc(${strokeWidth} * 1px) solid ${accentFillFocus};
    }

    .positioning-region {
      align-items: flex-start;
      display: inline-flex;
      flex-flow: row wrap;
      justify-content: flex-start;
      width: 100%;
      height: 100%;
    }

    :host([orientation='vertical']) .positioning-region {
      flex-direction: column;
    }

    ::slotted(:not([slot])) {
      flex: 0 0 auto;
      margin: 0 var(--toolbar-item-gap);
    }

    :host([orientation='vertical']) ::slotted(:not([slot])) {
      margin: var(--toolbar-item-gap) 0;
    }

    .start,
    .end {
      display: flex;
      margin: auto;
      margin-inline: 0;
    }

    ::slotted(svg) {
      /* TODO: adaptive typography https://github.com/microsoft/fast/issues/2432 */
      width: 16px;
      height: 16px;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host(:${focusVisible}) {
        box-shadow: 0 0 0 calc(${focusStrokeWidth} * 1px)
          ${SystemColors.Highlight};
        color: ${SystemColors.ButtonText};
        forced-color-adjust: none;
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/toolbar/index.js
var ToolbarArrowKeyMap2, FoundationToolbar, DelegatesARIAToolbar2, Toolbar2, jpToolbar;
var init_toolbar3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/toolbar/index.js"() {
    init_tslib_es62();
    init_esm();
    init_esm2();
    init_dist4();
    init_index_esm();
    init_design_tokens();
    init_toolbar_styles();
    ToolbarArrowKeyMap2 = Object.freeze({
      [ArrowKeys.ArrowUp]: {
        [Orientation.vertical]: -1
      },
      [ArrowKeys.ArrowDown]: {
        [Orientation.vertical]: 1
      },
      [ArrowKeys.ArrowLeft]: {
        [Orientation.horizontal]: {
          [Direction.ltr]: -1,
          [Direction.rtl]: 1
        }
      },
      [ArrowKeys.ArrowRight]: {
        [Orientation.horizontal]: {
          [Direction.ltr]: 1,
          [Direction.rtl]: -1
        }
      }
    });
    FoundationToolbar = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this._activeIndex = 0;
        this.direction = Direction.ltr;
        this.orientation = Orientation.horizontal;
      }
      /**
       * The index of the currently focused element, clamped between 0 and the last element.
       *
       * @internal
       */
      get activeIndex() {
        Observable.track(this, "activeIndex");
        return this._activeIndex;
      }
      set activeIndex(value) {
        if (this.$fastController.isConnected) {
          this._activeIndex = limit(0, this.focusableElements.length - 1, value);
          Observable.notify(this, "activeIndex");
        }
      }
      slottedItemsChanged() {
        if (this.$fastController.isConnected) {
          this.reduceFocusableElements();
        }
      }
      /**
       * Set the activeIndex when a focusable element in the toolbar is clicked.
       *
       * @internal
       */
      mouseDownHandler(e) {
        var _a;
        const activeIndex = (_a = this.focusableElements) === null || _a === void 0 ? void 0 : _a.findIndex((x) => x.contains(e.target));
        if (activeIndex > -1 && this.activeIndex !== activeIndex) {
          this.setFocusedElement(activeIndex);
        }
        return true;
      }
      childItemsChanged(prev, next) {
        if (this.$fastController.isConnected) {
          this.reduceFocusableElements();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.direction = getDirection(this);
      }
      /**
       * When the toolbar receives focus, set the currently active element as focused.
       *
       * @internal
       */
      focusinHandler(e) {
        const relatedTarget = e.relatedTarget;
        if (!relatedTarget || this.contains(relatedTarget)) {
          return;
        }
        this.setFocusedElement();
      }
      /**
       * Determines a value that can be used to iterate a list with the arrow keys.
       *
       * @param this - An element with an orientation and direction
       * @param key - The event key value
       * @internal
       */
      getDirectionalIncrementer(key2) {
        var _a, _b, _c, _d, _e;
        return (
          // @ts-expect-error ToolbarArrowKeyMap has not index
          (_e = (_c = (_b = (_a = ToolbarArrowKeyMap2[key2]) === null || _a === void 0 ? void 0 : _a[this.orientation]) === null || _b === void 0 ? void 0 : _b[this.direction]) !== null && _c !== void 0 ? _c : (
            // @ts-expect-error ToolbarArrowKeyMap has not index
            (_d = ToolbarArrowKeyMap2[key2]) === null || _d === void 0 ? void 0 : _d[this.orientation]
          )) !== null && _e !== void 0 ? _e : 0
        );
      }
      /**
       * Handle keyboard events for the toolbar.
       *
       * @internal
       */
      keydownHandler(e) {
        const key2 = e.key;
        if (!(key2 in ArrowKeys) || e.defaultPrevented || e.shiftKey) {
          return true;
        }
        const incrementer = this.getDirectionalIncrementer(key2);
        if (!incrementer) {
          return !e.target.closest("[role=radiogroup]");
        }
        const nextIndex = this.activeIndex + incrementer;
        if (this.focusableElements[nextIndex]) {
          e.preventDefault();
        }
        this.setFocusedElement(nextIndex);
        return true;
      }
      /**
       * get all the slotted elements
       * @internal
       */
      get allSlottedItems() {
        return [
          ...this.start.assignedElements(),
          ...this.slottedItems,
          ...this.end.assignedElements()
        ];
      }
      /**
       * Prepare the slotted elements which can be focusable.
       *
       * @internal
       */
      reduceFocusableElements() {
        var _a;
        const previousFocusedElement = (_a = this.focusableElements) === null || _a === void 0 ? void 0 : _a[this.activeIndex];
        this.focusableElements = this.allSlottedItems.reduce(Toolbar2.reduceFocusableItems, []);
        const adjustedActiveIndex = this.focusableElements.indexOf(previousFocusedElement);
        this.activeIndex = Math.max(0, adjustedActiveIndex);
        this.setFocusableElements();
      }
      /**
       * Set the activeIndex and focus the corresponding control.
       *
       * @param activeIndex - The new index to set
       * @internal
       */
      setFocusedElement(activeIndex = this.activeIndex) {
        this.activeIndex = activeIndex;
        this.setFocusableElements();
        if (this.focusableElements[this.activeIndex] && // Don't focus the toolbar element if some event handlers moved
        // the focus on another element in the page.
        this.contains(document.activeElement)) {
          this.focusableElements[this.activeIndex].focus();
        }
      }
      /**
       * Reduce a collection to only its focusable elements.
       *
       * @param elements - Collection of elements to reduce
       * @param element - The current element
       *
       * @internal
       */
      static reduceFocusableItems(elements2, element) {
        var _a, _b, _c, _d;
        const isRoleRadio = element.getAttribute("role") === "radio";
        const isFocusableFastElement = (_b = (_a = element.$fastController) === null || _a === void 0 ? void 0 : _a.definition.shadowOptions) === null || _b === void 0 ? void 0 : _b.delegatesFocus;
        const hasFocusableShadow = Array.from((_d = (_c = element.shadowRoot) === null || _c === void 0 ? void 0 : _c.querySelectorAll("*")) !== null && _d !== void 0 ? _d : []).some((x) => isFocusable(x));
        if (!element.hasAttribute("disabled") && !element.hasAttribute("hidden") && (isFocusable(element) || isRoleRadio || isFocusableFastElement || hasFocusableShadow)) {
          elements2.push(element);
          return elements2;
        }
        if (element.childElementCount) {
          return elements2.concat(Array.from(element.children).reduce(Toolbar2.reduceFocusableItems, []));
        }
        return elements2;
      }
      /**
       * @internal
       */
      setFocusableElements() {
        if (this.$fastController.isConnected && this.focusableElements.length > 0) {
          this.focusableElements.forEach((element, index) => {
            element.tabIndex = this.activeIndex === index ? 0 : -1;
          });
        }
      }
    };
    __decorate2([
      observable
    ], FoundationToolbar.prototype, "direction", void 0);
    __decorate2([
      attr
    ], FoundationToolbar.prototype, "orientation", void 0);
    __decorate2([
      observable
    ], FoundationToolbar.prototype, "slottedItems", void 0);
    __decorate2([
      observable
    ], FoundationToolbar.prototype, "slottedLabel", void 0);
    __decorate2([
      observable
    ], FoundationToolbar.prototype, "childItems", void 0);
    DelegatesARIAToolbar2 = class {
    };
    __decorate2([
      attr({ attribute: "aria-labelledby" })
    ], DelegatesARIAToolbar2.prototype, "ariaLabelledby", void 0);
    __decorate2([
      attr({ attribute: "aria-label" })
    ], DelegatesARIAToolbar2.prototype, "ariaLabel", void 0);
    applyMixins(DelegatesARIAToolbar2, ARIAGlobalStatesAndProperties);
    applyMixins(FoundationToolbar, StartEnd, DelegatesARIAToolbar2);
    Toolbar2 = class extends FoundationToolbar {
      connectedCallback() {
        super.connectedCallback();
        const parent = composedParent(this);
        if (parent) {
          fillColor.setValueFor(this, (target2) => neutralFillLayerRecipe.getValueFor(target2).evaluate(target2, fillColor.getValueFor(parent)));
        }
      }
    };
    jpToolbar = Toolbar2.compose({
      baseName: "toolbar",
      baseClass: FoundationToolbar,
      template: toolbarTemplate,
      styles: toolbarStyles,
      shadowOptions: {
        delegatesFocus: true
      }
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/tooltip/tooltip.styles.js
var tooltipStyles;
var init_tooltip_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/tooltip/tooltip.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    tooltipStyles = (context, definition) => {
      const anchoredRegionTag = context.tagFor(AnchoredRegion);
      return css`
    :host {
      contain: size;
      overflow: visible;
      height: 0;
      width: 0;
    }

    .tooltip {
      box-sizing: border-box;
      border-radius: calc(${controlCornerRadius} * 1px);
      border: calc(${strokeWidth} * 1px) solid ${focusStrokeOuter2};
      box-shadow: 0 0 0 1px ${focusStrokeOuter2} inset;
      background: ${neutralFillRest};
      color: ${neutralForegroundRest};
      padding: 4px;
      height: fit-content;
      width: fit-content;
      font-family: ${bodyFont};
      font-size: ${typeRampBaseFontSize};
      line-height: ${typeRampBaseLineHeight};
      white-space: nowrap;
      /* TODO: a mechanism to manage z-index across components
                    https://github.com/microsoft/fast/issues/3813 */
      z-index: 10000;
    }

    ${anchoredRegionTag} {
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: visible;
      flex-direction: row;
    }

    ${anchoredRegionTag}.right,
    ${anchoredRegionTag}.left {
      flex-direction: column;
    }

    ${anchoredRegionTag}.top .tooltip {
      margin-bottom: 4px;
    }

    ${anchoredRegionTag}.bottom .tooltip {
      margin-top: 4px;
    }

    ${anchoredRegionTag}.left .tooltip {
      margin-right: 4px;
    }

    ${anchoredRegionTag}.right .tooltip {
      margin-left: 4px;
    }

    ${anchoredRegionTag}.top.left .tooltip,
            ${anchoredRegionTag}.top.right .tooltip {
      margin-bottom: 0px;
    }

    ${anchoredRegionTag}.bottom.left .tooltip,
            ${anchoredRegionTag}.bottom.right .tooltip {
      margin-top: 0px;
    }

    ${anchoredRegionTag}.top.left .tooltip,
            ${anchoredRegionTag}.bottom.left .tooltip {
      margin-right: 0px;
    }

    ${anchoredRegionTag}.top.right .tooltip,
            ${anchoredRegionTag}.bottom.right .tooltip {
      margin-left: 0px;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host([disabled]) {
        opacity: 1;
      }
    `));
    };
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/tooltip/index.js
var jpTooltip;
var init_tooltip3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/tooltip/index.js"() {
    init_esm2();
    init_tooltip_styles();
    jpTooltip = Tooltip.compose({
      baseName: "tooltip",
      template: tooltipTemplate,
      styles: tooltipStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/tree-item/tree-item.styles.js
var ltr3, rtl3, expandCollapseButtonSize, expandCollapseHoverBehavior, selectedExpandCollapseHoverBehavior, treeItemStyles;
var init_tree_item_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/tree-item/tree-item.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    ltr3 = css`
  .expand-collapse-glyph {
    transform: rotate(0deg);
  }
  :host(.nested) .expand-collapse-button {
    left: var(
      --expand-collapse-button-nested-width,
      calc(${heightNumber} * -1px)
    );
  }
  :host([selected])::after {
    left: calc(${focusStrokeWidth} * 1px);
  }
  :host([expanded]) > .positioning-region .expand-collapse-glyph {
    transform: rotate(90deg);
  }
`;
    rtl3 = css`
  .expand-collapse-glyph {
    transform: rotate(180deg);
  }
  :host(.nested) .expand-collapse-button {
    right: var(
      --expand-collapse-button-nested-width,
      calc(${heightNumber} * -1px)
    );
  }
  :host([selected])::after {
    right: calc(${focusStrokeWidth} * 1px);
  }
  :host([expanded]) > .positioning-region .expand-collapse-glyph {
    transform: rotate(90deg);
  }
`;
    expandCollapseButtonSize = cssPartial`((${baseHeightMultiplier} / 2) * ${designUnit}) + ((${designUnit} * ${density}) / 2)`;
    expandCollapseHoverBehavior = DesignToken.create("tree-item-expand-collapse-hover").withDefault((target2) => {
      const recipe = neutralFillStealthRecipe.getValueFor(target2);
      return recipe.evaluate(target2, recipe.evaluate(target2).hover).hover;
    });
    selectedExpandCollapseHoverBehavior = DesignToken.create("tree-item-expand-collapse-selected-hover").withDefault((target2) => {
      const baseRecipe = neutralFillRecipe.getValueFor(target2);
      const buttonRecipe = neutralFillStealthRecipe.getValueFor(target2);
      return buttonRecipe.evaluate(target2, baseRecipe.evaluate(target2).rest).hover;
    });
    treeItemStyles = (context, definition) => css`
    /**
     * This animation exists because when tree item children are conditionally loaded
     * there is a visual bug where the DOM exists but styles have not yet been applied (essentially FOUC).
     * This subtle animation provides a ever so slight timing adjustment for loading that solves the issue.
     */
    @keyframes treeItemLoading {
      0% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }

    ${display("block")} :host {
      contain: content;
      position: relative;
      outline: none;
      color: ${neutralForegroundRest};
      background: ${neutralFillStealthRest};
      cursor: pointer;
      font-family: ${bodyFont};
      --expand-collapse-button-size: calc(${heightNumber} * 1px);
      --tree-item-nested-width: 0;
    }

    :host(:focus) > .positioning-region {
      outline: none;
    }

    :host(:focus) .content-region {
      outline: none;
    }

    :host(:${focusVisible}) .positioning-region {
      border-color: ${accentFillFocus};
      box-shadow: 0 0 0 calc((${focusStrokeWidth} - ${strokeWidth}) * 1px)
        ${accentFillFocus} inset;
      color: ${neutralForegroundRest};
    }

    .positioning-region {
      display: flex;
      position: relative;
      box-sizing: border-box;
      background: ${neutralFillStealthRest};
      border: transparent calc(${strokeWidth} * 1px) solid;
      border-radius: calc(${controlCornerRadius} * 1px);
      height: calc((${heightNumber} + 1) * 1px);
    }

    .positioning-region::before {
      content: '';
      display: block;
      width: var(--tree-item-nested-width);
      flex-shrink: 0;
    }

    :host(:not([disabled])) .positioning-region:hover {
      background: ${neutralFillStealthHover};
    }

    :host(:not([disabled])) .positioning-region:active {
      background: ${neutralFillStealthActive};
    }

    .content-region {
      display: inline-flex;
      align-items: center;
      white-space: nowrap;
      width: 100%;
      min-width: 0;
      height: calc(${heightNumber} * 1px);
      margin-inline-start: calc(${designUnit} * 2px + 8px);
      font-size: ${typeRampBaseFontSize};
      line-height: ${typeRampBaseLineHeight};
      font-weight: 400;
    }

    .items {
      /* TODO: adaptive typography https://github.com/microsoft/fast/issues/2432 */
      font-size: calc(1em + (${designUnit} + 16) * 1px);
    }

    .expand-collapse-button {
      background: none;
      border: none;
      outline: none;
      /* TODO: adaptive typography https://github.com/microsoft/fast/issues/2432 */
      width: calc((${expandCollapseButtonSize} + (${designUnit} * 2)) * 1px);
      height: calc((${expandCollapseButtonSize} + (${designUnit} * 2)) * 1px);
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      margin-left: 6px;
      margin-right: 6px;
    }

    .expand-collapse-glyph {
      /* TODO: adaptive typography https://github.com/microsoft/fast/issues/2432 */
      width: 16px;
      height: 16px;
      transition: transform 0.1s linear;

      pointer-events: none;
      fill: currentcolor;
    }

    .start,
    .end {
      display: flex;
      fill: currentcolor;
    }

    ::slotted(svg) {
      /* TODO: adaptive typography https://github.com/microsoft/fast/issues/2432 */
      width: 16px;
      height: 16px;
    }

    .start {
      /* TODO: horizontalSpacing https://github.com/microsoft/fast/issues/2766 */
      margin-inline-end: calc(${designUnit} * 2px + 2px);
    }

    .end {
      /* TODO: horizontalSpacing https://github.com/microsoft/fast/issues/2766 */
      margin-inline-start: calc(${designUnit} * 2px + 2px);
    }

    :host([expanded]) > .items {
      animation: treeItemLoading ease-in 10ms;
      animation-iteration-count: 1;
      animation-fill-mode: forwards;
    }

    :host([disabled]) .content-region {
      opacity: ${disabledOpacity};
      cursor: ${disabledCursor};
    }

    :host(.nested) .content-region {
      position: relative;
      margin-inline-start: var(--expand-collapse-button-size);
    }

    :host(.nested) .expand-collapse-button {
      position: absolute;
    }

    :host(.nested:not([disabled])) .expand-collapse-button:hover {
      background: ${expandCollapseHoverBehavior};
    }

    :host([selected]) .positioning-region {
      background: ${neutralFillRest};
    }

    :host([selected]:not([disabled])) .positioning-region:hover {
      background: ${neutralFillHover};
    }

    :host([selected]:not([disabled])) .positioning-region:active {
      background: ${neutralFillActive};
    }

    :host([selected]:not([disabled])) .expand-collapse-button:hover {
      background: ${selectedExpandCollapseHoverBehavior};
    }

    :host([selected])::after {
      /* The background needs to be calculated based on the selected background state
         for this control. We currently have no way of changing that, so setting to
         accent-foreground-rest for the time being */
      background: ${accentForegroundRest};
      border-radius: calc(${controlCornerRadius} * 1px);
      content: '';
      display: block;
      position: absolute;
      top: calc((${heightNumber} / 4) * 1px);
      width: 3px;
      height: calc((${heightNumber} / 2) * 1px);
    }

    ::slotted(${context.tagFor(TreeItem)}) {
      --tree-item-nested-width: 1em;
      --expand-collapse-button-nested-width: calc(${heightNumber} * -1px);
    }
  `.withBehaviors(new DirectionalStyleSheetBehavior(ltr3, rtl3), forcedColorsStylesheetBehavior(css`
      :host {
        forced-color-adjust: none;
        border-color: transparent;
        background: ${SystemColors.Field};
        color: ${SystemColors.FieldText};
      }
      :host .content-region .expand-collapse-glyph {
        fill: ${SystemColors.FieldText};
      }
      :host .positioning-region:hover,
      :host([selected]) .positioning-region {
        background: ${SystemColors.Highlight};
      }
      :host .positioning-region:hover .content-region,
      :host([selected]) .positioning-region .content-region {
        color: ${SystemColors.HighlightText};
      }
      :host .positioning-region:hover .content-region .expand-collapse-glyph,
      :host .positioning-region:hover .content-region .start,
      :host .positioning-region:hover .content-region .end,
      :host([selected]) .content-region .expand-collapse-glyph,
      :host([selected]) .content-region .start,
      :host([selected]) .content-region .end {
        fill: ${SystemColors.HighlightText};
      }
      :host([selected])::after {
        background: ${SystemColors.Field};
      }
      :host(:${focusVisible}) .positioning-region {
        border-color: ${SystemColors.FieldText};
        box-shadow: 0 0 0 2px inset ${SystemColors.Field};
        color: ${SystemColors.FieldText};
      }
      :host([disabled]) .content-region,
      :host([disabled]) .positioning-region:hover .content-region {
        opacity: 1;
        color: ${SystemColors.GrayText};
      }
      :host([disabled]) .content-region .expand-collapse-glyph,
      :host([disabled]) .content-region .start,
      :host([disabled]) .content-region .end,
      :host([disabled])
        .positioning-region:hover
        .content-region
        .expand-collapse-glyph,
      :host([disabled]) .positioning-region:hover .content-region .start,
      :host([disabled]) .positioning-region:hover .content-region .end {
        fill: ${SystemColors.GrayText};
      }
      :host([disabled]) .positioning-region:hover {
        background: ${SystemColors.Field};
      }
      .expand-collapse-glyph,
      .start,
      .end {
        fill: ${SystemColors.FieldText};
      }
      :host(.nested) .expand-collapse-button:hover {
        background: ${SystemColors.Field};
      }
      :host(.nested) .expand-collapse-button:hover .expand-collapse-glyph {
        fill: ${SystemColors.FieldText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/tree-item/index.js
var jpTreeItem;
var init_tree_item3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/tree-item/index.js"() {
    init_esm2();
    init_tree_item_styles();
    jpTreeItem = TreeItem.compose({
      baseName: "tree-item",
      template: treeItemTemplate,
      styles: treeItemStyles,
      expandCollapseGlyph: (
        /* html */
        `
        <svg
            viewBox="0 0 16 16"
            xmlns="http://www.w3.org/2000/svg"
            class="expand-collapse-glyph"
        >
            <path
                d="M5.00001 12.3263C5.00124 12.5147 5.05566 12.699 5.15699 12.8578C5.25831 13.0167 5.40243 13.1437 5.57273 13.2242C5.74304 13.3047 5.9326 13.3354 6.11959 13.3128C6.30659 13.2902 6.4834 13.2152 6.62967 13.0965L10.8988 8.83532C11.0739 8.69473 11.2153 8.51658 11.3124 8.31402C11.4096 8.11146 11.46 7.88966 11.46 7.66499C11.46 7.44033 11.4096 7.21853 11.3124 7.01597C11.2153 6.81341 11.0739 6.63526 10.8988 6.49467L6.62967 2.22347C6.48274 2.10422 6.30501 2.02912 6.11712 2.00691C5.92923 1.9847 5.73889 2.01628 5.56823 2.09799C5.39757 2.17969 5.25358 2.30817 5.153 2.46849C5.05241 2.62882 4.99936 2.8144 5.00001 3.00369V12.3263Z"
            />
        </svg>
    `
      )
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/tree-view/tree-view.styles.js
var treeViewStyles;
var init_tree_view_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/tree-view/tree-view.styles.js"() {
    init_esm();
    init_esm2();
    treeViewStyles = (context, definition) => css`
  ${display("flex")} :host {
    flex-direction: column;
    align-items: stretch;
    min-width: fit-content;
    font-size: 0;
  }

  :host:focus-visible {
    outline: none;
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/tree-view/index.js
var jpTreeView;
var init_tree_view4 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/tree-view/index.js"() {
    init_esm2();
    init_tree_view_styles();
    jpTreeView = TreeView.compose({
      baseName: "tree-view",
      template: treeViewTemplate,
      styles: treeViewStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/drafts/picker/picker.styles.js
var pickerStyles;
var init_picker_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/drafts/picker/picker.styles.js"() {
    init_esm();
    init_design_tokens();
    init_styles();
    pickerStyles = (context, definition) => css`
  .region {
    z-index: 1000;
    overflow: hidden;
    display: flex;
    font-family: ${bodyFont};
    font-size: ${typeRampBaseFontSize};
  }

  .loaded {
    opacity: 1;
    pointer-events: none;
  }

  .loading-display,
  .no-options-display {
    background: ${fillColor};
    width: 100%;
    min-height: calc(${heightNumber} * 1px);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-items: center;
    padding: calc(${designUnit} * 1px);
  }

  .loading-progress {
    width: 42px;
    height: 42px;
  }

  .bottom {
    flex-direction: column;
  }

  .top {
    flex-direction: column-reverse;
  }
`;
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/drafts/picker/picker-menu.styles.js
var pickerMenuStyles;
var init_picker_menu_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/drafts/picker/picker-menu.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    pickerMenuStyles = (context, definition) => css`
    :host {
      background: ${fillColor};
      --elevation: 11;
      /* TODO: a mechanism to manage z-index across components
            https://github.com/microsoft/fast/issues/3813 */
      z-index: 1000;
      display: flex;
      width: 100%;
      max-height: 100%;
      min-height: 58px;
      box-sizing: border-box;
      flex-direction: column;
      overflow-y: auto;
      overflow-x: hidden;
      pointer-events: auto;
      border-radius: calc(${controlCornerRadius} * 1px);
      padding: calc(${designUnit} * 1px) 0;
      border: calc(${strokeWidth} * 1px) solid transparent;
      ${elevation}
    }

    .suggestions-available-alert {
      height: 0;
      opacity: 0;
      overflow: hidden;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host {
        background: ${SystemColors.Canvas};
        border-color: ${SystemColors.CanvasText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/drafts/picker/picker-menu-option.styles.js
var pickerMenuOptionStyles;
var init_picker_menu_option_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/drafts/picker/picker-menu-option.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    pickerMenuOptionStyles = (context, definition) => css`
    :host {
      display: flex;
      align-items: center;
      justify-items: center;
      font-family: ${bodyFont};
      border-radius: calc(${controlCornerRadius} * 1px);
      border: calc(${focusStrokeWidth} * 1px) solid transparent;
      box-sizing: border-box;
      background: ${neutralFillStealthRest};
      color: ${neutralForegroundRest};
      cursor: pointer;
      fill: currentcolor;
      font-size: ${typeRampBaseFontSize};
      min-height: calc(${heightNumber} * 1px);
      line-height: ${typeRampBaseLineHeight};
      margin: 0 calc(${designUnit} * 1px);
      outline: none;
      overflow: hidden;
      padding: 0 calc(${designUnit} * 2.25px);
      user-select: none;
      white-space: nowrap;
    }

    :host(:${focusVisible}[role="listitem"]) {
      border-color: ${focusStrokeOuter2};
      background: ${neutralFillStealthFocus};
    }

    :host(:hover) {
      background: ${neutralFillStealthHover};
    }

    :host(:active) {
      background: ${neutralFillStealthActive};
    }

    :host([aria-selected='true']) {
      background: ${accentFillRest};
      color: ${foregroundOnAccentRest};
    }

    :host([aria-selected='true']:hover) {
      background: ${accentFillHover};
      color: ${foregroundOnAccentHover};
    }

    :host([aria-selected='true']:active) {
      background: ${accentFillActive};
      color: ${foregroundOnAccentActive};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host {
        border-color: transparent;
        forced-color-adjust: none;
        color: ${SystemColors.ButtonText};
        fill: currentcolor;
      }

      :host(:not([aria-selected='true']):hover),
      :host([aria-selected='true']) {
        background: ${SystemColors.Highlight};
        color: ${SystemColors.HighlightText};
      }

      :host([disabled]),
      :host([disabled]:not([aria-selected='true']):hover) {
        background: ${SystemColors.Canvas};
        color: ${SystemColors.GrayText};
        fill: currentcolor;
        opacity: 1;
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/drafts/picker/picker-list.styles.js
var pickerListStyles;
var init_picker_list_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/drafts/picker/picker-list.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    pickerListStyles = (context, definition) => css`
        :host {
            display: flex;
            flex-direction: row;
            column-gap: calc(${designUnit} * 1px);
            row-gap: calc(${designUnit} * 1px);
            flex-wrap: wrap;
        }

        ::slotted([role="combobox"]) {
            min-width: 260px;
            width: auto;
            box-sizing: border-box;
            color: ${neutralForegroundRest};
            background: ${neutralFillInputRest};
            border-radius: calc(${controlCornerRadius} * 1px);
            border: calc(${strokeWidth} * 1px) solid ${accentFillRest};
            height: calc(${heightNumber} * 1px);
            font-family: ${bodyFont};
            outline: none;
            user-select: none;
            font-size: ${typeRampBaseFontSize};
            line-height: ${typeRampBaseLineHeight};
            padding: 0 calc(${designUnit} * 2px + 1px);
        }

        ::slotted([role="combobox"]:active) { {
            background: ${neutralFillInputHover};
            border-color: ${accentFillActive};
        }

        ::slotted([role="combobox"]:focus-within) {
            border-color: ${focusStrokeOuter2};
            box-shadow: 0 0 0 1px ${focusStrokeOuter2} inset;
        }
    `.withBehaviors(forcedColorsStylesheetBehavior(css`
      ::slotted([role='combobox']:active) {
        background: ${SystemColors.Field};
        border-color: ${SystemColors.Highlight};
      }
      ::slotted([role='combobox']:focus-within) {
        border-color: ${SystemColors.Highlight};
        box-shadow: 0 0 0 1px ${SystemColors.Highlight} inset;
      }
      ::slotted(input:placeholder) {
        color: ${SystemColors.GrayText};
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/drafts/picker/picker-list-item.styles.js
var pickerListItemStyles;
var init_picker_list_item_styles = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/drafts/picker/picker-list-item.styles.js"() {
    init_esm();
    init_esm2();
    init_dist4();
    init_design_tokens();
    init_styles();
    pickerListItemStyles = (context, definition) => css`
    :host {
      display: flex;
      align-items: center;
      justify-items: center;
      font-family: ${bodyFont};
      border-radius: calc(${controlCornerRadius} * 1px);
      border: calc(${focusStrokeWidth} * 1px) solid transparent;
      box-sizing: border-box;
      background: ${neutralFillStealthRest};
      color: ${neutralForegroundRest};
      cursor: pointer;
      fill: currentcolor;
      font-size: ${typeRampBaseFontSize};
      height: calc(${heightNumber} * 1px);
      line-height: ${typeRampBaseLineHeight};
      outline: none;
      overflow: hidden;
      padding: 0 calc(${designUnit} * 2.25px);
      user-select: none;
      white-space: nowrap;
    }

    :host(:hover) {
      background: ${neutralFillStealthHover};
    }

    :host(:active) {
      background: ${neutralFillStealthActive};
    }

    :host(:${focusVisible}) {
      background: ${neutralFillStealthFocus};
      border-color: ${focusStrokeOuter2};
    }

    :host([aria-selected='true']) {
      background: ${accentFillRest};
      color: ${foregroundOnAccentActive};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host {
        border-color: transparent;
        forced-color-adjust: none;
        color: ${SystemColors.ButtonText};
        fill: currentcolor;
      }

      :host(:not([aria-selected='true']):hover),
      :host([aria-selected='true']) {
        background: ${SystemColors.Highlight};
        color: ${SystemColors.HighlightText};
      }

      :host([disabled]),
      :host([disabled]:not([aria-selected='true']):hover) {
        background: ${SystemColors.Canvas};
        color: ${SystemColors.GrayText};
        fill: currentcolor;
        opacity: 1;
      }
    `));
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/drafts/picker/index.js
var jpPicker, PickerMenu2, jpPickerMenu, jpPickerMenuOption, jpPickerList, jpPickerListItem;
var init_picker3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/drafts/picker/index.js"() {
    init_esm2();
    init_design_tokens();
    init_picker_styles();
    init_picker_menu_styles();
    init_picker_menu_option_styles();
    init_picker_list_styles();
    init_picker_list_item_styles();
    jpPicker = Picker.compose({
      baseName: "draft-picker",
      template: pickerTemplate,
      styles: pickerStyles,
      shadowOptions: {}
    });
    PickerMenu2 = class extends PickerMenu {
      /**
       * @public
       */
      connectedCallback() {
        fillColor.setValueFor(this, neutralLayerFloating2);
        super.connectedCallback();
      }
    };
    jpPickerMenu = PickerMenu2.compose({
      baseName: "draft-picker-menu",
      baseClass: PickerMenu,
      template: pickerMenuTemplate,
      styles: pickerMenuStyles
    });
    jpPickerMenuOption = PickerMenuOption.compose({
      baseName: "draft-picker-menu-option",
      template: pickerMenuOptionTemplate,
      styles: pickerMenuOptionStyles
    });
    jpPickerList = PickerList.compose({
      baseName: "draft-picker-list",
      template: pickerListTemplate,
      styles: pickerListStyles
    });
    jpPickerListItem = PickerListItem.compose({
      baseName: "draft-picker-list-item",
      template: pickerListItemTemplate,
      styles: pickerListItemStyles
    });
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/custom-elements.js
var init_custom_elements = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/custom-elements.js"() {
    init_accordion3();
    init_accordion_item3();
    init_anchor3();
    init_anchored_region3();
    init_avatar3();
    init_badge3();
    init_breadcrumb3();
    init_breadcrumb_item3();
    init_button5();
    init_card3();
    init_checkbox3();
    init_combobox3();
    init_data_grid3();
    init_date_field2();
    init_design_system_provider();
    init_dialog3();
    init_disclosure3();
    init_divider3();
    init_listbox3();
    init_menu4();
    init_menu_item3();
    init_number_field3();
    init_option();
    init_progress2();
    init_progress_ring2();
    init_radio3();
    init_radio_group3();
    init_search4();
    init_select3();
    init_skeleton3();
    init_slider3();
    init_slider_label3();
    init_switch3();
    init_tab_panel3();
    init_tab4();
    init_tabs3();
    init_text_area3();
    init_text_field3();
    init_toolbar3();
    init_tooltip3();
    init_tree_item3();
    init_tree_view4();
    init_picker3();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/jupyter-design-system.js
function provideJupyterDesignSystem(element) {
  return DesignSystem.getOrCreate(element).withPrefix("jp");
}
var init_jupyter_design_system = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/jupyter-design-system.js"() {
    init_esm2();
  }
});

// ../../node_modules/@jupyter/web-components/dist/esm/index.js
var init_esm3 = __esm({
  "../../node_modules/@jupyter/web-components/dist/esm/index.js"() {
    init_applyTheme();
    init_custom_elements();
    init_jupyter_design_system();
    init_accordion3();
    init_anchor3();
    init_anchored_region3();
    init_avatar3();
    init_badge3();
    init_breadcrumb3();
    init_breadcrumb_item3();
    init_button5();
    init_card3();
    init_checkbox3();
    init_combobox3();
    init_data_grid3();
    init_design_system_provider();
    init_design_system_provider();
    init_design_tokens();
    init_dialog3();
    init_disclosure3();
    init_divider3();
    init_listbox3();
    init_menu4();
    init_menu_item3();
    init_number_field3();
    init_option();
    init_progress2();
    init_progress_ring2();
    init_radio3();
    init_radio_group3();
    init_search4();
    init_select3();
    init_skeleton3();
    init_slider3();
    init_slider_label3();
    init_direction2();
    init_switch3();
    init_tabs3();
    init_text_area3();
    init_text_field3();
    init_toolbar3();
    init_tooltip3();
    init_tree_view4();
    init_tree_item3();
    init_picker3();
  }
});

// ../../node_modules/@microsoft/fast-react-wrapper/dist/esm/index.js
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else {
    ref2.current = value;
  }
}
function getTagName(type, config) {
  if (!config.name) {
    const definition = FASTElementDefinition.forType(type);
    if (definition) {
      config.name = definition.name;
    } else {
      throw new Error("React wrappers must wrap a FASTElement or be configured with a name.");
    }
  }
  return config.name;
}
function getElementEvents(config) {
  return config.events || (config.events = {});
}
function keyIsValid(type, config, name2) {
  if (reservedReactProperties.has(name2)) {
    console.warn(`${getTagName(type, config)} contains property ${name2} which is a React reserved property. It will be used by React and not set on the element.`);
    return false;
  }
  return true;
}
function getElementKeys(type, config) {
  if (!config.keys) {
    if (config.properties) {
      config.keys = new Set(config.properties.concat(Object.keys(getElementEvents(config))));
    } else {
      const keys = new Set(Object.keys(getElementEvents(config)));
      const accessors = Observable.getAccessors(type.prototype);
      if (accessors.length > 0) {
        for (const a of accessors) {
          if (keyIsValid(type, config, a.name)) {
            keys.add(a.name);
          }
        }
      } else {
        for (const p in type.prototype) {
          if (!(p in HTMLElement.prototype) && keyIsValid(type, config, p)) {
            keys.add(p);
          }
        }
      }
      config.keys = keys;
    }
  }
  return config.keys;
}
function provideReactWrapper(React20, designSystem) {
  let registrations = [];
  const registry = {
    register(container, ...rest) {
      registrations.forEach((x) => x.register(container, ...rest));
      registrations = [];
    }
  };
  function wrap2(type, config = {}) {
    var _a, _b;
    if (type instanceof FoundationElementRegistry) {
      if (designSystem) {
        designSystem.register(type);
      } else {
        registrations.push(type);
      }
      type = type.type;
    }
    const cachedCandidates = wrappersCache.get(type);
    if (cachedCandidates) {
      const cachedWrapper = cachedCandidates.get((_a = config.name) !== null && _a !== void 0 ? _a : DEFAULT_CACHE_NAME);
      if (cachedWrapper) {
        return cachedWrapper;
      }
    }
    class ReactComponent extends React20.Component {
      constructor() {
        super(...arguments);
        this._element = null;
      }
      _updateElement(oldProps) {
        const element = this._element;
        if (element === null) {
          return;
        }
        const currentProps = this.props;
        const previousProps = oldProps || emptyProps;
        const events = getElementEvents(config);
        for (const key2 in this._elementProps) {
          const newValue = currentProps[key2];
          const event = events[key2];
          if (event === void 0) {
            element[key2] = newValue;
          } else {
            const oldValue = previousProps[key2];
            if (newValue === oldValue) {
              continue;
            }
            if (oldValue !== void 0) {
              element.removeEventListener(event, oldValue);
            }
            if (newValue !== void 0) {
              element.addEventListener(event, newValue);
            }
          }
        }
      }
      componentDidMount() {
        this._updateElement();
      }
      componentDidUpdate(old) {
        this._updateElement(old);
      }
      render() {
        const userRef = this.props.__forwardedRef;
        if (this._ref === void 0 || this._userRef !== userRef) {
          this._ref = (value) => {
            if (this._element === null) {
              this._element = value;
            }
            if (userRef !== null) {
              setRef(userRef, value);
            }
            this._userRef = userRef;
          };
        }
        const newReactProps = { ref: this._ref };
        const newElementProps = this._elementProps = {};
        const elementKeys = getElementKeys(type, config);
        const currentProps = this.props;
        for (const k in currentProps) {
          const v = currentProps[k];
          if (elementKeys.has(k)) {
            newElementProps[k] = v;
          } else {
            newReactProps[k === "className" ? "class" : k] = v;
          }
        }
        return React20.createElement(getTagName(type, config), newReactProps);
      }
    }
    const reactComponent = React20.forwardRef((props, ref2) => React20.createElement(ReactComponent, Object.assign(Object.assign({}, props), { __forwardedRef: ref2 }), props === null || props === void 0 ? void 0 : props.children));
    if (!wrappersCache.has(type)) {
      wrappersCache.set(type, /* @__PURE__ */ new Map());
    }
    wrappersCache.get(type).set((_b = config.name) !== null && _b !== void 0 ? _b : DEFAULT_CACHE_NAME, reactComponent);
    return reactComponent;
  }
  return { wrap: wrap2, registry };
}
var reservedReactProperties, emptyProps, DEFAULT_CACHE_NAME, wrappersCache;
var init_esm4 = __esm({
  "../../node_modules/@microsoft/fast-react-wrapper/dist/esm/index.js"() {
    init_esm();
    init_esm2();
    reservedReactProperties = /* @__PURE__ */ new Set([
      "children",
      "localName",
      "ref",
      "style",
      "className"
    ]);
    emptyProps = Object.freeze(/* @__PURE__ */ Object.create(null));
    DEFAULT_CACHE_NAME = "_default";
    wrappersCache = /* @__PURE__ */ new Map();
  }
});

// ../../node_modules/@jupyter/react-components/lib/wrap.js
var import_react25, wrap;
var init_wrap = __esm({
  "../../node_modules/@jupyter/react-components/lib/wrap.js"() {
    init_esm3();
    init_esm4();
    import_react25 = __toESM(require_react());
    ({ wrap } = provideReactWrapper(import_react25.default, provideJupyterDesignSystem()));
  }
});

// ../../node_modules/@jupyter/react-components/lib/accordion/index.js
var Accordion2;
var init_accordion4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/accordion/index.js"() {
    init_esm3();
    init_wrap();
    Accordion2 = wrap(jpAccordion(), { events: { onChange: "change" } });
    Accordion2.displayName = "Jupyter.Accordion";
  }
});

// ../../node_modules/@jupyter/react-components/lib/accordion-item/index.js
var AccordionItem2;
var init_accordion_item4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/accordion-item/index.js"() {
    init_esm3();
    init_wrap();
    AccordionItem2 = wrap(jpAccordionItem(), { events: { onChange: "change" } });
    AccordionItem2.displayName = "Jupyter.AccordionItem";
  }
});

// ../../node_modules/@jupyter/react-components/lib/anchor/index.js
var Anchor3;
var init_anchor4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/anchor/index.js"() {
    init_esm3();
    init_wrap();
    Anchor3 = wrap(jpAnchor());
    Anchor3.displayName = "Jupyter.Anchor";
  }
});

// ../../node_modules/@jupyter/react-components/lib/anchored-region/index.js
var AnchoredRegion2;
var init_anchored_region4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/anchored-region/index.js"() {
    init_esm3();
    init_wrap();
    AnchoredRegion2 = wrap(jpAnchoredRegion());
    AnchoredRegion2.displayName = "Jupyter.AnchoredRegion";
  }
});

// ../../node_modules/@jupyter/react-components/lib/avatar/index.js
var Avatar3;
var init_avatar4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/avatar/index.js"() {
    init_esm3();
    init_wrap();
    Avatar3 = wrap(jpAvatar());
    Avatar3.displayName = "Jupyter.Avatar";
  }
});

// ../../node_modules/@jupyter/react-components/lib/badge/index.js
var Badge2;
var init_badge4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/badge/index.js"() {
    init_esm3();
    init_wrap();
    Badge2 = wrap(jpBadge());
    Badge2.displayName = "Jupyter.Badge";
  }
});

// ../../node_modules/@jupyter/react-components/lib/breadcrumb/index.js
var Breadcrumb2;
var init_breadcrumb4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/breadcrumb/index.js"() {
    init_esm3();
    init_wrap();
    Breadcrumb2 = wrap(jpBreadcrumb());
    Breadcrumb2.displayName = "Jupyter.Breadcrumb";
  }
});

// ../../node_modules/@jupyter/react-components/lib/breadcrumb-item/index.js
var BreadcrumbItem2;
var init_breadcrumb_item4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/breadcrumb-item/index.js"() {
    init_esm3();
    init_wrap();
    BreadcrumbItem2 = wrap(jpBreadcrumbItem());
    BreadcrumbItem2.displayName = "Jupyter.BreadcrumbItem";
  }
});

// ../../node_modules/@jupyter/react-components/lib/button/index.js
var Button4;
var init_button6 = __esm({
  "../../node_modules/@jupyter/react-components/lib/button/index.js"() {
    init_esm3();
    init_wrap();
    Button4 = wrap(jpButton());
    Button4.displayName = "Jupyter.Button";
  }
});

// ../../node_modules/@jupyter/react-components/lib/card/index.js
var Card3;
var init_card4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/card/index.js"() {
    init_esm3();
    init_wrap();
    Card3 = wrap(jpCard());
    Card3.displayName = "Jupyter.Card";
  }
});

// ../../node_modules/@jupyter/react-components/lib/checkbox/index.js
var Checkbox3;
var init_checkbox4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/checkbox/index.js"() {
    init_esm3();
    init_wrap();
    Checkbox3 = wrap(jpCheckbox(), { events: { onChange: "change" } });
    Checkbox3.displayName = "Jupyter.Checkbox";
  }
});

// ../../node_modules/@jupyter/react-components/lib/combobox/index.js
var Combobox3;
var init_combobox4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/combobox/index.js"() {
    init_esm3();
    init_wrap();
    Combobox3 = wrap(jpCombobox(), {
      events: {
        onChange: "change",
        onInput: "input"
      }
    });
    Combobox3.displayName = "Jupyter.Combobox";
  }
});

// ../../node_modules/@jupyter/react-components/lib/data-grid/index.js
var DataGridCell2, DataGridRow2, DataGrid2;
var init_data_grid4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/data-grid/index.js"() {
    init_esm3();
    init_wrap();
    DataGridCell2 = wrap(jpDataGridCell(), {
      events: { onFocus: "cell-focused" }
    });
    DataGridCell2.displayName = "Jupyter.DataGridCell";
    DataGridRow2 = wrap(jpDataGridRow(), { events: { onFocus: "row-focused" } });
    DataGridRow2.displayName = "Jupyter.DataGridRow";
    DataGrid2 = wrap(jpDataGrid());
    DataGrid2.displayName = "Jupyter.DataGrid";
  }
});

// ../../node_modules/@jupyter/react-components/lib/date-field/index.js
var DateField2;
var init_date_field3 = __esm({
  "../../node_modules/@jupyter/react-components/lib/date-field/index.js"() {
    init_esm3();
    init_wrap();
    DateField2 = wrap(jpDateField(), {
      events: { onChange: "change" }
    });
    DateField2.displayName = "Jupyter.DateField";
  }
});

// ../../node_modules/@jupyter/react-components/lib/design-system-provider/index.js
var DesignSystemProvider2;
var init_design_system_provider2 = __esm({
  "../../node_modules/@jupyter/react-components/lib/design-system-provider/index.js"() {
    init_esm3();
    init_wrap();
    DesignSystemProvider2 = wrap(jpDesignSystemProvider());
    DesignSystemProvider2.displayName = "Jupyter.DesignSystemProvider";
  }
});

// ../../node_modules/@jupyter/react-components/lib/dialog/index.js
var Dialog2;
var init_dialog4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/dialog/index.js"() {
    init_esm3();
    init_wrap();
    Dialog2 = wrap(jpDialog());
    Dialog2.displayName = "Jupyter.Dialog";
  }
});

// ../../node_modules/@jupyter/react-components/lib/disclosure/index.js
var Disclosure3;
var init_disclosure4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/disclosure/index.js"() {
    init_esm3();
    init_wrap();
    Disclosure3 = wrap(jpDisclosure(), {
      events: { onToggle: "toggle" }
    });
    Disclosure3.displayName = "Jupyter.Disclosure";
  }
});

// ../../node_modules/@jupyter/react-components/lib/divider/index.js
var Divider2;
var init_divider4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/divider/index.js"() {
    init_esm3();
    init_wrap();
    Divider2 = wrap(jpDivider());
    Divider2.displayName = "Jupyter.Divider";
  }
});

// ../../node_modules/@jupyter/react-components/lib/listbox/index.js
var Listbox3;
var init_listbox4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/listbox/index.js"() {
    init_esm3();
    init_wrap();
    Listbox3 = wrap(jpListbox());
    Listbox3.displayName = "Jupyter.Listbox";
  }
});

// ../../node_modules/@jupyter/react-components/lib/menu/index.js
var Menu4;
var init_menu5 = __esm({
  "../../node_modules/@jupyter/react-components/lib/menu/index.js"() {
    init_esm3();
    init_wrap();
    Menu4 = wrap(jpMenu());
    Menu4.displayName = "Jupyter.Menu";
  }
});

// ../../node_modules/@jupyter/react-components/lib/menu-item/index.js
var MenuItem2;
var init_menu_item4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/menu-item/index.js"() {
    init_esm3();
    init_wrap();
    MenuItem2 = wrap(jpMenuItem(), { events: { onExpand: "expanded-change" } });
    MenuItem2.displayName = "Jupyter.MenuItem";
  }
});

// ../../node_modules/@jupyter/react-components/lib/number-field/index.js
var NumberField3;
var init_number_field4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/number-field/index.js"() {
    init_esm3();
    init_wrap();
    NumberField3 = wrap(jpNumberField(), {
      events: { onChange: "change", onInput: "input" }
    });
    NumberField3.displayName = "Jupyter.NumberField";
  }
});

// ../../node_modules/@jupyter/react-components/lib/option/index.js
var Option2;
var init_option2 = __esm({
  "../../node_modules/@jupyter/react-components/lib/option/index.js"() {
    init_esm3();
    init_wrap();
    Option2 = wrap(jpOption());
    Option2.displayName = "Juypter.Option";
  }
});

// ../../node_modules/@jupyter/react-components/lib/progress/index.js
var Progress;
var init_progress3 = __esm({
  "../../node_modules/@jupyter/react-components/lib/progress/index.js"() {
    init_esm3();
    init_wrap();
    Progress = wrap(jpProgress(), { name: "jp-progress" });
    Progress.displayName = "Jupyter.Progress";
  }
});

// ../../node_modules/@jupyter/react-components/lib/progress-ring/index.js
var ProgressRing;
var init_progress_ring3 = __esm({
  "../../node_modules/@jupyter/react-components/lib/progress-ring/index.js"() {
    init_esm3();
    init_wrap();
    ProgressRing = wrap(
      jpProgressRing(),
      // Name need to be exported otherwise a `jp-progress` element is instantiated
      { name: "jp-progress-ring" }
    );
    ProgressRing.displayName = "Jupyter.ProgressRing";
  }
});

// ../../node_modules/@jupyter/react-components/lib/radio/index.js
var Radio3;
var init_radio4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/radio/index.js"() {
    init_esm3();
    init_wrap();
    Radio3 = wrap(jpRadio(), { events: { onChange: "change" } });
    Radio3.displayName = "Jupyter.Radio";
  }
});

// ../../node_modules/@jupyter/react-components/lib/radio-group/index.js
var RadioGroup3;
var init_radio_group4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/radio-group/index.js"() {
    init_esm3();
    init_wrap();
    RadioGroup3 = wrap(jpRadioGroup(), { events: { onChange: "change" } });
    RadioGroup3.displayName = "Jupyter.RadioGroup";
  }
});

// ../../node_modules/@jupyter/react-components/lib/search/index.js
var Search3;
var init_search5 = __esm({
  "../../node_modules/@jupyter/react-components/lib/search/index.js"() {
    init_esm3();
    init_wrap();
    Search3 = wrap(jpSearch(), {
      events: {
        onChange: "change",
        onInput: "input"
      }
    });
    Search3.displayName = "Jupyter.Search";
  }
});

// ../../node_modules/@jupyter/react-components/lib/select/index.js
var Select3;
var init_select4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/select/index.js"() {
    init_esm3();
    init_wrap();
    Select3 = wrap(jpSelect(), {
      events: {
        onChange: "change",
        onInput: "input"
      }
    });
    Select3.displayName = "Jupyter.Select";
  }
});

// ../../node_modules/@jupyter/react-components/lib/skeleton/index.js
var Skeleton2;
var init_skeleton4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/skeleton/index.js"() {
    init_esm3();
    init_wrap();
    Skeleton2 = wrap(jpSkeleton());
    Skeleton2.displayName = "Jupyter.Skeleton";
  }
});

// ../../node_modules/@jupyter/react-components/lib/slider/index.js
var Slider3;
var init_slider4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/slider/index.js"() {
    init_esm3();
    init_wrap();
    Slider3 = wrap(jpSlider(), { events: { onChange: "change" } });
    Slider3.displayName = "Jupyter.Slider";
  }
});

// ../../node_modules/@jupyter/react-components/lib/slider-label/index.js
var SliderLabel3;
var init_slider_label4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/slider-label/index.js"() {
    init_esm3();
    init_wrap();
    SliderLabel3 = wrap(jpSliderLabel());
    SliderLabel3.displayName = "Jupyter.SliderLabel";
  }
});

// ../../node_modules/@jupyter/react-components/lib/switch/index.js
var Switch3;
var init_switch4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/switch/index.js"() {
    init_esm3();
    init_wrap();
    Switch3 = wrap(jpSwitch(), { events: { onChange: "change" } });
    Switch3.displayName = "Jupyter.Switch";
  }
});

// ../../node_modules/@jupyter/react-components/lib/tab-panel/index.js
var TabPanel3;
var init_tab_panel4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/tab-panel/index.js"() {
    init_esm3();
    init_wrap();
    TabPanel3 = wrap(jpTabPanel());
    TabPanel3.displayName = "Jupyter.TabPanel";
  }
});

// ../../node_modules/@jupyter/react-components/lib/tab/index.js
var Tab2;
var init_tab5 = __esm({
  "../../node_modules/@jupyter/react-components/lib/tab/index.js"() {
    init_esm3();
    init_wrap();
    Tab2 = wrap(jpTab());
    Tab2.displayName = "Jupyter.Tab";
  }
});

// ../../node_modules/@jupyter/react-components/lib/tabs/index.js
var Tabs2;
var init_tabs4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/tabs/index.js"() {
    init_esm3();
    init_wrap();
    Tabs2 = wrap(jpTabs(), { events: { onChange: "change" } });
    Tabs2.displayName = "Jupyter.Tabs";
  }
});

// ../../node_modules/@jupyter/react-components/lib/text-area/index.js
var TextArea3;
var init_text_area4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/text-area/index.js"() {
    init_esm3();
    init_wrap();
    TextArea3 = wrap(jpTextArea(), {
      events: { onChange: "change" }
    });
    TextArea3.displayName = "Jupyter.TextArea";
  }
});

// ../../node_modules/@jupyter/react-components/lib/text-field/index.js
var TextField3;
var init_text_field4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/text-field/index.js"() {
    init_esm3();
    init_wrap();
    TextField3 = wrap(jpTextField(), {
      events: { onChange: "change", onInput: "input" }
    });
    TextField3.displayName = "Jupyter.TextField";
  }
});

// ../../node_modules/@jupyter/react-components/lib/toolbar/index.js
var Toolbar3;
var init_toolbar4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/toolbar/index.js"() {
    init_esm3();
    init_wrap();
    Toolbar3 = wrap(jpToolbar());
    Toolbar3.displayName = "Jupyter.Toolbar";
  }
});

// ../../node_modules/@jupyter/react-components/lib/tooltip/index.js
var Tooltip2;
var init_tooltip4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/tooltip/index.js"() {
    init_esm3();
    init_wrap();
    Tooltip2 = wrap(jpTooltip());
    Tooltip2.displayName = "Jupyter.Tooltip";
  }
});

// ../../node_modules/@jupyter/react-components/lib/tree-item/index.js
var TreeItem2;
var init_tree_item4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/tree-item/index.js"() {
    init_esm3();
    init_wrap();
    TreeItem2 = wrap(jpTreeItem(), {
      events: { onExpand: "expanded-change", onSelect: "selected-change" }
    });
    TreeItem2.displayName = "Jupyter.TreeItem";
  }
});

// ../../node_modules/@jupyter/react-components/lib/tree-view/index.js
var TreeView2;
var init_tree_view5 = __esm({
  "../../node_modules/@jupyter/react-components/lib/tree-view/index.js"() {
    init_esm3();
    init_wrap();
    TreeView2 = wrap(jpTreeView());
    TreeView2.displayName = "Jupyter.TreeView";
  }
});

// ../../node_modules/@jupyter/react-components/lib/drafts/picker/index.js
var Picker2;
var init_picker4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/drafts/picker/index.js"() {
    init_esm3();
    init_wrap();
    Picker2 = wrap(jpPicker(), {
      events: {
        onChange: "change",
        onInput: "input"
      }
    });
    Picker2.displayName = "Jupyter.Picker";
  }
});

// ../../node_modules/@jupyter/react-components/lib/index.js
var init_lib4 = __esm({
  "../../node_modules/@jupyter/react-components/lib/index.js"() {
    init_wrap();
    init_accordion4();
    init_accordion_item4();
    init_anchor4();
    init_anchored_region4();
    init_avatar4();
    init_badge4();
    init_breadcrumb4();
    init_breadcrumb_item4();
    init_button6();
    init_card4();
    init_checkbox4();
    init_combobox4();
    init_data_grid4();
    init_date_field3();
    init_design_system_provider2();
    init_dialog4();
    init_disclosure4();
    init_divider4();
    init_listbox4();
    init_menu5();
    init_menu_item4();
    init_number_field4();
    init_option2();
    init_progress3();
    init_progress_ring3();
    init_radio4();
    init_radio_group4();
    init_search5();
    init_select4();
    init_skeleton4();
    init_slider4();
    init_slider_label4();
    init_switch4();
    init_tab_panel4();
    init_tab5();
    init_tabs4();
    init_text_area4();
    init_text_field4();
    init_toolbar4();
    init_tooltip4();
    init_tree_item4();
    init_tree_view5();
    init_picker4();
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/collections/dist/index.es6.js
var LinkedList2, Private20;
var init_index_es620 = __esm({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/collections/dist/index.es6.js"() {
    LinkedList2 = class {
      constructor() {
        this._first = null;
        this._last = null;
        this._size = 0;
      }
      /**
       * Whether the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get isEmpty() {
        return this._size === 0;
      }
      /**
       * The size of the list.
       *
       * #### Complexity
       * `O(1)`
       *
       * #### Notes
       * This is equivalent to `length`.
       */
      get size() {
        return this._size;
      }
      /**
       * The length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `size`.
       *
       * This property is deprecated.
       */
      get length() {
        return this._size;
      }
      /**
       * The first value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get first() {
        return this._first ? this._first.value : void 0;
      }
      /**
       * The last value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get last() {
        return this._last ? this._last.value : void 0;
      }
      /**
       * The first node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get firstNode() {
        return this._first;
      }
      /**
       * The last node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get lastNode() {
        return this._last;
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting with the first value.
       *
       * #### Complexity
       * Constant.
       */
      *[Symbol.iterator]() {
        let node = this._first;
        while (node) {
          yield node.value;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the values in the list.
       *
       * @returns A new iterator starting with the last value.
       *
       * #### Complexity
       * Constant.
       */
      *retro() {
        let node = this._last;
        while (node) {
          yield node.value;
          node = node.prev;
        }
      }
      /**
       * Create an iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the first node.
       *
       * #### Complexity
       * Constant.
       */
      *nodes() {
        let node = this._first;
        while (node) {
          yield node;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the last node.
       *
       * #### Complexity
       * Constant.
       */
      *retroNodes() {
        let node = this._last;
        while (node) {
          yield node;
          node = node.prev;
        }
      }
      /**
       * Assign new values to the list, replacing all current values.
       *
       * @param values - The values to assign to the list.
       *
       * #### Complexity
       * Linear.
       */
      assign(values) {
        this.clear();
        for (const value of values) {
          this.addLast(value);
        }
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addLast`.
       */
      push(value) {
        this.addLast(value);
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeLast`.
       */
      pop() {
        return this.removeLast();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addFirst`.
       */
      shift(value) {
        this.addFirst(value);
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeFirst`.
       */
      unshift() {
        return this.removeFirst();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addFirst(value) {
        let node = new Private20.LinkedListNode(this, value);
        if (!this._first) {
          this._first = node;
          this._last = node;
        } else {
          node.next = this._first;
          this._first.prev = node;
          this._first = node;
        }
        this._size++;
        return node;
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addLast(value) {
        let node = new Private20.LinkedListNode(this, value);
        if (!this._last) {
          this._first = node;
          this._last = node;
        } else {
          node.prev = this._last;
          this._last.next = node;
          this._last = node;
        }
        this._size++;
        return node;
      }
      /**
       * Insert a value before a specific node in the list.
       *
       * @param value - The value to insert before the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertBefore(value, ref2) {
        if (!ref2 || ref2 === this._first) {
          return this.addFirst(value);
        }
        if (!(ref2 instanceof Private20.LinkedListNode) || ref2.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private20.LinkedListNode(this, value);
        let _ref = ref2;
        let prev = _ref.prev;
        node.next = _ref;
        node.prev = prev;
        _ref.prev = node;
        prev.next = node;
        this._size++;
        return node;
      }
      /**
       * Insert a value after a specific node in the list.
       *
       * @param value - The value to insert after the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertAfter(value, ref2) {
        if (!ref2 || ref2 === this._last) {
          return this.addLast(value);
        }
        if (!(ref2 instanceof Private20.LinkedListNode) || ref2.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private20.LinkedListNode(this, value);
        let _ref = ref2;
        let next = _ref.next;
        node.next = next;
        node.prev = _ref;
        _ref.next = node;
        next.prev = node;
        this._size++;
        return node;
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeFirst() {
        let node = this._first;
        if (!node) {
          return void 0;
        }
        if (node === this._last) {
          this._first = null;
          this._last = null;
        } else {
          this._first = node.next;
          this._first.prev = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeLast() {
        let node = this._last;
        if (!node) {
          return void 0;
        }
        if (node === this._first) {
          this._first = null;
          this._last = null;
        } else {
          this._last = node.prev;
          this._last.next = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove a specific node from the list.
       *
       * @param node - The node to remove from the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * The node must be owned by the list.
       */
      removeNode(node) {
        if (!(node instanceof Private20.LinkedListNode) || node.list !== this) {
          throw new Error("Node is not owned by the list.");
        }
        let _node = node;
        if (_node === this._first && _node === this._last) {
          this._first = null;
          this._last = null;
        } else if (_node === this._first) {
          this._first = _node.next;
          this._first.prev = null;
        } else if (_node === this._last) {
          this._last = _node.prev;
          this._last.next = null;
        } else {
          _node.next.prev = _node.prev;
          _node.prev.next = _node.next;
        }
        _node.list = null;
        _node.next = null;
        _node.prev = null;
        this._size--;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       */
      clear() {
        let node = this._first;
        while (node) {
          let next = node.next;
          node.list = null;
          node.prev = null;
          node.next = null;
          node = next;
        }
        this._first = null;
        this._last = null;
        this._size = 0;
      }
    };
    (function(LinkedList4) {
      function from2(values) {
        let list = new LinkedList4();
        list.assign(values);
        return list;
      }
      LinkedList4.from = from2;
    })(LinkedList2 || (LinkedList2 = {}));
    (function(Private36) {
      class LinkedListNode {
        /**
         * Construct a new linked list node.
         *
         * @param list - The list which owns the node.
         *
         * @param value - The value for the link.
         */
        constructor(list, value) {
          this.list = null;
          this.next = null;
          this.prev = null;
          this.list = list;
          this.value = value;
        }
      }
      Private36.LinkedListNode = LinkedListNode;
    })(Private20 || (Private20 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/messaging/dist/index.es6.js
var MessageLoop2;
var init_index_es621 = __esm({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/messaging/dist/index.es6.js"() {
    init_index_es619();
    init_index_es620();
    (function(MessageLoop4) {
      let pending = null;
      const schedule = ((resolved) => (fn) => {
        let rejected = false;
        resolved.then(() => !rejected && fn());
        return () => {
          rejected = true;
        };
      })(Promise.resolve());
      function sendMessage(handler, msg) {
        let hooks = messageHooks.get(handler);
        if (!hooks || hooks.length === 0) {
          invokeHandler(handler, msg);
          return;
        }
        let passed = every2(retro2(hooks), (hook) => {
          return hook ? invokeHook(hook, handler, msg) : true;
        });
        if (passed) {
          invokeHandler(handler, msg);
        }
      }
      MessageLoop4.sendMessage = sendMessage;
      function postMessage(handler, msg) {
        if (!msg.isConflatable) {
          enqueueMessage(handler, msg);
          return;
        }
        let conflated = some2(messageQueue, (posted) => {
          if (posted.handler !== handler) {
            return false;
          }
          if (!posted.msg) {
            return false;
          }
          if (posted.msg.type !== msg.type) {
            return false;
          }
          if (!posted.msg.isConflatable) {
            return false;
          }
          return posted.msg.conflate(msg);
        });
        if (!conflated) {
          enqueueMessage(handler, msg);
        }
      }
      MessageLoop4.postMessage = postMessage;
      function installMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.indexOf(hook) !== -1) {
          return;
        }
        if (!hooks) {
          messageHooks.set(handler, [hook]);
        } else {
          hooks.push(hook);
        }
      }
      MessageLoop4.installMessageHook = installMessageHook;
      function removeMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (!hooks) {
          return;
        }
        let i = hooks.indexOf(hook);
        if (i === -1) {
          return;
        }
        hooks[i] = null;
        scheduleCleanup(hooks);
      }
      MessageLoop4.removeMessageHook = removeMessageHook;
      function clearData(handler) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.length > 0) {
          ArrayExt5.fill(hooks, null);
          scheduleCleanup(hooks);
        }
        for (const posted of messageQueue) {
          if (posted.handler === handler) {
            posted.handler = null;
            posted.msg = null;
          }
        }
      }
      MessageLoop4.clearData = clearData;
      function flush() {
        if (flushGuard || pending === null) {
          return;
        }
        pending();
        pending = null;
        flushGuard = true;
        runMessageLoop();
        flushGuard = false;
      }
      MessageLoop4.flush = flush;
      function getExceptionHandler() {
        return exceptionHandler;
      }
      MessageLoop4.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = exceptionHandler;
        exceptionHandler = handler;
        return old;
      }
      MessageLoop4.setExceptionHandler = setExceptionHandler;
      const messageQueue = new LinkedList2();
      const messageHooks = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      let exceptionHandler = (err) => {
        console.error(err);
      };
      let flushGuard = false;
      function invokeHook(hook, handler, msg) {
        let result = true;
        try {
          if (typeof hook === "function") {
            result = hook(handler, msg);
          } else {
            result = hook.messageHook(handler, msg);
          }
        } catch (err) {
          exceptionHandler(err);
        }
        return result;
      }
      function invokeHandler(handler, msg) {
        try {
          handler.processMessage(msg);
        } catch (err) {
          exceptionHandler(err);
        }
      }
      function enqueueMessage(handler, msg) {
        messageQueue.addLast({ handler, msg });
        if (pending !== null) {
          return;
        }
        pending = schedule(runMessageLoop);
      }
      function runMessageLoop() {
        pending = null;
        if (messageQueue.isEmpty) {
          return;
        }
        let sentinel = { handler: null, msg: null };
        messageQueue.addLast(sentinel);
        while (true) {
          let posted = messageQueue.removeFirst();
          if (posted === sentinel) {
            return;
          }
          if (posted.handler && posted.msg) {
            sendMessage(posted.handler, posted.msg);
          }
        }
      }
      function scheduleCleanup(hooks) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(hooks);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupHooks);
        dirtySet.clear();
      }
      function cleanupHooks(hooks) {
        ArrayExt5.removeAllWhere(hooks, isNull);
      }
      function isNull(value) {
        return value === null;
      }
    })(MessageLoop2 || (MessageLoop2 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/properties/dist/index.es6.js
var AttachedProperty3, Private21;
var init_index_es622 = __esm({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/properties/dist/index.es6.js"() {
    AttachedProperty3 = class {
      /**
       * Construct a new attached property.
       *
       * @param options - The options for initializing the property.
       */
      constructor(options) {
        this._pid = Private21.nextPID();
        this.name = options.name;
        this._create = options.create;
        this._coerce = options.coerce || null;
        this._compare = options.compare || null;
        this._changed = options.changed || null;
      }
      /**
       * Get the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @returns The current value of the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and assigned as the current value of the property.
       */
      get(owner) {
        let value;
        let map2 = Private21.ensureMap(owner);
        if (this._pid in map2) {
          value = map2[this._pid];
        } else {
          value = map2[this._pid] = this._createValue(owner);
        }
        return value;
      }
      /**
       * Set the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @param value - The value for the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      set(owner, value) {
        let oldValue;
        let map2 = Private21.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, value);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Explicitly coerce the current property value for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      coerce(owner) {
        let oldValue;
        let map2 = Private21.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, oldValue);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Get or create the default value for the given owner.
       */
      _createValue(owner) {
        let create5 = this._create;
        return create5(owner);
      }
      /**
       * Coerce the value for the given owner.
       */
      _coerceValue(owner, value) {
        let coerce = this._coerce;
        return coerce ? coerce(owner, value) : value;
      }
      /**
       * Compare the old value and new value for equality.
       */
      _compareValue(oldValue, newValue) {
        let compare = this._compare;
        return compare ? compare(oldValue, newValue) : oldValue === newValue;
      }
      /**
       * Run the change notification if the given values are different.
       */
      _maybeNotify(owner, oldValue, newValue) {
        let changed = this._changed;
        if (changed && !this._compareValue(oldValue, newValue)) {
          changed(owner, oldValue, newValue);
        }
      }
    };
    (function(AttachedProperty5) {
      function clearData(owner) {
        Private21.ownerData.delete(owner);
      }
      AttachedProperty5.clearData = clearData;
    })(AttachedProperty3 || (AttachedProperty3 = {}));
    (function(Private36) {
      Private36.ownerData = /* @__PURE__ */ new WeakMap();
      Private36.nextPID = (() => {
        let id = 0;
        return () => {
          let rand = Math.random();
          let stem = `${rand}`.slice(2);
          return `pid-${stem}-${id++}`;
        };
      })();
      function ensureMap(owner) {
        let map2 = Private36.ownerData.get(owner);
        if (map2) {
          return map2;
        }
        map2 = /* @__PURE__ */ Object.create(null);
        Private36.ownerData.set(owner, map2);
        return map2;
      }
      Private36.ensureMap = ensureMap;
    })(Private21 || (Private21 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/vdom.js
var React7, import_client2, ReactWidget, VDomRenderer, UseSignal, VDomModel;
var init_vdom = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/vdom.js"() {
    init_index_es621();
    init_index_es63();
    init_index_es618();
    React7 = __toESM(require_react());
    import_client2 = __toESM(require_client());
    ReactWidget = class extends Widget {
      constructor() {
        super();
        this._rootDOM = null;
      }
      /**
       * Creates a new `ReactWidget` that renders a constant element.
       * @param element React element to render.
       */
      static create(element) {
        return new class extends ReactWidget {
          render() {
            return element;
          }
        }();
      }
      /**
       * Called to update the state of the widget.
       *
       * The default implementation of this method triggers
       * VDOM based rendering by calling the `renderDOM` method.
       */
      onUpdateRequest(msg) {
        this.renderPromise = this.renderDOM();
      }
      /**
       * Called after the widget is attached to the DOM
       */
      onAfterAttach(msg) {
        MessageLoop2.sendMessage(this, Widget.Msg.UpdateRequest);
      }
      /**
       * Called before the widget is detached from the DOM.
       */
      onBeforeDetach(msg) {
        if (this._rootDOM !== null) {
          this._rootDOM.unmount();
          this._rootDOM = null;
        }
      }
      /**
       * Render the React nodes to the DOM.
       *
       * @returns a promise that resolves when the rendering is done.
       */
      renderDOM() {
        return new Promise((resolve) => {
          const vnode = this.render();
          if (this._rootDOM === null) {
            this._rootDOM = (0, import_client2.createRoot)(this.node);
          }
          if (Array.isArray(vnode)) {
            this._rootDOM.render(vnode);
            requestIdleCallback(() => resolve());
          } else if (vnode) {
            this._rootDOM.render(vnode);
            requestIdleCallback(() => resolve());
          } else {
            this._rootDOM.unmount();
            this._rootDOM = null;
            requestIdleCallback(() => resolve());
          }
        });
      }
    };
    VDomRenderer = class extends ReactWidget {
      /**
       * Create a new VDomRenderer
       */
      constructor(model) {
        super();
        this._modelChanged = new Signal(this);
        this.model = model !== null && model !== void 0 ? model : null;
      }
      /**
       * A signal emitted when the model changes.
       */
      get modelChanged() {
        return this._modelChanged;
      }
      /**
       * Set the model and fire changed signals.
       */
      set model(newValue) {
        if (this._model === newValue) {
          return;
        }
        if (this._model) {
          this._model.stateChanged.disconnect(this.update, this);
        }
        this._model = newValue;
        if (newValue) {
          newValue.stateChanged.connect(this.update, this);
        }
        this.update();
        this._modelChanged.emit(void 0);
      }
      /**
       * Get the current model.
       */
      get model() {
        return this._model;
      }
      /**
       * Dispose this widget.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._model = null;
        super.dispose();
      }
    };
    UseSignal = class extends React7.Component {
      constructor(props) {
        super(props);
        this.slot = (sender, args) => {
          if (this.props.shouldUpdate && !this.props.shouldUpdate(sender, args)) {
            return;
          }
          this.setState({ value: [sender, args] });
        };
        this.state = { value: [this.props.initialSender, this.props.initialArgs] };
      }
      componentDidMount() {
        this.props.signal.connect(this.slot);
      }
      componentWillUnmount() {
        this.props.signal.disconnect(this.slot);
      }
      render() {
        return this.props.children(...this.state.value);
      }
    };
    VDomModel = class {
      constructor() {
        this.stateChanged = new Signal(this);
        this._isDisposed = false;
      }
      /**
       * Test whether the model is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose the model.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
      }
    };
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/toolbar.js
function ToolbarButtonComponent(props) {
  var _a, _b;
  const actualOnClick = (_a = props.actualOnClick) !== null && _a !== void 0 ? _a : false;
  const handleMouseDown = actualOnClick ? void 0 : (event) => {
    var _a2;
    if (event.button === 0) {
      event.preventDefault();
      (_a2 = props.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(props);
    }
  };
  const handleClick = actualOnClick ? (event) => {
    var _a2;
    if (event.button === 0) {
      (_a2 = props.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(props);
    }
  } : void 0;
  const handleKeyDown = (event) => {
    var _a2;
    const { key: key2 } = event;
    if (key2 === "Enter" || key2 === " ") {
      (_a2 = props.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(props);
    }
  };
  const getTooltip = () => {
    if (props.enabled === false && props.disabledTooltip) {
      return props.disabledTooltip;
    } else if (props.pressed && props.pressedTooltip) {
      return props.pressedTooltip;
    } else {
      return props.tooltip || props.iconLabel;
    }
  };
  return React8.createElement(
    Button4,
    { appearance: "stealth", className: props.className ? props.className + " jp-ToolbarButtonComponent" : "jp-ToolbarButtonComponent", "aria-pressed": props.pressed, "aria-disabled": props.enabled === false, ...props.dataset, disabled: props.enabled === false, onClick: handleClick, onMouseDown: handleMouseDown, onKeyDown: handleKeyDown, title: getTooltip(), minimal: true },
    (props.icon || props.iconClass) && React8.createElement(LabIcon.resolveReact, { icon: props.pressed ? (_b = props.pressedIcon) !== null && _b !== void 0 ? _b : props.icon : props.icon, iconClass: (
      // add some extra classes for proper support of icons-as-css-background
      classes(props.iconClass, "jp-Icon")
    ), tag: null }),
    props.label && React8.createElement("span", { className: "jp-ToolbarButtonComponent-label" }, props.label)
  );
}
function addToolbarButtonClass(w) {
  w.addClass("jp-ToolbarButton");
  return w;
}
var React8, TOOLBAR_CLASS, TOOLBAR_ITEM_CLASS, TOOLBAR_OPENER_NAME, TOOLBAR_SPACER_CLASS, ToolbarLayout, Toolbar4, ReactiveToolbar, ToolbarButton, ToolbarPopup, ToolbarPopupOpener, Private22;
var init_toolbar5 = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/toolbar.js"() {
    init_lib4();
    init_esm3();
    init_lib();
    init_index_es619();
    init_index_es617();
    init_index_es621();
    init_index_es622();
    init_index_es618();
    init_index_es64();
    React8 = __toESM(require_react());
    init_icon2();
    init_utils2();
    init_vdom();
    provideJupyterDesignSystem().register([jpButton(), jpToolbar()]);
    addJupyterLabThemeChangeListener();
    TOOLBAR_CLASS = "jp-Toolbar";
    TOOLBAR_ITEM_CLASS = "jp-Toolbar-item";
    TOOLBAR_OPENER_NAME = "toolbar-popup-opener";
    TOOLBAR_SPACER_CLASS = "jp-Toolbar-spacer";
    ToolbarLayout = class extends PanelLayout {
      constructor() {
        super(...arguments);
        this._dirty = false;
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       *
       * If any child widget is visible, expand the toolbar height to the normal
       * toolbar height.
       */
      onFitRequest(msg) {
        super.onFitRequest(msg);
        if (this.parent.isAttached) {
          if (some2(this.widgets, (w) => !w.isHidden)) {
            this.parent.node.style.minHeight = "var(--jp-private-toolbar-height)";
            this.parent.removeClass("jp-Toolbar-micro");
          } else {
            this.parent.node.style.minHeight = "";
            this.parent.addClass("jp-Toolbar-micro");
          }
        }
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop2.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop2.sendMessage(this.parent, Widget.Msg.UpdateRequest);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        super.onUpdateRequest(msg);
        if (this.parent.isVisible) {
          this._dirty = false;
        }
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        super.onChildShown(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        super.onChildHidden(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index, widget) {
        super.attachWidget(index, widget);
        this.parent.fit();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index, widget) {
        super.detachWidget(index, widget);
        this.parent.fit();
      }
    };
    Toolbar4 = class extends Widget {
      /**
       * Construct a new toolbar widget.
       */
      constructor(options = {}) {
        var _a;
        super({ node: document.createElement("jp-toolbar") });
        this.addClass(TOOLBAR_CLASS);
        this.layout = (_a = options.layout) !== null && _a !== void 0 ? _a : new ToolbarLayout();
      }
      /**
       * Get an iterator over the ordered toolbar item names.
       *
       * @returns An iterator over the toolbar item names.
       */
      names() {
        const layout = this.layout;
        return map(layout.widgets, (widget) => {
          return Private22.nameProperty.get(widget);
        });
      }
      /**
       * Add an item to the end of the toolbar.
       *
       * @param name - The name of the widget to add to the toolbar.
       *
       * @param widget - The widget to add to the toolbar.
       *
       * @param index - The optional name of the item to insert after.
       *
       * @returns Whether the item was added to toolbar.  Returns false if
       *   an item of the same name is already in the toolbar.
       *
       * #### Notes
       * The item can be removed from the toolbar by setting its parent to `null`.
       */
      addItem(name2, widget) {
        const layout = this.layout;
        return this.insertItem(layout.widgets.length, name2, widget);
      }
      /**
       * Insert an item into the toolbar at the specified index.
       *
       * @param index - The index at which to insert the item.
       *
       * @param name - The name of the item.
       *
       * @param widget - The widget to add.
       *
       * @returns Whether the item was added to the toolbar. Returns false if
       *   an item of the same name is already in the toolbar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       * The item can be removed from the toolbar by setting its parent to `null`.
       */
      insertItem(index, name2, widget) {
        const existing = find3(this.names(), (value) => value === name2);
        if (existing) {
          return false;
        }
        widget.addClass(TOOLBAR_ITEM_CLASS);
        const layout = this.layout;
        const j = Math.max(0, Math.min(index, layout.widgets.length));
        layout.insertWidget(j, widget);
        Private22.nameProperty.set(widget, name2);
        return true;
      }
      /**
       * Insert an item into the toolbar at the after a target item.
       *
       * @param at - The target item to insert after.
       *
       * @param name - The name of the item.
       *
       * @param widget - The widget to add.
       *
       * @returns Whether the item was added to the toolbar. Returns false if
       *   an item of the same name is already in the toolbar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       * The item can be removed from the toolbar by setting its parent to `null`.
       */
      insertAfter(at, name2, widget) {
        return this.insertRelative(at, 1, name2, widget);
      }
      /**
       * Insert an item into the toolbar at the before a target item.
       *
       * @param at - The target item to insert before.
       *
       * @param name - The name of the item.
       *
       * @param widget - The widget to add.
       *
       * @returns Whether the item was added to the toolbar. Returns false if
       *   an item of the same name is already in the toolbar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       * The item can be removed from the toolbar by setting its parent to `null`.
       */
      insertBefore(at, name2, widget) {
        return this.insertRelative(at, 0, name2, widget);
      }
      /**
       * Insert an item relatively to an other item.
       */
      insertRelative(at, offset, name2, widget) {
        const nameWithIndex = map(this.names(), (name3, i) => {
          return { name: name3, index: i };
        });
        const target2 = find3(nameWithIndex, (x) => x.name === at);
        if (target2) {
          return this.insertItem(target2.index + offset, name2, widget);
        }
        return false;
      }
      /**
       * Handle the DOM events for the widget.
       *
       * @param event - The DOM event sent to the widget.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the dock panel's node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "click":
            this.handleClick(event);
            break;
          default:
            break;
        }
      }
      /**
       * Handle a DOM click event.
       */
      handleClick(event) {
        event.stopPropagation();
        if (event.target instanceof HTMLLabelElement) {
          const forId = event.target.getAttribute("for");
          if (forId && this.node.querySelector(`#${forId}`)) {
            return;
          }
        }
        if (this.node.contains(document.activeElement)) {
          return;
        }
        if (this.parent) {
          this.parent.activate();
        }
      }
      /**
       * Handle `after-attach` messages for the widget.
       */
      onAfterAttach(msg) {
        this.node.addEventListener("click", this);
      }
      /**
       * Handle `before-detach` messages for the widget.
       */
      onBeforeDetach(msg) {
        this.node.removeEventListener("click", this);
      }
    };
    ReactiveToolbar = class extends Toolbar4 {
      /**
       * Construct a new toolbar widget.
       */
      constructor() {
        super();
        this.popupOpener = new ToolbarPopupOpener();
        this._widgetWidths = /* @__PURE__ */ new Map();
        this._widgetPositions = /* @__PURE__ */ new Map();
        this._zoomChanged = true;
        this.insertItem(0, TOOLBAR_OPENER_NAME, this.popupOpener);
        this.popupOpener.hide();
        this._resizer = new Throttler(async (callTwice = false) => {
          await this._onResize(callTwice);
        }, 500);
      }
      /**
       * Dispose of the widget and its descendant widgets.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        if (this._resizer) {
          this._resizer.dispose();
        }
        super.dispose();
      }
      /**
       * Insert an item into the toolbar at the after a target item.
       *
       * @param at - The target item to insert after.
       *
       * @param name - The name of the item.
       *
       * @param widget - The widget to add.
       *
       * @returns Whether the item was added to the toolbar. Returns false if
       *   an item of the same name is already in the toolbar or if the target
       *   is the toolbar pop-up opener.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       * The item can be removed from the toolbar by setting its parent to `null`.
       */
      insertAfter(at, name2, widget) {
        if (at === TOOLBAR_OPENER_NAME) {
          return false;
        }
        return super.insertAfter(at, name2, widget);
      }
      /**
       * Insert an item relatively to an other item.
       */
      insertRelative(at, offset, name2, widget) {
        const targetPosition = this._widgetPositions.get(at);
        const position = (targetPosition !== null && targetPosition !== void 0 ? targetPosition : 0) + offset;
        return this.insertItem(position, name2, widget);
      }
      /**
       * Insert an item into the toolbar at the specified index.
       *
       * @param index - The index at which to insert the item.
       *
       * @param name - The name of the item.
       *
       * @param widget - The widget to add.
       *
       * @returns Whether the item was added to the toolbar. Returns false if
       *   an item of the same name is already in the toolbar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       * The item can be removed from the toolbar by setting its parent to `null`.
       */
      insertItem(index, name2, widget) {
        var _a;
        let status;
        if (widget instanceof ToolbarPopupOpener) {
          status = super.insertItem(index, name2, widget);
        } else {
          const j = Math.max(0, Math.min(index, this.layout.widgets.length - 1));
          status = super.insertItem(j, name2, widget);
        }
        if (name2 !== TOOLBAR_OPENER_NAME && this._widgetPositions.get(name2) !== index) {
          const currentPosition = (_a = this._widgetPositions.get(name2)) !== null && _a !== void 0 ? _a : this._widgetPositions.size;
          this._widgetPositions.forEach((value, key2) => {
            if (key2 !== TOOLBAR_OPENER_NAME) {
              if (value >= index && value < currentPosition) {
                this._widgetPositions.set(key2, value + 1);
              } else if (value <= index && value > currentPosition) {
                this._widgetPositions.set(key2, value - 1);
              }
            }
          });
          this._widgetPositions.set(name2, index);
          if (this.isVisible) {
            void this._resizer.invoke();
          }
        }
        return status;
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       *
       * Invokes resizing to ensure correct display of items.
       */
      onAfterShow(msg) {
        void this._resizer.invoke(true);
      }
      /**
       * A message handler invoked on a `'before-hide'` message.
       *
       * It will hide the pop-up panel
       */
      onBeforeHide(msg) {
        this.popupOpener.hidePopup();
        super.onBeforeHide(msg);
      }
      onResize(msg) {
        super.onResize(msg);
        const zoom = Math.round(window.outerWidth / window.innerWidth * 100);
        if (zoom !== this._zoom) {
          this._zoomChanged = true;
          this._zoom = zoom;
        }
        if (msg.width > 0 && this._resizer) {
          void this._resizer.invoke();
        }
      }
      /**
       * Move the toolbar items between the reactive toolbar and the popup toolbar,
       * depending on the width of the toolbar and the width of each item.
       *
       * @param callTwice - whether to call the function twice.
       *
       * **NOTES**
       * The `callTwice` parameter is useful when the toolbar is displayed the first time,
       * because the size of the items is unknown before their first rendering. The first
       * call will usually add all the items in the main toolbar, and the second call will
       * reorganize the items between the main toolbar and the popup toolbar.
       */
      async _onResize(callTwice = false) {
        if (!(this.parent && this.parent.isAttached)) {
          return;
        }
        const toolbarWidth = this.node.clientWidth;
        const opener = this.popupOpener;
        const openerWidth = 32;
        const toolbarPadding = 2 + 5;
        let width = opener.isHidden ? toolbarPadding : toolbarPadding + openerWidth;
        this._getWidgetsToRemove(width, toolbarWidth, openerWidth).then((values) => {
          var _a, _b;
          let { width: width2, widgetsToRemove } = values;
          while (widgetsToRemove.length > 0) {
            const widget = widgetsToRemove.pop();
            const name2 = Private22.nameProperty.get(widget);
            width2 -= this._widgetWidths.get(name2) || 0;
            const position = (_a = this._widgetPositions.get(name2)) !== null && _a !== void 0 ? _a : 0;
            let openerFirstIndex = this._widgetPositions.size;
            const openerFirst = opener.widgetAt(0);
            if (openerFirst) {
              const openerFirstName = Private22.nameProperty.get(openerFirst);
              openerFirstIndex = (_b = this._widgetPositions.get(openerFirstName)) !== null && _b !== void 0 ? _b : openerFirstIndex;
            }
            const index = position - openerFirstIndex;
            opener.insertWidget(index, widget);
          }
          if (opener.widgetCount() > 0) {
            const widgetsToAdd = [];
            let index = 0;
            const widgetCount = opener.widgetCount();
            while (index < widgetCount) {
              let widget = opener.widgetAt(index);
              if (widget) {
                width2 += this._getWidgetWidth(widget);
                if (widgetCount - widgetsToAdd.length === 1) {
                  width2 -= openerWidth;
                }
              } else {
                break;
              }
              if (width2 < toolbarWidth) {
                widgetsToAdd.push(widget);
              } else {
                break;
              }
              index++;
            }
            while (widgetsToAdd.length > 0) {
              const widget = widgetsToAdd.shift();
              const name2 = Private22.nameProperty.get(widget);
              if (this._widgetPositions.has(name2)) {
                this.insertItem(this._widgetPositions.get(name2), name2, widget);
              } else {
                this.addItem(name2, widget);
              }
            }
          }
          if (opener.widgetCount() > 0) {
            opener.updatePopup();
            opener.show();
          } else {
            opener.hide();
          }
          if (callTwice) {
            void this._onResize();
          }
        }).catch((msg) => {
          console.error("Error while computing the ReactiveToolbar", msg);
        });
      }
      async _getWidgetsToRemove(width, toolbarWidth, openerWidth) {
        var _a;
        const opener = this.popupOpener;
        const layout = this.layout;
        const toIndex = layout.widgets.length - 1;
        const widgetsToRemove = [];
        let index = 0;
        while (index < toIndex) {
          const widget = layout.widgets[index];
          const name2 = Private22.nameProperty.get(widget);
          let widgetWidth;
          if (this._zoomChanged) {
            widgetWidth = await this._saveWidgetWidth(name2, widget);
          } else {
            widgetWidth = this._getWidgetWidth(widget) || await this._saveWidgetWidth(name2, widget);
          }
          width += widgetWidth;
          if (widgetsToRemove.length === 0 && opener.isHidden && width + openerWidth > toolbarWidth) {
            width += openerWidth;
          }
          if (width > toolbarWidth || ((_a = this._widgetPositions.get(name2)) !== null && _a !== void 0 ? _a : 0) > index) {
            widgetsToRemove.push(widget);
          }
          index++;
        }
        this._zoomChanged = false;
        return {
          width,
          widgetsToRemove
        };
      }
      async _saveWidgetWidth(name2, widget) {
        if (widget instanceof ReactWidget) {
          await widget.renderPromise;
        }
        const widgetWidth = widget.hasClass(TOOLBAR_SPACER_CLASS) ? 2 : widget.node.clientWidth;
        this._widgetWidths.set(name2, widgetWidth);
        return widgetWidth;
      }
      _getWidgetWidth(widget) {
        const widgetName = Private22.nameProperty.get(widget);
        return this._widgetWidths.get(widgetName) || 0;
      }
    };
    (function(Toolbar7) {
      function createSpacerItem() {
        return new Private22.Spacer();
      }
      Toolbar7.createSpacerItem = createSpacerItem;
    })(Toolbar4 || (Toolbar4 = {}));
    ToolbarButton = class extends ReactWidget {
      /**
       * Creates a toolbar button
       * @param props props for underlying `ToolbarButton` component
       */
      constructor(props = {}) {
        var _a, _b;
        super();
        this.props = props;
        addToolbarButtonClass(this);
        this._enabled = (_a = props.enabled) !== null && _a !== void 0 ? _a : true;
        this._pressed = this._enabled && ((_b = props.pressed) !== null && _b !== void 0 ? _b : false);
        this._onClick = props.onClick;
      }
      /**
       * Sets the pressed state for the button
       * @param value true if button is pressed, false otherwise
       */
      set pressed(value) {
        if (this.enabled && value !== this._pressed) {
          this._pressed = value;
          this.update();
        }
      }
      /**
       * Returns true if button is pressed, false otherwise
       */
      get pressed() {
        return this._pressed;
      }
      /**
       * Sets the enabled state for the button
       * @param value true to enable the button, false otherwise
       */
      set enabled(value) {
        if (value != this._enabled) {
          this._enabled = value;
          if (!this._enabled) {
            this._pressed = false;
          }
          this.update();
        }
      }
      /**
       * Returns true if button is enabled, false otherwise
       */
      get enabled() {
        return this._enabled;
      }
      /**
       * Sets the click handler for the button
       * @param value click handler
       */
      set onClick(value) {
        if (value !== this._onClick) {
          this._onClick = value;
          this.update();
        }
      }
      /**
       * Returns the click handler for the button
       */
      get onClick() {
        return this._onClick;
      }
      render() {
        return React8.createElement(ToolbarButtonComponent, { ...this.props, pressed: this.pressed, enabled: this.enabled, onClick: this.onClick });
      }
    };
    ToolbarPopup = class extends Widget {
      /**
       *  Construct a new ToolbarPopup
       */
      constructor() {
        super({ node: document.createElement("jp-toolbar") });
        this.width = 0;
        this.addClass("jp-Toolbar");
        this.addClass("jp-Toolbar-responsive-popup");
        this.layout = new PanelLayout();
        Widget.attach(this, document.body);
        this.hide();
      }
      /**
       * Updates the width of the popup, this
       * should match with the toolbar width
       *
       * @param width - The width to resize to
       * @protected
       */
      updateWidth(width) {
        if (width > 0) {
          this.width = width;
          this.node.style.width = `${width}px`;
        }
      }
      /**
       * Aligns the popup to left bottom of widget
       *
       * @param widget the widget to align to
       * @private
       */
      alignTo(widget) {
        const { height: widgetHeight, width: widgetWidth, x: widgetX, y: widgetY } = widget.node.getBoundingClientRect();
        const width = this.width;
        this.node.style.left = `${widgetX + widgetWidth - width + 1}px`;
        this.node.style.top = `${widgetY + widgetHeight + 1}px`;
      }
      /**
       * Inserts the widget at specified index
       * @param index the index
       * @param widget widget to add
       */
      insertWidget(index, widget) {
        this.layout.insertWidget(index, widget);
      }
      /**
       *  Total number of widgets in the popup
       */
      widgetCount() {
        return this.layout.widgets.length;
      }
      /**
       * Returns the widget at index
       * @param index the index
       */
      widgetAt(index) {
        return this.layout.widgets[index];
      }
    };
    ToolbarPopupOpener = class extends ToolbarButton {
      /**
       *  Create a new popup opener
       */
      constructor(props = {}) {
        const trans = (props.translator || nullTranslator).load("jupyterlab");
        super({
          icon: ellipsesIcon,
          onClick: () => {
            this.handleClick();
          },
          tooltip: trans.__("More commands")
        });
        this.addClass("jp-Toolbar-responsive-opener");
        this.popup = new ToolbarPopup();
      }
      /**
       * Add widget to the popup, prepends widgets
       * @param widget the widget to add
       */
      addWidget(widget) {
        this.popup.insertWidget(0, widget);
      }
      /**
       * Insert widget to the popup.
       * @param widget the widget to add
       */
      insertWidget(index, widget) {
        this.popup.insertWidget(index, widget);
      }
      /**
       * Dispose of the widget and its descendant widgets.
       *
       * #### Notes
       * It is unsafe to use the widget after it has been disposed.
       *
       * All calls made to this method after the first are a no-op.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this.popup.dispose();
        super.dispose();
      }
      /**
       * Hides the opener and the popup
       */
      hide() {
        super.hide();
        this.hidePopup();
      }
      /**
       * Hides the popup
       */
      hidePopup() {
        this.popup.hide();
      }
      /**
       *  Updates width and position of the popup
       *  to align with the toolbar
       */
      updatePopup() {
        this.popup.updateWidth(this.parent.node.clientWidth);
        this.popup.alignTo(this.parent);
      }
      /**
       * Returns widget at index in the popup
       * @param index
       */
      widgetAt(index) {
        return this.popup.widgetAt(index);
      }
      /**
       * Returns total number of widgets in the popup
       *
       * @returns Number of widgets
       */
      widgetCount() {
        return this.popup.widgetCount();
      }
      handleClick() {
        this.updatePopup();
        this.popup.setHidden(!this.popup.isHidden);
      }
    };
    (function(Private36) {
      function propsFromCommand(options) {
        var _a, _b;
        const { commands, id, args } = options;
        const iconClass = commands.iconClass(id, args);
        const iconLabel = commands.iconLabel(id, args);
        const icon = (_a = options.icon) !== null && _a !== void 0 ? _a : commands.icon(id, args);
        const label = commands.label(id, args);
        let className = commands.className(id, args);
        let pressed;
        if (commands.isToggleable(id, args)) {
          pressed = commands.isToggled(id, args);
          if (pressed) {
            className += " lm-mod-toggled";
          }
        }
        if (!commands.isVisible(id, args)) {
          className += " lm-mod-hidden";
        }
        const labelOverride = typeof options.label === "function" ? options.label(args !== null && args !== void 0 ? args : {}) : options.label;
        let tooltip = commands.caption(id, args) || labelOverride || label || iconLabel;
        const binding = commands.keyBindings.find((b) => b.command === id);
        if (binding) {
          const ks = binding.keys.map(CommandRegistry.formatKeystroke).join(", ");
          tooltip = `${tooltip} (${ks})`;
        }
        const onClick = () => {
          void commands.execute(id, args);
        };
        const enabled = commands.isEnabled(id, args);
        return {
          className,
          dataset: { "data-command": options.id },
          icon,
          iconClass,
          tooltip: (_b = options.caption) !== null && _b !== void 0 ? _b : tooltip,
          onClick,
          enabled,
          label: labelOverride !== null && labelOverride !== void 0 ? labelOverride : label,
          pressed
        };
      }
      Private36.propsFromCommand = propsFromCommand;
      Private36.nameProperty = new AttachedProperty3({
        name: "name",
        create: () => ""
      });
      class Spacer extends Widget {
        /**
         * Construct a new spacer widget.
         */
        constructor() {
          super();
          this.addClass(TOOLBAR_SPACER_CLASS);
        }
      }
      Private36.Spacer = Spacer;
    })(Private22 || (Private22 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/panelwithtoolbar.js
var init_panelwithtoolbar = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/panelwithtoolbar.js"() {
    init_index_es618();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/search.js
var import_react26;
var init_search6 = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/search.js"() {
    init_index_es619();
    import_react26 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/sidepanel.js
var init_sidepanel = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/sidepanel.js"() {
    init_lib();
    init_index_es618();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/spinner.js
var Spinner;
var init_spinner = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/spinner.js"() {
    init_index_es618();
    Spinner = class extends Widget {
      /**
       * Construct a spinner widget.
       */
      constructor() {
        super();
        this.addClass("jp-Spinner");
        this.node.tabIndex = -1;
        const content = document.createElement("div");
        content.className = "jp-SpinnerContent";
        this.node.appendChild(content);
      }
      /**
       * Handle `'activate-request'` messages.
       */
      onActivateRequest(msg) {
        this.node.focus();
      }
    };
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/styling.js
var Styling, Private23;
var init_styling = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/styling.js"() {
    init_icon2();
    (function(Styling2) {
      function styleNode(node, className = "") {
        styleNodeByTag(node, "select", className);
        styleNodeByTag(node, "textarea", className);
        styleNodeByTag(node, "input", className);
        styleNodeByTag(node, "button", className);
      }
      Styling2.styleNode = styleNode;
      function styleNodeByTag(node, tagName, className = "") {
        if (node.localName === tagName) {
          node.classList.add("jp-mod-styled");
        }
        if (node.localName === "select") {
          const multiple = node.hasAttribute("multiple");
          wrapSelect(node, multiple);
        }
        const nodes = node.getElementsByTagName(tagName);
        for (let i = 0; i < nodes.length; i++) {
          const child = nodes[i];
          child.classList.add("jp-mod-styled");
          if (className) {
            child.classList.add(className);
          }
          if (tagName === "select") {
            const multiple = child.hasAttribute("multiple");
            wrapSelect(child, multiple);
          }
        }
      }
      Styling2.styleNodeByTag = styleNodeByTag;
      function wrapSelect(node, multiple) {
        const wrapper = document.createElement("div");
        wrapper.classList.add("jp-select-wrapper");
        node.addEventListener("focus", Private23.onFocus);
        node.addEventListener("blur", Private23.onFocus);
        node.classList.add("jp-mod-styled");
        if (node.parentElement) {
          node.parentElement.replaceChild(wrapper, node);
        }
        wrapper.appendChild(node);
        if (multiple) {
          wrapper.classList.add("multiple");
        } else {
          wrapper.appendChild(caretDownEmptyIcon.element({
            tag: "span",
            stylesheet: "select",
            right: "8px",
            top: "5px",
            width: "18px"
          }));
        }
        return wrapper;
      }
      Styling2.wrapSelect = wrapSelect;
    })(Styling || (Styling = {}));
    (function(Private36) {
      function onFocus(event) {
        const target2 = event.target;
        const parent = target2.parentElement;
        if (!parent) {
          return;
        }
        if (event.type === "focus") {
          parent.classList.add("jp-mod-focused");
        } else {
          parent.classList.remove("jp-mod-focused");
        }
      }
      Private36.onFocus = onFocus;
    })(Private23 || (Private23 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/switch.js
var init_switch5 = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/switch.js"() {
    init_index_es63();
    init_index_es618();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/table.js
var import_react27;
var init_table = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/table.js"() {
    import_react27 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/windowedlist.js
var import_coreutils9, MAXIMUM_TIME_REMAINING, passiveIfSupported, WindowedList, WindowedLayout;
var init_windowedlist = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/windowedlist.js"() {
    init_index_es619();
    import_coreutils9 = __toESM(require_dist());
    init_index_es621();
    init_index_es64();
    init_index_es63();
    init_index_es618();
    MAXIMUM_TIME_REMAINING = 100;
    passiveIfSupported = false;
    try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", {
        get: function() {
          passiveIfSupported = { passive: true };
        }
      }));
    } catch (err) {
    }
    WindowedList = class extends Widget {
      /**
       * Constructor
       *
       * @param options Constructor options
       */
      constructor(options) {
        var _a, _b;
        const renderer = (_a = options.renderer) !== null && _a !== void 0 ? _a : WindowedList.defaultRenderer;
        const node = document.createElement("div");
        node.className = "jp-WindowedPanel";
        const scrollbarElement = node.appendChild(document.createElement("div"));
        scrollbarElement.classList.add("jp-WindowedPanel-scrollbar");
        const list = scrollbarElement.appendChild(renderer.createScrollbar());
        list.classList.add("jp-WindowedPanel-scrollbar-content");
        const outerElement = node.appendChild(renderer.createOuter());
        outerElement.classList.add("jp-WindowedPanel-outer");
        const innerElement = outerElement.appendChild(document.createElement("div"));
        innerElement.className = "jp-WindowedPanel-inner";
        const viewport = innerElement.appendChild(renderer.createViewport());
        viewport.classList.add("jp-WindowedPanel-viewport");
        super({ node });
        this.jumped = new Signal(this);
        this._needsUpdate = false;
        super.layout = (_b = options.layout) !== null && _b !== void 0 ? _b : new WindowedLayout();
        this.renderer = renderer;
        this._innerElement = innerElement;
        this._isScrolling = null;
        this._outerElement = outerElement;
        this._itemsResizeObserver = null;
        this._scrollbarElement = scrollbarElement;
        this._scrollToItem = null;
        this._scrollRepaint = null;
        this._scrollUpdateWasRequested = false;
        this._updater = new Throttler(() => this.update(), 50);
        this._viewModel = options.model;
        this._viewport = viewport;
        if (options.scrollbar) {
          node.classList.add("jp-mod-virtual-scrollbar");
        }
        this.viewModel.stateChanged.connect(this.onStateChanged, this);
      }
      /**
       * Whether the parent is hidden or not.
       *
       * This should be set externally if a container is hidden to
       * stop updating the widget size when hidden.
       */
      get isParentHidden() {
        return this._isParentHidden;
      }
      set isParentHidden(v) {
        this._isParentHidden = v;
      }
      /**
       * Widget layout
       */
      get layout() {
        return super.layout;
      }
      /**
       * The outer container of the windowed list.
       */
      get outerNode() {
        return this._outerElement;
      }
      /**
       * Viewport
       */
      get viewportNode() {
        return this._viewport;
      }
      /**
       * Flag to enable virtual scrollbar.
       */
      get scrollbar() {
        return this.node.classList.contains("jp-mod-virtual-scrollbar");
      }
      set scrollbar(enabled) {
        if (enabled) {
          this.node.classList.add("jp-mod-virtual-scrollbar");
        } else {
          this.node.classList.remove("jp-mod-virtual-scrollbar");
        }
        this._adjustDimensionsForScrollbar();
        this.update();
      }
      /**
       * Windowed list view model
       */
      get viewModel() {
        return this._viewModel;
      }
      /**
       * Dispose the windowed list.
       */
      dispose() {
        this._updater.dispose();
        super.dispose();
      }
      /**
       * Callback on event.
       *
       * @param event Event
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointerdown":
            event.preventDefault();
            event.stopPropagation();
            this._evtPointerDown(event);
            break;
          case "scroll":
            this.onScroll(event);
            break;
        }
      }
      /**
       * Scroll to the specified offset `scrollTop`.
       *
       * @param scrollOffset Offset to scroll
       *
       * @deprecated since v4 This is an internal helper. Prefer calling `scrollToItem`.
       */
      scrollTo(scrollOffset) {
        if (!this.viewModel.windowingActive) {
          this._outerElement.scrollTo({ top: scrollOffset });
          return;
        }
        scrollOffset = Math.max(0, scrollOffset);
        if (scrollOffset !== this.viewModel.scrollOffset) {
          this.viewModel.scrollOffset = scrollOffset;
          this._scrollUpdateWasRequested = true;
          this.update();
        }
      }
      /**
       * Scroll to the specified item.
       *
       * By default, the list will scroll as little as possible to ensure the item is fully visible (`auto`).
       * You can control the alignment of the item though by specifying a second alignment parameter.
       * Acceptable values are:
       *
       *   auto - Automatically align with the top or bottom minimising the amount scrolled,
       *          If `alignPreference` is given, follow such preferred alignment.
       *          If item is smaller than the viewport and fully visible, do not scroll at all.
       *   smart - If the item is significantly visible, don't scroll at all (regardless of whether it fits in the viewport).
       *           If the item is less than one viewport away, scroll so that it becomes fully visible (following the `auto` heuristics).
       *           If the item is more than one viewport away, scroll so that it is centered within the viewport (`center` if smaller than viewport, `top-center` otherwise).
       *   center - Align the middle of the item with the middle of the viewport (it only works well for items smaller than the viewport).
       *   top-center - Align the top of the item with the middle of the viewport (works well for items larger than the viewport).
       *   end - Align the bottom of the item to the bottom of the list.
       *   start - Align the top of item to the top of the list.
       *
       * @param index Item index to scroll to
       * @param align Type of alignment
       * @param margin In 'smart' mode the viewport proportion to add
       * @param alignPreference Allows to override the alignment of item when the `auto` heuristic decides that the item needs to be scrolled into view.
       */
      scrollToItem(index, align = "auto", margin = 0.25, alignPreference) {
        if (!this._isScrolling || this._scrollToItem === null || this._scrollToItem[0] !== index || this._scrollToItem[1] !== align) {
          if (this._isScrolling) {
            this._isScrolling.reject("Scrolling to a new item is requested.");
          }
          this._isScrolling = new import_coreutils9.PromiseDelegate();
          this._isScrolling.promise.catch(console.debug);
        }
        this._scrollToItem = [index, align, margin, alignPreference];
        this._resetScrollToItem();
        let precomputed = void 0;
        if (!this.viewModel.windowingActive) {
          const item = this._innerElement.querySelector(`[data-windowed-list-index="${index}"]`);
          if (!item || !(item instanceof HTMLElement)) {
            console.debug(`Element with index ${index} not found`);
            return Promise.resolve();
          }
          precomputed = {
            totalSize: this._outerElement.scrollHeight,
            itemMetadata: {
              offset: item.offsetTop,
              size: item.clientHeight
            },
            currentOffset: this._outerElement.scrollTop
          };
        }
        this.scrollTo(this.viewModel.getOffsetForIndexAndAlignment(Math.max(0, Math.min(index, this.viewModel.widgetCount - 1)), align, margin, precomputed, alignPreference));
        return this._isScrolling.promise;
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        super.onAfterAttach(msg);
        if (this.viewModel.windowingActive) {
          this._applyWindowingStyles();
        } else {
          this._applyNoWindowingStyles();
        }
        this._addListeners();
        this.viewModel.height = this.node.getBoundingClientRect().height;
        const style = window.getComputedStyle(this._viewport);
        this.viewModel.paddingTop = parseFloat(style.paddingTop);
        this._scrollbarElement.addEventListener("pointerdown", this);
      }
      /**
       * A message handler invoked on an `'before-detach'` message.
       */
      onBeforeDetach(msg) {
        this._removeListeners();
        this._scrollbarElement.removeEventListener("pointerdown", this);
        super.onBeforeDetach(msg);
      }
      /**
       * Callback on scroll event
       *
       * @param event Scroll event
       */
      onScroll(event) {
        const { clientHeight, scrollHeight, scrollTop } = event.currentTarget;
        if (!this._scrollUpdateWasRequested && Math.abs(this.viewModel.scrollOffset - scrollTop) > 1) {
          const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
          this.viewModel.scrollOffset = scrollOffset;
          this._scrollUpdateWasRequested = false;
          this.update();
        }
      }
      /**
       * A message handler invoked on an `'resize-request'` message.
       */
      onResize(msg) {
        const previousHeight = this.viewModel.height;
        this.viewModel.height = msg.height >= 0 ? msg.height : this.node.getBoundingClientRect().height;
        if (this.viewModel.height !== previousHeight) {
          void this._updater.invoke();
        }
        super.onResize(msg);
        void this._updater.invoke();
      }
      /**
       * Callback on view model change
       *
       * @param model Windowed list model
       * @param changes Change
       */
      onStateChanged(model, changes) {
        switch (changes.name) {
          case "windowingActive":
            this._removeListeners();
            if (this.viewModel.windowingActive) {
              this._applyWindowingStyles();
              this.onScroll({ currentTarget: this.node });
              this._addListeners();
              return;
            } else {
              this._applyNoWindowingStyles();
              this._addListeners();
            }
            break;
        }
        this.update();
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onUpdateRequest(msg) {
        if (this.scrollbar) {
          this._renderScrollbar();
        }
        if (this.viewModel.windowingActive) {
          if (this._scrollRepaint === null) {
            this._needsUpdate = false;
            this._scrollRepaint = window.requestAnimationFrame(() => {
              this._scrollRepaint = null;
              this._update();
              if (this._needsUpdate) {
                this.update();
              }
            });
          } else {
            this._needsUpdate = true;
          }
        } else {
          this._update();
        }
      }
      /*
       * Hide the native scrollbar if necessary and update dimensions
       */
      _adjustDimensionsForScrollbar() {
        const outer = this._outerElement;
        const scrollbar = this._scrollbarElement;
        if (this.scrollbar) {
          let outerScrollbarWidth = outer.offsetWidth - outer.clientWidth;
          if (outerScrollbarWidth == 0) {
            outerScrollbarWidth = 1e3;
            outer.style.paddingRight = `${outerScrollbarWidth}px`;
            outer.style.boxSizing = "border-box";
          } else {
            outer.style.paddingRight = "0";
          }
          outer.style.width = `calc(100% + ${outerScrollbarWidth}px)`;
          this._innerElement.style.marginRight = `${scrollbar.offsetWidth}px`;
        } else {
          outer.style.width = "100%";
          this._innerElement.style.marginRight = "0";
          outer.style.paddingRight = "0";
          outer.style.boxSizing = "";
        }
      }
      /**
       * Add listeners for viewport, contents and the virtual scrollbar.
       */
      _addListeners() {
        if (this.viewModel.windowingActive) {
          if (!this._itemsResizeObserver) {
            this._itemsResizeObserver = new ResizeObserver(this._onItemResize.bind(this));
          }
          for (const widget of this.layout.widgets) {
            this._itemsResizeObserver.observe(widget.node);
            widget.disposed.connect(() => {
              var _a;
              return (_a = this._itemsResizeObserver) === null || _a === void 0 ? void 0 : _a.unobserve(widget.node);
            });
          }
          this._outerElement.addEventListener("scroll", this, passiveIfSupported);
          this._scrollbarResizeObserver = new ResizeObserver(this._adjustDimensionsForScrollbar.bind(this));
          this._scrollbarResizeObserver.observe(this._outerElement);
          this._scrollbarResizeObserver.observe(this._scrollbarElement);
        } else {
          if (!this._areaResizeObserver) {
            this._areaResizeObserver = new ResizeObserver(this._onAreaResize.bind(this));
            this._areaResizeObserver.observe(this._innerElement);
          }
        }
      }
      /**
       * Turn off windowing related styles in the viewport.
       */
      _applyNoWindowingStyles() {
        this._viewport.style.position = "relative";
        this._viewport.style.top = "0px";
      }
      /**
       * Turn on windowing related styles in the viewport.
       */
      _applyWindowingStyles() {
        this._viewport.style.position = "absolute";
      }
      /**
       * Remove listeners for viewport and contents (but not the virtual scrollbar).
       */
      _removeListeners() {
        var _a, _b, _c;
        this._outerElement.removeEventListener("scroll", this);
        (_a = this._areaResizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
        this._areaResizeObserver = null;
        (_b = this._itemsResizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        this._itemsResizeObserver = null;
        (_c = this._scrollbarResizeObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
        this._scrollbarResizeObserver = null;
      }
      /**
       * Update viewport and DOM state.
       */
      _update() {
        var _a;
        if (this.isDisposed || !this.layout) {
          return;
        }
        const newWindowIndex = this.viewModel.getRangeToRender();
        if (newWindowIndex !== null) {
          const [startIndex, stopIndex] = newWindowIndex;
          const toAdd = [];
          if (stopIndex >= 0) {
            for (let index = startIndex; index <= stopIndex; index++) {
              const widget = this.viewModel.widgetRenderer(index);
              widget.dataset.windowedListIndex = `${index}`;
              toAdd.push(widget);
            }
          }
          const nWidgets = this.layout.widgets.length;
          for (let itemIdx = nWidgets - 1; itemIdx >= 0; itemIdx--) {
            if (!toAdd.includes(this.layout.widgets[itemIdx])) {
              (_a = this._itemsResizeObserver) === null || _a === void 0 ? void 0 : _a.unobserve(this.layout.widgets[itemIdx].node);
              this.layout.removeWidget(this.layout.widgets[itemIdx]);
            }
          }
          for (let index = 0; index < toAdd.length; index++) {
            const item = toAdd[index];
            if (this._itemsResizeObserver && !this.layout.widgets.includes(item)) {
              this._itemsResizeObserver.observe(item.node);
              item.disposed.connect(() => {
                var _a2;
                return (_a2 = this._itemsResizeObserver) === null || _a2 === void 0 ? void 0 : _a2.unobserve(item.node);
              });
            }
            this.layout.insertWidget(index, item);
          }
          if (this.viewModel.windowingActive) {
            if (stopIndex >= 0) {
              const estimatedTotalHeight = this.viewModel.getEstimatedTotalSize();
              this._innerElement.style.height = `${estimatedTotalHeight}px`;
              const [top, minHeight] = this.viewModel.getSpan(startIndex, stopIndex);
              this._viewport.style.top = `${top}px`;
              this._viewport.style.minHeight = `${minHeight}px`;
            } else {
              this._innerElement.style.height = `0px`;
              this._viewport.style.top = `0px`;
              this._viewport.style.minHeight = `0px`;
            }
            if (this._scrollUpdateWasRequested) {
              this._outerElement.scrollTop = this.viewModel.scrollOffset;
              this._scrollUpdateWasRequested = false;
            }
          }
        }
        let index2 = -1;
        for (const w of this._viewport.children) {
          const currentIdx = parseInt(w.dataset.windowedListIndex, 10);
          if (currentIdx < index2) {
            throw new Error("Inconsistent dataset index");
          } else {
            index2 = currentIdx;
          }
        }
      }
      /**
       * Handle viewport area resize.
       */
      _onAreaResize(_entries) {
        this._scrollBackToItemOnResize();
      }
      /**
       * Handle viewport content (i.e. items) resize.
       */
      _onItemResize(entries) {
        this._resetScrollToItem();
        if (this.isHidden || this.isParentHidden) {
          return;
        }
        const newSizes = [];
        for (let entry of entries) {
          if (entry.target.isConnected) {
            newSizes.push({
              index: parseInt(entry.target.dataset.windowedListIndex, 10),
              size: entry.borderBoxSize[0].blockSize
            });
          }
        }
        if (this.viewModel.setWidgetSize(newSizes)) {
          this._scrollBackToItemOnResize();
          this.update();
        }
      }
      /**
       * Scroll to the item which was most recently requested.
       *
       * This method ensures that the app scrolls to the item even if a resize event
       * occurs shortly after the scroll. Consider the following sequence of events:
       *
       * 1. User is at the nth cell, presses Shift+Enter (run current cell and
       *    advance to next)
       * 2. App scrolls to the next (n+1) cell
       * 3. The nth cell finishes running and renders the output, pushing the
       *    (n+1) cell down out of view
       * 4. This triggers the resize observer, which calls this method and scrolls
       *    the (n+1) cell back into view
       *
       * On implementation level, this is ensured by scrolling to `this._scrollToItem`
       * which is cleared after a short timeout once the scrolling settles
       * (see `this._resetScrollToItem()`).
       */
      _scrollBackToItemOnResize() {
        if (!this._scrollToItem) {
          return;
        }
        this.scrollToItem(...this._scrollToItem).catch((reason) => {
          console.log(reason);
        });
      }
      /**
       * Clear any outstanding timeout and enqueue scrolling to a new item.
       */
      _resetScrollToItem() {
        if (this._resetScrollToItemTimeout) {
          clearTimeout(this._resetScrollToItemTimeout);
        }
        if (this._scrollToItem) {
          this._resetScrollToItemTimeout = window.setTimeout(() => {
            this._scrollToItem = null;
            if (this._isScrolling) {
              this._isScrolling.resolve();
              this._isScrolling = null;
            }
          }, MAXIMUM_TIME_REMAINING);
        }
      }
      /**
       * Render virtual scrollbar.
       */
      _renderScrollbar() {
        var _a, _b;
        const { node, renderer, viewModel } = this;
        const content = node.querySelector(".jp-WindowedPanel-scrollbar-content");
        while (content.firstChild) {
          content.removeChild(content.firstChild);
        }
        const list = viewModel.itemsList;
        const count = (_a = list === null || list === void 0 ? void 0 : list.length) !== null && _a !== void 0 ? _a : viewModel.widgetCount;
        for (let index = 0; index < count; index += 1) {
          const item = (_b = list === null || list === void 0 ? void 0 : list.get) === null || _b === void 0 ? void 0 : _b.call(list, index);
          const element = renderer.createScrollbarItem(this, index, item);
          element.classList.add("jp-WindowedPanel-scrollbar-item");
          element.dataset.index = `${index}`;
          content.appendChild(element);
        }
      }
      /**
       * Handle `pointerdown` events on the virtual scrollbar.
       */
      _evtPointerDown(event) {
        let target2 = event.target;
        while (target2 && target2.parentElement) {
          if (target2.hasAttribute("data-index")) {
            const index = parseInt(target2.getAttribute("data-index"), 10);
            return void (async () => {
              await this.scrollToItem(index);
              this.jumped.emit(index);
            })();
          }
          target2 = target2.parentElement;
        }
      }
    };
    WindowedList.DEFAULT_WIDGET_SIZE = 50;
    WindowedLayout = class extends PanelLayout {
      /**
       * Constructor
       */
      constructor() {
        super({ fitPolicy: "set-no-constraint" });
      }
      /**
       * Specialized parent type definition
       */
      get parent() {
        return super.parent;
      }
      set parent(value) {
        super.parent = value;
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation adds the widgets's node to the parent's
       * node at the proper location, and sends the appropriate attach
       * messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is added to the parent's node.
       */
      attachWidget(index, widget) {
        let ref2 = this.parent.viewportNode.children[index];
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.viewportNode.insertBefore(widget.node, ref2);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget.Msg.AfterAttach);
        }
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation removes the widget's node from the
       * parent's node, and sends the appropriate detach messages to the
       * widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is removed from the parent's node.
       */
      detachWidget(index, widget) {
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.viewportNode.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget.Msg.AfterDetach);
        }
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation moves the widget's node to the proper
       * location in the parent's node and sends the appropriate attach and
       * detach messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is moved in the parent's node.
       */
      moveWidget(fromIndex, toIndex, widget) {
        let ref2 = this.parent.viewportNode.children[toIndex];
        if (fromIndex < toIndex) {
          ref2.insertAdjacentElement("afterend", widget.node);
        } else {
          ref2.insertAdjacentElement("beforebegin", widget.node);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * This is a reimplementation of the base class method,
       * and is a no-op.
       */
      onUpdateRequest(msg) {
      }
    };
    (function(WindowedList2) {
      class Renderer {
        /**
         * Create the outer, root element of the windowed list.
         */
        createOuter() {
          return document.createElement("div");
        }
        /**
         * Create the virtual scrollbar element.
         */
        createScrollbar() {
          return document.createElement("ol");
        }
        /**
         * Create an individual item rendered in the scrollbar.
         */
        createScrollbarItem(_, index) {
          const li = document.createElement("li");
          li.appendChild(document.createTextNode(`${index}`));
          return li;
        }
        /**
         * Create the viewport element into which virtualized children are added.
         */
        createViewport() {
          return document.createElement("div");
        }
      }
      WindowedList2.Renderer = Renderer;
      WindowedList2.defaultRenderer = new Renderer();
    })(WindowedList || (WindowedList = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/index.js
var init_components = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/index.js"() {
    init_button();
    init_collapser();
    init_form();
    init_htmlselect();
    init_iframe();
    init_inputgroup();
    init_interface();
    init_menu();
    init_panelwithtoolbar();
    init_search6();
    init_sidepanel();
    init_spinner();
    init_styling();
    init_switch5();
    init_table();
    init_toolbar5();
    init_vdom();
    init_windowedlist();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/hoverbox.js
var HOVERBOX_CLASS, OUTOFVIEW_Z_INDEX, HoverBox;
var init_hoverbox = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/hoverbox.js"() {
    HOVERBOX_CLASS = "jp-HoverBox";
    OUTOFVIEW_Z_INDEX = "-1000";
    (function(HoverBox2) {
      function setGeometry(options) {
        const { anchor, host, node, privilege, outOfViewDisplay } = options;
        const hostRect = host.getBoundingClientRect();
        if (!node.classList.contains(HOVERBOX_CLASS)) {
          node.classList.add(HOVERBOX_CLASS);
        }
        if (node.style.visibility) {
          node.style.visibility = "";
        }
        if (node.style.zIndex === "") {
          node.style.zIndex = "";
        }
        node.style.maxHeight = "";
        node.style.marginTop = "";
        const style = options.style || window.getComputedStyle(node);
        const spaceAbove = anchor.top - hostRect.top;
        const spaceBelow = hostRect.bottom - anchor.bottom;
        const marginTop = parseInt(style.marginTop, 10) || 0;
        const marginLeft = parseInt(style.marginLeft, 10) || 0;
        const minHeight = parseInt(style.minHeight, 10) || options.minHeight;
        let maxHeight = parseInt(style.maxHeight, 10) || options.maxHeight;
        const renderBelow = privilege === "forceAbove" ? false : privilege === "forceBelow" ? true : privilege === "above" ? spaceAbove < maxHeight && spaceAbove < spaceBelow : spaceBelow >= maxHeight || spaceBelow >= spaceAbove;
        if (renderBelow) {
          maxHeight = Math.min(spaceBelow - marginTop, maxHeight);
        } else {
          maxHeight = Math.min(spaceAbove, maxHeight);
          node.style.marginTop = "0px";
        }
        node.style.maxHeight = `${maxHeight}px`;
        const withinBounds = maxHeight >= minHeight && (spaceBelow >= minHeight || spaceAbove >= minHeight);
        if (!withinBounds) {
          node.style.zIndex = OUTOFVIEW_Z_INDEX;
          node.style.visibility = "hidden";
          return;
        }
        if (options.size) {
          node.style.width = `${options.size.width}px`;
          node.style.height = `${options.size.height}px`;
          node.style.contain = "strict";
        } else {
          node.style.contain = "";
          node.style.width = "auto";
          node.style.height = "";
        }
        const initialHeight = options.size ? options.size.height : node.getBoundingClientRect().height;
        const offsetAbove = options.offset && options.offset.vertical && options.offset.vertical.above || 0;
        const offsetBelow = options.offset && options.offset.vertical && options.offset.vertical.below || 0;
        let top = renderBelow ? hostRect.bottom - spaceBelow + offsetBelow : hostRect.top + spaceAbove - initialHeight + offsetAbove;
        node.style.top = `${Math.floor(top)}px`;
        const offsetHorizontal = options.offset && options.offset.horizontal || 0;
        let left = anchor.left + offsetHorizontal;
        node.style.left = `${Math.ceil(left)}px`;
        let rect = node.getBoundingClientRect();
        let right = rect.right;
        if (right > window.innerWidth) {
          left -= right - window.innerWidth;
          right = window.innerWidth;
          node.style.left = `${Math.ceil(left)}px`;
        }
        if (left < offsetHorizontal - marginLeft) {
          left = offsetHorizontal - marginLeft;
          node.style.left = `${Math.ceil(left)}px`;
        }
        node.style.zIndex = "-1000";
        const bottom = rect.bottom;
        const includesLeftTop = host.contains(document.elementFromPoint(left, top));
        const includesRightTop = host.contains(document.elementFromPoint(right, top));
        const includesRightBottom = host.contains(document.elementFromPoint(right, bottom));
        const includesLeftBottom = host.contains(document.elementFromPoint(left, bottom));
        node.style.zIndex = "";
        const topEdgeInside = includesLeftTop || includesRightTop;
        const bottomEdgeInside = includesLeftBottom || includesRightBottom;
        const leftEdgeInside = includesLeftTop || includesLeftBottom;
        const rightEdgeInside = includesRightBottom || includesRightTop;
        const height = bottom - top;
        const width = right - left;
        const overTheTop = top < hostRect.top;
        const belowTheBottom = bottom > hostRect.bottom;
        const beforeTheLeft = left + marginLeft < hostRect.left;
        const afterTheRight = right > hostRect.right;
        let hide = false;
        let leftChanged = false;
        let topChanged = false;
        if (overTheTop) {
          switch ((outOfViewDisplay === null || outOfViewDisplay === void 0 ? void 0 : outOfViewDisplay.top) || "hidden-inside") {
            case "hidden-inside":
              if (!topEdgeInside) {
                hide = true;
              }
              break;
            case "hidden-outside":
              if (!bottomEdgeInside) {
                hide = true;
              }
              break;
            case "stick-inside":
              if (hostRect.top > top) {
                top = hostRect.top;
                topChanged = true;
              }
              break;
            case "stick-outside":
              if (hostRect.top > bottom) {
                top = hostRect.top - height;
                topChanged = true;
              }
              break;
          }
        }
        if (belowTheBottom) {
          switch ((outOfViewDisplay === null || outOfViewDisplay === void 0 ? void 0 : outOfViewDisplay.bottom) || "hidden-outside") {
            case "hidden-inside":
              if (!bottomEdgeInside) {
                hide = true;
              }
              break;
            case "hidden-outside":
              if (!topEdgeInside) {
                hide = true;
              }
              break;
            case "stick-inside":
              if (hostRect.bottom < bottom) {
                top = hostRect.bottom - height;
                topChanged = true;
              }
              break;
            case "stick-outside":
              if (hostRect.bottom < top) {
                top = hostRect.bottom;
                topChanged = true;
              }
              break;
          }
        }
        if (beforeTheLeft) {
          switch ((outOfViewDisplay === null || outOfViewDisplay === void 0 ? void 0 : outOfViewDisplay.left) || "hidden-inside") {
            case "hidden-inside":
              if (!leftEdgeInside) {
                hide = true;
              }
              break;
            case "hidden-outside":
              if (!rightEdgeInside) {
                hide = true;
              }
              break;
            case "stick-inside":
              if (hostRect.left > left + marginLeft) {
                left = hostRect.left - marginLeft;
                leftChanged = true;
              }
              break;
            case "stick-outside":
              if (hostRect.left > right) {
                left = hostRect.left - marginLeft - width;
                leftChanged = true;
              }
              break;
          }
        }
        if (afterTheRight) {
          switch ((outOfViewDisplay === null || outOfViewDisplay === void 0 ? void 0 : outOfViewDisplay.right) || "hidden-outside") {
            case "hidden-inside":
              if (!rightEdgeInside) {
                hide = true;
              }
              break;
            case "hidden-outside":
              if (!leftEdgeInside) {
                hide = true;
              }
              break;
            case "stick-inside":
              if (hostRect.right < right) {
                left = hostRect.right - width;
                leftChanged = true;
              }
              break;
            case "stick-outside":
              if (hostRect.right < left) {
                left = hostRect.right;
                leftChanged = true;
              }
              break;
          }
        }
        if (hide) {
          node.style.zIndex = OUTOFVIEW_Z_INDEX;
          node.style.visibility = "hidden";
        }
        if (leftChanged) {
          node.style.left = `${Math.ceil(left)}px`;
        }
        if (topChanged) {
          node.style.top = `${Math.ceil(top)}px`;
        }
      }
      HoverBox2.setGeometry = setGeometry;
    })(HoverBox || (HoverBox = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/tokens.js
var import_coreutils10, IFormRendererRegistry, ILabIconManager;
var init_tokens2 = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/tokens.js"() {
    import_coreutils10 = __toESM(require_dist());
    IFormRendererRegistry = new import_coreutils10.Token("@jupyterlab/ui-components:IFormRendererRegistry", "A service for settings form renderer registration.");
    ILabIconManager = new import_coreutils10.Token("@jupyterlab/ui-components:ILabIconManager", "A service to register and request icons.");
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/FormRendererRegistry.js
var init_FormRendererRegistry = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/FormRendererRegistry.js"() {
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/index.js
var init_lib5 = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/index.js"() {
    init_components();
    init_icon2();
    init_hoverbox();
    init_tokens2();
    init_utils2();
    init_FormRendererRegistry();
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target2[key2] = source[key2];
        }
      }
    }
    return target2;
  };
  return _extends.apply(this, arguments);
}
var init_extends = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/extends.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
var init_typeof = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var init_toPrimitive = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
  var key2 = _toPrimitive(arg, "string");
  return _typeof(key2) === "symbol" ? key2 : String(key2);
}
var init_toPropertyKey = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key2, value) {
  key2 = _toPropertyKey(key2);
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var init_defineProperty = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var init_arrayLikeToArray = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
var init_unsupportedIterableToArray = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_arrayLikeToArray();
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/components/hover.js
function showPopup(options) {
  const dialog = new Popup(options);
  if (!options.startHidden) {
    dialog.launch();
  }
  return dialog;
}
var Popup;
var init_hover = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/components/hover.js"() {
    init_lib5();
    init_index_es618();
    Popup = class extends Widget {
      /**
       * Construct a new Popup.
       */
      constructor(options) {
        super();
        this._body = options.body;
        this._body.addClass("jp-StatusBar-HoverItem");
        this._anchor = options.anchor;
        this._align = options.align;
        if (options.hasDynamicSize) {
          this._observer = new ResizeObserver(() => {
            this.update();
          });
        }
        const layout = this.layout = new PanelLayout();
        layout.addWidget(options.body);
        this._body.node.addEventListener("resize", () => {
          this.update();
        });
      }
      /**
       * Attach the popup widget to the page.
       */
      launch() {
        this._setGeometry();
        Widget.attach(this, document.body);
        this.update();
        this._anchor.addClass("jp-mod-clicked");
        this._anchor.removeClass("jp-mod-highlight");
      }
      /**
       * Handle `'update'` messages for the widget.
       */
      onUpdateRequest(msg) {
        this._setGeometry();
        super.onUpdateRequest(msg);
      }
      /**
       * Handle `'after-attach'` messages for the widget.
       */
      onAfterAttach(msg) {
        var _a;
        document.addEventListener("click", this, false);
        this.node.addEventListener("keydown", this, false);
        window.addEventListener("resize", this, false);
        (_a = this._observer) === null || _a === void 0 ? void 0 : _a.observe(this._body.node);
      }
      /**
       * Handle `'before-detach'` messages for the widget.
       */
      onBeforeDetach(msg) {
        var _a;
        (_a = this._observer) === null || _a === void 0 ? void 0 : _a.disconnect();
        document.removeEventListener("click", this, false);
        this.node.removeEventListener("keydown", this, false);
        window.removeEventListener("resize", this, false);
      }
      /**
       * Handle `'resize'` messages for the widget.
       */
      onResize() {
        this.update();
      }
      /**
       * Dispose of the widget.
       */
      dispose() {
        var _a;
        (_a = this._observer) === null || _a === void 0 ? void 0 : _a.disconnect();
        super.dispose();
        this._anchor.removeClass("jp-mod-clicked");
        this._anchor.addClass("jp-mod-highlight");
      }
      /**
       * Handle DOM events for the widget.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeydown(event);
            break;
          case "click":
            this._evtClick(event);
            break;
          case "resize":
            this.onResize();
            break;
          default:
            break;
        }
      }
      _evtClick(event) {
        if (!!event.target && !(this._body.node.contains(event.target) || this._anchor.node.contains(event.target))) {
          this.dispose();
        }
      }
      _evtKeydown(event) {
        switch (event.keyCode) {
          case 27:
            event.stopPropagation();
            event.preventDefault();
            this.dispose();
            break;
          default:
            break;
        }
      }
      _setGeometry() {
        let aligned = 0;
        const anchorRect = this._anchor.node.getBoundingClientRect();
        const bodyRect = this._body.node.getBoundingClientRect();
        if (this._align === "right") {
          aligned = -(bodyRect.width - anchorRect.width);
        }
        const style = window.getComputedStyle(this._body.node);
        HoverBox.setGeometry({
          anchor: anchorRect,
          host: document.body,
          maxHeight: 500,
          minHeight: 20,
          node: this._body.node,
          offset: {
            horizontal: aligned
          },
          privilege: "forceAbove",
          style
        });
      }
    };
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/components/text.js
function TextItem(props) {
  const { title, source, className, ...rest } = props;
  return React11.createElement("span", { className: `jp-StatusBar-TextItem ${className}`, title, ...rest }, source);
}
var React11;
var init_text = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/components/text.js"() {
    React11 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/components/group.js
function GroupItem(props) {
  const { spacing, children: children2, className, ...rest } = props;
  const numChildren = React12.Children.count(children2);
  return React12.createElement("div", { className: `jp-StatusBar-GroupItem ${className || ""}`, ...rest }, React12.Children.map(children2, (child, i) => {
    if (i === 0) {
      return React12.createElement("div", { style: { marginRight: `${spacing}px` } }, child);
    } else if (i === numChildren - 1) {
      return React12.createElement("div", { style: { marginLeft: `${spacing}px` } }, child);
    } else {
      return React12.createElement("div", { style: { margin: `0px ${spacing}px` } }, child);
    }
  }));
}
var React12;
var init_group = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/components/group.js"() {
    React12 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/components/progressBar.js
var React13;
var init_progressBar = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/components/progressBar.js"() {
    React13 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/components/progressCircle.js
var import_react28;
var init_progressCircle = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/components/progressCircle.js"() {
    import_react28 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/components/index.js
var init_components2 = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/components/index.js"() {
    init_group();
    init_hover();
    init_progressBar();
    init_text();
    init_progressCircle();
  }
});

// ../../node_modules/@jupyterlab/statusbar/node_modules/@lumino/algorithm/dist/index.es6.js
var ArrayExt6, Private24, StringExt6;
var init_index_es623 = __esm({
  "../../node_modules/@jupyterlab/statusbar/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt8) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start + i) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start - i + n) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start + i) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findFirstIndex = findFirstIndex;
      function findLastIndex2(array, fn, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let d;
        if (start < stop) {
          d = start + 1 + (n - stop);
        } else {
          d = start - stop + 1;
        }
        for (let i = 0; i < d; ++i) {
          let j = (start - i + n) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findLastIndex = findLastIndex2;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index = findFirstIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index = findLastIndex2(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt8.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt8.upperBound = upperBound;
      function shallowEqual(a, b, fn) {
        if (a === b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0, n = a.length; i < n; ++i) {
          if (fn ? !fn(a[i], b[i]) : a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt8.shallowEqual = shallowEqual;
      function slice(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n = array.length;
        if (start === void 0) {
          start = step < 0 ? n - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n, step < 0 ? -1 : 0);
        } else if (start >= n) {
          start = step < 0 ? n - 1 : n;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n;
        } else if (stop < 0) {
          stop = Math.max(stop + n, step < 0 ? -1 : 0);
        } else if (stop >= n) {
          stop = step < 0 ? n - 1 : n;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result = [];
        for (let i = 0; i < length; ++i) {
          result[i] = array[start + i * step];
        }
        return result;
      }
      ArrayExt8.slice = slice;
      function move(array, fromIndex, toIndex) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n);
        } else {
          fromIndex = Math.min(fromIndex, n - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n);
        } else {
          toIndex = Math.min(toIndex, n - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d = fromIndex < toIndex ? 1 : -1;
        for (let i = fromIndex; i !== toIndex; i += d) {
          array[i] = array[i + d];
        }
        array[toIndex] = value;
      }
      ArrayExt8.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        while (start < stop) {
          let a = array[start];
          let b = array[stop];
          array[start++] = b;
          array[stop--] = a;
        }
      }
      ArrayExt8.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt8.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          array[(start + i) % n] = value;
        }
      }
      ArrayExt8.fill = fill;
      function insert(array, index, value) {
        let n = array.length;
        if (index < 0) {
          index = Math.max(0, index + n);
        } else {
          index = Math.min(index, n);
        }
        for (let i = n; i > index; --i) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      ArrayExt8.insert = insert;
      function removeAt(array, index) {
        let n = array.length;
        if (index < 0) {
          index += n;
        }
        if (index < 0 || index >= n) {
          return void 0;
        }
        let value = array[index];
        for (let i = index + 1; i < n; ++i) {
          array[i - 1] = array[i];
        }
        array.length = n - 1;
        return value;
      }
      ArrayExt8.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index = firstIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index = lastIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i = 0; i < n; ++i) {
          if (start <= stop && i >= start && i <= stop && array[i] === value) {
            count++;
          } else if (stop < start && (i <= stop || i >= start) && array[i] === value) {
            count++;
          } else if (count > 0) {
            array[i - count] = array[i];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index = findFirstIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index = findLastIndex2(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i = 0; i < n; ++i) {
          if (start <= stop && i >= start && i <= stop && fn(array[i], i)) {
            count++;
          } else if (stop < start && (i <= stop || i >= start) && fn(array[i], i)) {
            count++;
          } else if (count > 0) {
            array[i - count] = array[i];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllWhere = removeAllWhere;
    })(ArrayExt6 || (ArrayExt6 = {}));
    (function(Private36) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private36.rangeLength = rangeLength;
    })(Private24 || (Private24 = {}));
    (function(StringExt8) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i = 0, j = start, n = query.length; i < n; ++i, ++j) {
          j = source.indexOf(query[i], j);
          if (j === -1) {
            return null;
          }
          indices[i] = j;
        }
        return indices;
      }
      StringExt8.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i = 0, n = indices.length; i < n; ++i) {
          let j = indices[i] - start;
          score += j * j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last = start - 1;
        for (let i = 0, n = indices.length; i < n; ++i) {
          let j = indices[i];
          score += j - last - 1;
          last = j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result = [];
        let k = 0;
        let last = 0;
        let n = indices.length;
        while (k < n) {
          let i = indices[k];
          let j = indices[k];
          while (++k < n && indices[k] === j + 1) {
            j++;
          }
          if (last < i) {
            result.push(source.slice(last, i));
          }
          if (i < j + 1) {
            result.push(fn(source.slice(i, j + 1)));
          }
          last = j + 1;
        }
        if (last < source.length) {
          result.push(source.slice(last));
        }
        return result;
      }
      StringExt8.highlight = highlight;
      function cmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      StringExt8.cmp = cmp;
    })(StringExt6 || (StringExt6 = {}));
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/statusbar.js
var Private25;
var init_statusbar = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/statusbar.js"() {
    init_index_es623();
    init_index_es65();
    init_index_es618();
    (function(Private36) {
      Private36.statusItemDefaults = {
        align: "left",
        rank: 0,
        priority: 0,
        isActive: () => true,
        activeStateChanged: void 0
      };
    })(Private25 || (Private25 = {}));
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/tokens.js
var import_coreutils11, IStatusBar;
var init_tokens3 = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/tokens.js"() {
    import_coreutils11 = __toESM(require_dist());
    IStatusBar = new import_coreutils11.Token("@jupyterlab/statusbar:IStatusBar", "A service for the status bar on the application. Use this if you want to add new status bar items.");
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/index.js
var init_lib6 = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/index.js"() {
    init_components2();
    init_statusbar();
    init_tokens3();
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@lumino/algorithm/dist/index.es6.js
function find4(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return value;
    }
  }
  return void 0;
}
function every3(object, fn) {
  let index = 0;
  for (const value of object) {
    if (false === fn(value, index++)) {
      return false;
    }
  }
  return true;
}
function some3(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return true;
    }
  }
  return false;
}
function* retro3(object) {
  if (typeof object.retro === "function") {
    yield* object.retro();
  } else {
    for (let index = object.length - 1; index > -1; index--) {
      yield object[index];
    }
  }
}
var ArrayExt7, Private26, StringExt7;
var init_index_es624 = __esm({
  "../../node_modules/@jupyterlab/apputils/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt8) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start + i) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start - i + n) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          let j = (start + i) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findFirstIndex = findFirstIndex;
      function findLastIndex2(array, fn, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let d;
        if (start < stop) {
          d = start + 1 + (n - stop);
        } else {
          d = start - stop + 1;
        }
        for (let i = 0; i < d; ++i) {
          let j = (start - i + n) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findLastIndex = findLastIndex2;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index = findFirstIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index = findLastIndex2(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt8.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt8.upperBound = upperBound;
      function shallowEqual(a, b, fn) {
        if (a === b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0, n = a.length; i < n; ++i) {
          if (fn ? !fn(a[i], b[i]) : a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt8.shallowEqual = shallowEqual;
      function slice(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n = array.length;
        if (start === void 0) {
          start = step < 0 ? n - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n, step < 0 ? -1 : 0);
        } else if (start >= n) {
          start = step < 0 ? n - 1 : n;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n;
        } else if (stop < 0) {
          stop = Math.max(stop + n, step < 0 ? -1 : 0);
        } else if (stop >= n) {
          stop = step < 0 ? n - 1 : n;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result = [];
        for (let i = 0; i < length; ++i) {
          result[i] = array[start + i * step];
        }
        return result;
      }
      ArrayExt8.slice = slice;
      function move(array, fromIndex, toIndex) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n);
        } else {
          fromIndex = Math.min(fromIndex, n - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n);
        } else {
          toIndex = Math.min(toIndex, n - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d = fromIndex < toIndex ? 1 : -1;
        for (let i = fromIndex; i !== toIndex; i += d) {
          array[i] = array[i + d];
        }
        array[toIndex] = value;
      }
      ArrayExt8.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        while (start < stop) {
          let a = array[start];
          let b = array[stop];
          array[start++] = b;
          array[stop--] = a;
        }
      }
      ArrayExt8.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt8.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i = 0; i < span; ++i) {
          array[(start + i) % n] = value;
        }
      }
      ArrayExt8.fill = fill;
      function insert(array, index, value) {
        let n = array.length;
        if (index < 0) {
          index = Math.max(0, index + n);
        } else {
          index = Math.min(index, n);
        }
        for (let i = n; i > index; --i) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      ArrayExt8.insert = insert;
      function removeAt(array, index) {
        let n = array.length;
        if (index < 0) {
          index += n;
        }
        if (index < 0 || index >= n) {
          return void 0;
        }
        let value = array[index];
        for (let i = index + 1; i < n; ++i) {
          array[i - 1] = array[i];
        }
        array.length = n - 1;
        return value;
      }
      ArrayExt8.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index = firstIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index = lastIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i = 0; i < n; ++i) {
          if (start <= stop && i >= start && i <= stop && array[i] === value) {
            count++;
          } else if (stop < start && (i <= stop || i >= start) && array[i] === value) {
            count++;
          } else if (count > 0) {
            array[i - count] = array[i];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index = findFirstIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index = findLastIndex2(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i = 0; i < n; ++i) {
          if (start <= stop && i >= start && i <= stop && fn(array[i], i)) {
            count++;
          } else if (stop < start && (i <= stop || i >= start) && fn(array[i], i)) {
            count++;
          } else if (count > 0) {
            array[i - count] = array[i];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllWhere = removeAllWhere;
    })(ArrayExt7 || (ArrayExt7 = {}));
    (function(Private36) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private36.rangeLength = rangeLength;
    })(Private26 || (Private26 = {}));
    (function(StringExt8) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i = 0, j = start, n = query.length; i < n; ++i, ++j) {
          j = source.indexOf(query[i], j);
          if (j === -1) {
            return null;
          }
          indices[i] = j;
        }
        return indices;
      }
      StringExt8.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i = 0, n = indices.length; i < n; ++i) {
          let j = indices[i] - start;
          score += j * j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last = start - 1;
        for (let i = 0, n = indices.length; i < n; ++i) {
          let j = indices[i];
          score += j - last - 1;
          last = j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result = [];
        let k = 0;
        let last = 0;
        let n = indices.length;
        while (k < n) {
          let i = indices[k];
          let j = indices[k];
          while (++k < n && indices[k] === j + 1) {
            j++;
          }
          if (last < i) {
            result.push(source.slice(last, i));
          }
          if (i < j + 1) {
            result.push(fn(source.slice(i, j + 1)));
          }
          last = j + 1;
        }
        if (last < source.length) {
          result.push(source.slice(last));
        }
        return result;
      }
      StringExt8.highlight = highlight;
      function cmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      StringExt8.cmp = cmp;
    })(StringExt7 || (StringExt7 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@lumino/domutils/dist/index.es6.js
var ClipboardExt3, ElementExt3, Platform3, Selector4, Private27;
var init_index_es625 = __esm({
  "../../node_modules/@jupyterlab/apputils/node_modules/@lumino/domutils/dist/index.es6.js"() {
    (function(ClipboardExt4) {
      function copyText(text) {
        const body = document.body;
        const handler = (event) => {
          event.preventDefault();
          event.stopPropagation();
          event.clipboardData.setData("text", text);
          body.removeEventListener("copy", handler, true);
        };
        body.addEventListener("copy", handler, true);
        document.execCommand("copy");
      }
      ClipboardExt4.copyText = copyText;
    })(ClipboardExt3 || (ClipboardExt3 = {}));
    (function(ElementExt4) {
      function boxSizing(element) {
        let style = window.getComputedStyle(element);
        let bt = parseFloat(style.borderTopWidth) || 0;
        let bl = parseFloat(style.borderLeftWidth) || 0;
        let br = parseFloat(style.borderRightWidth) || 0;
        let bb = parseFloat(style.borderBottomWidth) || 0;
        let pt = parseFloat(style.paddingTop) || 0;
        let pl = parseFloat(style.paddingLeft) || 0;
        let pr = parseFloat(style.paddingRight) || 0;
        let pb = parseFloat(style.paddingBottom) || 0;
        let hs = bl + pl + pr + br;
        let vs = bt + pt + pb + bb;
        return {
          borderTop: bt,
          borderLeft: bl,
          borderRight: br,
          borderBottom: bb,
          paddingTop: pt,
          paddingLeft: pl,
          paddingRight: pr,
          paddingBottom: pb,
          horizontalSum: hs,
          verticalSum: vs
        };
      }
      ElementExt4.boxSizing = boxSizing;
      function sizeLimits(element) {
        let style = window.getComputedStyle(element);
        let minWidth = parseFloat(style.minWidth) || 0;
        let minHeight = parseFloat(style.minHeight) || 0;
        let maxWidth = parseFloat(style.maxWidth) || Infinity;
        let maxHeight = parseFloat(style.maxHeight) || Infinity;
        maxWidth = Math.max(minWidth, maxWidth);
        maxHeight = Math.max(minHeight, maxHeight);
        return { minWidth, minHeight, maxWidth, maxHeight };
      }
      ElementExt4.sizeLimits = sizeLimits;
      function hitTest(element, clientX, clientY) {
        let rect = element.getBoundingClientRect();
        return clientX >= rect.left && clientX < rect.right && clientY >= rect.top && clientY < rect.bottom;
      }
      ElementExt4.hitTest = hitTest;
      function scrollIntoViewIfNeeded(area, element) {
        let ar = area.getBoundingClientRect();
        let er = element.getBoundingClientRect();
        if (er.top <= ar.top && er.bottom >= ar.bottom) {
          return;
        }
        if (er.top < ar.top && er.height <= ar.height) {
          area.scrollTop -= ar.top - er.top;
          return;
        }
        if (er.bottom > ar.bottom && er.height >= ar.height) {
          area.scrollTop -= ar.top - er.top;
          return;
        }
        if (er.top < ar.top && er.height > ar.height) {
          area.scrollTop -= ar.bottom - er.bottom;
          return;
        }
        if (er.bottom > ar.bottom && er.height < ar.height) {
          area.scrollTop -= ar.bottom - er.bottom;
          return;
        }
      }
      ElementExt4.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;
    })(ElementExt3 || (ElementExt3 = {}));
    (function(Platform4) {
      Platform4.IS_MAC = !!navigator.platform.match(/Mac/i);
      Platform4.IS_WIN = !!navigator.platform.match(/Win/i);
      Platform4.IS_IE = /Trident/.test(navigator.userAgent);
      Platform4.IS_EDGE = /Edge/.test(navigator.userAgent);
      function accelKey(event) {
        return Platform4.IS_MAC ? event.metaKey : event.ctrlKey;
      }
      Platform4.accelKey = accelKey;
    })(Platform3 || (Platform3 = {}));
    (function(Selector5) {
      function calculateSpecificity(selector) {
        if (selector in Private27.specificityCache) {
          return Private27.specificityCache[selector];
        }
        let result = Private27.calculateSingle(selector);
        return Private27.specificityCache[selector] = result;
      }
      Selector5.calculateSpecificity = calculateSpecificity;
      function isValid(selector) {
        if (selector in Private27.validityCache) {
          return Private27.validityCache[selector];
        }
        let result = true;
        try {
          Private27.testElem.querySelector(selector);
        } catch (err) {
          result = false;
        }
        return Private27.validityCache[selector] = result;
      }
      Selector5.isValid = isValid;
      function matches2(element, selector) {
        return Private27.protoMatchFunc.call(element, selector);
      }
      Selector5.matches = matches2;
    })(Selector4 || (Selector4 = {}));
    (function(Private36) {
      Private36.specificityCache = /* @__PURE__ */ Object.create(null);
      Private36.validityCache = /* @__PURE__ */ Object.create(null);
      Private36.testElem = document.createElement("div");
      Private36.protoMatchFunc = (() => {
        let proto = Element.prototype;
        return proto.matches || proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector || function(selector) {
          let elem = this;
          let matches2 = elem.ownerDocument ? elem.ownerDocument.querySelectorAll(selector) : [];
          return Array.prototype.indexOf.call(matches2, elem) !== -1;
        };
      })();
      function calculateSingle(selector) {
        selector = selector.split(",", 1)[0];
        let a = 0;
        let b = 0;
        let c = 0;
        function match(re) {
          let match2 = selector.match(re);
          if (match2 === null) {
            return false;
          }
          selector = selector.slice(match2[0].length);
          return true;
        }
        selector = selector.replace(NEGATION_RE, " $1 ");
        while (selector.length > 0) {
          if (match(ID_RE)) {
            a++;
            continue;
          }
          if (match(CLASS_RE)) {
            b++;
            continue;
          }
          if (match(ATTR_RE)) {
            b++;
            continue;
          }
          if (match(PSEUDO_ELEM_RE)) {
            c++;
            continue;
          }
          if (match(PSEDUO_CLASS_RE)) {
            b++;
            continue;
          }
          if (match(TYPE_RE)) {
            c++;
            continue;
          }
          if (match(IGNORE_RE)) {
            continue;
          }
          return 0;
        }
        a = Math.min(a, 255);
        b = Math.min(b, 255);
        c = Math.min(c, 255);
        return a << 16 | b << 8 | c;
      }
      Private36.calculateSingle = calculateSingle;
      const ID_RE = /^#[^\s\+>~#\.\[:]+/;
      const CLASS_RE = /^\.[^\s\+>~#\.\[:]+/;
      const ATTR_RE = /^\[[^\]]+\]/;
      const TYPE_RE = /^[^\s\+>~#\.\[:]+/;
      const PSEUDO_ELEM_RE = /^(::[^\s\+>~#\.\[:]+|:first-line|:first-letter|:before|:after)/;
      const PSEDUO_CLASS_RE = /^:[^\s\+>~#\.\[:]+/;
      const IGNORE_RE = /^[\s\+>~\*]+/;
      const NEGATION_RE = /:not\(([^\)]+)\)/g;
    })(Private27 || (Private27 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/domutils.js
var import_coreutils12, DOMUtils;
var init_domutils = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/domutils.js"() {
    init_index_es624();
    import_coreutils12 = __toESM(require_dist());
    init_index_es625();
    (function(DOMUtils2) {
      function hitTestNodes(nodes, x, y) {
        return ArrayExt7.findFirstIndex(nodes, (node) => {
          return ElementExt3.hitTest(node, x, y);
        });
      }
      DOMUtils2.hitTestNodes = hitTestNodes;
      function findElement(parent, className) {
        return parent.querySelector(`.${className}`);
      }
      DOMUtils2.findElement = findElement;
      function findElements(parent, className) {
        return parent.getElementsByClassName(className);
      }
      DOMUtils2.findElements = findElements;
      function createDomID() {
        return `id-${import_coreutils12.UUID.uuid4()}`;
      }
      DOMUtils2.createDomID = createDomID;
      function hasActiveEditableElement(parent, root = document) {
        const element = root.activeElement;
        return !!(element && parent.contains(element) && (element.matches(":read-write") || element.shadowRoot && hasActiveEditableElement(element.shadowRoot, element.shadowRoot)));
      }
      DOMUtils2.hasActiveEditableElement = hasActiveEditableElement;
    })(DOMUtils || (DOMUtils = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@lumino/collections/dist/index.es6.js
var LinkedList3, Private28;
var init_index_es626 = __esm({
  "../../node_modules/@jupyterlab/apputils/node_modules/@lumino/collections/dist/index.es6.js"() {
    LinkedList3 = class {
      constructor() {
        this._first = null;
        this._last = null;
        this._size = 0;
      }
      /**
       * Whether the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get isEmpty() {
        return this._size === 0;
      }
      /**
       * The size of the list.
       *
       * #### Complexity
       * `O(1)`
       *
       * #### Notes
       * This is equivalent to `length`.
       */
      get size() {
        return this._size;
      }
      /**
       * The length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `size`.
       *
       * This property is deprecated.
       */
      get length() {
        return this._size;
      }
      /**
       * The first value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get first() {
        return this._first ? this._first.value : void 0;
      }
      /**
       * The last value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get last() {
        return this._last ? this._last.value : void 0;
      }
      /**
       * The first node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get firstNode() {
        return this._first;
      }
      /**
       * The last node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get lastNode() {
        return this._last;
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting with the first value.
       *
       * #### Complexity
       * Constant.
       */
      *[Symbol.iterator]() {
        let node = this._first;
        while (node) {
          yield node.value;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the values in the list.
       *
       * @returns A new iterator starting with the last value.
       *
       * #### Complexity
       * Constant.
       */
      *retro() {
        let node = this._last;
        while (node) {
          yield node.value;
          node = node.prev;
        }
      }
      /**
       * Create an iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the first node.
       *
       * #### Complexity
       * Constant.
       */
      *nodes() {
        let node = this._first;
        while (node) {
          yield node;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the last node.
       *
       * #### Complexity
       * Constant.
       */
      *retroNodes() {
        let node = this._last;
        while (node) {
          yield node;
          node = node.prev;
        }
      }
      /**
       * Assign new values to the list, replacing all current values.
       *
       * @param values - The values to assign to the list.
       *
       * #### Complexity
       * Linear.
       */
      assign(values) {
        this.clear();
        for (const value of values) {
          this.addLast(value);
        }
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addLast`.
       */
      push(value) {
        this.addLast(value);
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeLast`.
       */
      pop() {
        return this.removeLast();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addFirst`.
       */
      shift(value) {
        this.addFirst(value);
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeFirst`.
       */
      unshift() {
        return this.removeFirst();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addFirst(value) {
        let node = new Private28.LinkedListNode(this, value);
        if (!this._first) {
          this._first = node;
          this._last = node;
        } else {
          node.next = this._first;
          this._first.prev = node;
          this._first = node;
        }
        this._size++;
        return node;
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addLast(value) {
        let node = new Private28.LinkedListNode(this, value);
        if (!this._last) {
          this._first = node;
          this._last = node;
        } else {
          node.prev = this._last;
          this._last.next = node;
          this._last = node;
        }
        this._size++;
        return node;
      }
      /**
       * Insert a value before a specific node in the list.
       *
       * @param value - The value to insert before the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertBefore(value, ref2) {
        if (!ref2 || ref2 === this._first) {
          return this.addFirst(value);
        }
        if (!(ref2 instanceof Private28.LinkedListNode) || ref2.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private28.LinkedListNode(this, value);
        let _ref = ref2;
        let prev = _ref.prev;
        node.next = _ref;
        node.prev = prev;
        _ref.prev = node;
        prev.next = node;
        this._size++;
        return node;
      }
      /**
       * Insert a value after a specific node in the list.
       *
       * @param value - The value to insert after the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertAfter(value, ref2) {
        if (!ref2 || ref2 === this._last) {
          return this.addLast(value);
        }
        if (!(ref2 instanceof Private28.LinkedListNode) || ref2.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private28.LinkedListNode(this, value);
        let _ref = ref2;
        let next = _ref.next;
        node.next = next;
        node.prev = _ref;
        _ref.next = node;
        next.prev = node;
        this._size++;
        return node;
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeFirst() {
        let node = this._first;
        if (!node) {
          return void 0;
        }
        if (node === this._last) {
          this._first = null;
          this._last = null;
        } else {
          this._first = node.next;
          this._first.prev = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeLast() {
        let node = this._last;
        if (!node) {
          return void 0;
        }
        if (node === this._first) {
          this._first = null;
          this._last = null;
        } else {
          this._last = node.prev;
          this._last.next = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove a specific node from the list.
       *
       * @param node - The node to remove from the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * The node must be owned by the list.
       */
      removeNode(node) {
        if (!(node instanceof Private28.LinkedListNode) || node.list !== this) {
          throw new Error("Node is not owned by the list.");
        }
        let _node = node;
        if (_node === this._first && _node === this._last) {
          this._first = null;
          this._last = null;
        } else if (_node === this._first) {
          this._first = _node.next;
          this._first.prev = null;
        } else if (_node === this._last) {
          this._last = _node.prev;
          this._last.next = null;
        } else {
          _node.next.prev = _node.prev;
          _node.prev.next = _node.next;
        }
        _node.list = null;
        _node.next = null;
        _node.prev = null;
        this._size--;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       */
      clear() {
        let node = this._first;
        while (node) {
          let next = node.next;
          node.list = null;
          node.prev = null;
          node.next = null;
          node = next;
        }
        this._first = null;
        this._last = null;
        this._size = 0;
      }
    };
    (function(LinkedList4) {
      function from2(values) {
        let list = new LinkedList4();
        list.assign(values);
        return list;
      }
      LinkedList4.from = from2;
    })(LinkedList3 || (LinkedList3 = {}));
    (function(Private36) {
      class LinkedListNode {
        /**
         * Construct a new linked list node.
         *
         * @param list - The list which owns the node.
         *
         * @param value - The value for the link.
         */
        constructor(list, value) {
          this.list = null;
          this.next = null;
          this.prev = null;
          this.list = list;
          this.value = value;
        }
      }
      Private36.LinkedListNode = LinkedListNode;
    })(Private28 || (Private28 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@lumino/messaging/dist/index.es6.js
var MessageLoop3;
var init_index_es627 = __esm({
  "../../node_modules/@jupyterlab/apputils/node_modules/@lumino/messaging/dist/index.es6.js"() {
    init_index_es624();
    init_index_es626();
    (function(MessageLoop4) {
      let pending = null;
      const schedule = ((resolved) => (fn) => {
        let rejected = false;
        resolved.then(() => !rejected && fn());
        return () => {
          rejected = true;
        };
      })(Promise.resolve());
      function sendMessage(handler, msg) {
        let hooks = messageHooks.get(handler);
        if (!hooks || hooks.length === 0) {
          invokeHandler(handler, msg);
          return;
        }
        let passed = every3(retro3(hooks), (hook) => {
          return hook ? invokeHook(hook, handler, msg) : true;
        });
        if (passed) {
          invokeHandler(handler, msg);
        }
      }
      MessageLoop4.sendMessage = sendMessage;
      function postMessage(handler, msg) {
        if (!msg.isConflatable) {
          enqueueMessage(handler, msg);
          return;
        }
        let conflated = some3(messageQueue, (posted) => {
          if (posted.handler !== handler) {
            return false;
          }
          if (!posted.msg) {
            return false;
          }
          if (posted.msg.type !== msg.type) {
            return false;
          }
          if (!posted.msg.isConflatable) {
            return false;
          }
          return posted.msg.conflate(msg);
        });
        if (!conflated) {
          enqueueMessage(handler, msg);
        }
      }
      MessageLoop4.postMessage = postMessage;
      function installMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.indexOf(hook) !== -1) {
          return;
        }
        if (!hooks) {
          messageHooks.set(handler, [hook]);
        } else {
          hooks.push(hook);
        }
      }
      MessageLoop4.installMessageHook = installMessageHook;
      function removeMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (!hooks) {
          return;
        }
        let i = hooks.indexOf(hook);
        if (i === -1) {
          return;
        }
        hooks[i] = null;
        scheduleCleanup(hooks);
      }
      MessageLoop4.removeMessageHook = removeMessageHook;
      function clearData(handler) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.length > 0) {
          ArrayExt7.fill(hooks, null);
          scheduleCleanup(hooks);
        }
        for (const posted of messageQueue) {
          if (posted.handler === handler) {
            posted.handler = null;
            posted.msg = null;
          }
        }
      }
      MessageLoop4.clearData = clearData;
      function flush() {
        if (flushGuard || pending === null) {
          return;
        }
        pending();
        pending = null;
        flushGuard = true;
        runMessageLoop();
        flushGuard = false;
      }
      MessageLoop4.flush = flush;
      function getExceptionHandler() {
        return exceptionHandler;
      }
      MessageLoop4.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = exceptionHandler;
        exceptionHandler = handler;
        return old;
      }
      MessageLoop4.setExceptionHandler = setExceptionHandler;
      const messageQueue = new LinkedList3();
      const messageHooks = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      let exceptionHandler = (err) => {
        console.error(err);
      };
      let flushGuard = false;
      function invokeHook(hook, handler, msg) {
        let result = true;
        try {
          if (typeof hook === "function") {
            result = hook(handler, msg);
          } else {
            result = hook.messageHook(handler, msg);
          }
        } catch (err) {
          exceptionHandler(err);
        }
        return result;
      }
      function invokeHandler(handler, msg) {
        try {
          handler.processMessage(msg);
        } catch (err) {
          exceptionHandler(err);
        }
      }
      function enqueueMessage(handler, msg) {
        messageQueue.addLast({ handler, msg });
        if (pending !== null) {
          return;
        }
        pending = schedule(runMessageLoop);
      }
      function runMessageLoop() {
        pending = null;
        if (messageQueue.isEmpty) {
          return;
        }
        let sentinel = { handler: null, msg: null };
        messageQueue.addLast(sentinel);
        while (true) {
          let posted = messageQueue.removeFirst();
          if (posted === sentinel) {
            return;
          }
          if (posted.handler && posted.msg) {
            sendMessage(posted.handler, posted.msg);
          }
        }
      }
      function scheduleCleanup(hooks) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(hooks);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupHooks);
        dirtySet.clear();
      }
      function cleanupHooks(hooks) {
        ArrayExt7.removeAllWhere(hooks, isNull);
      }
      function isNull(value) {
        return value === null;
      }
    })(MessageLoop3 || (MessageLoop3 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/statedb/lib/dataconnector.js
var require_dataconnector2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/statedb/lib/dataconnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DataConnector = void 0;
    var DataConnector = class {
      /**
       * Retrieve the list of items available from the data connector.
       *
       * @param query - The optional query filter to apply to the connector request.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can list.
       */
      async list(query) {
        throw new Error("DataConnector#list method has not been implemented.");
      }
      /**
       * Remove a value using the data connector.
       *
       * @param id - The identifier for the data being removed.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can remove.
       */
      async remove(id) {
        throw new Error("DataConnector#remove method has not been implemented.");
      }
      /**
       * Save a value using the data connector.
       *
       * @param id - The identifier for the data being saved.
       *
       * @param value - The data being saved.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can save.
       */
      async save(id, value) {
        throw new Error("DataConnector#save method has not been implemented.");
      }
    };
    exports2.DataConnector = DataConnector;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/statedb/lib/interfaces.js
var require_interfaces4 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/statedb/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@lumino/properties/dist/index.es6.js
var index_es6_exports5 = {};
__export(index_es6_exports5, {
  AttachedProperty: () => AttachedProperty4
});
var AttachedProperty4, Private29;
var init_index_es628 = __esm({
  "../../node_modules/@jupyterlab/apputils/node_modules/@lumino/properties/dist/index.es6.js"() {
    AttachedProperty4 = class {
      /**
       * Construct a new attached property.
       *
       * @param options - The options for initializing the property.
       */
      constructor(options) {
        this._pid = Private29.nextPID();
        this.name = options.name;
        this._create = options.create;
        this._coerce = options.coerce || null;
        this._compare = options.compare || null;
        this._changed = options.changed || null;
      }
      /**
       * Get the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @returns The current value of the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and assigned as the current value of the property.
       */
      get(owner) {
        let value;
        let map2 = Private29.ensureMap(owner);
        if (this._pid in map2) {
          value = map2[this._pid];
        } else {
          value = map2[this._pid] = this._createValue(owner);
        }
        return value;
      }
      /**
       * Set the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @param value - The value for the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      set(owner, value) {
        let oldValue;
        let map2 = Private29.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, value);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Explicitly coerce the current property value for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      coerce(owner) {
        let oldValue;
        let map2 = Private29.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, oldValue);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Get or create the default value for the given owner.
       */
      _createValue(owner) {
        let create5 = this._create;
        return create5(owner);
      }
      /**
       * Coerce the value for the given owner.
       */
      _coerceValue(owner, value) {
        let coerce = this._coerce;
        return coerce ? coerce(owner, value) : value;
      }
      /**
       * Compare the old value and new value for equality.
       */
      _compareValue(oldValue, newValue) {
        let compare = this._compare;
        return compare ? compare(oldValue, newValue) : oldValue === newValue;
      }
      /**
       * Run the change notification if the given values are different.
       */
      _maybeNotify(owner, oldValue, newValue) {
        let changed = this._changed;
        if (changed && !this._compareValue(oldValue, newValue)) {
          changed(owner, oldValue, newValue);
        }
      }
    };
    (function(AttachedProperty5) {
      function clearData(owner) {
        Private29.ownerData.delete(owner);
      }
      AttachedProperty5.clearData = clearData;
    })(AttachedProperty4 || (AttachedProperty4 = {}));
    (function(Private36) {
      Private36.ownerData = /* @__PURE__ */ new WeakMap();
      Private36.nextPID = (() => {
        let id = 0;
        return () => {
          let rand = Math.random();
          let stem = `${rand}`.slice(2);
          return `pid-${stem}-${id++}`;
        };
      })();
      function ensureMap(owner) {
        let map2 = Private36.ownerData.get(owner);
        if (map2) {
          return map2;
        }
        map2 = /* @__PURE__ */ Object.create(null);
        Private36.ownerData.set(owner, map2);
        return map2;
      }
      Private36.ensureMap = ensureMap;
    })(Private29 || (Private29 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/statedb/lib/restorablepool.js
var require_restorablepool2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/statedb/lib/restorablepool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestorablePool = void 0;
    var coreutils_12 = require_dist();
    var properties_1 = (init_index_es628(), __toCommonJS(index_es6_exports5));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var RestorablePool2 = class {
      /**
       * Create a new restorable pool.
       *
       * @param options - The instantiation options for a restorable pool.
       */
      constructor(options) {
        this._added = new signaling_1.Signal(this);
        this._current = null;
        this._currentChanged = new signaling_1.Signal(this);
        this._hasRestored = false;
        this._isDisposed = false;
        this._objects = /* @__PURE__ */ new Set();
        this._restore = null;
        this._restored = new coreutils_12.PromiseDelegate();
        this._updated = new signaling_1.Signal(this);
        this.namespace = options.namespace;
      }
      /**
       * A signal emitted when an object object is added.
       *
       * #### Notes
       * This signal will only fire when an object is added to the pool.
       * It will not fire if an object injected into the pool.
       */
      get added() {
        return this._added;
      }
      /**
       * The current object.
       *
       * #### Notes
       * The restorable pool does not set `current`. It is intended for client use.
       *
       * If `current` is set to an object that does not exist in the pool, it is a
       * no-op.
       */
      get current() {
        return this._current;
      }
      set current(obj) {
        if (this._current === obj) {
          return;
        }
        if (obj !== null && this._objects.has(obj)) {
          this._current = obj;
          this._currentChanged.emit(this._current);
        }
      }
      /**
       * A signal emitted when the current widget changes.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * Test whether the pool is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * A promise resolved when the restorable pool has been restored.
       */
      get restored() {
        return this._restored.promise;
      }
      /**
       * The number of objects held by the pool.
       */
      get size() {
        return this._objects.size;
      }
      /**
       * A signal emitted when an object is updated.
       */
      get updated() {
        return this._updated;
      }
      /**
       * Add a new object to the pool.
       *
       * @param obj - The object object being added.
       *
       * #### Notes
       * The object passed into the pool is added synchronously; its existence in
       * the pool can be checked with the `has()` method. The promise this method
       * returns resolves after the object has been added and saved to an underlying
       * restoration connector, if one is available.
       */
      async add(obj) {
        var _a, _b;
        if (obj.isDisposed) {
          const warning = "A disposed object cannot be added.";
          console.warn(warning, obj);
          throw new Error(warning);
        }
        if (this._objects.has(obj)) {
          const warning = "This object already exists in the pool.";
          console.warn(warning, obj);
          throw new Error(warning);
        }
        this._objects.add(obj);
        obj.disposed.connect(this._onInstanceDisposed, this);
        if (Private36.injectedProperty.get(obj)) {
          return;
        }
        if (this._restore) {
          const { connector } = this._restore;
          const objName = this._restore.name(obj);
          if (objName) {
            const name2 = `${this.namespace}:${objName}`;
            const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
            Private36.nameProperty.set(obj, name2);
            await connector.save(name2, { data });
          }
        }
        this._added.emit(obj);
      }
      /**
       * Dispose of the resources held by the pool.
       *
       * #### Notes
       * Disposing a pool does not affect the underlying data in the data connector,
       * it simply disposes the client-side pool without making any connector calls.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._current = null;
        this._isDisposed = true;
        this._objects.clear();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Find the first object in the pool that satisfies a filter function.
       *
       * @param - fn The filter function to call on each object.
       */
      find(fn) {
        const values = this._objects.values();
        for (const value of values) {
          if (fn(value)) {
            return value;
          }
        }
        return void 0;
      }
      /**
       * Iterate through each object in the pool.
       *
       * @param fn - The function to call on each object.
       */
      forEach(fn) {
        this._objects.forEach(fn);
      }
      /**
       * Filter the objects in the pool based on a predicate.
       *
       * @param fn - The function by which to filter.
       */
      filter(fn) {
        const filtered = [];
        this.forEach((obj) => {
          if (fn(obj)) {
            filtered.push(obj);
          }
        });
        return filtered;
      }
      /**
       * Inject an object into the restorable pool without the pool handling its
       * restoration lifecycle.
       *
       * @param obj - The object to inject into the pool.
       */
      inject(obj) {
        Private36.injectedProperty.set(obj, true);
        return this.add(obj);
      }
      /**
       * Check if this pool has the specified object.
       *
       * @param obj - The object whose existence is being checked.
       */
      has(obj) {
        return this._objects.has(obj);
      }
      /**
       * Restore the objects in this pool's namespace.
       *
       * @param options - The configuration options that describe restoration.
       *
       * @returns A promise that resolves when restoration has completed.
       *
       * #### Notes
       * This function should almost never be invoked by client code. Its primary
       * use case is to be invoked by a layout restorer plugin that handles
       * multiple restorable pools and, when ready, asks them each to restore their
       * respective objects.
       */
      async restore(options) {
        if (this._hasRestored) {
          throw new Error("This pool has already been restored.");
        }
        this._hasRestored = true;
        const { command, connector, registry, when: when2 } = options;
        const namespace = this.namespace;
        const promises = when2 ? [connector.list(namespace)].concat(when2) : [connector.list(namespace)];
        this._restore = options;
        const [saved] = await Promise.all(promises);
        const values = await Promise.all(saved.ids.map(async (id, index) => {
          const value = saved.values[index];
          const args = value && value.data;
          if (args === void 0) {
            return connector.remove(id);
          }
          return registry.execute(command, args).catch(() => connector.remove(id));
        }));
        this._restored.resolve();
        return values;
      }
      /**
       * Save the restore data for a given object.
       *
       * @param obj - The object being saved.
       */
      async save(obj) {
        var _a, _b;
        const injected = Private36.injectedProperty.get(obj);
        if (!this._restore || !this.has(obj) || injected) {
          return;
        }
        const { connector } = this._restore;
        const objName = this._restore.name(obj);
        const oldName = Private36.nameProperty.get(obj);
        const newName = objName ? `${this.namespace}:${objName}` : "";
        if (oldName && oldName !== newName) {
          await connector.remove(oldName);
        }
        Private36.nameProperty.set(obj, newName);
        if (newName) {
          const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
          await connector.save(newName, { data });
        }
        if (oldName !== newName) {
          this._updated.emit(obj);
        }
      }
      /**
       * Clean up after disposed objects.
       */
      _onInstanceDisposed(obj) {
        this._objects.delete(obj);
        if (obj === this._current) {
          this._current = null;
          this._currentChanged.emit(this._current);
        }
        if (Private36.injectedProperty.get(obj)) {
          return;
        }
        if (!this._restore) {
          return;
        }
        const { connector } = this._restore;
        const name2 = Private36.nameProperty.get(obj);
        if (name2) {
          void connector.remove(name2);
        }
      }
    };
    exports2.RestorablePool = RestorablePool2;
    var Private36;
    (function(Private37) {
      Private37.injectedProperty = new properties_1.AttachedProperty({
        name: "injected",
        create: () => false
      });
      Private37.nameProperty = new properties_1.AttachedProperty({
        name: "name",
        create: () => ""
      });
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/statedb/lib/statedb.js
var require_statedb2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/statedb/lib/statedb.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StateDB = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var StateDB = class {
      /**
       * Create a new state database.
       *
       * @param options - The instantiation options for a state database.
       */
      constructor(options = {}) {
        this._changed = new signaling_1.Signal(this);
        const { connector, transform: transform2 } = options;
        this._connector = connector || new StateDB.Connector();
        if (!transform2) {
          this._ready = Promise.resolve(void 0);
        } else {
          this._ready = transform2.then((transformation) => {
            const { contents, type } = transformation;
            switch (type) {
              case "cancel":
                return;
              case "clear":
                return this._clear();
              case "merge":
                return this._merge(contents || {});
              case "overwrite":
                return this._overwrite(contents || {});
              default:
                return;
            }
          });
        }
      }
      /**
       * A signal that emits the change type any time a value changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Clear the entire database.
       */
      async clear() {
        await this._ready;
        await this._clear();
      }
      /**
       * Retrieve a saved bundle from the database.
       *
       * @param id - The identifier used to retrieve a data bundle.
       *
       * @returns A promise that bears a data payload if available.
       *
       * #### Notes
       * The `id` values of stored items in the state database are formatted:
       * `'namespace:identifier'`, which is the same convention that command
       * identifiers in JupyterLab use as well. While this is not a technical
       * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
       * using the `list(namespace: string)` method.
       *
       * The promise returned by this method may be rejected if an error occurs in
       * retrieving the data. Non-existence of an `id` will succeed with the `value`
       * `undefined`.
       */
      async fetch(id) {
        await this._ready;
        return this._fetch(id);
      }
      /**
       * Retrieve all the saved bundles for a namespace.
       *
       * @param filter - The namespace prefix to retrieve.
       *
       * @returns A promise that bears a collection of payloads for a namespace.
       *
       * #### Notes
       * Namespaces are entirely conventional entities. The `id` values of stored
       * items in the state database are formatted: `'namespace:identifier'`, which
       * is the same convention that command identifiers in JupyterLab use as well.
       *
       * If there are any errors in retrieving the data, they will be logged to the
       * console in order to optimistically return any extant data without failing.
       * This promise will always succeed.
       */
      async list(namespace) {
        await this._ready;
        return this._list(namespace);
      }
      /**
       * Remove a value from the database.
       *
       * @param id - The identifier for the data being removed.
       *
       * @returns A promise that is rejected if remove fails and succeeds otherwise.
       */
      async remove(id) {
        await this._ready;
        await this._remove(id);
        this._changed.emit({ id, type: "remove" });
      }
      /**
       * Save a value in the database.
       *
       * @param id - The identifier for the data being saved.
       *
       * @param value - The data being saved.
       *
       * @returns A promise that is rejected if saving fails and succeeds otherwise.
       *
       * #### Notes
       * The `id` values of stored items in the state database are formatted:
       * `'namespace:identifier'`, which is the same convention that command
       * identifiers in JupyterLab use as well. While this is not a technical
       * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
       * using the `list(namespace: string)` method.
       */
      async save(id, value) {
        await this._ready;
        await this._save(id, value);
        this._changed.emit({ id, type: "save" });
      }
      /**
       * Return a serialized copy of the state database's entire contents.
       *
       * @returns A promise that resolves with the database contents as JSON.
       */
      async toJSON() {
        await this._ready;
        const { ids, values } = await this._list();
        return values.reduce((acc, val, idx) => {
          acc[ids[idx]] = val;
          return acc;
        }, {});
      }
      /**
       * Clear the entire database.
       */
      async _clear() {
        await Promise.all((await this._list()).ids.map((id) => this._remove(id)));
      }
      /**
       * Fetch a value from the database.
       */
      async _fetch(id) {
        const value = await this._connector.fetch(id);
        if (value) {
          return JSON.parse(value).v;
        }
      }
      /**
       * Fetch a list from the database.
       */
      async _list(namespace = "") {
        const { ids, values } = await this._connector.list(namespace);
        return {
          ids,
          values: values.map((val) => JSON.parse(val).v)
        };
      }
      /**
       * Merge data into the state database.
       */
      async _merge(contents) {
        await Promise.all(Object.keys(contents).map((key2) => contents[key2] && this._save(key2, contents[key2])));
      }
      /**
       * Overwrite the entire database with new contents.
       */
      async _overwrite(contents) {
        await this._clear();
        await this._merge(contents);
      }
      /**
       * Remove a key in the database.
       */
      async _remove(id) {
        return this._connector.remove(id);
      }
      /**
       * Save a key and its value in the database.
       */
      async _save(id, value) {
        return this._connector.save(id, JSON.stringify({ v: value }));
      }
    };
    exports2.StateDB = StateDB;
    (function(StateDB2) {
      class Connector {
        constructor() {
          this._storage = {};
        }
        /**
         * Retrieve an item from the data connector.
         */
        async fetch(id) {
          return this._storage[id];
        }
        /**
         * Retrieve the list of items available from the data connector.
         *
         * @param namespace - If not empty, only keys whose first token before `:`
         * exactly match `namespace` will be returned, e.g. `foo` in `foo:bar`.
         */
        async list(namespace = "") {
          return Object.keys(this._storage).reduce((acc, val) => {
            if (namespace === "" ? true : namespace === val.split(":")[0]) {
              acc.ids.push(val);
              acc.values.push(this._storage[val]);
            }
            return acc;
          }, { ids: [], values: [] });
        }
        /**
         * Remove a value using the data connector.
         */
        async remove(id) {
          delete this._storage[id];
        }
        /**
         * Save a value using the data connector.
         */
        async save(id, value) {
          this._storage[id] = value;
        }
      }
      StateDB2.Connector = Connector;
    })(StateDB || (exports2.StateDB = StateDB = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/statedb/lib/tokens.js
var require_tokens2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/statedb/lib/tokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IStateDB = void 0;
    var coreutils_12 = require_dist();
    exports2.IStateDB = new coreutils_12.Token("@jupyterlab/coreutils:IStateDB", `A service for the JupyterLab state database.
  Use this if you want to store data that will persist across page loads.
  See "state database" for more information.`);
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/statedb/lib/index.js
var require_lib13 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/statedb/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_dataconnector2(), exports2);
    __exportStar2(require_interfaces4(), exports2);
    __exportStar2(require_restorablepool2(), exports2);
    __exportStar2(require_statedb2(), exports2);
    __exportStar2(require_tokens2(), exports2);
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/widgettracker.js
var import_statedb, WidgetTracker;
var init_widgettracker = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/widgettracker.js"() {
    import_statedb = __toESM(require_lib13());
    init_index_es63();
    init_index_es618();
    WidgetTracker = class {
      /**
       * Create a new widget tracker.
       *
       * @param options - The instantiation options for a widget tracker.
       */
      constructor(options) {
        this._currentChanged = new Signal(this);
        this._deferred = null;
        this._isDisposed = false;
        this._widgetAdded = new Signal(this);
        this._widgetUpdated = new Signal(this);
        const focus = this._focusTracker = new FocusTracker();
        const pool = this._pool = new import_statedb.RestorablePool(options);
        this.namespace = options.namespace;
        focus.currentChanged.connect((_, current) => {
          if (current.newValue !== this.currentWidget) {
            pool.current = current.newValue;
          }
        }, this);
        pool.added.connect((_, widget) => {
          this._widgetAdded.emit(widget);
        }, this);
        pool.currentChanged.connect((_, widget) => {
          if (widget === null && focus.currentWidget) {
            pool.current = focus.currentWidget;
            return;
          }
          this.onCurrentChanged(widget);
          this._currentChanged.emit(widget);
        }, this);
        pool.updated.connect((_, widget) => {
          this._widgetUpdated.emit(widget);
        }, this);
      }
      /**
       * A signal emitted when the current widget changes.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * The current widget is the most recently focused or added widget.
       *
       * #### Notes
       * It is the most recently focused widget, or the most recently added
       * widget if no widget has taken focus.
       */
      get currentWidget() {
        return this._pool.current || null;
      }
      /**
       * A promise resolved when the tracker has been restored.
       */
      get restored() {
        if (this._deferred) {
          return Promise.resolve();
        } else {
          return this._pool.restored;
        }
      }
      /**
       * The number of widgets held by the tracker.
       */
      get size() {
        return this._pool.size;
      }
      /**
       * A signal emitted when a widget is added.
       *
       * #### Notes
       * This signal will only fire when a widget is added to the tracker. It will
       * not fire if a widget is injected into the tracker.
       */
      get widgetAdded() {
        return this._widgetAdded;
      }
      /**
       * A signal emitted when a widget is updated.
       */
      get widgetUpdated() {
        return this._widgetUpdated;
      }
      /**
       * Add a new widget to the tracker.
       *
       * @param widget - The widget being added.
       *
       * #### Notes
       * The widget passed into the tracker is added synchronously; its existence in
       * the tracker can be checked with the `has()` method. The promise this method
       * returns resolves after the widget has been added and saved to an underlying
       * restoration connector, if one is available.
       *
       * The newly added widget becomes the current widget unless the focus tracker
       * already had a focused widget.
       */
      async add(widget) {
        this._focusTracker.add(widget);
        await this._pool.add(widget);
        if (!this._focusTracker.activeWidget) {
          this._pool.current = widget;
        }
      }
      /**
       * Test whether the tracker is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the tracker.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._pool.dispose();
        this._focusTracker.dispose();
        Signal.clearData(this);
      }
      /**
       * Find the first widget in the tracker that satisfies a filter function.
       *
       * @param - fn The filter function to call on each widget.
       *
       * #### Notes
       * If no widget is found, the value returned is `undefined`.
       */
      find(fn) {
        return this._pool.find(fn);
      }
      /**
       * Iterate through each widget in the tracker.
       *
       * @param fn - The function to call on each widget.
       */
      forEach(fn) {
        return this._pool.forEach(fn);
      }
      /**
       * Filter the widgets in the tracker based on a predicate.
       *
       * @param fn - The function by which to filter.
       */
      filter(fn) {
        return this._pool.filter(fn);
      }
      /**
       * Inject a foreign widget into the widget tracker.
       *
       * @param widget - The widget to inject into the tracker.
       *
       * #### Notes
       * Injected widgets will not have their state saved by the tracker.
       *
       * The primary use case for widget injection is for a plugin that offers a
       * sub-class of an extant plugin to have its instances share the same commands
       * as the parent plugin (since most relevant commands will use the
       * `currentWidget` of the parent plugin's widget tracker). In this situation,
       * the sub-class plugin may well have its own widget tracker for layout and
       * state restoration in addition to injecting its widgets into the parent
       * plugin's widget tracker.
       */
      inject(widget) {
        return this._pool.inject(widget);
      }
      /**
       * Check if this tracker has the specified widget.
       *
       * @param widget - The widget whose existence is being checked.
       */
      has(widget) {
        return this._pool.has(widget);
      }
      /**
       * Restore the widgets in this tracker's namespace.
       *
       * @param options - The configuration options that describe restoration.
       *
       * @returns A promise that resolves when restoration has completed.
       *
       * #### Notes
       * This function should not typically be invoked by client code.
       * Its primary use case is to be invoked by a restorer.
       */
      async restore(options) {
        const deferred = this._deferred;
        if (deferred) {
          this._deferred = null;
          return this._pool.restore(deferred);
        }
        if (options) {
          return this._pool.restore(options);
        }
        console.warn("No options provided to restore the tracker.");
      }
      /**
       * Save the restore options for this tracker, but do not restore yet.
       *
       * @param options - The configuration options that describe restoration.
       *
       * ### Notes
       * This function is useful when starting the shell in 'single-document' mode,
       * to avoid restoring all useless widgets. It should not ordinarily be called
       * by client code.
       */
      defer(options) {
        this._deferred = options;
      }
      /**
       * Save the restore data for a given widget.
       *
       * @param widget - The widget being saved.
       */
      async save(widget) {
        return this._pool.save(widget);
      }
      /**
       * Handle the current change event.
       *
       * #### Notes
       * The default implementation is a no-op.
       */
      onCurrentChanged(value) {
      }
    };
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/dialog.js
function showDialog(options = {}) {
  const dialog = new Dialog3(options);
  return dialog.launch();
}
var import_coreutils13, React15, Dialog3, Private30;
var init_dialog5 = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/dialog.js"() {
    init_lib();
    init_lib5();
    init_index_es624();
    import_coreutils13 = __toESM(require_dist());
    init_index_es627();
    init_index_es618();
    React15 = __toESM(require_react());
    init_widgettracker();
    Dialog3 = class extends Widget {
      /**
       * Create a dialog panel instance.
       *
       * @param options - The dialog setup options.
       */
      constructor(options = {}) {
        const dialogNode = document.createElement("dialog");
        dialogNode.ariaModal = "true";
        super({ node: dialogNode });
        this._ready = new import_coreutils13.PromiseDelegate();
        this._focusNodeSelector = "";
        this.addClass("jp-Dialog");
        const normalized = Private30.handleOptions(options);
        const renderer = normalized.renderer;
        this._host = normalized.host;
        this._defaultButton = normalized.defaultButton;
        this._buttons = normalized.buttons;
        this._hasClose = normalized.hasClose;
        this._buttonNodes = this._buttons.map((b) => renderer.createButtonNode(b));
        this._checkboxNode = null;
        this._lastMouseDownInDialog = false;
        if (normalized.checkbox) {
          const { label = "", caption = "", checked = false, className = "" } = normalized.checkbox;
          this._checkboxNode = renderer.createCheckboxNode({
            label,
            caption: caption !== null && caption !== void 0 ? caption : label,
            checked,
            className
          });
        }
        const layout = this.layout = new PanelLayout();
        const content = new Panel();
        content.addClass("jp-Dialog-content");
        if (typeof options.body === "string") {
          content.addClass("jp-Dialog-content-small");
          dialogNode.ariaLabel = [normalized.title, options.body].join(" ");
        }
        layout.addWidget(content);
        this._body = normalized.body;
        const header = renderer.createHeader(normalized.title, () => this.reject(), options);
        const body = renderer.createBody(normalized.body);
        const footer = renderer.createFooter(this._buttonNodes, this._checkboxNode);
        content.addWidget(header);
        content.addWidget(body);
        content.addWidget(footer);
        this._bodyWidget = body;
        this._primary = this._buttonNodes[this._defaultButton];
        this._focusNodeSelector = options.focusNodeSelector;
        void Dialog3.tracker.add(this);
      }
      /**
       * A promise that resolves when the Dialog first rendering is done.
       */
      get ready() {
        return this._ready.promise;
      }
      /**
       * Dispose of the resources used by the dialog.
       */
      dispose() {
        const promise = this._promise;
        if (promise) {
          this._promise = null;
          promise.reject(void 0);
          ArrayExt7.removeFirstOf(Private30.launchQueue, promise.promise);
        }
        super.dispose();
      }
      /**
       * Launch the dialog as a modal window.
       *
       * @returns a promise that resolves with the result of the dialog.
       */
      launch() {
        if (this._promise) {
          return this._promise.promise;
        }
        const promise = this._promise = new import_coreutils13.PromiseDelegate();
        const promises = Promise.all(Private30.launchQueue);
        Private30.launchQueue.push(this._promise.promise);
        return promises.then(() => {
          if (!this._promise) {
            return Promise.resolve({
              button: Dialog3.cancelButton(),
              isChecked: null,
              value: null
            });
          }
          Widget.attach(this, this._host);
          return promise.promise;
        });
      }
      /**
       * Resolve the current dialog.
       *
       * @param index - An optional index to the button to resolve.
       *
       * #### Notes
       * Will default to the defaultIndex.
       * Will resolve the current `show()` with the button value.
       * Will be a no-op if the dialog is not shown.
       */
      resolve(index) {
        if (!this._promise) {
          return;
        }
        if (index === void 0) {
          index = this._defaultButton;
        }
        this._resolve(this._buttons[index]);
      }
      /**
       * Reject the current dialog with a default reject value.
       *
       * #### Notes
       * Will be a no-op if the dialog is not shown.
       */
      reject() {
        if (!this._promise) {
          return;
        }
        this._resolve(Dialog3.cancelButton());
      }
      /**
       * Handle the DOM events for the directory listing.
       *
       * @param event - The DOM event sent to the widget.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeydown(event);
            break;
          case "mousedown":
            this._evtMouseDown(event);
            break;
          case "click":
            this._evtClick(event);
            break;
          case "focus":
            this._evtFocus(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
          default:
            break;
        }
      }
      /**
       *  A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        const node = this.node;
        node.addEventListener("keydown", this, true);
        node.addEventListener("contextmenu", this, true);
        node.addEventListener("click", this, true);
        document.addEventListener("mousedown", this, true);
        document.addEventListener("focus", this, true);
        this._first = Private30.findFirstFocusable(this.node);
        this._original = document.activeElement;
        const setFocus = () => {
          var _a;
          if (this._focusNodeSelector) {
            const body = this.node.querySelector(".jp-Dialog-body");
            const el = body === null || body === void 0 ? void 0 : body.querySelector(this._focusNodeSelector);
            if (el) {
              this._primary = el;
            }
          }
          (_a = this._primary) === null || _a === void 0 ? void 0 : _a.focus();
          this._ready.resolve();
        };
        if (this._bodyWidget instanceof ReactWidget && this._bodyWidget.renderPromise !== void 0) {
          this._bodyWidget.renderPromise.then(() => {
            setFocus();
          }).catch(() => {
            console.error("Error while loading Dialog's body");
          });
        } else {
          setFocus();
        }
      }
      /**
       *  A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        const node = this.node;
        node.removeEventListener("keydown", this, true);
        node.removeEventListener("contextmenu", this, true);
        node.removeEventListener("click", this, true);
        document.removeEventListener("focus", this, true);
        document.removeEventListener("mousedown", this, true);
        this._original.focus();
      }
      /**
       * A message handler invoked on a `'close-request'` message.
       */
      onCloseRequest(msg) {
        if (this._promise) {
          this.reject();
        }
        super.onCloseRequest(msg);
      }
      /**
       * Handle the `'click'` event for a dialog button.
       *
       * @param event - The DOM event sent to the widget
       */
      _evtClick(event) {
        const content = this.node.getElementsByClassName("jp-Dialog-content")[0];
        if (!content.contains(event.target)) {
          event.stopPropagation();
          event.preventDefault();
          if (this._hasClose && !this._lastMouseDownInDialog) {
            this.reject();
          }
          return;
        }
        for (const buttonNode of this._buttonNodes) {
          if (buttonNode.contains(event.target)) {
            const index = this._buttonNodes.indexOf(buttonNode);
            this.resolve(index);
          }
        }
      }
      /**
       * Handle the `'keydown'` event for the widget.
       *
       * @param event - The DOM event sent to the widget
       */
      _evtKeydown(event) {
        switch (event.keyCode) {
          case 27:
            event.stopPropagation();
            event.preventDefault();
            if (this._hasClose) {
              this.reject();
            }
            break;
          case 37: {
            const activeEl = document.activeElement;
            if (activeEl instanceof HTMLButtonElement) {
              let idx = this._buttonNodes.indexOf(activeEl) - 1;
              if (idx < 0) {
                idx = this._buttonNodes.length - 1;
              }
              const node = this._buttonNodes[idx];
              event.stopPropagation();
              event.preventDefault();
              node.focus();
            }
            break;
          }
          case 39: {
            const activeEl = document.activeElement;
            if (activeEl instanceof HTMLButtonElement) {
              let idx = this._buttonNodes.indexOf(activeEl) + 1;
              if (idx == this._buttons.length) {
                idx = 0;
              }
              const node = this._buttonNodes[idx];
              event.stopPropagation();
              event.preventDefault();
              node.focus();
            }
            break;
          }
          case 9: {
            const node = this._buttonNodes[this._buttons.length - 1];
            if (document.activeElement === node && !event.shiftKey) {
              event.stopPropagation();
              event.preventDefault();
              this._first.focus();
            }
            break;
          }
          case 13: {
            event.stopPropagation();
            event.preventDefault();
            const activeEl = document.activeElement;
            let index;
            if (activeEl instanceof HTMLButtonElement) {
              index = this._buttonNodes.indexOf(activeEl);
            }
            this.resolve(index);
            break;
          }
          default:
            break;
        }
      }
      /**
       * Handle the `'focus'` event for the widget.
       *
       * @param event - The DOM event sent to the widget
       */
      _evtFocus(event) {
        var _a;
        const target2 = event.target;
        if (!this.node.contains(target2)) {
          event.stopPropagation();
          (_a = this._buttonNodes[this._defaultButton]) === null || _a === void 0 ? void 0 : _a.focus();
        }
      }
      /**
       * Handle the `'mousedown'` event for the widget.
       *
       * @param event - The DOM event sent to the widget
       */
      _evtMouseDown(event) {
        const content = this.node.getElementsByClassName("jp-Dialog-content")[0];
        const target2 = event.target;
        this._lastMouseDownInDialog = content.contains(target2);
      }
      /**
       * Resolve a button item.
       */
      _resolve(button) {
        var _a, _b, _c;
        const promise = this._promise;
        if (!promise) {
          this.dispose();
          return;
        }
        this._promise = null;
        ArrayExt7.removeFirstOf(Private30.launchQueue, promise.promise);
        const body = this._body;
        let value = null;
        if (button.accept && body instanceof Widget && typeof body.getValue === "function") {
          value = body.getValue();
        }
        this.dispose();
        promise.resolve({
          button,
          isChecked: (_c = (_b = (_a = this._checkboxNode) === null || _a === void 0 ? void 0 : _a.querySelector("input")) === null || _b === void 0 ? void 0 : _b.checked) !== null && _c !== void 0 ? _c : null,
          value
        });
      }
    };
    (function(Dialog4) {
      Dialog4.translator = nullTranslator;
      function createButton(value) {
        value.accept = value.accept !== false;
        const trans = Dialog4.translator.load("jupyterlab");
        const defaultLabel = value.accept ? trans.__("Ok") : trans.__("Cancel");
        return {
          ariaLabel: value.ariaLabel || value.label || defaultLabel,
          label: value.label || defaultLabel,
          iconClass: value.iconClass || "",
          iconLabel: value.iconLabel || "",
          caption: value.caption || "",
          className: value.className || "",
          accept: value.accept,
          actions: value.actions || [],
          displayType: value.displayType || "default"
        };
      }
      Dialog4.createButton = createButton;
      function cancelButton(options = {}) {
        options.accept = false;
        return createButton(options);
      }
      Dialog4.cancelButton = cancelButton;
      function okButton(options = {}) {
        options.accept = true;
        return createButton(options);
      }
      Dialog4.okButton = okButton;
      function warnButton(options = {}) {
        options.displayType = "warn";
        return createButton(options);
      }
      Dialog4.warnButton = warnButton;
      function flush() {
        Dialog4.tracker.forEach((dialog) => {
          dialog.dispose();
        });
      }
      Dialog4.flush = flush;
      class Renderer {
        /**
         * Create the header of the dialog.
         *
         * @param title - The title of the dialog.
         *
         * @returns A widget for the dialog header.
         */
        createHeader(title, reject = () => {
        }, options = {}) {
          let header;
          const handleMouseDown = (event) => {
            if (event.button === 0) {
              event.preventDefault();
              reject();
            }
          };
          const handleKeyDown = (event) => {
            const { key: key2 } = event;
            if (key2 === "Enter" || key2 === " ") {
              reject();
            }
          };
          if (typeof title === "string") {
            const trans = Dialog4.translator.load("jupyterlab");
            header = ReactWidget.create(React15.createElement(
              React15.Fragment,
              null,
              title,
              options.hasClose && React15.createElement(
                Button,
                { className: "jp-Dialog-close-button", onMouseDown: handleMouseDown, onKeyDown: handleKeyDown, title: trans.__("Cancel"), minimal: true },
                React15.createElement(LabIcon.resolveReact, { icon: closeIcon, tag: "span" })
              )
            ));
          } else {
            header = ReactWidget.create(title);
          }
          header.addClass("jp-Dialog-header");
          Styling.styleNode(header.node);
          return header;
        }
        /**
         * Create the body of the dialog.
         *
         * @param value - The input value for the body.
         *
         * @returns A widget for the body.
         */
        createBody(value) {
          const styleReactWidget = (widget) => {
            if (widget.renderPromise !== void 0) {
              widget.renderPromise.then(() => {
                Styling.styleNode(widget.node);
              }).catch(() => {
                console.error("Error while loading Dialog's body");
              });
            } else {
              Styling.styleNode(widget.node);
            }
          };
          let body;
          if (typeof value === "string") {
            body = new Widget({ node: document.createElement("span") });
            body.node.textContent = value;
          } else if (value instanceof Widget) {
            body = value;
            if (body instanceof ReactWidget) {
              styleReactWidget(body);
            } else {
              Styling.styleNode(body.node);
            }
          } else {
            body = ReactWidget.create(value);
            MessageLoop3.sendMessage(body, Widget.Msg.UpdateRequest);
            styleReactWidget(body);
          }
          body.addClass("jp-Dialog-body");
          return body;
        }
        /**
         * Create the footer of the dialog.
         *
         * @param buttons - The buttons nodes to add to the footer.
         * @param checkbox - The checkbox node to add to the footer.
         *
         * @returns A widget for the footer.
         */
        createFooter(buttons, checkbox) {
          const footer = new Widget();
          footer.addClass("jp-Dialog-footer");
          if (checkbox) {
            footer.node.appendChild(checkbox);
            footer.node.insertAdjacentHTML("beforeend", '<div class="jp-Dialog-spacer"></div>');
          }
          for (const button of buttons) {
            footer.node.appendChild(button);
          }
          Styling.styleNode(footer.node);
          return footer;
        }
        /**
         * Create a button node for the dialog.
         *
         * @param button - The button data.
         *
         * @returns A node for the button.
         */
        createButtonNode(button) {
          const e = document.createElement("button");
          e.className = this.createItemClass(button);
          e.appendChild(this.renderIcon(button));
          e.appendChild(this.renderLabel(button));
          return e;
        }
        /**
         * Create a checkbox node for the dialog.
         *
         * @param checkbox - The checkbox data.
         *
         * @returns A node for the checkbox.
         */
        createCheckboxNode(checkbox) {
          const e = document.createElement("label");
          e.className = "jp-Dialog-checkbox";
          if (checkbox.className) {
            e.classList.add(checkbox.className);
          }
          e.title = checkbox.caption;
          e.textContent = checkbox.label;
          const input = document.createElement("input");
          input.type = "checkbox";
          input.checked = !!checkbox.checked;
          e.insertAdjacentElement("afterbegin", input);
          return e;
        }
        /**
         * Create the class name for the button.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the button.
         */
        createItemClass(data) {
          let name2 = "jp-Dialog-button";
          if (data.accept) {
            name2 += " jp-mod-accept";
          } else {
            name2 += " jp-mod-reject";
          }
          if (data.displayType === "warn") {
            name2 += " jp-mod-warn";
          }
          const extra = data.className;
          if (extra) {
            name2 += ` ${extra}`;
          }
          return name2;
        }
        /**
         * Render an icon element for a dialog item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns An HTML element representing the icon.
         */
        renderIcon(data) {
          const e = document.createElement("div");
          e.className = this.createIconClass(data);
          e.appendChild(document.createTextNode(data.iconLabel));
          return e;
        }
        /**
         * Create the class name for the button icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          const name2 = "jp-Dialog-buttonIcon";
          const extra = data.iconClass;
          return extra ? `${name2} ${extra}` : name2;
        }
        /**
         * Render the label element for a button.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns An HTML element representing the item label.
         */
        renderLabel(data) {
          const e = document.createElement("div");
          e.className = "jp-Dialog-buttonLabel";
          e.title = data.caption;
          e.ariaLabel = data.ariaLabel;
          e.appendChild(document.createTextNode(data.label));
          return e;
        }
      }
      Dialog4.Renderer = Renderer;
      Dialog4.defaultRenderer = new Renderer();
      Dialog4.tracker = new WidgetTracker({
        namespace: "@jupyterlab/apputils:Dialog"
      });
    })(Dialog3 || (Dialog3 = {}));
    (function(Private36) {
      Private36.launchQueue = [];
      Private36.errorMessagePromiseCache = /* @__PURE__ */ new Map();
      function handleOptions(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const buttons = (_a = options.buttons) !== null && _a !== void 0 ? _a : [
          Dialog3.cancelButton(),
          Dialog3.okButton()
        ];
        return {
          title: (_b = options.title) !== null && _b !== void 0 ? _b : "",
          body: (_c = options.body) !== null && _c !== void 0 ? _c : "",
          host: (_d = options.host) !== null && _d !== void 0 ? _d : document.body,
          checkbox: (_e = options.checkbox) !== null && _e !== void 0 ? _e : null,
          buttons,
          defaultButton: (_f = options.defaultButton) !== null && _f !== void 0 ? _f : buttons.length - 1,
          renderer: (_g = options.renderer) !== null && _g !== void 0 ? _g : Dialog3.defaultRenderer,
          focusNodeSelector: (_h = options.focusNodeSelector) !== null && _h !== void 0 ? _h : "",
          hasClose: (_j = options.hasClose) !== null && _j !== void 0 ? _j : true
        };
      }
      Private36.handleOptions = handleOptions;
      function findFirstFocusable(node) {
        const candidateSelectors2 = [
          "input",
          "select",
          "a[href]",
          "textarea",
          "button",
          "[tabindex]"
        ].join(",");
        return node.querySelectorAll(candidateSelectors2)[0];
      }
      Private36.findFirstFocusable = findFirstFocusable;
    })(Private30 || (Private30 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/toolbar/factory.js
var import_coreutils14;
var init_factory = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/toolbar/factory.js"() {
    init_index_es624();
    import_coreutils14 = __toESM(require_dist());
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/toolbar/registry.js
var init_registry = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/toolbar/registry.js"() {
    init_index_es618();
    init_index_es63();
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/activitymonitor.js
var require_activitymonitor3 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/activitymonitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActivityMonitor = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var ActivityMonitor = class {
      /**
       * Construct a new activity monitor.
       */
      constructor(options) {
        this._timer = -1;
        this._timeout = -1;
        this._isDisposed = false;
        this._activityStopped = new signaling_1.Signal(this);
        options.signal.connect(this._onSignalFired, this);
        this._timeout = options.timeout || 1e3;
      }
      /**
       * A signal emitted when activity has ceased.
       */
      get activityStopped() {
        return this._activityStopped;
      }
      /**
       * The timeout associated with the monitor, in milliseconds.
       */
      get timeout() {
        return this._timeout;
      }
      set timeout(value) {
        this._timeout = value;
      }
      /**
       * Test whether the monitor has been disposed.
       *
       * #### Notes
       * This is a read-only property.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the activity monitor.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * A signal handler for the monitored signal.
       */
      _onSignalFired(sender, args) {
        clearTimeout(this._timer);
        this._sender = sender;
        this._args = args;
        this._timer = setTimeout(() => {
          this._activityStopped.emit({
            sender: this._sender,
            args: this._args
          });
        }, this._timeout);
      }
    };
    exports2.ActivityMonitor = ActivityMonitor;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/interfaces.js
var require_interfaces5 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/lru.js
var require_lru3 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/lru.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LruCache = void 0;
    var DEFAULT_MAX_SIZE = 128;
    var LruCache = class {
      constructor(options = {}) {
        this._map = /* @__PURE__ */ new Map();
        this._maxSize = (options === null || options === void 0 ? void 0 : options.maxSize) || DEFAULT_MAX_SIZE;
      }
      /**
       * Return the current size of the cache.
       */
      get size() {
        return this._map.size;
      }
      /**
       * Clear the values in the cache.
       */
      clear() {
        this._map.clear();
      }
      /**
       * Get a value (or null) from the cache, pushing the item to the front of the cache.
       */
      get(key2) {
        const item = this._map.get(key2) || null;
        if (item != null) {
          this._map.delete(key2);
          this._map.set(key2, item);
        }
        return item;
      }
      /**
       * Set a value in the cache, potentially evicting an old item.
       */
      set(key2, value) {
        if (this._map.size >= this._maxSize) {
          this._map.delete(this._map.keys().next().value);
        }
        this._map.set(key2, value);
      }
    };
    exports2.LruCache = LruCache;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js
var require_markdowncodeblocks3 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MarkdownCodeBlocks = void 0;
    var MarkdownCodeBlocks;
    (function(MarkdownCodeBlocks2) {
      MarkdownCodeBlocks2.CODE_BLOCK_MARKER = "```";
      const markdownExtensions = [
        ".markdown",
        ".mdown",
        ".mkdn",
        ".md",
        ".mkd",
        ".mdwn",
        ".mdtxt",
        ".mdtext",
        ".text",
        ".txt",
        ".Rmd"
      ];
      class MarkdownCodeBlock {
        constructor(startLine) {
          this.startLine = startLine;
          this.code = "";
          this.endLine = -1;
        }
      }
      MarkdownCodeBlocks2.MarkdownCodeBlock = MarkdownCodeBlock;
      function isMarkdown(extension) {
        return markdownExtensions.indexOf(extension) > -1;
      }
      MarkdownCodeBlocks2.isMarkdown = isMarkdown;
      function findMarkdownCodeBlocks(text) {
        if (!text || text === "") {
          return [];
        }
        const lines = text.split("\n");
        const codeBlocks = [];
        let currentBlock = null;
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
          const line = lines[lineIndex];
          const lineContainsMarker = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER) === 0;
          const constructingBlock = currentBlock != null;
          if (!lineContainsMarker && !constructingBlock) {
            continue;
          }
          if (!constructingBlock) {
            currentBlock = new MarkdownCodeBlock(lineIndex);
            const firstIndex = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const lastIndex = line.lastIndexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const isSingleLine = firstIndex !== lastIndex;
            if (isSingleLine) {
              currentBlock.code = line.substring(firstIndex + MarkdownCodeBlocks2.CODE_BLOCK_MARKER.length, lastIndex);
              currentBlock.endLine = lineIndex;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            }
          } else if (currentBlock) {
            if (lineContainsMarker) {
              currentBlock.endLine = lineIndex - 1;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            } else {
              currentBlock.code += line + "\n";
            }
          }
        }
        return codeBlocks;
      }
      MarkdownCodeBlocks2.findMarkdownCodeBlocks = findMarkdownCodeBlocks;
    })(MarkdownCodeBlocks || (exports2.MarkdownCodeBlocks = MarkdownCodeBlocks = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/url.js
var require_url3 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/url.js"(exports2) {
    "use strict";
    var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLExt = void 0;
    var path_1 = __require("path");
    var url_parse_1 = __importDefault3(require_url_parse());
    var URLExt;
    (function(URLExt2) {
      function parse(url) {
        if (typeof document !== "undefined" && document) {
          const a = document.createElement("a");
          a.href = url;
          return a;
        }
        return (0, url_parse_1.default)(url);
      }
      URLExt2.parse = parse;
      function getHostName(url) {
        return (0, url_parse_1.default)(url).hostname;
      }
      URLExt2.getHostName = getHostName;
      function normalize2(url) {
        return url && parse(url).toString();
      }
      URLExt2.normalize = normalize2;
      function join2(...parts) {
        let u = (0, url_parse_1.default)(parts[0], {});
        const isSchemaLess = u.protocol === "" && u.slashes;
        if (isSchemaLess) {
          u = (0, url_parse_1.default)(parts[0], "https:" + parts[0]);
        }
        const prefix = `${isSchemaLess ? "" : u.protocol}${u.slashes ? "//" : ""}${u.auth}${u.auth ? "@" : ""}${u.host}`;
        const path2 = path_1.posix.join(`${!!prefix && u.pathname[0] !== "/" ? "/" : ""}${u.pathname}`, ...parts.slice(1));
        return `${prefix}${path2 === "." ? "" : path2}`;
      }
      URLExt2.join = join2;
      function encodeParts(url) {
        return join2(...url.split("/").map(encodeURIComponent));
      }
      URLExt2.encodeParts = encodeParts;
      function objectToQueryString(value) {
        const keys = Object.keys(value).filter((key2) => key2.length > 0);
        if (!keys.length) {
          return "";
        }
        return "?" + keys.map((key2) => {
          const content = encodeURIComponent(String(value[key2]));
          return key2 + (content ? "=" + content : "");
        }).join("&");
      }
      URLExt2.objectToQueryString = objectToQueryString;
      function queryStringToObject(value) {
        return value.replace(/^\?/, "").split("&").reduce((acc, val) => {
          const [key2, value2] = val.split("=");
          if (key2.length > 0) {
            acc[key2] = decodeURIComponent(value2 || "");
          }
          return acc;
        }, {});
      }
      URLExt2.queryStringToObject = queryStringToObject;
      function isLocal(url, allowRoot = false) {
        const { protocol } = parse(url);
        return (!protocol || url.toLowerCase().indexOf(protocol) !== 0) && (allowRoot ? url.indexOf("//") !== 0 : url.indexOf("/") !== 0);
      }
      URLExt2.isLocal = isLocal;
    })(URLExt || (exports2.URLExt = URLExt = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/pageconfig.js
var require_pageconfig3 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/pageconfig.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageConfig = void 0;
    var coreutils_1 = require_dist();
    var minimist_1 = __importDefault(require_minimist());
    var url_1 = require_url3();
    var PageConfig;
    (function(PageConfig) {
      function getOption(name) {
        if (configData) {
          return configData[name] || getBodyData(name);
        }
        configData = /* @__PURE__ */ Object.create(null);
        let found = false;
        if (typeof document !== "undefined" && document) {
          const el = document.getElementById("jupyter-config-data");
          if (el) {
            configData = JSON.parse(el.textContent || "");
            found = true;
          }
        }
        if (!found && typeof process !== "undefined" && process.argv) {
          try {
            const cli = (0, minimist_1.default)(process.argv.slice(2));
            const path = __require("path");
            let fullPath = "";
            if ("jupyter-config-data" in cli) {
              fullPath = path.resolve(cli["jupyter-config-data"]);
            } else if ("JUPYTER_CONFIG_DATA" in process.env) {
              fullPath = path.resolve(process.env["JUPYTER_CONFIG_DATA"]);
            }
            if (fullPath) {
              configData = eval("require")(fullPath);
            }
          } catch (e) {
            console.error(e);
          }
        }
        if (!coreutils_1.JSONExt.isObject(configData)) {
          configData = /* @__PURE__ */ Object.create(null);
        } else {
          for (const key2 in configData) {
            if (typeof configData[key2] !== "string") {
              configData[key2] = JSON.stringify(configData[key2]);
            }
          }
        }
        return configData[name] || getBodyData(name);
      }
      PageConfig.getOption = getOption;
      function setOption(name2, value) {
        const last = getOption(name2);
        configData[name2] = value;
        return last;
      }
      PageConfig.setOption = setOption;
      function getBaseUrl() {
        return url_1.URLExt.normalize(getOption("baseUrl") || "/");
      }
      PageConfig.getBaseUrl = getBaseUrl;
      function getTreeUrl() {
        return url_1.URLExt.join(getBaseUrl(), getOption("treeUrl"));
      }
      PageConfig.getTreeUrl = getTreeUrl;
      function getShareUrl() {
        return url_1.URLExt.normalize(getOption("shareUrl") || getBaseUrl());
      }
      PageConfig.getShareUrl = getShareUrl;
      function getTreeShareUrl() {
        return url_1.URLExt.normalize(url_1.URLExt.join(getShareUrl(), getOption("treeUrl")));
      }
      PageConfig.getTreeShareUrl = getTreeShareUrl;
      function getUrl(options) {
        var _a, _b, _c, _d;
        let path2 = options.toShare ? getShareUrl() : getBaseUrl();
        const mode = (_a = options.mode) !== null && _a !== void 0 ? _a : getOption("mode");
        const workspace = (_b = options.workspace) !== null && _b !== void 0 ? _b : getOption("workspace");
        const labOrDoc = mode === "single-document" ? "doc" : "lab";
        path2 = url_1.URLExt.join(path2, labOrDoc);
        if (workspace !== PageConfig.defaultWorkspace) {
          path2 = url_1.URLExt.join(path2, "workspaces", encodeURIComponent((_c = getOption("workspace")) !== null && _c !== void 0 ? _c : PageConfig.defaultWorkspace));
        }
        const treePath = (_d = options.treePath) !== null && _d !== void 0 ? _d : getOption("treePath");
        if (treePath) {
          path2 = url_1.URLExt.join(path2, "tree", url_1.URLExt.encodeParts(treePath));
        }
        return path2;
      }
      PageConfig.getUrl = getUrl;
      PageConfig.defaultWorkspace = "default";
      function getWsUrl(baseUrl) {
        let wsUrl = getOption("wsUrl");
        if (!wsUrl) {
          baseUrl = baseUrl ? url_1.URLExt.normalize(baseUrl) : getBaseUrl();
          if (baseUrl.indexOf("http") !== 0) {
            return "";
          }
          wsUrl = "ws" + baseUrl.slice(4);
        }
        return url_1.URLExt.normalize(wsUrl);
      }
      PageConfig.getWsUrl = getWsUrl;
      function getNBConvertURL({ path: path2, format, download }) {
        const notebookPath = url_1.URLExt.encodeParts(path2);
        const url = url_1.URLExt.join(getBaseUrl(), "nbconvert", format, notebookPath);
        if (download) {
          return url + "?download=true";
        }
        return url;
      }
      PageConfig.getNBConvertURL = getNBConvertURL;
      function getToken() {
        return getOption("token") || getBodyData("jupyterApiToken");
      }
      PageConfig.getToken = getToken;
      function getNotebookVersion() {
        const notebookVersion = getOption("notebookVersion");
        if (notebookVersion === "") {
          return [0, 0, 0];
        }
        return JSON.parse(notebookVersion);
      }
      PageConfig.getNotebookVersion = getNotebookVersion;
      let configData = null;
      function getBodyData(key2) {
        if (typeof document === "undefined" || !document.body) {
          return "";
        }
        const val = document.body.dataset[key2];
        if (typeof val === "undefined") {
          return "";
        }
        return decodeURIComponent(val);
      }
      let Extension;
      (function(Extension2) {
        function populate(key2) {
          try {
            const raw = getOption(key2);
            if (raw) {
              return JSON.parse(raw);
            }
          } catch (error) {
            console.warn(`Unable to parse ${key2}.`, error);
          }
          return [];
        }
        Extension2.deferred = populate("deferredExtensions");
        Extension2.disabled = populate("disabledExtensions");
        function isDeferred(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.deferred.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDeferred = isDeferred;
        function isDisabled(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.disabled.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDisabled = isDisabled;
      })(Extension = PageConfig.Extension || (PageConfig.Extension = {}));
    })(PageConfig || (exports.PageConfig = PageConfig = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/path.js
var require_path3 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathExt = void 0;
    var path_1 = __require("path");
    var PathExt2;
    (function(PathExt3) {
      function join2(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : removeSlash(path2);
      }
      PathExt3.join = join2;
      function joinWithLeadingSlash(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : path2;
      }
      PathExt3.joinWithLeadingSlash = joinWithLeadingSlash;
      function basename(path2, ext) {
        return path_1.posix.basename(path2, ext);
      }
      PathExt3.basename = basename;
      function dirname(path2) {
        const dir = removeSlash(path_1.posix.dirname(path2));
        return dir === "." ? "" : dir;
      }
      PathExt3.dirname = dirname;
      function extname(path2) {
        return path_1.posix.extname(path2);
      }
      PathExt3.extname = extname;
      function normalize2(path2) {
        if (path2 === "") {
          return "";
        }
        return removeSlash(path_1.posix.normalize(path2));
      }
      PathExt3.normalize = normalize2;
      function resolve(...parts) {
        return removeSlash(path_1.posix.resolve(...parts));
      }
      PathExt3.resolve = resolve;
      function relative(from2, to) {
        return removeSlash(path_1.posix.relative(from2, to));
      }
      PathExt3.relative = relative;
      function normalizeExtension(extension) {
        if (extension.length > 0 && extension.indexOf(".") !== 0) {
          extension = `.${extension}`;
        }
        return extension;
      }
      PathExt3.normalizeExtension = normalizeExtension;
      function removeSlash(path2) {
        if (path2.indexOf("/") === 0) {
          path2 = path2.slice(1);
        }
        return path2;
      }
      PathExt3.removeSlash = removeSlash;
    })(PathExt2 || (exports2.PathExt = PathExt2 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/signal.js
var require_signal3 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/signal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signalToPromise = void 0;
    var coreutils_12 = require_dist();
    function signalToPromise(signal, timeout) {
      const waitForSignal = new coreutils_12.PromiseDelegate();
      function cleanup() {
        signal.disconnect(slot);
      }
      function slot(sender, args) {
        cleanup();
        waitForSignal.resolve([sender, args]);
      }
      signal.connect(slot);
      if ((timeout !== null && timeout !== void 0 ? timeout : 0) > 0) {
        setTimeout(() => {
          cleanup();
          waitForSignal.reject(`Signal not emitted within ${timeout} ms.`);
        }, timeout);
      }
      return waitForSignal.promise;
    }
    exports2.signalToPromise = signalToPromise;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/text.js
var require_text3 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/text.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Text = void 0;
    var Text3;
    (function(Text4) {
      const HAS_SURROGATES = "\u{1D41A}".length > 1;
      function jsIndexToCharIndex(jsIdx, text) {
        if (HAS_SURROGATES) {
          return jsIdx;
        }
        let charIdx = jsIdx;
        for (let i = 0; i + 1 < text.length && i < jsIdx; i++) {
          const charCode = text.charCodeAt(i);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              charIdx--;
              i++;
            }
          }
        }
        return charIdx;
      }
      Text4.jsIndexToCharIndex = jsIndexToCharIndex;
      function charIndexToJsIndex(charIdx, text) {
        if (HAS_SURROGATES) {
          return charIdx;
        }
        let jsIdx = charIdx;
        for (let i = 0; i + 1 < text.length && i < jsIdx; i++) {
          const charCode = text.charCodeAt(i);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              jsIdx++;
              i++;
            }
          }
        }
        return jsIdx;
      }
      Text4.charIndexToJsIndex = charIndexToJsIndex;
      function camelCase(str, upper = false) {
        return str.replace(/^(\w)|[\s-_:]+(\w)/g, function(match, p1, p2) {
          if (p2) {
            return p2.toUpperCase();
          } else {
            return upper ? p1.toUpperCase() : p1.toLowerCase();
          }
        });
      }
      Text4.camelCase = camelCase;
      function titleCase(str) {
        return (str || "").toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
      }
      Text4.titleCase = titleCase;
    })(Text3 || (exports2.Text = Text3 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/time.js
var require_time3 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Time = void 0;
    var UNITS = [
      { name: "years", milliseconds: 365 * 24 * 60 * 60 * 1e3 },
      { name: "months", milliseconds: 30 * 24 * 60 * 60 * 1e3 },
      { name: "days", milliseconds: 24 * 60 * 60 * 1e3 },
      { name: "hours", milliseconds: 60 * 60 * 1e3 },
      { name: "minutes", milliseconds: 60 * 1e3 },
      { name: "seconds", milliseconds: 1e3 }
    ];
    var Time;
    (function(Time2) {
      function formatHuman(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.RelativeTimeFormat(lang, { numeric: "auto" });
        const delta = new Date(value).getTime() - Date.now();
        for (let unit of UNITS) {
          const amount = Math.ceil(delta / unit.milliseconds);
          if (amount === 0) {
            continue;
          }
          return formatter.format(amount, unit.name);
        }
        return formatter.format(0, "seconds");
      }
      Time2.formatHuman = formatHuman;
      function format(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.DateTimeFormat(lang, {
          dateStyle: "short",
          timeStyle: "short"
        });
        return formatter.format(new Date(value));
      }
      Time2.format = format;
    })(Time || (exports2.Time = Time = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/index.js
var require_lib14 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/coreutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_activitymonitor3(), exports2);
    __exportStar2(require_interfaces5(), exports2);
    __exportStar2(require_lru3(), exports2);
    __exportStar2(require_markdowncodeblocks3(), exports2);
    __exportStar2(require_pageconfig3(), exports2);
    __exportStar2(require_path3(), exports2);
    __exportStar2(require_signal3(), exports2);
    __exportStar2(require_text3(), exports2);
    __exportStar2(require_time3(), exports2);
    __exportStar2(require_url3(), exports2);
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/sessioncontext.js
var import_coreutils15, import_coreutils16, React16, SessionContext, SessionContextDialogs, Private31;
var init_sessioncontext = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/sessioncontext.js"() {
    import_coreutils15 = __toESM(require_lib14());
    init_lib();
    init_index_es624();
    import_coreutils16 = __toESM(require_dist());
    init_index_es63();
    init_index_es618();
    React16 = __toESM(require_react());
    init_dialog5();
    SessionContext = class {
      /**
       * Construct a new session context.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        this._path = "";
        this._name = "";
        this._type = "";
        this._prevKernelName = "";
        this._isDisposed = false;
        this._disposed = new Signal(this);
        this._session = null;
        this._ready = new import_coreutils16.PromiseDelegate();
        this._initializing = false;
        this._initStarted = new import_coreutils16.PromiseDelegate();
        this._initPromise = new import_coreutils16.PromiseDelegate();
        this._isReady = false;
        this._isTerminating = false;
        this._isRestarting = false;
        this._kernelChanged = new Signal(this);
        this._preferenceChanged = new Signal(this);
        this._sessionChanged = new Signal(this);
        this._statusChanged = new Signal(this);
        this._connectionStatusChanged = new Signal(this);
        this._pendingInput = false;
        this._iopubMessage = new Signal(this);
        this._unhandledMessage = new Signal(this);
        this._propertyChanged = new Signal(this);
        this._dialog = null;
        this._busyDisposable = null;
        this._pendingKernelName = "";
        this._pendingSessionRequest = "";
        this.sessionManager = options.sessionManager;
        this.specsManager = options.specsManager;
        this.translator = options.translator || nullTranslator;
        this._trans = this.translator.load("jupyterlab");
        this._path = (_a = options.path) !== null && _a !== void 0 ? _a : import_coreutils16.UUID.uuid4();
        this._type = (_b = options.type) !== null && _b !== void 0 ? _b : "";
        this._name = (_c = options.name) !== null && _c !== void 0 ? _c : "";
        this._setBusy = options.setBusy;
        this._kernelPreference = (_d = options.kernelPreference) !== null && _d !== void 0 ? _d : {};
      }
      /**
       * The current session connection.
       */
      get session() {
        var _a;
        return (_a = this._session) !== null && _a !== void 0 ? _a : null;
      }
      /**
       * The session path.
       *
       * #### Notes
       * Typically `.session.path` should be used. This attribute is useful if
       * there is no current session.
       */
      get path() {
        return this._path;
      }
      /**
       * The session type.
       *
       * #### Notes
       * Typically `.session.type` should be used. This attribute is useful if
       * there is no current session.
       */
      get type() {
        return this._type;
      }
      /**
       * The session name.
       *
       * #### Notes
       * Typically `.session.name` should be used. This attribute is useful if
       * there is no current session.
       */
      get name() {
        return this._name;
      }
      /**
       * A signal emitted when the kernel connection changes, proxied from the session connection.
       */
      get kernelChanged() {
        return this._kernelChanged;
      }
      /**
       * A signal emitted when the session connection changes.
       */
      get sessionChanged() {
        return this._sessionChanged;
      }
      /**
       * A signal emitted when the kernel status changes, proxied from the kernel.
       */
      get statusChanged() {
        return this._statusChanged;
      }
      /**
       * A flag indicating if the session has ending input, proxied from the kernel.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * A signal emitted when the kernel status changes, proxied from the kernel.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * A signal emitted for iopub kernel messages, proxied from the kernel.
       */
      get iopubMessage() {
        return this._iopubMessage;
      }
      /**
       * A signal emitted for an unhandled kernel message, proxied from the kernel.
       */
      get unhandledMessage() {
        return this._unhandledMessage;
      }
      /**
       * A signal emitted when a session property changes, proxied from the current session.
       */
      get propertyChanged() {
        return this._propertyChanged;
      }
      /**
       * The kernel preference of this client session.
       *
       * This is used when selecting a new kernel, and should reflect the sort of
       * kernel the activity prefers.
       */
      get kernelPreference() {
        return this._kernelPreference;
      }
      set kernelPreference(value) {
        if (!import_coreutils16.JSONExt.deepEqual(value, this._kernelPreference)) {
          const oldValue = this._kernelPreference;
          this._kernelPreference = value;
          this._preferenceChanged.emit({
            name: "kernelPreference",
            oldValue,
            newValue: import_coreutils16.JSONExt.deepCopy(value)
          });
        }
      }
      /**
       * Signal emitted if the kernel preference changes.
       */
      get kernelPreferenceChanged() {
        return this._preferenceChanged;
      }
      /**
       * Whether the context is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that is fulfilled when the context is ready.
       */
      get ready() {
        return this._ready.promise;
      }
      /**
       * Whether the context is terminating.
       */
      get isTerminating() {
        return this._isTerminating;
      }
      /**
       * Whether the context is restarting.
       */
      get isRestarting() {
        return this._isRestarting;
      }
      /**
       * Whether the kernel is "No Kernel" or not.
       *
       * #### Notes
       * As the displayed name is translated, this can be used directly.
       */
      get hasNoKernel() {
        return this.kernelDisplayName === this.noKernelName;
      }
      /**
       * The display name of the current kernel, or a sensible alternative.
       *
       * #### Notes
       * This is a convenience function to have a consistent sensible name for the
       * kernel.
       */
      get kernelDisplayName() {
        var _a, _b, _c, _d, _e, _f, _g;
        const kernel = (_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (this._pendingKernelName === this.noKernelName) {
          return this.noKernelName;
        }
        if (this._pendingKernelName) {
          return (_d = (_c = (_b = this.specsManager.specs) === null || _b === void 0 ? void 0 : _b.kernelspecs[this._pendingKernelName]) === null || _c === void 0 ? void 0 : _c.display_name) !== null && _d !== void 0 ? _d : this._pendingKernelName;
        }
        if (!kernel) {
          return this.noKernelName;
        }
        return (_g = (_f = (_e = this.specsManager.specs) === null || _e === void 0 ? void 0 : _e.kernelspecs[kernel.name]) === null || _f === void 0 ? void 0 : _f.display_name) !== null && _g !== void 0 ? _g : kernel.name;
      }
      /**
       * A sensible status to display
       *
       * #### Notes
       * This combines the status and connection status into a single status for
       * the user.
       */
      get kernelDisplayStatus() {
        var _a, _b;
        const kernel = (_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (this._isTerminating) {
          return "terminating";
        }
        if (this._isRestarting) {
          return "restarting";
        }
        if (this._pendingKernelName === this.noKernelName) {
          return "unknown";
        }
        if (!kernel && this._pendingKernelName) {
          return "initializing";
        }
        if (!kernel && !this.isReady && this.kernelPreference.canStart !== false && this.kernelPreference.shouldStart !== false) {
          return "initializing";
        }
        return (_b = (kernel === null || kernel === void 0 ? void 0 : kernel.connectionStatus) === "connected" ? kernel === null || kernel === void 0 ? void 0 : kernel.status : kernel === null || kernel === void 0 ? void 0 : kernel.connectionStatus) !== null && _b !== void 0 ? _b : "unknown";
      }
      /**
       * The name of the previously started kernel.
       */
      get prevKernelName() {
        return this._prevKernelName;
      }
      /**
       * Test whether the context is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * A signal emitted when the poll is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Get the constant displayed name for "No Kernel"
       */
      get noKernelName() {
        return this._trans.__("No Kernel");
      }
      /**
       * Dispose of the resources held by the context.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        if (this._session) {
          if (this.kernelPreference.shutdownOnDispose) {
            this.sessionManager.shutdown(this._session.id).catch((reason) => {
              console.error(`Kernel not shut down ${reason}`);
            });
          }
          this._session.dispose();
          this._session = null;
        }
        if (this._dialog) {
          this._dialog.dispose();
        }
        if (this._busyDisposable) {
          this._busyDisposable.dispose();
          this._busyDisposable = null;
        }
        Signal.clearData(this);
      }
      /**
       * Starts new Kernel.
       *
       * @returns Whether to ask the user to pick a kernel.
       */
      async startKernel() {
        const preference = this.kernelPreference;
        if (!preference.autoStartDefault && preference.shouldStart === false) {
          return true;
        }
        let options;
        if (preference.id) {
          options = { id: preference.id };
        } else {
          const name2 = Private31.getDefaultKernel({
            specs: this.specsManager.specs,
            sessions: this.sessionManager.running(),
            preference
          });
          if (name2) {
            options = { name: name2 };
          }
        }
        if (options) {
          try {
            await this._changeKernel(options);
            return false;
          } catch (err) {
          }
        }
        return true;
      }
      /**
       * Restart the current Kernel.
       *
       * @returns A promise that resolves when the kernel is restarted.
       */
      async restartKernel() {
        var _a, _b, _c, _d, _e, _f;
        const kernel = ((_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel) || null;
        if (this._isRestarting) {
          return;
        }
        this._isRestarting = true;
        this._isReady = false;
        this._statusChanged.emit("restarting");
        try {
          await ((_c = (_b = this.session) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.restart());
          this._isReady = true;
        } catch (e) {
          console.error(e);
        }
        this._isRestarting = false;
        this._statusChanged.emit(((_e = (_d = this.session) === null || _d === void 0 ? void 0 : _d.kernel) === null || _e === void 0 ? void 0 : _e.status) || "unknown");
        this._kernelChanged.emit({
          name: "kernel",
          oldValue: kernel,
          newValue: ((_f = this.session) === null || _f === void 0 ? void 0 : _f.kernel) || null
        });
      }
      /**
       * Change the current kernel associated with the session.
       */
      async changeKernel(options = {}) {
        if (this.isDisposed) {
          throw new Error("Disposed");
        }
        await this._initStarted.promise;
        return this._changeKernel(options);
      }
      /**
       * Kill the kernel and shutdown the session.
       *
       * @returns A promise that resolves when the session is shut down.
       */
      async shutdown() {
        if (this.isDisposed || !this._initializing) {
          return;
        }
        await this._initStarted.promise;
        this._pendingSessionRequest = "";
        this._pendingKernelName = this.noKernelName;
        return this._shutdownSession();
      }
      /**
       * Initialize the session context
       *
       * @returns A promise that resolves with whether to ask the user to select a kernel.
       *
       * #### Notes
       * If a server session exists on the current path, we will connect to it.
       * If preferences include disabling `canStart` or `shouldStart`, no
       * server session will be started.
       * If a kernel id is given, we attempt to start a session with that id.
       * If a default kernel is available, we connect to it.
       * Otherwise we ask the user to select a kernel.
       */
      async initialize() {
        if (this._initializing) {
          return this._initPromise.promise;
        }
        this._initializing = true;
        const needsSelection = await this._initialize();
        if (!needsSelection) {
          this._isReady = true;
          this._ready.resolve(void 0);
        }
        if (!this._pendingSessionRequest) {
          this._initStarted.resolve(void 0);
        }
        this._initPromise.resolve(needsSelection);
        return needsSelection;
      }
      /**
       * Inner initialize function that doesn't handle promises.
       * This makes it easier to consolidate promise handling logic.
       */
      async _initialize() {
        const manager = this.sessionManager;
        await manager.ready;
        await manager.refreshRunning();
        const model = find4(manager.running(), (item) => {
          return item.path === this._path;
        });
        if (model) {
          try {
            const session = manager.connectTo({ model });
            this._handleNewSession(session);
          } catch (err) {
            void this._handleSessionError(err);
            return Promise.reject(err);
          }
        }
        return await this._startIfNecessary();
      }
      /**
       * Shut down the current session.
       */
      async _shutdownSession() {
        var _a;
        const session = this._session;
        const isTerminating = this._isTerminating;
        const isReady = this._isReady;
        this._isTerminating = true;
        this._isReady = false;
        this._statusChanged.emit("terminating");
        try {
          await (session === null || session === void 0 ? void 0 : session.shutdown());
          this._isTerminating = false;
          session === null || session === void 0 ? void 0 : session.dispose();
          this._session = null;
          const kernel = (session === null || session === void 0 ? void 0 : session.kernel) || null;
          this._statusChanged.emit("unknown");
          this._kernelChanged.emit({
            name: "kernel",
            oldValue: kernel,
            newValue: null
          });
          this._sessionChanged.emit({
            name: "session",
            oldValue: session,
            newValue: null
          });
        } catch (err) {
          this._isTerminating = isTerminating;
          this._isReady = isReady;
          const status = (_a = session === null || session === void 0 ? void 0 : session.kernel) === null || _a === void 0 ? void 0 : _a.status;
          if (status === void 0) {
            this._statusChanged.emit("unknown");
          } else {
            this._statusChanged.emit(status);
          }
          throw err;
        }
        return;
      }
      /**
       * Start the session if necessary.
       *
       * @returns Whether to ask the user to pick a kernel.
       */
      async _startIfNecessary() {
        var _a;
        const preference = this.kernelPreference;
        if (this.isDisposed || ((_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel) || preference.shouldStart === false || preference.canStart === false) {
          return false;
        }
        return this.startKernel();
      }
      /**
       * Change the kernel.
       */
      async _changeKernel(model = {}) {
        if (model.name) {
          this._pendingKernelName = model.name;
        }
        if (!this._session) {
          this._kernelChanged.emit({
            name: "kernel",
            oldValue: null,
            newValue: null
          });
        }
        if (!this._pendingSessionRequest) {
          this._initStarted.resolve(void 0);
        }
        if (this._session && !this._isTerminating) {
          try {
            await this._session.changeKernel(model);
            return this._session.kernel;
          } catch (err) {
            void this._handleSessionError(err);
            throw err;
          }
        }
        const dirName = import_coreutils15.PathExt.dirname(this._path);
        const requestId = this._pendingSessionRequest = import_coreutils15.PathExt.join(dirName, import_coreutils16.UUID.uuid4());
        try {
          this._statusChanged.emit("starting");
          const session = await this.sessionManager.startNew({
            path: requestId,
            type: this._type,
            name: this._name,
            kernel: model
          });
          if (this._pendingSessionRequest !== session.path) {
            await session.shutdown();
            session.dispose();
            return null;
          }
          await session.setPath(this._path);
          await session.setName(this._name);
          if (this._session && !this._isTerminating) {
            await this._shutdownSession();
          }
          return this._handleNewSession(session);
        } catch (err) {
          void this._handleSessionError(err);
          throw err;
        }
      }
      /**
       * Handle a new session object.
       */
      _handleNewSession(session) {
        var _a, _b, _c;
        if (this.isDisposed) {
          throw Error("Disposed");
        }
        if (!this._isReady) {
          this._isReady = true;
          this._ready.resolve(void 0);
        }
        if (this._session) {
          this._session.dispose();
        }
        this._session = session;
        this._pendingKernelName = "";
        if (session) {
          this._prevKernelName = (_b = (_a = session.kernel) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "";
          session.disposed.connect(this._onSessionDisposed, this);
          session.propertyChanged.connect(this._onPropertyChanged, this);
          session.kernelChanged.connect(this._onKernelChanged, this);
          session.statusChanged.connect(this._onStatusChanged, this);
          session.connectionStatusChanged.connect(this._onConnectionStatusChanged, this);
          session.pendingInput.connect(this._onPendingInput, this);
          session.iopubMessage.connect(this._onIopubMessage, this);
          session.unhandledMessage.connect(this._onUnhandledMessage, this);
          if (session.path !== this._path) {
            this._onPropertyChanged(session, "path");
          }
          if (session.name !== this._name) {
            this._onPropertyChanged(session, "name");
          }
          if (session.type !== this._type) {
            this._onPropertyChanged(session, "type");
          }
        }
        this._sessionChanged.emit({
          name: "session",
          oldValue: null,
          newValue: session
        });
        this._kernelChanged.emit({
          oldValue: null,
          newValue: (session === null || session === void 0 ? void 0 : session.kernel) || null,
          name: "kernel"
        });
        this._statusChanged.emit(((_c = session === null || session === void 0 ? void 0 : session.kernel) === null || _c === void 0 ? void 0 : _c.status) || "unknown");
        return (session === null || session === void 0 ? void 0 : session.kernel) || null;
      }
      /**
       * Handle an error in session startup.
       */
      async _handleSessionError(err) {
        this._handleNewSession(null);
        let traceback = "";
        let message = "";
        try {
          traceback = err.traceback;
          message = err.message;
        } catch (err2) {
        }
        await this._displayKernelError(message, traceback);
      }
      /**
       * Display kernel error
       */
      async _displayKernelError(message, traceback) {
        const body = React16.createElement(
          "div",
          null,
          message && React16.createElement("pre", null, message),
          traceback && React16.createElement(
            "details",
            { className: "jp-mod-wide" },
            React16.createElement("pre", null, traceback)
          )
        );
        const dialog = this._dialog = new Dialog3({
          title: this._trans.__("Error Starting Kernel"),
          body,
          buttons: [Dialog3.okButton()]
        });
        await dialog.launch();
        this._dialog = null;
      }
      /**
       * Handle a session termination.
       */
      _onSessionDisposed() {
        if (this._session) {
          const oldValue = this._session;
          this._session = null;
          const newValue = this._session;
          this._sessionChanged.emit({ name: "session", oldValue, newValue });
        }
      }
      /**
       * Handle a change to a session property.
       */
      _onPropertyChanged(sender, property) {
        switch (property) {
          case "path":
            this._path = sender.path;
            break;
          case "name":
            this._name = sender.name;
            break;
          case "type":
            this._type = sender.type;
            break;
          default:
            throw new Error(`unrecognized property ${property}`);
        }
        this._propertyChanged.emit(property);
      }
      /**
       * Handle a change to the kernel.
       */
      _onKernelChanged(sender, args) {
        this._kernelChanged.emit(args);
      }
      /**
       * Handle a change to the session status.
       */
      _onStatusChanged(sender, status) {
        var _a;
        if (status === "dead") {
          const model = (_a = sender.kernel) === null || _a === void 0 ? void 0 : _a.model;
          if (model === null || model === void 0 ? void 0 : model.reason) {
            const traceback = model.traceback || "";
            void this._displayKernelError(model.reason, traceback);
          }
        }
        if (this._setBusy) {
          if (status === "busy") {
            if (!this._busyDisposable) {
              this._busyDisposable = this._setBusy();
            }
          } else {
            if (this._busyDisposable) {
              this._busyDisposable.dispose();
              this._busyDisposable = null;
            }
          }
        }
        this._statusChanged.emit(status);
      }
      /**
       * Handle a change to the session status.
       */
      _onConnectionStatusChanged(sender, status) {
        this._connectionStatusChanged.emit(status);
      }
      /**
       * Handle a change to the pending input.
       */
      _onPendingInput(sender, value) {
        this._pendingInput = value;
      }
      /**
       * Handle an iopub message.
       */
      _onIopubMessage(sender, message) {
        if (message.header.msg_type === "shutdown_reply") {
          this.session.kernel.removeInputGuard();
        }
        this._iopubMessage.emit(message);
      }
      /**
       * Handle an unhandled message.
       */
      _onUnhandledMessage(sender, message) {
        this._unhandledMessage.emit(message);
      }
    };
    (function(SessionContext2) {
      function getDefaultKernel(options) {
        const { preference } = options;
        const { shouldStart } = preference;
        if (shouldStart === false) {
          return null;
        }
        return Private31.getDefaultKernel(options);
      }
      SessionContext2.getDefaultKernel = getDefaultKernel;
    })(SessionContext || (SessionContext = {}));
    SessionContextDialogs = class {
      constructor(options = {}) {
        var _a;
        this._translator = (_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator;
      }
      /**
       * Select a kernel for the session.
       */
      async selectKernel(sessionContext) {
        if (sessionContext.isDisposed) {
          return Promise.resolve();
        }
        const trans = this._translator.load("jupyterlab");
        let label = trans.__("Cancel");
        if (sessionContext.hasNoKernel) {
          label = sessionContext.kernelDisplayName;
        }
        const buttons = [
          Dialog3.cancelButton({
            label
          }),
          Dialog3.okButton({
            label: trans.__("Select"),
            ariaLabel: trans.__("Select Kernel")
          })
        ];
        const autoStartDefault = sessionContext.kernelPreference.autoStartDefault;
        const hasCheckbox = typeof autoStartDefault === "boolean";
        const dialog = new Dialog3({
          title: trans.__("Select Kernel"),
          body: new Private31.KernelSelector(sessionContext, this._translator),
          buttons,
          checkbox: hasCheckbox ? {
            label: trans.__("Always start the preferred kernel"),
            caption: trans.__("Remember my choice and always start the preferred kernel"),
            checked: autoStartDefault
          } : null
        });
        const result = await dialog.launch();
        if (sessionContext.isDisposed || !result.button.accept) {
          return;
        }
        if (hasCheckbox && result.isChecked !== null) {
          sessionContext.kernelPreference = {
            ...sessionContext.kernelPreference,
            autoStartDefault: result.isChecked
          };
        }
        const model = result.value;
        if (model === null && !sessionContext.hasNoKernel) {
          return sessionContext.shutdown();
        }
        if (model) {
          await sessionContext.changeKernel(model);
        }
      }
      /**
       * Restart the session.
       *
       * @returns A promise that resolves with whether the kernel has restarted.
       *
       * #### Notes
       * If there is a running kernel, present a dialog.
       * If there is no kernel, we start a kernel with the last run
       * kernel name and resolves with `true`.
       */
      async restart(sessionContext) {
        var _a;
        const trans = this._translator.load("jupyterlab");
        await sessionContext.initialize();
        if (sessionContext.isDisposed) {
          throw new Error("session already disposed");
        }
        const kernel = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (!kernel && sessionContext.prevKernelName) {
          await sessionContext.changeKernel({
            name: sessionContext.prevKernelName
          });
          return true;
        }
        if (!kernel) {
          throw new Error("No kernel to restart");
        }
        const restartBtn = Dialog3.warnButton({
          label: trans.__("Restart"),
          ariaLabel: trans.__("Confirm Kernel Restart")
        });
        const result = await showDialog({
          title: trans.__("Restart Kernel?"),
          body: trans.__("Do you want to restart the kernel of %1? All variables will be lost.", sessionContext.name),
          buttons: [
            Dialog3.cancelButton({ ariaLabel: trans.__("Cancel Kernel Restart") }),
            restartBtn
          ]
        });
        if (kernel.isDisposed) {
          return false;
        }
        if (result.button.accept) {
          await sessionContext.restartKernel();
          return true;
        }
        return false;
      }
    };
    (function(Private36) {
      class KernelSelector extends Widget {
        /**
         * Create a new kernel selector widget.
         */
        constructor(sessionContext, translator) {
          super({ node: createSelectorNode(sessionContext, translator) });
        }
        /**
         * Get the value of the kernel selector widget.
         */
        getValue() {
          const selector = this.node.querySelector("select");
          return JSON.parse(selector.value);
        }
      }
      Private36.KernelSelector = KernelSelector;
      function createSelectorNode(sessionContext, translator) {
        translator = translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        const body = document.createElement("div");
        const text = document.createElement("label");
        text.textContent = `${trans.__("Select kernel for:")} "${sessionContext.name}"`;
        body.appendChild(text);
        const options = getKernelSearch(sessionContext);
        const selector = document.createElement("select");
        populateKernelSelect(selector, options, translator, !sessionContext.hasNoKernel ? sessionContext.kernelDisplayName : null);
        body.appendChild(selector);
        return body;
      }
      function getDefaultKernel(options) {
        var _a;
        const { specs, preference } = options;
        const { name: name2, language, canStart, autoStartDefault } = preference;
        if (!specs || canStart === false) {
          return null;
        }
        const defaultName = autoStartDefault ? specs.default : null;
        if (!name2 && !language) {
          return defaultName;
        }
        for (const specName in specs.kernelspecs) {
          if (specName === name2) {
            return name2;
          }
        }
        if (!language) {
          return defaultName;
        }
        const matches2 = [];
        for (const specName in specs.kernelspecs) {
          const kernelLanguage = (_a = specs.kernelspecs[specName]) === null || _a === void 0 ? void 0 : _a.language;
          if (language === kernelLanguage) {
            matches2.push(specName);
          }
        }
        if (matches2.length === 1) {
          const specName = matches2[0];
          console.warn("No exact match found for " + specName + ", using kernel " + specName + " that matches language=" + language);
          return specName;
        }
        return defaultName;
      }
      Private36.getDefaultKernel = getDefaultKernel;
      function populateKernelSelect(node, options, translator, currentKernelDisplayName = null) {
        var _a;
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
        const { preference, sessions, specs } = options;
        const { name: name2, id, language, canStart, shouldStart } = preference;
        translator = translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        if (!specs || canStart === false) {
          node.appendChild(optionForNone(translator));
          node.value = "null";
          node.disabled = true;
          return;
        }
        node.disabled = false;
        const displayNames = /* @__PURE__ */ Object.create(null);
        const languages = /* @__PURE__ */ Object.create(null);
        for (const name3 in specs.kernelspecs) {
          const spec = specs.kernelspecs[name3];
          displayNames[name3] = spec.display_name;
          languages[name3] = spec.language;
        }
        const names = [];
        if (name2 && name2 in specs.kernelspecs) {
          names.push(name2);
        }
        if (name2 && names.length > 0 && language) {
          for (const specName in specs.kernelspecs) {
            if (name2 !== specName && languages[specName] === language) {
              names.push(specName);
            }
          }
        }
        if (!names.length) {
          names.push(specs.default);
        }
        const preferred = document.createElement("optgroup");
        preferred.label = trans.__("Start Preferred Kernel");
        names.sort((a, b) => displayNames[a].localeCompare(displayNames[b]));
        for (const name3 of names) {
          preferred.appendChild(optionForName(name3, displayNames[name3]));
        }
        if (preferred.firstChild) {
          node.appendChild(preferred);
        }
        node.appendChild(optionForNone(translator));
        const other = document.createElement("optgroup");
        other.label = trans.__("Start Other Kernel");
        const otherNames = [];
        for (const specName in specs.kernelspecs) {
          if (names.indexOf(specName) !== -1) {
            continue;
          }
          otherNames.push(specName);
        }
        otherNames.sort((a, b) => displayNames[a].localeCompare(displayNames[b]));
        for (const otherName of otherNames) {
          other.appendChild(optionForName(otherName, displayNames[otherName]));
        }
        if (otherNames.length) {
          node.appendChild(other);
        }
        if (shouldStart === false) {
          node.value = "null";
        } else {
          let selectedIndex = 0;
          if (currentKernelDisplayName) {
            selectedIndex = [...node.options].findIndex((option) => option.text === currentKernelDisplayName);
            selectedIndex = Math.max(selectedIndex, 0);
          }
          node.selectedIndex = selectedIndex;
        }
        if (!sessions) {
          return;
        }
        const matchingSessions = [];
        const otherSessions = [];
        for (const session of sessions) {
          if (language && session.kernel && languages[session.kernel.name] === language && session.kernel.id !== id) {
            matchingSessions.push(session);
          } else if (((_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id) !== id) {
            otherSessions.push(session);
          }
        }
        const matching = document.createElement("optgroup");
        matching.label = trans.__("Use Kernel from Preferred Session");
        node.appendChild(matching);
        if (matchingSessions.length) {
          matchingSessions.sort((a, b) => {
            return a.path.localeCompare(b.path);
          });
          for (const session of matchingSessions) {
            const name3 = session.kernel ? displayNames[session.kernel.name] : "";
            matching.appendChild(optionForSession(session, name3, translator));
          }
        }
        const otherSessionsNode = document.createElement("optgroup");
        otherSessionsNode.label = trans.__("Use Kernel from Other Session");
        node.appendChild(otherSessionsNode);
        if (otherSessions.length) {
          otherSessions.sort((a, b) => {
            return a.path.localeCompare(b.path);
          });
          for (const session of otherSessions) {
            const name3 = session.kernel ? displayNames[session.kernel.name] || session.kernel.name : "";
            otherSessionsNode.appendChild(optionForSession(session, name3, translator));
          }
        }
      }
      Private36.populateKernelSelect = populateKernelSelect;
      function getKernelSearch(sessionContext) {
        return {
          specs: sessionContext.specsManager.specs,
          sessions: sessionContext.sessionManager.running(),
          preference: sessionContext.kernelPreference
        };
      }
      function optionForName(name2, displayName) {
        const option = document.createElement("option");
        option.text = displayName;
        option.value = JSON.stringify({ name: name2 });
        return option;
      }
      function optionForNone(translator) {
        translator = translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        const group = document.createElement("optgroup");
        group.label = trans.__("Use No Kernel");
        const option = document.createElement("option");
        option.text = trans.__("No Kernel");
        option.value = "null";
        group.appendChild(option);
        return group;
      }
      function optionForSession(session, displayName, translator) {
        var _a, _b;
        translator = translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        const option = document.createElement("option");
        const sessionName = session.name || import_coreutils15.PathExt.basename(session.path);
        option.text = sessionName;
        option.value = JSON.stringify({ id: (_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id });
        option.title = `${trans.__("Path:")} ${session.path}
${trans.__("Name:")} ${sessionName}
${trans.__("Kernel Name:")} ${displayName}
${trans.__("Kernel Id:")} ${(_b = session.kernel) === null || _b === void 0 ? void 0 : _b.id}`;
        return option;
      }
    })(Private31 || (Private31 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/kernelstatuses.js
function translateKernelStatuses(translator) {
  translator = translator || nullTranslator;
  const trans = translator.load("jupyterlab");
  const translated = {
    unknown: trans.__("Unknown"),
    starting: trans.__("Starting"),
    idle: trans.__("Idle"),
    busy: trans.__("Busy"),
    terminating: trans.__("Terminating"),
    restarting: trans.__("Restarting"),
    autorestarting: trans.__("Autorestarting"),
    dead: trans.__("Dead"),
    connected: trans.__("Connected"),
    connecting: trans.__("Connecting"),
    disconnected: trans.__("Disconnected"),
    initializing: trans.__("Initializing"),
    "": ""
  };
  return translated;
}
function KernelStatusComponent(props) {
  const translator = props.translator || nullTranslator;
  const trans = translator.load("jupyterlab");
  let statusText = "";
  if (props.status) {
    statusText = ` | ${props.status}`;
  }
  return import_react29.default.createElement(TextItem, { onClick: props.handleClick, onKeyDown: props.handleKeyDown, source: `${props.kernelName}${statusText}`, title: trans.__("Change kernel for %1", props.activityName), tabIndex: 0 });
}
var import_coreutils17, import_react29, KernelStatus;
var init_kernelstatuses = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/kernelstatuses.js"() {
    init_lib6();
    init_lib();
    init_lib5();
    import_coreutils17 = __toESM(require_dist());
    import_react29 = __toESM(require_react());
    KernelStatus = class extends VDomRenderer {
      /**
       * Construct the kernel status widget.
       */
      constructor(opts, translator) {
        super(new KernelStatus.Model(translator));
        this.translator = translator || nullTranslator;
        this._handleClick = opts.onClick;
        this._handleKeyDown = opts.onKeyDown;
        this.addClass("jp-mod-highlighted");
      }
      /**
       * Render the kernel status item.
       */
      render() {
        if (this.model === null) {
          return null;
        } else {
          return import_react29.default.createElement(KernelStatusComponent, { status: this.model.status, kernelName: this.model.kernelName, activityName: this.model.activityName, handleClick: this._handleClick, handleKeyDown: this._handleKeyDown, translator: this.translator });
        }
      }
    };
    (function(KernelStatus2) {
      class Model extends VDomModel {
        constructor(translator) {
          super();
          this._activityName = "";
          this._kernelName = "";
          this._kernelStatus = "";
          this._sessionContext = null;
          translator = translator !== null && translator !== void 0 ? translator : nullTranslator;
          this._trans = translator.load("jupyterlab");
          this._statusNames = translateKernelStatuses(translator);
        }
        /**
         * The name of the kernel.
         */
        get kernelName() {
          return this._kernelName;
        }
        /**
         * The current status of the kernel.
         */
        get status() {
          return this._kernelStatus ? this._statusNames[this._kernelStatus] : void 0;
        }
        /**
         * A display name for the activity.
         */
        get activityName() {
          return this._activityName;
        }
        set activityName(val) {
          const oldVal = this._activityName;
          if (oldVal === val) {
            return;
          }
          this._activityName = val;
          this.stateChanged.emit();
        }
        /**
         * The current client session associated with the kernel status indicator.
         */
        get sessionContext() {
          return this._sessionContext;
        }
        set sessionContext(sessionContext) {
          var _a, _b, _c, _d;
          (_a = this._sessionContext) === null || _a === void 0 ? void 0 : _a.statusChanged.disconnect(this._onKernelStatusChanged, this);
          (_b = this._sessionContext) === null || _b === void 0 ? void 0 : _b.connectionStatusChanged.disconnect(this._onKernelStatusChanged, this);
          (_c = this._sessionContext) === null || _c === void 0 ? void 0 : _c.kernelChanged.disconnect(this._onKernelChanged, this);
          const oldState = this._getAllState();
          this._sessionContext = sessionContext;
          this._kernelStatus = sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.kernelDisplayStatus;
          this._kernelName = (_d = sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.kernelDisplayName) !== null && _d !== void 0 ? _d : this._trans.__("No Kernel");
          sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.statusChanged.connect(this._onKernelStatusChanged, this);
          sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.connectionStatusChanged.connect(this._onKernelStatusChanged, this);
          sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.kernelChanged.connect(this._onKernelChanged, this);
          this._triggerChange(oldState, this._getAllState());
        }
        /**
         * React to changes to the kernel status.
         */
        _onKernelStatusChanged() {
          var _a;
          this._kernelStatus = (_a = this._sessionContext) === null || _a === void 0 ? void 0 : _a.kernelDisplayStatus;
          this.stateChanged.emit(void 0);
        }
        /**
         * React to changes in the kernel.
         */
        _onKernelChanged(_sessionContext, change) {
          var _a;
          const oldState = this._getAllState();
          this._kernelStatus = (_a = this._sessionContext) === null || _a === void 0 ? void 0 : _a.kernelDisplayStatus;
          this._kernelName = _sessionContext.kernelDisplayName;
          this._triggerChange(oldState, this._getAllState());
        }
        _getAllState() {
          return [this._kernelName, this._kernelStatus, this._activityName];
        }
        _triggerChange(oldState, newState) {
          if (import_coreutils17.JSONExt.deepEqual(oldState, newState)) {
            this.stateChanged.emit(void 0);
          }
        }
      }
      KernelStatus2.Model = Model;
    })(KernelStatus || (KernelStatus = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/toolbar/widget.js
var React18, TOOLBAR_KERNEL_NAME_CLASS, TOOLBAR_KERNEL_STATUS_CLASS, Toolbar5, Private32;
var init_widget = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/toolbar/widget.js"() {
    init_lib();
    init_lib5();
    init_index_es618();
    React18 = __toESM(require_react());
    init_sessioncontext();
    init_kernelstatuses();
    TOOLBAR_KERNEL_NAME_CLASS = "jp-Toolbar-kernelName";
    TOOLBAR_KERNEL_STATUS_CLASS = "jp-Toolbar-kernelStatus";
    (function(Toolbar7) {
      function createInterruptButton(sessionContext, translator) {
        translator = translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        return new ToolbarButton({
          icon: stopIcon,
          onClick: () => {
            var _a, _b;
            void ((_b = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) === null || _b === void 0 ? void 0 : _b.interrupt());
          },
          tooltip: trans.__("Interrupt the kernel")
        });
      }
      Toolbar7.createInterruptButton = createInterruptButton;
      function createRestartButton(sessionContext, dialogs, translator) {
        translator = translator !== null && translator !== void 0 ? translator : nullTranslator;
        const trans = translator.load("jupyterlab");
        return new ToolbarButton({
          icon: refreshIcon,
          onClick: () => {
            void (dialogs !== null && dialogs !== void 0 ? dialogs : new SessionContextDialogs({ translator })).restart(sessionContext);
          },
          tooltip: trans.__("Restart the kernel")
        });
      }
      Toolbar7.createRestartButton = createRestartButton;
      function createKernelNameItem(sessionContext, dialogs, translator) {
        const el = ReactWidget.create(React18.createElement(Private32.KernelNameComponent, { sessionContext, dialogs: dialogs !== null && dialogs !== void 0 ? dialogs : new SessionContextDialogs({ translator }), translator }));
        el.addClass("jp-KernelName");
        return el;
      }
      Toolbar7.createKernelNameItem = createKernelNameItem;
      function createKernelStatusItem(sessionContext, translator) {
        return new Private32.KernelStatus(sessionContext, translator);
      }
      Toolbar7.createKernelStatusItem = createKernelStatusItem;
    })(Toolbar5 || (Toolbar5 = {}));
    (function(Private36) {
      function KernelNameComponent(props) {
        const translator = props.translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        const callback = () => {
          void props.dialogs.selectKernel(props.sessionContext);
        };
        return React18.createElement(UseSignal, { signal: props.sessionContext.kernelChanged, initialSender: props.sessionContext }, (sessionContext) => React18.createElement(ToolbarButtonComponent, { className: TOOLBAR_KERNEL_NAME_CLASS, onClick: callback, tooltip: trans.__("Switch kernel"), label: sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.kernelDisplayName }));
      }
      Private36.KernelNameComponent = KernelNameComponent;
      class KernelStatus2 extends Widget {
        /**
         * Construct a new kernel status widget.
         */
        constructor(sessionContext, translator) {
          super();
          this.translator = translator || nullTranslator;
          this._trans = this.translator.load("jupyterlab");
          this.addClass(TOOLBAR_KERNEL_STATUS_CLASS);
          this._statusNames = translateKernelStatuses(this.translator);
          this._onStatusChanged(sessionContext);
          sessionContext.statusChanged.connect(this._onStatusChanged, this);
          sessionContext.connectionStatusChanged.connect(this._onStatusChanged, this);
        }
        /**
         * Handle a status on a kernel.
         */
        _onStatusChanged(sessionContext) {
          if (this.isDisposed) {
            return;
          }
          const status = sessionContext.kernelDisplayStatus;
          const circleIconProps = {
            container: this.node,
            title: this._trans.__("Kernel %1", this._statusNames[status] || status),
            stylesheet: "toolbarButton",
            alignSelf: "normal",
            height: "24px"
          };
          LabIcon.remove(this.node);
          if (status === "busy" || status === "starting" || status === "terminating" || status === "restarting" || status === "initializing") {
            circleIcon.element(circleIconProps);
          } else if (status === "connecting" || status === "disconnected" || status === "unknown") {
            offlineBoltIcon.element(circleIconProps);
          } else {
            circleEmptyIcon.element(circleIconProps);
          }
        }
      }
      Private36.KernelStatus = KernelStatus2;
    })(Private32 || (Private32 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/toolbar/index.js
var init_toolbar6 = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/toolbar/index.js"() {
    init_factory();
    init_registry();
    init_widget();
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/clipboard.js
var import_coreutils18, Clipboard, Private33;
var init_clipboard = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/clipboard.js"() {
    import_coreutils18 = __toESM(require_dist());
    (function(Clipboard2) {
      function getInstance() {
        return Private33.instance;
      }
      Clipboard2.getInstance = getInstance;
      function setInstance(value) {
        Private33.instance = value;
      }
      Clipboard2.setInstance = setInstance;
      function copyToSystem(clipboardData) {
        const node = document.body;
        const handler = (event) => {
          const data = event.clipboardData || window.clipboardData;
          if (typeof clipboardData === "string") {
            data.setData("text", clipboardData);
          } else {
            clipboardData.types().map((mimeType) => {
              data.setData(mimeType, clipboardData.getData(mimeType));
            });
          }
          event.preventDefault();
          node.removeEventListener("copy", handler);
        };
        node.addEventListener("copy", handler);
        generateEvent(node);
      }
      Clipboard2.copyToSystem = copyToSystem;
      function generateEvent(node, type = "copy") {
        let sel = window.getSelection();
        const savedRanges = [];
        for (let i = 0, len = (sel === null || sel === void 0 ? void 0 : sel.rangeCount) || 0; i < len; ++i) {
          savedRanges[i] = sel.getRangeAt(i).cloneRange();
        }
        const range2 = document.createRange();
        range2.selectNodeContents(node);
        if (sel) {
          sel.removeAllRanges();
          sel.addRange(range2);
        }
        document.execCommand(type);
        sel = window.getSelection();
        if (sel) {
          sel.removeAllRanges();
          for (let i = 0, len = savedRanges.length; i < len; ++i) {
            sel.addRange(savedRanges[i]);
          }
        }
      }
      Clipboard2.generateEvent = generateEvent;
    })(Clipboard || (Clipboard = {}));
    (function(Private36) {
      Private36.instance = new import_coreutils18.MimeData();
    })(Private33 || (Private33 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/commandlinker.js
var import_coreutils19;
var init_commandlinker = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/commandlinker.js"() {
    import_coreutils19 = __toESM(require_dist());
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/commandpalette.js
var init_commandpalette = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/commandpalette.js"() {
    init_index_es618();
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/inputdialog.js
var INPUT_DIALOG_CLASS, INPUT_BOOLEAN_DIALOG_CLASS, InputDialog, InputDialogBase, InputBooleanDialog, InputNumberDialog, InputTextDialog, InputPasswordDialog, InputItemsDialog, InputMultipleItemsDialog;
var init_inputdialog = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/inputdialog.js"() {
    init_index_es618();
    init_dialog5();
    INPUT_DIALOG_CLASS = "jp-Input-Dialog";
    INPUT_BOOLEAN_DIALOG_CLASS = "jp-Input-Boolean-Dialog";
    (function(InputDialog2) {
      function getBoolean(options) {
        return showDialog({
          ...options,
          body: new InputBooleanDialog(options),
          buttons: [
            Dialog3.cancelButton({ label: options.cancelLabel }),
            Dialog3.okButton({ label: options.okLabel })
          ],
          focusNodeSelector: "input"
        });
      }
      InputDialog2.getBoolean = getBoolean;
      function getNumber(options) {
        return showDialog({
          ...options,
          body: new InputNumberDialog(options),
          buttons: [
            Dialog3.cancelButton({ label: options.cancelLabel }),
            Dialog3.okButton({ label: options.okLabel })
          ],
          focusNodeSelector: "input"
        });
      }
      InputDialog2.getNumber = getNumber;
      function getItem(options) {
        return showDialog({
          ...options,
          body: new InputItemsDialog(options),
          buttons: [
            Dialog3.cancelButton({ label: options.cancelLabel }),
            Dialog3.okButton({ label: options.okLabel })
          ],
          focusNodeSelector: options.editable ? "input" : "select"
        });
      }
      InputDialog2.getItem = getItem;
      function getMultipleItems(options) {
        return showDialog({
          ...options,
          body: new InputMultipleItemsDialog(options),
          buttons: [
            Dialog3.cancelButton({ label: options.cancelLabel }),
            Dialog3.okButton({ label: options.okLabel })
          ]
        });
      }
      InputDialog2.getMultipleItems = getMultipleItems;
      function getText(options) {
        return showDialog({
          ...options,
          body: new InputTextDialog(options),
          buttons: [
            Dialog3.cancelButton({ label: options.cancelLabel }),
            Dialog3.okButton({ label: options.okLabel })
          ],
          focusNodeSelector: "input"
        });
      }
      InputDialog2.getText = getText;
      function getPassword(options) {
        return showDialog({
          ...options,
          body: new InputPasswordDialog(options),
          buttons: [
            Dialog3.cancelButton({ label: options.cancelLabel }),
            Dialog3.okButton({ label: options.okLabel })
          ],
          focusNodeSelector: "input"
        });
      }
      InputDialog2.getPassword = getPassword;
    })(InputDialog || (InputDialog = {}));
    InputDialogBase = class extends Widget {
      /**
       * InputDialog constructor
       *
       * @param label Input field label
       */
      constructor(label) {
        super();
        this.addClass(INPUT_DIALOG_CLASS);
        this._input = document.createElement("input");
        this._input.classList.add("jp-mod-styled");
        this._input.id = "jp-dialog-input-id";
        if (label !== void 0) {
          const labelElement = document.createElement("label");
          labelElement.textContent = label;
          labelElement.htmlFor = this._input.id;
          this.node.appendChild(labelElement);
        }
        this.node.appendChild(this._input);
      }
    };
    InputBooleanDialog = class extends InputDialogBase {
      /**
       * InputBooleanDialog constructor
       *
       * @param options Constructor options
       */
      constructor(options) {
        super(options.label);
        this.addClass(INPUT_BOOLEAN_DIALOG_CLASS);
        this._input.type = "checkbox";
        this._input.checked = options.value ? true : false;
      }
      /**
       * Get the text specified by the user
       */
      getValue() {
        return this._input.checked;
      }
    };
    InputNumberDialog = class extends InputDialogBase {
      /**
       * InputNumberDialog constructor
       *
       * @param options Constructor options
       */
      constructor(options) {
        super(options.label);
        this._input.type = "number";
        this._input.value = options.value ? options.value.toString() : "0";
      }
      /**
       * Get the number specified by the user.
       */
      getValue() {
        if (this._input.value) {
          return Number(this._input.value);
        } else {
          return Number.NaN;
        }
      }
    };
    InputTextDialog = class extends InputDialogBase {
      /**
       * InputTextDialog constructor
       *
       * @param options Constructor options
       */
      constructor(options) {
        var _a;
        super(options.label);
        this._input.type = "text";
        this._input.value = options.text ? options.text : "";
        if (options.placeholder) {
          this._input.placeholder = options.placeholder;
        }
        this._initialSelectionRange = Math.min(this._input.value.length, Math.max(0, (_a = options.selectionRange) !== null && _a !== void 0 ? _a : this._input.value.length));
      }
      /**
       *  A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        super.onAfterAttach(msg);
        if (this._initialSelectionRange > 0 && this._input.value) {
          this._input.setSelectionRange(0, this._initialSelectionRange);
        }
      }
      /**
       * Get the text specified by the user
       */
      getValue() {
        return this._input.value;
      }
    };
    InputPasswordDialog = class extends InputDialogBase {
      /**
       * InputPasswordDialog constructor
       *
       * @param options Constructor options
       */
      constructor(options) {
        super(options.label);
        this._input.type = "password";
        this._input.value = options.text ? options.text : "";
        if (options.placeholder) {
          this._input.placeholder = options.placeholder;
        }
      }
      /**
       *  A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        super.onAfterAttach(msg);
        if (this._input.value) {
          this._input.select();
        }
      }
      /**
       * Get the text specified by the user
       */
      getValue() {
        return this._input.value;
      }
    };
    InputItemsDialog = class extends InputDialogBase {
      /**
       * InputItemsDialog constructor
       *
       * @param options Constructor options
       */
      constructor(options) {
        super(options.label);
        this._editable = options.editable || false;
        let current = options.current || 0;
        let defaultIndex;
        if (typeof current === "number") {
          defaultIndex = Math.max(0, Math.min(current, options.items.length - 1));
          current = "";
        }
        this._list = document.createElement("select");
        options.items.forEach((item, index) => {
          const option = document.createElement("option");
          if (index === defaultIndex) {
            option.selected = true;
            current = item;
          }
          option.value = item;
          option.textContent = item;
          this._list.appendChild(option);
        });
        if (options.editable) {
          const data = document.createElement("datalist");
          data.id = "input-dialog-items";
          data.appendChild(this._list);
          this._input.type = "list";
          this._input.value = current;
          this._input.setAttribute("list", data.id);
          if (options.placeholder) {
            this._input.placeholder = options.placeholder;
          }
          this.node.appendChild(data);
        } else {
          this._input.remove();
          this.node.appendChild(this._list);
        }
      }
      /**
       * Get the user choice
       */
      getValue() {
        if (this._editable) {
          return this._input.value;
        } else {
          return this._list.value;
        }
      }
    };
    InputMultipleItemsDialog = class extends InputDialogBase {
      /**
       * InputMultipleItemsDialog constructor
       *
       * @param options Constructor options
       */
      constructor(options) {
        super(options.label);
        let defaults = options.defaults || [];
        this._list = document.createElement("select");
        this._list.setAttribute("multiple", "");
        options.items.forEach((item) => {
          const option = document.createElement("option");
          option.value = item;
          option.textContent = item;
          this._list.appendChild(option);
        });
        this._input.remove();
        this.node.appendChild(this._list);
        const htmlOptions = this._list.options;
        for (let i = 0; i < htmlOptions.length; i++) {
          const option = htmlOptions[i];
          if (defaults.includes(option.value)) {
            option.selected = true;
          } else {
            option.selected = false;
          }
        }
      }
      /**
       * Get the user choices
       */
      getValue() {
        let result = [];
        for (let opt of this._list.options) {
          if (opt.selected && !opt.classList.contains("hidden")) {
            result.push(opt.value || opt.text);
          }
        }
        return result;
      }
    };
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/messages.js
var require_messages2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.supportedKernelWebSocketProtocols = exports2.isInputReplyMsg = exports2.isInputRequestMsg = exports2.isDebugReplyMsg = exports2.isDebugRequestMsg = exports2.isExecuteReplyMsg = exports2.isInfoRequestMsg = exports2.isCommMsgMsg = exports2.isCommCloseMsg = exports2.isCommOpenMsg = exports2.isDebugEventMsg = exports2.isClearOutputMsg = exports2.isStatusMsg = exports2.isErrorMsg = exports2.isExecuteResultMsg = exports2.isExecuteInputMsg = exports2.isUpdateDisplayDataMsg = exports2.isDisplayDataMsg = exports2.isStreamMsg = exports2.createMessage = void 0;
    var coreutils_12 = require_dist();
    function createMessage(options) {
      var _a, _b, _c, _d, _e;
      return {
        buffers: (_a = options.buffers) !== null && _a !== void 0 ? _a : [],
        channel: options.channel,
        content: options.content,
        header: {
          date: (/* @__PURE__ */ new Date()).toISOString(),
          msg_id: (_b = options.msgId) !== null && _b !== void 0 ? _b : coreutils_12.UUID.uuid4(),
          msg_type: options.msgType,
          session: options.session,
          username: (_c = options.username) !== null && _c !== void 0 ? _c : "",
          version: "5.2"
        },
        metadata: (_d = options.metadata) !== null && _d !== void 0 ? _d : {},
        parent_header: (_e = options.parentHeader) !== null && _e !== void 0 ? _e : {}
      };
    }
    exports2.createMessage = createMessage;
    function isStreamMsg(msg) {
      return msg.header.msg_type === "stream";
    }
    exports2.isStreamMsg = isStreamMsg;
    function isDisplayDataMsg(msg) {
      return msg.header.msg_type === "display_data";
    }
    exports2.isDisplayDataMsg = isDisplayDataMsg;
    function isUpdateDisplayDataMsg(msg) {
      return msg.header.msg_type === "update_display_data";
    }
    exports2.isUpdateDisplayDataMsg = isUpdateDisplayDataMsg;
    function isExecuteInputMsg(msg) {
      return msg.header.msg_type === "execute_input";
    }
    exports2.isExecuteInputMsg = isExecuteInputMsg;
    function isExecuteResultMsg(msg) {
      return msg.header.msg_type === "execute_result";
    }
    exports2.isExecuteResultMsg = isExecuteResultMsg;
    function isErrorMsg(msg) {
      return msg.header.msg_type === "error";
    }
    exports2.isErrorMsg = isErrorMsg;
    function isStatusMsg(msg) {
      return msg.header.msg_type === "status";
    }
    exports2.isStatusMsg = isStatusMsg;
    function isClearOutputMsg(msg) {
      return msg.header.msg_type === "clear_output";
    }
    exports2.isClearOutputMsg = isClearOutputMsg;
    function isDebugEventMsg(msg) {
      return msg.header.msg_type === "debug_event";
    }
    exports2.isDebugEventMsg = isDebugEventMsg;
    function isCommOpenMsg(msg) {
      return msg.header.msg_type === "comm_open";
    }
    exports2.isCommOpenMsg = isCommOpenMsg;
    function isCommCloseMsg(msg) {
      return msg.header.msg_type === "comm_close";
    }
    exports2.isCommCloseMsg = isCommCloseMsg;
    function isCommMsgMsg(msg) {
      return msg.header.msg_type === "comm_msg";
    }
    exports2.isCommMsgMsg = isCommMsgMsg;
    function isInfoRequestMsg(msg) {
      return msg.header.msg_type === "kernel_info_request";
    }
    exports2.isInfoRequestMsg = isInfoRequestMsg;
    function isExecuteReplyMsg(msg) {
      return msg.header.msg_type === "execute_reply";
    }
    exports2.isExecuteReplyMsg = isExecuteReplyMsg;
    function isDebugRequestMsg(msg) {
      return msg.header.msg_type === "debug_request";
    }
    exports2.isDebugRequestMsg = isDebugRequestMsg;
    function isDebugReplyMsg(msg) {
      return msg.header.msg_type === "debug_reply";
    }
    exports2.isDebugReplyMsg = isDebugReplyMsg;
    function isInputRequestMsg(msg) {
      return msg.header.msg_type === "input_request";
    }
    exports2.isInputRequestMsg = isInputRequestMsg;
    function isInputReplyMsg(msg) {
      return msg.header.msg_type === "input_reply";
    }
    exports2.isInputReplyMsg = isInputReplyMsg;
    var supportedKernelWebSocketProtocols;
    (function(supportedKernelWebSocketProtocols2) {
      supportedKernelWebSocketProtocols2["v1KernelWebsocketJupyterOrg"] = "v1.kernel.websocket.jupyter.org";
    })(supportedKernelWebSocketProtocols || (exports2.supportedKernelWebSocketProtocols = supportedKernelWebSocketProtocols = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/serialize.js
var require_serialize2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/serialize.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deserialize = exports2.serialize = void 0;
    var KernelMessage = __importStar2(require_messages2());
    function serialize(msg, protocol = "") {
      switch (protocol) {
        case KernelMessage.supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg:
          return Private36.serializeV1KernelWebsocketJupyterOrg(msg);
        default:
          return Private36.serializeDefault(msg);
      }
    }
    exports2.serialize = serialize;
    function deserialize(data, protocol = "") {
      switch (protocol) {
        case KernelMessage.supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg:
          return Private36.deserializeV1KernelWebsocketJupyterOrg(data);
        default:
          return Private36.deserializeDefault(data);
      }
    }
    exports2.deserialize = deserialize;
    var Private36;
    (function(Private37) {
      function deserializeV1KernelWebsocketJupyterOrg(binMsg) {
        let msg;
        const data = new DataView(binMsg);
        const offsetNumber = Number(data.getBigUint64(
          0,
          true
          /* littleEndian */
        ));
        let offsets = [];
        for (let i = 0; i < offsetNumber; i++) {
          offsets.push(Number(data.getBigUint64(
            8 * (i + 1),
            true
            /* littleEndian */
          )));
        }
        const decoder = new TextDecoder("utf8");
        const channel = decoder.decode(binMsg.slice(offsets[0], offsets[1]));
        const header = JSON.parse(decoder.decode(binMsg.slice(offsets[1], offsets[2])));
        const parent_header = JSON.parse(decoder.decode(binMsg.slice(offsets[2], offsets[3])));
        const metadata = JSON.parse(decoder.decode(binMsg.slice(offsets[3], offsets[4])));
        const content = JSON.parse(decoder.decode(binMsg.slice(offsets[4], offsets[5])));
        let buffers = [];
        for (let i = 5; i < offsets.length - 1; i++) {
          buffers.push(new DataView(binMsg.slice(offsets[i], offsets[i + 1])));
        }
        msg = {
          channel,
          header,
          parent_header,
          metadata,
          content,
          buffers
        };
        return msg;
      }
      Private37.deserializeV1KernelWebsocketJupyterOrg = deserializeV1KernelWebsocketJupyterOrg;
      function serializeV1KernelWebsocketJupyterOrg(msg) {
        const header = JSON.stringify(msg.header);
        const parentHeader = msg.parent_header == null ? "{}" : JSON.stringify(msg.parent_header);
        const metadata = JSON.stringify(msg.metadata);
        const content = JSON.stringify(msg.content);
        const buffers = msg.buffers !== void 0 ? msg.buffers : [];
        const offsetNumber = 1 + 4 + buffers.length + 1;
        let offsets = [];
        offsets.push(8 * (1 + offsetNumber));
        offsets.push(msg.channel.length + offsets[offsets.length - 1]);
        const encoder = new TextEncoder();
        const channelEncoded = encoder.encode(msg.channel);
        const headerEncoded = encoder.encode(header);
        const parentHeaderEncoded = encoder.encode(parentHeader);
        const metadataEncoded = encoder.encode(metadata);
        const contentEncoded = encoder.encode(content);
        const binMsgNoBuff = new Uint8Array(channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length + metadataEncoded.length + contentEncoded.length);
        binMsgNoBuff.set(channelEncoded);
        binMsgNoBuff.set(headerEncoded, channelEncoded.length);
        binMsgNoBuff.set(parentHeaderEncoded, channelEncoded.length + headerEncoded.length);
        binMsgNoBuff.set(metadataEncoded, channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length);
        binMsgNoBuff.set(contentEncoded, channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length + metadataEncoded.length);
        for (let length of [
          headerEncoded.length,
          parentHeaderEncoded.length,
          metadataEncoded.length,
          contentEncoded.length
        ]) {
          offsets.push(length + offsets[offsets.length - 1]);
        }
        let buffersByteLength = 0;
        for (let buffer of buffers) {
          let length = buffer.byteLength;
          offsets.push(length + offsets[offsets.length - 1]);
          buffersByteLength += length;
        }
        const binMsg = new Uint8Array(8 * (1 + offsetNumber) + binMsgNoBuff.byteLength + buffersByteLength);
        const word = new ArrayBuffer(8);
        const data = new DataView(word);
        data.setBigUint64(
          0,
          BigInt(offsetNumber),
          true
          /* littleEndian */
        );
        binMsg.set(new Uint8Array(word), 0);
        for (let i = 0; i < offsets.length; i++) {
          data.setBigUint64(
            0,
            BigInt(offsets[i]),
            true
            /* littleEndian */
          );
          binMsg.set(new Uint8Array(word), 8 * (i + 1));
        }
        binMsg.set(binMsgNoBuff, offsets[0]);
        for (let i = 0; i < buffers.length; i++) {
          const buffer = buffers[i];
          binMsg.set(new Uint8Array(ArrayBuffer.isView(buffer) ? buffer.buffer : buffer), offsets[5 + i]);
        }
        return binMsg.buffer;
      }
      Private37.serializeV1KernelWebsocketJupyterOrg = serializeV1KernelWebsocketJupyterOrg;
      function deserializeDefault(data) {
        let value;
        if (typeof data === "string") {
          value = JSON.parse(data);
        } else {
          value = deserializeBinary(data);
        }
        return value;
      }
      Private37.deserializeDefault = deserializeDefault;
      function serializeDefault(msg) {
        var _a;
        let value;
        if ((_a = msg.buffers) === null || _a === void 0 ? void 0 : _a.length) {
          value = serializeBinary(msg);
        } else {
          value = JSON.stringify(msg);
        }
        return value;
      }
      Private37.serializeDefault = serializeDefault;
      function deserializeBinary(buf) {
        const data = new DataView(buf);
        const nbufs = data.getUint32(0);
        const offsets = [];
        if (nbufs < 2) {
          throw new Error("Invalid incoming Kernel Message");
        }
        for (let i = 1; i <= nbufs; i++) {
          offsets.push(data.getUint32(i * 4));
        }
        const jsonBytes = new Uint8Array(buf.slice(offsets[0], offsets[1]));
        const msg = JSON.parse(new TextDecoder("utf8").decode(jsonBytes));
        msg.buffers = [];
        for (let i = 1; i < nbufs; i++) {
          const start = offsets[i];
          const stop = offsets[i + 1] || buf.byteLength;
          msg.buffers.push(new DataView(buf.slice(start, stop)));
        }
        return msg;
      }
      function serializeBinary(msg) {
        const offsets = [];
        const buffers = [];
        const encoder = new TextEncoder();
        let origBuffers = [];
        if (msg.buffers !== void 0) {
          origBuffers = msg.buffers;
          delete msg["buffers"];
        }
        const jsonUtf8 = encoder.encode(JSON.stringify(msg));
        buffers.push(jsonUtf8.buffer);
        for (let i = 0; i < origBuffers.length; i++) {
          const b = origBuffers[i];
          buffers.push(ArrayBuffer.isView(b) ? b.buffer : b);
        }
        const nbufs = buffers.length;
        offsets.push(4 * (nbufs + 1));
        for (let i = 0; i + 1 < buffers.length; i++) {
          offsets.push(offsets[offsets.length - 1] + buffers[i].byteLength);
        }
        const msgBuf = new Uint8Array(offsets[offsets.length - 1] + buffers[buffers.length - 1].byteLength);
        const view = new DataView(msgBuf.buffer);
        view.setUint32(0, nbufs);
        for (let i = 0; i < offsets.length; i++) {
          view.setUint32(4 * (i + 1), offsets[i]);
        }
        for (let i = 0; i < buffers.length; i++) {
          msgBuf.set(new Uint8Array(buffers[i]), offsets[i]);
        }
        return msgBuf.buffer;
      }
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/shim/ws.js
var require_ws2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/shim/ws.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = WebSocket;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/serverconnection.js
var require_serverconnection2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/serverconnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerConnection = void 0;
    var coreutils_12 = require_lib14();
    var serialize_1 = require_serialize2();
    var WEBSOCKET;
    if (typeof window === "undefined") {
      WEBSOCKET = require_ws2();
    } else {
      WEBSOCKET = WebSocket;
    }
    var ServerConnection3;
    (function(ServerConnection4) {
      function makeSettings(options) {
        return Private36.makeSettings(options);
      }
      ServerConnection4.makeSettings = makeSettings;
      function makeRequest(url, init, settings) {
        return Private36.handleRequest(url, init, settings);
      }
      ServerConnection4.makeRequest = makeRequest;
      class ResponseError extends Error {
        /**
         * Create a ResponseError from a response, handling the traceback and message
         * as appropriate.
         *
         * @param response The response object.
         *
         * @returns A promise that resolves with a `ResponseError` object.
         */
        static async create(response) {
          try {
            const data = await response.json();
            const { message, traceback } = data;
            if (traceback) {
              console.error(traceback);
            }
            return new ResponseError(response, message !== null && message !== void 0 ? message : ResponseError._defaultMessage(response), traceback !== null && traceback !== void 0 ? traceback : "");
          } catch (e) {
            console.debug(e);
            return new ResponseError(response);
          }
        }
        /**
         * Create a new response error.
         */
        constructor(response, message = ResponseError._defaultMessage(response), traceback = "") {
          super(message);
          this.response = response;
          this.traceback = traceback;
        }
        static _defaultMessage(response) {
          return `Invalid response: ${response.status} ${response.statusText}`;
        }
      }
      ServerConnection4.ResponseError = ResponseError;
      class NetworkError extends TypeError {
        /**
         * Create a new network error.
         */
        constructor(original) {
          super(original.message);
          this.stack = original.stack;
        }
      }
      ServerConnection4.NetworkError = NetworkError;
    })(ServerConnection3 || (exports2.ServerConnection = ServerConnection3 = {}));
    var Private36;
    (function(Private37) {
      function makeSettings(options = {}) {
        var _a;
        const pageBaseUrl = coreutils_12.PageConfig.getBaseUrl();
        const pageWsUrl = coreutils_12.PageConfig.getWsUrl();
        const baseUrl = coreutils_12.URLExt.normalize(options.baseUrl) || pageBaseUrl;
        let wsUrl = options.wsUrl;
        if (!wsUrl && baseUrl === pageBaseUrl) {
          wsUrl = pageWsUrl;
        }
        if (!wsUrl && baseUrl.indexOf("http") === 0) {
          wsUrl = "ws" + baseUrl.slice(4);
        }
        wsUrl = wsUrl !== null && wsUrl !== void 0 ? wsUrl : pageWsUrl;
        return {
          init: { cache: "no-store", credentials: "same-origin" },
          fetch,
          Headers,
          Request,
          WebSocket: WEBSOCKET,
          token: coreutils_12.PageConfig.getToken(),
          appUrl: coreutils_12.PageConfig.getOption("appUrl"),
          appendToken: typeof window === "undefined" || typeof process !== "undefined" && ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.JEST_WORKER_ID) !== void 0 || coreutils_12.URLExt.getHostName(pageBaseUrl) !== coreutils_12.URLExt.getHostName(wsUrl),
          serializer: { serialize: serialize_1.serialize, deserialize: serialize_1.deserialize },
          ...options,
          baseUrl,
          wsUrl
        };
      }
      Private37.makeSettings = makeSettings;
      function handleRequest(url, init, settings) {
        var _a;
        if (url.indexOf(settings.baseUrl) !== 0) {
          throw new Error("Can only be used for notebook server requests");
        }
        const cache2 = (_a = init.cache) !== null && _a !== void 0 ? _a : settings.init.cache;
        if (cache2 === "no-store") {
          url += (/\?/.test(url) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
        }
        const request = new settings.Request(url, { ...settings.init, ...init });
        let authenticated = false;
        if (settings.token) {
          authenticated = true;
          request.headers.append("Authorization", `token ${settings.token}`);
        }
        if (typeof document !== "undefined") {
          const xsrfToken = getCookie("_xsrf");
          if (xsrfToken !== void 0) {
            authenticated = true;
            request.headers.append("X-XSRFToken", xsrfToken);
          }
        }
        if (!request.headers.has("Content-Type") && authenticated) {
          request.headers.set("Content-Type", "application/json");
        }
        return settings.fetch.call(null, request).catch((e) => {
          throw new ServerConnection3.NetworkError(e);
        });
      }
      Private37.handleRequest = handleRequest;
      function getCookie(name2) {
        let cookie = "";
        try {
          cookie = document.cookie;
        } catch (e) {
          return;
        }
        const matches2 = cookie.match("\\b" + name2 + "=([^;]*)\\b");
        return matches2 === null || matches2 === void 0 ? void 0 : matches2[1];
      }
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/basemanager.js
var require_basemanager2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/basemanager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseManager = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var serverconnection_1 = require_serverconnection2();
    var BaseManager = class {
      constructor(options) {
        var _a;
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * A signal emitted when the delegate is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Test whether the delegate has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Whether the manager is active.
       */
      get isActive() {
        return true;
      }
      /**
       * Dispose of the delegate and invoke the callback function.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._disposed.emit(void 0);
        signaling_1.Signal.clearData(this);
      }
    };
    exports2.BaseManager = BaseManager;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/config/index.js
var require_config2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigWithDefaults = exports2.ConfigSection = void 0;
    var coreutils_12 = require_lib14();
    var __1 = require_lib15();
    var SERVICE_CONFIG_URL = "api/config";
    var ConfigSection;
    (function(ConfigSection2) {
      function create5(options) {
        const section = new DefaultConfigSection(options);
        return section.load().then(() => {
          return section;
        });
      }
      ConfigSection2.create = create5;
    })(ConfigSection || (exports2.ConfigSection = ConfigSection = {}));
    var DefaultConfigSection = class {
      /**
       * Construct a new config section.
       */
      constructor(options) {
        var _a;
        this._url = "unknown";
        const settings = this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._url = coreutils_12.URLExt.join(settings.baseUrl, SERVICE_CONFIG_URL, encodeURIComponent(options.name));
      }
      /**
       * Get the data for this section.
       */
      get data() {
        return this._data;
      }
      /**
       * Load the initial data for this section.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       */
      async load() {
        const response = await __1.ServerConnection.makeRequest(this._url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._data = await response.json();
      }
      /**
       * Modify the stored config values.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * Updates the local data immediately, sends the change to the server,
       * and updates the local data with the response, and fulfils the promise
       * with that data.
       */
      async update(newdata) {
        this._data = { ...this._data, ...newdata };
        const init = {
          method: "PATCH",
          body: JSON.stringify(newdata)
        };
        const response = await __1.ServerConnection.makeRequest(this._url, init, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._data = await response.json();
        return this._data;
      }
    };
    var ConfigWithDefaults = class {
      /**
       * Create a new config with defaults.
       */
      constructor(options) {
        var _a, _b;
        this._className = "";
        this._section = options.section;
        this._defaults = (_a = options.defaults) !== null && _a !== void 0 ? _a : {};
        this._className = (_b = options.className) !== null && _b !== void 0 ? _b : "";
      }
      /**
       * Get data from the config section or fall back to defaults.
       */
      get(key2) {
        const data = this._classData();
        return key2 in data ? data[key2] : this._defaults[key2];
      }
      /**
       * Set a config value.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * Sends the update to the server, and changes our local copy of the data
       * immediately.
       */
      set(key2, value) {
        const d = {};
        d[key2] = value;
        if (this._className) {
          const d2 = {};
          d2[this._className] = d;
          return this._section.update(d2);
        } else {
          return this._section.update(d);
        }
      }
      /**
       * Get data from the Section with our classname, if available.
       *
       * #### Notes
       * If we have no classname, get all of the data in the Section
       */
      _classData() {
        const data = this._section.data;
        if (this._className && this._className in data) {
          return data[this._className];
        }
        return data;
      }
    };
    exports2.ConfigWithDefaults = ConfigWithDefaults;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/validate.js
var require_validate6 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateProperty = void 0;
    function validateProperty(object, name2, typeName, values = []) {
      if (!object.hasOwnProperty(name2)) {
        throw Error(`Missing property '${name2}'`);
      }
      const value = object[name2];
      if (typeName !== void 0) {
        let valid = true;
        switch (typeName) {
          case "array":
            valid = Array.isArray(value);
            break;
          case "object":
            valid = typeof value !== "undefined";
            break;
          default:
            valid = typeof value === typeName;
        }
        if (!valid) {
          throw new Error(`Property '${name2}' is not of type '${typeName}'`);
        }
        if (values.length > 0) {
          let valid2 = true;
          switch (typeName) {
            case "string":
            case "number":
            case "boolean":
              valid2 = values.includes(value);
              break;
            default:
              valid2 = values.findIndex((v) => v === value) >= 0;
              break;
          }
          if (!valid2) {
            throw new Error(`Property '${name2}' is not one of the valid values ${JSON.stringify(values)}`);
          }
        }
      }
    }
    exports2.validateProperty = validateProperty;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/contents/validate.js
var require_validate7 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/contents/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateCheckpointModel = exports2.validateContentsModel = void 0;
    var validate_1 = require_validate6();
    function validateContentsModel(model) {
      (0, validate_1.validateProperty)(model, "name", "string");
      (0, validate_1.validateProperty)(model, "path", "string");
      (0, validate_1.validateProperty)(model, "type", "string");
      (0, validate_1.validateProperty)(model, "created", "string");
      (0, validate_1.validateProperty)(model, "last_modified", "string");
      (0, validate_1.validateProperty)(model, "mimetype", "object");
      (0, validate_1.validateProperty)(model, "content", "object");
      (0, validate_1.validateProperty)(model, "format", "object");
    }
    exports2.validateContentsModel = validateContentsModel;
    function validateCheckpointModel(model) {
      (0, validate_1.validateProperty)(model, "id", "string");
      (0, validate_1.validateProperty)(model, "last_modified", "string");
    }
    exports2.validateCheckpointModel = validateCheckpointModel;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/contents/index.js
var require_contents2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/contents/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Drive = exports2.ContentsManager = exports2.Contents = void 0;
    var coreutils_12 = require_lib14();
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib15();
    var validate = __importStar2(require_validate7());
    var SERVICE_DRIVE_URL = "api/contents";
    var FILES_URL = "files";
    var Contents;
    (function(Contents2) {
      function validateContentsModel(contents) {
        validate.validateContentsModel(contents);
      }
      Contents2.validateContentsModel = validateContentsModel;
      function validateCheckpointModel(checkpoint) {
        validate.validateCheckpointModel(checkpoint);
      }
      Contents2.validateCheckpointModel = validateCheckpointModel;
    })(Contents || (exports2.Contents = Contents = {}));
    var ContentsManager = class {
      /**
       * Construct a new contents manager object.
       *
       * @param options - The options used to initialize the object.
       */
      constructor(options = {}) {
        var _a, _b;
        this._isDisposed = false;
        this._additionalDrives = /* @__PURE__ */ new Map();
        this._fileChanged = new signaling_1.Signal(this);
        const serverSettings = this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._defaultDrive = (_b = options.defaultDrive) !== null && _b !== void 0 ? _b : new Drive({ serverSettings });
        this._defaultDrive.fileChanged.connect(this._onFileChanged, this);
      }
      /**
       * A signal emitted when a file operation takes place.
       */
      get fileChanged() {
        return this._fileChanged;
      }
      /**
       * Test whether the manager has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * Add an `IDrive` to the manager.
       */
      addDrive(drive) {
        this._additionalDrives.set(drive.name, drive);
        drive.fileChanged.connect(this._onFileChanged, this);
      }
      /**
       * Given a path, get a shared model factory from the
       * relevant backend. Returns `null` if the backend
       * does not provide one.
       */
      getSharedModelFactory(path2) {
        var _a;
        const [drive] = this._driveForPath(path2);
        return (_a = drive === null || drive === void 0 ? void 0 : drive.sharedModelFactory) !== null && _a !== void 0 ? _a : null;
      }
      /**
       * Given a path of the form `drive:local/portion/of/it.txt`
       * get the local part of it.
       *
       * @param path: the path.
       *
       * @returns The local part of the path.
       */
      localPath(path2) {
        const parts = path2.split("/");
        const firstParts = parts[0].split(":");
        if (firstParts.length === 1 || !this._additionalDrives.has(firstParts[0])) {
          return coreutils_12.PathExt.removeSlash(path2);
        }
        return coreutils_12.PathExt.join(firstParts.slice(1).join(":"), ...parts.slice(1));
      }
      /**
       * Normalize a global path. Reduces '..' and '.' parts, and removes
       * leading slashes from the local part of the path, while retaining
       * the drive name if it exists.
       *
       * @param path: the path.
       *
       * @returns The normalized path.
       */
      normalize(path2) {
        const parts = path2.split(":");
        if (parts.length === 1) {
          return coreutils_12.PathExt.normalize(path2);
        }
        return `${parts[0]}:${coreutils_12.PathExt.normalize(parts.slice(1).join(":"))}`;
      }
      /**
       * Resolve a global path, starting from the root path. Behaves like
       * posix-path.resolve, with 3 differences:
       *  - will never prepend cwd
       *  - if root has a drive name, the result is prefixed with "<drive>:"
       *  - before adding drive name, leading slashes are removed
       *
       * @param path: the path.
       *
       * @returns The normalized path.
       */
      resolvePath(root, path2) {
        const driveName = this.driveName(root);
        const localPath = this.localPath(root);
        const resolved = coreutils_12.PathExt.resolve("/", localPath, path2);
        return driveName ? `${driveName}:${resolved}` : resolved;
      }
      /**
       * Given a path of the form `drive:local/portion/of/it.txt`
       * get the name of the drive. If the path is missing
       * a drive portion, returns an empty string.
       *
       * @param path: the path.
       *
       * @returns The drive name for the path, or the empty string.
       */
      driveName(path2) {
        const parts = path2.split("/");
        const firstParts = parts[0].split(":");
        if (firstParts.length === 1) {
          return "";
        }
        if (this._additionalDrives.has(firstParts[0])) {
          return firstParts[0];
        }
        return "";
      }
      /**
       * Get a file or directory.
       *
       * @param path: The path to the file.
       *
       * @param options: The options used to fetch the file.
       *
       * @returns A promise which resolves with the file content.
       */
      get(path2, options) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.get(localPath, options).then((contentsModel) => {
          const listing = [];
          if (contentsModel.type === "directory" && contentsModel.content) {
            for (const item of contentsModel.content) {
              listing.push({ ...item, path: this._toGlobalPath(drive, item.path) });
            }
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive, localPath),
              content: listing,
              serverPath: contentsModel.path
            };
          } else {
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive, localPath),
              serverPath: contentsModel.path
            };
          }
        });
      }
      /**
       * Get an encoded download url given a file path.
       *
       * @param path - An absolute POSIX file path on the server.
       *
       * #### Notes
       * It is expected that the path contains no relative paths.
       *
       * The returned URL may include a query parameter.
       */
      getDownloadUrl(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.getDownloadUrl(localPath);
      }
      /**
       * Create a new untitled file or directory in the specified directory path.
       *
       * @param options: The options used to create the file.
       *
       * @returns A promise which resolves with the created file content when the
       *    file is created.
       */
      newUntitled(options = {}) {
        if (options.path) {
          const globalPath = this.normalize(options.path);
          const [drive, localPath] = this._driveForPath(globalPath);
          return drive.newUntitled({ ...options, path: localPath }).then((contentsModel) => {
            return {
              ...contentsModel,
              path: coreutils_12.PathExt.join(globalPath, contentsModel.name),
              serverPath: contentsModel.path
            };
          });
        } else {
          return this._defaultDrive.newUntitled(options);
        }
      }
      /**
       * Delete a file.
       *
       * @param path - The path to the file.
       *
       * @returns A promise which resolves when the file is deleted.
       */
      delete(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.delete(localPath);
      }
      /**
       * Rename a file or directory.
       *
       * @param path - The original file path.
       *
       * @param newPath - The new file path.
       *
       * @returns A promise which resolves with the new file contents model when
       *   the file is renamed.
       */
      rename(path2, newPath) {
        const [drive1, path1] = this._driveForPath(path2);
        const [drive2, path22] = this._driveForPath(newPath);
        if (drive1 !== drive2) {
          throw Error("ContentsManager: renaming files must occur within a Drive");
        }
        return drive1.rename(path1, path22).then((contentsModel) => {
          return {
            ...contentsModel,
            path: this._toGlobalPath(drive1, path22),
            serverPath: contentsModel.path
          };
        });
      }
      /**
       * Save a file.
       *
       * @param path - The desired file path.
       *
       * @param options - Optional overrides to the model.
       *
       * @returns A promise which resolves with the file content model when the
       *   file is saved.
       *
       * #### Notes
       * Ensure that `model.content` is populated for the file.
       */
      save(path2, options = {}) {
        const globalPath = this.normalize(path2);
        const [drive, localPath] = this._driveForPath(path2);
        return drive.save(localPath, { ...options, path: localPath }).then((contentsModel) => {
          return {
            ...contentsModel,
            path: globalPath,
            serverPath: contentsModel.path
          };
        });
      }
      /**
       * Copy a file into a given directory.
       *
       * @param path - The original file path.
       *
       * @param toDir - The destination directory path.
       *
       * @returns A promise which resolves with the new contents model when the
       *  file is copied.
       *
       * #### Notes
       * The server will select the name of the copied file.
       */
      copy(fromFile, toDir) {
        const [drive1, path1] = this._driveForPath(fromFile);
        const [drive2, path2] = this._driveForPath(toDir);
        if (drive1 === drive2) {
          return drive1.copy(path1, path2).then((contentsModel) => {
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive1, contentsModel.path),
              serverPath: contentsModel.path
            };
          });
        } else {
          throw Error("Copying files between drives is not currently implemented");
        }
      }
      /**
       * Create a checkpoint for a file.
       *
       * @param path - The path of the file.
       *
       * @returns A promise which resolves with the new checkpoint model when the
       *   checkpoint is created.
       */
      createCheckpoint(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.createCheckpoint(localPath);
      }
      /**
       * List available checkpoints for a file.
       *
       * @param path - The path of the file.
       *
       * @returns A promise which resolves with a list of checkpoint models for
       *    the file.
       */
      listCheckpoints(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.listCheckpoints(localPath);
      }
      /**
       * Restore a file to a known checkpoint state.
       *
       * @param path - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to restore.
       *
       * @returns A promise which resolves when the checkpoint is restored.
       */
      restoreCheckpoint(path2, checkpointID) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.restoreCheckpoint(localPath, checkpointID);
      }
      /**
       * Delete a checkpoint for a file.
       *
       * @param path - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to delete.
       *
       * @returns A promise which resolves when the checkpoint is deleted.
       */
      deleteCheckpoint(path2, checkpointID) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.deleteCheckpoint(localPath, checkpointID);
      }
      /**
       * Given a drive and a local path, construct a fully qualified
       * path. The inverse of `_driveForPath`.
       *
       * @param drive: an `IDrive`.
       *
       * @param localPath: the local path on the drive.
       *
       * @returns the fully qualified path.
       */
      _toGlobalPath(drive, localPath) {
        if (drive === this._defaultDrive) {
          return coreutils_12.PathExt.removeSlash(localPath);
        } else {
          return `${drive.name}:${coreutils_12.PathExt.removeSlash(localPath)}`;
        }
      }
      /**
       * Given a path, get the `IDrive to which it refers,
       * where the path satisfies the pattern
       * `'driveName:path/to/file'`. If there is no `driveName`
       * prepended to the path, it returns the default drive.
       *
       * @param path: a path to a file.
       *
       * @returns A tuple containing an `IDrive` object for the path,
       * and a local path for that drive.
       */
      _driveForPath(path2) {
        const driveName = this.driveName(path2);
        const localPath = this.localPath(path2);
        if (driveName) {
          return [this._additionalDrives.get(driveName), localPath];
        } else {
          return [this._defaultDrive, localPath];
        }
      }
      /**
       * Respond to fileChanged signals from the drives attached to
       * the manager. This prepends the drive name to the path if necessary,
       * and then forwards the signal.
       */
      _onFileChanged(sender, args) {
        var _a, _b;
        if (sender === this._defaultDrive) {
          this._fileChanged.emit(args);
        } else {
          let newValue = null;
          let oldValue = null;
          if ((_a = args.newValue) === null || _a === void 0 ? void 0 : _a.path) {
            newValue = {
              ...args.newValue,
              path: this._toGlobalPath(sender, args.newValue.path)
            };
          }
          if ((_b = args.oldValue) === null || _b === void 0 ? void 0 : _b.path) {
            oldValue = {
              ...args.oldValue,
              path: this._toGlobalPath(sender, args.oldValue.path)
            };
          }
          this._fileChanged.emit({
            type: args.type,
            newValue,
            oldValue
          });
        }
      }
    };
    exports2.ContentsManager = ContentsManager;
    var Drive = class {
      /**
       * Construct a new contents manager object.
       *
       * @param options - The options used to initialize the object.
       */
      constructor(options = {}) {
        var _a, _b, _c;
        this._isDisposed = false;
        this._fileChanged = new signaling_1.Signal(this);
        this.name = (_a = options.name) !== null && _a !== void 0 ? _a : "Default";
        this._apiEndpoint = (_b = options.apiEndpoint) !== null && _b !== void 0 ? _b : SERVICE_DRIVE_URL;
        this.serverSettings = (_c = options.serverSettings) !== null && _c !== void 0 ? _c : __1.ServerConnection.makeSettings();
      }
      /**
       * A signal emitted when a file operation takes place.
       */
      get fileChanged() {
        return this._fileChanged;
      }
      /**
       * Test whether the manager has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * Get a file or directory.
       *
       * @param localPath: The path to the file.
       *
       * @param options: The options used to fetch the file.
       *
       * @returns A promise which resolves with the file content.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async get(localPath, options) {
        let url = this._getUrl(localPath);
        if (options) {
          if (options.type === "notebook") {
            delete options["format"];
          }
          const content = options.content ? "1" : "0";
          const hash = options.hash ? "1" : "0";
          const params = { ...options, content, hash };
          url += coreutils_12.URLExt.objectToQueryString(params);
        }
        const settings = this.serverSettings;
        const response = await __1.ServerConnection.makeRequest(url, {}, settings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        return data;
      }
      /**
       * Get an encoded download url given a file path.
       *
       * @param localPath - An absolute POSIX file path on the server.
       *
       * #### Notes
       * It is expected that the path contains no relative paths.
       *
       * The returned URL may include a query parameter.
       */
      getDownloadUrl(localPath) {
        const baseUrl = this.serverSettings.baseUrl;
        let url = coreutils_12.URLExt.join(baseUrl, FILES_URL, coreutils_12.URLExt.encodeParts(localPath));
        let cookie = "";
        try {
          cookie = document.cookie;
        } catch (e) {
        }
        const xsrfTokenMatch = cookie.match("\\b_xsrf=([^;]*)\\b");
        if (xsrfTokenMatch) {
          const fullUrl = new URL(url);
          fullUrl.searchParams.append("_xsrf", xsrfTokenMatch[1]);
          url = fullUrl.toString();
        }
        return Promise.resolve(url);
      }
      /**
       * Create a new untitled file or directory in the specified directory path.
       *
       * @param options: The options used to create the file.
       *
       * @returns A promise which resolves with the created file content when the
       *    file is created.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async newUntitled(options = {}) {
        var _a;
        let body = "{}";
        if (options) {
          if (options.ext) {
            options.ext = Private36.normalizeExtension(options.ext);
          }
          body = JSON.stringify(options);
        }
        const settings = this.serverSettings;
        const url = this._getUrl((_a = options.path) !== null && _a !== void 0 ? _a : "");
        const init = {
          method: "POST",
          body
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "new",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Delete a file.
       *
       * @param localPath - The path to the file.
       *
       * @returns A promise which resolves when the file is deleted.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async delete(localPath) {
        const url = this._getUrl(localPath);
        const settings = this.serverSettings;
        const init = { method: "DELETE" };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._fileChanged.emit({
          type: "delete",
          oldValue: { path: localPath },
          newValue: null
        });
      }
      /**
       * Rename a file or directory.
       *
       * @param oldLocalPath - The original file path.
       *
       * @param newLocalPath - The new file path.
       *
       * @returns A promise which resolves with the new file contents model when
       *   the file is renamed.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async rename(oldLocalPath, newLocalPath) {
        const settings = this.serverSettings;
        const url = this._getUrl(oldLocalPath);
        const init = {
          method: "PATCH",
          body: JSON.stringify({ path: newLocalPath })
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "rename",
          oldValue: { path: oldLocalPath },
          newValue: data
        });
        return data;
      }
      /**
       * Save a file.
       *
       * @param localPath - The desired file path.
       *
       * @param options - Optional overrides to the model.
       *
       * @returns A promise which resolves with the file content model when the
       *   file is saved.
       *
       * #### Notes
       * Ensure that `model.content` is populated for the file.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async save(localPath, options = {}) {
        const settings = this.serverSettings;
        const url = this._getUrl(localPath);
        const init = {
          method: "PUT",
          body: JSON.stringify(options)
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 200 && response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "save",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Copy a file into a given directory.
       *
       * @param localPath - The original file path.
       *
       * @param toDir - The destination directory path.
       *
       * @returns A promise which resolves with the new contents model when the
       *  file is copied.
       *
       * #### Notes
       * The server will select the name of the copied file.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async copy(fromFile, toDir) {
        const settings = this.serverSettings;
        const url = this._getUrl(toDir);
        const init = {
          method: "POST",
          body: JSON.stringify({ copy_from: fromFile })
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "new",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Create a checkpoint for a file.
       *
       * @param localPath - The path of the file.
       *
       * @returns A promise which resolves with the new checkpoint model when the
       *   checkpoint is created.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async createCheckpoint(localPath) {
        const url = this._getUrl(localPath, "checkpoints");
        const init = { method: "POST" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateCheckpointModel(data);
        return data;
      }
      /**
       * List available checkpoints for a file.
       *
       * @param localPath - The path of the file.
       *
       * @returns A promise which resolves with a list of checkpoint models for
       *    the file.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async listCheckpoints(localPath) {
        const url = this._getUrl(localPath, "checkpoints");
        const response = await __1.ServerConnection.makeRequest(url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        if (!Array.isArray(data)) {
          throw new Error("Invalid Checkpoint list");
        }
        for (let i = 0; i < data.length; i++) {
          validate.validateCheckpointModel(data[i]);
        }
        return data;
      }
      /**
       * Restore a file to a known checkpoint state.
       *
       * @param localPath - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to restore.
       *
       * @returns A promise which resolves when the checkpoint is restored.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async restoreCheckpoint(localPath, checkpointID) {
        const url = this._getUrl(localPath, "checkpoints", checkpointID);
        const init = { method: "POST" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Delete a checkpoint for a file.
       *
       * @param localPath - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to delete.
       *
       * @returns A promise which resolves when the checkpoint is deleted.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async deleteCheckpoint(localPath, checkpointID) {
        const url = this._getUrl(localPath, "checkpoints", checkpointID);
        const init = { method: "DELETE" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Get a REST url for a file given a path.
       */
      _getUrl(...args) {
        const parts = args.map((path2) => coreutils_12.URLExt.encodeParts(path2));
        const baseUrl = this.serverSettings.baseUrl;
        return coreutils_12.URLExt.join(baseUrl, this._apiEndpoint, ...parts);
      }
    };
    exports2.Drive = Drive;
    var Private36;
    (function(Private37) {
      function normalizeExtension(extension) {
        if (extension.length > 0 && extension.indexOf(".") !== 0) {
          extension = `.${extension}`;
        }
        return extension;
      }
      Private37.normalizeExtension = normalizeExtension;
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/event/index.js
var require_event2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/event/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventManager = void 0;
    var coreutils_12 = require_lib14();
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var serverconnection_1 = require_serverconnection2();
    var SERVICE_EVENTS_URL = "api/events";
    var EventManager = class {
      /**
       * Create a new event manager.
       */
      constructor(options = {}) {
        var _a;
        this._socket = null;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        this._poll = new polling_1.Poll({ factory: () => this._subscribe() });
        this._stream = new signaling_1.Stream(this);
        void this._poll.start();
      }
      /**
       * Whether the event manager is disposed.
       */
      get isDisposed() {
        return this._poll.isDisposed;
      }
      /**
       * An event stream that emits and yields each new event.
       */
      get stream() {
        return this._stream;
      }
      /**
       * Dispose the event manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._poll.dispose();
        const socket = this._socket;
        if (socket) {
          this._socket = null;
          socket.onopen = () => void 0;
          socket.onerror = () => void 0;
          socket.onmessage = () => void 0;
          socket.onclose = () => void 0;
          socket.close();
        }
        signaling_1.Signal.clearData(this);
        this._stream.stop();
      }
      /**
       * Post an event request to be emitted by the event bus.
       */
      async emit(event) {
        const { serverSettings } = this;
        const { baseUrl, token } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const url = coreutils_12.URLExt.join(baseUrl, SERVICE_EVENTS_URL) + (token ? `?token=${token}` : "");
        const init = { body: JSON.stringify(event), method: "POST" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          throw new ResponseError(response);
        }
      }
      /**
       * Subscribe to event bus emissions.
       */
      _subscribe() {
        return new Promise((_, reject) => {
          if (this.isDisposed) {
            return;
          }
          const { token, WebSocket: WebSocket2, wsUrl } = this.serverSettings;
          const url = coreutils_12.URLExt.join(wsUrl, SERVICE_EVENTS_URL, "subscribe") + (token ? `?token=${encodeURIComponent(token)}` : "");
          const socket = this._socket = new WebSocket2(url);
          const stream = this._stream;
          socket.onclose = () => reject(new Error("EventManager socket closed"));
          socket.onmessage = (msg) => msg.data && stream.emit(JSON.parse(msg.data));
        });
      }
    };
    exports2.EventManager = EventManager;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/kernel.js
var require_kernel3 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/kernel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/validate.js
var require_validate8 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateModels = exports2.validateModel = exports2.validateMessage = void 0;
    var validate_1 = require_validate6();
    var HEADER_FIELDS = ["username", "version", "session", "msg_id", "msg_type"];
    var IOPUB_CONTENT_FIELDS = {
      stream: { name: "string", text: "string" },
      display_data: { data: "object", metadata: "object" },
      execute_input: { code: "string", execution_count: "number" },
      execute_result: {
        execution_count: "number",
        data: "object",
        metadata: "object"
      },
      error: { ename: "string", evalue: "string", traceback: "object" },
      status: {
        execution_state: [
          "string",
          ["starting", "idle", "busy", "restarting", "dead"]
        ]
      },
      clear_output: { wait: "boolean" },
      comm_open: { comm_id: "string", target_name: "string", data: "object" },
      comm_msg: { comm_id: "string", data: "object" },
      comm_close: { comm_id: "string" },
      shutdown_reply: { restart: "boolean" }
      // Emitted by the IPython kernel.
    };
    function validateHeader(header) {
      for (let i = 0; i < HEADER_FIELDS.length; i++) {
        (0, validate_1.validateProperty)(header, HEADER_FIELDS[i], "string");
      }
    }
    function validateMessage(msg) {
      (0, validate_1.validateProperty)(msg, "metadata", "object");
      (0, validate_1.validateProperty)(msg, "content", "object");
      (0, validate_1.validateProperty)(msg, "channel", "string");
      validateHeader(msg.header);
      if (msg.channel === "iopub") {
        validateIOPubContent(msg);
      }
    }
    exports2.validateMessage = validateMessage;
    function validateIOPubContent(msg) {
      if (msg.channel === "iopub") {
        const fields = IOPUB_CONTENT_FIELDS[msg.header.msg_type];
        if (fields === void 0) {
          return;
        }
        const names = Object.keys(fields);
        const content = msg.content;
        for (let i = 0; i < names.length; i++) {
          let args = fields[names[i]];
          if (!Array.isArray(args)) {
            args = [args];
          }
          (0, validate_1.validateProperty)(content, names[i], ...args);
        }
      }
    }
    function validateModel(model) {
      (0, validate_1.validateProperty)(model, "name", "string");
      (0, validate_1.validateProperty)(model, "id", "string");
    }
    exports2.validateModel = validateModel;
    function validateModels(models) {
      if (!Array.isArray(models)) {
        throw new Error("Invalid kernel list");
      }
      models.forEach((d) => validateModel(d));
    }
    exports2.validateModels = validateModels;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/restapi.js
var require_restapi5 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKernelModel = exports2.shutdownKernel = exports2.interruptKernel = exports2.restartKernel = exports2.startNew = exports2.listRunning = exports2.KERNEL_SERVICE_URL = void 0;
    var serverconnection_1 = require_serverconnection2();
    var coreutils_12 = require_lib14();
    var validate_1 = require_validate8();
    exports2.KERNEL_SERVICE_URL = "api/kernels";
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModels)(data);
      return data;
    }
    exports2.listRunning = listRunning;
    async function startNew(options = {}, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify(options)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 201) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.startNew = startNew;
    async function restartKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id), "restart");
      const init = { method: "POST" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
    }
    exports2.restartKernel = restartKernel;
    async function interruptKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id), "interrupt");
      const init = { method: "POST" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.interruptKernel = interruptKernel;
    async function shutdownKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id));
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const msg = `The kernel "${id}" does not exist on the server`;
        console.warn(msg);
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownKernel = shutdownKernel;
    async function getKernelModel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id));
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status === 404) {
        return void 0;
      } else if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.getKernelModel = getKernelModel;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/comm.js
var require_comm2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/comm.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommHandler = void 0;
    var disposable_1 = (init_index_es65(), __toCommonJS(index_es6_exports4));
    var KernelMessage = __importStar2(require_messages2());
    var CommHandler = class extends disposable_1.DisposableDelegate {
      /**
       * Construct a new comm channel.
       */
      constructor(target2, id, kernel, disposeCb) {
        super(disposeCb);
        this._target = "";
        this._id = "";
        this._id = id;
        this._target = target2;
        this._kernel = kernel;
      }
      /**
       * The unique id for the comm channel.
       */
      get commId() {
        return this._id;
      }
      /**
       * The target name for the comm channel.
       */
      get targetName() {
        return this._target;
      }
      /**
       * Get the callback for a comm close event.
       *
       * #### Notes
       * This is called when the comm is closed from either the server or client.
       *
       * **See also:** [[ICommClose]], [[close]]
       */
      get onClose() {
        return this._onClose;
      }
      /**
       * Set the callback for a comm close event.
       *
       * #### Notes
       * This is called when the comm is closed from either the server or client. If
       * the function returns a promise, and the kernel was closed from the server,
       * kernel message processing will pause until the returned promise is
       * fulfilled.
       *
       * **See also:** [[close]]
       */
      set onClose(cb) {
        this._onClose = cb;
      }
      /**
       * Get the callback for a comm message received event.
       */
      get onMsg() {
        return this._onMsg;
      }
      /**
       * Set the callback for a comm message received event.
       *
       * #### Notes
       * This is called when a comm message is received. If the function returns a
       * promise, kernel message processing will pause until it is fulfilled.
       */
      set onMsg(cb) {
        this._onMsg = cb;
      }
      /**
       * Open a comm with optional data and metadata.
       *
       * #### Notes
       * This sends a `comm_open` message to the server.
       *
       * **See also:** [[ICommOpen]]
       */
      open(data, metadata, buffers = []) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot open");
        }
        const msg = KernelMessage.createMessage({
          msgType: "comm_open",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            target_name: this._target,
            data: data !== null && data !== void 0 ? data : {}
          },
          metadata,
          buffers
        });
        return this._kernel.sendShellMessage(msg, false, true);
      }
      /**
       * Send a `comm_msg` message to the kernel.
       *
       * #### Notes
       * This is a no-op if the comm has been closed.
       *
       * **See also:** [[ICommMsg]]
       */
      send(data, metadata, buffers = [], disposeOnDone = true) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot send");
        }
        const msg = KernelMessage.createMessage({
          msgType: "comm_msg",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            data
          },
          metadata,
          buffers
        });
        return this._kernel.sendShellMessage(msg, false, disposeOnDone);
      }
      /**
       * Close the comm.
       *
       * #### Notes
       * This will send a `comm_close` message to the kernel, and call the
       * `onClose` callback if set.
       *
       * This is a no-op if the comm is already closed.
       *
       * **See also:** [[ICommClose]], [[onClose]]
       */
      close(data, metadata, buffers = []) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot close");
        }
        const msg = KernelMessage.createMessage({
          msgType: "comm_close",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            data: data !== null && data !== void 0 ? data : {}
          },
          metadata,
          buffers
        });
        const future = this._kernel.sendShellMessage(msg, false, true);
        const onClose = this._onClose;
        if (onClose) {
          const ioMsg = KernelMessage.createMessage({
            msgType: "comm_close",
            channel: "iopub",
            username: this._kernel.username,
            session: this._kernel.clientId,
            content: {
              comm_id: this._id,
              data: data !== null && data !== void 0 ? data : {}
            },
            metadata,
            buffers
          });
          void onClose(ioMsg);
        }
        this.dispose();
        return future;
      }
    };
    exports2.CommHandler = CommHandler;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/future.js
var require_future2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/future.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelShellFutureHandler = exports2.KernelControlFutureHandler = exports2.KernelFutureHandler = void 0;
    var coreutils_12 = require_dist();
    var disposable_1 = (init_index_es65(), __toCommonJS(index_es6_exports4));
    var KernelMessage = __importStar2(require_messages2());
    var KernelFutureHandler = class extends disposable_1.DisposableDelegate {
      /**
       * Construct a new KernelFutureHandler.
       */
      constructor(cb, msg, expectReply, disposeOnDone, kernel) {
        super(cb);
        this._status = 0;
        this._stdin = Private36.noOp;
        this._iopub = Private36.noOp;
        this._reply = Private36.noOp;
        this._done = new coreutils_12.PromiseDelegate();
        this._hooks = new Private36.HookList();
        this._disposeOnDone = true;
        this._msg = msg;
        if (!expectReply) {
          this._setFlag(Private36.KernelFutureFlag.GotReply);
        }
        this._disposeOnDone = disposeOnDone;
        this._kernel = kernel;
      }
      /**
       * Get the original outgoing message.
       */
      get msg() {
        return this._msg;
      }
      /**
       * A promise that resolves when the future is done.
       */
      get done() {
        return this._done.promise;
      }
      /**
       * Get the reply handler.
       */
      get onReply() {
        return this._reply;
      }
      /**
       * Set the reply handler.
       */
      set onReply(cb) {
        this._reply = cb;
      }
      /**
       * Get the iopub handler.
       */
      get onIOPub() {
        return this._iopub;
      }
      /**
       * Set the iopub handler.
       */
      set onIOPub(cb) {
        this._iopub = cb;
      }
      /**
       * Get the stdin handler.
       */
      get onStdin() {
        return this._stdin;
      }
      /**
       * Set the stdin handler.
       */
      set onStdin(cb) {
        this._stdin = cb;
      }
      /**
       * Register hook for IOPub messages.
       *
       * @param hook - The callback invoked for an IOPub message.
       *
       * #### Notes
       * The IOPub hook system allows you to preempt the handlers for IOPub
       * messages handled by the future.
       *
       * The most recently registered hook is run first. A hook can return a
       * boolean or a promise to a boolean, in which case all kernel message
       * processing pauses until the promise is fulfilled. If a hook return value
       * resolves to false, any later hooks will not run and the function will
       * return a promise resolving to false. If a hook throws an error, the error
       * is logged to the console and the next hook is run. If a hook is
       * registered during the hook processing, it will not run until the next
       * message. If a hook is removed during the hook processing, it will be
       * deactivated immediately.
       */
      registerMessageHook(hook) {
        if (this.isDisposed) {
          throw new Error("Kernel future is disposed");
        }
        this._hooks.add(hook);
      }
      /**
       * Remove a hook for IOPub messages.
       *
       * @param hook - The hook to remove.
       *
       * #### Notes
       * If a hook is removed during the hook processing, it will be deactivated immediately.
       */
      removeMessageHook(hook) {
        if (this.isDisposed) {
          return;
        }
        this._hooks.remove(hook);
      }
      /**
       * Send an `input_reply` message.
       */
      sendInputReply(content, parent_header) {
        this._kernel.sendInputReply(content, parent_header);
      }
      /**
       * Dispose and unregister the future.
       */
      dispose() {
        this._stdin = Private36.noOp;
        this._iopub = Private36.noOp;
        this._reply = Private36.noOp;
        this._hooks = null;
        if (!this._testFlag(Private36.KernelFutureFlag.IsDone)) {
          this._done.promise.catch(() => {
          });
          this._done.reject(new Error(`Canceled future for ${this.msg.header.msg_type} message before replies were done`));
        }
        super.dispose();
      }
      /**
       * Handle an incoming kernel message.
       */
      async handleMsg(msg) {
        switch (msg.channel) {
          case "control":
          case "shell":
            if (msg.channel === this.msg.channel && msg.parent_header.msg_id === this.msg.header.msg_id) {
              await this._handleReply(msg);
            }
            break;
          case "stdin":
            await this._handleStdin(msg);
            break;
          case "iopub":
            await this._handleIOPub(msg);
            break;
          default:
            break;
        }
      }
      async _handleReply(msg) {
        const reply = this._reply;
        if (reply) {
          await reply(msg);
        }
        this._replyMsg = msg;
        this._setFlag(Private36.KernelFutureFlag.GotReply);
        if (this._testFlag(Private36.KernelFutureFlag.GotIdle)) {
          this._handleDone();
        }
      }
      async _handleStdin(msg) {
        this._kernel.hasPendingInput = true;
        const stdin = this._stdin;
        if (stdin) {
          await stdin(msg);
        }
      }
      async _handleIOPub(msg) {
        const process2 = await this._hooks.process(msg);
        const iopub = this._iopub;
        if (process2 && iopub) {
          await iopub(msg);
        }
        if (KernelMessage.isStatusMsg(msg) && msg.content.execution_state === "idle") {
          this._setFlag(Private36.KernelFutureFlag.GotIdle);
          if (this._testFlag(Private36.KernelFutureFlag.GotReply)) {
            this._handleDone();
          }
        }
      }
      _handleDone() {
        if (this._testFlag(Private36.KernelFutureFlag.IsDone)) {
          return;
        }
        this._setFlag(Private36.KernelFutureFlag.IsDone);
        this._done.resolve(this._replyMsg);
        if (this._disposeOnDone) {
          this.dispose();
        }
      }
      /**
       * Test whether the given future flag is set.
       */
      _testFlag(flag) {
        return (this._status & flag) !== 0;
      }
      /**
       * Set the given future flag.
       */
      _setFlag(flag) {
        this._status |= flag;
      }
    };
    exports2.KernelFutureHandler = KernelFutureHandler;
    var KernelControlFutureHandler = class extends KernelFutureHandler {
    };
    exports2.KernelControlFutureHandler = KernelControlFutureHandler;
    var KernelShellFutureHandler = class extends KernelFutureHandler {
    };
    exports2.KernelShellFutureHandler = KernelShellFutureHandler;
    var Private36;
    (function(Private37) {
      Private37.noOp = () => {
      };
      const defer = (() => {
        const ok = typeof requestAnimationFrame === "function";
        return ok ? requestAnimationFrame : setImmediate;
      })();
      class HookList {
        constructor() {
          this._hooks = [];
        }
        /**
         * Register a hook.
         *
         * @param hook - The callback to register.
         */
        add(hook) {
          this.remove(hook);
          this._hooks.push(hook);
        }
        /**
         * Remove a hook, if it exists in the hook list.
         *
         * @param hook - The callback to remove.
         */
        remove(hook) {
          const index = this._hooks.indexOf(hook);
          if (index >= 0) {
            this._hooks[index] = null;
            this._scheduleCompact();
          }
        }
        /**
         * Process a message through the hooks.
         *
         * @returns a promise resolving to false if any hook resolved as false,
         * otherwise true
         *
         * #### Notes
         * The most recently registered hook is run first. A hook can return a
         * boolean or a promise to a boolean, in which case processing pauses until
         * the promise is fulfilled. If a hook return value resolves to false, any
         * later hooks will not run and the function will return a promise resolving
         * to false. If a hook throws an error, the error is logged to the console
         * and the next hook is run. If a hook is registered during the hook
         * processing, it will not run until the next message. If a hook is removed
         * during the hook processing, it will be deactivated immediately.
         */
        async process(msg) {
          await this._processing;
          const processing = new coreutils_12.PromiseDelegate();
          this._processing = processing.promise;
          let continueHandling;
          for (let i = this._hooks.length - 1; i >= 0; i--) {
            const hook = this._hooks[i];
            if (hook === null) {
              continue;
            }
            try {
              continueHandling = await hook(msg);
            } catch (err) {
              continueHandling = true;
              console.error(err);
            }
            if (continueHandling === false) {
              processing.resolve(void 0);
              return false;
            }
          }
          processing.resolve(void 0);
          return true;
        }
        /**
         * Schedule a cleanup of the list, removing any hooks that have been nulled out.
         */
        _scheduleCompact() {
          if (!this._compactScheduled) {
            this._compactScheduled = true;
            defer(() => {
              this._processing = this._processing.then(() => {
                this._compactScheduled = false;
                this._compact();
              });
            });
          }
        }
        /**
         * Compact the list, removing any nulls.
         */
        _compact() {
          let numNulls = 0;
          for (let i = 0, len = this._hooks.length; i < len; i++) {
            const hook = this._hooks[i];
            if (this._hooks[i] === null) {
              numNulls++;
            } else {
              this._hooks[i - numNulls] = hook;
            }
          }
          this._hooks.length -= numNulls;
        }
      }
      Private37.HookList = HookList;
      let KernelFutureFlag;
      (function(KernelFutureFlag2) {
        KernelFutureFlag2[KernelFutureFlag2["GotReply"] = 1] = "GotReply";
        KernelFutureFlag2[KernelFutureFlag2["GotIdle"] = 2] = "GotIdle";
        KernelFutureFlag2[KernelFutureFlag2["IsDone"] = 4] = "IsDone";
        KernelFutureFlag2[KernelFutureFlag2["DisposeOnDone"] = 8] = "DisposeOnDone";
      })(KernelFutureFlag = Private37.KernelFutureFlag || (Private37.KernelFutureFlag = {}));
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernelspec/kernelspec.js
var require_kernelspec3 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernelspec/kernelspec.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernelspec/validate.js
var require_validate9 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernelspec/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSpecModels = exports2.validateSpecModel = void 0;
    var validate_1 = require_validate6();
    function validateSpecModel(data) {
      const spec = data.spec;
      if (!spec) {
        throw new Error("Invalid kernel spec");
      }
      (0, validate_1.validateProperty)(data, "name", "string");
      (0, validate_1.validateProperty)(data, "resources", "object");
      (0, validate_1.validateProperty)(spec, "language", "string");
      (0, validate_1.validateProperty)(spec, "display_name", "string");
      (0, validate_1.validateProperty)(spec, "argv", "array");
      let metadata = null;
      if (spec.hasOwnProperty("metadata")) {
        (0, validate_1.validateProperty)(spec, "metadata", "object");
        metadata = spec.metadata;
      }
      let env = null;
      if (spec.hasOwnProperty("env")) {
        (0, validate_1.validateProperty)(spec, "env", "object");
        env = spec.env;
      }
      return {
        name: data.name,
        resources: data.resources,
        language: spec.language,
        display_name: spec.display_name,
        argv: spec.argv,
        metadata,
        env
      };
    }
    exports2.validateSpecModel = validateSpecModel;
    function validateSpecModels(data) {
      if (!data.hasOwnProperty("kernelspecs")) {
        throw new Error("No kernelspecs found");
      }
      let keys = Object.keys(data.kernelspecs);
      const kernelspecs = /* @__PURE__ */ Object.create(null);
      let defaultSpec = data.default;
      for (let i = 0; i < keys.length; i++) {
        const ks = data.kernelspecs[keys[i]];
        try {
          kernelspecs[keys[i]] = validateSpecModel(ks);
        } catch (err) {
          console.warn(`Removing errant kernel spec: ${keys[i]}`);
        }
      }
      keys = Object.keys(kernelspecs);
      if (!keys.length) {
        throw new Error("No valid kernelspecs found");
      }
      if (!defaultSpec || typeof defaultSpec !== "string" || !(defaultSpec in kernelspecs)) {
        defaultSpec = keys[0];
        console.warn(`Default kernel not found, using '${keys[0]}'`);
      }
      return {
        default: defaultSpec,
        kernelspecs
      };
    }
    exports2.validateSpecModels = validateSpecModels;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernelspec/restapi.js
var require_restapi6 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernelspec/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSpecs = void 0;
    var serverconnection_1 = require_serverconnection2();
    var validate_1 = require_validate9();
    var coreutils_12 = require_lib14();
    var KERNELSPEC_SERVICE_URL = "api/kernelspecs";
    async function getSpecs(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, KERNELSPEC_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      return (0, validate_1.validateSpecModels)(data);
    }
    exports2.getSpecs = getSpecs;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernelspec/manager.js
var require_manager6 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernelspec/manager.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelSpecManager = void 0;
    var coreutils_12 = require_dist();
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var restapi = __importStar2(require_restapi6());
    var basemanager_1 = require_basemanager2();
    var KernelSpecManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new kernel spec manager.
       *
       * @param options - The default options for kernel.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._connectionFailure = new signaling_1.Signal(this);
        this._specs = null;
        this._specsChanged = new signaling_1.Signal(this);
        this._ready = Promise.all([this.requestSpecs()]).then((_) => void 0).catch((_) => void 0).then(() => {
          if (this.isDisposed) {
            return;
          }
          this._isReady = true;
        });
        this._pollSpecs = new polling_1.Poll({
          auto: false,
          factory: () => this.requestSpecs(),
          frequency: {
            interval: 61 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:KernelSpecManager#specs`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        void this.ready.then(() => {
          void this._pollSpecs.start();
        });
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * Get the most recently fetched kernel specs.
       */
      get specs() {
        return this._specs;
      }
      /**
       * A signal emitted when the specs change.
       */
      get specsChanged() {
        return this._specsChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        this._pollSpecs.dispose();
        super.dispose();
      }
      /**
       * Force a refresh of the specs from the server.
       *
       * @returns A promise that resolves when the specs are fetched.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshSpecs() {
        await this._pollSpecs.refresh();
        await this._pollSpecs.tick;
      }
      /**
       * Execute a request to the server to poll specs and update state.
       */
      async requestSpecs() {
        const specs = await restapi.getSpecs(this.serverSettings);
        if (this.isDisposed) {
          return;
        }
        if (!coreutils_12.JSONExt.deepEqual(specs, this._specs)) {
          this._specs = specs;
          this._specsChanged.emit(specs);
        }
      }
    };
    exports2.KernelSpecManager = KernelSpecManager;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernelspec/index.js
var require_kernelspec4 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernelspec/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelSpecAPI = exports2.KernelSpec = void 0;
    var KernelSpec = __importStar2(require_kernelspec3());
    exports2.KernelSpec = KernelSpec;
    var KernelSpecAPI = __importStar2(require_restapi6());
    exports2.KernelSpecAPI = KernelSpecAPI;
    __exportStar2(require_manager6(), exports2);
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/default.js
var require_default4 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/default.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelConnection = void 0;
    var coreutils_12 = require_lib14();
    var coreutils_2 = require_dist();
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib15();
    var comm_1 = require_comm2();
    var KernelMessage = __importStar2(require_messages2());
    var future_1 = require_future2();
    var validate = __importStar2(require_validate8());
    var kernelspec_1 = require_kernelspec4();
    var restapi = __importStar2(require_restapi5());
    var KERNEL_INFO_TIMEOUT = 3e3;
    var RESTARTING_KERNEL_SESSION = "_RESTARTING_";
    var STARTING_KERNEL_SESSION = "";
    var KernelConnection = class {
      /**
       * Construct a kernel object.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        this._createSocket = (useProtocols = true) => {
          this._errorIfDisposed();
          this._clearSocket();
          this._updateConnectionStatus("connecting");
          const settings = this.serverSettings;
          const partialUrl = coreutils_12.URLExt.join(settings.wsUrl, restapi.KERNEL_SERVICE_URL, encodeURIComponent(this._id));
          const display2 = partialUrl.replace(/^((?:\w+:)?\/\/)(?:[^@\/]+@)/, "$1");
          console.debug(`Starting WebSocket: ${display2}`);
          let url = coreutils_12.URLExt.join(partialUrl, "channels?session_id=" + encodeURIComponent(this._clientId));
          const token = settings.token;
          if (settings.appendToken && token !== "") {
            url = url + `&token=${encodeURIComponent(token)}`;
          }
          const supportedProtocols = useProtocols ? this._supportedProtocols : [];
          this._ws = new settings.WebSocket(url, supportedProtocols);
          this._ws.binaryType = "arraybuffer";
          let alreadyCalledOnclose = false;
          const getKernelModel = async (evt) => {
            var _a2, _b2;
            if (this._isDisposed) {
              return;
            }
            this._reason = "";
            this._model = void 0;
            try {
              const model = await restapi.getKernelModel(this._id, settings);
              this._model = model;
              if ((model === null || model === void 0 ? void 0 : model.execution_state) === "dead") {
                this._updateStatus("dead");
              } else {
                this._onWSClose(evt);
              }
            } catch (err) {
              if (err instanceof __1.ServerConnection.NetworkError || ((_a2 = err.response) === null || _a2 === void 0 ? void 0 : _a2.status) === 503 || ((_b2 = err.response) === null || _b2 === void 0 ? void 0 : _b2.status) === 424) {
                const timeout = Private36.getRandomIntInclusive(10, 30) * 1e3;
                setTimeout(getKernelModel, timeout, evt);
              } else {
                this._reason = "Kernel died unexpectedly";
                this._updateStatus("dead");
              }
            }
            return;
          };
          const earlyClose = async (evt) => {
            if (alreadyCalledOnclose) {
              return;
            }
            alreadyCalledOnclose = true;
            await getKernelModel(evt);
            return;
          };
          this._ws.onmessage = this._onWSMessage;
          this._ws.onopen = this._onWSOpen;
          this._ws.onclose = earlyClose;
          this._ws.onerror = earlyClose;
        };
        this._onWSOpen = (evt) => {
          if (this._ws.protocol !== "" && !this._supportedProtocols.includes(this._ws.protocol)) {
            console.log("Server selected unknown kernel wire protocol:", this._ws.protocol);
            this._updateStatus("dead");
            throw new Error(`Unknown kernel wire protocol:  ${this._ws.protocol}`);
          }
          this._selectedProtocol = this._ws.protocol;
          this._ws.onclose = this._onWSClose;
          this._ws.onerror = this._onWSClose;
          this._updateConnectionStatus("connected");
        };
        this._onWSMessage = (evt) => {
          let msg;
          try {
            msg = this.serverSettings.serializer.deserialize(evt.data, this._ws.protocol);
            validate.validateMessage(msg);
          } catch (error) {
            error.message = `Kernel message validation error: ${error.message}`;
            throw error;
          }
          this._kernelSession = msg.header.session;
          this._msgChain = this._msgChain.then(() => {
            return this._handleMessage(msg);
          }).catch((error) => {
            if (error.message.startsWith("Canceled future for ")) {
              console.error(error);
            }
          });
          this._anyMessage.emit({ msg, direction: "recv" });
        };
        this._onWSClose = (evt) => {
          if (!this.isDisposed) {
            this._reconnect();
          }
        };
        this._id = "";
        this._name = "";
        this._status = "unknown";
        this._connectionStatus = "connecting";
        this._kernelSession = "";
        this._isDisposed = false;
        this._ws = null;
        this._username = "";
        this._reconnectLimit = 7;
        this._reconnectAttempt = 0;
        this._reconnectTimeout = null;
        this._supportedProtocols = Object.values(KernelMessage.supportedKernelWebSocketProtocols);
        this._selectedProtocol = "";
        this._futures = /* @__PURE__ */ new Map();
        this._comms = /* @__PURE__ */ new Map();
        this._targetRegistry = /* @__PURE__ */ Object.create(null);
        this._info = new coreutils_2.PromiseDelegate();
        this._pendingMessages = [];
        this._statusChanged = new signaling_1.Signal(this);
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._disposed = new signaling_1.Signal(this);
        this._iopubMessage = new signaling_1.Signal(this);
        this._anyMessage = new signaling_1.Signal(this);
        this._pendingInput = new signaling_1.Signal(this);
        this._unhandledMessage = new signaling_1.Signal(this);
        this._displayIdToParentIds = /* @__PURE__ */ new Map();
        this._msgIdToDisplayIds = /* @__PURE__ */ new Map();
        this._msgChain = Promise.resolve();
        this._hasPendingInput = false;
        this._reason = "";
        this._noOp = () => {
        };
        this._name = options.model.name;
        this._id = options.model.id;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._clientId = (_b = options.clientId) !== null && _b !== void 0 ? _b : coreutils_2.UUID.uuid4();
        this._username = (_c = options.username) !== null && _c !== void 0 ? _c : "";
        this.handleComms = (_d = options.handleComms) !== null && _d !== void 0 ? _d : true;
        this._createSocket();
      }
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when the kernel status changes.
       */
      get statusChanged() {
        return this._statusChanged;
      }
      /**
       * A signal emitted when the kernel status changes.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * A signal emitted for iopub kernel messages.
       *
       * #### Notes
       * This signal is emitted after the iopub message is handled asynchronously.
       */
      get iopubMessage() {
        return this._iopubMessage;
      }
      /**
       * A signal emitted for unhandled kernel message.
       *
       * #### Notes
       * This signal is emitted for a message that was not handled. It is emitted
       * during the asynchronous message handling code.
       */
      get unhandledMessage() {
        return this._unhandledMessage;
      }
      /**
       * The kernel model
       */
      get model() {
        return this._model || {
          id: this.id,
          name: this.name,
          reason: this._reason
        };
      }
      /**
       * A signal emitted for any kernel message.
       *
       * #### Notes
       * This signal is emitted when a message is received, before it is handled
       * asynchronously.
       *
       * This message is emitted when a message is queued for sending (either in
       * the websocket buffer, or our own pending message buffer). The message may
       * actually be sent across the wire at a later time.
       *
       * The message emitted in this signal should not be modified in any way.
       */
      get anyMessage() {
        return this._anyMessage;
      }
      /**
       * A signal emitted when a kernel has pending inputs from the user.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * The id of the server-side kernel.
       */
      get id() {
        return this._id;
      }
      /**
       * The name of the server-side kernel.
       */
      get name() {
        return this._name;
      }
      /**
       * The client username.
       */
      get username() {
        return this._username;
      }
      /**
       * The client unique id.
       */
      get clientId() {
        return this._clientId;
      }
      /**
       * The current status of the kernel.
       */
      get status() {
        return this._status;
      }
      /**
       * The current connection status of the kernel connection.
       */
      get connectionStatus() {
        return this._connectionStatus;
      }
      /**
       * Test whether the kernel has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * The cached kernel info.
       *
       * @returns A promise that resolves to the kernel info.
       */
      get info() {
        return this._info.promise;
      }
      /**
       * The kernel spec.
       *
       * @returns A promise that resolves to the kernel spec.
       */
      get spec() {
        if (this._specPromise) {
          return this._specPromise;
        }
        this._specPromise = kernelspec_1.KernelSpecAPI.getSpecs(this.serverSettings).then((specs) => {
          return specs.kernelspecs[this._name];
        });
        return this._specPromise;
      }
      /**
       * Clone the current kernel with a new clientId.
       */
      clone(options = {}) {
        return new KernelConnection({
          model: this.model,
          username: this.username,
          serverSettings: this.serverSettings,
          // handleComms defaults to false since that is safer
          handleComms: false,
          ...options
        });
      }
      /**
       * Dispose of the resources held by the kernel.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        this._updateConnectionStatus("disconnected");
        this._clearKernelState();
        this._pendingMessages = [];
        this._clearSocket();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Send a shell message to the kernel.
       *
       * #### Notes
       * Send a message to the kernel's shell channel, yielding a future object
       * for accepting replies.
       *
       * If `expectReply` is given and `true`, the future is disposed when both a
       * shell reply and an idle status message are received. If `expectReply`
       * is not given or is `false`, the future is resolved when an idle status
       * message is received.
       * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.
       * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.
       *
       * All replies are validated as valid kernel messages.
       *
       * If the kernel status is `dead`, this will throw an error.
       */
      sendShellMessage(msg, expectReply = false, disposeOnDone = true) {
        return this._sendKernelShellControl(future_1.KernelShellFutureHandler, msg, expectReply, disposeOnDone);
      }
      /**
       * Send a control message to the kernel.
       *
       * #### Notes
       * Send a message to the kernel's control channel, yielding a future object
       * for accepting replies.
       *
       * If `expectReply` is given and `true`, the future is disposed when both a
       * control reply and an idle status message are received. If `expectReply`
       * is not given or is `false`, the future is resolved when an idle status
       * message is received.
       * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.
       * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.
       *
       * All replies are validated as valid kernel messages.
       *
       * If the kernel status is `dead`, this will throw an error.
       */
      sendControlMessage(msg, expectReply = false, disposeOnDone = true) {
        return this._sendKernelShellControl(future_1.KernelControlFutureHandler, msg, expectReply, disposeOnDone);
      }
      _sendKernelShellControl(ctor, msg, expectReply = false, disposeOnDone = true) {
        this._sendMessage(msg);
        this._anyMessage.emit({ msg, direction: "send" });
        const future = new ctor(() => {
          const msgId = msg.header.msg_id;
          this._futures.delete(msgId);
          const displayIds = this._msgIdToDisplayIds.get(msgId);
          if (!displayIds) {
            return;
          }
          displayIds.forEach((displayId) => {
            const msgIds = this._displayIdToParentIds.get(displayId);
            if (msgIds) {
              const idx = msgIds.indexOf(msgId);
              if (idx === -1) {
                return;
              }
              if (msgIds.length === 1) {
                this._displayIdToParentIds.delete(displayId);
              } else {
                msgIds.splice(idx, 1);
                this._displayIdToParentIds.set(displayId, msgIds);
              }
            }
          });
          this._msgIdToDisplayIds.delete(msgId);
        }, msg, expectReply, disposeOnDone, this);
        this._futures.set(msg.header.msg_id, future);
        return future;
      }
      /**
       * Send a message on the websocket.
       *
       * If queue is true, queue the message for later sending if we cannot send
       * now. Otherwise throw an error.
       *
       * #### Notes
       * As an exception to the queueing, if we are sending a kernel_info_request
       * message while we think the kernel is restarting, we send the message
       * immediately without queueing. This is so that we can trigger a message
       * back, which will then clear the kernel restarting state.
       */
      _sendMessage(msg, queue = true) {
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        if ((this._kernelSession === STARTING_KERNEL_SESSION || this._kernelSession === RESTARTING_KERNEL_SESSION) && KernelMessage.isInfoRequestMsg(msg)) {
          if (this.connectionStatus === "connected") {
            this._ws.send(this.serverSettings.serializer.serialize(msg, this._ws.protocol));
            return;
          } else {
            throw new Error("Could not send message: status is not connected");
          }
        }
        if (queue && this._pendingMessages.length > 0) {
          this._pendingMessages.push(msg);
          return;
        }
        if (this.connectionStatus === "connected" && this._kernelSession !== RESTARTING_KERNEL_SESSION) {
          this._ws.send(this.serverSettings.serializer.serialize(msg, this._ws.protocol));
        } else if (queue) {
          this._pendingMessages.push(msg);
        } else {
          throw new Error("Could not send message");
        }
      }
      /**
       * Interrupt a kernel.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * It is assumed that the API call does not mutate the kernel id or name.
       *
       * The promise will be rejected if the kernel status is `Dead` or if the
       * request fails or the response is invalid.
       */
      async interrupt() {
        this.hasPendingInput = false;
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        return restapi.interruptKernel(this.id, this.serverSettings);
      }
      /**
       * Request a kernel restart.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels)
       * and validates the response model.
       *
       * Any existing Future or Comm objects are cleared once the kernel has
       * actually be restarted.
       *
       * The promise is fulfilled on a valid server response (after the kernel restarts)
       * and rejected otherwise.
       *
       * It is assumed that the API call does not mutate the kernel id or name.
       *
       * The promise will be rejected if the request fails or the response is
       * invalid.
       */
      async restart() {
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        this._updateStatus("restarting");
        this._clearKernelState();
        this._kernelSession = RESTARTING_KERNEL_SESSION;
        await restapi.restartKernel(this.id, this.serverSettings);
        await this.reconnect();
        this.hasPendingInput = false;
      }
      /**
       * Reconnect to a kernel.
       *
       * #### Notes
       * This may try multiple times to reconnect to a kernel, and will sever any
       * existing connection.
       */
      reconnect() {
        this._errorIfDisposed();
        const result = new coreutils_2.PromiseDelegate();
        const fulfill = (sender, status) => {
          if (status === "connected") {
            result.resolve();
            this.connectionStatusChanged.disconnect(fulfill, this);
          } else if (status === "disconnected") {
            result.reject(new Error("Kernel connection disconnected"));
            this.connectionStatusChanged.disconnect(fulfill, this);
          }
        };
        this.connectionStatusChanged.connect(fulfill, this);
        this._reconnectAttempt = 0;
        this._reconnect();
        return result.promise;
      }
      /**
       * Shutdown a kernel.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * On a valid response, disposes this kernel connection.
       *
       * If the kernel is already `dead`, disposes this kernel connection without
       * a server request.
       */
      async shutdown() {
        if (this.status !== "dead") {
          await restapi.shutdownKernel(this.id, this.serverSettings);
        }
        this.handleShutdown();
      }
      /**
       * Handles a kernel shutdown.
       *
       * #### Notes
       * This method should be called if we know from outside information that a
       * kernel is dead (for example, we cannot find the kernel model on the
       * server).
       */
      handleShutdown() {
        this._updateStatus("dead");
        this.dispose();
      }
      /**
       * Send a `kernel_info_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#kernel-info).
       *
       * Fulfills with the `kernel_info_response` content when the shell reply is
       * received and validated.
       */
      async requestKernelInfo() {
        const msg = KernelMessage.createMessage({
          msgType: "kernel_info_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content: {}
        });
        let reply;
        try {
          reply = await Private36.handleShellMessage(this, msg);
        } catch (e) {
          if (this.isDisposed) {
            return;
          } else {
            throw e;
          }
        }
        this._errorIfDisposed();
        if (!reply) {
          return;
        }
        if (reply.content.status === void 0) {
          reply.content.status = "ok";
        }
        if (reply.content.status !== "ok") {
          this._info.reject("Kernel info reply errored");
          return reply;
        }
        this._info.resolve(reply.content);
        this._kernelSession = reply.header.session;
        return reply;
      }
      /**
       * Send a `complete_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#completion).
       *
       * Fulfills with the `complete_reply` content when the shell reply is
       * received and validated.
       */
      requestComplete(content) {
        const msg = KernelMessage.createMessage({
          msgType: "complete_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private36.handleShellMessage(this, msg);
      }
      /**
       * Send an `inspect_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#introspection).
       *
       * Fulfills with the `inspect_reply` content when the shell reply is
       * received and validated.
       */
      requestInspect(content) {
        const msg = KernelMessage.createMessage({
          msgType: "inspect_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private36.handleShellMessage(this, msg);
      }
      /**
       * Send a `history_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#history).
       *
       * Fulfills with the `history_reply` content when the shell reply is
       * received and validated.
       */
      requestHistory(content) {
        const msg = KernelMessage.createMessage({
          msgType: "history_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private36.handleShellMessage(this, msg);
      }
      /**
       * Send an `execute_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#execute).
       *
       * Future `onReply` is called with the `execute_reply` content when the
       * shell reply is received and validated. The future will resolve when
       * this message is received and the `idle` iopub status is received.
       * The future will also be disposed at this point unless `disposeOnDone`
       * is specified and `false`, in which case it is up to the caller to dispose
       * of the future.
       *
       * **See also:** [[IExecuteReply]]
       */
      requestExecute(content, disposeOnDone = true, metadata) {
        const defaults = {
          silent: false,
          store_history: true,
          user_expressions: {},
          allow_stdin: true,
          stop_on_error: false
        };
        const msg = KernelMessage.createMessage({
          msgType: "execute_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content: { ...defaults, ...content },
          metadata
        });
        return this.sendShellMessage(msg, true, disposeOnDone);
      }
      /**
       * Send an experimental `debug_request` message.
       *
       * @hidden
       *
       * #### Notes
       * Debug messages are experimental messages that are not in the official
       * kernel message specification. As such, this function is *NOT* considered
       * part of the public API, and may change without notice.
       */
      requestDebug(content, disposeOnDone = true) {
        const msg = KernelMessage.createMessage({
          msgType: "debug_request",
          channel: "control",
          username: this._username,
          session: this._clientId,
          content
        });
        return this.sendControlMessage(msg, true, disposeOnDone);
      }
      /**
       * Send an `is_complete_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#code-completeness).
       *
       * Fulfills with the `is_complete_response` content when the shell reply is
       * received and validated.
       */
      requestIsComplete(content) {
        const msg = KernelMessage.createMessage({
          msgType: "is_complete_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private36.handleShellMessage(this, msg);
      }
      /**
       * Send a `comm_info_request` message.
       *
       * #### Notes
       * Fulfills with the `comm_info_reply` content when the shell reply is
       * received and validated.
       */
      requestCommInfo(content) {
        const msg = KernelMessage.createMessage({
          msgType: "comm_info_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private36.handleShellMessage(this, msg);
      }
      /**
       * Send an `input_reply` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#messages-on-the-stdin-router-dealer-sockets).
       */
      sendInputReply(content, parent_header) {
        const msg = KernelMessage.createMessage({
          msgType: "input_reply",
          channel: "stdin",
          username: this._username,
          session: this._clientId,
          content
        });
        msg.parent_header = parent_header;
        this._sendMessage(msg);
        this._anyMessage.emit({ msg, direction: "send" });
        this.hasPendingInput = false;
      }
      /**
       * Create a new comm.
       *
       * #### Notes
       * If a client-side comm already exists with the given commId, an error is thrown.
       * If the kernel does not handle comms, an error is thrown.
       */
      createComm(targetName, commId = coreutils_2.UUID.uuid4()) {
        if (!this.handleComms) {
          throw new Error("Comms are disabled on this kernel connection");
        }
        if (this._comms.has(commId)) {
          throw new Error("Comm is already created");
        }
        const comm = new comm_1.CommHandler(targetName, commId, this, () => {
          this._unregisterComm(commId);
        });
        this._comms.set(commId, comm);
        return comm;
      }
      /**
       * Check if a comm exists.
       */
      hasComm(commId) {
        return this._comms.has(commId);
      }
      /**
       * Register a comm target handler.
       *
       * @param targetName - The name of the comm target.
       *
       * @param callback - The callback invoked for a comm open message.
       *
       * @returns A disposable used to unregister the comm target.
       *
       * #### Notes
       * Only one comm target can be registered to a target name at a time, an
       * existing callback for the same target name will be overridden.  A registered
       * comm target handler will take precedence over a comm which specifies a
       * `target_module`.
       *
       * If the callback returns a promise, kernel message processing will pause
       * until the returned promise is fulfilled.
       */
      registerCommTarget(targetName, callback) {
        if (!this.handleComms) {
          return;
        }
        this._targetRegistry[targetName] = callback;
      }
      /**
       * Remove a comm target handler.
       *
       * @param targetName - The name of the comm target to remove.
       *
       * @param callback - The callback to remove.
       *
       * #### Notes
       * The comm target is only removed if the callback argument matches.
       */
      removeCommTarget(targetName, callback) {
        if (!this.handleComms) {
          return;
        }
        if (!this.isDisposed && this._targetRegistry[targetName] === callback) {
          delete this._targetRegistry[targetName];
        }
      }
      /**
       * Register an IOPub message hook.
       *
       * @param msg_id - The parent_header message id the hook will intercept.
       *
       * @param hook - The callback invoked for the message.
       *
       * #### Notes
       * The IOPub hook system allows you to preempt the handlers for IOPub
       * messages that are responses to a given message id.
       *
       * The most recently registered hook is run first. A hook can return a
       * boolean or a promise to a boolean, in which case all kernel message
       * processing pauses until the promise is fulfilled. If a hook return value
       * resolves to false, any later hooks will not run and the function will
       * return a promise resolving to false. If a hook throws an error, the error
       * is logged to the console and the next hook is run. If a hook is
       * registered during the hook processing, it will not run until the next
       * message. If a hook is removed during the hook processing, it will be
       * deactivated immediately.
       *
       * See also [[IFuture.registerMessageHook]].
       */
      registerMessageHook(msgId, hook) {
        var _a;
        const future = (_a = this._futures) === null || _a === void 0 ? void 0 : _a.get(msgId);
        if (future) {
          future.registerMessageHook(hook);
        }
      }
      /**
       * Remove an IOPub message hook.
       *
       * @param msg_id - The parent_header message id the hook intercepted.
       *
       * @param hook - The callback invoked for the message.
       *
       */
      removeMessageHook(msgId, hook) {
        var _a;
        const future = (_a = this._futures) === null || _a === void 0 ? void 0 : _a.get(msgId);
        if (future) {
          future.removeMessageHook(hook);
        }
      }
      /**
       * Remove the input guard, if any.
       */
      removeInputGuard() {
        this.hasPendingInput = false;
      }
      /**
       * Handle a message with a display id.
       *
       * @returns Whether the message was handled.
       */
      async _handleDisplayId(displayId, msg) {
        var _a, _b;
        const msgId = msg.parent_header.msg_id;
        let parentIds = this._displayIdToParentIds.get(displayId);
        if (parentIds) {
          const updateMsg = {
            header: coreutils_2.JSONExt.deepCopy(msg.header),
            parent_header: coreutils_2.JSONExt.deepCopy(msg.parent_header),
            metadata: coreutils_2.JSONExt.deepCopy(msg.metadata),
            content: coreutils_2.JSONExt.deepCopy(msg.content),
            channel: msg.channel,
            buffers: msg.buffers ? msg.buffers.slice() : []
          };
          updateMsg.header.msg_type = "update_display_data";
          await Promise.all(parentIds.map(async (parentId) => {
            const future = this._futures && this._futures.get(parentId);
            if (future) {
              await future.handleMsg(updateMsg);
            }
          }));
        }
        if (msg.header.msg_type === "update_display_data") {
          return true;
        }
        parentIds = (_a = this._displayIdToParentIds.get(displayId)) !== null && _a !== void 0 ? _a : [];
        if (parentIds.indexOf(msgId) === -1) {
          parentIds.push(msgId);
        }
        this._displayIdToParentIds.set(displayId, parentIds);
        const displayIds = (_b = this._msgIdToDisplayIds.get(msgId)) !== null && _b !== void 0 ? _b : [];
        if (displayIds.indexOf(msgId) === -1) {
          displayIds.push(msgId);
        }
        this._msgIdToDisplayIds.set(msgId, displayIds);
        return false;
      }
      /**
       * Forcefully clear the socket state.
       *
       * #### Notes
       * This will clear all socket state without calling any handlers and will
       * not update the connection status. If you call this method, you are
       * responsible for updating the connection status as needed and recreating
       * the socket if you plan to reconnect.
       */
      _clearSocket() {
        if (this._ws !== null) {
          this._ws.onopen = this._noOp;
          this._ws.onclose = this._noOp;
          this._ws.onerror = this._noOp;
          this._ws.onmessage = this._noOp;
          this._ws.close();
          this._ws = null;
        }
      }
      /**
       * Handle status iopub messages from the kernel.
       */
      _updateStatus(status) {
        if (this._status === status || this._status === "dead") {
          return;
        }
        this._status = status;
        Private36.logKernelStatus(this);
        this._statusChanged.emit(status);
        if (status === "dead") {
          this.dispose();
        }
      }
      /**
       * Send pending messages to the kernel.
       */
      _sendPending() {
        while (this.connectionStatus === "connected" && this._kernelSession !== RESTARTING_KERNEL_SESSION && this._pendingMessages.length > 0) {
          this._sendMessage(this._pendingMessages[0], false);
          this._pendingMessages.shift();
        }
      }
      /**
       * Clear the internal state.
       */
      _clearKernelState() {
        this._kernelSession = "";
        this._pendingMessages = [];
        this._futures.forEach((future) => {
          future.dispose();
        });
        this._comms.forEach((comm) => {
          comm.dispose();
        });
        this._msgChain = Promise.resolve();
        this._futures = /* @__PURE__ */ new Map();
        this._comms = /* @__PURE__ */ new Map();
        this._displayIdToParentIds.clear();
        this._msgIdToDisplayIds.clear();
      }
      /**
       * Check to make sure it is okay to proceed to handle a message.
       *
       * #### Notes
       * Because we handle messages asynchronously, before a message is handled the
       * kernel might be disposed or restarted (and have a different session id).
       * This function throws an error in each of these cases. This is meant to be
       * called at the start of an asynchronous message handler to cancel message
       * processing if the message no longer is valid.
       */
      _assertCurrentMessage(msg) {
        this._errorIfDisposed();
        if (msg.header.session !== this._kernelSession) {
          throw new Error(`Canceling handling of old message: ${msg.header.msg_type}`);
        }
      }
      /**
       * Handle a `comm_open` kernel message.
       */
      async _handleCommOpen(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = new comm_1.CommHandler(content.target_name, content.comm_id, this, () => {
          this._unregisterComm(content.comm_id);
        });
        this._comms.set(content.comm_id, comm);
        try {
          const target2 = await Private36.loadObject(content.target_name, content.target_module, this._targetRegistry);
          await target2(comm, msg);
        } catch (e) {
          comm.close();
          console.error("Exception opening new comm");
          throw e;
        }
      }
      /**
       * Handle 'comm_close' kernel message.
       */
      async _handleCommClose(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = this._comms.get(content.comm_id);
        if (!comm) {
          console.error("Comm not found for comm id " + content.comm_id);
          return;
        }
        this._unregisterComm(comm.commId);
        const onClose = comm.onClose;
        if (onClose) {
          await onClose(msg);
        }
        comm.dispose();
      }
      /**
       * Handle a 'comm_msg' kernel message.
       */
      async _handleCommMsg(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = this._comms.get(content.comm_id);
        if (!comm) {
          return;
        }
        const onMsg = comm.onMsg;
        if (onMsg) {
          await onMsg(msg);
        }
      }
      /**
       * Unregister a comm instance.
       */
      _unregisterComm(commId) {
        this._comms.delete(commId);
      }
      /**
       * Handle connection status changes.
       */
      _updateConnectionStatus(connectionStatus) {
        if (this._connectionStatus === connectionStatus) {
          return;
        }
        this._connectionStatus = connectionStatus;
        if (connectionStatus !== "connecting") {
          this._reconnectAttempt = 0;
          clearTimeout(this._reconnectTimeout);
        }
        if (this.status !== "dead") {
          if (connectionStatus === "connected") {
            let restarting = this._kernelSession === RESTARTING_KERNEL_SESSION;
            let p = this.requestKernelInfo();
            let sendPendingCalled = false;
            let sendPendingOnce = () => {
              if (sendPendingCalled) {
                return;
              }
              sendPendingCalled = true;
              if (restarting && this._kernelSession === RESTARTING_KERNEL_SESSION) {
                this._kernelSession = "";
              }
              clearTimeout(timeoutHandle);
              if (this._pendingMessages.length > 0) {
                this._sendPending();
              }
            };
            void p.then(sendPendingOnce);
            let timeoutHandle = setTimeout(sendPendingOnce, KERNEL_INFO_TIMEOUT);
          } else {
            this._updateStatus("unknown");
          }
        }
        this._connectionStatusChanged.emit(connectionStatus);
      }
      async _handleMessage(msg) {
        var _a, _b;
        let handled = false;
        if (msg.parent_header && msg.channel === "iopub" && (KernelMessage.isDisplayDataMsg(msg) || KernelMessage.isUpdateDisplayDataMsg(msg) || KernelMessage.isExecuteResultMsg(msg))) {
          const transient = (_a = msg.content.transient) !== null && _a !== void 0 ? _a : {};
          const displayId = transient["display_id"];
          if (displayId) {
            handled = await this._handleDisplayId(displayId, msg);
            this._assertCurrentMessage(msg);
          }
        }
        if (!handled && msg.parent_header) {
          const parentHeader = msg.parent_header;
          const future = (_b = this._futures) === null || _b === void 0 ? void 0 : _b.get(parentHeader.msg_id);
          if (future) {
            await future.handleMsg(msg);
            this._assertCurrentMessage(msg);
          } else {
            const owned = parentHeader.session === this.clientId;
            if (msg.channel !== "iopub" && owned) {
              this._unhandledMessage.emit(msg);
            }
          }
        }
        if (msg.channel === "iopub") {
          switch (msg.header.msg_type) {
            case "status": {
              const executionState = msg.content.execution_state;
              if (executionState === "restarting") {
                void Promise.resolve().then(async () => {
                  this._updateStatus("autorestarting");
                  this._clearKernelState();
                  await this.reconnect();
                });
              }
              this._updateStatus(executionState);
              break;
            }
            case "comm_open":
              if (this.handleComms) {
                await this._handleCommOpen(msg);
              }
              break;
            case "comm_msg":
              if (this.handleComms) {
                await this._handleCommMsg(msg);
              }
              break;
            case "comm_close":
              if (this.handleComms) {
                await this._handleCommClose(msg);
              }
              break;
            default:
              break;
          }
          if (!this.isDisposed) {
            this._assertCurrentMessage(msg);
            this._iopubMessage.emit(msg);
          }
        }
      }
      /**
       * Attempt a connection if we have not exhausted connection attempts.
       */
      _reconnect() {
        this._errorIfDisposed();
        clearTimeout(this._reconnectTimeout);
        if (this._reconnectAttempt < this._reconnectLimit) {
          this._updateConnectionStatus("connecting");
          const timeout = Private36.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
          console.warn(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`);
          const useProtocols = this._selectedProtocol !== "" ? true : false;
          this._reconnectTimeout = setTimeout(this._createSocket, timeout, useProtocols);
          this._reconnectAttempt += 1;
        } else {
          this._updateConnectionStatus("disconnected");
        }
        this._clearSocket();
      }
      /**
       * Utility function to throw an error if this instance is disposed.
       */
      _errorIfDisposed() {
        if (this.isDisposed) {
          throw new Error("Kernel connection is disposed");
        }
      }
      get hasPendingInput() {
        return this._hasPendingInput;
      }
      set hasPendingInput(value) {
        this._hasPendingInput = value;
        this._pendingInput.emit(value);
      }
    };
    exports2.KernelConnection = KernelConnection;
    var Private36;
    (function(Private37) {
      function logKernelStatus(kernel) {
        switch (kernel.status) {
          case "idle":
          case "busy":
          case "unknown":
            return;
          default:
            console.debug(`Kernel: ${kernel.status} (${kernel.id})`);
            break;
        }
      }
      Private37.logKernelStatus = logKernelStatus;
      async function handleShellMessage(kernel, msg) {
        const future = kernel.sendShellMessage(msg, true);
        return future.done;
      }
      Private37.handleShellMessage = handleShellMessage;
      function loadObject(name2, moduleName, registry) {
        return new Promise((resolve, reject) => {
          if (moduleName) {
            if (typeof requirejs === "undefined") {
              throw new Error("requirejs not found");
            }
            requirejs([moduleName], (mod) => {
              if (mod[name2] === void 0) {
                const msg = `Object '${name2}' not found in module '${moduleName}'`;
                reject(new Error(msg));
              } else {
                resolve(mod[name2]);
              }
            }, reject);
          } else {
            if (registry === null || registry === void 0 ? void 0 : registry[name2]) {
              resolve(registry[name2]);
            } else {
              reject(new Error(`Object '${name2}' not found in registry`));
            }
          }
        });
      }
      Private37.loadObject = loadObject;
      function getRandomIntInclusive(min, max2) {
        min = Math.ceil(min);
        max2 = Math.floor(max2);
        return Math.floor(Math.random() * (max2 - min + 1)) + min;
      }
      Private37.getRandomIntInclusive = getRandomIntInclusive;
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/manager.js
var require_manager7 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelManager = void 0;
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib15();
    var basemanager_1 = require_basemanager2();
    var restapi_1 = require_restapi5();
    var default_1 = require_default4();
    var KernelManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new kernel manager.
       *
       * @param options - The default options for kernel.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._kernelConnections = /* @__PURE__ */ new Set();
        this._models = /* @__PURE__ */ new Map();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:KernelManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running kernels change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._models.clear();
        this._kernelConnections.forEach((x) => x.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /**
       * Connect to an existing kernel.
       *
       * @returns The new kernel connection.
       *
       * #### Notes
       * This will use the manager's server settings and ignore any server
       * settings passed in the options.
       */
      connectTo(options) {
        var _a;
        const { id } = options.model;
        let handleComms = (_a = options.handleComms) !== null && _a !== void 0 ? _a : true;
        if (options.handleComms === void 0) {
          for (const kc of this._kernelConnections) {
            if (kc.id === id && kc.handleComms) {
              handleComms = false;
              break;
            }
          }
        }
        const kernelConnection = new default_1.KernelConnection({
          handleComms,
          ...options,
          serverSettings: this.serverSettings
        });
        this._onStarted(kernelConnection);
        if (!this._models.has(id)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return kernelConnection;
      }
      /**
       * Create an iterator over the most recent running kernels.
       *
       * @returns A new iterator over the running kernels.
       */
      running() {
        return this._models.values();
      }
      /**
       * Force a refresh of the running kernels.
       *
       * @returns A promise that resolves when the running list has been refreshed.
       *
       * #### Notes
       * This is not typically meant to be called by the user, since the
       * manager maintains its own internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Start a new kernel.
       *
       * @param createOptions - The kernel creation options
       *
       * @param connectOptions - The kernel connection options
       *
       * @returns A promise that resolves with the kernel connection.
       *
       * #### Notes
       * The manager `serverSettings` will be always be used.
       */
      async startNew(createOptions = {}, connectOptions = {}) {
        const model = await (0, restapi_1.startNew)(createOptions, this.serverSettings);
        return this.connectTo({
          ...connectOptions,
          model
        });
      }
      /**
       * Shut down a kernel by id.
       *
       * @param id - The id of the target kernel.
       *
       * @returns A promise that resolves when the operation is complete.
       */
      async shutdown(id) {
        await (0, restapi_1.shutdownKernel)(id, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all kernels.
       *
       * @returns A promise that resolves when all of the kernels are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all([...this._models.keys()].map((id) => (0, restapi_1.shutdownKernel)(id, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Find a kernel by id.
       *
       * @param id - The id of the target kernel.
       *
       * @returns A promise that resolves with the kernel's model.
       */
      async findById(id) {
        if (this._models.has(id)) {
          return this._models.get(id);
        }
        await this.refreshRunning();
        return this._models.get(id);
      }
      /**
       * Execute a request to the server to poll running kernels and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof __1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        if (this._models.size === models.length && models.every((model) => {
          const existing = this._models.get(model.id);
          if (!existing) {
            return false;
          }
          return existing.connections === model.connections && existing.execution_state === model.execution_state && existing.last_activity === model.last_activity && existing.name === model.name && existing.reason === model.reason && existing.traceback === model.traceback;
        })) {
          return;
        }
        this._models = new Map(models.map((x) => [x.id, x]));
        this._kernelConnections.forEach((kc) => {
          if (!this._models.has(kc.id)) {
            kc.handleShutdown();
          }
        });
        this._runningChanged.emit(models);
      }
      /**
       * Handle a kernel starting.
       */
      _onStarted(kernelConnection) {
        this._kernelConnections.add(kernelConnection);
        kernelConnection.statusChanged.connect(this._onStatusChanged, this);
        kernelConnection.disposed.connect(this._onDisposed, this);
      }
      _onDisposed(kernelConnection) {
        this._kernelConnections.delete(kernelConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      _onStatusChanged(kernelConnection, status) {
        if (status === "dead") {
          void this.refreshRunning().catch(() => {
          });
        }
      }
    };
    exports2.KernelManager = KernelManager;
    (function(KernelManager2) {
      class NoopManager extends KernelManager2 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * Start a new kernel - throws an error since it is not supported.
         */
        async startNew(createOptions = {}, connectOptions = {}) {
          return Promise.reject(new Error("Not implemented in no-op Kernel Manager"));
        }
        /**
         * Connect to an existing kernel - throws an error since it is not supported.
         */
        connectTo(options) {
          throw new Error("Not implemented in no-op Kernel Manager");
        }
        /**
         * Shut down a kernel by id - throws an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Kernel Manager"));
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Execute a request to the server to poll running kernels and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      KernelManager2.NoopManager = NoopManager;
    })(KernelManager || (exports2.KernelManager = KernelManager = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/index.js
var require_kernel4 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/kernel/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelConnection = exports2.KernelAPI = exports2.KernelMessage = exports2.Kernel = void 0;
    var Kernel = __importStar2(require_kernel3());
    exports2.Kernel = Kernel;
    var KernelMessage = __importStar2(require_messages2());
    exports2.KernelMessage = KernelMessage;
    var KernelAPI = __importStar2(require_restapi5());
    exports2.KernelAPI = KernelAPI;
    var default_1 = require_default4();
    Object.defineProperty(exports2, "KernelConnection", { enumerable: true, get: function() {
      return default_1.KernelConnection;
    } });
    __exportStar2(require_manager7(), exports2);
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/builder/index.js
var require_builder2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/builder/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BuildManager = void 0;
    var coreutils_12 = require_lib14();
    var serverconnection_1 = require_serverconnection2();
    var BUILD_SETTINGS_URL = "api/build";
    var BuildManager = class {
      /**
       * Create a new setting manager.
       */
      constructor(options = {}) {
        var _a;
        this._url = "";
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        const { baseUrl, appUrl } = this.serverSettings;
        this._url = coreutils_12.URLExt.join(baseUrl, appUrl, BUILD_SETTINGS_URL);
      }
      /**
       * Test whether the build service is available.
       */
      get isAvailable() {
        return coreutils_12.PageConfig.getOption("buildAvailable").toLowerCase() === "true";
      }
      /**
       * Test whether to check build status automatically.
       */
      get shouldCheck() {
        return coreutils_12.PageConfig.getOption("buildCheck").toLowerCase() === "true";
      }
      /**
       * Get whether the application should be built.
       */
      getStatus() {
        const { _url, serverSettings } = this;
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, {}, serverSettings);
        return promise.then((response) => {
          if (response.status !== 200) {
            throw new serverconnection_1.ServerConnection.ResponseError(response);
          }
          return response.json();
        }).then((data) => {
          if (typeof data.status !== "string") {
            throw new Error("Invalid data");
          }
          if (typeof data.message !== "string") {
            throw new Error("Invalid data");
          }
          return data;
        });
      }
      /**
       * Build the application.
       */
      build() {
        const { _url, serverSettings } = this;
        const init = { method: "POST" };
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, init, serverSettings);
        return promise.then((response) => {
          if (response.status === 400) {
            throw new serverconnection_1.ServerConnection.ResponseError(response, "Build aborted");
          }
          if (response.status !== 200) {
            const message = `Build failed with ${response.status}.

        If you are experiencing the build failure after installing an extension (or trying to include previously installed extension after updating JupyterLab) please check the extension repository for new installation instructions as many extensions migrated to the prebuilt extensions system which no longer requires rebuilding JupyterLab (but uses a different installation procedure, typically involving a package manager such as 'pip' or 'conda').

        If you specifically intended to install a source extension, please run 'jupyter lab build' on the server for full output.`;
            throw new serverconnection_1.ServerConnection.ResponseError(response, message);
          }
        });
      }
      /**
       * Cancel an active build.
       */
      cancel() {
        const { _url, serverSettings } = this;
        const init = { method: "DELETE" };
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, init, serverSettings);
        return promise.then((response) => {
          if (response.status !== 204) {
            throw new serverconnection_1.ServerConnection.ResponseError(response);
          }
        });
      }
    };
    exports2.BuildManager = BuildManager;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/nbconvert/index.js
var require_nbconvert2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/nbconvert/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NbConvertManager = void 0;
    var coreutils_12 = require_lib14();
    var serverconnection_1 = require_serverconnection2();
    var coreutils_2 = require_dist();
    var NBCONVERT_SETTINGS_URL = "api/nbconvert";
    var NbConvertManager = class {
      /**
       * Create a new nbconvert manager.
       */
      constructor(options = {}) {
        var _a;
        this._exportFormats = null;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch and cache the export formats from the expensive nbconvert handler.
       */
      async fetchExportFormats() {
        this._requestingFormats = new coreutils_2.PromiseDelegate();
        this._exportFormats = null;
        const base = this.serverSettings.baseUrl;
        const url = coreutils_12.URLExt.join(base, NBCONVERT_SETTINGS_URL);
        const { serverSettings } = this;
        const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        const exportList = {};
        const keys = Object.keys(data);
        keys.forEach(function(key2) {
          const mimeType = data[key2].output_mimetype;
          exportList[key2] = { output_mimetype: mimeType };
        });
        this._exportFormats = exportList;
        this._requestingFormats.resolve(exportList);
        return exportList;
      }
      /**
       * Get the list of export formats, preferring pre-cached ones.
       */
      async getExportFormats(force = true) {
        if (this._requestingFormats) {
          return this._requestingFormats.promise;
        }
        if (force || !this._exportFormats) {
          return await this.fetchExportFormats();
        }
        return this._exportFormats;
      }
    };
    exports2.NbConvertManager = NbConvertManager;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/session/session.js
var require_session3 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/session/session.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/session/validate.js
var require_validate10 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/session/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateModels = exports2.updateLegacySessionModel = exports2.validateModel = void 0;
    var validate_1 = require_validate8();
    var validate_2 = require_validate6();
    function validateModel(data) {
      (0, validate_2.validateProperty)(data, "id", "string");
      (0, validate_2.validateProperty)(data, "type", "string");
      (0, validate_2.validateProperty)(data, "name", "string");
      (0, validate_2.validateProperty)(data, "path", "string");
      (0, validate_2.validateProperty)(data, "kernel", "object");
      (0, validate_1.validateModel)(data.kernel);
    }
    exports2.validateModel = validateModel;
    function updateLegacySessionModel(data) {
      if (data.path === void 0 && data.notebook !== void 0) {
        data.path = data.notebook.path;
        data.type = "notebook";
        data.name = "";
      }
    }
    exports2.updateLegacySessionModel = updateLegacySessionModel;
    function validateModels(models) {
      if (!Array.isArray(models)) {
        throw new Error("Invalid session list");
      }
      models.forEach((d) => validateModel(d));
    }
    exports2.validateModels = validateModels;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/session/restapi.js
var require_restapi7 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/session/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateSession = exports2.startSession = exports2.getSessionModel = exports2.shutdownSession = exports2.getSessionUrl = exports2.listRunning = exports2.SESSION_SERVICE_URL = void 0;
    var serverconnection_1 = require_serverconnection2();
    var coreutils_12 = require_lib14();
    var validate_1 = require_validate10();
    exports2.SESSION_SERVICE_URL = "api/sessions";
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.SESSION_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error("Invalid Session list");
      }
      data.forEach((m) => {
        (0, validate_1.updateLegacySessionModel)(m);
        (0, validate_1.validateModel)(m);
      });
      return data;
    }
    exports2.listRunning = listRunning;
    function getSessionUrl(baseUrl, id) {
      const servicesBase = coreutils_12.URLExt.join(baseUrl, exports2.SESSION_SERVICE_URL);
      const result = coreutils_12.URLExt.join(servicesBase, id);
      if (!result.startsWith(servicesBase)) {
        throw new Error("Can only be used for services requests");
      }
      return result;
    }
    exports2.getSessionUrl = getSessionUrl;
    async function shutdownSession(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      var _a;
      const url = getSessionUrl(settings.baseUrl, id);
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const data = await response.json();
        const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The session "${id}"" does not exist on the server`;
        console.warn(msg);
      } else if (response.status === 410) {
        throw new serverconnection_1.ServerConnection.ResponseError(response, "The kernel was deleted but the session was not");
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownSession = shutdownSession;
    async function getSessionModel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = getSessionUrl(settings.baseUrl, id);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.getSessionModel = getSessionModel;
    async function startSession(options, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.SESSION_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify(options)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 201) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.startSession = startSession;
    async function updateSession(model, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = getSessionUrl(settings.baseUrl, model.id);
      const init = {
        method: "PATCH",
        body: JSON.stringify(model)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.updateSession = updateSession;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/session/default.js
var require_default5 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/session/default.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionConnection = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib15();
    var restapi_1 = require_restapi7();
    var coreutils_12 = require_dist();
    var SessionConnection = class {
      /**
       * Construct a new session.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        this._id = "";
        this._path = "";
        this._name = "";
        this._type = "";
        this._kernel = null;
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this._kernelChanged = new signaling_1.Signal(this);
        this._statusChanged = new signaling_1.Signal(this);
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._pendingInput = new signaling_1.Signal(this);
        this._iopubMessage = new signaling_1.Signal(this);
        this._unhandledMessage = new signaling_1.Signal(this);
        this._anyMessage = new signaling_1.Signal(this);
        this._propertyChanged = new signaling_1.Signal(this);
        this._id = options.model.id;
        this._name = options.model.name;
        this._path = options.model.path;
        this._type = options.model.type;
        this._username = (_a = options.username) !== null && _a !== void 0 ? _a : "";
        this._clientId = (_b = options.clientId) !== null && _b !== void 0 ? _b : coreutils_12.UUID.uuid4();
        this._connectToKernel = options.connectToKernel;
        this._kernelConnectionOptions = (_c = options.kernelConnectionOptions) !== null && _c !== void 0 ? _c : {};
        this.serverSettings = (_d = options.serverSettings) !== null && _d !== void 0 ? _d : __1.ServerConnection.makeSettings();
        this.setupKernel(options.model.kernel);
      }
      /**
       * A signal emitted when the session is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when the kernel changes.
       */
      get kernelChanged() {
        return this._kernelChanged;
      }
      /**
       * A signal proxied from the connection about the kernel status.
       */
      get statusChanged() {
        return this._statusChanged;
      }
      /**
       * A signal proxied from the kernel about the connection status.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * A signal proxied from the kernel pending input.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * A signal proxied from the kernel about iopub kernel messages.
       */
      get iopubMessage() {
        return this._iopubMessage;
      }
      /**
       * A signal proxied from the kernel for an unhandled kernel message.
       */
      get unhandledMessage() {
        return this._unhandledMessage;
      }
      /**
       * A signal proxied from the kernel emitted for any kernel message.
       *
       * #### Notes
       * The behavior is undefined if the message is modified during message
       * handling. As such, it should be treated as read-only.
       */
      get anyMessage() {
        return this._anyMessage;
      }
      /**
       * A signal emitted when a session property changes.
       */
      get propertyChanged() {
        return this._propertyChanged;
      }
      /**
       * Get the session id.
       */
      get id() {
        return this._id;
      }
      /**
       * Get the session kernel connection object.
       *
       * #### Notes
       * This is a read-only property, and can be altered by [changeKernel].
       */
      get kernel() {
        return this._kernel;
      }
      /**
       * Get the session path.
       */
      get path() {
        return this._path;
      }
      /**
       * Get the session type.
       */
      get type() {
        return this._type;
      }
      /**
       * Get the session name.
       */
      get name() {
        return this._name;
      }
      /**
       * Get the model associated with the session.
       */
      get model() {
        return {
          id: this.id,
          kernel: this.kernel && { id: this.kernel.id, name: this.kernel.name },
          path: this._path,
          type: this._type,
          name: this._name
        };
      }
      /**
       * Test whether the session has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Update the session based on a session model from the server.
       *
       * #### Notes
       * This only updates this session connection instance. Use `setPath`,
       * `setName`, `setType`, and `changeKernel` to change the session values on
       * the server.
       */
      update(model) {
        const oldModel = this.model;
        this._path = model.path;
        this._name = model.name;
        this._type = model.type;
        if (this._kernel === null && model.kernel !== null || this._kernel !== null && model.kernel === null || this._kernel !== null && model.kernel !== null && this._kernel.id !== model.kernel.id) {
          if (this._kernel !== null) {
            this._kernel.dispose();
          }
          const oldValue = this._kernel || null;
          this.setupKernel(model.kernel);
          const newValue = this._kernel || null;
          this._kernelChanged.emit({ name: "kernel", oldValue, newValue });
        }
        this._handleModelChange(oldModel);
      }
      /**
       * Dispose of the resources held by the session.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        if (this._kernel) {
          this._kernel.dispose();
          const oldValue = this._kernel;
          this._kernel = null;
          const newValue = this._kernel;
          this._kernelChanged.emit({ name: "kernel", oldValue, newValue });
        }
        signaling_1.Signal.clearData(this);
      }
      /**
       * Change the session path.
       *
       * @param path - The new session path.
       *
       * @returns A promise that resolves when the session has renamed.
       *
       * #### Notes
       * This uses the Jupyter REST API, and the response is validated.
       * The promise is fulfilled on a valid response and rejected otherwise.
       */
      async setPath(path2) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ path: path2 });
      }
      /**
       * Change the session name.
       */
      async setName(name2) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ name: name2 });
      }
      /**
       * Change the session type.
       */
      async setType(type) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ type });
      }
      /**
       * Change the kernel.
       *
       * @param options - The name or id of the new kernel.
       *
       * #### Notes
       * This shuts down the existing kernel and creates a new kernel,
       * keeping the existing session ID and session path.
       */
      async changeKernel(options) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ kernel: options });
        return this.kernel;
      }
      /**
       * Kill the kernel and shutdown the session.
       *
       * @returns - The promise fulfilled on a valid response from the server.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/sessions), and validates the response.
       * Disposes of the session and emits a [sessionDied] signal on success.
       */
      async shutdown() {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await (0, restapi_1.shutdownSession)(this.id, this.serverSettings);
        this.dispose();
      }
      /**
       * Create a new kernel connection and connect to its signals.
       *
       * #### Notes
       * This method is not meant to be subclassed.
       */
      setupKernel(model) {
        if (model === null) {
          this._kernel = null;
          return;
        }
        const kc = this._connectToKernel({
          ...this._kernelConnectionOptions,
          model,
          username: this._username,
          clientId: this._clientId,
          serverSettings: this.serverSettings
        });
        this._kernel = kc;
        kc.statusChanged.connect(this.onKernelStatus, this);
        kc.connectionStatusChanged.connect(this.onKernelConnectionStatus, this);
        kc.pendingInput.connect(this.onPendingInput, this);
        kc.unhandledMessage.connect(this.onUnhandledMessage, this);
        kc.iopubMessage.connect(this.onIOPubMessage, this);
        kc.anyMessage.connect(this.onAnyMessage, this);
      }
      /**
       * Handle to changes in the Kernel status.
       */
      onKernelStatus(sender, state) {
        this._statusChanged.emit(state);
      }
      /**
       * Handle to changes in the Kernel status.
       */
      onKernelConnectionStatus(sender, state) {
        this._connectionStatusChanged.emit(state);
      }
      /**
       * Handle a change in the pendingInput.
       */
      onPendingInput(sender, state) {
        this._pendingInput.emit(state);
      }
      /**
       * Handle iopub kernel messages.
       */
      onIOPubMessage(sender, msg) {
        this._iopubMessage.emit(msg);
      }
      /**
       * Handle unhandled kernel messages.
       */
      onUnhandledMessage(sender, msg) {
        this._unhandledMessage.emit(msg);
      }
      /**
       * Handle any kernel messages.
       */
      onAnyMessage(sender, args) {
        this._anyMessage.emit(args);
      }
      /**
       * Send a PATCH to the server, updating the session path or the kernel.
       */
      async _patch(body) {
        const model = await (0, restapi_1.updateSession)({ ...body, id: this._id }, this.serverSettings);
        this.update(model);
        return model;
      }
      /**
       * Handle a change to the model.
       */
      _handleModelChange(oldModel) {
        if (oldModel.name !== this._name) {
          this._propertyChanged.emit("name");
        }
        if (oldModel.type !== this._type) {
          this._propertyChanged.emit("type");
        }
        if (oldModel.path !== this._path) {
          this._propertyChanged.emit("path");
        }
      }
    };
    exports2.SessionConnection = SessionConnection;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/session/manager.js
var require_manager8 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/session/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionManager = void 0;
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var serverconnection_1 = require_serverconnection2();
    var basemanager_1 = require_basemanager2();
    var default_1 = require_default5();
    var restapi_1 = require_restapi7();
    var SessionManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new session manager.
       *
       * @param options - The default options for each session.
       */
      constructor(options) {
        var _a;
        super(options);
        this._isReady = false;
        this._sessionConnections = /* @__PURE__ */ new Set();
        this._models = /* @__PURE__ */ new Map();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._connectToKernel = (options2) => {
          return this._kernelManager.connectTo(options2);
        };
        this._kernelManager = options.kernelManager;
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:SessionManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          if (this._kernelManager.isActive) {
            await this._kernelManager.ready;
          }
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running sessions change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._models.clear();
        this._sessionConnections.forEach((x) => x.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /*
       * Connect to a running session.  See also [[connectToSession]].
       */
      connectTo(options) {
        const sessionConnection = new default_1.SessionConnection({
          ...options,
          connectToKernel: this._connectToKernel,
          serverSettings: this.serverSettings
        });
        this._onStarted(sessionConnection);
        if (!this._models.has(options.model.id)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return sessionConnection;
      }
      /**
       * Create an iterator over the most recent running sessions.
       *
       * @returns A new iterator over the running sessions.
       */
      running() {
        return this._models.values();
      }
      /**
       * Force a refresh of the running sessions.
       *
       * @returns A promise that with the list of running sessions.
       *
       * #### Notes
       * This is not typically meant to be called by the user, since the
       * manager maintains its own internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Start a new session.  See also [[startNewSession]].
       *
       * @param createOptions - Options for creating the session
       *
       * @param connectOptions - Options for connecting to the session
       */
      async startNew(createOptions, connectOptions = {}) {
        const model = await (0, restapi_1.startSession)(createOptions, this.serverSettings);
        await this.refreshRunning();
        return this.connectTo({ ...connectOptions, model });
      }
      /**
       * Shut down a session by id.
       */
      async shutdown(id) {
        await (0, restapi_1.shutdownSession)(id, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all sessions.
       *
       * @returns A promise that resolves when all of the kernels are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all([...this._models.keys()].map((id) => (0, restapi_1.shutdownSession)(id, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Find a session associated with a path and stop it if it is the only session
       * using that kernel.
       *
       * @param path - The path in question.
       *
       * @returns A promise that resolves when the relevant sessions are stopped.
       */
      async stopIfNeeded(path2) {
        try {
          const sessions = await (0, restapi_1.listRunning)(this.serverSettings);
          const matches2 = sessions.filter((value) => value.path === path2);
          if (matches2.length === 1) {
            const id = matches2[0].id;
            await this.shutdown(id);
          }
        } catch (error) {
        }
      }
      /**
       * Find a session by id.
       */
      async findById(id) {
        if (this._models.has(id)) {
          return this._models.get(id);
        }
        await this.refreshRunning();
        return this._models.get(id);
      }
      /**
       * Find a session by path.
       */
      async findByPath(path2) {
        for (const m of this._models.values()) {
          if (m.path === path2) {
            return m;
          }
        }
        await this.refreshRunning();
        for (const m of this._models.values()) {
          if (m.path === path2) {
            return m;
          }
        }
        return void 0;
      }
      /**
       * Execute a request to the server to poll running kernels and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof serverconnection_1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        if (this._models.size === models.length && models.every((model) => {
          var _a2, _b2, _c, _d;
          const existing = this._models.get(model.id);
          if (!existing) {
            return false;
          }
          return ((_a2 = existing.kernel) === null || _a2 === void 0 ? void 0 : _a2.id) === ((_b2 = model.kernel) === null || _b2 === void 0 ? void 0 : _b2.id) && ((_c = existing.kernel) === null || _c === void 0 ? void 0 : _c.name) === ((_d = model.kernel) === null || _d === void 0 ? void 0 : _d.name) && existing.name === model.name && existing.path === model.path && existing.type === model.type;
        })) {
          return;
        }
        this._models = new Map(models.map((x) => [x.id, x]));
        this._sessionConnections.forEach((sc) => {
          if (this._models.has(sc.id)) {
            sc.update(this._models.get(sc.id));
          } else {
            sc.dispose();
          }
        });
        this._runningChanged.emit(models);
      }
      /**
       * Handle a session starting.
       */
      _onStarted(sessionConnection) {
        this._sessionConnections.add(sessionConnection);
        sessionConnection.disposed.connect(this._onDisposed, this);
        sessionConnection.propertyChanged.connect(this._onChanged, this);
        sessionConnection.kernelChanged.connect(this._onChanged, this);
      }
      _onDisposed(sessionConnection) {
        this._sessionConnections.delete(sessionConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      _onChanged() {
        void this.refreshRunning().catch(() => {
        });
      }
    };
    exports2.SessionManager = SessionManager;
    (function(SessionManager2) {
      class NoopManager extends SessionManager2 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * Start a new session - throw an error since it is not supported.
         */
        async startNew(createOptions, connectOptions = {}) {
          return Promise.reject(new Error("Not implemented in no-op Session Manager"));
        }
        /*
         * Connect to a running session - throw an error since it is not supported.
         */
        connectTo(options) {
          throw Error("Not implemented in no-op Session Manager");
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Shut down a session by id - throw an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Session Manager"));
        }
        /**
         * Execute a request to the server to poll running sessions and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      SessionManager2.NoopManager = NoopManager;
    })(SessionManager || (exports2.SessionManager = SessionManager = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/session/index.js
var require_session4 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/session/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionAPI = exports2.Session = void 0;
    var Session = __importStar2(require_session3());
    exports2.Session = Session;
    var SessionAPI = __importStar2(require_restapi7());
    exports2.SessionAPI = SessionAPI;
    __exportStar2(require_manager8(), exports2);
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/setting/index.js
var require_setting2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/setting/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SettingManager = void 0;
    var coreutils_12 = require_lib14();
    var statedb_1 = require_lib13();
    var serverconnection_1 = require_serverconnection2();
    var SERVICE_SETTINGS_URL = "api/settings";
    var SettingManager = class extends statedb_1.DataConnector {
      /**
       * Create a new setting manager.
       */
      constructor(options = {}) {
        var _a;
        super();
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch a plugin's settings.
       *
       * @param id - The plugin's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async fetch(id) {
        if (!id) {
          throw new Error("Plugin `id` parameter is required for settings fetch.");
        }
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private36.url(base, id);
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        return response.json();
      }
      /**
       * Fetch the list of all plugin setting bundles.
       *
       * @returns A promise that resolves if successful.
       */
      async list(query) {
        var _a, _b, _c, _d;
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private36.url(base, "", query === "ids");
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          throw new ResponseError(response);
        }
        const json = await response.json();
        const ids = (_b = (_a = json === null || json === void 0 ? void 0 : json["settings"]) === null || _a === void 0 ? void 0 : _a.map((plugin) => plugin.id)) !== null && _b !== void 0 ? _b : [];
        let values = [];
        if (!query) {
          values = (_d = (_c = json === null || json === void 0 ? void 0 : json["settings"]) === null || _c === void 0 ? void 0 : _c.map((plugin) => {
            plugin.data = { composite: {}, user: {} };
            return plugin;
          })) !== null && _d !== void 0 ? _d : [];
        }
        return { ids, values };
      }
      /**
       * Save a plugin's settings.
       *
       * @param id - The plugin's ID.
       *
       * @param raw - The user setting values as a raw string of JSON with comments.
       *
       * @returns A promise that resolves if successful.
       */
      async save(id, raw) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private36.url(base, id);
        const init = { body: JSON.stringify({ raw }), method: "PUT" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          throw new ResponseError(response);
        }
      }
    };
    exports2.SettingManager = SettingManager;
    var Private36;
    (function(Private37) {
      function url(base, id, idsOnly) {
        const idsOnlyParam = idsOnly ? coreutils_12.URLExt.objectToQueryString({ ids_only: true }) : "";
        const settingsBase = coreutils_12.URLExt.join(base, SERVICE_SETTINGS_URL);
        const result = coreutils_12.URLExt.join(settingsBase, id);
        if (!result.startsWith(settingsBase)) {
          throw new Error("Can only be used for workspaces requests");
        }
        return `${result}${idsOnlyParam}`;
      }
      Private37.url = url;
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/terminal/restapi.js
var require_restapi8 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/terminal/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shutdownTerminal = exports2.listRunning = exports2.startNew = exports2.isAvailable = exports2.TERMINAL_SERVICE_URL = void 0;
    var coreutils_12 = require_lib14();
    var serverconnection_1 = require_serverconnection2();
    exports2.TERMINAL_SERVICE_URL = "api/terminals";
    function isAvailable() {
      const available = String(coreutils_12.PageConfig.getOption("terminalsAvailable"));
      return available.toLowerCase() === "true";
    }
    exports2.isAvailable = isAvailable;
    async function startNew(settings = serverconnection_1.ServerConnection.makeSettings(), name2, cwd) {
      Private36.errorIfNotAvailable();
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify({ name: name2, cwd })
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      return data;
    }
    exports2.startNew = startNew;
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      Private36.errorIfNotAvailable();
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error("Invalid terminal list");
      }
      return data;
    }
    exports2.listRunning = listRunning;
    async function shutdownTerminal(name2, settings = serverconnection_1.ServerConnection.makeSettings()) {
      var _a;
      Private36.errorIfNotAvailable();
      const workspacesBase = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const url = coreutils_12.URLExt.join(workspacesBase, name2);
      if (!url.startsWith(workspacesBase)) {
        throw new Error("Can only be used for terminal requests");
      }
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const data = await response.json();
        const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The terminal session "${name2}"" does not exist on the server`;
        console.warn(msg);
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownTerminal = shutdownTerminal;
    var Private36;
    (function(Private37) {
      function errorIfNotAvailable() {
        if (!isAvailable()) {
          throw new Error("Terminals Unavailable");
        }
      }
      Private37.errorIfNotAvailable = errorIfNotAvailable;
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/terminal/terminal.js
var require_terminal3 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/terminal/terminal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAvailable = void 0;
    var restapi_1 = require_restapi8();
    Object.defineProperty(exports2, "isAvailable", { enumerable: true, get: function() {
      return restapi_1.isAvailable;
    } });
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/terminal/default.js
var require_default6 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/terminal/default.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalConnection = void 0;
    var coreutils_12 = require_lib14();
    var coreutils_2 = require_dist();
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib15();
    var restapi_1 = require_restapi8();
    var TerminalConnection = class {
      /**
       * Construct a new terminal session.
       */
      constructor(options) {
        var _a;
        this._createSocket = () => {
          this._errorIfDisposed();
          this._clearSocket();
          this._updateConnectionStatus("connecting");
          const name2 = this._name;
          const settings = this.serverSettings;
          let url = coreutils_12.URLExt.join(settings.wsUrl, "terminals", "websocket", encodeURIComponent(name2));
          const token = settings.token;
          if (settings.appendToken && token !== "") {
            url = url + `?token=${encodeURIComponent(token)}`;
          }
          this._ws = new settings.WebSocket(url);
          this._ws.onmessage = this._onWSMessage;
          this._ws.onclose = this._onWSClose;
          this._ws.onerror = this._onWSClose;
        };
        this._onWSMessage = (event) => {
          if (this._isDisposed) {
            return;
          }
          const data = JSON.parse(event.data);
          if (data[0] === "disconnect") {
            this.dispose();
          }
          if (this._connectionStatus === "connecting") {
            if (data[0] === "setup") {
              this._updateConnectionStatus("connected");
            }
            return;
          }
          this._messageReceived.emit({
            type: data[0],
            content: data.slice(1)
          });
        };
        this._onWSClose = (event) => {
          console.warn(`Terminal websocket closed: ${event.code}`);
          if (!this.isDisposed) {
            this._reconnect();
          }
        };
        this._connectionStatus = "connecting";
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this._messageReceived = new signaling_1.Signal(this);
        this._reconnectTimeout = null;
        this._ws = null;
        this._noOp = () => {
        };
        this._reconnectLimit = 7;
        this._reconnectAttempt = 0;
        this._pendingMessages = [];
        this._name = options.model.name;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._createSocket();
      }
      /**
       * A signal emitted when the session is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when a message is received from the server.
       */
      get messageReceived() {
        return this._messageReceived;
      }
      /**
       * Get the name of the terminal session.
       */
      get name() {
        return this._name;
      }
      /**
       * Get the model for the terminal session.
       */
      get model() {
        return { name: this._name };
      }
      /**
       * Test whether the session is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the session.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        this._updateConnectionStatus("disconnected");
        this._clearSocket();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Send a message to the terminal session.
       *
       * #### Notes
       * If the connection is down, the message will be queued for sending when
       * the connection comes back up.
       */
      send(message) {
        this._sendMessage(message);
      }
      /**
       * Send a message on the websocket, or possibly queue for later sending.
       *
       * @param queue - whether to queue the message if it cannot be sent
       */
      _sendMessage(message, queue = true) {
        if (this._isDisposed || !message.content) {
          return;
        }
        if (this.connectionStatus === "connected" && this._ws) {
          const msg = [message.type, ...message.content];
          this._ws.send(JSON.stringify(msg));
        } else if (queue) {
          this._pendingMessages.push(message);
        } else {
          throw new Error(`Could not send message: ${JSON.stringify(message)}`);
        }
      }
      /**
       * Send pending messages to the kernel.
       */
      _sendPending() {
        while (this.connectionStatus === "connected" && this._pendingMessages.length > 0) {
          this._sendMessage(this._pendingMessages[0], false);
          this._pendingMessages.shift();
        }
      }
      /**
       * Reconnect to a terminal.
       *
       * #### Notes
       * This may try multiple times to reconnect to a terminal, and will sever
       * any existing connection.
       */
      reconnect() {
        this._errorIfDisposed();
        const result = new coreutils_2.PromiseDelegate();
        const fulfill = (sender, status) => {
          if (status === "connected") {
            result.resolve();
            this.connectionStatusChanged.disconnect(fulfill, this);
          } else if (status === "disconnected") {
            result.reject(new Error("Terminal connection disconnected"));
            this.connectionStatusChanged.disconnect(fulfill, this);
          }
        };
        this.connectionStatusChanged.connect(fulfill, this);
        this._reconnectAttempt = 0;
        this._reconnect();
        return result.promise;
      }
      /**
       * Attempt a connection if we have not exhausted connection attempts.
       */
      _reconnect() {
        this._errorIfDisposed();
        clearTimeout(this._reconnectTimeout);
        if (this._reconnectAttempt < this._reconnectLimit) {
          this._updateConnectionStatus("connecting");
          const timeout = Private36.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
          console.error(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`);
          this._reconnectTimeout = setTimeout(this._createSocket, timeout);
          this._reconnectAttempt += 1;
        } else {
          this._updateConnectionStatus("disconnected");
        }
        this._clearSocket();
      }
      /**
       * Forcefully clear the socket state.
       *
       * #### Notes
       * This will clear all socket state without calling any handlers and will
       * not update the connection status. If you call this method, you are
       * responsible for updating the connection status as needed and recreating
       * the socket if you plan to reconnect.
       */
      _clearSocket() {
        if (this._ws !== null) {
          this._ws.onopen = this._noOp;
          this._ws.onclose = this._noOp;
          this._ws.onerror = this._noOp;
          this._ws.onmessage = this._noOp;
          this._ws.close();
          this._ws = null;
        }
      }
      /**
       * Shut down the terminal session.
       */
      async shutdown() {
        await (0, restapi_1.shutdownTerminal)(this.name, this.serverSettings);
        this.dispose();
      }
      /**
       * Clone the current terminal connection.
       */
      clone() {
        return new TerminalConnection(this);
      }
      /**
       * Handle connection status changes.
       */
      _updateConnectionStatus(connectionStatus) {
        if (this._connectionStatus === connectionStatus) {
          return;
        }
        this._connectionStatus = connectionStatus;
        if (connectionStatus !== "connecting") {
          this._reconnectAttempt = 0;
          clearTimeout(this._reconnectTimeout);
        }
        if (connectionStatus === "connected") {
          this._sendPending();
        }
        this._connectionStatusChanged.emit(connectionStatus);
      }
      /**
       * Utility function to throw an error if this instance is disposed.
       */
      _errorIfDisposed() {
        if (this.isDisposed) {
          throw new Error("Terminal connection is disposed");
        }
      }
      /**
       * A signal emitted when the terminal connection status changes.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * The current connection status of the terminal connection.
       */
      get connectionStatus() {
        return this._connectionStatus;
      }
    };
    exports2.TerminalConnection = TerminalConnection;
    var Private36;
    (function(Private37) {
      function getTermUrl(baseUrl, name2) {
        return coreutils_12.URLExt.join(baseUrl, restapi_1.TERMINAL_SERVICE_URL, encodeURIComponent(name2));
      }
      Private37.getTermUrl = getTermUrl;
      function getRandomIntInclusive(min, max2) {
        min = Math.ceil(min);
        max2 = Math.floor(max2);
        return Math.floor(Math.random() * (max2 - min + 1)) + min;
      }
      Private37.getRandomIntInclusive = getRandomIntInclusive;
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/terminal/manager.js
var require_manager9 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/terminal/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalManager = void 0;
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib15();
    var basemanager_1 = require_basemanager2();
    var restapi_1 = require_restapi8();
    var default_1 = require_default6();
    var TerminalManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new terminal manager.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._names = [];
        this._terminalConnections = /* @__PURE__ */ new Set();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        if (!this.isAvailable()) {
          this._ready = Promise.reject("Terminals unavailable");
          this._ready.catch((_) => void 0);
          return;
        }
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:TerminalManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running terminals change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._names.length = 0;
        this._terminalConnections.forEach((x) => x.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /**
       * Whether the terminal service is available.
       */
      isAvailable() {
        return (0, restapi_1.isAvailable)();
      }
      /*
       * Connect to a running terminal.
       *
       * @param options - The options used to connect to the terminal.
       *
       * @returns The new terminal connection instance.
       *
       * #### Notes
       * The manager `serverSettings` will be used.
       */
      connectTo(options) {
        const terminalConnection = new default_1.TerminalConnection({
          ...options,
          serverSettings: this.serverSettings
        });
        this._onStarted(terminalConnection);
        if (!this._names.includes(options.model.name)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return terminalConnection;
      }
      /**
       * Create an iterator over the most recent running terminals.
       *
       * @returns A new iterator over the running terminals.
       */
      running() {
        return this._models[Symbol.iterator]();
      }
      /**
       * Force a refresh of the running terminals.
       *
       * @returns A promise that with the list of running terminals.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Create a new terminal session.
       *
       * @param options - The options used to create the terminal.
       *
       * @returns A promise that resolves with the terminal connection instance.
       *
       * #### Notes
       * The manager `serverSettings` will be used unless overridden in the
       * options.
       */
      async startNew(options) {
        const model = await (0, restapi_1.startNew)(this.serverSettings, options === null || options === void 0 ? void 0 : options.name, options === null || options === void 0 ? void 0 : options.cwd);
        await this.refreshRunning();
        return this.connectTo({ model });
      }
      /**
       * Shut down a terminal session by name.
       */
      async shutdown(name2) {
        await (0, restapi_1.shutdownTerminal)(name2, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all terminal sessions.
       *
       * @returns A promise that resolves when all of the sessions are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all(this._names.map((name2) => (0, restapi_1.shutdownTerminal)(name2, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Execute a request to the server to poll running terminals and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof __1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        const names = models.map(({ name: name2 }) => name2).sort();
        if (names === this._names) {
          return;
        }
        this._names = names;
        this._terminalConnections.forEach((tc) => {
          if (!names.includes(tc.name)) {
            tc.dispose();
          }
        });
        this._runningChanged.emit(this._models);
      }
      /**
       * Handle a session starting.
       */
      _onStarted(terminalConnection) {
        this._terminalConnections.add(terminalConnection);
        terminalConnection.disposed.connect(this._onDisposed, this);
      }
      /**
       * Handle a session terminating.
       */
      _onDisposed(terminalConnection) {
        this._terminalConnections.delete(terminalConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      get _models() {
        return this._names.map((name2) => {
          return { name: name2 };
        });
      }
    };
    exports2.TerminalManager = TerminalManager;
    (function(TerminalManager2) {
      class NoopManager extends TerminalManager2 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Create a new terminal session - throw an error since it is not supported.
         *
         */
        async startNew(options) {
          return Promise.reject(new Error("Not implemented in no-op Terminal Manager"));
        }
        /*
         * Connect to a running terminal - throw an error since it is not supported.
         */
        connectTo(options) {
          throw Error("Not implemented in no-op Terminal Manager");
        }
        /**
         * Shut down a session by id - throw an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Terminal Manager"));
        }
        /**
         * Execute a request to the server to poll running sessions and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      TerminalManager2.NoopManager = NoopManager;
    })(TerminalManager || (exports2.TerminalManager = TerminalManager = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/terminal/index.js
var require_terminal4 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/terminal/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalAPI = exports2.Terminal = void 0;
    var Terminal = __importStar2(require_terminal3());
    exports2.Terminal = Terminal;
    var TerminalAPI = __importStar2(require_restapi8());
    exports2.TerminalAPI = TerminalAPI;
    __exportStar2(require_manager9(), exports2);
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/user/index.js
var require_user2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/user/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserManager = void 0;
    var coreutils_12 = require_lib14();
    var coreutils_2 = require_dist();
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var serverconnection_1 = require_serverconnection2();
    var basemanager_1 = require_basemanager2();
    var SERVICE_USER_URL = "api/me";
    var SERVICE_ID = "@jupyterlab/services:UserManager#user";
    var UserManager = class extends basemanager_1.BaseManager {
      /**
       * Create a new user manager.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._userChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._ready = this.requestUser().then(() => {
          if (this.isDisposed) {
            return;
          }
          this._isReady = true;
        }).catch((_) => (
          // Return a promise that will never resolve, so user service is never ready
          // This typically occurs when the backend has no user service
          new Promise(() => {
          })
        ));
        this._pollSpecs = new polling_1.Poll({
          auto: false,
          factory: () => this.requestUser(),
          frequency: {
            interval: 61 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: SERVICE_ID,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        void this.ready.then(() => {
          void this._pollSpecs.start();
        });
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * Get the most recently fetched identity.
       */
      get identity() {
        return this._identity;
      }
      /**
       * Get the most recently fetched permissions.
       */
      get permissions() {
        return this._permissions;
      }
      /**
       * A signal emitted when the user changes.
       */
      get userChanged() {
        return this._userChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        this._pollSpecs.dispose();
        super.dispose();
      }
      /**
       * Force a refresh of the specs from the server.
       *
       * @returns A promise that resolves when the specs are fetched.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshUser() {
        await this._pollSpecs.refresh();
        await this._pollSpecs.tick;
      }
      /**
       * Execute a request to the server to poll the user and update state.
       */
      async requestUser() {
        if (this.isDisposed) {
          return;
        }
        const { baseUrl } = this.serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const url = coreutils_12.URLExt.join(baseUrl, SERVICE_USER_URL);
        const response = await makeRequest(url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        const oldUser = {
          identity: this._identity,
          permissions: this._permissions
        };
        const newUser = await response.json();
        const identity = newUser.identity;
        const { localStorage } = window;
        const data = localStorage.getItem(SERVICE_ID);
        if (data && (!identity.initials || !identity.color)) {
          const localUser = JSON.parse(data);
          identity.initials = identity.initials || localUser.initials || identity.name.substring(0, 1);
          identity.color = identity.color || localUser.color || Private36.getRandomColor();
        }
        if (!coreutils_2.JSONExt.deepEqual(newUser, oldUser)) {
          this._identity = identity;
          this._permissions = newUser.permissions;
          localStorage.setItem(SERVICE_ID, JSON.stringify(identity));
          this._userChanged.emit(newUser);
        }
      }
    };
    exports2.UserManager = UserManager;
    var Private36;
    (function(Private37) {
      const userColors = [
        "var(--jp-collaborator-color1)",
        "var(--jp-collaborator-color2)",
        "var(--jp-collaborator-color3)",
        "var(--jp-collaborator-color4)",
        "var(--jp-collaborator-color5)",
        "var(--jp-collaborator-color6)",
        "var(--jp-collaborator-color7)"
      ];
      Private37.getRandomColor = () => userColors[Math.floor(Math.random() * userColors.length)];
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/workspace/index.js
var require_workspace2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/workspace/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceManager = void 0;
    var coreutils_12 = require_lib14();
    var statedb_1 = require_lib13();
    var serverconnection_1 = require_serverconnection2();
    var SERVICE_WORKSPACES_URL = "api/workspaces";
    var WorkspaceManager = class extends statedb_1.DataConnector {
      /**
       * Create a new workspace manager.
       */
      constructor(options = {}) {
        var _a;
        super();
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch a workspace.
       *
       * @param id - The workspace's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async fetch(id) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private36.url(base, id);
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        return response.json();
      }
      /**
       * Fetch the list of workspace IDs that exist on the server.
       *
       * @returns A promise that resolves if successful.
       */
      async list() {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private36.url(base, "");
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        const result = await response.json();
        return result.workspaces;
      }
      /**
       * Remove a workspace from the server.
       *
       * @param id - The workspaces's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async remove(id) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private36.url(base, id);
        const init = { method: "DELETE" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          const err = await ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Save a workspace.
       *
       * @param id - The workspace's ID.
       *
       * @param workspace - The workspace being saved.
       *
       * @returns A promise that resolves if successful.
       */
      async save(id, workspace) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private36.url(base, id);
        const init = { body: JSON.stringify(workspace), method: "PUT" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          const err = await ResponseError.create(response);
          throw err;
        }
      }
    };
    exports2.WorkspaceManager = WorkspaceManager;
    var Private36;
    (function(Private37) {
      function url(base, id) {
        const workspacesBase = coreutils_12.URLExt.join(base, SERVICE_WORKSPACES_URL);
        const result = coreutils_12.URLExt.join(workspacesBase, id);
        if (!result.startsWith(workspacesBase)) {
          throw new Error("Can only be used for workspaces requests");
        }
        return result;
      }
      Private37.url = url;
    })(Private36 || (Private36 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/manager.js
var require_manager10 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServiceManager = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var builder_1 = require_builder2();
    var contents_1 = require_contents2();
    var event_1 = require_event2();
    var kernel_1 = require_kernel4();
    var kernelspec_1 = require_kernelspec4();
    var nbconvert_1 = require_nbconvert2();
    var serverconnection_1 = require_serverconnection2();
    var session_1 = require_session4();
    var setting_1 = require_setting2();
    var terminal_1 = require_terminal4();
    var user_1 = require_user2();
    var workspace_1 = require_workspace2();
    var ServiceManager = class {
      /**
       * Construct a new services provider.
       */
      constructor(options = {}) {
        var _a, _b;
        this._isDisposed = false;
        this._connectionFailure = new signaling_1.Signal(this);
        this._isReady = false;
        const defaultDrive = options.defaultDrive;
        const serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        const standby = (_b = options.standby) !== null && _b !== void 0 ? _b : "when-hidden";
        const normalized = { defaultDrive, serverSettings, standby };
        this.serverSettings = serverSettings;
        this.contents = options.contents || new contents_1.ContentsManager(normalized);
        this.events = options.events || new event_1.EventManager(normalized);
        this.kernels = options.kernels || new kernel_1.KernelManager(normalized);
        this.sessions = options.sessions || new session_1.SessionManager({
          ...normalized,
          kernelManager: this.kernels
        });
        this.settings = options.settings || new setting_1.SettingManager(normalized);
        this.terminals = options.terminals || new terminal_1.TerminalManager(normalized);
        this.builder = options.builder || new builder_1.BuildManager(normalized);
        this.workspaces = options.workspaces || new workspace_1.WorkspaceManager(normalized);
        this.nbconvert = options.nbconvert || new nbconvert_1.NbConvertManager(normalized);
        this.kernelspecs = options.kernelspecs || new kernelspec_1.KernelSpecManager(normalized);
        this.user = options.user || new user_1.UserManager(normalized);
        this.kernelspecs.connectionFailure.connect(this._onConnectionFailure, this);
        this.sessions.connectionFailure.connect(this._onConnectionFailure, this);
        this.terminals.connectionFailure.connect(this._onConnectionFailure, this);
        const readyList = [this.sessions.ready, this.kernelspecs.ready];
        if (this.terminals.isAvailable()) {
          readyList.push(this.terminals.ready);
        }
        this._readyPromise = Promise.all(readyList).then(() => {
          this._isReady = true;
        });
      }
      /**
       * A signal emitted when there is a connection failure with the kernel.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Test whether the service manager is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
        this.contents.dispose();
        this.events.dispose();
        this.sessions.dispose();
        this.terminals.dispose();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._readyPromise;
      }
      _onConnectionFailure(sender, err) {
        this._connectionFailure.emit(err);
      }
    };
    exports2.ServiceManager = ServiceManager;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/index.js
var require_lib15 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/@jupyterlab/services/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_basemanager2(), exports2);
    __exportStar2(require_config2(), exports2);
    __exportStar2(require_contents2(), exports2);
    __exportStar2(require_event2(), exports2);
    __exportStar2(require_kernel4(), exports2);
    __exportStar2(require_kernelspec4(), exports2);
    __exportStar2(require_manager10(), exports2);
    __exportStar2(require_serverconnection2(), exports2);
    __exportStar2(require_session4(), exports2);
    __exportStar2(require_setting2(), exports2);
    __exportStar2(require_terminal4(), exports2);
    __exportStar2(require_user2(), exports2);
    __exportStar2(require_workspace2(), exports2);
    __exportStar2(require_nbconvert2(), exports2);
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/printing.js
var import_services2, Printing;
var init_printing = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/printing.js"() {
    import_services2 = __toESM(require_lib15());
    (function(Printing2) {
      Printing2.symbol = Symbol("printable");
      function isPrintable(a) {
        if (typeof a !== "object" || !a) {
          return false;
        }
        return Printing2.symbol in a;
      }
      Printing2.isPrintable = isPrintable;
      function getPrintFunction(val) {
        if (isPrintable(val)) {
          return val[Printing2.symbol]();
        }
        return null;
      }
      Printing2.getPrintFunction = getPrintFunction;
      function printWidget(widget) {
        return printContent(widget.node);
      }
      Printing2.printWidget = printWidget;
      async function printURL(url) {
        const settings = import_services2.ServerConnection.makeSettings();
        const text = await (await import_services2.ServerConnection.makeRequest(url, {}, settings)).text();
        return printContent(text);
      }
      Printing2.printURL = printURL;
      async function printContent(textOrEl) {
        const isText = typeof textOrEl === "string";
        const iframe = createIFrame();
        const parent = window.document.body;
        parent.appendChild(iframe);
        if (isText) {
          iframe.srcdoc = textOrEl;
          await resolveWhenLoaded(iframe);
        } else {
          iframe.src = "about:blank";
          await resolveWhenLoaded(iframe);
          setIFrameNode(iframe, textOrEl);
        }
        const printed = resolveAfterEvent();
        launchPrint(iframe.contentWindow);
        await printed;
        parent.removeChild(iframe);
      }
      function createIFrame() {
        const el = window.document.createElement("iframe");
        el.setAttribute("sandbox", "allow-modals allow-same-origin");
        const css2 = "visibility:hidden;width:0;height:0;position:absolute;z-index:-9999;bottom:0;";
        el.setAttribute("style", css2);
        el.setAttribute("width", "0");
        el.setAttribute("height", "0");
        return el;
      }
      function setIFrameNode(iframe, node) {
        iframe.contentDocument.body.appendChild(node.cloneNode(true));
        iframe.contentDocument.close();
      }
      function resolveWhenLoaded(iframe) {
        return new Promise((resolve) => {
          iframe.onload = () => resolve();
        });
      }
      function resolveAfterEvent() {
        return new Promise((resolve) => {
          const onEvent = () => {
            document.removeEventListener("mousemove", onEvent, true);
            document.removeEventListener("mousedown", onEvent, true);
            document.removeEventListener("keydown", onEvent, true);
            resolve();
          };
          document.addEventListener("mousemove", onEvent, true);
          document.addEventListener("mousedown", onEvent, true);
          document.addEventListener("keydown", onEvent, true);
        });
      }
      function launchPrint(contentWindow) {
        const result = contentWindow.document.execCommand("print", false);
        if (!result) {
          contentWindow.print();
        }
      }
    })(Printing || (Printing = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/mainareawidget.js
var USE_CAPTURE, MainAreaWidget;
var init_mainareawidget = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/mainareawidget.js"() {
    init_lib();
    init_lib5();
    init_index_es627();
    init_index_es618();
    init_domutils();
    init_printing();
    USE_CAPTURE = true;
    MainAreaWidget = class extends Widget {
      /**
       * Construct a new main area widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this._changeGuard = false;
        this._spinner = new Spinner();
        this._isRevealed = false;
        this._evtMouseDown = () => {
          if (!this.node.contains(document.activeElement)) {
            this._focusContent();
          }
        };
        this.addClass("jp-MainAreaWidget");
        this.addClass("jp-MainAreaWidget-ContainStrict");
        this.id = DOMUtils.createDomID();
        const trans = (options.translator || nullTranslator).load("jupyterlab");
        const content = this._content = options.content;
        content.node.setAttribute("role", "region");
        content.node.setAttribute("aria-label", trans.__("notebook content"));
        const toolbar = this._toolbar = options.toolbar || new ReactiveToolbar();
        toolbar.node.setAttribute("role", "toolbar");
        toolbar.node.setAttribute("aria-label", trans.__("notebook actions"));
        const contentHeader = this._contentHeader = options.contentHeader || new BoxPanel({
          direction: "top-to-bottom",
          spacing: 0
        });
        const layout = this.layout = new BoxLayout({ spacing: 0 });
        layout.direction = "top-to-bottom";
        BoxLayout.setStretch(toolbar, 0);
        BoxLayout.setStretch(contentHeader, 0);
        BoxLayout.setStretch(content, 1);
        layout.addWidget(toolbar);
        layout.addWidget(contentHeader);
        layout.addWidget(content);
        if (!content.id) {
          content.id = DOMUtils.createDomID();
        }
        content.node.tabIndex = -1;
        this._updateTitle();
        content.title.changed.connect(this._updateTitle, this);
        this.title.closable = true;
        this.title.changed.connect(this._updateContentTitle, this);
        if (options.reveal) {
          this.node.appendChild(this._spinner.node);
          this._revealed = options.reveal.then(() => {
            if (content.isDisposed) {
              this.dispose();
              return;
            }
            content.disposed.connect(() => this.dispose());
            const active = document.activeElement === this._spinner.node;
            this._disposeSpinner();
            this._isRevealed = true;
            if (active) {
              this._focusContent();
            }
          }).catch((e) => {
            const error = new Widget();
            error.addClass("jp-MainAreaWidget-error");
            const pre = document.createElement("pre");
            pre.textContent = String(e);
            error.node.appendChild(pre);
            BoxLayout.setStretch(error, 1);
            this._disposeSpinner();
            content.dispose();
            this._content = null;
            toolbar.dispose();
            this._toolbar = null;
            layout.addWidget(error);
            this._isRevealed = true;
            throw error;
          });
        } else {
          this._spinner.dispose();
          this.removeClass("jp-MainAreaWidget-ContainStrict");
          content.disposed.connect(() => this.dispose());
          this._isRevealed = true;
          this._revealed = Promise.resolve(void 0);
        }
      }
      /**
       * Print method. Deferred to content.
       */
      [Printing.symbol]() {
        if (!this._content) {
          return null;
        }
        return Printing.getPrintFunction(this._content);
      }
      /**
       * The content hosted by the widget.
       */
      get content() {
        return this._content;
      }
      /**
       * The toolbar hosted by the widget.
       */
      get toolbar() {
        return this._toolbar;
      }
      /**
       * A panel for widgets that sit between the toolbar and the content.
       * Imagine a formatting toolbar, notification headers, etc.
       */
      get contentHeader() {
        return this._contentHeader;
      }
      /**
       * Whether the content widget or an error is revealed.
       */
      get isRevealed() {
        return this._isRevealed;
      }
      /**
       * A promise that resolves when the widget is revealed.
       */
      get revealed() {
        return this._revealed;
      }
      /**
       * Handle `'activate-request'` messages.
       */
      onActivateRequest(msg) {
        if (this._isRevealed) {
          this._focusContent();
        } else {
          this._spinner.node.focus();
        }
      }
      /**
       * Handle `after-attach` messages for the widget.
       */
      onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this.node.addEventListener("mousedown", this._evtMouseDown, USE_CAPTURE);
      }
      /**
       * Handle `before-detach` messages for the widget.
       */
      onBeforeDetach(msg) {
        this.node.removeEventListener("mousedown", this._evtMouseDown, USE_CAPTURE);
        super.onBeforeDetach(msg);
      }
      /**
       * Handle `'close-request'` messages.
       */
      onCloseRequest(msg) {
        this.dispose();
      }
      /**
       * Handle `'update-request'` messages by forwarding them to the content.
       */
      onUpdateRequest(msg) {
        if (this._content) {
          MessageLoop3.sendMessage(this._content, msg);
        }
      }
      _disposeSpinner() {
        this.node.removeChild(this._spinner.node);
        this._spinner.dispose();
        this.removeClass("jp-MainAreaWidget-ContainStrict");
      }
      /**
       * Update the title based on the attributes of the child widget.
       */
      _updateTitle() {
        if (this._changeGuard || !this.content) {
          return;
        }
        this._changeGuard = true;
        const content = this.content;
        this.title.label = content.title.label;
        this.title.mnemonic = content.title.mnemonic;
        this.title.icon = content.title.icon;
        this.title.iconClass = content.title.iconClass;
        this.title.iconLabel = content.title.iconLabel;
        this.title.caption = content.title.caption;
        this.title.className = content.title.className;
        this.title.dataset = content.title.dataset;
        this._changeGuard = false;
      }
      /**
       * Update the content title based on attributes of the main widget.
       */
      _updateContentTitle() {
        if (this._changeGuard || !this.content) {
          return;
        }
        this._changeGuard = true;
        const content = this.content;
        content.title.label = this.title.label;
        content.title.mnemonic = this.title.mnemonic;
        content.title.icon = this.title.icon;
        content.title.iconClass = this.title.iconClass;
        content.title.iconLabel = this.title.iconLabel;
        content.title.caption = this.title.caption;
        content.title.className = this.title.className;
        content.title.dataset = this.title.dataset;
        this._changeGuard = false;
      }
      /**
       * Give focus to the content.
       */
      _focusContent() {
        if (!this.content) {
          return;
        }
        if (!this.content.node.contains(document.activeElement)) {
          this.content.node.focus();
        }
        this.content.activate();
      }
    };
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/menufactory.js
var import_coreutils20, import_coreutils21, MenuFactory;
var init_menufactory = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/menufactory.js"() {
    import_coreutils20 = __toESM(require_lib14());
    init_lib5();
    import_coreutils21 = __toESM(require_dist());
    (function(MenuFactory2) {
      function createMenus(data, menuFactory) {
        return data.filter((item) => !item.disabled).sort((a, b) => {
          var _a, _b;
          return ((_a = a.rank) !== null && _a !== void 0 ? _a : Infinity) - ((_b = b.rank) !== null && _b !== void 0 ? _b : Infinity);
        }).map((menuItem) => {
          return dataToMenu(menuItem, menuFactory);
        });
      }
      MenuFactory2.createMenus = createMenus;
      function dataToMenu(item, menuFactory) {
        var _a, _b;
        const menu = menuFactory(item);
        menu.id = item.id;
        if (!menu.title.label) {
          menu.title.label = (_a = item.label) !== null && _a !== void 0 ? _a : import_coreutils20.Text.titleCase(menu.id.trim());
        }
        if (item.icon) {
          menu.title.icon = LabIcon.resolve({ icon: item.icon });
        }
        if (item.mnemonic !== void 0) {
          menu.title.mnemonic = item.mnemonic;
        }
        (_b = item.items) === null || _b === void 0 ? void 0 : _b.filter((item2) => !item2.disabled).sort((a, b) => {
          var _a2, _b2;
          return ((_a2 = a.rank) !== null && _a2 !== void 0 ? _a2 : Infinity) - ((_b2 = b.rank) !== null && _b2 !== void 0 ? _b2 : Infinity);
        }).map((item2) => {
          addItem(item2, menu, menuFactory);
        });
        return menu;
      }
      function addContextItem(item, menu, menuFactory) {
        const { submenu, ...newItem } = item;
        menu.addItem({
          ...newItem,
          submenu: submenu ? dataToMenu(submenu, menuFactory) : null
        });
      }
      MenuFactory2.addContextItem = addContextItem;
      function addItem(item, menu, menuFactory) {
        const { submenu, ...newItem } = item;
        menu.addItem({
          ...newItem,
          submenu: submenu ? dataToMenu(submenu, menuFactory) : null
        });
      }
      function updateMenus(menus, data, menuFactory) {
        const newMenus = [];
        data.forEach((item) => {
          const menu = menus.find((menu2) => menu2.id === item.id);
          if (menu) {
            mergeMenus(item, menu, menuFactory);
          } else {
            if (!item.disabled) {
              newMenus.push(dataToMenu(item, menuFactory));
            }
          }
        });
        menus.push(...newMenus);
        return newMenus;
      }
      MenuFactory2.updateMenus = updateMenus;
      function mergeMenus(item, menu, menuFactory) {
        var _a;
        if (item.disabled) {
          menu.dispose();
        } else {
          (_a = item.items) === null || _a === void 0 ? void 0 : _a.forEach((entry) => {
            var _a2, _b;
            const existingItem = menu === null || menu === void 0 ? void 0 : menu.items.find((i, idx) => {
              var _a3, _b2, _c;
              return i.type === entry.type && i.command === ((_a3 = entry.command) !== null && _a3 !== void 0 ? _a3 : "") && ((_b2 = i.submenu) === null || _b2 === void 0 ? void 0 : _b2.id) === ((_c = entry.submenu) === null || _c === void 0 ? void 0 : _c.id);
            });
            if (existingItem && entry.type !== "separator") {
              if (entry.disabled) {
                menu.removeItem(existingItem);
              } else {
                switch ((_a2 = entry.type) !== null && _a2 !== void 0 ? _a2 : "command") {
                  case "command":
                    if (entry.command) {
                      if (!import_coreutils21.JSONExt.deepEqual(existingItem.args, (_b = entry.args) !== null && _b !== void 0 ? _b : {})) {
                        addItem(entry, menu, menuFactory);
                      }
                    }
                    break;
                  case "submenu":
                    if (entry.submenu) {
                      mergeMenus(entry.submenu, existingItem.submenu, menuFactory);
                    }
                }
              }
            } else {
              addItem(entry, menu, menuFactory);
            }
          });
        }
      }
    })(MenuFactory || (MenuFactory = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/notification.js
var import_coreutils22, NotificationManager, Notification;
var init_notification = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/notification.js"() {
    import_coreutils22 = __toESM(require_dist());
    init_index_es63();
    NotificationManager = class {
      constructor() {
        this._isDisposed = false;
        this._queue = [];
        this._changed = new Signal(this);
      }
      /**
       * Signal emitted whenever a notification changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Total number of notifications.
       */
      get count() {
        return this._queue.length;
      }
      /**
       * Whether the manager is disposed or not.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * The list of notifications.
       */
      get notifications() {
        return this._queue.slice();
      }
      /**
       * Dismiss one notification (specified by its id) or all if no id provided.
       *
       * @param id Notification id
       */
      dismiss(id) {
        if (typeof id === "undefined") {
          const q = this._queue.slice();
          this._queue.length = 0;
          for (const notification of q) {
            this._changed.emit({
              type: "removed",
              notification
            });
          }
        } else {
          const notificationIndex = this._queue.findIndex((n) => n.id === id);
          if (notificationIndex > -1) {
            const notification = this._queue.splice(notificationIndex, 1)[0];
            this._changed.emit({
              type: "removed",
              notification
            });
          }
        }
      }
      /**
       * Dispose the manager.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
      }
      /**
       * Test whether a notification exists or not.
       *
       * @param id Notification id
       * @returns Notification status
       */
      has(id) {
        return this._queue.findIndex((n) => n.id === id) > -1;
      }
      /**
       * Add a new notification.
       *
       * This will trigger the `changed` signal with an `added` event.
       *
       * @param message Notification message
       * @param type Notification type
       * @param options Notification option
       * @returns Notification unique id
       */
      notify(message, type, options) {
        const now = Date.now();
        const { progress, ...othersOptions } = options;
        const notification = Object.freeze({
          id: import_coreutils22.UUID.uuid4(),
          createdAt: now,
          modifiedAt: now,
          message,
          type,
          options: {
            // By default notification will be silent
            autoClose: 0,
            progress: typeof progress === "number" ? Math.min(Math.max(0, progress), 1) : progress,
            ...othersOptions
          }
        });
        this._queue.unshift(notification);
        this._changed.emit({
          type: "added",
          notification
        });
        return notification.id;
      }
      /**
       * Update an existing notification.
       *
       * If the notification does not exists this won't do anything.
       *
       * Once updated the notification will be moved at the begin
       * of the notification stack.
       *
       * @param args Update options
       * @returns Whether the update was successful or not.
       */
      update(args) {
        const { id, message, actions, autoClose, data, progress, type } = args;
        const newProgress = typeof progress === "number" ? Math.min(Math.max(0, progress), 1) : progress;
        const notificationIndex = this._queue.findIndex((n) => n.id === id);
        if (notificationIndex > -1) {
          const oldNotification = this._queue[notificationIndex];
          const notification = Object.freeze({
            ...oldNotification,
            message: message !== null && message !== void 0 ? message : oldNotification.message,
            type: type !== null && type !== void 0 ? type : oldNotification.type,
            options: {
              actions: actions !== null && actions !== void 0 ? actions : oldNotification.options.actions,
              autoClose: autoClose !== null && autoClose !== void 0 ? autoClose : oldNotification.options.autoClose,
              data: data !== null && data !== void 0 ? data : oldNotification.options.data,
              progress: newProgress !== null && newProgress !== void 0 ? newProgress : oldNotification.options.progress
            },
            modifiedAt: Date.now()
          });
          this._queue.splice(notificationIndex, 1);
          this._queue.unshift(notification);
          this._changed.emit({
            type: "updated",
            notification
          });
          return true;
        }
        return false;
      }
    };
    (function(Notification2) {
      Notification2.manager = new NotificationManager();
      function dismiss(id) {
        Notification2.manager.dismiss(id);
      }
      Notification2.dismiss = dismiss;
      function emit(message, type = "default", options = {}) {
        return Notification2.manager.notify(message, type, options);
      }
      Notification2.emit = emit;
      function error(message, options = {}) {
        return Notification2.manager.notify(message, "error", options);
      }
      Notification2.error = error;
      function info(message, options = {}) {
        return Notification2.manager.notify(message, "info", options);
      }
      Notification2.info = info;
      function promise(promise2, options) {
        var _a;
        const { pending, error: error2, success: success2 } = options;
        const id = Notification2.manager.notify(pending.message, "in-progress", (_a = pending.options) !== null && _a !== void 0 ? _a : {});
        promise2.then((result) => {
          var _a2, _b, _c;
          Notification2.manager.update({
            id,
            message: success2.message(result, (_a2 = success2.options) === null || _a2 === void 0 ? void 0 : _a2.data),
            type: "success",
            ...success2.options,
            data: (_c = (_b = success2.options) === null || _b === void 0 ? void 0 : _b.data) !== null && _c !== void 0 ? _c : result
          });
        }).catch((reason) => {
          var _a2, _b, _c;
          Notification2.manager.update({
            id,
            message: error2.message(reason, (_a2 = error2.options) === null || _a2 === void 0 ? void 0 : _a2.data),
            type: "error",
            ...error2.options,
            data: (_c = (_b = error2.options) === null || _b === void 0 ? void 0 : _b.data) !== null && _c !== void 0 ? _c : reason
          });
        });
        return id;
      }
      Notification2.promise = promise;
      function success(message, options = {}) {
        return Notification2.manager.notify(message, "success", options);
      }
      Notification2.success = success;
      function update(args) {
        return Notification2.manager.update(args);
      }
      Notification2.update = update;
      function warning(message, options = {}) {
        return Notification2.manager.notify(message, "warning", options);
      }
      Notification2.warning = warning;
    })(Notification || (Notification = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/runningSessions.js
function RunningSessionsComponent(props) {
  return import_react30.default.createElement(
    GroupItem,
    { tabIndex: 0, spacing: HALF_SPACING, onClick: props.handleClick, onKeyDown: props.handleKeyDown },
    import_react30.default.createElement(
      GroupItem,
      { spacing: HALF_SPACING },
      import_react30.default.createElement(TextItem, { source: props.terminals }),
      import_react30.default.createElement(terminalIcon.react, { left: "1px", top: "3px", stylesheet: "statusBar" })
    ),
    import_react30.default.createElement(
      GroupItem,
      { spacing: HALF_SPACING },
      import_react30.default.createElement(TextItem, { source: props.sessions }),
      import_react30.default.createElement(kernelIcon.react, { top: "2px", stylesheet: "statusBar" })
    )
  );
}
var import_react30, HALF_SPACING, RunningSessions;
var init_runningSessions = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/runningSessions.js"() {
    init_lib();
    init_lib5();
    import_react30 = __toESM(require_react());
    init_lib6();
    HALF_SPACING = 4;
    RunningSessions = class extends VDomRenderer {
      /**
       * Create a new RunningSessions widget.
       */
      constructor(opts) {
        super(new RunningSessions.Model());
        this._serviceManager = opts.serviceManager;
        this._handleClick = opts.onClick;
        this._handleKeyDown = opts.onKeyDown;
        this.translator = opts.translator || nullTranslator;
        this._trans = this.translator.load("jupyterlab");
        this._serviceManager.sessions.runningChanged.connect(this._onSessionsRunningChanged, this);
        this._serviceManager.terminals.runningChanged.connect(this._onTerminalsRunningChanged, this);
        this.addClass("jp-mod-highlighted");
      }
      /**
       * Render the running sessions widget.
       */
      render() {
        if (!this.model) {
          return null;
        }
        this.title.caption = this._trans.__("%1 Terminals, %2 Kernel sessions", this.model.terminals, this.model.sessions);
        return import_react30.default.createElement(RunningSessionsComponent, { sessions: this.model.sessions, terminals: this.model.terminals, handleClick: this._handleClick, handleKeyDown: this._handleKeyDown });
      }
      /**
       * Dispose of the status item.
       */
      dispose() {
        super.dispose();
        this._serviceManager.sessions.runningChanged.disconnect(this._onSessionsRunningChanged, this);
        this._serviceManager.terminals.runningChanged.disconnect(this._onTerminalsRunningChanged, this);
      }
      /**
       * Set the number of kernel sessions when the list changes.
       */
      _onSessionsRunningChanged(manager, sessions) {
        this.model.sessions = sessions.length;
      }
      /**
       * Set the number of terminal sessions when the list changes.
       */
      _onTerminalsRunningChanged(manager, terminals) {
        this.model.terminals = terminals.length;
      }
    };
    (function(RunningSessions2) {
      class Model extends VDomModel {
        constructor() {
          super(...arguments);
          this._terminals = 0;
          this._sessions = 0;
        }
        /**
         * The number of active kernel sessions.
         */
        get sessions() {
          return this._sessions;
        }
        set sessions(sessions) {
          const oldSessions = this._sessions;
          this._sessions = sessions;
          if (oldSessions !== this._sessions) {
            this.stateChanged.emit(void 0);
          }
        }
        /**
         * The number of active terminal sessions.
         */
        get terminals() {
          return this._terminals;
        }
        set terminals(terminals) {
          const oldTerminals = this._terminals;
          this._terminals = terminals;
          if (oldTerminals !== this._terminals) {
            this.stateChanged.emit(void 0);
          }
        }
      }
      RunningSessions2.Model = Model;
    })(RunningSessions || (RunningSessions = {}));
  }
});

// ../../node_modules/entities/lib/maps/decode.json
var require_decode = __commonJS({
  "../../node_modules/entities/lib/maps/decode.json"(exports2, module2) {
    module2.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
  }
});

// ../../node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "../../node_modules/entities/lib/decode_codepoint.js"(exports2) {
    "use strict";
    var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var decode_json_1 = __importDefault3(require_decode());
    function decodeCodePoint(codePoint) {
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return "\uFFFD";
      }
      if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
      }
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    }
    exports2.default = decodeCodePoint;
  }
});

// ../../node_modules/entities/lib/maps/legacy.json
var require_legacy = __commonJS({
  "../../node_modules/entities/lib/maps/legacy.json"(exports2, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", Agrave: "\xC0", agrave: "\xE0", amp: "&", AMP: "&", Aring: "\xC5", aring: "\xE5", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", brvbar: "\xA6", Ccedil: "\xC7", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", Eacute: "\xC9", eacute: "\xE9", Ecirc: "\xCA", ecirc: "\xEA", Egrave: "\xC8", egrave: "\xE8", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", Iacute: "\xCD", iacute: "\xED", Icirc: "\xCE", icirc: "\xEE", iexcl: "\xA1", Igrave: "\xCC", igrave: "\xEC", iquest: "\xBF", Iuml: "\xCF", iuml: "\xEF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", Ntilde: "\xD1", ntilde: "\xF1", Oacute: "\xD3", oacute: "\xF3", Ocirc: "\xD4", ocirc: "\xF4", Ograve: "\xD2", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", Ouml: "\xD6", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", THORN: "\xDE", thorn: "\xFE", times: "\xD7", Uacute: "\xDA", uacute: "\xFA", Ucirc: "\xDB", ucirc: "\xFB", Ugrave: "\xD9", ugrave: "\xF9", uml: "\xA8", Uuml: "\xDC", uuml: "\xFC", Yacute: "\xDD", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
  }
});

// ../../node_modules/entities/lib/maps/xml.json
var require_xml = __commonJS({
  "../../node_modules/entities/lib/maps/xml.json"(exports2, module2) {
    module2.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/Tokenizer.js"(exports2) {
    "use strict";
    var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var decode_codepoint_1 = __importDefault3(require_decode_codepoint());
    var entities_json_1 = __importDefault3(require_entities());
    var legacy_json_1 = __importDefault3(require_legacy());
    var xml_json_1 = __importDefault3(require_xml());
    function whitespace(c) {
      return c === " " || c === "\n" || c === "	" || c === "\f" || c === "\r";
    }
    function isASCIIAlpha(c) {
      return c >= "a" && c <= "z" || c >= "A" && c <= "Z";
    }
    function ifElseState(upper, SUCCESS, FAILURE) {
      var lower = upper.toLowerCase();
      if (upper === lower) {
        return function(t, c) {
          if (c === lower) {
            t._state = SUCCESS;
          } else {
            t._state = FAILURE;
            t._index--;
          }
        };
      }
      return function(t, c) {
        if (c === lower || c === upper) {
          t._state = SUCCESS;
        } else {
          t._state = FAILURE;
          t._index--;
        }
      };
    }
    function consumeSpecialNameChar(upper, NEXT_STATE) {
      var lower = upper.toLowerCase();
      return function(t, c) {
        if (c === lower || c === upper) {
          t._state = NEXT_STATE;
        } else {
          t._state = 3;
          t._index--;
        }
      };
    }
    var stateBeforeCdata1 = ifElseState(
      "C",
      24,
      16
      /* InDeclaration */
    );
    var stateBeforeCdata2 = ifElseState(
      "D",
      25,
      16
      /* InDeclaration */
    );
    var stateBeforeCdata3 = ifElseState(
      "A",
      26,
      16
      /* InDeclaration */
    );
    var stateBeforeCdata4 = ifElseState(
      "T",
      27,
      16
      /* InDeclaration */
    );
    var stateBeforeCdata5 = ifElseState(
      "A",
      28,
      16
      /* InDeclaration */
    );
    var stateBeforeScript1 = consumeSpecialNameChar(
      "R",
      35
      /* BeforeScript2 */
    );
    var stateBeforeScript2 = consumeSpecialNameChar(
      "I",
      36
      /* BeforeScript3 */
    );
    var stateBeforeScript3 = consumeSpecialNameChar(
      "P",
      37
      /* BeforeScript4 */
    );
    var stateBeforeScript4 = consumeSpecialNameChar(
      "T",
      38
      /* BeforeScript5 */
    );
    var stateAfterScript1 = ifElseState(
      "R",
      40,
      1
      /* Text */
    );
    var stateAfterScript2 = ifElseState(
      "I",
      41,
      1
      /* Text */
    );
    var stateAfterScript3 = ifElseState(
      "P",
      42,
      1
      /* Text */
    );
    var stateAfterScript4 = ifElseState(
      "T",
      43,
      1
      /* Text */
    );
    var stateBeforeStyle1 = consumeSpecialNameChar(
      "Y",
      45
      /* BeforeStyle2 */
    );
    var stateBeforeStyle2 = consumeSpecialNameChar(
      "L",
      46
      /* BeforeStyle3 */
    );
    var stateBeforeStyle3 = consumeSpecialNameChar(
      "E",
      47
      /* BeforeStyle4 */
    );
    var stateAfterStyle1 = ifElseState(
      "Y",
      49,
      1
      /* Text */
    );
    var stateAfterStyle2 = ifElseState(
      "L",
      50,
      1
      /* Text */
    );
    var stateAfterStyle3 = ifElseState(
      "E",
      51,
      1
      /* Text */
    );
    var stateBeforeSpecialT = consumeSpecialNameChar(
      "I",
      54
      /* BeforeTitle1 */
    );
    var stateBeforeTitle1 = consumeSpecialNameChar(
      "T",
      55
      /* BeforeTitle2 */
    );
    var stateBeforeTitle2 = consumeSpecialNameChar(
      "L",
      56
      /* BeforeTitle3 */
    );
    var stateBeforeTitle3 = consumeSpecialNameChar(
      "E",
      57
      /* BeforeTitle4 */
    );
    var stateAfterSpecialTEnd = ifElseState(
      "I",
      58,
      1
      /* Text */
    );
    var stateAfterTitle1 = ifElseState(
      "T",
      59,
      1
      /* Text */
    );
    var stateAfterTitle2 = ifElseState(
      "L",
      60,
      1
      /* Text */
    );
    var stateAfterTitle3 = ifElseState(
      "E",
      61,
      1
      /* Text */
    );
    var stateBeforeEntity = ifElseState(
      "#",
      63,
      64
      /* InNamedEntity */
    );
    var stateBeforeNumericEntity = ifElseState(
      "X",
      66,
      65
      /* InNumericEntity */
    );
    var Tokenizer = (
      /** @class */
      function() {
        function Tokenizer2(options, cbs) {
          var _a;
          this._state = 1;
          this.buffer = "";
          this.sectionStart = 0;
          this._index = 0;
          this.bufferOffset = 0;
          this.baseState = 1;
          this.special = 1;
          this.running = true;
          this.ended = false;
          this.cbs = cbs;
          this.xmlMode = !!(options === null || options === void 0 ? void 0 : options.xmlMode);
          this.decodeEntities = (_a = options === null || options === void 0 ? void 0 : options.decodeEntities) !== null && _a !== void 0 ? _a : true;
        }
        Tokenizer2.prototype.reset = function() {
          this._state = 1;
          this.buffer = "";
          this.sectionStart = 0;
          this._index = 0;
          this.bufferOffset = 0;
          this.baseState = 1;
          this.special = 1;
          this.running = true;
          this.ended = false;
        };
        Tokenizer2.prototype.write = function(chunk) {
          if (this.ended)
            this.cbs.onerror(Error(".write() after done!"));
          this.buffer += chunk;
          this.parse();
        };
        Tokenizer2.prototype.end = function(chunk) {
          if (this.ended)
            this.cbs.onerror(Error(".end() after done!"));
          if (chunk)
            this.write(chunk);
          this.ended = true;
          if (this.running)
            this.finish();
        };
        Tokenizer2.prototype.pause = function() {
          this.running = false;
        };
        Tokenizer2.prototype.resume = function() {
          this.running = true;
          if (this._index < this.buffer.length) {
            this.parse();
          }
          if (this.ended) {
            this.finish();
          }
        };
        Tokenizer2.prototype.getAbsoluteIndex = function() {
          return this.bufferOffset + this._index;
        };
        Tokenizer2.prototype.stateText = function(c) {
          if (c === "<") {
            if (this._index > this.sectionStart) {
              this.cbs.ontext(this.getSection());
            }
            this._state = 2;
            this.sectionStart = this._index;
          } else if (this.decodeEntities && c === "&" && (this.special === 1 || this.special === 4)) {
            if (this._index > this.sectionStart) {
              this.cbs.ontext(this.getSection());
            }
            this.baseState = 1;
            this._state = 62;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.isTagStartChar = function(c) {
          return isASCIIAlpha(c) || this.xmlMode && !whitespace(c) && c !== "/" && c !== ">";
        };
        Tokenizer2.prototype.stateBeforeTagName = function(c) {
          if (c === "/") {
            this._state = 5;
          } else if (c === "<") {
            this.cbs.ontext(this.getSection());
            this.sectionStart = this._index;
          } else if (c === ">" || this.special !== 1 || whitespace(c)) {
            this._state = 1;
          } else if (c === "!") {
            this._state = 15;
            this.sectionStart = this._index + 1;
          } else if (c === "?") {
            this._state = 17;
            this.sectionStart = this._index + 1;
          } else if (!this.isTagStartChar(c)) {
            this._state = 1;
          } else {
            this._state = !this.xmlMode && (c === "s" || c === "S") ? 32 : !this.xmlMode && (c === "t" || c === "T") ? 52 : 3;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateInTagName = function(c) {
          if (c === "/" || c === ">" || whitespace(c)) {
            this.emitToken("onopentagname");
            this._state = 8;
            this._index--;
          }
        };
        Tokenizer2.prototype.stateBeforeClosingTagName = function(c) {
          if (whitespace(c)) {
          } else if (c === ">") {
            this._state = 1;
          } else if (this.special !== 1) {
            if (this.special !== 4 && (c === "s" || c === "S")) {
              this._state = 33;
            } else if (this.special === 4 && (c === "t" || c === "T")) {
              this._state = 53;
            } else {
              this._state = 1;
              this._index--;
            }
          } else if (!this.isTagStartChar(c)) {
            this._state = 20;
            this.sectionStart = this._index;
          } else {
            this._state = 6;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateInClosingTagName = function(c) {
          if (c === ">" || whitespace(c)) {
            this.emitToken("onclosetag");
            this._state = 7;
            this._index--;
          }
        };
        Tokenizer2.prototype.stateAfterClosingTagName = function(c) {
          if (c === ">") {
            this._state = 1;
            this.sectionStart = this._index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeAttributeName = function(c) {
          if (c === ">") {
            this.cbs.onopentagend();
            this._state = 1;
            this.sectionStart = this._index + 1;
          } else if (c === "/") {
            this._state = 4;
          } else if (!whitespace(c)) {
            this._state = 9;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateInSelfClosingTag = function(c) {
          if (c === ">") {
            this.cbs.onselfclosingtag();
            this._state = 1;
            this.sectionStart = this._index + 1;
            this.special = 1;
          } else if (!whitespace(c)) {
            this._state = 8;
            this._index--;
          }
        };
        Tokenizer2.prototype.stateInAttributeName = function(c) {
          if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
            this.cbs.onattribname(this.getSection());
            this.sectionStart = -1;
            this._state = 10;
            this._index--;
          }
        };
        Tokenizer2.prototype.stateAfterAttributeName = function(c) {
          if (c === "=") {
            this._state = 11;
          } else if (c === "/" || c === ">") {
            this.cbs.onattribend(void 0);
            this._state = 8;
            this._index--;
          } else if (!whitespace(c)) {
            this.cbs.onattribend(void 0);
            this._state = 9;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateBeforeAttributeValue = function(c) {
          if (c === '"') {
            this._state = 12;
            this.sectionStart = this._index + 1;
          } else if (c === "'") {
            this._state = 13;
            this.sectionStart = this._index + 1;
          } else if (!whitespace(c)) {
            this._state = 14;
            this.sectionStart = this._index;
            this._index--;
          }
        };
        Tokenizer2.prototype.handleInAttributeValue = function(c, quote) {
          if (c === quote) {
            this.emitToken("onattribdata");
            this.cbs.onattribend(quote);
            this._state = 8;
          } else if (this.decodeEntities && c === "&") {
            this.emitToken("onattribdata");
            this.baseState = this._state;
            this._state = 62;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function(c) {
          this.handleInAttributeValue(c, '"');
        };
        Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function(c) {
          this.handleInAttributeValue(c, "'");
        };
        Tokenizer2.prototype.stateInAttributeValueNoQuotes = function(c) {
          if (whitespace(c) || c === ">") {
            this.emitToken("onattribdata");
            this.cbs.onattribend(null);
            this._state = 8;
            this._index--;
          } else if (this.decodeEntities && c === "&") {
            this.emitToken("onattribdata");
            this.baseState = this._state;
            this._state = 62;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateBeforeDeclaration = function(c) {
          this._state = c === "[" ? 23 : c === "-" ? 18 : 16;
        };
        Tokenizer2.prototype.stateInDeclaration = function(c) {
          if (c === ">") {
            this.cbs.ondeclaration(this.getSection());
            this._state = 1;
            this.sectionStart = this._index + 1;
          }
        };
        Tokenizer2.prototype.stateInProcessingInstruction = function(c) {
          if (c === ">") {
            this.cbs.onprocessinginstruction(this.getSection());
            this._state = 1;
            this.sectionStart = this._index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeComment = function(c) {
          if (c === "-") {
            this._state = 19;
            this.sectionStart = this._index + 1;
          } else {
            this._state = 16;
          }
        };
        Tokenizer2.prototype.stateInComment = function(c) {
          if (c === "-")
            this._state = 21;
        };
        Tokenizer2.prototype.stateInSpecialComment = function(c) {
          if (c === ">") {
            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index));
            this._state = 1;
            this.sectionStart = this._index + 1;
          }
        };
        Tokenizer2.prototype.stateAfterComment1 = function(c) {
          if (c === "-") {
            this._state = 22;
          } else {
            this._state = 19;
          }
        };
        Tokenizer2.prototype.stateAfterComment2 = function(c) {
          if (c === ">") {
            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2));
            this._state = 1;
            this.sectionStart = this._index + 1;
          } else if (c !== "-") {
            this._state = 19;
          }
        };
        Tokenizer2.prototype.stateBeforeCdata6 = function(c) {
          if (c === "[") {
            this._state = 29;
            this.sectionStart = this._index + 1;
          } else {
            this._state = 16;
            this._index--;
          }
        };
        Tokenizer2.prototype.stateInCdata = function(c) {
          if (c === "]")
            this._state = 30;
        };
        Tokenizer2.prototype.stateAfterCdata1 = function(c) {
          if (c === "]")
            this._state = 31;
          else
            this._state = 29;
        };
        Tokenizer2.prototype.stateAfterCdata2 = function(c) {
          if (c === ">") {
            this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2));
            this._state = 1;
            this.sectionStart = this._index + 1;
          } else if (c !== "]") {
            this._state = 29;
          }
        };
        Tokenizer2.prototype.stateBeforeSpecialS = function(c) {
          if (c === "c" || c === "C") {
            this._state = 34;
          } else if (c === "t" || c === "T") {
            this._state = 44;
          } else {
            this._state = 3;
            this._index--;
          }
        };
        Tokenizer2.prototype.stateBeforeSpecialSEnd = function(c) {
          if (this.special === 2 && (c === "c" || c === "C")) {
            this._state = 39;
          } else if (this.special === 3 && (c === "t" || c === "T")) {
            this._state = 48;
          } else
            this._state = 1;
        };
        Tokenizer2.prototype.stateBeforeSpecialLast = function(c, special) {
          if (c === "/" || c === ">" || whitespace(c)) {
            this.special = special;
          }
          this._state = 3;
          this._index--;
        };
        Tokenizer2.prototype.stateAfterSpecialLast = function(c, sectionStartOffset) {
          if (c === ">" || whitespace(c)) {
            this.special = 1;
            this._state = 6;
            this.sectionStart = this._index - sectionStartOffset;
            this._index--;
          } else
            this._state = 1;
        };
        Tokenizer2.prototype.parseFixedEntity = function(map2) {
          if (map2 === void 0) {
            map2 = this.xmlMode ? xml_json_1.default : entities_json_1.default;
          }
          if (this.sectionStart + 1 < this._index) {
            var entity = this.buffer.substring(this.sectionStart + 1, this._index);
            if (Object.prototype.hasOwnProperty.call(map2, entity)) {
              this.emitPartial(map2[entity]);
              this.sectionStart = this._index + 1;
            }
          }
        };
        Tokenizer2.prototype.parseLegacyEntity = function() {
          var start = this.sectionStart + 1;
          var limit2 = Math.min(this._index - start, 6);
          while (limit2 >= 2) {
            var entity = this.buffer.substr(start, limit2);
            if (Object.prototype.hasOwnProperty.call(legacy_json_1.default, entity)) {
              this.emitPartial(legacy_json_1.default[entity]);
              this.sectionStart += limit2 + 1;
              return;
            }
            limit2--;
          }
        };
        Tokenizer2.prototype.stateInNamedEntity = function(c) {
          if (c === ";") {
            this.parseFixedEntity();
            if (this.baseState === 1 && this.sectionStart + 1 < this._index && !this.xmlMode) {
              this.parseLegacyEntity();
            }
            this._state = this.baseState;
          } else if ((c < "0" || c > "9") && !isASCIIAlpha(c)) {
            if (this.xmlMode || this.sectionStart + 1 === this._index) {
            } else if (this.baseState !== 1) {
              if (c !== "=") {
                this.parseFixedEntity(legacy_json_1.default);
              }
            } else {
              this.parseLegacyEntity();
            }
            this._state = this.baseState;
            this._index--;
          }
        };
        Tokenizer2.prototype.decodeNumericEntity = function(offset, base, strict) {
          var sectionStart = this.sectionStart + offset;
          if (sectionStart !== this._index) {
            var entity = this.buffer.substring(sectionStart, this._index);
            var parsed = parseInt(entity, base);
            this.emitPartial(decode_codepoint_1.default(parsed));
            this.sectionStart = strict ? this._index + 1 : this._index;
          }
          this._state = this.baseState;
        };
        Tokenizer2.prototype.stateInNumericEntity = function(c) {
          if (c === ";") {
            this.decodeNumericEntity(2, 10, true);
          } else if (c < "0" || c > "9") {
            if (!this.xmlMode) {
              this.decodeNumericEntity(2, 10, false);
            } else {
              this._state = this.baseState;
            }
            this._index--;
          }
        };
        Tokenizer2.prototype.stateInHexEntity = function(c) {
          if (c === ";") {
            this.decodeNumericEntity(3, 16, true);
          } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
            if (!this.xmlMode) {
              this.decodeNumericEntity(3, 16, false);
            } else {
              this._state = this.baseState;
            }
            this._index--;
          }
        };
        Tokenizer2.prototype.cleanup = function() {
          if (this.sectionStart < 0) {
            this.buffer = "";
            this.bufferOffset += this._index;
            this._index = 0;
          } else if (this.running) {
            if (this._state === 1) {
              if (this.sectionStart !== this._index) {
                this.cbs.ontext(this.buffer.substr(this.sectionStart));
              }
              this.buffer = "";
              this.bufferOffset += this._index;
              this._index = 0;
            } else if (this.sectionStart === this._index) {
              this.buffer = "";
              this.bufferOffset += this._index;
              this._index = 0;
            } else {
              this.buffer = this.buffer.substr(this.sectionStart);
              this._index -= this.sectionStart;
              this.bufferOffset += this.sectionStart;
            }
            this.sectionStart = 0;
          }
        };
        Tokenizer2.prototype.parse = function() {
          while (this._index < this.buffer.length && this.running) {
            var c = this.buffer.charAt(this._index);
            if (this._state === 1) {
              this.stateText(c);
            } else if (this._state === 12) {
              this.stateInAttributeValueDoubleQuotes(c);
            } else if (this._state === 9) {
              this.stateInAttributeName(c);
            } else if (this._state === 19) {
              this.stateInComment(c);
            } else if (this._state === 20) {
              this.stateInSpecialComment(c);
            } else if (this._state === 8) {
              this.stateBeforeAttributeName(c);
            } else if (this._state === 3) {
              this.stateInTagName(c);
            } else if (this._state === 6) {
              this.stateInClosingTagName(c);
            } else if (this._state === 2) {
              this.stateBeforeTagName(c);
            } else if (this._state === 10) {
              this.stateAfterAttributeName(c);
            } else if (this._state === 13) {
              this.stateInAttributeValueSingleQuotes(c);
            } else if (this._state === 11) {
              this.stateBeforeAttributeValue(c);
            } else if (this._state === 5) {
              this.stateBeforeClosingTagName(c);
            } else if (this._state === 7) {
              this.stateAfterClosingTagName(c);
            } else if (this._state === 32) {
              this.stateBeforeSpecialS(c);
            } else if (this._state === 21) {
              this.stateAfterComment1(c);
            } else if (this._state === 14) {
              this.stateInAttributeValueNoQuotes(c);
            } else if (this._state === 4) {
              this.stateInSelfClosingTag(c);
            } else if (this._state === 16) {
              this.stateInDeclaration(c);
            } else if (this._state === 15) {
              this.stateBeforeDeclaration(c);
            } else if (this._state === 22) {
              this.stateAfterComment2(c);
            } else if (this._state === 18) {
              this.stateBeforeComment(c);
            } else if (this._state === 33) {
              this.stateBeforeSpecialSEnd(c);
            } else if (this._state === 53) {
              stateAfterSpecialTEnd(this, c);
            } else if (this._state === 39) {
              stateAfterScript1(this, c);
            } else if (this._state === 40) {
              stateAfterScript2(this, c);
            } else if (this._state === 41) {
              stateAfterScript3(this, c);
            } else if (this._state === 34) {
              stateBeforeScript1(this, c);
            } else if (this._state === 35) {
              stateBeforeScript2(this, c);
            } else if (this._state === 36) {
              stateBeforeScript3(this, c);
            } else if (this._state === 37) {
              stateBeforeScript4(this, c);
            } else if (this._state === 38) {
              this.stateBeforeSpecialLast(
                c,
                2
                /* Script */
              );
            } else if (this._state === 42) {
              stateAfterScript4(this, c);
            } else if (this._state === 43) {
              this.stateAfterSpecialLast(c, 6);
            } else if (this._state === 44) {
              stateBeforeStyle1(this, c);
            } else if (this._state === 29) {
              this.stateInCdata(c);
            } else if (this._state === 45) {
              stateBeforeStyle2(this, c);
            } else if (this._state === 46) {
              stateBeforeStyle3(this, c);
            } else if (this._state === 47) {
              this.stateBeforeSpecialLast(
                c,
                3
                /* Style */
              );
            } else if (this._state === 48) {
              stateAfterStyle1(this, c);
            } else if (this._state === 49) {
              stateAfterStyle2(this, c);
            } else if (this._state === 50) {
              stateAfterStyle3(this, c);
            } else if (this._state === 51) {
              this.stateAfterSpecialLast(c, 5);
            } else if (this._state === 52) {
              stateBeforeSpecialT(this, c);
            } else if (this._state === 54) {
              stateBeforeTitle1(this, c);
            } else if (this._state === 55) {
              stateBeforeTitle2(this, c);
            } else if (this._state === 56) {
              stateBeforeTitle3(this, c);
            } else if (this._state === 57) {
              this.stateBeforeSpecialLast(
                c,
                4
                /* Title */
              );
            } else if (this._state === 58) {
              stateAfterTitle1(this, c);
            } else if (this._state === 59) {
              stateAfterTitle2(this, c);
            } else if (this._state === 60) {
              stateAfterTitle3(this, c);
            } else if (this._state === 61) {
              this.stateAfterSpecialLast(c, 5);
            } else if (this._state === 17) {
              this.stateInProcessingInstruction(c);
            } else if (this._state === 64) {
              this.stateInNamedEntity(c);
            } else if (this._state === 23) {
              stateBeforeCdata1(this, c);
            } else if (this._state === 62) {
              stateBeforeEntity(this, c);
            } else if (this._state === 24) {
              stateBeforeCdata2(this, c);
            } else if (this._state === 25) {
              stateBeforeCdata3(this, c);
            } else if (this._state === 30) {
              this.stateAfterCdata1(c);
            } else if (this._state === 31) {
              this.stateAfterCdata2(c);
            } else if (this._state === 26) {
              stateBeforeCdata4(this, c);
            } else if (this._state === 27) {
              stateBeforeCdata5(this, c);
            } else if (this._state === 28) {
              this.stateBeforeCdata6(c);
            } else if (this._state === 66) {
              this.stateInHexEntity(c);
            } else if (this._state === 65) {
              this.stateInNumericEntity(c);
            } else if (this._state === 63) {
              stateBeforeNumericEntity(this, c);
            } else {
              this.cbs.onerror(Error("unknown _state"), this._state);
            }
            this._index++;
          }
          this.cleanup();
        };
        Tokenizer2.prototype.finish = function() {
          if (this.sectionStart < this._index) {
            this.handleTrailingData();
          }
          this.cbs.onend();
        };
        Tokenizer2.prototype.handleTrailingData = function() {
          var data = this.buffer.substr(this.sectionStart);
          if (this._state === 29 || this._state === 30 || this._state === 31) {
            this.cbs.oncdata(data);
          } else if (this._state === 19 || this._state === 21 || this._state === 22) {
            this.cbs.oncomment(data);
          } else if (this._state === 64 && !this.xmlMode) {
            this.parseLegacyEntity();
            if (this.sectionStart < this._index) {
              this._state = this.baseState;
              this.handleTrailingData();
            }
          } else if (this._state === 65 && !this.xmlMode) {
            this.decodeNumericEntity(2, 10, false);
            if (this.sectionStart < this._index) {
              this._state = this.baseState;
              this.handleTrailingData();
            }
          } else if (this._state === 66 && !this.xmlMode) {
            this.decodeNumericEntity(3, 16, false);
            if (this.sectionStart < this._index) {
              this._state = this.baseState;
              this.handleTrailingData();
            }
          } else if (this._state !== 3 && this._state !== 8 && this._state !== 11 && this._state !== 10 && this._state !== 9 && this._state !== 13 && this._state !== 12 && this._state !== 14 && this._state !== 6) {
            this.cbs.ontext(data);
          }
        };
        Tokenizer2.prototype.getSection = function() {
          return this.buffer.substring(this.sectionStart, this._index);
        };
        Tokenizer2.prototype.emitToken = function(name2) {
          this.cbs[name2](this.getSection());
          this.sectionStart = -1;
        };
        Tokenizer2.prototype.emitPartial = function(value) {
          if (this.baseState !== 1) {
            this.cbs.onattribdata(value);
          } else {
            this.cbs.ontext(value);
          }
        };
        return Tokenizer2;
      }()
    );
    exports2.default = Tokenizer;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/Parser.js
var require_Parser = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/Parser.js"(exports2) {
    "use strict";
    var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Parser = void 0;
    var Tokenizer_1 = __importDefault3(require_Tokenizer());
    var formTags = /* @__PURE__ */ new Set([
      "input",
      "option",
      "optgroup",
      "select",
      "button",
      "datalist",
      "textarea"
    ]);
    var pTag = /* @__PURE__ */ new Set(["p"]);
    var openImpliesClose = {
      tr: /* @__PURE__ */ new Set(["tr", "th", "td"]),
      th: /* @__PURE__ */ new Set(["th"]),
      td: /* @__PURE__ */ new Set(["thead", "th", "td"]),
      body: /* @__PURE__ */ new Set(["head", "link", "script"]),
      li: /* @__PURE__ */ new Set(["li"]),
      p: pTag,
      h1: pTag,
      h2: pTag,
      h3: pTag,
      h4: pTag,
      h5: pTag,
      h6: pTag,
      select: formTags,
      input: formTags,
      output: formTags,
      button: formTags,
      datalist: formTags,
      textarea: formTags,
      option: /* @__PURE__ */ new Set(["option"]),
      optgroup: /* @__PURE__ */ new Set(["optgroup", "option"]),
      dd: /* @__PURE__ */ new Set(["dt", "dd"]),
      dt: /* @__PURE__ */ new Set(["dt", "dd"]),
      address: pTag,
      article: pTag,
      aside: pTag,
      blockquote: pTag,
      details: pTag,
      div: pTag,
      dl: pTag,
      fieldset: pTag,
      figcaption: pTag,
      figure: pTag,
      footer: pTag,
      form: pTag,
      header: pTag,
      hr: pTag,
      main: pTag,
      nav: pTag,
      ol: pTag,
      pre: pTag,
      section: pTag,
      table: pTag,
      ul: pTag,
      rt: /* @__PURE__ */ new Set(["rt", "rp"]),
      rp: /* @__PURE__ */ new Set(["rt", "rp"]),
      tbody: /* @__PURE__ */ new Set(["thead", "tbody"]),
      tfoot: /* @__PURE__ */ new Set(["thead", "tbody"])
    };
    var voidElements = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
    var htmlIntegrationElements = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var reNameEnd = /\s|\//;
    var Parser = (
      /** @class */
      function() {
        function Parser2(cbs, options) {
          if (options === void 0) {
            options = {};
          }
          var _a, _b, _c, _d, _e;
          this.startIndex = 0;
          this.endIndex = null;
          this.tagname = "";
          this.attribname = "";
          this.attribvalue = "";
          this.attribs = null;
          this.stack = [];
          this.foreignContext = [];
          this.options = options;
          this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
          this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
          this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
          this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1.default)(this.options, this);
          (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
        }
        Parser2.prototype.updatePosition = function(initialOffset) {
          if (this.endIndex === null) {
            if (this.tokenizer.sectionStart <= initialOffset) {
              this.startIndex = 0;
            } else {
              this.startIndex = this.tokenizer.sectionStart - initialOffset;
            }
          } else {
            this.startIndex = this.endIndex + 1;
          }
          this.endIndex = this.tokenizer.getAbsoluteIndex();
        };
        Parser2.prototype.ontext = function(data) {
          var _a, _b;
          this.updatePosition(1);
          this.endIndex--;
          (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
        };
        Parser2.prototype.onopentagname = function(name2) {
          var _a, _b;
          if (this.lowerCaseTagNames) {
            name2 = name2.toLowerCase();
          }
          this.tagname = name2;
          if (!this.options.xmlMode && Object.prototype.hasOwnProperty.call(openImpliesClose, name2)) {
            var el = void 0;
            while (this.stack.length > 0 && openImpliesClose[name2].has(el = this.stack[this.stack.length - 1])) {
              this.onclosetag(el);
            }
          }
          if (this.options.xmlMode || !voidElements.has(name2)) {
            this.stack.push(name2);
            if (foreignContextElements.has(name2)) {
              this.foreignContext.push(true);
            } else if (htmlIntegrationElements.has(name2)) {
              this.foreignContext.push(false);
            }
          }
          (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, name2);
          if (this.cbs.onopentag)
            this.attribs = {};
        };
        Parser2.prototype.onopentagend = function() {
          var _a, _b;
          this.updatePosition(1);
          if (this.attribs) {
            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs);
            this.attribs = null;
          }
          if (!this.options.xmlMode && this.cbs.onclosetag && voidElements.has(this.tagname)) {
            this.cbs.onclosetag(this.tagname);
          }
          this.tagname = "";
        };
        Parser2.prototype.onclosetag = function(name2) {
          this.updatePosition(1);
          if (this.lowerCaseTagNames) {
            name2 = name2.toLowerCase();
          }
          if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
            this.foreignContext.pop();
          }
          if (this.stack.length && (this.options.xmlMode || !voidElements.has(name2))) {
            var pos = this.stack.lastIndexOf(name2);
            if (pos !== -1) {
              if (this.cbs.onclosetag) {
                pos = this.stack.length - pos;
                while (pos--) {
                  this.cbs.onclosetag(this.stack.pop());
                }
              } else
                this.stack.length = pos;
            } else if (name2 === "p" && !this.options.xmlMode) {
              this.onopentagname(name2);
              this.closeCurrentTag();
            }
          } else if (!this.options.xmlMode && (name2 === "br" || name2 === "p")) {
            this.onopentagname(name2);
            this.closeCurrentTag();
          }
        };
        Parser2.prototype.onselfclosingtag = function() {
          if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag();
          } else {
            this.onopentagend();
          }
        };
        Parser2.prototype.closeCurrentTag = function() {
          var _a, _b;
          var name2 = this.tagname;
          this.onopentagend();
          if (this.stack[this.stack.length - 1] === name2) {
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name2);
            this.stack.pop();
          }
        };
        Parser2.prototype.onattribname = function(name2) {
          if (this.lowerCaseAttributeNames) {
            name2 = name2.toLowerCase();
          }
          this.attribname = name2;
        };
        Parser2.prototype.onattribdata = function(value) {
          this.attribvalue += value;
        };
        Parser2.prototype.onattribend = function(quote) {
          var _a, _b;
          (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote);
          if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
          }
          this.attribname = "";
          this.attribvalue = "";
        };
        Parser2.prototype.getInstructionName = function(value) {
          var idx = value.search(reNameEnd);
          var name2 = idx < 0 ? value : value.substr(0, idx);
          if (this.lowerCaseTagNames) {
            name2 = name2.toLowerCase();
          }
          return name2;
        };
        Parser2.prototype.ondeclaration = function(value) {
          if (this.cbs.onprocessinginstruction) {
            var name_1 = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("!" + name_1, "!" + value);
          }
        };
        Parser2.prototype.onprocessinginstruction = function(value) {
          if (this.cbs.onprocessinginstruction) {
            var name_2 = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("?" + name_2, "?" + value);
          }
        };
        Parser2.prototype.oncomment = function(value) {
          var _a, _b, _c, _d;
          this.updatePosition(4);
          (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, value);
          (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
        };
        Parser2.prototype.oncdata = function(value) {
          var _a, _b, _c, _d, _e, _f;
          this.updatePosition(1);
          if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
          } else {
            this.oncomment("[CDATA[" + value + "]]");
          }
        };
        Parser2.prototype.onerror = function(err) {
          var _a, _b;
          (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, err);
        };
        Parser2.prototype.onend = function() {
          var _a, _b;
          if (this.cbs.onclosetag) {
            for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i]))
              ;
          }
          (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        Parser2.prototype.reset = function() {
          var _a, _b, _c, _d;
          (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
          this.tokenizer.reset();
          this.tagname = "";
          this.attribname = "";
          this.attribs = null;
          this.stack = [];
          (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        };
        Parser2.prototype.parseComplete = function(data) {
          this.reset();
          this.end(data);
        };
        Parser2.prototype.write = function(chunk) {
          this.tokenizer.write(chunk);
        };
        Parser2.prototype.end = function(chunk) {
          this.tokenizer.end(chunk);
        };
        Parser2.prototype.pause = function() {
          this.tokenizer.pause();
        };
        Parser2.prototype.resume = function() {
          this.tokenizer.resume();
        };
        Parser2.prototype.parseChunk = function(chunk) {
          this.write(chunk);
        };
        Parser2.prototype.done = function(chunk) {
          this.end(chunk);
        };
        return Parser2;
      }()
    );
    exports2.Parser = Parser;
  }
});

// ../../node_modules/domelementtype/lib/index.js
var require_lib16 = __commonJS({
  "../../node_modules/domelementtype/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Doctype = exports2.CDATA = exports2.Tag = exports2.Style = exports2.Script = exports2.Comment = exports2.Directive = exports2.Text = exports2.Root = exports2.isTag = exports2.ElementType = void 0;
    var ElementType;
    (function(ElementType2) {
      ElementType2["Root"] = "root";
      ElementType2["Text"] = "text";
      ElementType2["Directive"] = "directive";
      ElementType2["Comment"] = "comment";
      ElementType2["Script"] = "script";
      ElementType2["Style"] = "style";
      ElementType2["Tag"] = "tag";
      ElementType2["CDATA"] = "cdata";
      ElementType2["Doctype"] = "doctype";
    })(ElementType = exports2.ElementType || (exports2.ElementType = {}));
    function isTag(elem) {
      return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
    }
    exports2.isTag = isTag;
    exports2.Root = ElementType.Root;
    exports2.Text = ElementType.Text;
    exports2.Directive = ElementType.Directive;
    exports2.Comment = ElementType.Comment;
    exports2.Script = ElementType.Script;
    exports2.Style = ElementType.Style;
    exports2.Tag = ElementType.Tag;
    exports2.CDATA = ElementType.CDATA;
    exports2.Doctype = ElementType.Doctype;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domhandler/lib/node.js
var require_node = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domhandler/lib/node.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloneNode = exports2.hasChildren = exports2.isDocument = exports2.isDirective = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = exports2.Element = exports2.Document = exports2.NodeWithChildren = exports2.ProcessingInstruction = exports2.Comment = exports2.Text = exports2.DataNode = exports2.Node = void 0;
    var domelementtype_1 = require_lib16();
    var nodeTypes = /* @__PURE__ */ new Map([
      [domelementtype_1.ElementType.Tag, 1],
      [domelementtype_1.ElementType.Script, 1],
      [domelementtype_1.ElementType.Style, 1],
      [domelementtype_1.ElementType.Directive, 1],
      [domelementtype_1.ElementType.Text, 3],
      [domelementtype_1.ElementType.CDATA, 4],
      [domelementtype_1.ElementType.Comment, 8],
      [domelementtype_1.ElementType.Root, 9]
    ]);
    var Node2 = (
      /** @class */
      function() {
        function Node3(type) {
          this.type = type;
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node3.prototype, "nodeType", {
          // Read-only aliases
          /**
           * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
           * node {@link type}.
           */
          get: function() {
            var _a;
            return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true
        });
        Node3.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node3;
      }()
    );
    exports2.Node = Node2;
    var DataNode = (
      /** @class */
      function(_super) {
        __extends2(DataNode2, _super);
        function DataNode2(type, data) {
          var _this = _super.call(this, type) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode2.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode2;
      }(Node2)
    );
    exports2.DataNode = DataNode;
    var Text3 = (
      /** @class */
      function(_super) {
        __extends2(Text4, _super);
        function Text4(data) {
          return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
        }
        return Text4;
      }(DataNode)
    );
    exports2.Text = Text3;
    var Comment = (
      /** @class */
      function(_super) {
        __extends2(Comment2, _super);
        function Comment2(data) {
          return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
        }
        return Comment2;
      }(DataNode)
    );
    exports2.Comment = Comment;
    var ProcessingInstruction = (
      /** @class */
      function(_super) {
        __extends2(ProcessingInstruction2, _super);
        function ProcessingInstruction2(name2, data) {
          var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
          _this.name = name2;
          return _this;
        }
        return ProcessingInstruction2;
      }(DataNode)
    );
    exports2.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren = (
      /** @class */
      function(_super) {
        __extends2(NodeWithChildren2, _super);
        function NodeWithChildren2(type, children2) {
          var _this = _super.call(this, type) || this;
          _this.children = children2;
          return _this;
        }
        Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(children2) {
            this.children = children2;
          },
          enumerable: false,
          configurable: true
        });
        return NodeWithChildren2;
      }(Node2)
    );
    exports2.NodeWithChildren = NodeWithChildren;
    var Document2 = (
      /** @class */
      function(_super) {
        __extends2(Document3, _super);
        function Document3(children2) {
          return _super.call(this, domelementtype_1.ElementType.Root, children2) || this;
        }
        return Document3;
      }(NodeWithChildren)
    );
    exports2.Document = Document2;
    var Element2 = (
      /** @class */
      function(_super) {
        __extends2(Element3, _super);
        function Element3(name2, attribs, children2, type) {
          if (children2 === void 0) {
            children2 = [];
          }
          if (type === void 0) {
            type = name2 === "script" ? domelementtype_1.ElementType.Script : name2 === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, type, children2) || this;
          _this.name = name2;
          _this.attribs = attribs;
          return _this;
        }
        Object.defineProperty(Element3.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.name;
          },
          set: function(name2) {
            this.name = name2;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element3.prototype, "attributes", {
          get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name2) {
              var _a, _b;
              return {
                name: name2,
                value: _this.attribs[name2],
                namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name2],
                prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
              };
            });
          },
          enumerable: false,
          configurable: true
        });
        return Element3;
      }(NodeWithChildren)
    );
    exports2.Element = Element2;
    function isTag(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports2.isTag = isTag;
    function isCDATA(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports2.isCDATA = isCDATA;
    function isText(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports2.isText = isText;
    function isComment(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports2.isComment = isComment;
    function isDirective(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports2.isDirective = isDirective;
    function isDocument(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports2.isDocument = isDocument;
    function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports2.hasChildren = hasChildren;
    function cloneNode(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result;
      if (isText(node)) {
        result = new Text3(node.data);
      } else if (isComment(node)) {
        result = new Comment(node.data);
      } else if (isTag(node)) {
        var children2 = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element2(node.name, __assign2({}, node.attribs), children2);
        children2.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign2({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign2({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
      } else if (isCDATA(node)) {
        var children2 = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children2);
        children2.forEach(function(child) {
          return child.parent = clone_2;
        });
        result = clone_2;
      } else if (isDocument(node)) {
        var children2 = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document2(children2);
        children2.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
      } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
    }
    exports2.cloneNode = cloneNode;
    function cloneChildren(childs) {
      var children2 = childs.map(function(child) {
        return cloneNode(child, true);
      });
      for (var i = 1; i < children2.length; i++) {
        children2[i].prev = children2[i - 1];
        children2[i - 1].next = children2[i];
      }
      return children2;
    }
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domhandler/lib/index.js
var require_lib17 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domhandler/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomHandler = void 0;
    var domelementtype_1 = require_lib16();
    var node_1 = require_node();
    __exportStar2(require_node(), exports2);
    var reWhitespace = /\s+/g;
    var defaultOpts = {
      normalizeWhitespace: false,
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = (
      /** @class */
      function() {
        function DomHandler2(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler2.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler2.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler2.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler2.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler2.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler2.prototype.onopentag = function(name2, attribs) {
          var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element = new node_1.Element(name2, attribs, void 0, type);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler2.prototype.ontext = function(data) {
          var normalizeWhitespace = this.options.normalizeWhitespace;
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            if (normalizeWhitespace) {
              lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
            } else {
              lastNode.data += data;
            }
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            if (normalizeWhitespace) {
              data = data.replace(reWhitespace, " ");
            }
            var node = new node_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler2.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler2.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.oncdatastart = function() {
          var text = new node_1.Text("");
          var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler2.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.onprocessinginstruction = function(name2, data) {
          var node = new node_1.ProcessingInstruction(name2, data);
          this.addNode(node);
        };
        DomHandler2.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler2.prototype.addNode = function(node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler2;
      }()
    );
    exports2.DomHandler = DomHandler;
    exports2.default = DomHandler;
  }
});

// ../../node_modules/entities/lib/decode.js
var require_decode2 = __commonJS({
  "../../node_modules/entities/lib/decode.js"(exports2) {
    "use strict";
    var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeHTML = exports2.decodeHTMLStrict = exports2.decodeXML = void 0;
    var entities_json_1 = __importDefault3(require_entities());
    var legacy_json_1 = __importDefault3(require_legacy());
    var xml_json_1 = __importDefault3(require_xml());
    var decode_codepoint_1 = __importDefault3(require_decode_codepoint());
    exports2.decodeXML = getStrictDecoder(xml_json_1.default);
    exports2.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
    function getStrictDecoder(map2) {
      var keys = Object.keys(map2).join("|");
      var replace = getReplacer(map2);
      keys += "|#[xX][\\da-fA-F]+|#\\d+";
      var re = new RegExp("&(?:" + keys + ");", "g");
      return function(str) {
        return String(str).replace(re, replace);
      };
    }
    var sorter = function(a, b) {
      return a < b ? 1 : -1;
    };
    exports2.decodeHTML = function() {
      var legacy = Object.keys(legacy_json_1.default).sort(sorter);
      var keys = Object.keys(entities_json_1.default).sort(sorter);
      for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
          keys[i] += ";?";
          j++;
        } else {
          keys[i] += ";";
        }
      }
      var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
      var replace = getReplacer(entities_json_1.default);
      function replacer(str) {
        if (str.substr(-1) !== ";")
          str += ";";
        return replace(str);
      }
      return function(str) {
        return String(str).replace(re, replacer);
      };
    }();
    function getReplacer(map2) {
      return function replace(str) {
        if (str.charAt(1) === "#") {
          var secondChar = str.charAt(2);
          if (secondChar === "X" || secondChar === "x") {
            return decode_codepoint_1.default(parseInt(str.substr(3), 16));
          }
          return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        return map2[str.slice(1, -1)];
      };
    }
  }
});

// ../../node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "../../node_modules/entities/lib/encode.js"(exports2) {
    "use strict";
    var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escape = exports2.encodeHTML = exports2.encodeXML = void 0;
    var xml_json_1 = __importDefault3(require_xml());
    var inverseXML = getInverseObj(xml_json_1.default);
    var xmlReplacer = getInverseReplacer(inverseXML);
    exports2.encodeXML = getInverse(inverseXML, xmlReplacer);
    var entities_json_1 = __importDefault3(require_entities());
    var inverseHTML = getInverseObj(entities_json_1.default);
    var htmlReplacer = getInverseReplacer(inverseHTML);
    exports2.encodeHTML = getInverse(inverseHTML, htmlReplacer);
    function getInverseObj(obj) {
      return Object.keys(obj).sort().reduce(function(inverse, name2) {
        inverse[obj[name2]] = "&" + name2 + ";";
        return inverse;
      }, {});
    }
    function getInverseReplacer(inverse) {
      var single = [];
      var multiple = [];
      for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
          single.push("\\" + k);
        } else {
          multiple.push(k);
        }
      }
      single.sort();
      for (var start = 0; start < single.length - 1; start++) {
        var end = start;
        while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
          end += 1;
        }
        var count = 1 + end - start;
        if (count < 3)
          continue;
        single.splice(start, count, single[start] + "-" + single[end]);
      }
      multiple.unshift("[" + single.join("") + "]");
      return new RegExp(multiple.join("|"), "g");
    }
    var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
    function singleCharReplacer(c) {
      return "&#x" + c.codePointAt(0).toString(16).toUpperCase() + ";";
    }
    function getInverse(inverse, re) {
      return function(data) {
        return data.replace(re, function(name2) {
          return inverse[name2];
        }).replace(reNonASCII, singleCharReplacer);
      };
    }
    var reXmlChars = getInverseReplacer(inverseXML);
    function escape2(data) {
      return data.replace(reXmlChars, singleCharReplacer).replace(reNonASCII, singleCharReplacer);
    }
    exports2.escape = escape2;
  }
});

// ../../node_modules/entities/lib/index.js
var require_lib18 = __commonJS({
  "../../node_modules/entities/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.escape = exports2.encodeHTML = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = void 0;
    var decode_1 = require_decode2();
    var encode_1 = require_encode();
    function decode(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    exports2.decode = decode;
    function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    exports2.decodeStrict = decodeStrict;
    function encode(data, level) {
      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    exports2.encode = encode;
    var encode_2 = require_encode();
    Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
      return encode_2.encodeXML;
    } });
    Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return encode_2.escape;
    } });
    Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    var decode_2 = require_decode2();
    Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
    Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/dom-serializer/lib/foreignNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attributeNames = exports2.elementNames = void 0;
    exports2.elementNames = /* @__PURE__ */ new Map([
      ["altglyph", "altGlyph"],
      ["altglyphdef", "altGlyphDef"],
      ["altglyphitem", "altGlyphItem"],
      ["animatecolor", "animateColor"],
      ["animatemotion", "animateMotion"],
      ["animatetransform", "animateTransform"],
      ["clippath", "clipPath"],
      ["feblend", "feBlend"],
      ["fecolormatrix", "feColorMatrix"],
      ["fecomponenttransfer", "feComponentTransfer"],
      ["fecomposite", "feComposite"],
      ["feconvolvematrix", "feConvolveMatrix"],
      ["fediffuselighting", "feDiffuseLighting"],
      ["fedisplacementmap", "feDisplacementMap"],
      ["fedistantlight", "feDistantLight"],
      ["fedropshadow", "feDropShadow"],
      ["feflood", "feFlood"],
      ["fefunca", "feFuncA"],
      ["fefuncb", "feFuncB"],
      ["fefuncg", "feFuncG"],
      ["fefuncr", "feFuncR"],
      ["fegaussianblur", "feGaussianBlur"],
      ["feimage", "feImage"],
      ["femerge", "feMerge"],
      ["femergenode", "feMergeNode"],
      ["femorphology", "feMorphology"],
      ["feoffset", "feOffset"],
      ["fepointlight", "fePointLight"],
      ["fespecularlighting", "feSpecularLighting"],
      ["fespotlight", "feSpotLight"],
      ["fetile", "feTile"],
      ["feturbulence", "feTurbulence"],
      ["foreignobject", "foreignObject"],
      ["glyphref", "glyphRef"],
      ["lineargradient", "linearGradient"],
      ["radialgradient", "radialGradient"],
      ["textpath", "textPath"]
    ]);
    exports2.attributeNames = /* @__PURE__ */ new Map([
      ["definitionurl", "definitionURL"],
      ["attributename", "attributeName"],
      ["attributetype", "attributeType"],
      ["basefrequency", "baseFrequency"],
      ["baseprofile", "baseProfile"],
      ["calcmode", "calcMode"],
      ["clippathunits", "clipPathUnits"],
      ["diffuseconstant", "diffuseConstant"],
      ["edgemode", "edgeMode"],
      ["filterunits", "filterUnits"],
      ["glyphref", "glyphRef"],
      ["gradienttransform", "gradientTransform"],
      ["gradientunits", "gradientUnits"],
      ["kernelmatrix", "kernelMatrix"],
      ["kernelunitlength", "kernelUnitLength"],
      ["keypoints", "keyPoints"],
      ["keysplines", "keySplines"],
      ["keytimes", "keyTimes"],
      ["lengthadjust", "lengthAdjust"],
      ["limitingconeangle", "limitingConeAngle"],
      ["markerheight", "markerHeight"],
      ["markerunits", "markerUnits"],
      ["markerwidth", "markerWidth"],
      ["maskcontentunits", "maskContentUnits"],
      ["maskunits", "maskUnits"],
      ["numoctaves", "numOctaves"],
      ["pathlength", "pathLength"],
      ["patterncontentunits", "patternContentUnits"],
      ["patterntransform", "patternTransform"],
      ["patternunits", "patternUnits"],
      ["pointsatx", "pointsAtX"],
      ["pointsaty", "pointsAtY"],
      ["pointsatz", "pointsAtZ"],
      ["preservealpha", "preserveAlpha"],
      ["preserveaspectratio", "preserveAspectRatio"],
      ["primitiveunits", "primitiveUnits"],
      ["refx", "refX"],
      ["refy", "refY"],
      ["repeatcount", "repeatCount"],
      ["repeatdur", "repeatDur"],
      ["requiredextensions", "requiredExtensions"],
      ["requiredfeatures", "requiredFeatures"],
      ["specularconstant", "specularConstant"],
      ["specularexponent", "specularExponent"],
      ["spreadmethod", "spreadMethod"],
      ["startoffset", "startOffset"],
      ["stddeviation", "stdDeviation"],
      ["stitchtiles", "stitchTiles"],
      ["surfacescale", "surfaceScale"],
      ["systemlanguage", "systemLanguage"],
      ["tablevalues", "tableValues"],
      ["targetx", "targetX"],
      ["targety", "targetY"],
      ["textlength", "textLength"],
      ["viewbox", "viewBox"],
      ["viewtarget", "viewTarget"],
      ["xchannelselector", "xChannelSelector"],
      ["ychannelselector", "yChannelSelector"],
      ["zoomandpan", "zoomAndPan"]
    ]);
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/dom-serializer/lib/index.js
var require_lib19 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/dom-serializer/lib/index.js"(exports2) {
    "use strict";
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ElementType = __importStar2(require_lib16());
    var entities_1 = require_lib18();
    var foreignNames_1 = require_foreignNames();
    var unencodedElements = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function formatAttributes(attributes, opts) {
      if (!attributes)
        return;
      return Object.keys(attributes).map(function(key2) {
        var _a, _b;
        var value = (_a = attributes[key2]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
          key2 = (_b = foreignNames_1.attributeNames.get(key2)) !== null && _b !== void 0 ? _b : key2;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
          return key2;
        }
        return key2 + '="' + (opts.decodeEntities !== false ? entities_1.encodeXML(value) : value.replace(/"/g, "&quot;")) + '"';
      }).join(" ");
    }
    var singleTag = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function render(node, options) {
      if (options === void 0) {
        options = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
      }
      return output;
    }
    exports2.default = render;
    function renderNode(node, options) {
      switch (node.type) {
        case ElementType.Root:
          return render(node.children, options);
        case ElementType.Directive:
        case ElementType.Doctype:
          return renderDirective(node);
        case ElementType.Comment:
          return renderComment(node);
        case ElementType.CDATA:
          return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
          return renderTag(node, options);
        case ElementType.Text:
          return renderText(node, options);
      }
    }
    var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag(elem, opts) {
      var _a;
      if (opts.xmlMode === "foreign") {
        elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
          opts = __assign2(__assign2({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign2(__assign2({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<" + elem.name;
      var attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
        tag += " " + attribs;
      }
      if (elem.children.length === 0 && (opts.xmlMode ? (
        // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
        opts.selfClosingTags !== false
      ) : (
        // User explicitly asked for self-closing tags, even in HTML mode
        opts.selfClosingTags && singleTag.has(elem.name)
      ))) {
        if (!opts.xmlMode)
          tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
          tag += "</" + elem.name + ">";
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<" + elem.data + ">";
    }
    function renderText(elem, opts) {
      var data = elem.data || "";
      if (opts.decodeEntities !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
        data = entities_1.encodeXML(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[" + elem.children[0].data + "]]>";
    }
    function renderComment(elem) {
      return "<!--" + elem.data + "-->";
    }
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/stringify.js"(exports2) {
    "use strict";
    var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.innerText = exports2.textContent = exports2.getText = exports2.getInnerHTML = exports2.getOuterHTML = void 0;
    var domhandler_1 = require_lib17();
    var dom_serializer_1 = __importDefault3(require_lib19());
    var domelementtype_1 = require_lib16();
    function getOuterHTML(node, options) {
      return (0, dom_serializer_1.default)(node, options);
    }
    exports2.getOuterHTML = getOuterHTML;
    function getInnerHTML(node, options) {
      return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
        return getOuterHTML(node2, options);
      }).join("") : "";
    }
    exports2.getInnerHTML = getInnerHTML;
    function getText(node) {
      if (Array.isArray(node))
        return node.map(getText).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
      if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports2.getText = getText;
    function textContent(node) {
      if (Array.isArray(node))
        return node.map(textContent).join("");
      if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports2.textContent = textContent;
    function innerText(node) {
      if (Array.isArray(node))
        return node.map(innerText).join("");
      if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports2.innerText = innerText;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/traversal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prevElementSibling = exports2.nextElementSibling = exports2.getName = exports2.hasAttrib = exports2.getAttributeValue = exports2.getSiblings = exports2.getParent = exports2.getChildren = void 0;
    var domhandler_1 = require_lib17();
    var emptyArray2 = [];
    function getChildren(elem) {
      var _a;
      return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray2;
    }
    exports2.getChildren = getChildren;
    function getParent(elem) {
      return elem.parent || null;
    }
    exports2.getParent = getParent;
    function getSiblings(elem) {
      var _a, _b;
      var parent = getParent(elem);
      if (parent != null)
        return getChildren(parent);
      var siblings = [elem];
      var prev = elem.prev, next = elem.next;
      while (prev != null) {
        siblings.unshift(prev);
        _a = prev, prev = _a.prev;
      }
      while (next != null) {
        siblings.push(next);
        _b = next, next = _b.next;
      }
      return siblings;
    }
    exports2.getSiblings = getSiblings;
    function getAttributeValue(elem, name2) {
      var _a;
      return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name2];
    }
    exports2.getAttributeValue = getAttributeValue;
    function hasAttrib(elem, name2) {
      return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
    }
    exports2.hasAttrib = hasAttrib;
    function getName(elem) {
      return elem.name;
    }
    exports2.getName = getName;
    function nextElementSibling(elem) {
      var _a;
      var next = elem.next;
      while (next !== null && !(0, domhandler_1.isTag)(next))
        _a = next, next = _a.next;
      return next;
    }
    exports2.nextElementSibling = nextElementSibling;
    function prevElementSibling(elem) {
      var _a;
      var prev = elem.prev;
      while (prev !== null && !(0, domhandler_1.isTag)(prev))
        _a = prev, prev = _a.prev;
      return prev;
    }
    exports2.prevElementSibling = prevElementSibling;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/manipulation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepend = exports2.prependChild = exports2.append = exports2.appendChild = exports2.replaceElement = exports2.removeElement = void 0;
    function removeElement(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
      }
    }
    exports2.removeElement = removeElement;
    function replaceElement(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
      }
    }
    exports2.replaceElement = replaceElement;
    function appendChild(elem, child) {
      removeElement(child);
      child.next = null;
      child.parent = elem;
      if (elem.children.push(child) > 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    exports2.appendChild = appendChild;
    function append(elem, next) {
      removeElement(next);
      var parent = elem.parent;
      var currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    }
    exports2.append = append;
    function prependChild(elem, child) {
      removeElement(child);
      child.parent = elem;
      child.prev = null;
      if (elem.children.unshift(child) !== 1) {
        var sibling = elem.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    exports2.prependChild = prependChild;
    function prepend(elem, prev) {
      removeElement(prev);
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    }
    exports2.prepend = prepend;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/querying.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findAll = exports2.existsOne = exports2.findOne = exports2.findOneChild = exports2.find = exports2.filter = void 0;
    var domhandler_1 = require_lib17();
    function filter(test, node, recurse, limit2) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit2 === void 0) {
        limit2 = Infinity;
      }
      if (!Array.isArray(node))
        node = [node];
      return find5(test, node, recurse, limit2);
    }
    exports2.filter = filter;
    function find5(test, nodes, recurse, limit2) {
      var result = [];
      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var elem = nodes_1[_i];
        if (test(elem)) {
          result.push(elem);
          if (--limit2 <= 0)
            break;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          var children2 = find5(test, elem.children, recurse, limit2);
          result.push.apply(result, children2);
          limit2 -= children2.length;
          if (limit2 <= 0)
            break;
        }
      }
      return result;
    }
    exports2.find = find5;
    function findOneChild(test, nodes) {
      return nodes.find(test);
    }
    exports2.findOneChild = findOneChild;
    function findOne(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var elem = null;
      for (var i = 0; i < nodes.length && !elem; i++) {
        var checked = nodes[i];
        if (!(0, domhandler_1.isTag)(checked)) {
          continue;
        } else if (test(checked)) {
          elem = checked;
        } else if (recurse && checked.children.length > 0) {
          elem = findOne(test, checked.children);
        }
      }
      return elem;
    }
    exports2.findOne = findOne;
    function existsOne(test, nodes) {
      return nodes.some(function(checked) {
        return (0, domhandler_1.isTag)(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children));
      });
    }
    exports2.existsOne = existsOne;
    function findAll(test, nodes) {
      var _a;
      var result = [];
      var stack = nodes.filter(domhandler_1.isTag);
      var elem;
      while (elem = stack.shift()) {
        var children2 = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);
        if (children2 && children2.length > 0) {
          stack.unshift.apply(stack, children2);
        }
        if (test(elem))
          result.push(elem);
      }
      return result;
    }
    exports2.findAll = findAll;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/legacy.js
var require_legacy2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/legacy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getElementsByTagType = exports2.getElementsByTagName = exports2.getElementById = exports2.getElements = exports2.testElement = void 0;
    var domhandler_1 = require_lib17();
    var querying_1 = require_querying();
    var Checks = {
      tag_name: function(name2) {
        if (typeof name2 === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && name2(elem.name);
          };
        } else if (name2 === "*") {
          return domhandler_1.isTag;
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name2;
        };
      },
      tag_type: function(type) {
        if (typeof type === "function") {
          return function(elem) {
            return type(elem.type);
          };
        }
        return function(elem) {
          return elem.type === type;
        };
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && data(elem.data);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
      };
    }
    function combineFuncs(a, b) {
      return function(elem) {
        return a(elem) || b(elem);
      };
    }
    function compileTest(options) {
      var funcs = Object.keys(options).map(function(key2) {
        var value = options[key2];
        return Object.prototype.hasOwnProperty.call(Checks, key2) ? Checks[key2](value) : getAttribCheck(key2, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    function testElement(options, node) {
      var test = compileTest(options);
      return test ? test(node) : true;
    }
    exports2.testElement = testElement;
    function getElements(options, nodes, recurse, limit2) {
      if (limit2 === void 0) {
        limit2 = Infinity;
      }
      var test = compileTest(options);
      return test ? (0, querying_1.filter)(test, nodes, recurse, limit2) : [];
    }
    exports2.getElements = getElements;
    function getElementById(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes))
        nodes = [nodes];
      return (0, querying_1.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    exports2.getElementById = getElementById;
    function getElementsByTagName(tagName, nodes, recurse, limit2) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit2 === void 0) {
        limit2 = Infinity;
      }
      return (0, querying_1.filter)(Checks.tag_name(tagName), nodes, recurse, limit2);
    }
    exports2.getElementsByTagName = getElementsByTagName;
    function getElementsByTagType(type, nodes, recurse, limit2) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit2 === void 0) {
        limit2 = Infinity;
      }
      return (0, querying_1.filter)(Checks.tag_type(type), nodes, recurse, limit2);
    }
    exports2.getElementsByTagType = getElementsByTagType;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uniqueSort = exports2.compareDocumentPosition = exports2.removeSubsets = void 0;
    var domhandler_1 = require_lib17();
    function removeSubsets(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    exports2.removeSubsets = removeSubsets;
    function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return 1;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return 4 | 16;
        }
        return 4;
      }
      if (sharedParent === nodeA) {
        return 2 | 8;
      }
      return 2;
    }
    exports2.compareDocumentPosition = compareDocumentPosition;
    function uniqueSort(nodes) {
      nodes = nodes.filter(function(node, i, arr) {
        return !arr.includes(node, i + 1);
      });
      nodes.sort(function(a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & 2) {
          return -1;
        } else if (relative & 4) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
    exports2.uniqueSort = uniqueSort;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/feeds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFeed = void 0;
    var stringify_1 = require_stringify();
    var legacy_1 = require_legacy2();
    function getFeed(doc) {
      var feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
    }
    exports2.getFeed = getFeed;
    function getAtomFeed(feedRoot) {
      var _a;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_1.getElementsByTagName)("entry", childs).map(function(item) {
          var _a2;
          var children2 = item.children;
          var entry = { media: getMediaElements(children2) };
          addConditionally(entry, "id", "id", children2);
          addConditionally(entry, "title", "title", children2);
          var href2 = (_a2 = getOneElement("link", children2)) === null || _a2 === void 0 ? void 0 : _a2.attribs.href;
          if (href2) {
            entry.link = href2;
          }
          var description = fetch2("summary", children2) || fetch2("content", children2);
          if (description) {
            entry.description = description;
          }
          var pubDate = fetch2("updated", children2);
          if (pubDate) {
            entry.pubDate = new Date(pubDate);
          }
          return entry;
        })
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs.href;
      if (href) {
        feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      var updated = fetch2("updated", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed(feedRoot) {
      var _a, _b;
      var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
          var children2 = item.children;
          var entry = { media: getMediaElements(children2) };
          addConditionally(entry, "id", "guid", children2);
          addConditionally(entry, "title", "title", children2);
          addConditionally(entry, "link", "link", children2);
          addConditionally(entry, "description", "description", children2);
          var pubDate = fetch2("pubDate", children2);
          if (pubDate)
            entry.pubDate = new Date(pubDate);
          return entry;
        })
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      var updated = fetch2("lastBuildDate", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function getMediaElements(where) {
      return (0, legacy_1.getElementsByTagName)("media:content", where).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
          medium: attribs.medium,
          isDefault: !!attribs.isDefault
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
          var attrib = MEDIA_KEYS_STRING_1[_i];
          if (attribs[attrib]) {
            media[attrib] = attribs[attrib];
          }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
          var attrib = MEDIA_KEYS_INT_1[_a];
          if (attribs[attrib]) {
            media[attrib] = parseInt(attribs[attrib], 10);
          }
        }
        if (attribs.expression) {
          media.expression = attribs.expression;
        }
        return media;
      });
    }
    function getOneElement(tagName, node) {
      return (0, legacy_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch2(tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_1.textContent)((0, legacy_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
    }
    function addConditionally(obj, prop, tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val = fetch2(tagName, where, recurse);
      if (val)
        obj[prop] = val;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/index.js
var require_lib20 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
    __exportStar2(require_stringify(), exports2);
    __exportStar2(require_traversal(), exports2);
    __exportStar2(require_manipulation(), exports2);
    __exportStar2(require_querying(), exports2);
    __exportStar2(require_legacy2(), exports2);
    __exportStar2(require_helpers(), exports2);
    __exportStar2(require_feeds(), exports2);
    var domhandler_1 = require_lib17();
    Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/FeedHandler.js
var require_FeedHandler = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/FeedHandler.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseFeed = exports2.FeedHandler = void 0;
    var domhandler_1 = __importDefault3(require_lib17());
    var DomUtils = __importStar2(require_lib20());
    var Parser_1 = require_Parser();
    var FeedItemMediaMedium;
    (function(FeedItemMediaMedium2) {
      FeedItemMediaMedium2[FeedItemMediaMedium2["image"] = 0] = "image";
      FeedItemMediaMedium2[FeedItemMediaMedium2["audio"] = 1] = "audio";
      FeedItemMediaMedium2[FeedItemMediaMedium2["video"] = 2] = "video";
      FeedItemMediaMedium2[FeedItemMediaMedium2["document"] = 3] = "document";
      FeedItemMediaMedium2[FeedItemMediaMedium2["executable"] = 4] = "executable";
    })(FeedItemMediaMedium || (FeedItemMediaMedium = {}));
    var FeedItemMediaExpression;
    (function(FeedItemMediaExpression2) {
      FeedItemMediaExpression2[FeedItemMediaExpression2["sample"] = 0] = "sample";
      FeedItemMediaExpression2[FeedItemMediaExpression2["full"] = 1] = "full";
      FeedItemMediaExpression2[FeedItemMediaExpression2["nonstop"] = 2] = "nonstop";
    })(FeedItemMediaExpression || (FeedItemMediaExpression = {}));
    var FeedHandler = (
      /** @class */
      function(_super) {
        __extends2(FeedHandler2, _super);
        function FeedHandler2(callback, options) {
          var _this = this;
          if (typeof callback === "object") {
            callback = void 0;
            options = callback;
          }
          _this = _super.call(this, callback, options) || this;
          return _this;
        }
        FeedHandler2.prototype.onend = function() {
          var _a, _b;
          var feedRoot = getOneElement(isValidFeed, this.dom);
          if (!feedRoot) {
            this.handleCallback(new Error("couldn't find root of feed"));
            return;
          }
          var feed = {};
          if (feedRoot.name === "feed") {
            var childs = feedRoot.children;
            feed.type = "atom";
            addConditionally(feed, "id", "id", childs);
            addConditionally(feed, "title", "title", childs);
            var href = getAttribute("href", getOneElement("link", childs));
            if (href) {
              feed.link = href;
            }
            addConditionally(feed, "description", "subtitle", childs);
            var updated = fetch2("updated", childs);
            if (updated) {
              feed.updated = new Date(updated);
            }
            addConditionally(feed, "author", "email", childs, true);
            feed.items = getElements("entry", childs).map(function(item) {
              var entry = {};
              var children2 = item.children;
              addConditionally(entry, "id", "id", children2);
              addConditionally(entry, "title", "title", children2);
              var href2 = getAttribute("href", getOneElement("link", children2));
              if (href2) {
                entry.link = href2;
              }
              var description = fetch2("summary", children2) || fetch2("content", children2);
              if (description) {
                entry.description = description;
              }
              var pubDate = fetch2("updated", children2);
              if (pubDate) {
                entry.pubDate = new Date(pubDate);
              }
              entry.media = getMediaElements(children2);
              return entry;
            });
          } else {
            var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
            feed.type = feedRoot.name.substr(0, 3);
            feed.id = "";
            addConditionally(feed, "title", "title", childs);
            addConditionally(feed, "link", "link", childs);
            addConditionally(feed, "description", "description", childs);
            var updated = fetch2("lastBuildDate", childs);
            if (updated) {
              feed.updated = new Date(updated);
            }
            addConditionally(feed, "author", "managingEditor", childs, true);
            feed.items = getElements("item", feedRoot.children).map(function(item) {
              var entry = {};
              var children2 = item.children;
              addConditionally(entry, "id", "guid", children2);
              addConditionally(entry, "title", "title", children2);
              addConditionally(entry, "link", "link", children2);
              addConditionally(entry, "description", "description", children2);
              var pubDate = fetch2("pubDate", children2);
              if (pubDate)
                entry.pubDate = new Date(pubDate);
              entry.media = getMediaElements(children2);
              return entry;
            });
          }
          this.feed = feed;
          this.handleCallback(null);
        };
        return FeedHandler2;
      }(domhandler_1.default)
    );
    exports2.FeedHandler = FeedHandler;
    function getMediaElements(where) {
      return getElements("media:content", where).map(function(elem) {
        var media = {
          medium: elem.attribs.medium,
          isDefault: !!elem.attribs.isDefault
        };
        if (elem.attribs.url) {
          media.url = elem.attribs.url;
        }
        if (elem.attribs.fileSize) {
          media.fileSize = parseInt(elem.attribs.fileSize, 10);
        }
        if (elem.attribs.type) {
          media.type = elem.attribs.type;
        }
        if (elem.attribs.expression) {
          media.expression = elem.attribs.expression;
        }
        if (elem.attribs.bitrate) {
          media.bitrate = parseInt(elem.attribs.bitrate, 10);
        }
        if (elem.attribs.framerate) {
          media.framerate = parseInt(elem.attribs.framerate, 10);
        }
        if (elem.attribs.samplingrate) {
          media.samplingrate = parseInt(elem.attribs.samplingrate, 10);
        }
        if (elem.attribs.channels) {
          media.channels = parseInt(elem.attribs.channels, 10);
        }
        if (elem.attribs.duration) {
          media.duration = parseInt(elem.attribs.duration, 10);
        }
        if (elem.attribs.height) {
          media.height = parseInt(elem.attribs.height, 10);
        }
        if (elem.attribs.width) {
          media.width = parseInt(elem.attribs.width, 10);
        }
        if (elem.attribs.lang) {
          media.lang = elem.attribs.lang;
        }
        return media;
      });
    }
    function getElements(tagName, where) {
      return DomUtils.getElementsByTagName(tagName, where, true);
    }
    function getOneElement(tagName, node) {
      return DomUtils.getElementsByTagName(tagName, node, true, 1)[0];
    }
    function fetch2(tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return DomUtils.getText(DomUtils.getElementsByTagName(tagName, where, recurse, 1)).trim();
    }
    function getAttribute(name2, elem) {
      if (!elem) {
        return null;
      }
      var attribs = elem.attribs;
      return attribs[name2];
    }
    function addConditionally(obj, prop, what, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var tmp = fetch2(what, where, recurse);
      if (tmp)
        obj[prop] = tmp;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
    function parseFeed(feed, options) {
      if (options === void 0) {
        options = { xmlMode: true };
      }
      var handler = new FeedHandler(options);
      new Parser_1.Parser(handler, options).end(feed);
      return handler.feed;
    }
    exports2.parseFeed = parseFeed;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/index.js
var require_lib21 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RssHandler = exports2.DefaultHandler = exports2.DomUtils = exports2.ElementType = exports2.Tokenizer = exports2.createDomStream = exports2.parseDOM = exports2.parseDocument = exports2.DomHandler = exports2.Parser = void 0;
    var Parser_1 = require_Parser();
    Object.defineProperty(exports2, "Parser", { enumerable: true, get: function() {
      return Parser_1.Parser;
    } });
    var domhandler_1 = require_lib17();
    Object.defineProperty(exports2, "DomHandler", { enumerable: true, get: function() {
      return domhandler_1.DomHandler;
    } });
    Object.defineProperty(exports2, "DefaultHandler", { enumerable: true, get: function() {
      return domhandler_1.DomHandler;
    } });
    function parseDocument(data, options) {
      var handler = new domhandler_1.DomHandler(void 0, options);
      new Parser_1.Parser(handler, options).end(data);
      return handler.root;
    }
    exports2.parseDocument = parseDocument;
    function parseDOM(data, options) {
      return parseDocument(data, options).children;
    }
    exports2.parseDOM = parseDOM;
    function createDomStream(cb, options, elementCb) {
      var handler = new domhandler_1.DomHandler(cb, options, elementCb);
      return new Parser_1.Parser(handler, options);
    }
    exports2.createDomStream = createDomStream;
    var Tokenizer_1 = require_Tokenizer();
    Object.defineProperty(exports2, "Tokenizer", { enumerable: true, get: function() {
      return __importDefault3(Tokenizer_1).default;
    } });
    var ElementType = __importStar2(require_lib16());
    exports2.ElementType = ElementType;
    __exportStar2(require_FeedHandler(), exports2);
    exports2.DomUtils = __importStar2(require_lib20());
    var FeedHandler_1 = require_FeedHandler();
    Object.defineProperty(exports2, "RssHandler", { enumerable: true, get: function() {
      return FeedHandler_1.FeedHandler;
    } });
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// ../../node_modules/is-plain-object/dist/is-plain-object.js
var require_is_plain_object = __commonJS({
  "../../node_modules/is-plain-object/dist/is-plain-object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isObject9(o) {
      return Object.prototype.toString.call(o) === "[object Object]";
    }
    function isPlainObject4(o) {
      var ctor, prot;
      if (isObject9(o) === false)
        return false;
      ctor = o.constructor;
      if (ctor === void 0)
        return true;
      prot = ctor.prototype;
      if (isObject9(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    }
    exports2.isPlainObject = isPlainObject4;
  }
});

// ../../node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../../node_modules/deepmerge/dist/cjs.js"(exports2, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target2, source, options) {
      return target2.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key2, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key2);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target2) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target2).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target2, symbol);
      }) : [];
    }
    function getKeys(target2) {
      return Object.keys(target2).concat(getEnumerableOwnPropertySymbols(target2));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target2, key2) {
      return propertyIsOnObject(target2, key2) && !(Object.hasOwnProperty.call(target2, key2) && Object.propertyIsEnumerable.call(target2, key2));
    }
    function mergeObject(target2, source, options) {
      var destination = {};
      if (options.isMergeableObject(target2)) {
        getKeys(target2).forEach(function(key2) {
          destination[key2] = cloneUnlessOtherwiseSpecified(target2[key2], options);
        });
      }
      getKeys(source).forEach(function(key2) {
        if (propertyIsUnsafe(target2, key2)) {
          return;
        }
        if (propertyIsOnObject(target2, key2) && options.isMergeableObject(source[key2])) {
          destination[key2] = getMergeFunction(key2, options)(target2[key2], source[key2], options);
        } else {
          destination[key2] = cloneUnlessOtherwiseSpecified(source[key2], options);
        }
      });
      return destination;
    }
    function deepmerge(target2, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target2);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target2, source, options);
      } else {
        return mergeObject(target2, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module2.exports = deepmerge_1;
  }
});

// ../../node_modules/parse-srcset/src/parse-srcset.js
var require_parse_srcset = __commonJS({
  "../../node_modules/parse-srcset/src/parse-srcset.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.parseSrcset = factory();
      }
    })(exports2, function() {
      return function(input) {
        function isSpace(c2) {
          return c2 === " " || // space
          c2 === "	" || // horizontal tab
          c2 === "\n" || // new line
          c2 === "\f" || // form feed
          c2 === "\r";
        }
        function collectCharacters(regEx) {
          var chars, match = regEx.exec(input.substring(pos));
          if (match) {
            chars = match[0];
            pos += chars.length;
            return chars;
          }
        }
        var inputLength = input.length, regexLeadingSpaces = /^[ \t\n\r\u000c]+/, regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/, regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\d+$/, regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, url, descriptors, currentDescriptor, state, c, pos = 0, candidates = [];
        while (true) {
          collectCharacters(regexLeadingCommasOrSpaces);
          if (pos >= inputLength) {
            return candidates;
          }
          url = collectCharacters(regexLeadingNotSpaces);
          descriptors = [];
          if (url.slice(-1) === ",") {
            url = url.replace(regexTrailingCommas, "");
            parseDescriptors();
          } else {
            tokenize();
          }
        }
        function tokenize() {
          collectCharacters(regexLeadingSpaces);
          currentDescriptor = "";
          state = "in descriptor";
          while (true) {
            c = input.charAt(pos);
            if (state === "in descriptor") {
              if (isSpace(c)) {
                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                  currentDescriptor = "";
                  state = "after descriptor";
                }
              } else if (c === ",") {
                pos += 1;
                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                }
                parseDescriptors();
                return;
              } else if (c === "(") {
                currentDescriptor = currentDescriptor + c;
                state = "in parens";
              } else if (c === "") {
                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                }
                parseDescriptors();
                return;
              } else {
                currentDescriptor = currentDescriptor + c;
              }
            } else if (state === "in parens") {
              if (c === ")") {
                currentDescriptor = currentDescriptor + c;
                state = "in descriptor";
              } else if (c === "") {
                descriptors.push(currentDescriptor);
                parseDescriptors();
                return;
              } else {
                currentDescriptor = currentDescriptor + c;
              }
            } else if (state === "after descriptor") {
              if (isSpace(c)) {
              } else if (c === "") {
                parseDescriptors();
                return;
              } else {
                state = "in descriptor";
                pos -= 1;
              }
            }
            pos += 1;
          }
        }
        function parseDescriptors() {
          var pError = false, w, d, h2, i, candidate = {}, desc, lastChar, value, intVal, floatVal;
          for (i = 0; i < descriptors.length; i++) {
            desc = descriptors[i];
            lastChar = desc[desc.length - 1];
            value = desc.substring(0, desc.length - 1);
            intVal = parseInt(value, 10);
            floatVal = parseFloat(value);
            if (regexNonNegativeInteger.test(value) && lastChar === "w") {
              if (w || d) {
                pError = true;
              }
              if (intVal === 0) {
                pError = true;
              } else {
                w = intVal;
              }
            } else if (regexFloatingPoint.test(value) && lastChar === "x") {
              if (w || d || h2) {
                pError = true;
              }
              if (floatVal < 0) {
                pError = true;
              } else {
                d = floatVal;
              }
            } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
              if (h2 || d) {
                pError = true;
              }
              if (intVal === 0) {
                pError = true;
              } else {
                h2 = intVal;
              }
            } else {
              pError = true;
            }
          }
          if (!pError) {
            candidate.url = url;
            if (w) {
              candidate.w = w;
            }
            if (d) {
              candidate.d = d;
            }
            if (h2) {
              candidate.h = h2;
            }
            candidates.push(candidate);
          } else if (console && console.log) {
            console.log("Invalid srcset descriptor found in '" + input + "' at '" + desc + "'.");
          }
        }
      };
    });
  }
});

// ../../node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = __commonJS({
  "../../node_modules/picocolors/picocolors.browser.js"(exports2, module2) {
    var x = String;
    var create5 = function() {
      return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x };
    };
    module2.exports = create5();
    module2.exports.createColors = create5;
  }
});

// (disabled):../../node_modules/postcss/lib/terminal-highlight
var require_terminal_highlight = __commonJS({
  "(disabled):../../node_modules/postcss/lib/terminal-highlight"() {
  }
});

// ../../node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = __commonJS({
  "../../node_modules/postcss/lib/css-syntax-error.js"(exports2, module2) {
    "use strict";
    var pico = require_picocolors_browser();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError = class extends Error {
      constructor(message, line, column, source, file, plugin) {
        super(message);
        this.name = "CssSyntaxError";
        this.reason = message;
        if (file) {
          this.file = file;
        }
        if (source) {
          this.source = source;
        }
        if (plugin) {
          this.plugin = plugin;
        }
        if (typeof line !== "undefined" && typeof column !== "undefined") {
          if (typeof line === "number") {
            this.line = line;
            this.column = column;
          } else {
            this.line = line.line;
            this.column = line.column;
            this.endLine = column.line;
            this.endColumn = column.column;
          }
        }
        this.setMessage();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, CssSyntaxError);
        }
      }
      setMessage() {
        this.message = this.plugin ? this.plugin + ": " : "";
        this.message += this.file ? this.file : "<css input>";
        if (typeof this.line !== "undefined") {
          this.message += ":" + this.line + ":" + this.column;
        }
        this.message += ": " + this.reason;
      }
      showSourceCode(color) {
        if (!this.source)
          return "";
        let css2 = this.source;
        if (color == null)
          color = pico.isColorSupported;
        if (terminalHighlight) {
          if (color)
            css2 = terminalHighlight(css2);
        }
        let lines = css2.split(/\r?\n/);
        let start = Math.max(this.line - 3, 0);
        let end = Math.min(this.line + 2, lines.length);
        let maxWidth = String(end).length;
        let mark, aside;
        if (color) {
          let { bold, gray, red } = pico.createColors(true);
          mark = (text) => bold(red(text));
          aside = (text) => gray(text);
        } else {
          mark = aside = (str) => str;
        }
        return lines.slice(start, end).map((line, index) => {
          let number = start + 1 + index;
          let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
          if (number === this.line) {
            let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
            return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
          }
          return " " + aside(gutter) + line;
        }).join("\n");
      }
      toString() {
        let code = this.showSourceCode();
        if (code) {
          code = "\n\n" + code + "\n";
        }
        return this.name + ": " + this.message + code;
      }
    };
    module2.exports = CssSyntaxError;
    CssSyntaxError.default = CssSyntaxError;
  }
});

// ../../node_modules/postcss/lib/symbols.js
var require_symbols = __commonJS({
  "../../node_modules/postcss/lib/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports.isClean = Symbol("isClean");
    module2.exports.my = Symbol("my");
  }
});

// ../../node_modules/postcss/lib/stringifier.js
var require_stringifier = __commonJS({
  "../../node_modules/postcss/lib/stringifier.js"(exports2, module2) {
    "use strict";
    var DEFAULT_RAW = {
      after: "\n",
      beforeClose: "\n",
      beforeComment: "\n",
      beforeDecl: "\n",
      beforeOpen: " ",
      beforeRule: "\n",
      colon: ": ",
      commentLeft: " ",
      commentRight: " ",
      emptyBody: "",
      indent: "    ",
      semicolon: false
    };
    function capitalize(str) {
      return str[0].toUpperCase() + str.slice(1);
    }
    var Stringifier = class {
      constructor(builder) {
        this.builder = builder;
      }
      atrule(node, semicolon) {
        let name2 = "@" + node.name;
        let params = node.params ? this.rawValue(node, "params") : "";
        if (typeof node.raws.afterName !== "undefined") {
          name2 += node.raws.afterName;
        } else if (params) {
          name2 += " ";
        }
        if (node.nodes) {
          this.block(node, name2 + params);
        } else {
          let end = (node.raws.between || "") + (semicolon ? ";" : "");
          this.builder(name2 + params + end, node);
        }
      }
      beforeAfter(node, detect) {
        let value;
        if (node.type === "decl") {
          value = this.raw(node, null, "beforeDecl");
        } else if (node.type === "comment") {
          value = this.raw(node, null, "beforeComment");
        } else if (detect === "before") {
          value = this.raw(node, null, "beforeRule");
        } else {
          value = this.raw(node, null, "beforeClose");
        }
        let buf = node.parent;
        let depth = 0;
        while (buf && buf.type !== "root") {
          depth += 1;
          buf = buf.parent;
        }
        if (value.includes("\n")) {
          let indent = this.raw(node, null, "indent");
          if (indent.length) {
            for (let step = 0; step < depth; step++)
              value += indent;
          }
        }
        return value;
      }
      block(node, start) {
        let between = this.raw(node, "between", "beforeOpen");
        this.builder(start + between + "{", node, "start");
        let after;
        if (node.nodes && node.nodes.length) {
          this.body(node);
          after = this.raw(node, "after");
        } else {
          after = this.raw(node, "after", "emptyBody");
        }
        if (after)
          this.builder(after);
        this.builder("}", node, "end");
      }
      body(node) {
        let last = node.nodes.length - 1;
        while (last > 0) {
          if (node.nodes[last].type !== "comment")
            break;
          last -= 1;
        }
        let semicolon = this.raw(node, "semicolon");
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          let before = this.raw(child, "before");
          if (before)
            this.builder(before);
          this.stringify(child, last !== i || semicolon);
        }
      }
      comment(node) {
        let left = this.raw(node, "left", "commentLeft");
        let right = this.raw(node, "right", "commentRight");
        this.builder("/*" + left + node.text + right + "*/", node);
      }
      decl(node, semicolon) {
        let between = this.raw(node, "between", "colon");
        let string = node.prop + between + this.rawValue(node, "value");
        if (node.important) {
          string += node.raws.important || " !important";
        }
        if (semicolon)
          string += ";";
        this.builder(string, node);
      }
      document(node) {
        this.body(node);
      }
      raw(node, own, detect) {
        let value;
        if (!detect)
          detect = own;
        if (own) {
          value = node.raws[own];
          if (typeof value !== "undefined")
            return value;
        }
        let parent = node.parent;
        if (detect === "before") {
          if (!parent || parent.type === "root" && parent.first === node) {
            return "";
          }
          if (parent && parent.type === "document") {
            return "";
          }
        }
        if (!parent)
          return DEFAULT_RAW[detect];
        let root = node.root();
        if (!root.rawCache)
          root.rawCache = {};
        if (typeof root.rawCache[detect] !== "undefined") {
          return root.rawCache[detect];
        }
        if (detect === "before" || detect === "after") {
          return this.beforeAfter(node, detect);
        } else {
          let method = "raw" + capitalize(detect);
          if (this[method]) {
            value = this[method](root, node);
          } else {
            root.walk((i) => {
              value = i.raws[own];
              if (typeof value !== "undefined")
                return false;
            });
          }
        }
        if (typeof value === "undefined")
          value = DEFAULT_RAW[detect];
        root.rawCache[detect] = value;
        return value;
      }
      rawBeforeClose(root) {
        let value;
        root.walk((i) => {
          if (i.nodes && i.nodes.length > 0) {
            if (typeof i.raws.after !== "undefined") {
              value = i.raws.after;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/\S/g, "");
        return value;
      }
      rawBeforeComment(root, node) {
        let value;
        root.walkComments((i) => {
          if (typeof i.raws.before !== "undefined") {
            value = i.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node, null, "beforeDecl");
        } else if (value) {
          value = value.replace(/\S/g, "");
        }
        return value;
      }
      rawBeforeDecl(root, node) {
        let value;
        root.walkDecls((i) => {
          if (typeof i.raws.before !== "undefined") {
            value = i.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node, null, "beforeRule");
        } else if (value) {
          value = value.replace(/\S/g, "");
        }
        return value;
      }
      rawBeforeOpen(root) {
        let value;
        root.walk((i) => {
          if (i.type !== "decl") {
            value = i.raws.between;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawBeforeRule(root) {
        let value;
        root.walk((i) => {
          if (i.nodes && (i.parent !== root || root.first !== i)) {
            if (typeof i.raws.before !== "undefined") {
              value = i.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/\S/g, "");
        return value;
      }
      rawColon(root) {
        let value;
        root.walkDecls((i) => {
          if (typeof i.raws.between !== "undefined") {
            value = i.raws.between.replace(/[^\s:]/g, "");
            return false;
          }
        });
        return value;
      }
      rawEmptyBody(root) {
        let value;
        root.walk((i) => {
          if (i.nodes && i.nodes.length === 0) {
            value = i.raws.after;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawIndent(root) {
        if (root.raws.indent)
          return root.raws.indent;
        let value;
        root.walk((i) => {
          let p = i.parent;
          if (p && p !== root && p.parent && p.parent === root) {
            if (typeof i.raws.before !== "undefined") {
              let parts = i.raws.before.split("\n");
              value = parts[parts.length - 1];
              value = value.replace(/\S/g, "");
              return false;
            }
          }
        });
        return value;
      }
      rawSemicolon(root) {
        let value;
        root.walk((i) => {
          if (i.nodes && i.nodes.length && i.last.type === "decl") {
            value = i.raws.semicolon;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawValue(node, prop) {
        let value = node[prop];
        let raw = node.raws[prop];
        if (raw && raw.value === value) {
          return raw.raw;
        }
        return value;
      }
      root(node) {
        this.body(node);
        if (node.raws.after)
          this.builder(node.raws.after);
      }
      rule(node) {
        this.block(node, this.rawValue(node, "selector"));
        if (node.raws.ownSemicolon) {
          this.builder(node.raws.ownSemicolon, node, "end");
        }
      }
      stringify(node, semicolon) {
        if (!this[node.type]) {
          throw new Error(
            "Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier."
          );
        }
        this[node.type](node, semicolon);
      }
    };
    module2.exports = Stringifier;
    Stringifier.default = Stringifier;
  }
});

// ../../node_modules/postcss/lib/stringify.js
var require_stringify2 = __commonJS({
  "../../node_modules/postcss/lib/stringify.js"(exports2, module2) {
    "use strict";
    var Stringifier = require_stringifier();
    function stringify(node, builder) {
      let str = new Stringifier(builder);
      str.stringify(node);
    }
    module2.exports = stringify;
    stringify.default = stringify;
  }
});

// ../../node_modules/postcss/lib/node.js
var require_node2 = __commonJS({
  "../../node_modules/postcss/lib/node.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var CssSyntaxError = require_css_syntax_error();
    var Stringifier = require_stringifier();
    var stringify = require_stringify2();
    function cloneNode(obj, parent) {
      let cloned = new obj.constructor();
      for (let i in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, i)) {
          continue;
        }
        if (i === "proxyCache")
          continue;
        let value = obj[i];
        let type = typeof value;
        if (i === "parent" && type === "object") {
          if (parent)
            cloned[i] = parent;
        } else if (i === "source") {
          cloned[i] = value;
        } else if (Array.isArray(value)) {
          cloned[i] = value.map((j) => cloneNode(j, cloned));
        } else {
          if (type === "object" && value !== null)
            value = cloneNode(value);
          cloned[i] = value;
        }
      }
      return cloned;
    }
    var Node2 = class {
      constructor(defaults = {}) {
        this.raws = {};
        this[isClean] = false;
        this[my] = true;
        for (let name2 in defaults) {
          if (name2 === "nodes") {
            this.nodes = [];
            for (let node of defaults[name2]) {
              if (typeof node.clone === "function") {
                this.append(node.clone());
              } else {
                this.append(node);
              }
            }
          } else {
            this[name2] = defaults[name2];
          }
        }
      }
      addToError(error) {
        error.postcssNode = this;
        if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
          let s = this.source;
          error.stack = error.stack.replace(
            /\n\s{4}at /,
            `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
          );
        }
        return error;
      }
      after(add) {
        this.parent.insertAfter(this, add);
        return this;
      }
      assign(overrides = {}) {
        for (let name2 in overrides) {
          this[name2] = overrides[name2];
        }
        return this;
      }
      before(add) {
        this.parent.insertBefore(this, add);
        return this;
      }
      cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween)
          delete this.raws.between;
      }
      clone(overrides = {}) {
        let cloned = cloneNode(this);
        for (let name2 in overrides) {
          cloned[name2] = overrides[name2];
        }
        return cloned;
      }
      cloneAfter(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
      }
      cloneBefore(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
      }
      error(message, opts = {}) {
        if (this.source) {
          let { end, start } = this.rangeBy(opts);
          return this.source.input.error(
            message,
            { column: start.column, line: start.line },
            { column: end.column, line: end.line },
            opts
          );
        }
        return new CssSyntaxError(message);
      }
      getProxyProcessor() {
        return {
          get(node, prop) {
            if (prop === "proxyOf") {
              return node;
            } else if (prop === "root") {
              return () => node.root().toProxy();
            } else {
              return node[prop];
            }
          },
          set(node, prop, value) {
            if (node[prop] === value)
              return true;
            node[prop] = value;
            if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
            prop === "text") {
              node.markDirty();
            }
            return true;
          }
        };
      }
      markDirty() {
        if (this[isClean]) {
          this[isClean] = false;
          let next = this;
          while (next = next.parent) {
            next[isClean] = false;
          }
        }
      }
      next() {
        if (!this.parent)
          return void 0;
        let index = this.parent.index(this);
        return this.parent.nodes[index + 1];
      }
      positionBy(opts, stringRepresentation) {
        let pos = this.source.start;
        if (opts.index) {
          pos = this.positionInside(opts.index, stringRepresentation);
        } else if (opts.word) {
          stringRepresentation = this.toString();
          let index = stringRepresentation.indexOf(opts.word);
          if (index !== -1)
            pos = this.positionInside(index, stringRepresentation);
        }
        return pos;
      }
      positionInside(index, stringRepresentation) {
        let string = stringRepresentation || this.toString();
        let column = this.source.start.column;
        let line = this.source.start.line;
        for (let i = 0; i < index; i++) {
          if (string[i] === "\n") {
            column = 1;
            line += 1;
          } else {
            column += 1;
          }
        }
        return { column, line };
      }
      prev() {
        if (!this.parent)
          return void 0;
        let index = this.parent.index(this);
        return this.parent.nodes[index - 1];
      }
      rangeBy(opts) {
        let start = {
          column: this.source.start.column,
          line: this.source.start.line
        };
        let end = this.source.end ? {
          column: this.source.end.column + 1,
          line: this.source.end.line
        } : {
          column: start.column + 1,
          line: start.line
        };
        if (opts.word) {
          let stringRepresentation = this.toString();
          let index = stringRepresentation.indexOf(opts.word);
          if (index !== -1) {
            start = this.positionInside(index, stringRepresentation);
            end = this.positionInside(index + opts.word.length, stringRepresentation);
          }
        } else {
          if (opts.start) {
            start = {
              column: opts.start.column,
              line: opts.start.line
            };
          } else if (opts.index) {
            start = this.positionInside(opts.index);
          }
          if (opts.end) {
            end = {
              column: opts.end.column,
              line: opts.end.line
            };
          } else if (typeof opts.endIndex === "number") {
            end = this.positionInside(opts.endIndex);
          } else if (opts.index) {
            end = this.positionInside(opts.index + 1);
          }
        }
        if (end.line < start.line || end.line === start.line && end.column <= start.column) {
          end = { column: start.column + 1, line: start.line };
        }
        return { end, start };
      }
      raw(prop, defaultType) {
        let str = new Stringifier();
        return str.raw(this, prop, defaultType);
      }
      remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      }
      replaceWith(...nodes) {
        if (this.parent) {
          let bookmark = this;
          let foundSelf = false;
          for (let node of nodes) {
            if (node === this) {
              foundSelf = true;
            } else if (foundSelf) {
              this.parent.insertAfter(bookmark, node);
              bookmark = node;
            } else {
              this.parent.insertBefore(bookmark, node);
            }
          }
          if (!foundSelf) {
            this.remove();
          }
        }
        return this;
      }
      root() {
        let result = this;
        while (result.parent && result.parent.type !== "document") {
          result = result.parent;
        }
        return result;
      }
      toJSON(_, inputs) {
        let fixed = {};
        let emitInputs = inputs == null;
        inputs = inputs || /* @__PURE__ */ new Map();
        let inputsNextIndex = 0;
        for (let name2 in this) {
          if (!Object.prototype.hasOwnProperty.call(this, name2)) {
            continue;
          }
          if (name2 === "parent" || name2 === "proxyCache")
            continue;
          let value = this[name2];
          if (Array.isArray(value)) {
            fixed[name2] = value.map((i) => {
              if (typeof i === "object" && i.toJSON) {
                return i.toJSON(null, inputs);
              } else {
                return i;
              }
            });
          } else if (typeof value === "object" && value.toJSON) {
            fixed[name2] = value.toJSON(null, inputs);
          } else if (name2 === "source") {
            let inputId = inputs.get(value.input);
            if (inputId == null) {
              inputId = inputsNextIndex;
              inputs.set(value.input, inputsNextIndex);
              inputsNextIndex++;
            }
            fixed[name2] = {
              end: value.end,
              inputId,
              start: value.start
            };
          } else {
            fixed[name2] = value;
          }
        }
        if (emitInputs) {
          fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
        }
        return fixed;
      }
      toProxy() {
        if (!this.proxyCache) {
          this.proxyCache = new Proxy(this, this.getProxyProcessor());
        }
        return this.proxyCache;
      }
      toString(stringifier = stringify) {
        if (stringifier.stringify)
          stringifier = stringifier.stringify;
        let result = "";
        stringifier(this, (i) => {
          result += i;
        });
        return result;
      }
      warn(result, text, opts) {
        let data = { node: this };
        for (let i in opts)
          data[i] = opts[i];
        return result.warn(text, data);
      }
      get proxyOf() {
        return this;
      }
    };
    module2.exports = Node2;
    Node2.default = Node2;
  }
});

// ../../node_modules/postcss/lib/declaration.js
var require_declaration = __commonJS({
  "../../node_modules/postcss/lib/declaration.js"(exports2, module2) {
    "use strict";
    var Node2 = require_node2();
    var Declaration = class extends Node2 {
      constructor(defaults) {
        if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
          defaults = { ...defaults, value: String(defaults.value) };
        }
        super(defaults);
        this.type = "decl";
      }
      get variable() {
        return this.prop.startsWith("--") || this.prop[0] === "$";
      }
    };
    module2.exports = Declaration;
    Declaration.default = Declaration;
  }
});

// (disabled):../../node_modules/source-map-js/source-map.js
var require_source_map = __commonJS({
  "(disabled):../../node_modules/source-map-js/source-map.js"() {
  }
});

// node-modules-polyfills-empty:path
var require_path4 = __commonJS({
  "node-modules-polyfills-empty:path"(exports2, module2) {
    module2.exports = {};
  }
});

// node-modules-polyfills-empty:url
var require_url4 = __commonJS({
  "node-modules-polyfills-empty:url"(exports2, module2) {
    module2.exports = {};
  }
});

// ../../node_modules/postcss/node_modules/nanoid/non-secure/index.cjs
var require_non_secure = __commonJS({
  "../../node_modules/postcss/node_modules/nanoid/non-secure/index.cjs"(exports2, module2) {
    var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    var customAlphabet = (alphabet, defaultSize = 21) => {
      return (size = defaultSize) => {
        let id = "";
        let i = size;
        while (i--) {
          id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
      };
    };
    var nanoid = (size = 21) => {
      let id = "";
      let i = size;
      while (i--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
    module2.exports = { nanoid, customAlphabet };
  }
});

// node-modules-polyfills-empty:fs
var require_fs = __commonJS({
  "node-modules-polyfills-empty:fs"(exports2, module2) {
    module2.exports = {};
  }
});

// ../../node_modules/postcss/lib/previous-map.js
var require_previous_map = __commonJS({
  "../../node_modules/postcss/lib/previous-map.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { existsSync, readFileSync } = require_fs();
    var { dirname, join: join2 } = require_path4();
    function fromBase64(str) {
      if (Buffer) {
        return Buffer.from(str, "base64").toString();
      } else {
        return window.atob(str);
      }
    }
    var PreviousMap = class {
      constructor(css2, opts) {
        if (opts.map === false)
          return;
        this.loadAnnotation(css2);
        this.inline = this.startWith(this.annotation, "data:");
        let prev = opts.map ? opts.map.prev : void 0;
        let text = this.loadMap(opts.from, prev);
        if (!this.mapFile && opts.from) {
          this.mapFile = opts.from;
        }
        if (this.mapFile)
          this.root = dirname(this.mapFile);
        if (text)
          this.text = text;
      }
      consumer() {
        if (!this.consumerCache) {
          this.consumerCache = new SourceMapConsumer(this.text);
        }
        return this.consumerCache;
      }
      decodeInline(text) {
        let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
        let baseUri = /^data:application\/json;base64,/;
        let charsetUri = /^data:application\/json;charset=utf-?8,/;
        let uri = /^data:application\/json,/;
        if (charsetUri.test(text) || uri.test(text)) {
          return decodeURIComponent(text.substr(RegExp.lastMatch.length));
        }
        if (baseCharsetUri.test(text) || baseUri.test(text)) {
          return fromBase64(text.substr(RegExp.lastMatch.length));
        }
        let encoding = text.match(/data:application\/json;([^,]+),/)[1];
        throw new Error("Unsupported source map encoding " + encoding);
      }
      getAnnotationURL(sourceMapString) {
        return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
      }
      isMap(map2) {
        if (typeof map2 !== "object")
          return false;
        return typeof map2.mappings === "string" || typeof map2._mappings === "string" || Array.isArray(map2.sections);
      }
      loadAnnotation(css2) {
        let comments = css2.match(/\/\*\s*# sourceMappingURL=/gm);
        if (!comments)
          return;
        let start = css2.lastIndexOf(comments.pop());
        let end = css2.indexOf("*/", start);
        if (start > -1 && end > -1) {
          this.annotation = this.getAnnotationURL(css2.substring(start, end));
        }
      }
      loadFile(path2) {
        this.root = dirname(path2);
        if (existsSync(path2)) {
          this.mapFile = path2;
          return readFileSync(path2, "utf-8").toString().trim();
        }
      }
      loadMap(file, prev) {
        if (prev === false)
          return false;
        if (prev) {
          if (typeof prev === "string") {
            return prev;
          } else if (typeof prev === "function") {
            let prevPath = prev(file);
            if (prevPath) {
              let map2 = this.loadFile(prevPath);
              if (!map2) {
                throw new Error(
                  "Unable to load previous source map: " + prevPath.toString()
                );
              }
              return map2;
            }
          } else if (prev instanceof SourceMapConsumer) {
            return SourceMapGenerator.fromSourceMap(prev).toString();
          } else if (prev instanceof SourceMapGenerator) {
            return prev.toString();
          } else if (this.isMap(prev)) {
            return JSON.stringify(prev);
          } else {
            throw new Error(
              "Unsupported previous source map format: " + prev.toString()
            );
          }
        } else if (this.inline) {
          return this.decodeInline(this.annotation);
        } else if (this.annotation) {
          let map2 = this.annotation;
          if (file)
            map2 = join2(dirname(file), map2);
          return this.loadFile(map2);
        }
      }
      startWith(string, start) {
        if (!string)
          return false;
        return string.substr(0, start.length) === start;
      }
      withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
      }
    };
    module2.exports = PreviousMap;
    PreviousMap.default = PreviousMap;
  }
});

// ../../node_modules/postcss/lib/input.js
var require_input = __commonJS({
  "../../node_modules/postcss/lib/input.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { fileURLToPath, pathToFileURL } = require_url4();
    var { isAbsolute, resolve } = require_path4();
    var { nanoid } = require_non_secure();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError = require_css_syntax_error();
    var PreviousMap = require_previous_map();
    var fromOffsetCache = Symbol("fromOffsetCache");
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(resolve && isAbsolute);
    var Input = class {
      constructor(css2, opts = {}) {
        if (css2 === null || typeof css2 === "undefined" || typeof css2 === "object" && !css2.toString) {
          throw new Error(`PostCSS received ${css2} instead of CSS string`);
        }
        this.css = css2.toString();
        if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
          this.hasBOM = true;
          this.css = this.css.slice(1);
        } else {
          this.hasBOM = false;
        }
        if (opts.from) {
          if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
            this.file = opts.from;
          } else {
            this.file = resolve(opts.from);
          }
        }
        if (pathAvailable && sourceMapAvailable) {
          let map2 = new PreviousMap(this.css, opts);
          if (map2.text) {
            this.map = map2;
            let file = map2.consumer().file;
            if (!this.file && file)
              this.file = this.mapResolve(file);
          }
        }
        if (!this.file) {
          this.id = "<input css " + nanoid(6) + ">";
        }
        if (this.map)
          this.map.file = this.from;
      }
      error(message, line, column, opts = {}) {
        let result, endLine, endColumn;
        if (line && typeof line === "object") {
          let start = line;
          let end = column;
          if (typeof start.offset === "number") {
            let pos = this.fromOffset(start.offset);
            line = pos.line;
            column = pos.col;
          } else {
            line = start.line;
            column = start.column;
          }
          if (typeof end.offset === "number") {
            let pos = this.fromOffset(end.offset);
            endLine = pos.line;
            endColumn = pos.col;
          } else {
            endLine = end.line;
            endColumn = end.column;
          }
        } else if (!column) {
          let pos = this.fromOffset(line);
          line = pos.line;
          column = pos.col;
        }
        let origin = this.origin(line, column, endLine, endColumn);
        if (origin) {
          result = new CssSyntaxError(
            message,
            origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
            origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
            origin.source,
            origin.file,
            opts.plugin
          );
        } else {
          result = new CssSyntaxError(
            message,
            endLine === void 0 ? line : { column, line },
            endLine === void 0 ? column : { column: endColumn, line: endLine },
            this.css,
            this.file,
            opts.plugin
          );
        }
        result.input = { column, endColumn, endLine, line, source: this.css };
        if (this.file) {
          if (pathToFileURL) {
            result.input.url = pathToFileURL(this.file).toString();
          }
          result.input.file = this.file;
        }
        return result;
      }
      fromOffset(offset) {
        let lastLine, lineToIndex;
        if (!this[fromOffsetCache]) {
          let lines = this.css.split("\n");
          lineToIndex = new Array(lines.length);
          let prevIndex = 0;
          for (let i = 0, l = lines.length; i < l; i++) {
            lineToIndex[i] = prevIndex;
            prevIndex += lines[i].length + 1;
          }
          this[fromOffsetCache] = lineToIndex;
        } else {
          lineToIndex = this[fromOffsetCache];
        }
        lastLine = lineToIndex[lineToIndex.length - 1];
        let min = 0;
        if (offset >= lastLine) {
          min = lineToIndex.length - 1;
        } else {
          let max2 = lineToIndex.length - 2;
          let mid;
          while (min < max2) {
            mid = min + (max2 - min >> 1);
            if (offset < lineToIndex[mid]) {
              max2 = mid - 1;
            } else if (offset >= lineToIndex[mid + 1]) {
              min = mid + 1;
            } else {
              min = mid;
              break;
            }
          }
        }
        return {
          col: offset - lineToIndex[min] + 1,
          line: min + 1
        };
      }
      mapResolve(file) {
        if (/^\w+:\/\//.test(file)) {
          return file;
        }
        return resolve(this.map.consumer().sourceRoot || this.map.root || ".", file);
      }
      origin(line, column, endLine, endColumn) {
        if (!this.map)
          return false;
        let consumer = this.map.consumer();
        let from2 = consumer.originalPositionFor({ column, line });
        if (!from2.source)
          return false;
        let to;
        if (typeof endLine === "number") {
          to = consumer.originalPositionFor({ column: endColumn, line: endLine });
        }
        let fromUrl;
        if (isAbsolute(from2.source)) {
          fromUrl = pathToFileURL(from2.source);
        } else {
          fromUrl = new URL(
            from2.source,
            this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
          );
        }
        let result = {
          column: from2.column,
          endColumn: to && to.column,
          endLine: to && to.line,
          line: from2.line,
          url: fromUrl.toString()
        };
        if (fromUrl.protocol === "file:") {
          if (fileURLToPath) {
            result.file = fileURLToPath(fromUrl);
          } else {
            throw new Error(`file: protocol is not available in this PostCSS build`);
          }
        }
        let source = consumer.sourceContentFor(from2.source);
        if (source)
          result.source = source;
        return result;
      }
      toJSON() {
        let json = {};
        for (let name2 of ["hasBOM", "css", "file", "id"]) {
          if (this[name2] != null) {
            json[name2] = this[name2];
          }
        }
        if (this.map) {
          json.map = { ...this.map };
          if (json.map.consumerCache) {
            json.map.consumerCache = void 0;
          }
        }
        return json;
      }
      get from() {
        return this.file || this.id;
      }
    };
    module2.exports = Input;
    Input.default = Input;
    if (terminalHighlight && terminalHighlight.registerInput) {
      terminalHighlight.registerInput(Input);
    }
  }
});

// ../../node_modules/postcss/lib/map-generator.js
var require_map_generator = __commonJS({
  "../../node_modules/postcss/lib/map-generator.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { dirname, relative, resolve, sep } = require_path4();
    var { pathToFileURL } = require_url4();
    var Input = require_input();
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(dirname && resolve && relative && sep);
    var MapGenerator = class {
      constructor(stringify, root, opts, cssString) {
        this.stringify = stringify;
        this.mapOpts = opts.map || {};
        this.root = root;
        this.opts = opts;
        this.css = cssString;
        this.originalCSS = cssString;
        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
        this.memoizedFileURLs = /* @__PURE__ */ new Map();
        this.memoizedPaths = /* @__PURE__ */ new Map();
        this.memoizedURLs = /* @__PURE__ */ new Map();
      }
      addAnnotation() {
        let content;
        if (this.isInline()) {
          content = "data:application/json;base64," + this.toBase64(this.map.toString());
        } else if (typeof this.mapOpts.annotation === "string") {
          content = this.mapOpts.annotation;
        } else if (typeof this.mapOpts.annotation === "function") {
          content = this.mapOpts.annotation(this.opts.to, this.root);
        } else {
          content = this.outputFile() + ".map";
        }
        let eol = "\n";
        if (this.css.includes("\r\n"))
          eol = "\r\n";
        this.css += eol + "/*# sourceMappingURL=" + content + " */";
      }
      applyPrevMaps() {
        for (let prev of this.previous()) {
          let from2 = this.toUrl(this.path(prev.file));
          let root = prev.root || dirname(prev.file);
          let map2;
          if (this.mapOpts.sourcesContent === false) {
            map2 = new SourceMapConsumer(prev.text);
            if (map2.sourcesContent) {
              map2.sourcesContent = null;
            }
          } else {
            map2 = prev.consumer();
          }
          this.map.applySourceMap(map2, from2, this.toUrl(this.path(root)));
        }
      }
      clearAnnotation() {
        if (this.mapOpts.annotation === false)
          return;
        if (this.root) {
          let node;
          for (let i = this.root.nodes.length - 1; i >= 0; i--) {
            node = this.root.nodes[i];
            if (node.type !== "comment")
              continue;
            if (node.text.indexOf("# sourceMappingURL=") === 0) {
              this.root.removeChild(i);
            }
          }
        } else if (this.css) {
          this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, "");
        }
      }
      generate() {
        this.clearAnnotation();
        if (pathAvailable && sourceMapAvailable && this.isMap()) {
          return this.generateMap();
        } else {
          let result = "";
          this.stringify(this.root, (i) => {
            result += i;
          });
          return [result];
        }
      }
      generateMap() {
        if (this.root) {
          this.generateString();
        } else if (this.previous().length === 1) {
          let prev = this.previous()[0].consumer();
          prev.file = this.outputFile();
          this.map = SourceMapGenerator.fromSourceMap(prev, {
            ignoreInvalidMapping: true
          });
        } else {
          this.map = new SourceMapGenerator({
            file: this.outputFile(),
            ignoreInvalidMapping: true
          });
          this.map.addMapping({
            generated: { column: 0, line: 1 },
            original: { column: 0, line: 1 },
            source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
          });
        }
        if (this.isSourcesContent())
          this.setSourcesContent();
        if (this.root && this.previous().length > 0)
          this.applyPrevMaps();
        if (this.isAnnotation())
          this.addAnnotation();
        if (this.isInline()) {
          return [this.css];
        } else {
          return [this.css, this.map];
        }
      }
      generateString() {
        this.css = "";
        this.map = new SourceMapGenerator({
          file: this.outputFile(),
          ignoreInvalidMapping: true
        });
        let line = 1;
        let column = 1;
        let noSource = "<no source>";
        let mapping = {
          generated: { column: 0, line: 0 },
          original: { column: 0, line: 0 },
          source: ""
        };
        let lines, last;
        this.stringify(this.root, (str, node, type) => {
          this.css += str;
          if (node && type !== "end") {
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            if (node.source && node.source.start) {
              mapping.source = this.sourcePath(node);
              mapping.original.line = node.source.start.line;
              mapping.original.column = node.source.start.column - 1;
              this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              this.map.addMapping(mapping);
            }
          }
          lines = str.match(/\n/g);
          if (lines) {
            line += lines.length;
            last = str.lastIndexOf("\n");
            column = str.length - last;
          } else {
            column += str.length;
          }
          if (node && type !== "start") {
            let p = node.parent || { raws: {} };
            let childless = node.type === "decl" || node.type === "atrule" && !node.nodes;
            if (!childless || node !== p.last || p.raws.semicolon) {
              if (node.source && node.source.end) {
                mapping.source = this.sourcePath(node);
                mapping.original.line = node.source.end.line;
                mapping.original.column = node.source.end.column - 1;
                mapping.generated.line = line;
                mapping.generated.column = column - 2;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                mapping.generated.line = line;
                mapping.generated.column = column - 1;
                this.map.addMapping(mapping);
              }
            }
          }
        });
      }
      isAnnotation() {
        if (this.isInline()) {
          return true;
        }
        if (typeof this.mapOpts.annotation !== "undefined") {
          return this.mapOpts.annotation;
        }
        if (this.previous().length) {
          return this.previous().some((i) => i.annotation);
        }
        return true;
      }
      isInline() {
        if (typeof this.mapOpts.inline !== "undefined") {
          return this.mapOpts.inline;
        }
        let annotation = this.mapOpts.annotation;
        if (typeof annotation !== "undefined" && annotation !== true) {
          return false;
        }
        if (this.previous().length) {
          return this.previous().some((i) => i.inline);
        }
        return true;
      }
      isMap() {
        if (typeof this.opts.map !== "undefined") {
          return !!this.opts.map;
        }
        return this.previous().length > 0;
      }
      isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== "undefined") {
          return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
          return this.previous().some((i) => i.withContent());
        }
        return true;
      }
      outputFile() {
        if (this.opts.to) {
          return this.path(this.opts.to);
        } else if (this.opts.from) {
          return this.path(this.opts.from);
        } else {
          return "to.css";
        }
      }
      path(file) {
        if (this.mapOpts.absolute)
          return file;
        if (file.charCodeAt(0) === 60)
          return file;
        if (/^\w+:\/\//.test(file))
          return file;
        let cached = this.memoizedPaths.get(file);
        if (cached)
          return cached;
        let from2 = this.opts.to ? dirname(this.opts.to) : ".";
        if (typeof this.mapOpts.annotation === "string") {
          from2 = dirname(resolve(from2, this.mapOpts.annotation));
        }
        let path2 = relative(from2, file);
        this.memoizedPaths.set(file, path2);
        return path2;
      }
      previous() {
        if (!this.previousMaps) {
          this.previousMaps = [];
          if (this.root) {
            this.root.walk((node) => {
              if (node.source && node.source.input.map) {
                let map2 = node.source.input.map;
                if (!this.previousMaps.includes(map2)) {
                  this.previousMaps.push(map2);
                }
              }
            });
          } else {
            let input = new Input(this.originalCSS, this.opts);
            if (input.map)
              this.previousMaps.push(input.map);
          }
        }
        return this.previousMaps;
      }
      setSourcesContent() {
        let already = {};
        if (this.root) {
          this.root.walk((node) => {
            if (node.source) {
              let from2 = node.source.input.from;
              if (from2 && !already[from2]) {
                already[from2] = true;
                let fromUrl = this.usesFileUrls ? this.toFileUrl(from2) : this.toUrl(this.path(from2));
                this.map.setSourceContent(fromUrl, node.source.input.css);
              }
            }
          });
        } else if (this.css) {
          let from2 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
          this.map.setSourceContent(from2, this.css);
        }
      }
      sourcePath(node) {
        if (this.mapOpts.from) {
          return this.toUrl(this.mapOpts.from);
        } else if (this.usesFileUrls) {
          return this.toFileUrl(node.source.input.from);
        } else {
          return this.toUrl(this.path(node.source.input.from));
        }
      }
      toBase64(str) {
        if (Buffer) {
          return Buffer.from(str).toString("base64");
        } else {
          return window.btoa(unescape(encodeURIComponent(str)));
        }
      }
      toFileUrl(path2) {
        let cached = this.memoizedFileURLs.get(path2);
        if (cached)
          return cached;
        if (pathToFileURL) {
          let fileURL = pathToFileURL(path2).toString();
          this.memoizedFileURLs.set(path2, fileURL);
          return fileURL;
        } else {
          throw new Error(
            "`map.absolute` option is not available in this PostCSS build"
          );
        }
      }
      toUrl(path2) {
        let cached = this.memoizedURLs.get(path2);
        if (cached)
          return cached;
        if (sep === "\\") {
          path2 = path2.replace(/\\/g, "/");
        }
        let url = encodeURI(path2).replace(/[#?]/g, encodeURIComponent);
        this.memoizedURLs.set(path2, url);
        return url;
      }
    };
    module2.exports = MapGenerator;
  }
});

// ../../node_modules/postcss/lib/comment.js
var require_comment = __commonJS({
  "../../node_modules/postcss/lib/comment.js"(exports2, module2) {
    "use strict";
    var Node2 = require_node2();
    var Comment = class extends Node2 {
      constructor(defaults) {
        super(defaults);
        this.type = "comment";
      }
    };
    module2.exports = Comment;
    Comment.default = Comment;
  }
});

// ../../node_modules/postcss/lib/container.js
var require_container = __commonJS({
  "../../node_modules/postcss/lib/container.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var Declaration = require_declaration();
    var Comment = require_comment();
    var Node2 = require_node2();
    var parse;
    var Rule2;
    var AtRule;
    var Root;
    function cleanSource(nodes) {
      return nodes.map((i) => {
        if (i.nodes)
          i.nodes = cleanSource(i.nodes);
        delete i.source;
        return i;
      });
    }
    function markDirtyUp(node) {
      node[isClean] = false;
      if (node.proxyOf.nodes) {
        for (let i of node.proxyOf.nodes) {
          markDirtyUp(i);
        }
      }
    }
    var Container2 = class extends Node2 {
      append(...children2) {
        for (let child of children2) {
          let nodes = this.normalize(child, this.last);
          for (let node of nodes)
            this.proxyOf.nodes.push(node);
        }
        this.markDirty();
        return this;
      }
      cleanRaws(keepBetween) {
        super.cleanRaws(keepBetween);
        if (this.nodes) {
          for (let node of this.nodes)
            node.cleanRaws(keepBetween);
        }
      }
      each(callback) {
        if (!this.proxyOf.nodes)
          return void 0;
        let iterator = this.getIterator();
        let index, result;
        while (this.indexes[iterator] < this.proxyOf.nodes.length) {
          index = this.indexes[iterator];
          result = callback(this.proxyOf.nodes[index], index);
          if (result === false)
            break;
          this.indexes[iterator] += 1;
        }
        delete this.indexes[iterator];
        return result;
      }
      every(condition) {
        return this.nodes.every(condition);
      }
      getIterator() {
        if (!this.lastEach)
          this.lastEach = 0;
        if (!this.indexes)
          this.indexes = {};
        this.lastEach += 1;
        let iterator = this.lastEach;
        this.indexes[iterator] = 0;
        return iterator;
      }
      getProxyProcessor() {
        return {
          get(node, prop) {
            if (prop === "proxyOf") {
              return node;
            } else if (!node[prop]) {
              return node[prop];
            } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
              return (...args) => {
                return node[prop](
                  ...args.map((i) => {
                    if (typeof i === "function") {
                      return (child, index) => i(child.toProxy(), index);
                    } else {
                      return i;
                    }
                  })
                );
              };
            } else if (prop === "every" || prop === "some") {
              return (cb) => {
                return node[prop](
                  (child, ...other) => cb(child.toProxy(), ...other)
                );
              };
            } else if (prop === "root") {
              return () => node.root().toProxy();
            } else if (prop === "nodes") {
              return node.nodes.map((i) => i.toProxy());
            } else if (prop === "first" || prop === "last") {
              return node[prop].toProxy();
            } else {
              return node[prop];
            }
          },
          set(node, prop, value) {
            if (node[prop] === value)
              return true;
            node[prop] = value;
            if (prop === "name" || prop === "params" || prop === "selector") {
              node.markDirty();
            }
            return true;
          }
        };
      }
      index(child) {
        if (typeof child === "number")
          return child;
        if (child.proxyOf)
          child = child.proxyOf;
        return this.proxyOf.nodes.indexOf(child);
      }
      insertAfter(exist, add) {
        let existIndex = this.index(exist);
        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
        existIndex = this.index(exist);
        for (let node of nodes)
          this.proxyOf.nodes.splice(existIndex + 1, 0, node);
        let index;
        for (let id in this.indexes) {
          index = this.indexes[id];
          if (existIndex < index) {
            this.indexes[id] = index + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      insertBefore(exist, add) {
        let existIndex = this.index(exist);
        let type = existIndex === 0 ? "prepend" : false;
        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
        existIndex = this.index(exist);
        for (let node of nodes)
          this.proxyOf.nodes.splice(existIndex, 0, node);
        let index;
        for (let id in this.indexes) {
          index = this.indexes[id];
          if (existIndex <= index) {
            this.indexes[id] = index + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      normalize(nodes, sample) {
        if (typeof nodes === "string") {
          nodes = cleanSource(parse(nodes).nodes);
        } else if (typeof nodes === "undefined") {
          nodes = [];
        } else if (Array.isArray(nodes)) {
          nodes = nodes.slice(0);
          for (let i of nodes) {
            if (i.parent)
              i.parent.removeChild(i, "ignore");
          }
        } else if (nodes.type === "root" && this.type !== "document") {
          nodes = nodes.nodes.slice(0);
          for (let i of nodes) {
            if (i.parent)
              i.parent.removeChild(i, "ignore");
          }
        } else if (nodes.type) {
          nodes = [nodes];
        } else if (nodes.prop) {
          if (typeof nodes.value === "undefined") {
            throw new Error("Value field is missed in node creation");
          } else if (typeof nodes.value !== "string") {
            nodes.value = String(nodes.value);
          }
          nodes = [new Declaration(nodes)];
        } else if (nodes.selector) {
          nodes = [new Rule2(nodes)];
        } else if (nodes.name) {
          nodes = [new AtRule(nodes)];
        } else if (nodes.text) {
          nodes = [new Comment(nodes)];
        } else {
          throw new Error("Unknown node type in node creation");
        }
        let processed = nodes.map((i) => {
          if (!i[my])
            Container2.rebuild(i);
          i = i.proxyOf;
          if (i.parent)
            i.parent.removeChild(i);
          if (i[isClean])
            markDirtyUp(i);
          if (typeof i.raws.before === "undefined") {
            if (sample && typeof sample.raws.before !== "undefined") {
              i.raws.before = sample.raws.before.replace(/\S/g, "");
            }
          }
          i.parent = this.proxyOf;
          return i;
        });
        return processed;
      }
      prepend(...children2) {
        children2 = children2.reverse();
        for (let child of children2) {
          let nodes = this.normalize(child, this.first, "prepend").reverse();
          for (let node of nodes)
            this.proxyOf.nodes.unshift(node);
          for (let id in this.indexes) {
            this.indexes[id] = this.indexes[id] + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      push(child) {
        child.parent = this;
        this.proxyOf.nodes.push(child);
        return this;
      }
      removeAll() {
        for (let node of this.proxyOf.nodes)
          node.parent = void 0;
        this.proxyOf.nodes = [];
        this.markDirty();
        return this;
      }
      removeChild(child) {
        child = this.index(child);
        this.proxyOf.nodes[child].parent = void 0;
        this.proxyOf.nodes.splice(child, 1);
        let index;
        for (let id in this.indexes) {
          index = this.indexes[id];
          if (index >= child) {
            this.indexes[id] = index - 1;
          }
        }
        this.markDirty();
        return this;
      }
      replaceValues(pattern, opts, callback) {
        if (!callback) {
          callback = opts;
          opts = {};
        }
        this.walkDecls((decl) => {
          if (opts.props && !opts.props.includes(decl.prop))
            return;
          if (opts.fast && !decl.value.includes(opts.fast))
            return;
          decl.value = decl.value.replace(pattern, callback);
        });
        this.markDirty();
        return this;
      }
      some(condition) {
        return this.nodes.some(condition);
      }
      walk(callback) {
        return this.each((child, i) => {
          let result;
          try {
            result = callback(child, i);
          } catch (e) {
            throw child.addToError(e);
          }
          if (result !== false && child.walk) {
            result = child.walk(callback);
          }
          return result;
        });
      }
      walkAtRules(name2, callback) {
        if (!callback) {
          callback = name2;
          return this.walk((child, i) => {
            if (child.type === "atrule") {
              return callback(child, i);
            }
          });
        }
        if (name2 instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === "atrule" && name2.test(child.name)) {
              return callback(child, i);
            }
          });
        }
        return this.walk((child, i) => {
          if (child.type === "atrule" && child.name === name2) {
            return callback(child, i);
          }
        });
      }
      walkComments(callback) {
        return this.walk((child, i) => {
          if (child.type === "comment") {
            return callback(child, i);
          }
        });
      }
      walkDecls(prop, callback) {
        if (!callback) {
          callback = prop;
          return this.walk((child, i) => {
            if (child.type === "decl") {
              return callback(child, i);
            }
          });
        }
        if (prop instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === "decl" && prop.test(child.prop)) {
              return callback(child, i);
            }
          });
        }
        return this.walk((child, i) => {
          if (child.type === "decl" && child.prop === prop) {
            return callback(child, i);
          }
        });
      }
      walkRules(selector, callback) {
        if (!callback) {
          callback = selector;
          return this.walk((child, i) => {
            if (child.type === "rule") {
              return callback(child, i);
            }
          });
        }
        if (selector instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === "rule" && selector.test(child.selector)) {
              return callback(child, i);
            }
          });
        }
        return this.walk((child, i) => {
          if (child.type === "rule" && child.selector === selector) {
            return callback(child, i);
          }
        });
      }
      get first() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[0];
      }
      get last() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
    };
    Container2.registerParse = (dependant) => {
      parse = dependant;
    };
    Container2.registerRule = (dependant) => {
      Rule2 = dependant;
    };
    Container2.registerAtRule = (dependant) => {
      AtRule = dependant;
    };
    Container2.registerRoot = (dependant) => {
      Root = dependant;
    };
    module2.exports = Container2;
    Container2.default = Container2;
    Container2.rebuild = (node) => {
      if (node.type === "atrule") {
        Object.setPrototypeOf(node, AtRule.prototype);
      } else if (node.type === "rule") {
        Object.setPrototypeOf(node, Rule2.prototype);
      } else if (node.type === "decl") {
        Object.setPrototypeOf(node, Declaration.prototype);
      } else if (node.type === "comment") {
        Object.setPrototypeOf(node, Comment.prototype);
      } else if (node.type === "root") {
        Object.setPrototypeOf(node, Root.prototype);
      }
      node[my] = true;
      if (node.nodes) {
        node.nodes.forEach((child) => {
          Container2.rebuild(child);
        });
      }
    };
  }
});

// ../../node_modules/postcss/lib/document.js
var require_document = __commonJS({
  "../../node_modules/postcss/lib/document.js"(exports2, module2) {
    "use strict";
    var Container2 = require_container();
    var LazyResult;
    var Processor;
    var Document2 = class extends Container2 {
      constructor(defaults) {
        super({ type: "document", ...defaults });
        if (!this.nodes) {
          this.nodes = [];
        }
      }
      toResult(opts = {}) {
        let lazy2 = new LazyResult(new Processor(), this, opts);
        return lazy2.stringify();
      }
    };
    Document2.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Document2.registerProcessor = (dependant) => {
      Processor = dependant;
    };
    module2.exports = Document2;
    Document2.default = Document2;
  }
});

// ../../node_modules/postcss/lib/warn-once.js
var require_warn_once = __commonJS({
  "../../node_modules/postcss/lib/warn-once.js"(exports2, module2) {
    "use strict";
    var printed = {};
    module2.exports = function warnOnce(message) {
      if (printed[message])
        return;
      printed[message] = true;
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
    };
  }
});

// ../../node_modules/postcss/lib/warning.js
var require_warning = __commonJS({
  "../../node_modules/postcss/lib/warning.js"(exports2, module2) {
    "use strict";
    var Warning = class {
      constructor(text, opts = {}) {
        this.type = "warning";
        this.text = text;
        if (opts.node && opts.node.source) {
          let range2 = opts.node.rangeBy(opts);
          this.line = range2.start.line;
          this.column = range2.start.column;
          this.endLine = range2.end.line;
          this.endColumn = range2.end.column;
        }
        for (let opt in opts)
          this[opt] = opts[opt];
      }
      toString() {
        if (this.node) {
          return this.node.error(this.text, {
            index: this.index,
            plugin: this.plugin,
            word: this.word
          }).message;
        }
        if (this.plugin) {
          return this.plugin + ": " + this.text;
        }
        return this.text;
      }
    };
    module2.exports = Warning;
    Warning.default = Warning;
  }
});

// ../../node_modules/postcss/lib/result.js
var require_result = __commonJS({
  "../../node_modules/postcss/lib/result.js"(exports2, module2) {
    "use strict";
    var Warning = require_warning();
    var Result = class {
      constructor(processor, root, opts) {
        this.processor = processor;
        this.messages = [];
        this.root = root;
        this.opts = opts;
        this.css = void 0;
        this.map = void 0;
      }
      toString() {
        return this.css;
      }
      warn(text, opts = {}) {
        if (!opts.plugin) {
          if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
            opts.plugin = this.lastPlugin.postcssPlugin;
          }
        }
        let warning = new Warning(text, opts);
        this.messages.push(warning);
        return warning;
      }
      warnings() {
        return this.messages.filter((i) => i.type === "warning");
      }
      get content() {
        return this.css;
      }
    };
    module2.exports = Result;
    Result.default = Result;
  }
});

// ../../node_modules/postcss/lib/tokenize.js
var require_tokenize = __commonJS({
  "../../node_modules/postcss/lib/tokenize.js"(exports2, module2) {
    "use strict";
    var SINGLE_QUOTE = "'".charCodeAt(0);
    var DOUBLE_QUOTE = '"'.charCodeAt(0);
    var BACKSLASH = "\\".charCodeAt(0);
    var SLASH = "/".charCodeAt(0);
    var NEWLINE = "\n".charCodeAt(0);
    var SPACE = " ".charCodeAt(0);
    var FEED = "\f".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var CR = "\r".charCodeAt(0);
    var OPEN_SQUARE = "[".charCodeAt(0);
    var CLOSE_SQUARE = "]".charCodeAt(0);
    var OPEN_PARENTHESES = "(".charCodeAt(0);
    var CLOSE_PARENTHESES = ")".charCodeAt(0);
    var OPEN_CURLY = "{".charCodeAt(0);
    var CLOSE_CURLY = "}".charCodeAt(0);
    var SEMICOLON = ";".charCodeAt(0);
    var ASTERISK = "*".charCodeAt(0);
    var COLON = ":".charCodeAt(0);
    var AT = "@".charCodeAt(0);
    var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
    var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
    var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
    var RE_HEX_ESCAPE = /[\da-f]/i;
    module2.exports = function tokenizer(input, options = {}) {
      let css2 = input.css.valueOf();
      let ignore2 = options.ignoreErrors;
      let code, next, quote, content, escape2;
      let escaped, escapePos, prev, n, currentToken;
      let length = css2.length;
      let pos = 0;
      let buffer = [];
      let returned = [];
      function position() {
        return pos;
      }
      function unclosed(what) {
        throw input.error("Unclosed " + what, pos);
      }
      function endOfFile() {
        return returned.length === 0 && pos >= length;
      }
      function nextToken(opts) {
        if (returned.length)
          return returned.pop();
        if (pos >= length)
          return;
        let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
        code = css2.charCodeAt(pos);
        switch (code) {
          case NEWLINE:
          case SPACE:
          case TAB:
          case CR:
          case FEED: {
            next = pos;
            do {
              next += 1;
              code = css2.charCodeAt(next);
            } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
            currentToken = ["space", css2.slice(pos, next)];
            pos = next - 1;
            break;
          }
          case OPEN_SQUARE:
          case CLOSE_SQUARE:
          case OPEN_CURLY:
          case CLOSE_CURLY:
          case COLON:
          case SEMICOLON:
          case CLOSE_PARENTHESES: {
            let controlChar = String.fromCharCode(code);
            currentToken = [controlChar, controlChar, pos];
            break;
          }
          case OPEN_PARENTHESES: {
            prev = buffer.length ? buffer.pop()[1] : "";
            n = css2.charCodeAt(pos + 1);
            if (prev === "url" && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
              next = pos;
              do {
                escaped = false;
                next = css2.indexOf(")", next + 1);
                if (next === -1) {
                  if (ignore2 || ignoreUnclosed) {
                    next = pos;
                    break;
                  } else {
                    unclosed("bracket");
                  }
                }
                escapePos = next;
                while (css2.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["brackets", css2.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              next = css2.indexOf(")", pos + 1);
              content = css2.slice(pos, next + 1);
              if (next === -1 || RE_BAD_BRACKET.test(content)) {
                currentToken = ["(", "(", pos];
              } else {
                currentToken = ["brackets", content, pos, next];
                pos = next;
              }
            }
            break;
          }
          case SINGLE_QUOTE:
          case DOUBLE_QUOTE: {
            quote = code === SINGLE_QUOTE ? "'" : '"';
            next = pos;
            do {
              escaped = false;
              next = css2.indexOf(quote, next + 1);
              if (next === -1) {
                if (ignore2 || ignoreUnclosed) {
                  next = pos + 1;
                  break;
                } else {
                  unclosed("string");
                }
              }
              escapePos = next;
              while (css2.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            currentToken = ["string", css2.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case AT: {
            RE_AT_END.lastIndex = pos + 1;
            RE_AT_END.test(css2);
            if (RE_AT_END.lastIndex === 0) {
              next = css2.length - 1;
            } else {
              next = RE_AT_END.lastIndex - 2;
            }
            currentToken = ["at-word", css2.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case BACKSLASH: {
            next = pos;
            escape2 = true;
            while (css2.charCodeAt(next + 1) === BACKSLASH) {
              next += 1;
              escape2 = !escape2;
            }
            code = css2.charCodeAt(next + 1);
            if (escape2 && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
              next += 1;
              if (RE_HEX_ESCAPE.test(css2.charAt(next))) {
                while (RE_HEX_ESCAPE.test(css2.charAt(next + 1))) {
                  next += 1;
                }
                if (css2.charCodeAt(next + 1) === SPACE) {
                  next += 1;
                }
              }
            }
            currentToken = ["word", css2.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          default: {
            if (code === SLASH && css2.charCodeAt(pos + 1) === ASTERISK) {
              next = css2.indexOf("*/", pos + 2) + 1;
              if (next === 0) {
                if (ignore2 || ignoreUnclosed) {
                  next = css2.length;
                } else {
                  unclosed("comment");
                }
              }
              currentToken = ["comment", css2.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              RE_WORD_END.lastIndex = pos + 1;
              RE_WORD_END.test(css2);
              if (RE_WORD_END.lastIndex === 0) {
                next = css2.length - 1;
              } else {
                next = RE_WORD_END.lastIndex - 2;
              }
              currentToken = ["word", css2.slice(pos, next + 1), pos, next];
              buffer.push(currentToken);
              pos = next;
            }
            break;
          }
        }
        pos++;
        return currentToken;
      }
      function back(token) {
        returned.push(token);
      }
      return {
        back,
        endOfFile,
        nextToken,
        position
      };
    };
  }
});

// ../../node_modules/postcss/lib/at-rule.js
var require_at_rule = __commonJS({
  "../../node_modules/postcss/lib/at-rule.js"(exports2, module2) {
    "use strict";
    var Container2 = require_container();
    var AtRule = class extends Container2 {
      constructor(defaults) {
        super(defaults);
        this.type = "atrule";
      }
      append(...children2) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.append(...children2);
      }
      prepend(...children2) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.prepend(...children2);
      }
    };
    module2.exports = AtRule;
    AtRule.default = AtRule;
    Container2.registerAtRule(AtRule);
  }
});

// ../../node_modules/postcss/lib/root.js
var require_root2 = __commonJS({
  "../../node_modules/postcss/lib/root.js"(exports2, module2) {
    "use strict";
    var Container2 = require_container();
    var LazyResult;
    var Processor;
    var Root = class extends Container2 {
      constructor(defaults) {
        super(defaults);
        this.type = "root";
        if (!this.nodes)
          this.nodes = [];
      }
      normalize(child, sample, type) {
        let nodes = super.normalize(child);
        if (sample) {
          if (type === "prepend") {
            if (this.nodes.length > 1) {
              sample.raws.before = this.nodes[1].raws.before;
            } else {
              delete sample.raws.before;
            }
          } else if (this.first !== sample) {
            for (let node of nodes) {
              node.raws.before = sample.raws.before;
            }
          }
        }
        return nodes;
      }
      removeChild(child, ignore2) {
        let index = this.index(child);
        if (!ignore2 && index === 0 && this.nodes.length > 1) {
          this.nodes[1].raws.before = this.nodes[index].raws.before;
        }
        return super.removeChild(child);
      }
      toResult(opts = {}) {
        let lazy2 = new LazyResult(new Processor(), this, opts);
        return lazy2.stringify();
      }
    };
    Root.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Root.registerProcessor = (dependant) => {
      Processor = dependant;
    };
    module2.exports = Root;
    Root.default = Root;
    Container2.registerRoot(Root);
  }
});

// ../../node_modules/postcss/lib/list.js
var require_list = __commonJS({
  "../../node_modules/postcss/lib/list.js"(exports2, module2) {
    "use strict";
    var list = {
      comma(string) {
        return list.split(string, [","], true);
      },
      space(string) {
        let spaces = [" ", "\n", "	"];
        return list.split(string, spaces);
      },
      split(string, separators, last) {
        let array = [];
        let current = "";
        let split = false;
        let func = 0;
        let inQuote = false;
        let prevQuote = "";
        let escape2 = false;
        for (let letter of string) {
          if (escape2) {
            escape2 = false;
          } else if (letter === "\\") {
            escape2 = true;
          } else if (inQuote) {
            if (letter === prevQuote) {
              inQuote = false;
            }
          } else if (letter === '"' || letter === "'") {
            inQuote = true;
            prevQuote = letter;
          } else if (letter === "(") {
            func += 1;
          } else if (letter === ")") {
            if (func > 0)
              func -= 1;
          } else if (func === 0) {
            if (separators.includes(letter))
              split = true;
          }
          if (split) {
            if (current !== "")
              array.push(current.trim());
            current = "";
            split = false;
          } else {
            current += letter;
          }
        }
        if (last || current !== "")
          array.push(current.trim());
        return array;
      }
    };
    module2.exports = list;
    list.default = list;
  }
});

// ../../node_modules/postcss/lib/rule.js
var require_rule = __commonJS({
  "../../node_modules/postcss/lib/rule.js"(exports2, module2) {
    "use strict";
    var Container2 = require_container();
    var list = require_list();
    var Rule2 = class extends Container2 {
      constructor(defaults) {
        super(defaults);
        this.type = "rule";
        if (!this.nodes)
          this.nodes = [];
      }
      get selectors() {
        return list.comma(this.selector);
      }
      set selectors(values) {
        let match = this.selector ? this.selector.match(/,\s*/) : null;
        let sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
        this.selector = values.join(sep);
      }
    };
    module2.exports = Rule2;
    Rule2.default = Rule2;
    Container2.registerRule(Rule2);
  }
});

// ../../node_modules/postcss/lib/parser.js
var require_parser = __commonJS({
  "../../node_modules/postcss/lib/parser.js"(exports2, module2) {
    "use strict";
    var Declaration = require_declaration();
    var tokenizer = require_tokenize();
    var Comment = require_comment();
    var AtRule = require_at_rule();
    var Root = require_root2();
    var Rule2 = require_rule();
    var SAFE_COMMENT_NEIGHBOR = {
      empty: true,
      space: true
    };
    function findLastWithPosition(tokens) {
      for (let i = tokens.length - 1; i >= 0; i--) {
        let token = tokens[i];
        let pos = token[3] || token[2];
        if (pos)
          return pos;
      }
    }
    var Parser = class {
      constructor(input) {
        this.input = input;
        this.root = new Root();
        this.current = this.root;
        this.spaces = "";
        this.semicolon = false;
        this.createTokenizer();
        this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
      }
      atrule(token) {
        let node = new AtRule();
        node.name = token[1].slice(1);
        if (node.name === "") {
          this.unnamedAtrule(node, token);
        }
        this.init(node, token[2]);
        let type;
        let prev;
        let shift;
        let last = false;
        let open = false;
        let params = [];
        let brackets = [];
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          type = token[0];
          if (type === "(" || type === "[") {
            brackets.push(type === "(" ? ")" : "]");
          } else if (type === "{" && brackets.length > 0) {
            brackets.push("}");
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
          }
          if (brackets.length === 0) {
            if (type === ";") {
              node.source.end = this.getPosition(token[2]);
              node.source.end.offset++;
              this.semicolon = true;
              break;
            } else if (type === "{") {
              open = true;
              break;
            } else if (type === "}") {
              if (params.length > 0) {
                shift = params.length - 1;
                prev = params[shift];
                while (prev && prev[0] === "space") {
                  prev = params[--shift];
                }
                if (prev) {
                  node.source.end = this.getPosition(prev[3] || prev[2]);
                  node.source.end.offset++;
                }
              }
              this.end(token);
              break;
            } else {
              params.push(token);
            }
          } else {
            params.push(token);
          }
          if (this.tokenizer.endOfFile()) {
            last = true;
            break;
          }
        }
        node.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
          node.raws.afterName = this.spacesAndCommentsFromStart(params);
          this.raw(node, "params", params);
          if (last) {
            token = params[params.length - 1];
            node.source.end = this.getPosition(token[3] || token[2]);
            node.source.end.offset++;
            this.spaces = node.raws.between;
            node.raws.between = "";
          }
        } else {
          node.raws.afterName = "";
          node.params = "";
        }
        if (open) {
          node.nodes = [];
          this.current = node;
        }
      }
      checkMissedSemicolon(tokens) {
        let colon = this.colon(tokens);
        if (colon === false)
          return;
        let founded = 0;
        let token;
        for (let j = colon - 1; j >= 0; j--) {
          token = tokens[j];
          if (token[0] !== "space") {
            founded += 1;
            if (founded === 2)
              break;
          }
        }
        throw this.input.error(
          "Missed semicolon",
          token[0] === "word" ? token[3] + 1 : token[2]
        );
      }
      colon(tokens) {
        let brackets = 0;
        let token, type, prev;
        for (let [i, element] of tokens.entries()) {
          token = element;
          type = token[0];
          if (type === "(") {
            brackets += 1;
          }
          if (type === ")") {
            brackets -= 1;
          }
          if (brackets === 0 && type === ":") {
            if (!prev) {
              this.doubleColon(token);
            } else if (prev[0] === "word" && prev[1] === "progid") {
              continue;
            } else {
              return i;
            }
          }
          prev = token;
        }
        return false;
      }
      comment(token) {
        let node = new Comment();
        this.init(node, token[2]);
        node.source.end = this.getPosition(token[3] || token[2]);
        node.source.end.offset++;
        let text = token[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
          node.text = "";
          node.raws.left = text;
          node.raws.right = "";
        } else {
          let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
          node.text = match[2];
          node.raws.left = match[1];
          node.raws.right = match[3];
        }
      }
      createTokenizer() {
        this.tokenizer = tokenizer(this.input);
      }
      decl(tokens, customProperty) {
        let node = new Declaration();
        this.init(node, tokens[0][2]);
        let last = tokens[tokens.length - 1];
        if (last[0] === ";") {
          this.semicolon = true;
          tokens.pop();
        }
        node.source.end = this.getPosition(
          last[3] || last[2] || findLastWithPosition(tokens)
        );
        node.source.end.offset++;
        while (tokens[0][0] !== "word") {
          if (tokens.length === 1)
            this.unknownWord(tokens);
          node.raws.before += tokens.shift()[1];
        }
        node.source.start = this.getPosition(tokens[0][2]);
        node.prop = "";
        while (tokens.length) {
          let type = tokens[0][0];
          if (type === ":" || type === "space" || type === "comment") {
            break;
          }
          node.prop += tokens.shift()[1];
        }
        node.raws.between = "";
        let token;
        while (tokens.length) {
          token = tokens.shift();
          if (token[0] === ":") {
            node.raws.between += token[1];
            break;
          } else {
            if (token[0] === "word" && /\w/.test(token[1])) {
              this.unknownWord([token]);
            }
            node.raws.between += token[1];
          }
        }
        if (node.prop[0] === "_" || node.prop[0] === "*") {
          node.raws.before += node.prop[0];
          node.prop = node.prop.slice(1);
        }
        let firstSpaces = [];
        let next;
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          firstSpaces.push(tokens.shift());
        }
        this.precheckMissedSemicolon(tokens);
        for (let i = tokens.length - 1; i >= 0; i--) {
          token = tokens[i];
          if (token[1].toLowerCase() === "!important") {
            node.important = true;
            let string = this.stringFrom(tokens, i);
            string = this.spacesFromEnd(tokens) + string;
            if (string !== " !important")
              node.raws.important = string;
            break;
          } else if (token[1].toLowerCase() === "important") {
            let cache2 = tokens.slice(0);
            let str = "";
            for (let j = i; j > 0; j--) {
              let type = cache2[j][0];
              if (str.trim().indexOf("!") === 0 && type !== "space") {
                break;
              }
              str = cache2.pop()[1] + str;
            }
            if (str.trim().indexOf("!") === 0) {
              node.important = true;
              node.raws.important = str;
              tokens = cache2;
            }
          }
          if (token[0] !== "space" && token[0] !== "comment") {
            break;
          }
        }
        let hasWord = tokens.some((i) => i[0] !== "space" && i[0] !== "comment");
        if (hasWord) {
          node.raws.between += firstSpaces.map((i) => i[1]).join("");
          firstSpaces = [];
        }
        this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
        if (node.value.includes(":") && !customProperty) {
          this.checkMissedSemicolon(tokens);
        }
      }
      doubleColon(token) {
        throw this.input.error(
          "Double colon",
          { offset: token[2] },
          { offset: token[2] + token[1].length }
        );
      }
      emptyRule(token) {
        let node = new Rule2();
        this.init(node, token[2]);
        node.selector = "";
        node.raws.between = "";
        this.current = node;
      }
      end(token) {
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.spaces = "";
        if (this.current.parent) {
          this.current.source.end = this.getPosition(token[2]);
          this.current.source.end.offset++;
          this.current = this.current.parent;
        } else {
          this.unexpectedClose(token);
        }
      }
      endFile() {
        if (this.current.parent)
          this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.root.source.end = this.getPosition(this.tokenizer.position());
      }
      freeSemicolon(token) {
        this.spaces += token[1];
        if (this.current.nodes) {
          let prev = this.current.nodes[this.current.nodes.length - 1];
          if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
            prev.raws.ownSemicolon = this.spaces;
            this.spaces = "";
          }
        }
      }
      // Helpers
      getPosition(offset) {
        let pos = this.input.fromOffset(offset);
        return {
          column: pos.col,
          line: pos.line,
          offset
        };
      }
      init(node, offset) {
        this.current.push(node);
        node.source = {
          input: this.input,
          start: this.getPosition(offset)
        };
        node.raws.before = this.spaces;
        this.spaces = "";
        if (node.type !== "comment")
          this.semicolon = false;
      }
      other(start) {
        let end = false;
        let type = null;
        let colon = false;
        let bracket = null;
        let brackets = [];
        let customProperty = start[1].startsWith("--");
        let tokens = [];
        let token = start;
        while (token) {
          type = token[0];
          tokens.push(token);
          if (type === "(" || type === "[") {
            if (!bracket)
              bracket = token;
            brackets.push(type === "(" ? ")" : "]");
          } else if (customProperty && colon && type === "{") {
            if (!bracket)
              bracket = token;
            brackets.push("}");
          } else if (brackets.length === 0) {
            if (type === ";") {
              if (colon) {
                this.decl(tokens, customProperty);
                return;
              } else {
                break;
              }
            } else if (type === "{") {
              this.rule(tokens);
              return;
            } else if (type === "}") {
              this.tokenizer.back(tokens.pop());
              end = true;
              break;
            } else if (type === ":") {
              colon = true;
            }
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
            if (brackets.length === 0)
              bracket = null;
          }
          token = this.tokenizer.nextToken();
        }
        if (this.tokenizer.endOfFile())
          end = true;
        if (brackets.length > 0)
          this.unclosedBracket(bracket);
        if (end && colon) {
          if (!customProperty) {
            while (tokens.length) {
              token = tokens[tokens.length - 1][0];
              if (token !== "space" && token !== "comment")
                break;
              this.tokenizer.back(tokens.pop());
            }
          }
          this.decl(tokens, customProperty);
        } else {
          this.unknownWord(tokens);
        }
      }
      parse() {
        let token;
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          switch (token[0]) {
            case "space":
              this.spaces += token[1];
              break;
            case ";":
              this.freeSemicolon(token);
              break;
            case "}":
              this.end(token);
              break;
            case "comment":
              this.comment(token);
              break;
            case "at-word":
              this.atrule(token);
              break;
            case "{":
              this.emptyRule(token);
              break;
            default:
              this.other(token);
              break;
          }
        }
        this.endFile();
      }
      precheckMissedSemicolon() {
      }
      raw(node, prop, tokens, customProperty) {
        let token, type;
        let length = tokens.length;
        let value = "";
        let clean = true;
        let next, prev;
        for (let i = 0; i < length; i += 1) {
          token = tokens[i];
          type = token[0];
          if (type === "space" && i === length - 1 && !customProperty) {
            clean = false;
          } else if (type === "comment") {
            prev = tokens[i - 1] ? tokens[i - 1][0] : "empty";
            next = tokens[i + 1] ? tokens[i + 1][0] : "empty";
            if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
              if (value.slice(-1) === ",") {
                clean = false;
              } else {
                value += token[1];
              }
            } else {
              clean = false;
            }
          } else {
            value += token[1];
          }
        }
        if (!clean) {
          let raw = tokens.reduce((all2, i) => all2 + i[1], "");
          node.raws[prop] = { raw, value };
        }
        node[prop] = value;
      }
      rule(tokens) {
        tokens.pop();
        let node = new Rule2();
        this.init(node, tokens[0][2]);
        node.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node, "selector", tokens);
        this.current = node;
      }
      spacesAndCommentsFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space" && lastTokenType !== "comment")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      // Errors
      spacesAndCommentsFromStart(tokens) {
        let next;
        let spaces = "";
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          spaces += tokens.shift()[1];
        }
        return spaces;
      }
      spacesFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      stringFrom(tokens, from2) {
        let result = "";
        for (let i = from2; i < tokens.length; i++) {
          result += tokens[i][1];
        }
        tokens.splice(from2, tokens.length - from2);
        return result;
      }
      unclosedBlock() {
        let pos = this.current.source.start;
        throw this.input.error("Unclosed block", pos.line, pos.column);
      }
      unclosedBracket(bracket) {
        throw this.input.error(
          "Unclosed bracket",
          { offset: bracket[2] },
          { offset: bracket[2] + 1 }
        );
      }
      unexpectedClose(token) {
        throw this.input.error(
          "Unexpected }",
          { offset: token[2] },
          { offset: token[2] + 1 }
        );
      }
      unknownWord(tokens) {
        throw this.input.error(
          "Unknown word",
          { offset: tokens[0][2] },
          { offset: tokens[0][2] + tokens[0][1].length }
        );
      }
      unnamedAtrule(node, token) {
        throw this.input.error(
          "At-rule without name",
          { offset: token[2] },
          { offset: token[2] + token[1].length }
        );
      }
    };
    module2.exports = Parser;
  }
});

// ../../node_modules/postcss/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/postcss/lib/parse.js"(exports2, module2) {
    "use strict";
    var Container2 = require_container();
    var Parser = require_parser();
    var Input = require_input();
    function parse(css2, opts) {
      let input = new Input(css2, opts);
      let parser = new Parser(input);
      try {
        parser.parse();
      } catch (e) {
        if (true) {
          if (e.name === "CssSyntaxError" && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
              e.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
            } else if (/\.sass/i.test(opts.from)) {
              e.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
            } else if (/\.less$/i.test(opts.from)) {
              e.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
            }
          }
        }
        throw e;
      }
      return parser.root;
    }
    module2.exports = parse;
    parse.default = parse;
    Container2.registerParse(parse);
  }
});

// ../../node_modules/postcss/lib/lazy-result.js
var require_lazy_result = __commonJS({
  "../../node_modules/postcss/lib/lazy-result.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var MapGenerator = require_map_generator();
    var stringify = require_stringify2();
    var Container2 = require_container();
    var Document2 = require_document();
    var warnOnce = require_warn_once();
    var Result = require_result();
    var parse = require_parse();
    var Root = require_root2();
    var TYPE_TO_CLASS_NAME = {
      atrule: "AtRule",
      comment: "Comment",
      decl: "Declaration",
      document: "Document",
      root: "Root",
      rule: "Rule"
    };
    var PLUGIN_PROPS = {
      AtRule: true,
      AtRuleExit: true,
      Comment: true,
      CommentExit: true,
      Declaration: true,
      DeclarationExit: true,
      Document: true,
      DocumentExit: true,
      Once: true,
      OnceExit: true,
      postcssPlugin: true,
      prepare: true,
      Root: true,
      RootExit: true,
      Rule: true,
      RuleExit: true
    };
    var NOT_VISITORS = {
      Once: true,
      postcssPlugin: true,
      prepare: true
    };
    var CHILDREN = 0;
    function isPromise(obj) {
      return typeof obj === "object" && typeof obj.then === "function";
    }
    function getEvents(node) {
      let key2 = false;
      let type = TYPE_TO_CLASS_NAME[node.type];
      if (node.type === "decl") {
        key2 = node.prop.toLowerCase();
      } else if (node.type === "atrule") {
        key2 = node.name.toLowerCase();
      }
      if (key2 && node.append) {
        return [
          type,
          type + "-" + key2,
          CHILDREN,
          type + "Exit",
          type + "Exit-" + key2
        ];
      } else if (key2) {
        return [type, type + "-" + key2, type + "Exit", type + "Exit-" + key2];
      } else if (node.append) {
        return [type, CHILDREN, type + "Exit"];
      } else {
        return [type, type + "Exit"];
      }
    }
    function toStack(node) {
      let events;
      if (node.type === "document") {
        events = ["Document", CHILDREN, "DocumentExit"];
      } else if (node.type === "root") {
        events = ["Root", CHILDREN, "RootExit"];
      } else {
        events = getEvents(node);
      }
      return {
        eventIndex: 0,
        events,
        iterator: 0,
        node,
        visitorIndex: 0,
        visitors: []
      };
    }
    function cleanMarks(node) {
      node[isClean] = false;
      if (node.nodes)
        node.nodes.forEach((i) => cleanMarks(i));
      return node;
    }
    var postcss = {};
    var LazyResult = class {
      constructor(processor, css2, opts) {
        this.stringified = false;
        this.processed = false;
        let root;
        if (typeof css2 === "object" && css2 !== null && (css2.type === "root" || css2.type === "document")) {
          root = cleanMarks(css2);
        } else if (css2 instanceof LazyResult || css2 instanceof Result) {
          root = cleanMarks(css2.root);
          if (css2.map) {
            if (typeof opts.map === "undefined")
              opts.map = {};
            if (!opts.map.inline)
              opts.map.inline = false;
            opts.map.prev = css2.map;
          }
        } else {
          let parser = parse;
          if (opts.syntax)
            parser = opts.syntax.parse;
          if (opts.parser)
            parser = opts.parser;
          if (parser.parse)
            parser = parser.parse;
          try {
            root = parser(css2, opts);
          } catch (error) {
            this.processed = true;
            this.error = error;
          }
          if (root && !root[my]) {
            Container2.rebuild(root);
          }
        }
        this.result = new Result(processor, root, opts);
        this.helpers = { ...postcss, postcss, result: this.result };
        this.plugins = this.processor.plugins.map((plugin) => {
          if (typeof plugin === "object" && plugin.prepare) {
            return { ...plugin, ...plugin.prepare(this.result) };
          } else {
            return plugin;
          }
        });
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        if (this.processed)
          return Promise.resolve(this.result);
        if (!this.processing) {
          this.processing = this.runAsync();
        }
        return this.processing;
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      getAsyncError() {
        throw new Error("Use process(css).then(cb) to work with async plugins");
      }
      handleError(error, node) {
        let plugin = this.result.lastPlugin;
        try {
          if (node)
            node.addToError(error);
          this.error = error;
          if (error.name === "CssSyntaxError" && !error.plugin) {
            error.plugin = plugin.postcssPlugin;
            error.setMessage();
          } else if (plugin.postcssVersion) {
            if (true) {
              let pluginName = plugin.postcssPlugin;
              let pluginVer = plugin.postcssVersion;
              let runtimeVer = this.result.processor.version;
              let a = pluginVer.split(".");
              let b = runtimeVer.split(".");
              if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                console.error(
                  "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
                );
              }
            }
          }
        } catch (err) {
          if (console && console.error)
            console.error(err);
        }
        return error;
      }
      prepareVisitors() {
        this.listeners = {};
        let add = (plugin, type, cb) => {
          if (!this.listeners[type])
            this.listeners[type] = [];
          this.listeners[type].push([plugin, cb]);
        };
        for (let plugin of this.plugins) {
          if (typeof plugin === "object") {
            for (let event in plugin) {
              if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                throw new Error(
                  `Unknown event ${event} in ${plugin.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
                );
              }
              if (!NOT_VISITORS[event]) {
                if (typeof plugin[event] === "object") {
                  for (let filter in plugin[event]) {
                    if (filter === "*") {
                      add(plugin, event, plugin[event][filter]);
                    } else {
                      add(
                        plugin,
                        event + "-" + filter.toLowerCase(),
                        plugin[event][filter]
                      );
                    }
                  }
                } else if (typeof plugin[event] === "function") {
                  add(plugin, event, plugin[event]);
                }
              }
            }
          }
        }
        this.hasListener = Object.keys(this.listeners).length > 0;
      }
      async runAsync() {
        this.plugin = 0;
        for (let i = 0; i < this.plugins.length; i++) {
          let plugin = this.plugins[i];
          let promise = this.runOnRoot(plugin);
          if (isPromise(promise)) {
            try {
              await promise;
            } catch (error) {
              throw this.handleError(error);
            }
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root = this.result.root;
          while (!root[isClean]) {
            root[isClean] = true;
            let stack = [toStack(root)];
            while (stack.length > 0) {
              let promise = this.visitTick(stack);
              if (isPromise(promise)) {
                try {
                  await promise;
                } catch (e) {
                  let node = stack[stack.length - 1].node;
                  throw this.handleError(e, node);
                }
              }
            }
          }
          if (this.listeners.OnceExit) {
            for (let [plugin, visitor] of this.listeners.OnceExit) {
              this.result.lastPlugin = plugin;
              try {
                if (root.type === "document") {
                  let roots = root.nodes.map(
                    (subRoot) => visitor(subRoot, this.helpers)
                  );
                  await Promise.all(roots);
                } else {
                  await visitor(root, this.helpers);
                }
              } catch (e) {
                throw this.handleError(e);
              }
            }
          }
        }
        this.processed = true;
        return this.stringify();
      }
      runOnRoot(plugin) {
        this.result.lastPlugin = plugin;
        try {
          if (typeof plugin === "object" && plugin.Once) {
            if (this.result.root.type === "document") {
              let roots = this.result.root.nodes.map(
                (root) => plugin.Once(root, this.helpers)
              );
              if (isPromise(roots[0])) {
                return Promise.all(roots);
              }
              return roots;
            }
            return plugin.Once(this.result.root, this.helpers);
          } else if (typeof plugin === "function") {
            return plugin(this.result.root, this.result);
          }
        } catch (error) {
          throw this.handleError(error);
        }
      }
      stringify() {
        if (this.error)
          throw this.error;
        if (this.stringified)
          return this.result;
        this.stringified = true;
        this.sync();
        let opts = this.result.opts;
        let str = stringify;
        if (opts.syntax)
          str = opts.syntax.stringify;
        if (opts.stringifier)
          str = opts.stringifier;
        if (str.stringify)
          str = str.stringify;
        let map2 = new MapGenerator(str, this.result.root, this.result.opts);
        let data = map2.generate();
        this.result.css = data[0];
        this.result.map = data[1];
        return this.result;
      }
      sync() {
        if (this.error)
          throw this.error;
        if (this.processed)
          return this.result;
        this.processed = true;
        if (this.processing) {
          throw this.getAsyncError();
        }
        for (let plugin of this.plugins) {
          let promise = this.runOnRoot(plugin);
          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root = this.result.root;
          while (!root[isClean]) {
            root[isClean] = true;
            this.walkSync(root);
          }
          if (this.listeners.OnceExit) {
            if (root.type === "document") {
              for (let subRoot of root.nodes) {
                this.visitSync(this.listeners.OnceExit, subRoot);
              }
            } else {
              this.visitSync(this.listeners.OnceExit, root);
            }
          }
        }
        return this.result;
      }
      then(onFulfilled, onRejected) {
        if (true) {
          if (!("from" in this.opts)) {
            warnOnce(
              "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
            );
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      toString() {
        return this.css;
      }
      visitSync(visitors, node) {
        for (let [plugin, visitor] of visitors) {
          this.result.lastPlugin = plugin;
          let promise;
          try {
            promise = visitor(node, this.helpers);
          } catch (e) {
            throw this.handleError(e, node.proxyOf);
          }
          if (node.type !== "root" && node.type !== "document" && !node.parent) {
            return true;
          }
          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
      }
      visitTick(stack) {
        let visit = stack[stack.length - 1];
        let { node, visitors } = visit;
        if (node.type !== "root" && node.type !== "document" && !node.parent) {
          stack.pop();
          return;
        }
        if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
          let [plugin, visitor] = visitors[visit.visitorIndex];
          visit.visitorIndex += 1;
          if (visit.visitorIndex === visitors.length) {
            visit.visitors = [];
            visit.visitorIndex = 0;
          }
          this.result.lastPlugin = plugin;
          try {
            return visitor(node.toProxy(), this.helpers);
          } catch (e) {
            throw this.handleError(e, node);
          }
        }
        if (visit.iterator !== 0) {
          let iterator = visit.iterator;
          let child;
          while (child = node.nodes[node.indexes[iterator]]) {
            node.indexes[iterator] += 1;
            if (!child[isClean]) {
              child[isClean] = true;
              stack.push(toStack(child));
              return;
            }
          }
          visit.iterator = 0;
          delete node.indexes[iterator];
        }
        let events = visit.events;
        while (visit.eventIndex < events.length) {
          let event = events[visit.eventIndex];
          visit.eventIndex += 1;
          if (event === CHILDREN) {
            if (node.nodes && node.nodes.length) {
              node[isClean] = true;
              visit.iterator = node.getIterator();
            }
            return;
          } else if (this.listeners[event]) {
            visit.visitors = this.listeners[event];
            return;
          }
        }
        stack.pop();
      }
      walkSync(node) {
        node[isClean] = true;
        let events = getEvents(node);
        for (let event of events) {
          if (event === CHILDREN) {
            if (node.nodes) {
              node.each((child) => {
                if (!child[isClean])
                  this.walkSync(child);
              });
            }
          } else {
            let visitors = this.listeners[event];
            if (visitors) {
              if (this.visitSync(visitors, node.toProxy()))
                return;
            }
          }
        }
      }
      warnings() {
        return this.sync().warnings();
      }
      get content() {
        return this.stringify().content;
      }
      get css() {
        return this.stringify().css;
      }
      get map() {
        return this.stringify().map;
      }
      get messages() {
        return this.sync().messages;
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        return this.sync().root;
      }
      get [Symbol.toStringTag]() {
        return "LazyResult";
      }
    };
    LazyResult.registerPostcss = (dependant) => {
      postcss = dependant;
    };
    module2.exports = LazyResult;
    LazyResult.default = LazyResult;
    Root.registerLazyResult(LazyResult);
    Document2.registerLazyResult(LazyResult);
  }
});

// ../../node_modules/postcss/lib/no-work-result.js
var require_no_work_result = __commonJS({
  "../../node_modules/postcss/lib/no-work-result.js"(exports2, module2) {
    "use strict";
    var MapGenerator = require_map_generator();
    var stringify = require_stringify2();
    var warnOnce = require_warn_once();
    var parse = require_parse();
    var Result = require_result();
    var NoWorkResult = class {
      constructor(processor, css2, opts) {
        css2 = css2.toString();
        this.stringified = false;
        this._processor = processor;
        this._css = css2;
        this._opts = opts;
        this._map = void 0;
        let root;
        let str = stringify;
        this.result = new Result(this._processor, root, this._opts);
        this.result.css = css2;
        let self2 = this;
        Object.defineProperty(this.result, "root", {
          get() {
            return self2.root;
          }
        });
        let map2 = new MapGenerator(str, root, this._opts, css2);
        if (map2.isMap()) {
          let [generatedCSS, generatedMap] = map2.generate();
          if (generatedCSS) {
            this.result.css = generatedCSS;
          }
          if (generatedMap) {
            this.result.map = generatedMap;
          }
        } else {
          map2.clearAnnotation();
          this.result.css = map2.css;
        }
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        return Promise.resolve(this.result);
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      sync() {
        if (this.error)
          throw this.error;
        return this.result;
      }
      then(onFulfilled, onRejected) {
        if (true) {
          if (!("from" in this._opts)) {
            warnOnce(
              "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
            );
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      toString() {
        return this._css;
      }
      warnings() {
        return [];
      }
      get content() {
        return this.result.css;
      }
      get css() {
        return this.result.css;
      }
      get map() {
        return this.result.map;
      }
      get messages() {
        return [];
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        if (this._root) {
          return this._root;
        }
        let root;
        let parser = parse;
        try {
          root = parser(this._css, this._opts);
        } catch (error) {
          this.error = error;
        }
        if (this.error) {
          throw this.error;
        } else {
          this._root = root;
          return root;
        }
      }
      get [Symbol.toStringTag]() {
        return "NoWorkResult";
      }
    };
    module2.exports = NoWorkResult;
    NoWorkResult.default = NoWorkResult;
  }
});

// ../../node_modules/postcss/lib/processor.js
var require_processor = __commonJS({
  "../../node_modules/postcss/lib/processor.js"(exports2, module2) {
    "use strict";
    var NoWorkResult = require_no_work_result();
    var LazyResult = require_lazy_result();
    var Document2 = require_document();
    var Root = require_root2();
    var Processor = class {
      constructor(plugins = []) {
        this.version = "8.4.38";
        this.plugins = this.normalize(plugins);
      }
      normalize(plugins) {
        let normalized = [];
        for (let i of plugins) {
          if (i.postcss === true) {
            i = i();
          } else if (i.postcss) {
            i = i.postcss;
          }
          if (typeof i === "object" && Array.isArray(i.plugins)) {
            normalized = normalized.concat(i.plugins);
          } else if (typeof i === "object" && i.postcssPlugin) {
            normalized.push(i);
          } else if (typeof i === "function") {
            normalized.push(i);
          } else if (typeof i === "object" && (i.parse || i.stringify)) {
            if (true) {
              throw new Error(
                "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
              );
            }
          } else {
            throw new Error(i + " is not a PostCSS plugin");
          }
        }
        return normalized;
      }
      process(css2, opts = {}) {
        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
          return new NoWorkResult(this, css2, opts);
        } else {
          return new LazyResult(this, css2, opts);
        }
      }
      use(plugin) {
        this.plugins = this.plugins.concat(this.normalize([plugin]));
        return this;
      }
    };
    module2.exports = Processor;
    Processor.default = Processor;
    Root.registerProcessor(Processor);
    Document2.registerProcessor(Processor);
  }
});

// ../../node_modules/postcss/lib/fromJSON.js
var require_fromJSON = __commonJS({
  "../../node_modules/postcss/lib/fromJSON.js"(exports2, module2) {
    "use strict";
    var Declaration = require_declaration();
    var PreviousMap = require_previous_map();
    var Comment = require_comment();
    var AtRule = require_at_rule();
    var Input = require_input();
    var Root = require_root2();
    var Rule2 = require_rule();
    function fromJSON(json, inputs) {
      if (Array.isArray(json))
        return json.map((n) => fromJSON(n));
      let { inputs: ownInputs, ...defaults } = json;
      if (ownInputs) {
        inputs = [];
        for (let input of ownInputs) {
          let inputHydrated = { ...input, __proto__: Input.prototype };
          if (inputHydrated.map) {
            inputHydrated.map = {
              ...inputHydrated.map,
              __proto__: PreviousMap.prototype
            };
          }
          inputs.push(inputHydrated);
        }
      }
      if (defaults.nodes) {
        defaults.nodes = json.nodes.map((n) => fromJSON(n, inputs));
      }
      if (defaults.source) {
        let { inputId, ...source } = defaults.source;
        defaults.source = source;
        if (inputId != null) {
          defaults.source.input = inputs[inputId];
        }
      }
      if (defaults.type === "root") {
        return new Root(defaults);
      } else if (defaults.type === "decl") {
        return new Declaration(defaults);
      } else if (defaults.type === "rule") {
        return new Rule2(defaults);
      } else if (defaults.type === "comment") {
        return new Comment(defaults);
      } else if (defaults.type === "atrule") {
        return new AtRule(defaults);
      } else {
        throw new Error("Unknown node type: " + json.type);
      }
    }
    module2.exports = fromJSON;
    fromJSON.default = fromJSON;
  }
});

// ../../node_modules/postcss/lib/postcss.js
var require_postcss = __commonJS({
  "../../node_modules/postcss/lib/postcss.js"(exports2, module2) {
    "use strict";
    var CssSyntaxError = require_css_syntax_error();
    var Declaration = require_declaration();
    var LazyResult = require_lazy_result();
    var Container2 = require_container();
    var Processor = require_processor();
    var stringify = require_stringify2();
    var fromJSON = require_fromJSON();
    var Document2 = require_document();
    var Warning = require_warning();
    var Comment = require_comment();
    var AtRule = require_at_rule();
    var Result = require_result();
    var Input = require_input();
    var parse = require_parse();
    var list = require_list();
    var Rule2 = require_rule();
    var Root = require_root2();
    var Node2 = require_node2();
    function postcss(...plugins) {
      if (plugins.length === 1 && Array.isArray(plugins[0])) {
        plugins = plugins[0];
      }
      return new Processor(plugins);
    }
    postcss.plugin = function plugin(name2, initializer) {
      let warningPrinted = false;
      function creator(...args) {
        if (console && console.warn && !warningPrinted) {
          warningPrinted = true;
          console.warn(
            name2 + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
          );
          if (process.env.LANG && process.env.LANG.startsWith("cn")) {
            console.warn(
              name2 + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226"
            );
          }
        }
        let transformer = initializer(...args);
        transformer.postcssPlugin = name2;
        transformer.postcssVersion = new Processor().version;
        return transformer;
      }
      let cache2;
      Object.defineProperty(creator, "postcss", {
        get() {
          if (!cache2)
            cache2 = creator();
          return cache2;
        }
      });
      creator.process = function(css2, processOpts, pluginOpts) {
        return postcss([creator(pluginOpts)]).process(css2, processOpts);
      };
      return creator;
    };
    postcss.stringify = stringify;
    postcss.parse = parse;
    postcss.fromJSON = fromJSON;
    postcss.list = list;
    postcss.comment = (defaults) => new Comment(defaults);
    postcss.atRule = (defaults) => new AtRule(defaults);
    postcss.decl = (defaults) => new Declaration(defaults);
    postcss.rule = (defaults) => new Rule2(defaults);
    postcss.root = (defaults) => new Root(defaults);
    postcss.document = (defaults) => new Document2(defaults);
    postcss.CssSyntaxError = CssSyntaxError;
    postcss.Declaration = Declaration;
    postcss.Container = Container2;
    postcss.Processor = Processor;
    postcss.Document = Document2;
    postcss.Comment = Comment;
    postcss.Warning = Warning;
    postcss.AtRule = AtRule;
    postcss.Result = Result;
    postcss.Input = Input;
    postcss.Rule = Rule2;
    postcss.Root = Root;
    postcss.Node = Node2;
    LazyResult.registerPostcss(postcss);
    module2.exports = postcss;
    postcss.default = postcss;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/sanitize-html/index.js
var require_sanitize_html = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/sanitize-html/index.js"(exports2, module2) {
    var htmlparser = require_lib21();
    var escapeStringRegexp = require_escape_string_regexp();
    var { isPlainObject: isPlainObject4 } = require_is_plain_object();
    var deepmerge = require_cjs();
    var parseSrcset = require_parse_srcset();
    var { parse: postcssParse } = require_postcss();
    var mediaTags = [
      "img",
      "audio",
      "video",
      "picture",
      "svg",
      "object",
      "map",
      "iframe",
      "embed"
    ];
    var vulnerableTags = ["script", "style"];
    function each(obj, cb) {
      if (obj) {
        Object.keys(obj).forEach(function(key2) {
          cb(obj[key2], key2);
        });
      }
    }
    function has5(obj, key2) {
      return {}.hasOwnProperty.call(obj, key2);
    }
    function filter(a, cb) {
      const n = [];
      each(a, function(v) {
        if (cb(v)) {
          n.push(v);
        }
      });
      return n;
    }
    function isEmptyObject(obj) {
      for (const key2 in obj) {
        if (has5(obj, key2)) {
          return false;
        }
      }
      return true;
    }
    function stringifySrcset(parsedSrcset) {
      return parsedSrcset.map(function(part) {
        if (!part.url) {
          throw new Error("URL missing");
        }
        return part.url + (part.w ? ` ${part.w}w` : "") + (part.h ? ` ${part.h}h` : "") + (part.d ? ` ${part.d}x` : "");
      }).join(", ");
    }
    module2.exports = sanitizeHtml;
    var VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;
    function sanitizeHtml(html2, options, _recursing) {
      if (html2 == null) {
        return "";
      }
      let result = "";
      let tempResult = "";
      function Frame(tag, attribs) {
        const that = this;
        this.tag = tag;
        this.attribs = attribs || {};
        this.tagPosition = result.length;
        this.text = "";
        this.mediaChildren = [];
        this.updateParentNodeText = function() {
          if (stack.length) {
            const parentFrame = stack[stack.length - 1];
            parentFrame.text += that.text;
          }
        };
        this.updateParentNodeMediaChildren = function() {
          if (stack.length && mediaTags.includes(this.tag)) {
            const parentFrame = stack[stack.length - 1];
            parentFrame.mediaChildren.push(this.tag);
          }
        };
      }
      options = Object.assign({}, sanitizeHtml.defaults, options);
      options.parser = Object.assign({}, htmlParserDefaults, options.parser);
      vulnerableTags.forEach(function(tag) {
        if (options.allowedTags !== false && (options.allowedTags || []).indexOf(tag) > -1 && !options.allowVulnerableTags) {
          console.warn(`

\u26A0\uFE0F Your \`allowedTags\` option includes, \`${tag}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
        }
      });
      const nonTextTagsArray = options.nonTextTags || [
        "script",
        "style",
        "textarea",
        "option"
      ];
      let allowedAttributesMap;
      let allowedAttributesGlobMap;
      if (options.allowedAttributes) {
        allowedAttributesMap = {};
        allowedAttributesGlobMap = {};
        each(options.allowedAttributes, function(attributes, tag) {
          allowedAttributesMap[tag] = [];
          const globRegex = [];
          attributes.forEach(function(obj) {
            if (typeof obj === "string" && obj.indexOf("*") >= 0) {
              globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
            } else {
              allowedAttributesMap[tag].push(obj);
            }
          });
          if (globRegex.length) {
            allowedAttributesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
          }
        });
      }
      const allowedClassesMap = {};
      const allowedClassesGlobMap = {};
      const allowedClassesRegexMap = {};
      each(options.allowedClasses, function(classes2, tag) {
        if (allowedAttributesMap) {
          if (!has5(allowedAttributesMap, tag)) {
            allowedAttributesMap[tag] = [];
          }
          allowedAttributesMap[tag].push("class");
        }
        allowedClassesMap[tag] = [];
        allowedClassesRegexMap[tag] = [];
        const globRegex = [];
        classes2.forEach(function(obj) {
          if (typeof obj === "string" && obj.indexOf("*") >= 0) {
            globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
          } else if (obj instanceof RegExp) {
            allowedClassesRegexMap[tag].push(obj);
          } else {
            allowedClassesMap[tag].push(obj);
          }
        });
        if (globRegex.length) {
          allowedClassesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
        }
      });
      const transformTagsMap = {};
      let transformTagsAll;
      each(options.transformTags, function(transform2, tag) {
        let transFun;
        if (typeof transform2 === "function") {
          transFun = transform2;
        } else if (typeof transform2 === "string") {
          transFun = sanitizeHtml.simpleTransform(transform2);
        }
        if (tag === "*") {
          transformTagsAll = transFun;
        } else {
          transformTagsMap[tag] = transFun;
        }
      });
      let depth;
      let stack;
      let skipMap;
      let transformMap;
      let skipText;
      let skipTextDepth;
      let addedText = false;
      initializeState();
      const parser = new htmlparser.Parser({
        onopentag: function(name2, attribs) {
          if (options.enforceHtmlBoundary && name2 === "html") {
            initializeState();
          }
          if (skipText) {
            skipTextDepth++;
            return;
          }
          const frame = new Frame(name2, attribs);
          stack.push(frame);
          let skip = false;
          const hasText = !!frame.text;
          let transformedTag;
          if (has5(transformTagsMap, name2)) {
            transformedTag = transformTagsMap[name2](name2, attribs);
            frame.attribs = attribs = transformedTag.attribs;
            if (transformedTag.text !== void 0) {
              frame.innerText = transformedTag.text;
            }
            if (name2 !== transformedTag.tagName) {
              frame.name = name2 = transformedTag.tagName;
              transformMap[depth] = transformedTag.tagName;
            }
          }
          if (transformTagsAll) {
            transformedTag = transformTagsAll(name2, attribs);
            frame.attribs = attribs = transformedTag.attribs;
            if (name2 !== transformedTag.tagName) {
              frame.name = name2 = transformedTag.tagName;
              transformMap[depth] = transformedTag.tagName;
            }
          }
          if (options.allowedTags !== false && (options.allowedTags || []).indexOf(name2) === -1 || options.disallowedTagsMode === "recursiveEscape" && !isEmptyObject(skipMap) || options.nestingLimit != null && depth >= options.nestingLimit) {
            skip = true;
            skipMap[depth] = true;
            if (options.disallowedTagsMode === "discard") {
              if (nonTextTagsArray.indexOf(name2) !== -1) {
                skipText = true;
                skipTextDepth = 1;
              }
            }
            skipMap[depth] = true;
          }
          depth++;
          if (skip) {
            if (options.disallowedTagsMode === "discard") {
              return;
            }
            tempResult = result;
            result = "";
          }
          result += "<" + name2;
          if (name2 === "script") {
            if (options.allowedScriptHostnames || options.allowedScriptDomains) {
              frame.innerText = "";
            }
          }
          if (!allowedAttributesMap || has5(allowedAttributesMap, name2) || allowedAttributesMap["*"]) {
            each(attribs, function(value, a) {
              if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {
                delete frame.attribs[a];
                return;
              }
              let passedAllowedAttributesMapCheck = false;
              if (!allowedAttributesMap || has5(allowedAttributesMap, name2) && allowedAttributesMap[name2].indexOf(a) !== -1 || allowedAttributesMap["*"] && allowedAttributesMap["*"].indexOf(a) !== -1 || has5(allowedAttributesGlobMap, name2) && allowedAttributesGlobMap[name2].test(a) || allowedAttributesGlobMap["*"] && allowedAttributesGlobMap["*"].test(a)) {
                passedAllowedAttributesMapCheck = true;
              } else if (allowedAttributesMap && allowedAttributesMap[name2]) {
                for (const o of allowedAttributesMap[name2]) {
                  if (isPlainObject4(o) && o.name && o.name === a) {
                    passedAllowedAttributesMapCheck = true;
                    let newValue = "";
                    if (o.multiple === true) {
                      const splitStrArray = value.split(" ");
                      for (const s of splitStrArray) {
                        if (o.values.indexOf(s) !== -1) {
                          if (newValue === "") {
                            newValue = s;
                          } else {
                            newValue += " " + s;
                          }
                        }
                      }
                    } else if (o.values.indexOf(value) >= 0) {
                      newValue = value;
                    }
                    value = newValue;
                  }
                }
              }
              if (passedAllowedAttributesMapCheck) {
                if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {
                  if (naughtyHref(name2, value)) {
                    delete frame.attribs[a];
                    return;
                  }
                }
                if (name2 === "script" && a === "src") {
                  let allowed = true;
                  try {
                    const parsed = parseUrl(value);
                    if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                      const allowedHostname = (options.allowedScriptHostnames || []).find(function(hostname) {
                        return hostname === parsed.url.hostname;
                      });
                      const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {
                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                      });
                      allowed = allowedHostname || allowedDomain;
                    }
                  } catch (e) {
                    allowed = false;
                  }
                  if (!allowed) {
                    delete frame.attribs[a];
                    return;
                  }
                }
                if (name2 === "iframe" && a === "src") {
                  let allowed = true;
                  try {
                    const parsed = parseUrl(value);
                    if (parsed.isRelativeUrl) {
                      allowed = has5(options, "allowIframeRelativeUrls") ? options.allowIframeRelativeUrls : !options.allowedIframeHostnames && !options.allowedIframeDomains;
                    } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {
                      const allowedHostname = (options.allowedIframeHostnames || []).find(function(hostname) {
                        return hostname === parsed.url.hostname;
                      });
                      const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {
                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                      });
                      allowed = allowedHostname || allowedDomain;
                    }
                  } catch (e) {
                    allowed = false;
                  }
                  if (!allowed) {
                    delete frame.attribs[a];
                    return;
                  }
                }
                if (a === "srcset") {
                  try {
                    let parsed = parseSrcset(value);
                    parsed.forEach(function(value2) {
                      if (naughtyHref("srcset", value2.url)) {
                        value2.evil = true;
                      }
                    });
                    parsed = filter(parsed, function(v) {
                      return !v.evil;
                    });
                    if (!parsed.length) {
                      delete frame.attribs[a];
                      return;
                    } else {
                      value = stringifySrcset(filter(parsed, function(v) {
                        return !v.evil;
                      }));
                      frame.attribs[a] = value;
                    }
                  } catch (e) {
                    delete frame.attribs[a];
                    return;
                  }
                }
                if (a === "class") {
                  const allowedSpecificClasses = allowedClassesMap[name2];
                  const allowedWildcardClasses = allowedClassesMap["*"];
                  const allowedSpecificClassesGlob = allowedClassesGlobMap[name2];
                  const allowedSpecificClassesRegex = allowedClassesRegexMap[name2];
                  const allowedWildcardClassesGlob = allowedClassesGlobMap["*"];
                  const allowedClassesGlobs = [
                    allowedSpecificClassesGlob,
                    allowedWildcardClassesGlob
                  ].concat(allowedSpecificClassesRegex).filter(function(t) {
                    return t;
                  });
                  if (allowedSpecificClasses && allowedWildcardClasses) {
                    value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);
                  } else {
                    value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);
                  }
                  if (!value.length) {
                    delete frame.attribs[a];
                    return;
                  }
                }
                if (a === "style") {
                  try {
                    const abstractSyntaxTree = postcssParse(name2 + " {" + value + "}");
                    const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);
                    value = stringifyStyleAttributes(filteredAST);
                    if (value.length === 0) {
                      delete frame.attribs[a];
                      return;
                    }
                  } catch (e) {
                    delete frame.attribs[a];
                    return;
                  }
                }
                result += " " + a;
                if (value && value.length) {
                  result += '="' + escapeHtml(value, true) + '"';
                }
              } else {
                delete frame.attribs[a];
              }
            });
          }
          if (options.selfClosing.indexOf(name2) !== -1) {
            result += " />";
          } else {
            result += ">";
            if (frame.innerText && !hasText && !options.textFilter) {
              result += escapeHtml(frame.innerText);
              addedText = true;
            }
          }
          if (skip) {
            result = tempResult + escapeHtml(result);
            tempResult = "";
          }
        },
        ontext: function(text) {
          if (skipText) {
            return;
          }
          const lastFrame = stack[stack.length - 1];
          let tag;
          if (lastFrame) {
            tag = lastFrame.tag;
            text = lastFrame.innerText !== void 0 ? lastFrame.innerText : text;
          }
          if (options.disallowedTagsMode === "discard" && (tag === "script" || tag === "style")) {
            result += text;
          } else {
            const escaped = escapeHtml(text, false);
            if (options.textFilter && !addedText) {
              result += options.textFilter(escaped, tag);
            } else if (!addedText) {
              result += escaped;
            }
          }
          if (stack.length) {
            const frame = stack[stack.length - 1];
            frame.text += text;
          }
        },
        onclosetag: function(name2) {
          if (skipText) {
            skipTextDepth--;
            if (!skipTextDepth) {
              skipText = false;
            } else {
              return;
            }
          }
          const frame = stack.pop();
          if (!frame) {
            return;
          }
          if (frame.tag !== name2) {
            stack.push(frame);
            return;
          }
          skipText = options.enforceHtmlBoundary ? name2 === "html" : false;
          depth--;
          const skip = skipMap[depth];
          if (skip) {
            delete skipMap[depth];
            if (options.disallowedTagsMode === "discard") {
              frame.updateParentNodeText();
              return;
            }
            tempResult = result;
            result = "";
          }
          if (transformMap[depth]) {
            name2 = transformMap[depth];
            delete transformMap[depth];
          }
          if (options.exclusiveFilter && options.exclusiveFilter(frame)) {
            result = result.substr(0, frame.tagPosition);
            return;
          }
          frame.updateParentNodeMediaChildren();
          frame.updateParentNodeText();
          if (options.selfClosing.indexOf(name2) !== -1) {
            if (skip) {
              result = tempResult;
              tempResult = "";
            }
            return;
          }
          result += "</" + name2 + ">";
          if (skip) {
            result = tempResult + escapeHtml(result);
            tempResult = "";
          }
          addedText = false;
        }
      }, options.parser);
      parser.write(html2);
      parser.end();
      return result;
      function initializeState() {
        result = "";
        depth = 0;
        stack = [];
        skipMap = {};
        transformMap = {};
        skipText = false;
        skipTextDepth = 0;
      }
      function escapeHtml(s, quote) {
        if (typeof s !== "string") {
          s = s + "";
        }
        if (options.parser.decodeEntities) {
          s = s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
          if (quote) {
            s = s.replace(/"/g, "&quot;");
          }
        }
        s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        if (quote) {
          s = s.replace(/"/g, "&quot;");
        }
        return s;
      }
      function naughtyHref(name2, href) {
        href = href.replace(/[\x00-\x20]+/g, "");
        while (true) {
          const firstIndex = href.indexOf("<!--");
          if (firstIndex === -1) {
            break;
          }
          const lastIndex = href.indexOf("-->", firstIndex + 4);
          if (lastIndex === -1) {
            break;
          }
          href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);
        }
        const matches2 = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
        if (!matches2) {
          if (href.match(/^[/\\]{2}/)) {
            return !options.allowProtocolRelative;
          }
          return false;
        }
        const scheme = matches2[1].toLowerCase();
        if (has5(options.allowedSchemesByTag, name2)) {
          return options.allowedSchemesByTag[name2].indexOf(scheme) === -1;
        }
        return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;
      }
      function parseUrl(value) {
        value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//");
        if (value.startsWith("relative:")) {
          throw new Error("relative: exploit attempt");
        }
        let base = "relative://relative-site";
        for (let i = 0; i < 100; i++) {
          base += `/${i}`;
        }
        const parsed = new URL(value, base);
        const isRelativeUrl = parsed && parsed.hostname === "relative-site" && parsed.protocol === "relative:";
        return {
          isRelativeUrl,
          url: parsed
        };
      }
      function filterCss(abstractSyntaxTree, allowedStyles) {
        if (!allowedStyles) {
          return abstractSyntaxTree;
        }
        const astRules = abstractSyntaxTree.nodes[0];
        let selectedRule;
        if (allowedStyles[astRules.selector] && allowedStyles["*"]) {
          selectedRule = deepmerge(
            allowedStyles[astRules.selector],
            allowedStyles["*"]
          );
        } else {
          selectedRule = allowedStyles[astRules.selector] || allowedStyles["*"];
        }
        if (selectedRule) {
          abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
        }
        return abstractSyntaxTree;
      }
      function stringifyStyleAttributes(filteredAST) {
        return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes, attrObject) {
          extractedAttributes.push(
            `${attrObject.prop}:${attrObject.value}${attrObject.important ? " !important" : ""}`
          );
          return extractedAttributes;
        }, []).join(";");
      }
      function filterDeclarations(selectedRule) {
        return function(allowedDeclarationsList, attributeObject) {
          if (has5(selectedRule, attributeObject.prop)) {
            const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
              return regularExpression.test(attributeObject.value);
            });
            if (matchesRegex) {
              allowedDeclarationsList.push(attributeObject);
            }
          }
          return allowedDeclarationsList;
        };
      }
      function filterClasses(classes2, allowed, allowedGlobs) {
        if (!allowed) {
          return classes2;
        }
        classes2 = classes2.split(/\s+/);
        return classes2.filter(function(clss) {
          return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {
            return glob.test(clss);
          });
        }).join(" ");
      }
    }
    var htmlParserDefaults = {
      decodeEntities: true
    };
    sanitizeHtml.defaults = {
      allowedTags: [
        // Sections derived from MDN element categories and limited to the more
        // benign categories.
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
        // Content sectioning
        "address",
        "article",
        "aside",
        "footer",
        "header",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hgroup",
        "main",
        "nav",
        "section",
        // Text content
        "blockquote",
        "dd",
        "div",
        "dl",
        "dt",
        "figcaption",
        "figure",
        "hr",
        "li",
        "main",
        "ol",
        "p",
        "pre",
        "ul",
        // Inline text semantics
        "a",
        "abbr",
        "b",
        "bdi",
        "bdo",
        "br",
        "cite",
        "code",
        "data",
        "dfn",
        "em",
        "i",
        "kbd",
        "mark",
        "q",
        "rb",
        "rp",
        "rt",
        "rtc",
        "ruby",
        "s",
        "samp",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "time",
        "u",
        "var",
        "wbr",
        // Table content
        "caption",
        "col",
        "colgroup",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "tr"
      ],
      disallowedTagsMode: "discard",
      allowedAttributes: {
        a: ["href", "name", "target"],
        // We don't currently allow img itself by default, but
        // these attributes would make sense if we did.
        img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
      },
      // Lots of these won't come up by default because we don't allow them
      selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
      // URL schemes we permit
      allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
      allowedSchemesByTag: {},
      allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
      allowProtocolRelative: true,
      enforceHtmlBoundary: false
    };
    sanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge2) {
      merge2 = merge2 === void 0 ? true : merge2;
      newAttribs = newAttribs || {};
      return function(tagName, attribs) {
        let attrib;
        if (merge2) {
          for (attrib in newAttribs) {
            attribs[attrib] = newAttribs[attrib];
          }
        } else {
          attribs = newAttribs;
        }
        return {
          tagName: newTagName,
          attribs
        };
      };
    };
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/sanitizer.js
var import_sanitize_html, CssProp, Sanitizer;
var init_sanitizer = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/sanitizer.js"() {
    import_sanitize_html = __toESM(require_sanitize_html());
    CssProp = class {
      static reg(r) {
        return new RegExp("^" + r + "$", "i");
      }
    };
    CssProp.N = {
      integer: `[+-]?[0-9]+`,
      integer_pos: `[+]?[0-9]+`,
      integer_zero_ff: `([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])`,
      number: `[+-]?([0-9]*[.])?[0-9]+(e-?[0-9]*)?`,
      number_pos: `[+]?([0-9]*[.])?[0-9]+(e-?[0-9]*)?`,
      number_zero_hundred: `[+]?(([0-9]|[1-9][0-9])([.][0-9]+)?|100)`,
      number_zero_one: `[+]?(1([.][0]+)?|0?([.][0-9]+)?)`
    };
    CssProp.B = {
      angle: `(${CssProp.N.number}(deg|rad|grad|turn)|0)`,
      frequency: `${CssProp.N.number}(Hz|kHz)`,
      ident: String.raw`-?([_a-z]|[\xA0-\xFF]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\xA0-\xFF]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*`,
      len_or_perc: `(0|${CssProp.N.number}(px|em|rem|ex|in|cm|mm|pt|pc|%))`,
      length: `(${CssProp.N.number}(px|em|rem|ex|in|cm|mm|pt|pc)|0)`,
      length_pos: `(${CssProp.N.number_pos}(px|em|rem|ex|in|cm|mm|pt|pc)|0)`,
      percentage: `${CssProp.N.number}%`,
      percentage_pos: `${CssProp.N.number_pos}%`,
      percentage_zero_hundred: `${CssProp.N.number_zero_hundred}%`,
      string: String.raw`(\"([^\n\r\f\\"]|\\\n|\r\n|\r|\f|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*\")|(\'([^\n\r\f\\']|\\\n|\r\n|\r|\f|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*\')`,
      time: `${CssProp.N.number}(s|ms)`,
      url: `url\\(.*?\\)`,
      z_index: `[+-]?[0-9]{1,7}`
    };
    CssProp.A = {
      absolute_size: `xx-small|x-small|small|medium|large|x-large|xx-large`,
      attachment: `scroll|fixed|local`,
      bg_origin: `border-box|padding-box|content-box`,
      border_style: `none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset`,
      box: `border-box|padding-box|content-box`,
      display_inside: `auto|block|table|flex|grid`,
      display_outside: `block-level|inline-level|none|table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption`,
      ending_shape: `circle|ellipse`,
      generic_family: `serif|sans-serif|cursive|fantasy|monospace`,
      generic_voice: `male|female|child`,
      relative_size: `smaller|larger`,
      repeat_style: `repeat-x|repeat-y|((?:repeat|space|round|no-repeat)(?:\\s*(?:repeat|space|round|no-repeat))?)`,
      side_or_corner: `(left|right)?\\s*(top|bottom)?`,
      single_animation_direction: `normal|reverse|alternate|alternate-reverse`,
      single_animation_fill_mode: `none|forwards|backwards|both`,
      single_animation_play_state: `running|paused`
    };
    CssProp._COLOR = {
      hex: `\\#(0x)?[0-9a-f]+`,
      name: `aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|transparent|violet|wheat|white|whitesmoke|yellow|yellowgreen`,
      rgb: String.raw`rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)`,
      rgba: String.raw`rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(${CssProp.N.integer_zero_ff}|${CssProp.N.number_zero_one}|${CssProp.B.percentage_zero_hundred})\s*\)`
    };
    CssProp._C = {
      alpha: `${CssProp.N.integer_zero_ff}|${CssProp.N.number_zero_one}|${CssProp.B.percentage_zero_hundred}`,
      alphavalue: CssProp.N.number_zero_one,
      bg_position: `((${CssProp.B.len_or_perc}|left|center|right|top|bottom)\\s*){1,4}`,
      bg_size: `(${CssProp.B.length_pos}|${CssProp.B.percentage}|auto){1,2}|cover|contain`,
      border_width: `thin|medium|thick|${CssProp.B.length}`,
      bottom: `${CssProp.B.length}|auto`,
      color: `${CssProp._COLOR.hex}|${CssProp._COLOR.rgb}|${CssProp._COLOR.rgba}|${CssProp._COLOR.name}`,
      color_stop_length: `(${CssProp.B.len_or_perc}\\s*){1,2}`,
      linear_color_hint: `${CssProp.B.len_or_perc}`,
      family_name: `${CssProp.B.string}|(${CssProp.B.ident}\\s*)+`,
      image_decl: CssProp.B.url,
      left: `${CssProp.B.length}|auto`,
      loose_quotable_words: `(${CssProp.B.ident})+`,
      margin_width: `${CssProp.B.len_or_perc}|auto`,
      padding_width: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}`,
      page_url: CssProp.B.url,
      position: `((${CssProp.B.len_or_perc}|left|center|right|top|bottom)\\s*){1,4}`,
      right: `${CssProp.B.length}|auto`,
      shadow: "",
      size: `closest-side|farthest-side|closest-corner|farthest-corner|${CssProp.B.length}|(${CssProp.B.len_or_perc})\\s+(${CssProp.B.len_or_perc})`,
      top: `${CssProp.B.length}|auto`
    };
    CssProp._C1 = {
      image_list: `image\\(\\s*(${CssProp.B.url})*\\s*(${CssProp.B.url}|${CssProp._C.color})\\s*\\)`,
      linear_color_stop: `(${CssProp._C.color})(\\s*${CssProp._C.color_stop_length})?`,
      shadow: `((${CssProp._C.color})\\s+((${CssProp.B.length})\\s*){2,4}(s+inset)?)|((inset\\s+)?((${CssProp.B.length})\\s*){2,4}\\s*(${CssProp._C.color})?)`
    };
    CssProp._C2 = {
      color_stop_list: `((${CssProp._C1.linear_color_stop})(\\s*(${CssProp._C.linear_color_hint}))?\\s*,\\s*)+(${CssProp._C1.linear_color_stop})`,
      shape: `rect\\(\\s*(${CssProp._C.top})\\s*,\\s*(${CssProp._C.right})\\s*,\\s*(${CssProp._C.bottom})\\s*,\\s*(${CssProp._C.left})\\s*\\)`
    };
    CssProp._C3 = {
      linear_gradient: `linear-gradient\\((((${CssProp.B.angle})|to\\s+(${CssProp.A.side_or_corner}))\\s*,\\s*)?\\s*(${CssProp._C2.color_stop_list})\\s*\\)`,
      radial_gradient: `radial-gradient\\(((((${CssProp.A.ending_shape})|(${CssProp._C.size}))\\s*)*\\s*(at\\s+${CssProp._C.position})?\\s*,\\s*)?\\s*(${CssProp._C2.color_stop_list})\\s*\\)`
    };
    CssProp._C4 = {
      image: `${CssProp.B.url}|${CssProp._C3.linear_gradient}|${CssProp._C3.radial_gradient}|${CssProp._C1.image_list}`,
      bg_image: `(${CssProp.B.url}|${CssProp._C3.linear_gradient}|${CssProp._C3.radial_gradient}|${CssProp._C1.image_list})|none`
    };
    CssProp.C = {
      ...CssProp._C,
      ...CssProp._C1,
      ...CssProp._C2,
      ...CssProp._C3,
      ...CssProp._C4
    };
    CssProp.AP = {
      border_collapse: `collapse|separate`,
      box: `normal|none|contents`,
      box_sizing: `content-box|padding-box|border-box`,
      caption_side: `top|bottom`,
      clear: `none|left|right|both`,
      direction: `ltr|rtl`,
      empty_cells: `show|hide`,
      float: `left|right|none`,
      font_stretch: `normal|wider|narrower|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded`,
      font_style: `normal|italic|oblique`,
      font_variant: `normal|small-caps`,
      font_weight: `normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900`,
      list_style_position: `inside|outside`,
      list_style_type: `disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman|lower-greek|lower-latin|upper-latin|armenian|georgian|lower-alpha|upper-alpha|none`,
      overflow: `visible|hidden|scroll|auto`,
      overflow_wrap: `normal|break-word`,
      overflow_x: `visible|hidden|scroll|auto|no-display|no-content`,
      page_break_after: `auto|always|avoid|left|right`,
      page_break_before: `auto|always|avoid|left|right`,
      page_break_inside: `avoid|auto`,
      position: `static|relative|absolute`,
      resize: `none|both|horizontal|vertical`,
      speak: `normal|none|spell-out`,
      speak_header: `once|always`,
      speak_numeral: `digits|continuous`,
      speak_punctuation: `code|none`,
      table_layout: `auto|fixed`,
      text_align: `left|right|center|justify`,
      text_decoration: `none|((underline|overline|line-through|blink)\\s*)+`,
      text_transform: `capitalize|uppercase|lowercase|none`,
      text_wrap: `normal|unrestricted|none|suppress`,
      unicode_bidi: `normal|embed|bidi-override`,
      visibility: `visible|hidden|collapse`,
      white_space: `normal|pre|nowrap|pre-wrap|pre-line`,
      word_break: `normal|keep-all|break-all`
    };
    CssProp._CP = {
      background_attachment: `${CssProp.A.attachment}(,\\s*${CssProp.A.attachment})*`,
      background_color: CssProp.C.color,
      background_origin: `${CssProp.A.box}(,\\s*${CssProp.A.box})*`,
      background_repeat: `${CssProp.A.repeat_style}(,\\s*${CssProp.A.repeat_style})*`,
      border: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
      border_radius: `((${CssProp.B.len_or_perc})\\s*){1,4}(\\/\\s*((${CssProp.B.len_or_perc})\\s*){1,4})?`,
      border_spacing: `${CssProp.B.length}\\s*(${CssProp.B.length})?`,
      border_top_color: CssProp.C.color,
      border_top_style: CssProp.A.border_style,
      border_width: `((${CssProp.C.border_width})\\s*){1,4}`,
      color: CssProp.C.color,
      cursor: `(${CssProp.B.url}(\\s*,\\s*)?)*(auto|crosshair|default|pointer|move|e-resize|ne-resize|nw-resize|n-resize|se-resize|sw-resize|s-resize|w-resize|text|wait|help|progress|all-scroll|col-resize|hand|no-drop|not-allowed|row-resize|vertical-text)`,
      display: `inline|block|list-item|run-in|inline-list-item|inline-block|table|inline-table|table-cell|table-caption|flex|inline-flex|grid|inline-grid|${CssProp.A.display_inside}|${CssProp.A.display_outside}|inherit|inline-box|inline-stack`,
      display_outside: CssProp.A.display_outside,
      elevation: `${CssProp.B.angle}|below|level|above|higher|lower`,
      font_family: `(${CssProp.C.family_name}|${CssProp.A.generic_family})(,\\s*(${CssProp.C.family_name}|${CssProp.A.generic_family}))*`,
      height: `${CssProp.B.length}|${CssProp.B.percentage}|auto`,
      letter_spacing: `normal|${CssProp.B.length}`,
      list_style_image: `${CssProp.C.image}|none`,
      margin_right: CssProp.C.margin_width,
      max_height: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|none|auto`,
      min_height: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|auto`,
      opacity: CssProp.C.alphavalue,
      outline_color: `${CssProp.C.color}|invert`,
      outline_width: CssProp.C.border_width,
      padding: `((${CssProp.C.padding_width})\\s*){1,4}`,
      padding_top: CssProp.C.padding_width,
      pitch_range: CssProp.N.number,
      right: `${CssProp.B.length}|${CssProp.B.percentage}|auto`,
      stress: CssProp.N.number,
      text_indent: `${CssProp.B.length}|${CssProp.B.percentage}`,
      text_shadow: `none|${CssProp.C.shadow}(,\\s*(${CssProp.C.shadow}))*`,
      volume: `${CssProp.N.number_pos}|${CssProp.B.percentage_pos}|silent|x-soft|soft|medium|loud|x-loud`,
      word_wrap: CssProp.AP.overflow_wrap,
      zoom: `normal|${CssProp.N.number_pos}|${CssProp.B.percentage_pos}`,
      backface_visibility: CssProp.AP.visibility,
      background_clip: `${CssProp.A.box}(,\\s*(${CssProp.A.box}))*`,
      background_position: `${CssProp.C.bg_position}(,\\s*(${CssProp.C.bg_position}))*`,
      border_bottom_color: CssProp.C.color,
      border_bottom_style: CssProp.A.border_style,
      border_color: `((${CssProp.C.color})\\s*){1,4}`,
      border_left_color: CssProp.C.color,
      border_right_color: CssProp.C.color,
      border_style: `((${CssProp.A.border_style})\\s*){1,4}`,
      border_top_left_radius: `(${CssProp.B.length}|${CssProp.B.percentage})(\\s*(${CssProp.B.length}|${CssProp.B.percentage}))?`,
      border_top_width: CssProp.C.border_width,
      box_shadow: `none|${CssProp.C.shadow}(,\\s*(${CssProp.C.shadow}))*`,
      clip: `${CssProp.C.shape}|auto`,
      display_inside: CssProp.A.display_inside,
      font_size: `${CssProp.A.absolute_size}|${CssProp.A.relative_size}|${CssProp.B.length_pos}|${CssProp.B.percentage_pos}`,
      line_height: `normal|${CssProp.N.number_pos}|${CssProp.B.length_pos}|${CssProp.B.percentage_pos}`,
      margin_left: CssProp.C.margin_width,
      max_width: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|none|auto`,
      outline_style: CssProp.A.border_style,
      padding_bottom: CssProp.C.padding_width,
      padding_right: CssProp.C.padding_width,
      perspective: `none|${CssProp.B.length}`,
      richness: CssProp.N.number,
      text_overflow: `((clip|ellipsis|${CssProp.B.string})\\s*){1,2}`,
      top: `${CssProp.B.length}|${CssProp.B.percentage}|auto`,
      width: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|auto`,
      z_index: `auto|${CssProp.B.z_index}`,
      // Simplified background
      background: `(((${CssProp.C.bg_position}\\s*(\\/\\s*${CssProp.C.bg_size})?)|(${CssProp.A.repeat_style})|(${CssProp.A.attachment})|(${CssProp.A.bg_origin})|(${CssProp.C.bg_image})|(${CssProp.C.color}))\\s*)+`,
      background_size: `${CssProp.C.bg_size}(,\\s*${CssProp.C.bg_size})*`,
      border_bottom_left_radius: `(${CssProp.B.length}|${CssProp.B.percentage})(\\s*(${CssProp.B.length}|${CssProp.B.percentage}))?`,
      border_bottom_width: CssProp.C.border_width,
      border_left_style: CssProp.A.border_style,
      border_right_style: CssProp.A.border_style,
      border_top: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
      bottom: `${CssProp.B.len_or_perc}|auto`,
      list_style: `((${CssProp.AP.list_style_type}|${CssProp.AP.list_style_position}|${CssProp.C.image}|none})\\s*){1,3}`,
      margin_top: CssProp.C.margin_width,
      outline: `((${CssProp.C.color}|invert|${CssProp.A.border_style}|${CssProp.C.border_width})\\s*){1,3}`,
      overflow_y: CssProp.AP.overflow_x,
      pitch: `${CssProp.B.frequency}|x-low|low|medium|high|x-high`,
      vertical_align: `baseline|sub|super|top|text-top|middle|bottom|text-bottom|${CssProp.B.len_or_perc}`,
      word_spacing: `normal|${CssProp.B.length}`,
      background_image: `${CssProp.C.bg_image}(,\\s*${CssProp.C.bg_image})*`,
      border_bottom_right_radius: `(${CssProp.B.length}|${CssProp.B.percentage})(\\s*(${CssProp.B.length}|${CssProp.B.percentage}))?`,
      border_left_width: CssProp.C.border_width,
      border_right_width: CssProp.C.border_width,
      left: `${CssProp.B.len_or_perc}|auto`,
      margin_bottom: CssProp.C.margin_width,
      pause_after: `${CssProp.B.time}|${CssProp.B.percentage}`,
      speech_rate: `${CssProp.N.number}|x-slow|slow|medium|fast|x-fast|faster|slower`,
      transition_duration: `${CssProp.B.time}(,\\s*${CssProp.B.time})*`,
      border_bottom: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
      border_right: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
      margin: `((${CssProp.C.margin_width})\\s*){1,4}`,
      padding_left: CssProp.C.padding_width,
      border_left: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
      quotes: `(${CssProp.B.string}\\s*${CssProp.B.string})+|none`,
      border_top_right_radius: `(${CssProp.B.length}|${CssProp.B.percentage})(\\s*(${CssProp.B.length}|${CssProp.B.percentage}))?`,
      min_width: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|auto`
    };
    CssProp._CP1 = {
      font: `(((((${CssProp.AP.font_style}|${CssProp.AP.font_variant}|${CssProp.AP.font_weight})\\s*){1,3})?\\s*(${CssProp._CP.font_size})\\s*(\\/\\s*(${CssProp._CP.line_height}))?\\s+(${CssProp._CP.font_family}))|caption|icon|menu|message-box|small-caption|status-bar)`
    };
    CssProp.CP = { ...CssProp._CP, ...CssProp._CP1 };
    CssProp.BORDER_COLLAPSE = CssProp.reg(CssProp.AP.border_collapse);
    CssProp.BOX = CssProp.reg(CssProp.AP.box);
    CssProp.BOX_SIZING = CssProp.reg(CssProp.AP.box_sizing);
    CssProp.CAPTION_SIDE = CssProp.reg(CssProp.AP.caption_side);
    CssProp.CLEAR = CssProp.reg(CssProp.AP.clear);
    CssProp.DIRECTION = CssProp.reg(CssProp.AP.direction);
    CssProp.EMPTY_CELLS = CssProp.reg(CssProp.AP.empty_cells);
    CssProp.FLOAT = CssProp.reg(CssProp.AP.float);
    CssProp.FONT_STRETCH = CssProp.reg(CssProp.AP.font_stretch);
    CssProp.FONT_STYLE = CssProp.reg(CssProp.AP.font_style);
    CssProp.FONT_VARIANT = CssProp.reg(CssProp.AP.font_variant);
    CssProp.FONT_WEIGHT = CssProp.reg(CssProp.AP.font_weight);
    CssProp.LIST_STYLE_POSITION = CssProp.reg(CssProp.AP.list_style_position);
    CssProp.LIST_STYLE_TYPE = CssProp.reg(CssProp.AP.list_style_type);
    CssProp.OVERFLOW = CssProp.reg(CssProp.AP.overflow);
    CssProp.OVERFLOW_WRAP = CssProp.reg(CssProp.AP.overflow_wrap);
    CssProp.OVERFLOW_X = CssProp.reg(CssProp.AP.overflow_x);
    CssProp.PAGE_BREAK_AFTER = CssProp.reg(CssProp.AP.page_break_after);
    CssProp.PAGE_BREAK_BEFORE = CssProp.reg(CssProp.AP.page_break_before);
    CssProp.PAGE_BREAK_INSIDE = CssProp.reg(CssProp.AP.page_break_inside);
    CssProp.POSITION = CssProp.reg(CssProp.AP.position);
    CssProp.RESIZE = CssProp.reg(CssProp.AP.resize);
    CssProp.SPEAK = CssProp.reg(CssProp.AP.speak);
    CssProp.SPEAK_HEADER = CssProp.reg(CssProp.AP.speak_header);
    CssProp.SPEAK_NUMERAL = CssProp.reg(CssProp.AP.speak_numeral);
    CssProp.SPEAK_PUNCTUATION = CssProp.reg(CssProp.AP.speak_punctuation);
    CssProp.TABLE_LAYOUT = CssProp.reg(CssProp.AP.table_layout);
    CssProp.TEXT_ALIGN = CssProp.reg(CssProp.AP.text_align);
    CssProp.TEXT_DECORATION = CssProp.reg(CssProp.AP.text_decoration);
    CssProp.TEXT_TRANSFORM = CssProp.reg(CssProp.AP.text_transform);
    CssProp.TEXT_WRAP = CssProp.reg(CssProp.AP.text_wrap);
    CssProp.UNICODE_BIDI = CssProp.reg(CssProp.AP.unicode_bidi);
    CssProp.VISIBILITY = CssProp.reg(CssProp.AP.visibility);
    CssProp.WHITE_SPACE = CssProp.reg(CssProp.AP.white_space);
    CssProp.WORD_BREAK = CssProp.reg(CssProp.AP.word_break);
    CssProp.BACKGROUND_ATTACHMENT = CssProp.reg(CssProp.CP.background_attachment);
    CssProp.BACKGROUND_COLOR = CssProp.reg(CssProp.CP.background_color);
    CssProp.BACKGROUND_ORIGIN = CssProp.reg(CssProp.CP.background_origin);
    CssProp.BACKGROUND_REPEAT = CssProp.reg(CssProp.CP.background_repeat);
    CssProp.BORDER = CssProp.reg(CssProp.CP.border);
    CssProp.BORDER_RADIUS = CssProp.reg(CssProp.CP.border_radius);
    CssProp.BORDER_SPACING = CssProp.reg(CssProp.CP.border_spacing);
    CssProp.BORDER_TOP_COLOR = CssProp.reg(CssProp.CP.border_top_color);
    CssProp.BORDER_TOP_STYLE = CssProp.reg(CssProp.CP.border_top_style);
    CssProp.BORDER_WIDTH = CssProp.reg(CssProp.CP.border_width);
    CssProp.COLOR = CssProp.reg(CssProp.CP.color);
    CssProp.CURSOR = CssProp.reg(CssProp.CP.cursor);
    CssProp.DISPLAY = CssProp.reg(CssProp.CP.display);
    CssProp.DISPLAY_OUTSIDE = CssProp.reg(CssProp.CP.display_outside);
    CssProp.ELEVATION = CssProp.reg(CssProp.CP.elevation);
    CssProp.FONT_FAMILY = CssProp.reg(CssProp.CP.font_family);
    CssProp.HEIGHT = CssProp.reg(CssProp.CP.height);
    CssProp.LETTER_SPACING = CssProp.reg(CssProp.CP.letter_spacing);
    CssProp.LIST_STYLE_IMAGE = CssProp.reg(CssProp.CP.list_style_image);
    CssProp.MARGIN_RIGHT = CssProp.reg(CssProp.CP.margin_right);
    CssProp.MAX_HEIGHT = CssProp.reg(CssProp.CP.max_height);
    CssProp.MIN_HEIGHT = CssProp.reg(CssProp.CP.min_height);
    CssProp.OPACITY = CssProp.reg(CssProp.CP.opacity);
    CssProp.OUTLINE_COLOR = CssProp.reg(CssProp.CP.outline_color);
    CssProp.OUTLINE_WIDTH = CssProp.reg(CssProp.CP.outline_width);
    CssProp.PADDING = CssProp.reg(CssProp.CP.padding);
    CssProp.PADDING_TOP = CssProp.reg(CssProp.CP.padding_top);
    CssProp.PITCH_RANGE = CssProp.reg(CssProp.CP.pitch_range);
    CssProp.RIGHT = CssProp.reg(CssProp.CP.right);
    CssProp.STRESS = CssProp.reg(CssProp.CP.stress);
    CssProp.TEXT_INDENT = CssProp.reg(CssProp.CP.text_indent);
    CssProp.TEXT_SHADOW = CssProp.reg(CssProp.CP.text_shadow);
    CssProp.VOLUME = CssProp.reg(CssProp.CP.volume);
    CssProp.WORD_WRAP = CssProp.reg(CssProp.CP.word_wrap);
    CssProp.ZOOM = CssProp.reg(CssProp.CP.zoom);
    CssProp.BACKFACE_VISIBILITY = CssProp.reg(CssProp.CP.backface_visibility);
    CssProp.BACKGROUND_CLIP = CssProp.reg(CssProp.CP.background_clip);
    CssProp.BACKGROUND_POSITION = CssProp.reg(CssProp.CP.background_position);
    CssProp.BORDER_BOTTOM_COLOR = CssProp.reg(CssProp.CP.border_bottom_color);
    CssProp.BORDER_BOTTOM_STYLE = CssProp.reg(CssProp.CP.border_bottom_style);
    CssProp.BORDER_COLOR = CssProp.reg(CssProp.CP.border_color);
    CssProp.BORDER_LEFT_COLOR = CssProp.reg(CssProp.CP.border_left_color);
    CssProp.BORDER_RIGHT_COLOR = CssProp.reg(CssProp.CP.border_right_color);
    CssProp.BORDER_STYLE = CssProp.reg(CssProp.CP.border_style);
    CssProp.BORDER_TOP_LEFT_RADIUS = CssProp.reg(CssProp.CP.border_top_left_radius);
    CssProp.BORDER_TOP_WIDTH = CssProp.reg(CssProp.CP.border_top_width);
    CssProp.BOX_SHADOW = CssProp.reg(CssProp.CP.box_shadow);
    CssProp.CLIP = CssProp.reg(CssProp.CP.clip);
    CssProp.DISPLAY_INSIDE = CssProp.reg(CssProp.CP.display_inside);
    CssProp.FONT_SIZE = CssProp.reg(CssProp.CP.font_size);
    CssProp.LINE_HEIGHT = CssProp.reg(CssProp.CP.line_height);
    CssProp.MARGIN_LEFT = CssProp.reg(CssProp.CP.margin_left);
    CssProp.MAX_WIDTH = CssProp.reg(CssProp.CP.max_width);
    CssProp.OUTLINE_STYLE = CssProp.reg(CssProp.CP.outline_style);
    CssProp.PADDING_BOTTOM = CssProp.reg(CssProp.CP.padding_bottom);
    CssProp.PADDING_RIGHT = CssProp.reg(CssProp.CP.padding_right);
    CssProp.PERSPECTIVE = CssProp.reg(CssProp.CP.perspective);
    CssProp.RICHNESS = CssProp.reg(CssProp.CP.richness);
    CssProp.TEXT_OVERFLOW = CssProp.reg(CssProp.CP.text_overflow);
    CssProp.TOP = CssProp.reg(CssProp.CP.top);
    CssProp.WIDTH = CssProp.reg(CssProp.CP.width);
    CssProp.Z_INDEX = CssProp.reg(CssProp.CP.z_index);
    CssProp.BACKGROUND = CssProp.reg(CssProp.CP.background);
    CssProp.BACKGROUND_SIZE = CssProp.reg(CssProp.CP.background_size);
    CssProp.BORDER_BOTTOM_LEFT_RADIUS = CssProp.reg(CssProp.CP.border_bottom_left_radius);
    CssProp.BORDER_BOTTOM_WIDTH = CssProp.reg(CssProp.CP.border_bottom_width);
    CssProp.BORDER_LEFT_STYLE = CssProp.reg(CssProp.CP.border_left_style);
    CssProp.BORDER_RIGHT_STYLE = CssProp.reg(CssProp.CP.border_right_style);
    CssProp.BORDER_TOP = CssProp.reg(CssProp.CP.border_top);
    CssProp.BOTTOM = CssProp.reg(CssProp.CP.bottom);
    CssProp.LIST_STYLE = CssProp.reg(CssProp.CP.list_style);
    CssProp.MARGIN_TOP = CssProp.reg(CssProp.CP.margin_top);
    CssProp.OUTLINE = CssProp.reg(CssProp.CP.outline);
    CssProp.OVERFLOW_Y = CssProp.reg(CssProp.CP.overflow_y);
    CssProp.PITCH = CssProp.reg(CssProp.CP.pitch);
    CssProp.VERTICAL_ALIGN = CssProp.reg(CssProp.CP.vertical_align);
    CssProp.WORD_SPACING = CssProp.reg(CssProp.CP.word_spacing);
    CssProp.BACKGROUND_IMAGE = CssProp.reg(CssProp.CP.background_image);
    CssProp.BORDER_BOTTOM_RIGHT_RADIUS = CssProp.reg(CssProp.CP.border_bottom_right_radius);
    CssProp.BORDER_LEFT_WIDTH = CssProp.reg(CssProp.CP.border_left_width);
    CssProp.BORDER_RIGHT_WIDTH = CssProp.reg(CssProp.CP.border_right_width);
    CssProp.LEFT = CssProp.reg(CssProp.CP.left);
    CssProp.MARGIN_BOTTOM = CssProp.reg(CssProp.CP.margin_bottom);
    CssProp.PAUSE_AFTER = CssProp.reg(CssProp.CP.pause_after);
    CssProp.SPEECH_RATE = CssProp.reg(CssProp.CP.speech_rate);
    CssProp.TRANSITION_DURATION = CssProp.reg(CssProp.CP.transition_duration);
    CssProp.BORDER_BOTTOM = CssProp.reg(CssProp.CP.border_bottom);
    CssProp.BORDER_RIGHT = CssProp.reg(CssProp.CP.border_right);
    CssProp.MARGIN = CssProp.reg(CssProp.CP.margin);
    CssProp.PADDING_LEFT = CssProp.reg(CssProp.CP.padding_left);
    CssProp.BORDER_LEFT = CssProp.reg(CssProp.CP.border_left);
    CssProp.FONT = CssProp.reg(CssProp.CP.font);
    CssProp.QUOTES = CssProp.reg(CssProp.CP.quotes);
    CssProp.BORDER_TOP_RIGHT_RADIUS = CssProp.reg(CssProp.CP.border_top_right_radius);
    CssProp.MIN_WIDTH = CssProp.reg(CssProp.CP.min_width);
    Sanitizer = class {
      constructor() {
        this._autolink = true;
        this._options = {
          // HTML tags that are allowed to be used. Tags were extracted from Google Caja
          allowedTags: [
            "a",
            "abbr",
            "acronym",
            "address",
            "area",
            "article",
            "aside",
            "audio",
            "b",
            "bdi",
            "bdo",
            "big",
            "blockquote",
            "br",
            "button",
            "canvas",
            "caption",
            "center",
            "cite",
            "code",
            "col",
            "colgroup",
            "colspan",
            "command",
            "data",
            "datalist",
            "dd",
            "del",
            "details",
            "dfn",
            "dir",
            "div",
            "dl",
            "dt",
            "em",
            "fieldset",
            "figcaption",
            "figure",
            "font",
            "footer",
            "form",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "header",
            "hgroup",
            "hr",
            "i",
            // 'iframe' is allowed by Google Caja, but disallowed by default by sanitize-html
            // , 'iframe'
            "img",
            "input",
            "ins",
            "kbd",
            "label",
            "legend",
            "li",
            "map",
            "mark",
            "menu",
            "meter",
            "nav",
            "nobr",
            "ol",
            "optgroup",
            "option",
            "output",
            "p",
            "pre",
            "progress",
            "q",
            "rowspan",
            "s",
            "samp",
            "section",
            "select",
            "small",
            "source",
            "span",
            "strike",
            "strong",
            "sub",
            "summary",
            "sup",
            "table",
            "tbody",
            "td",
            "textarea",
            "tfoot",
            "th",
            "thead",
            "time",
            "tr",
            "track",
            "tt",
            "u",
            "ul",
            "var",
            "video",
            "wbr"
          ],
          // Attributes that HTML tags are allowed to have, extracted from Google Caja.
          // See https://github.com/jupyterlab/jupyterlab/issues/1812#issuecomment-285848435
          allowedAttributes: {
            "*": [
              "class",
              "dir",
              "draggable",
              "hidden",
              "id",
              "inert",
              "itemprop",
              "itemref",
              "itemscope",
              "lang",
              "spellcheck",
              "style",
              "title",
              "translate"
            ],
            // 'rel' and 'target' were *not* allowed by Google Caja
            a: [
              "accesskey",
              "coords",
              "href",
              "hreflang",
              "name",
              "rel",
              "shape",
              "tabindex",
              "target",
              "type"
            ],
            area: [
              "accesskey",
              "alt",
              "coords",
              "href",
              "nohref",
              "shape",
              "tabindex"
            ],
            // 'autoplay' was *not* allowed by Google Caja
            audio: [
              "autoplay",
              "controls",
              "loop",
              "mediagroup",
              "muted",
              "preload",
              "src"
            ],
            bdo: ["dir"],
            blockquote: ["cite"],
            br: ["clear"],
            button: [
              "accesskey",
              "data-commandlinker-args",
              "data-commandlinker-command",
              "disabled",
              "name",
              "tabindex",
              "type",
              "value"
            ],
            canvas: ["height", "width"],
            caption: ["align"],
            col: ["align", "char", "charoff", "span", "valign", "width"],
            colgroup: ["align", "char", "charoff", "span", "valign", "width"],
            command: [
              "checked",
              "command",
              "disabled",
              "icon",
              "label",
              "radiogroup",
              "type"
            ],
            data: ["value"],
            del: ["cite", "datetime"],
            details: ["open"],
            dir: ["compact"],
            div: ["align"],
            dl: ["compact"],
            fieldset: ["disabled"],
            font: ["color", "face", "size"],
            form: [
              "accept",
              "autocomplete",
              "enctype",
              "method",
              "name",
              "novalidate"
            ],
            h1: ["align"],
            h2: ["align"],
            h3: ["align"],
            h4: ["align"],
            h5: ["align"],
            h6: ["align"],
            hr: ["align", "noshade", "size", "width"],
            iframe: [
              "align",
              "frameborder",
              "height",
              "marginheight",
              "marginwidth",
              "width"
            ],
            img: [
              "align",
              "alt",
              "border",
              "height",
              "hspace",
              "ismap",
              "name",
              "src",
              "usemap",
              "vspace",
              "width"
            ],
            input: [
              "accept",
              "accesskey",
              "align",
              "alt",
              "autocomplete",
              "checked",
              "disabled",
              "inputmode",
              "ismap",
              "list",
              "max",
              "maxlength",
              "min",
              "multiple",
              "name",
              "placeholder",
              "readonly",
              "required",
              "size",
              "src",
              "step",
              "tabindex",
              "type",
              "usemap",
              "value"
            ],
            ins: ["cite", "datetime"],
            label: ["accesskey", "for"],
            legend: ["accesskey", "align"],
            li: ["type", "value"],
            map: ["name"],
            menu: ["compact", "label", "type"],
            meter: ["high", "low", "max", "min", "value"],
            ol: ["compact", "reversed", "start", "type"],
            optgroup: ["disabled", "label"],
            option: ["disabled", "label", "selected", "value"],
            output: ["for", "name"],
            p: ["align"],
            pre: ["width"],
            progress: ["max", "min", "value"],
            q: ["cite"],
            select: [
              "autocomplete",
              "disabled",
              "multiple",
              "name",
              "required",
              "size",
              "tabindex"
            ],
            source: ["type"],
            table: [
              "align",
              "bgcolor",
              "border",
              "cellpadding",
              "cellspacing",
              "frame",
              "rules",
              "summary",
              "width"
            ],
            tbody: ["align", "char", "charoff", "valign"],
            td: [
              "abbr",
              "align",
              "axis",
              "bgcolor",
              "char",
              "charoff",
              "colspan",
              "headers",
              "height",
              "nowrap",
              "rowspan",
              "scope",
              "valign",
              "width"
            ],
            textarea: [
              "accesskey",
              "autocomplete",
              "cols",
              "disabled",
              "inputmode",
              "name",
              "placeholder",
              "readonly",
              "required",
              "rows",
              "tabindex",
              "wrap"
            ],
            tfoot: ["align", "char", "charoff", "valign"],
            th: [
              "abbr",
              "align",
              "axis",
              "bgcolor",
              "char",
              "charoff",
              "colspan",
              "headers",
              "height",
              "nowrap",
              "rowspan",
              "scope",
              "valign",
              "width"
            ],
            thead: ["align", "char", "charoff", "valign"],
            tr: ["align", "bgcolor", "char", "charoff", "valign"],
            track: ["default", "kind", "label", "srclang"],
            ul: ["compact", "type"],
            video: [
              "autoplay",
              "controls",
              "height",
              "loop",
              "mediagroup",
              "muted",
              "poster",
              "preload",
              "src",
              "width"
            ]
          },
          // Inline CSS styles that HTML tags may have (and their allowed values)
          allowedStyles: {
            // To simplify the data, all styles are allowed on all tags that allow the style attribute
            "*": {
              "backface-visibility": [CssProp.BACKFACE_VISIBILITY],
              background: [CssProp.BACKGROUND],
              "background-attachment": [CssProp.BACKGROUND_ATTACHMENT],
              "background-clip": [CssProp.BACKGROUND_CLIP],
              "background-color": [CssProp.BACKGROUND_COLOR],
              "background-image": [CssProp.BACKGROUND_IMAGE],
              "background-origin": [CssProp.BACKGROUND_ORIGIN],
              "background-position": [CssProp.BACKGROUND_POSITION],
              "background-repeat": [CssProp.BACKGROUND_REPEAT],
              "background-size": [CssProp.BACKGROUND_SIZE],
              border: [CssProp.BORDER],
              "border-bottom": [CssProp.BORDER_BOTTOM],
              "border-bottom-color": [CssProp.BORDER_BOTTOM_COLOR],
              "border-bottom-left-radius": [CssProp.BORDER_BOTTOM_LEFT_RADIUS],
              "border-bottom-right-radius": [CssProp.BORDER_BOTTOM_RIGHT_RADIUS],
              "border-bottom-style": [CssProp.BORDER_BOTTOM_STYLE],
              "border-bottom-width": [CssProp.BORDER_BOTTOM_WIDTH],
              "border-collapse": [CssProp.BORDER_COLLAPSE],
              "border-color": [CssProp.BORDER_COLOR],
              "border-left": [CssProp.BORDER_LEFT],
              "border-left-color": [CssProp.BORDER_LEFT_COLOR],
              "border-left-style": [CssProp.BORDER_LEFT_STYLE],
              "border-left-width": [CssProp.BORDER_LEFT_WIDTH],
              "border-radius": [CssProp.BORDER_RADIUS],
              "border-right": [CssProp.BORDER_RIGHT],
              "border-right-color": [CssProp.BORDER_RIGHT_COLOR],
              "border-right-style": [CssProp.BORDER_RIGHT_STYLE],
              "border-right-width": [CssProp.BORDER_RIGHT_WIDTH],
              "border-spacing": [CssProp.BORDER_SPACING],
              "border-style": [CssProp.BORDER_STYLE],
              "border-top": [CssProp.BORDER_TOP],
              "border-top-color": [CssProp.BORDER_TOP_COLOR],
              "border-top-left-radius": [CssProp.BORDER_TOP_LEFT_RADIUS],
              "border-top-right-radius": [CssProp.BORDER_TOP_RIGHT_RADIUS],
              "border-top-style": [CssProp.BORDER_TOP_STYLE],
              "border-top-width": [CssProp.BORDER_TOP_WIDTH],
              "border-width": [CssProp.BORDER_WIDTH],
              bottom: [CssProp.BOTTOM],
              box: [CssProp.BOX],
              "box-shadow": [CssProp.BOX_SHADOW],
              "box-sizing": [CssProp.BOX_SIZING],
              "caption-side": [CssProp.CAPTION_SIDE],
              clear: [CssProp.CLEAR],
              clip: [CssProp.CLIP],
              color: [CssProp.COLOR],
              cursor: [CssProp.CURSOR],
              direction: [CssProp.DIRECTION],
              display: [CssProp.DISPLAY],
              "display-inside": [CssProp.DISPLAY_INSIDE],
              "display-outside": [CssProp.DISPLAY_OUTSIDE],
              elevation: [CssProp.ELEVATION],
              "empty-cells": [CssProp.EMPTY_CELLS],
              float: [CssProp.FLOAT],
              font: [CssProp.FONT],
              "font-family": [CssProp.FONT_FAMILY],
              "font-size": [CssProp.FONT_SIZE],
              "font-stretch": [CssProp.FONT_STRETCH],
              "font-style": [CssProp.FONT_STYLE],
              "font-variant": [CssProp.FONT_VARIANT],
              "font-weight": [CssProp.FONT_WEIGHT],
              height: [CssProp.HEIGHT],
              left: [CssProp.LEFT],
              "letter-spacing": [CssProp.LETTER_SPACING],
              "line-height": [CssProp.LINE_HEIGHT],
              "list-style": [CssProp.LIST_STYLE],
              "list-style-image": [CssProp.LIST_STYLE_IMAGE],
              "list-style-position": [CssProp.LIST_STYLE_POSITION],
              "list-style-type": [CssProp.LIST_STYLE_TYPE],
              margin: [CssProp.MARGIN],
              "margin-bottom": [CssProp.MARGIN_BOTTOM],
              "margin-left": [CssProp.MARGIN_LEFT],
              "margin-right": [CssProp.MARGIN_RIGHT],
              "margin-top": [CssProp.MARGIN_TOP],
              "max-height": [CssProp.MAX_HEIGHT],
              "max-width": [CssProp.MAX_WIDTH],
              "min-height": [CssProp.MIN_HEIGHT],
              "min-width": [CssProp.MIN_WIDTH],
              opacity: [CssProp.OPACITY],
              outline: [CssProp.OUTLINE],
              "outline-color": [CssProp.OUTLINE_COLOR],
              "outline-style": [CssProp.OUTLINE_STYLE],
              "outline-width": [CssProp.OUTLINE_WIDTH],
              overflow: [CssProp.OVERFLOW],
              "overflow-wrap": [CssProp.OVERFLOW_WRAP],
              "overflow-x": [CssProp.OVERFLOW_X],
              "overflow-y": [CssProp.OVERFLOW_Y],
              padding: [CssProp.PADDING],
              "padding-bottom": [CssProp.PADDING_BOTTOM],
              "padding-left": [CssProp.PADDING_LEFT],
              "padding-right": [CssProp.PADDING_RIGHT],
              "padding-top": [CssProp.PADDING_TOP],
              "page-break-after": [CssProp.PAGE_BREAK_AFTER],
              "page-break-before": [CssProp.PAGE_BREAK_BEFORE],
              "page-break-inside": [CssProp.PAGE_BREAK_INSIDE],
              "pause-after": [CssProp.PAUSE_AFTER],
              perspective: [CssProp.PERSPECTIVE],
              pitch: [CssProp.PITCH],
              "pitch-range": [CssProp.PITCH_RANGE],
              position: [CssProp.POSITION],
              quotes: [CssProp.QUOTES],
              resize: [CssProp.RESIZE],
              richness: [CssProp.RICHNESS],
              right: [CssProp.RIGHT],
              speak: [CssProp.SPEAK],
              "speak-header": [CssProp.SPEAK_HEADER],
              "speak-numeral": [CssProp.SPEAK_NUMERAL],
              "speak-punctuation": [CssProp.SPEAK_PUNCTUATION],
              "speech-rate": [CssProp.SPEECH_RATE],
              stress: [CssProp.STRESS],
              "table-layout": [CssProp.TABLE_LAYOUT],
              "text-align": [CssProp.TEXT_ALIGN],
              "text-decoration": [CssProp.TEXT_DECORATION],
              "text-indent": [CssProp.TEXT_INDENT],
              "text-overflow": [CssProp.TEXT_OVERFLOW],
              "text-shadow": [CssProp.TEXT_SHADOW],
              "text-transform": [CssProp.TEXT_TRANSFORM],
              "text-wrap": [CssProp.TEXT_WRAP],
              top: [CssProp.TOP],
              "unicode-bidi": [CssProp.UNICODE_BIDI],
              "vertical-align": [CssProp.VERTICAL_ALIGN],
              visibility: [CssProp.VISIBILITY],
              volume: [CssProp.VOLUME],
              "white-space": [CssProp.WHITE_SPACE],
              width: [CssProp.WIDTH],
              "word-break": [CssProp.WORD_BREAK],
              "word-spacing": [CssProp.WORD_SPACING],
              "word-wrap": [CssProp.WORD_WRAP],
              "z-index": [CssProp.Z_INDEX],
              zoom: [CssProp.ZOOM]
            }
          },
          transformTags: {
            // Set the "rel" attribute for <a> tags to "nofollow".
            a: import_sanitize_html.default.simpleTransform("a", { rel: "nofollow" }),
            // Set the "disabled" attribute for <input> tags.
            input: import_sanitize_html.default.simpleTransform("input", { disabled: "disabled" })
          },
          allowedSchemes: [...import_sanitize_html.default.defaults.allowedSchemes],
          allowedSchemesByTag: {
            // Allow 'attachment:' img src (used for markdown cell attachments).
            img: import_sanitize_html.default.defaults.allowedSchemes.concat(["attachment"])
          },
          // Override of the default option, so we can skip 'src' attribute validation.
          // 'src' Attributes are validated to be URIs, which does not allow for embedded (image) data.
          // Since embedded data is no longer deemed to be a threat, validation can be skipped.
          // See https://github.com/jupyterlab/jupyterlab/issues/5183
          allowedSchemesAppliedToAttributes: ["href", "cite"]
        };
      }
      /**
       * Sanitize an HTML string.
       *
       * @param dirty - The dirty text.
       *
       * @param options - The optional sanitization options.
       *
       * @returns The sanitized string.
       */
      sanitize(dirty, options) {
        return (0, import_sanitize_html.default)(dirty, { ...this._options, ...options || {} });
      }
      /**
       * @returns Whether to replace URLs by HTML anchors.
       */
      getAutolink() {
        return this._autolink;
      }
      /**
       * Set the allowed schemes
       *
       * @param scheme Allowed schemes
       */
      setAllowedSchemes(scheme) {
        this._options.allowedSchemes = [...scheme];
      }
      /**
       * Set the URL replacement boolean.
       *
       * @param autolink URL replacement boolean.
       */
      setAutolink(autolink) {
        this._autolink = autolink;
      }
    };
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/semanticCommand.js
var SemanticCommand;
var init_semanticCommand = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/semanticCommand.js"() {
    SemanticCommand = class {
      constructor() {
        this._commands = new Array();
      }
      /**
       * Add a command to the semantic group
       *
       * @param command Command to add
       */
      add(command) {
        if (this._commands.map((c) => c.id).includes(command.id)) {
          throw Error(`Command ${command.id} is already defined.`);
        }
        this._commands.push({
          isEnabled: () => true,
          rank: SemanticCommand.DEFAULT_RANK,
          ...command
        });
      }
      /**
       * Get the command id of the enabled command from this group
       * for the given widget.
       *
       * @param widget Widget
       * @returns Command id
       */
      getActiveCommandId(widget) {
        var _a;
        const commands = this._commands.filter((c) => c.isEnabled(widget)).sort((a, b) => {
          const rankDelta = a.rank - b.rank;
          return rankDelta || (a.id < b.id ? -1 : 1);
        });
        const command = (_a = commands[0]) !== null && _a !== void 0 ? _a : { id: null };
        return command.id;
      }
    };
    SemanticCommand.DEFAULT_RANK = 500;
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/thememanager.js
var Private34;
var init_thememanager = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/thememanager.js"() {
    init_lib();
    init_index_es65();
    init_index_es63();
    (function(Private36) {
      function fitAll(widget) {
        for (const child of widget.children()) {
          fitAll(child);
        }
        widget.fit();
      }
      Private36.fitAll = fitAll;
    })(Private34 || (Private34 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/tokens.js
var import_coreutils23, ICommandPalette, IKernelStatusModel, ISessionContextDialogs, IThemeManager, ISanitizer, ISplashScreen, IWindowResolver, IToolbarWidgetRegistry;
var init_tokens4 = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/tokens.js"() {
    import_coreutils23 = __toESM(require_dist());
    ICommandPalette = new import_coreutils23.Token("@jupyterlab/apputils:ICommandPalette", `A service for the application command palette
  in the left panel. Use this to add commands to the palette.`);
    IKernelStatusModel = new import_coreutils23.Token("@jupyterlab/apputils:IKernelStatusModel", "A service to register kernel session provider to the kernel status indicator.");
    ISessionContextDialogs = new import_coreutils23.Token("@jupyterlab/apputils:ISessionContextDialogs", "A service for handling the session dialogs.");
    IThemeManager = new import_coreutils23.Token("@jupyterlab/apputils:IThemeManager", "A service for the theme manager for the application. This is used primarily in theme extensions to register new themes.");
    ISanitizer = new import_coreutils23.Token("@jupyterlab/apputils:ISanitizer", "A service for sanitizing HTML strings.");
    ISplashScreen = new import_coreutils23.Token("@jupyterlab/apputils:ISplashScreen", `A service for the splash screen for the application.
  Use this if you want to show the splash screen for your own purposes.`);
    IWindowResolver = new import_coreutils23.Token("@jupyterlab/apputils:IWindowResolver", `A service for a window resolver for the
  application. JupyterLab workspaces are given a name, which are determined using
  the window resolver. Require this if you want to use the name of the current workspace.`);
    IToolbarWidgetRegistry = new import_coreutils23.Token("@jupyterlab/apputils:IToolbarWidgetRegistry", `A registry for toolbar widgets. Require this
  if you want to build the toolbar dynamically from a data definition (stored in settings for example).`);
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/windowresolver.js
var import_coreutils24, Private35;
var init_windowresolver = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/windowresolver.js"() {
    import_coreutils24 = __toESM(require_dist());
    (function(Private36) {
      const PREFIX = "@jupyterlab/statedb:StateDB";
      const BEACON = `${PREFIX}:beacon`;
      const TIMEOUT = Math.floor(200 + Math.random() * 300);
      const WINDOW = `${PREFIX}:window`;
      let currentBeaconRequest = null;
      let candidate = null;
      const delegate = new import_coreutils24.PromiseDelegate();
      const known = {};
      let name2 = null;
      let resolved = false;
      function initialize() {
        window.addEventListener("storage", (event) => {
          const { key: key2, newValue } = event;
          if (newValue === null) {
            return;
          }
          if (key2 === BEACON && newValue !== currentBeaconRequest && candidate !== null) {
            ping(resolved ? name2 : candidate);
            return;
          }
          if (resolved || key2 !== WINDOW) {
            return;
          }
          const reported = newValue.replace(/\-\d+$/, "");
          known[reported] = null;
          if (!candidate || candidate in known) {
            reject();
          }
        });
      }
      function ping(payload) {
        if (payload === null) {
          return;
        }
        const { localStorage } = window;
        localStorage.setItem(WINDOW, `${payload}-${(/* @__PURE__ */ new Date()).getTime()}`);
      }
      function reject() {
        resolved = true;
        currentBeaconRequest = null;
        delegate.reject(`Window name candidate "${candidate}" already exists`);
      }
      function resolve(potential) {
        if (resolved) {
          return delegate.promise;
        }
        candidate = potential;
        if (candidate in known) {
          reject();
          return delegate.promise;
        }
        const { localStorage, setTimeout: setTimeout2 } = window;
        setTimeout2(() => {
          if (resolved) {
            return;
          }
          if (!candidate || candidate in known) {
            return reject();
          }
          resolved = true;
          currentBeaconRequest = null;
          delegate.resolve(name2 = candidate);
          ping(name2);
        }, TIMEOUT);
        currentBeaconRequest = `${Math.random()}-${(/* @__PURE__ */ new Date()).getTime()}`;
        localStorage.setItem(BEACON, currentBeaconRequest);
        return delegate.promise;
      }
      Private36.resolve = resolve;
      (() => {
        initialize();
      })();
    })(Private35 || (Private35 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/index.js
var Toolbar6;
var init_lib7 = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/index.js"() {
    init_lib5();
    init_toolbar6();
    init_clipboard();
    init_commandlinker();
    init_commandpalette();
    init_dialog5();
    init_domutils();
    init_inputdialog();
    init_kernelstatuses();
    init_mainareawidget();
    init_menufactory();
    init_notification();
    init_printing();
    init_runningSessions();
    init_sanitizer();
    init_semanticCommand();
    init_sessioncontext();
    init_thememanager();
    init_tokens4();
    init_widgettracker();
    init_windowresolver();
    Toolbar6 = class extends Toolbar4 {
    };
    (function(Toolbar7) {
      Toolbar7.createInterruptButton = Toolbar5.createInterruptButton;
      Toolbar7.createKernelNameItem = Toolbar5.createKernelNameItem;
      Toolbar7.createKernelStatusItem = Toolbar5.createKernelStatusItem;
      Toolbar7.createRestartButton = Toolbar5.createRestartButton;
      Toolbar7.createSpacerItem = Toolbar4.createSpacerItem;
    })(Toolbar6 || (Toolbar6 = {}));
  }
});

export {
  require_jsx_runtime,
  _extends,
  init_extends,
  _arrayLikeToArray,
  init_arrayLikeToArray,
  _unsupportedIterableToArray,
  init_unsupportedIterableToArray,
  _typeof,
  init_typeof,
  _toPropertyKey,
  init_toPropertyKey,
  _defineProperty,
  init_defineProperty,
  __assign,
  __rest,
  __awaiter,
  __spreadArray,
  tslib_es6_exports,
  init_tslib_es62 as init_tslib_es6,
  require_dist,
  Signal,
  index_es6_exports2 as index_es6_exports,
  init_index_es63 as init_index_es6,
  require_minimist,
  require_url_parse,
  index_es6_exports3 as index_es6_exports2,
  init_index_es64 as init_index_es62,
  index_es6_exports4 as index_es6_exports3,
  init_index_es65 as init_index_es63,
  Widget,
  PanelLayout,
  Panel,
  TabBar,
  init_index_es618 as init_index_es64,
  classes,
  lineFormIcon,
  nullTranslator,
  init_lib,
  require_isEqual,
  InputGroup,
  ReactWidget,
  VDomRenderer,
  VDomModel,
  init_lib5 as init_lib2,
  WidgetTracker,
  showPopup,
  TextItem,
  init_lib6 as init_lib3,
  DOMUtils,
  Printing,
  require_lib16 as require_lib,
  require_is_plain_object,
  require_cjs,
  require_parse_srcset,
  require_postcss,
  Sanitizer,
  init_lib7 as init_lib4
};
/*! Bundled license information:

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 5.3.3
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

is-plain-object/dist/is-plain-object.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=/build/_shared/chunk-VQ44ZQQP.js.map
